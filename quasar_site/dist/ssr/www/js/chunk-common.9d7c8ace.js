"use strict";(globalThis["webpackChunkquasar_site_webpack"]=globalThis["webpackChunkquasar_site_webpack"]||[]).push([[64],{87692:(e,t,n)=>{n.d(t,{Z:()=>h});n(69665),n(40702);var r=n(95220);const a={NAMESPACE:"namespace",CLASS:"class",ENUM:"enum",EVENT:"event",INTERFACE:"interface",STRUCT:"struct"},s={};let i=null,o=null,u=null,m="",c=null,l={};const d={itemPath(e){if(e.path)return e.path;let t=null;return t=e.namespace?e.namespace+"."+e.name:e.name,t.toLowerCase()},childTree(e,t){const n=`${this.itemPath(e)}#${t.toLowerCase()}`,r="constructors"!=t.toLowerCase(),a=this.getMembers(e,t.toLowerCase(),r);if(a.length<1)return;const s=a.map((e=>({label:this.memberName(e,t.toLowerCase()),path:e.path,header:"secondary",deprecated:e.deprecated}))),i={label:t,namespace:e.namespace,parents:[this.itemPath(e)],path:n,children:s};return l[n]=i,i},getTree(){if(console.log("start tree"),i)return i;let e=null;{const t={};r.forEach((e=>{let n="";if(e.summary&&(n=e.summary),e.dataType===a.NAMESPACE)t[e.name]={label:e.name,path:this.itemPath(e),summary:n,children:[]};else{const r={label:e.name,path:this.itemPath(e),summary:n,children:[]},a=this.childTree(e,"Constructors");a&&r.children.push(a);const s=this.childTree(e,"Properties");s&&r.children.push(s);const i=this.childTree(e,"Methods");i&&r.children.push(i);const o=this.childTree(e,"Events");o&&r.children.push(o),e.inherits&&(r.inherits=e.inherits);const u=t[e.namespace];u?t[e.namespace].children.push(r):console.warn("no namespace for "+e.name)}l[this.itemPath(e)]=e})),e=[];const n=Object.keys(t).sort();n.forEach((n=>{e.push(t[n])}))}return console.log("end tree"),i=e,e},getTypeMap(){if(o)return o;const e={};return r.forEach((t=>{t.dataType!==a.NAMESPACE&&(e[t.name]=t)})),o=e,e},setSelectedItemChangedCallback(e,t){s[e]=t},findNodeByPath(e){e=e.toLowerCase();let t=null;return c&&this.itemPath(c)===e?c:(r.forEach((n=>{t||this.itemPath(n)===e&&(t=n)})),c=t,t)},setSelectedItem(e,t=!0){let n=e.dataType?this.itemPath(e):e;if(n=n.toLowerCase(),n===m)return;m=n;const r=e.dataType?e:l[n];if(r)for(const[,a]of Object.entries(s))a(r,t)},getInheritence(e){const t=[];let n=0;while(e&&e.baseclass){if(n++,n>10)break;const r=this.getTypeMap();let a=e.baseclass.lastIndexOf("."),s=e.baseclass.substring(a+1);a=s.indexOf("<"),a>0&&(s=s.substring(0,a+1)+"T>");const i=e.baseclass.toLowerCase(),o={name:e.baseclass};e=r[s],"EventArgs"===s&&(e=null),e&&(o.link=i,o.item=e),t.push(o)}return t.reverse(),t},mostRecentSince(){let e="0.0";const t=function(e,t){if(e===t)return!1;const n=e.split("."),r=t.split(".");return!(n[0]<r[0])&&!(n[0]===r[0]&&n[1]<r[1])};return r.forEach((n=>{n.constructors&&n.constructors.forEach((n=>{n.since&&t(n.since,e)&&(e=n.since)})),n.properties&&n.properties.forEach((n=>{n.since&&t(n.since,e)&&(e=n.since)})),n.methods&&n.methods.forEach((n=>{n.since&&t(n.since,e)&&(e=n.since)}))})),e},getFilteredSet(e){const t=[];return r.forEach((n=>{const r={name:n.name,dataType:n.dataType,summary:n.summary,constructors:[],methods:[],properties:[],values:[]};n.namespace&&(r.namespace=n.namespace);let a=e(n,n.constructors,r.constructors);a+=e(n,n.properties,r.properties),a+=e(n,n.methods,r.methods),n.values&&"7.0"===n.since&&(a+=e(n,n.values,r.values)),a>0&&t.push(r)})),t},getFilteredApi(e){const t=function(t,n,r){let a=0;return n&&n.forEach((n=>{n.since!==e&&t.since!==e||(r.push(n),a++)})),a};return this.getFilteredSet(t)},getReferences(e){const t=e.name,n=function(e,n,r){let a=0;return n&&n.forEach((s=>{if(s.signature.indexOf(t)>=0){let i=!1;if(e.properties===n||e.methods===n){const e=s.signature.split(" ");i=e[0]===t,i=i||"static"===e[0]&&e[1]===t}if(!i&&(e.methods===n||e.constructors===n)){const e=s.signature.indexOf("("),n=s.signature.substring(e+1,s.signature.length-1),r=n.split(",");for(let a=0;a<r.length;a++)r[a].startsWith(t)&&(i=i||r[a]===t,r[a].length>t.length&&(i=" "===r[a][t.length]))}i&&(r.push(s),a++)}})),a};return this.getFilteredSet(n)},getSearchInstance(){return u},setSearchInstance(e){u=e},getSearchList(){const e=[];return r.forEach((t=>{if("namespace"===t.dataType)return;const n=(t.namespace+"."+t.name).toLowerCase(),r=t.namespace+"."+t.name;let a={typename:r,member:t.name,type:t.dataType,url:n};t.summary&&(a.summary=t.summary),e.push(a),t.properties&&t.properties.forEach((t=>{const s=t.signature.split(" ");a={typename:r,member:s[s.length-1]},e[e.length-1].member!==a.member&&(a.type="property",a.url=n+"/"+a.member.toLowerCase(),t.summary&&(a.summary=t.summary),e.push(a))})),t.methods&&t.methods.forEach((t=>{let s=t.signature.split("(");s=s[0].split(" "),a={typename:r,member:s[s.length-1]},e[e.length-1].member!==a.member&&(a.type="method",a.url=n+"/"+a.member.toLowerCase(),t.summary&&(a.summary=t.summary),e.push(a))})),t.events&&t.events.forEach((t=>{const s=t.signature.split(" ");a={typename:r,member:s[s.length-1]},e[e.length-1].member!==a.member&&(a.type="event",a.url=n+"/"+a.member.toLowerCase(),t.summary&&(a.summary=t.summary),e.push(a))}))})),e},getMembers(e,t,n=!0){const r=this.getInheritence(e);let a=[].concat(e[t]);if(e[t])for(let s=0;s<a.length;s++){a[s].parent=e.namespace+"."+e.name,a[s].namespace=e.namespace;const n=this.memberUrl(t,a[s]);a[s].path=n,a[s].parents=[`${this.itemPath(e)}#${t}`,this.itemPath(e)],l[n]=a[s]}if(a=a.filter((e=>null!=e)),n)for(const s in r){if(!r[s].item)continue;const e=r[s].item[t];if(null!=e){for(let n=0;n<e.length;n++){e[n].parent=r[s].item.namespace+"."+r[s].item.name,e[n].namespace=r[s].item.namespace;const a=this.memberUrl(t,e[n]);e[n].path=a,l[a]=e[n]}if(a=a.concat(e),a=a.filter((e=>null!=e)),"methods"==t){const e={methods:!0};a.sort(((t,n)=>this.memberName(t,e).localeCompare(this.memberName(n,e))))}if("properties"==t){const e={properties:!0};a.sort(((t,n)=>this.memberName(t,e).localeCompare(this.memberName(n,e))))}}}return a},memberName(e,t){if("constructors"==t||"values"==t)return e.signature;if("methods"==t){const t=e.signature.match(/\S*\(.*\)/g);return t[0]}const n=e.signature.split(" ");let r=n[1];if("static"===n[0]&&"events"!=t&&(r=n[2]),!r)return"";let a=r.indexOf("(");return a>0?(a=e.signature.indexOf(r),e.signature.substring(a)):r},memberUrl(e,t){if("values"==e)return"";let n=this.memberName(t,e).toLowerCase();const r=n.indexOf("(");if(r>0&&(n=n.substring(0,r)),"constructors"==e){const e=t.namespace+"."+n+"/"+n;return e.toLowerCase()}const a=t.parent+"/"+n;return a.toLowerCase()}},h=d},48284:e=>{e.exports=JSON.parse('[{"name":"Activeviewport.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result ActiveViewport(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.Display.RhinoView view = doc.Views.ActiveView;\\n    if (view == null)\\n      return Rhino.Commands.Result.Failure;\\n\\n    Rhino.Display.RhinoPageView pageview = view as Rhino.Display.RhinoPageView;\\n    if (pageview != null)\\n    {\\n      string layout_name = pageview.PageName;\\n      if (pageview.PageIsActive)\\n      {\\n        Rhino.RhinoApp.WriteLine(\\"The layout {0} is active\\", layout_name);\\n      }\\n      else\\n      {\\n        string detail_name = pageview.ActiveViewport.Name;\\n        Rhino.RhinoApp.WriteLine(\\"The detail {0} on layout {1} is active\\", detail_name, layout_name);\\n      }\\n    }\\n    else\\n    {\\n      string viewport_name = view.MainViewport.Name;\\n      Rhino.RhinoApp.WriteLine(\\"The viewport {0} is active\\", viewport_name);\\n    }\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Display.RhinoPageView","bool PageIsActive"],["Rhino.Display.RhinoPageView","string PageName"]]},{"name":"Addbackgroundbitmap.cs","code":"using System;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddBackgroundBitmap(Rhino.RhinoDoc doc)\\n  {\\n    // Allow the user to select a bitmap file\\n    var fd = new Rhino.UI.OpenFileDialog { Filter = \\"Image Files (*.bmp;*.png;*.jpg)|*.bmp;*.png;*.jpg\\" };\\n    if (!fd.ShowOpenDialog())\\n      return Rhino.Commands.Result.Cancel;\\n\\n    // Verify the file that was selected\\n    System.Drawing.Image image;\\n    try\\n    {\\n      image = System.Drawing.Image.FromFile(fd.FileName);\\n    }\\n    catch (Exception)\\n    {\\n      return Rhino.Commands.Result.Failure;\\n    }\\n\\n    // Allow the user to pick the bitmap origin\\n    var gp = new Rhino.Input.Custom.GetPoint();\\n    gp.SetCommandPrompt(\\"Bitmap Origin\\");\\n    gp.ConstrainToConstructionPlane(true);\\n    gp.Get();\\n    if (gp.CommandResult() != Rhino.Commands.Result.Success)\\n      return gp.CommandResult();\\n\\n    // Get the view that the point was picked in.\\n    // This will be the view that the bitmap appears in.\\n    var view = gp.View();\\n    if (view == null)\\n    {\\n      view = doc.Views.ActiveView;\\n      if (view == null)\\n        return Rhino.Commands.Result.Failure;\\n    }\\n\\n    // Allow the user to specify the bitmap width in model units\\n    var gn = new Rhino.Input.Custom.GetNumber();\\n    gn.SetCommandPrompt(\\"Bitmap width\\");\\n    gn.SetLowerLimit(1.0, false);\\n    gn.Get();\\n    if (gn.CommandResult() != Rhino.Commands.Result.Success)\\n      return gn.CommandResult();\\n\\n    // Cook up some scale factors\\n    var w = gn.Number();\\n    var image_width = image.Width;\\n    var image_height = image.Height;\\n    var h = w * (image_height / image_width);\\n\\n    var plane = view.ActiveViewport.ConstructionPlane();\\n    plane.Origin = gp.Point();\\n    view.ActiveViewport.SetTraceImage(fd.FileName, plane, w, h, false, false);\\n    view.Redraw();\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Display.RhinoView","RhinoViewport ActiveViewport"],["Rhino.Display.RhinoView","void Redraw()"],["Rhino.Display.RhinoViewport","Plane ConstructionPlane()"],["Rhino.Display.RhinoViewport","bool SetTraceImage(string bitmapFileName, Plane plane, double width, double height, bool grayscale, bool filtered)"],["Rhino.UI.OpenFileDialog","OpenFileDialog()"],["Rhino.UI.OpenFileDialog","string FileName"],["Rhino.UI.OpenFileDialog","string Filter"],["Rhino.UI.OpenFileDialog","bool ShowOpenDialog()"],["Rhino.Input.Custom.GetBaseClass","Result CommandResult()"],["Rhino.Input.Custom.GetBaseClass","double Number()"],["Rhino.Input.Custom.GetBaseClass","RhinoView View()"],["Rhino.Input.Custom.GetPoint","bool ConstrainToConstructionPlane(bool throughBasePoint)"],["Rhino.Input.Custom.GetNumber","GetNumber()"],["Rhino.Input.Custom.GetNumber","GetResult Get()"],["Rhino.Input.Custom.GetNumber","void SetLowerLimit(double lowerLimit, bool strictlyGreaterThan)"],["Rhino.DocObjects.Tables.ViewTable","RhinoView ActiveView"]]},{"name":"Addbrepbox.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result AddBrepBox(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.Geometry.Point3d pt0 = new Rhino.Geometry.Point3d(0, 0, 0);\\n    Rhino.Geometry.Point3d pt1 = new Rhino.Geometry.Point3d(10, 10, 10);\\n    Rhino.Geometry.BoundingBox box = new Rhino.Geometry.BoundingBox(pt0, pt1);\\n    Rhino.Geometry.Brep brep = box.ToBrep();\\n    Rhino.Commands.Result rc = Rhino.Commands.Result.Failure;\\n    if( doc.Objects.AddBrep(brep) != System.Guid.Empty )\\n    {\\n      rc = Rhino.Commands.Result.Success;\\n      doc.Views.Redraw();\\n    }\\n    return rc;\\n  }\\n}\\n","members":[["Rhino.Geometry.BoundingBox","BoundingBox(Point3d min, Point3d max)"],["Rhino.Geometry.BoundingBox","Brep ToBrep()"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddBrep(Brep brep)"]]},{"name":"Addchildlayer.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result AddChildLayer(Rhino.RhinoDoc doc)\\n  {\\n    // Get an existing layer\\n    string default_name = doc.Layers.CurrentLayer.Name;\\n\\n    // Prompt the user to enter a layer name\\n    Rhino.Input.Custom.GetString gs = new Rhino.Input.Custom.GetString();\\n    gs.SetCommandPrompt(\\"Name of existing layer\\");\\n    gs.SetDefaultString(default_name);\\n    gs.AcceptNothing(true);\\n    gs.Get();\\n    if (gs.CommandResult() != Rhino.Commands.Result.Success)\\n      return gs.CommandResult();\\n\\n    // Was a layer named entered?\\n    string layer_name = gs.StringResult().Trim();\\n    int index = doc.Layers.Find(layer_name, true);\\n    if (index<0)\\n      return Rhino.Commands.Result.Cancel;\\n\\n    Rhino.DocObjects.Layer parent_layer = doc.Layers[index];\\n\\n    // Create a child layer\\n    string child_name = parent_layer.Name + \\"_child\\";\\n    Rhino.DocObjects.Layer childlayer = new Rhino.DocObjects.Layer();\\n    childlayer.ParentLayerId = parent_layer.Id;\\n    childlayer.Name = child_name;\\n    childlayer.Color = System.Drawing.Color.Red;\\n\\n    index = doc.Layers.Add(childlayer);\\n    if (index < 0)\\n    {\\n      Rhino.RhinoApp.WriteLine(\\"Unable to add {0} layer.\\", child_name);\\n      return Rhino.Commands.Result.Failure;\\n    }\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.DocObjects.Layer","Guid ParentLayerId"],["Rhino.DocObjects.Tables.LayerTable","int Add(Layer layer)"]]},{"name":"Addcircle.cs","code":"using System;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddCircle(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.Geometry.Point3d center = new Rhino.Geometry.Point3d(0, 0, 0);\\n    const double radius = 10.0;\\n    Rhino.Geometry.Circle c = new Rhino.Geometry.Circle(center, radius);\\n    if (doc.Objects.AddCircle(c) != Guid.Empty)\\n    {\\n      doc.Views.Redraw();\\n      return Rhino.Commands.Result.Success;\\n    }\\n    return Rhino.Commands.Result.Failure;\\n  }\\n}\\n","members":[["Rhino.Geometry.Circle","Circle(Plane plane, double radius)"],["Rhino.Geometry.Point3d","Point3d(double x, double y, double z)"],["Rhino.DocObjects.Tables.ViewTable","void Redraw()"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddCircle(Circle circle)"]]},{"name":"Addclippingplane.cs","code":"using System;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddClippingPlane(Rhino.RhinoDoc doc)\\n  {\\n    // Define the corners of the clipping plane\\n    Rhino.Geometry.Point3d[] corners;\\n    Rhino.Commands.Result rc = Rhino.Input.RhinoGet.GetRectangle(out corners);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n\\n    // Get the active view\\n    Rhino.Display.RhinoView view = doc.Views.ActiveView;\\n    if (view == null)\\n      return Rhino.Commands.Result.Failure;\\n\\n    Rhino.Geometry.Point3d p0 = corners[0];\\n    Rhino.Geometry.Point3d p1 = corners[1];\\n    Rhino.Geometry.Point3d p3 = corners[3];\\n\\n    // Create a plane from the corner points\\n    Rhino.Geometry.Plane plane = new Rhino.Geometry.Plane(p0, p1, p3);\\n\\n    // Add a clipping plane object to the document\\n    Guid id = doc.Objects.AddClippingPlane(plane, p0.DistanceTo(p1), p0.DistanceTo(p3), view.ActiveViewportID);\\n    if (id != Guid.Empty)\\n    {\\n      doc.Views.Redraw();\\n      return Rhino.Commands.Result.Success;\\n    }\\n    return Rhino.Commands.Result.Failure;\\n  }\\n}\\n","members":[["Rhino.Geometry.Plane","Plane(Point3d origin, Point3d xPoint, Point3d yPoint)"],["Rhino.FileIO.File3dmObjectTable","Guid AddClippingPlane(Plane plane, double uMagnitude, double vMagnitude, Guid clippedViewportId)"],["Rhino.Input.RhinoGet","static Result GetRectangle(out Point3d[] corners)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddClippingPlane(Plane plane, double uMagnitude, double vMagnitude, Guid clippedViewportId)"]]},{"name":"Addcylinder.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result AddCylinder(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.Geometry.Point3d center_point = new Rhino.Geometry.Point3d(0, 0, 0);\\n    Rhino.Geometry.Point3d height_point = new Rhino.Geometry.Point3d(0, 0, 10);\\n    Rhino.Geometry.Vector3d zaxis = height_point - center_point;\\n    Rhino.Geometry.Plane plane = new Rhino.Geometry.Plane(center_point, zaxis);\\n    const double radius = 5;\\n    Rhino.Geometry.Circle circle = new Rhino.Geometry.Circle(plane, radius);\\n    Rhino.Geometry.Cylinder cylinder = new Rhino.Geometry.Cylinder(circle, zaxis.Length);\\n    Rhino.Geometry.Brep brep = cylinder.ToBrep(true, true);\\n    if (brep != null)\\n    {\\n      doc.Objects.AddBrep(brep);\\n      doc.Views.Redraw();\\n    }\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Geometry.Cylinder","Cylinder(Circle baseCircle, double height)"],["Rhino.Geometry.Cylinder","Brep ToBrep(bool capBottom, bool capTop)"],["Rhino.Geometry.Plane","Plane(Point3d origin, Vector3d normal)"]]},{"name":"Addlayer.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result AddLayer(Rhino.RhinoDoc doc)\\n  {\\n    // Cook up an unused layer name\\n    string unused_name = doc.Layers.GetUnusedLayerName(false);\\n\\n    // Prompt the user to enter a layer name\\n    Rhino.Input.Custom.GetString gs = new Rhino.Input.Custom.GetString();\\n    gs.SetCommandPrompt(\\"Name of layer to add\\");\\n    gs.SetDefaultString(unused_name);\\n    gs.AcceptNothing(true);\\n    gs.Get();\\n    if (gs.CommandResult() != Rhino.Commands.Result.Success)\\n      return gs.CommandResult();\\n\\n    // Was a layer named entered?\\n    string layer_name = gs.StringResult().Trim();\\n    if (string.IsNullOrEmpty(layer_name))\\n    {\\n      Rhino.RhinoApp.WriteLine(\\"Layer name cannot be blank.\\");\\n      return Rhino.Commands.Result.Cancel;\\n    }\\n\\n    // Is the layer name valid?\\n    if (!Rhino.DocObjects.Layer.IsValidName(layer_name))\\n    {\\n      Rhino.RhinoApp.WriteLine(layer_name + \\" is not a valid layer name.\\");\\n      return Rhino.Commands.Result.Cancel;\\n    }\\n\\n    // Does a layer with the same name already exist?\\n    int layer_index = doc.Layers.Find(layer_name, true);\\n    if (layer_index >= 0)\\n    {\\n      Rhino.RhinoApp.WriteLine(\\"A layer with the name {0} already exists.\\", layer_name);\\n      return Rhino.Commands.Result.Cancel;\\n    }\\n\\n    // Add a new layer to the document\\n    layer_index = doc.Layers.Add(layer_name, System.Drawing.Color.Black);\\n    if (layer_index < 0)\\n    {\\n      Rhino.RhinoApp.WriteLine(\\"Unable to add {0} layer.\\", layer_name);\\n      return Rhino.Commands.Result.Failure;\\n    }\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.RhinoApp","static void WriteLine(string message)"],["Rhino.RhinoApp","static void WriteLine(string format, object arg0)"],["Rhino.DocObjects.Layer","static bool IsValidName(string name)"],["Rhino.Input.Custom.GetBaseClass","void AcceptNothing(bool enable)"],["Rhino.Input.Custom.GetBaseClass","void SetDefaultString(string defaultValue)"],["Rhino.Input.Custom.GetBaseClass","string StringResult()"],["Rhino.Input.Custom.GetString","GetString()"],["Rhino.Input.Custom.GetString","GetResult Get()"],["Rhino.DocObjects.Tables.LayerTable","int Add(string layerName, Color layerColor)"],["Rhino.DocObjects.Tables.LayerTable","int Find(string layerName, bool ignoreDeletedLayers)"],["Rhino.DocObjects.Tables.LayerTable","Layer FindName(string layerName)"],["Rhino.DocObjects.Tables.LayerTable","string GetUnusedLayerName()"],["Rhino.DocObjects.Tables.LayerTable","string GetUnusedLayerName(bool ignoreDeleted)"]]},{"name":"Addlayout.cs","code":"partial class Examples\\n{\\n  /// <summary>\\n  /// Generate a layout with a single detail view that zooms to a list of objects\\n  /// </summary>\\n  /// <param name=\\"doc\\"></param>\\n  /// <returns></returns>\\n  public static Rhino.Commands.Result AddLayout(Rhino.RhinoDoc doc)\\n  {\\n    doc.PageUnitSystem = Rhino.UnitSystem.Millimeters;\\n    var page_views = doc.Views.GetPageViews();\\n    int page_number = (page_views==null) ? 1 : page_views.Length + 1;\\n    var pageview = doc.Views.AddPageView(string.Format(\\"A0_{0}\\",page_number), 1189, 841);\\n    if( pageview!=null )\\n    {\\n      Rhino.Geometry.Point2d top_left = new Rhino.Geometry.Point2d(20,821);\\n      Rhino.Geometry.Point2d bottom_right = new Rhino.Geometry.Point2d(1169, 20);\\n      var detail = pageview.AddDetailView(\\"ModelView\\", top_left, bottom_right, Rhino.Display.DefinedViewportProjection.Top);\\n      if (detail != null)\\n      {\\n        pageview.SetActiveDetail(detail.Id);\\n        detail.Viewport.ZoomExtents();\\n        detail.DetailGeometry.IsProjectionLocked = true;\\n        detail.DetailGeometry.SetScale(1, doc.ModelUnitSystem, 10, doc.PageUnitSystem);\\n        // Commit changes tells the document to replace the document\'s detail object\\n        // with the modified one that we just adjusted\\n        detail.CommitChanges();\\n      }\\n      pageview.SetPageAsActive();\\n      doc.Views.ActiveView = pageview;\\n      doc.Views.Redraw();\\n      return Rhino.Commands.Result.Success;\\n    }\\n    return Rhino.Commands.Result.Failure;\\n  }\\n}\\n","members":[["Rhino.RhinoDoc","UnitSystem PageUnitSystem"],["Rhino.Geometry.DetailView","bool IsProjectionLocked"],["Rhino.Geometry.DetailView","bool SetScale(double modelLength, UnitSystem modelUnits, double pageLength, UnitSystem pageUnits)"],["Rhino.DocObjects.RhinoObject","bool CommitChanges()"],["Rhino.Display.RhinoPageView","DetailViewObject AddDetailView(string title, Point2d corner0, Point2d corner1, DefinedViewportProjection initialProjection)"],["Rhino.Display.RhinoPageView","bool SetActiveDetail(Guid detailId)"],["Rhino.Display.RhinoPageView","void SetPageAsActive()"],["Rhino.Display.RhinoViewport","bool ZoomExtents()"],["Rhino.DocObjects.Tables.ViewTable","RhinoPageView AddPageView(string title, double pageWidth, double pageHeight)"],["Rhino.DocObjects.Tables.ViewTable","RhinoPageView[] GetPageViews()"]]},{"name":"Addline.cs","code":"using System;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddLine(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.Input.Custom.GetPoint gp = new Rhino.Input.Custom.GetPoint();\\n    gp.SetCommandPrompt(\\"Start of line\\");\\n    gp.Get();\\n    if (gp.CommandResult() != Rhino.Commands.Result.Success)\\n      return gp.CommandResult();\\n\\n    Rhino.Geometry.Point3d pt_start = gp.Point();\\n\\n    gp.SetCommandPrompt(\\"End of line\\");\\n    gp.SetBasePoint(pt_start, false);\\n    gp.DrawLineFromPoint(pt_start, true);\\n    gp.Get();\\n    if (gp.CommandResult() != Rhino.Commands.Result.Success)\\n      return gp.CommandResult();\\n\\n    Rhino.Geometry.Point3d pt_end = gp.Point();\\n    Rhino.Geometry.Vector3d v = pt_end - pt_start;\\n    if (v.IsTiny(Rhino.RhinoMath.ZeroTolerance))\\n      return Rhino.Commands.Result.Nothing;\\n\\n    if (doc.Objects.AddLine(pt_start, pt_end) != Guid.Empty)\\n    {\\n      doc.Views.Redraw();\\n      return Rhino.Commands.Result.Success;\\n    }\\n    return Rhino.Commands.Result.Failure;\\n  }\\n}\\n","members":[["Rhino.Geometry.Vector2d","bool IsTiny(double tolerance)"],["Rhino.Geometry.Vector3d","bool IsTiny(double tolerance)"],["Rhino.Input.Custom.GetBaseClass","Point3d Point()"],["Rhino.Input.Custom.GetBaseClass","void SetCommandPrompt(string prompt)"],["Rhino.Input.Custom.GetPoint","GetPoint()"],["Rhino.Input.Custom.GetPoint","void DrawLineFromPoint(Point3d startPoint, bool showDistanceInStatusBar)"],["Rhino.Input.Custom.GetPoint","GetResult Get()"],["Rhino.Input.Custom.GetPoint","void SetBasePoint(Point3d basePoint, bool showDistanceInStatusBar)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddLine(Point3d from, Point3d to)"]]},{"name":"Addlineardimension.cs","code":"using System;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddLinearDimension(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.Geometry.LinearDimension dimension;\\n    Rhino.Commands.Result rc = Rhino.Input.RhinoGet.GetLinearDimension(out dimension);\\n    if (rc == Rhino.Commands.Result.Success && dimension != null)\\n    {\\n      if (doc.Objects.AddLinearDimension(dimension) == Guid.Empty)\\n        rc = Rhino.Commands.Result.Failure;\\n      else\\n        doc.Views.Redraw();\\n    }\\n    return rc;\\n  }\\n}\\n","members":[["Rhino.Input.RhinoGet","static Result GetLinearDimension(out LinearDimension dimension)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddLinearDimension(LinearDimension dimension)"]]},{"name":"Addlineardimension2.cs","code":"using System;\\nusing Rhino.Geometry;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddLinearDimension2(Rhino.RhinoDoc doc)\\n  {\\n    Point3d origin = new Point3d(1,1,0);\\n    Point3d offset = new Point3d(11,1,0);\\n    Point3d pt = new Point3d((offset.X-origin.X)/2,3,0);\\n\\n    Plane plane = Plane.WorldXY;\\n    plane.Origin = origin;\\n\\n    double u,v;\\n    plane.ClosestParameter(origin, out u, out v);\\n    Point2d ext1 = new Point2d(u, v);\\n\\n    plane.ClosestParameter(offset, out u, out v);\\n    Point2d ext2 = new Point2d(u, v);\\n\\n    plane.ClosestParameter(pt, out u, out v);\\n    Point2d linePt = new Point2d(u, v);\\n\\n    LinearDimension dimension = new LinearDimension(plane, ext1, ext2, linePt);\\n    if (doc.Objects.AddLinearDimension(dimension) != Guid.Empty)\\n    {\\n      doc.Views.Redraw();\\n      return Rhino.Commands.Result.Success;\\n    }\\n    return Rhino.Commands.Result.Failure;\\n  }\\n}\\n","members":[["Rhino.Geometry.LinearDimension","LinearDimension(Plane dimensionPlane, Point2d extensionLine1End, Point2d extensionLine2End, Point2d pointOnDimensionLine)"],["Rhino.Geometry.Plane","bool ClosestParameter(Point3d testPoint, out double s, out double t)"]]},{"name":"Addmesh.cs","code":"using System;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddMesh(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.Geometry.Mesh mesh = new Rhino.Geometry.Mesh();\\n    mesh.Vertices.Add(0.0, 0.0, 1.0); //0\\n    mesh.Vertices.Add(1.0, 0.0, 1.0); //1\\n    mesh.Vertices.Add(2.0, 0.0, 1.0); //2\\n    mesh.Vertices.Add(3.0, 0.0, 0.0); //3\\n    mesh.Vertices.Add(0.0, 1.0, 1.0); //4\\n    mesh.Vertices.Add(1.0, 1.0, 2.0); //5\\n    mesh.Vertices.Add(2.0, 1.0, 1.0); //6\\n    mesh.Vertices.Add(3.0, 1.0, 0.0); //7\\n    mesh.Vertices.Add(0.0, 2.0, 1.0); //8\\n    mesh.Vertices.Add(1.0, 2.0, 1.0); //9\\n    mesh.Vertices.Add(2.0, 2.0, 1.0); //10\\n    mesh.Vertices.Add(3.0, 2.0, 1.0); //11\\n\\n    mesh.Faces.AddFace(0, 1, 5, 4);\\n    mesh.Faces.AddFace(1, 2, 6, 5);\\n    mesh.Faces.AddFace(2, 3, 7, 6);\\n    mesh.Faces.AddFace(4, 5, 9, 8);\\n    mesh.Faces.AddFace(5, 6, 10, 9);\\n    mesh.Faces.AddFace(6, 7, 11, 10);\\n    mesh.Normals.ComputeNormals();\\n    mesh.Compact();\\n    if (doc.Objects.AddMesh(mesh) != Guid.Empty)\\n    {\\n      doc.Views.Redraw();\\n      return Rhino.Commands.Result.Success;\\n    }\\n    return Rhino.Commands.Result.Failure;\\n  }\\n}","members":[["Rhino.Geometry.Mesh","Mesh()"],["Rhino.Geometry.Mesh","MeshFaceList Faces"],["Rhino.Geometry.Mesh","MeshVertexNormalList Normals"],["Rhino.Geometry.Mesh","MeshVertexList Vertices"],["Rhino.Geometry.Mesh","bool Compact()"],["Rhino.Geometry.Collections.MeshVertexList","int Add(double x, double y, double z)"],["Rhino.Geometry.Collections.MeshVertexList","int Add(float x, float y, float z)"],["Rhino.Geometry.Collections.MeshVertexNormalList","bool ComputeNormals()"],["Rhino.Geometry.Collections.MeshFaceList","int AddFace(int vertex1, int vertex2, int vertex3, int vertex4)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddMesh(Mesh mesh)"]]},{"name":"Addnamedview.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result AddNamedView(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.Display.RhinoView view;\\n    Rhino.Commands.Result rc = Rhino.Input.RhinoGet.GetView(\\"Select view to adjust\\", out view);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n\\n    Rhino.Geometry.Point3d location;\\n    rc = Rhino.Input.RhinoGet.GetPoint(\\"Camera Location\\", false, out location);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n\\n    Rhino.Input.Custom.GetPoint gp = new Rhino.Input.Custom.GetPoint();\\n    gp.SetCommandPrompt(\\"Look At Location\\");\\n    gp.DrawLineFromPoint(location, false);\\n    gp.Get();\\n    if (gp.CommandResult() != Rhino.Commands.Result.Success)\\n      return gp.CommandResult();\\n    Rhino.Geometry.Point3d lookat = gp.Point();\\n    \\n    string name = view.ActiveViewport.Name;\\n    rc = Rhino.Input.RhinoGet.GetString(\\"Name\\", true, ref name);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n\\n    Rhino.Display.RhinoViewport vp = view.ActiveViewport;\\n    // save the current viewport projection\\n    vp.PushViewProjection();\\n    vp.CameraUp = Rhino.Geometry.Vector3d.ZAxis;\\n    vp.SetCameraLocation(location, false);\\n    vp.SetCameraDirection(lookat - location, true);\\n    vp.Name = name;\\n\\n    doc.NamedViews.Add(name, vp.Id);\\n    view.Redraw();\\n    return Rhino.Commands.Result.Success;\\n  }\\n}","members":[["Rhino.RhinoDoc","NamedViewTable NamedViews"],["Rhino.Display.RhinoViewport","Vector3d CameraUp"],["Rhino.Display.RhinoViewport","string Name"],["Rhino.Display.RhinoViewport","bool PopViewProjection()"],["Rhino.Display.RhinoViewport","void PushViewProjection()"],["Rhino.Display.RhinoViewport","void SetCameraDirection(Vector3d cameraDirection, bool updateTargetLocation)"],["Rhino.Display.RhinoViewport","void SetCameraLocation(Point3d cameraLocation, bool updateTargetLocation)"],["Rhino.Input.RhinoGet","static Result GetPoint(string prompt, bool acceptNothing, out Point3d point)"],["Rhino.Input.RhinoGet","static Result GetString(string prompt, bool acceptNothing, ref string outputString)"],["Rhino.Input.RhinoGet","static Result GetView(string commandPrompt, out RhinoView view)"],["Rhino.DocObjects.Tables.NamedViewTable","int Add(string name, Guid viewportId)"]]},{"name":"Addnurbscircle.cs","code":"using System;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddNurbsCircle(Rhino.RhinoDoc doc)\\n  {\\n    // The easy way to get a NURBS curve from a circle is with\\n    // the following two lines of code.\\n    //\\n    // Rhino.Geometry.Circle c = new Rhino.Geometry.Circle(20);\\n    // Rhino.Geometry.NurbsCurve nc = c.ToNurbsCurve();\\n    //\\n    // This sample demonstrates creating a NURBS curve from scratch.\\n    const int dimension = 3;\\n    const bool isRational = true;\\n    const int order = 3;\\n    const int cv_count = 9;\\n    Rhino.Geometry.NurbsCurve nc = new Rhino.Geometry.NurbsCurve(dimension, isRational, order, cv_count);\\n    nc.Points.SetPoint(0, 1.0, 0.0, 0.0, 1.0);\\n    nc.Points.SetPoint(1, 0.707107, 0.707107, 0.0, 0.707107);\\n    nc.Points.SetPoint(2, 0.0, 1.0, 0.0, 1.0);\\n    nc.Points.SetPoint(3, -0.707107, 0.707107, 0.0, 0.707107);\\n    nc.Points.SetPoint(4, -1.0, 0.0, 0.0, 1.0);\\n    nc.Points.SetPoint(5, -0.707107, -0.707107, 0.0, 0.707107);\\n    nc.Points.SetPoint(6, 0.0, -1.0, 0.0, 1.0);\\n    nc.Points.SetPoint(7, 0.707107, -0.707107, 0.0, 0.707107);\\n    nc.Points.SetPoint(8, 1.0, 0.0, 0.0, 1.0);\\n    nc.Knots[0] = 0.0;\\n    nc.Knots[1] = 0.0;\\n    nc.Knots[2] = 0.5 * Math.PI;\\n    nc.Knots[3] = 0.5 * Math.PI;\\n    nc.Knots[4] = Math.PI;\\n    nc.Knots[5] = Math.PI;\\n    nc.Knots[6] = 1.5 * Math.PI;\\n    nc.Knots[7] = 1.5 * Math.PI;\\n    nc.Knots[8] = 2.0 * Math.PI;\\n    nc.Knots[9] = 2.0 * Math.PI;\\n    if (nc.IsValid)\\n    {\\n      doc.Objects.AddCurve(nc);\\n      doc.Views.Redraw();\\n      return Rhino.Commands.Result.Success;\\n    }\\n    return Rhino.Commands.Result.Failure;\\n  }\\n}\\n","members":[["Rhino.Geometry.NurbsCurve","NurbsCurve(int dimension, bool rational, int order, int pointCount)"],["Rhino.Geometry.NurbsCurve","NurbsCurveKnotList Knots"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddCurve(Curve curve)"]]},{"name":"Addnurbscurve.cs","code":"using System;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddNurbsCurve(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.Collections.Point3dList points = new Rhino.Collections.Point3dList(5);\\n    points.Add(0, 0, 0);\\n    points.Add(0, 2, 0);\\n    points.Add(2, 3, 0);\\n    points.Add(4, 2, 0);\\n    points.Add(4, 0, 0);\\n    Rhino.Geometry.NurbsCurve nc = Rhino.Geometry.NurbsCurve.Create(false, 3, points);\\n    Rhino.Commands.Result rc = Rhino.Commands.Result.Failure;\\n    if (nc != null && nc.IsValid)\\n    {\\n      if (doc.Objects.AddCurve(nc) != Guid.Empty)\\n      {\\n        doc.Views.Redraw();\\n        rc = Rhino.Commands.Result.Success;\\n      }\\n    }\\n    return rc;\\n  }\\n}\\n","members":[["Rhino.Geometry.NurbsCurve","static NurbsCurve Create(bool periodic, int degree, IEnumerable<Point3d> points)"],["Rhino.Collections.Point3dList","Point3dList(int initialCapacity)"],["Rhino.Collections.Point3dList","void Add(double x, double y, double z)"]]},{"name":"Addobjectstogroup.cs","code":"using System;\\nusing System.Collections.Generic;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddObjectsToGroup(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.Input.Custom.GetObject go = new Rhino.Input.Custom.GetObject();\\n    go.SetCommandPrompt(\\"Select objects to group\\");\\n    go.GroupSelect = true;\\n    go.GetMultiple(1, 0);\\n    if (go.CommandResult() != Rhino.Commands.Result.Success)\\n      return go.CommandResult();\\n\\n    List<Guid> ids = new List<Guid>();\\n    for (int i = 0; i < go.ObjectCount; i++)\\n    {\\n      ids.Add(go.Object(i).ObjectId);\\n    }\\n    int index = doc.Groups.Add(ids);\\n    doc.Views.Redraw();\\n    if (index >= 0)\\n      return Rhino.Commands.Result.Success;\\n    return Rhino.Commands.Result.Failure;\\n  }\\n}\\n","members":[["Rhino.RhinoDoc","GroupTable Groups"],["Rhino.Input.Custom.GetObject","GetObject()"],["Rhino.Input.Custom.GetObject","GetResult GetMultiple(int minimumNumber, int maximumNumber)"],["Rhino.DocObjects.Tables.GroupTable","int Add(IEnumerable<Guid> objectIds)"]]},{"name":"Addradialdimension.cs","code":"using Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Commands;\\nusing Rhino.Geometry;\\nusing Rhino.Input;\\n\\nnamespace examples_cs\\n{\\n  public class AddRadialDimensionCommand : Rhino.Commands.Command\\n  {\\n    public override string EnglishName\\n    {\\n      get { return \\"csAddRadialDimension\\"; }\\n    }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef obj_ref;\\n      var rc = RhinoGet.GetOneObject(\\"Select curve for radius dimension\\", \\n        true, ObjectType.Curve, out obj_ref);\\n      if (rc != Result.Success)\\n        return rc;\\n      double curve_parameter;\\n      var curve = obj_ref.CurveParameter(out curve_parameter);\\n      if (curve == null)\\n        return Result.Failure;\\n\\n      if (curve.IsLinear() || curve.IsPolyline())\\n      {\\n        RhinoApp.WriteLine(\\"Curve must be non-linear.\\");\\n        return Result.Nothing;\\n      }\\n\\n      // in this example just deal with planar curves\\n      if (!curve.IsPlanar())\\n      {\\n        RhinoApp.WriteLine(\\"Curve must be planar.\\");\\n        return Result.Nothing;\\n      }\\n\\n      var point_on_curve = curve.PointAt(curve_parameter);\\n      var curvature_vector = curve.CurvatureAt(curve_parameter);\\n      var len = curvature_vector.Length;\\n      if (len < RhinoMath.SqrtEpsilon)\\n      {\\n        RhinoApp.WriteLine(\\"Curve is almost linear and therefore has no curvature.\\");\\n        return Result.Nothing;\\n      }\\n\\n      var center = point_on_curve + (curvature_vector/(len*len));\\n      Plane plane;\\n      curve.TryGetPlane(out plane);\\n      var radial_dimension = \\n        new RadialDimension(center, point_on_curve, plane.XAxis, plane.Normal, 5.0);\\n      doc.Objects.AddRadialDimension(radial_dimension);\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Curve","Vector3d CurvatureAt(double t)"],["Rhino.Geometry.Curve","bool IsLinear()"],["Rhino.Geometry.Curve","bool IsPlanar()"],["Rhino.Geometry.Curve","bool IsPolyline()"],["Rhino.Geometry.Curve","Point3d PointAt(double t)"],["Rhino.DocObjects.ObjRef","Curve CurveParameter(out double parameter)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddRadialDimension(RadialDimension dimension)"]]},{"name":"Addsphere.cs","code":"using System;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddSphere(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.Geometry.Point3d center = new Rhino.Geometry.Point3d(0, 0, 0);\\n    const double radius = 5.0;\\n    Rhino.Geometry.Sphere sphere = new Rhino.Geometry.Sphere(center, radius);\\n    if( doc.Objects.AddSphere(sphere) != Guid.Empty )\\n    {\\n      doc.Views.Redraw();\\n      return Rhino.Commands.Result.Success;\\n    }\\n    return Rhino.Commands.Result.Failure;\\n  }\\n}\\n","members":[["Rhino.Geometry.Sphere","Sphere(Point3d center, double radius)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddSphere(Sphere sphere)"]]},{"name":"Addtext.cs","code":"using System;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddAnnotationText(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.Geometry.Point3d pt = new Rhino.Geometry.Point3d(10, 0, 0);\\n    const string text = \\"Hello RhinoCommon\\";\\n    const double height = 2.0;\\n    const string font = \\"Arial\\";\\n    Rhino.Geometry.Plane plane = doc.Views.ActiveView.ActiveViewport.ConstructionPlane();\\n    plane.Origin = pt;\\n    Guid id = doc.Objects.AddText(text, plane, height, font, false, false);\\n    if( id != Guid.Empty )\\n    {\\n      doc.Views.Redraw();\\n      return Rhino.Commands.Result.Success;\\n    }\\n    return Rhino.Commands.Result.Failure;\\n  }\\n}\\n","members":[["Rhino.DocObjects.Tables.ObjectTable","Guid AddText(string text, Plane plane, double height, string fontName, bool bold, bool italic)"]]},{"name":"Addtorus.cs","code":"using System;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddTorus(Rhino.RhinoDoc doc)\\n  {\\n    const double major_radius = 4.0;\\n    const double minor_radius = 2.0;\\n\\n    Rhino.Geometry.Plane plane = Rhino.Geometry.Plane.WorldXY;\\n    Rhino.Geometry.Torus torus = new Rhino.Geometry.Torus(plane, major_radius, minor_radius);\\n    Rhino.Geometry.RevSurface revsrf = torus.ToRevSurface();\\n    if (doc.Objects.AddSurface(revsrf) != Guid.Empty)\\n    {\\n      doc.Views.Redraw();\\n      return Rhino.Commands.Result.Success;\\n    }\\n    return Rhino.Commands.Result.Failure;\\n  }\\n}\\n","members":[["Rhino.Geometry.Torus","Torus(Plane basePlane, double majorRadius, double minorRadius)"],["Rhino.Geometry.Torus","RevSurface ToRevSurface()"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddSurface(Surface surface)"]]},{"name":"Addtruncatedcone.cs","code":"using System;\\nusing Rhino.Geometry;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddTruncatedCone(Rhino.RhinoDoc doc)\\n  {\\n    Point3d bottom_pt = new Point3d(0,0,0);\\n    const double bottom_radius = 2;\\n    Circle bottom_circle = new Circle(bottom_pt, bottom_radius);\\n\\n    Point3d top_pt = new Point3d(0,0,10);\\n    const double top_radius = 6;\\n    Circle top_circle = new Circle(top_pt, top_radius);\\n\\n    LineCurve shapeCurve = new LineCurve(bottom_circle.PointAt(0), top_circle.PointAt(0));\\n    Line axis = new Line(bottom_circle.Center, top_circle.Center);\\n    RevSurface revsrf = RevSurface.Create(shapeCurve, axis);\\n    Brep tcone_brep = Brep.CreateFromRevSurface(revsrf, true, true);\\n    if( doc.Objects.AddBrep(tcone_brep) != Guid.Empty )\\n    {\\n      doc.Views.Redraw();\\n      return Rhino.Commands.Result.Success;\\n    }\\n    return Rhino.Commands.Result.Failure;\\n  }\\n}\\n","members":[["Rhino.Geometry.Brep","static Brep CreateFromRevSurface(RevSurface surface, bool capStart, bool capEnd)"],["Rhino.Geometry.Circle","Circle(Point3d center, double radius)"],["Rhino.Geometry.LineCurve","LineCurve(Point3d from, Point3d to)"],["Rhino.Geometry.RevSurface","static RevSurface Create(Curve revoluteCurve, Line axisOfRevolution)"]]},{"name":"Advanceddisplay.cs","code":"using System.Collections.Generic;\\nusing Rhino.Display;\\n\\npartial class Examples\\n{\\n  // The following example code demonstrates how to modify advanced display settings using\\n  // the Rhino SDK. In this example, a display mode\'s mesh wireframe thickness (in pixels)\\n  // will be modified.\\n  public static Rhino.Commands.Result AdvancedDisplay(Rhino.RhinoDoc doc)\\n  {\\n    // Use the display attributes manager to build a list of display modes.\\n    // Note, these are copies of the originals...\\n    DisplayModeDescription[] display_modes = DisplayModeDescription.GetDisplayModes();\\n    if( display_modes==null || display_modes.Length<1 )\\n      return Rhino.Commands.Result.Failure;\\n\\n    // Construct an options picker so the user can pick which\\n    // display mode they want modified\\n    Rhino.Input.Custom.GetOption go = new Rhino.Input.Custom.GetOption();\\n    go.SetCommandPrompt(\\"Display mode to modify mesh thickness\\");\\n    List<int> opt_list = new List<int>();\\n\\n    for( int i=0; i<display_modes.Length; i++ )\\n    {\\n      string english_name = display_modes[i].EnglishName;\\n      english_name = english_name.Replace(\\"_\\", \\"\\");\\n      english_name = english_name.Replace(\\" \\", \\"\\");\\n      english_name = english_name.Replace(\\"-\\", \\"\\");\\n      english_name = english_name.Replace(\\",\\", \\"\\");\\n      english_name = english_name.Replace(\\".\\", \\"\\");\\n      int index = go.AddOption(english_name);\\n      opt_list.Add(index);\\n    }\\n    \\n    // Get the command option\\n    go.Get();\\n    if( go.CommandResult() != Rhino.Commands.Result.Success )\\n      return go.CommandResult();\\n\\n    int selected_index = go.Option().Index;\\n    DisplayModeDescription selected_description = null;\\n    for( int i=0; i<opt_list.Count; i++ )\\n    {\\n      if( opt_list[i]==selected_index )\\n      {\\n        selected_description = display_modes[i];\\n        break;\\n      }\\n    }\\n \\n    // Validate...\\n    if( selected_description==null )\\n      return Rhino.Commands.Result.Failure;\\n\\n    // Modify the desired display mode. In this case, we\\n    // will just set the mesh wireframe thickness to zero.\\n    selected_description.DisplayAttributes.MeshSpecificAttributes.MeshWireThickness = 0;\\n    // Use the display attributes manager to update the display mode.\\n    DisplayModeDescription.UpdateDisplayMode(selected_description);\\n\\n    // Force the document to regenerate.\\n    doc.Views.Redraw();\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Display.DisplayModeDescription","DisplayPipelineAttributes DisplayAttributes"],["Rhino.Display.DisplayModeDescription","static DisplayModeDescription[] GetDisplayModes()"],["Rhino.Display.DisplayModeDescription","static bool UpdateDisplayMode(DisplayModeDescription displayMode)"],["Rhino.Input.Custom.GetBaseClass","int AddOption(string englishOption)"]]},{"name":"Analysismode.cs","code":"using System;\\nusing Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Geometry;\\n\\n\\n[System.Runtime.InteropServices.Guid(\\"62dd8eec-5cce-42c7-9d80-8b01fc169b81\\")]\\npublic class AnalysisModeOnCommand : Rhino.Commands.Command\\n{\\n  public override string EnglishName { get { return \\"cs_analysismode_on\\"; } }\\n\\n  protected override Rhino.Commands.Result RunCommand(RhinoDoc doc, Rhino.Commands.RunMode mode)\\n  {\\n    // make sure our custom visual analysis mode is registered\\n    var zmode = Rhino.Display.VisualAnalysisMode.Register(typeof(ZAnalysisMode));\\n\\n    const ObjectType filter = Rhino.DocObjects.ObjectType.Surface | Rhino.DocObjects.ObjectType.PolysrfFilter | Rhino.DocObjects.ObjectType.Mesh;\\n    Rhino.DocObjects.ObjRef[] objs;\\n    var rc = Rhino.Input.RhinoGet.GetMultipleObjects(\\"Select objects for Z analysis\\", false, filter, out objs);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n\\n    int count = 0;\\n    for (int i = 0; i < objs.Length; i++)\\n    {\\n      var obj = objs[i].Object();\\n\\n      // see if this object is alreay in Z analysis mode\\n      if (obj.InVisualAnalysisMode(zmode))\\n        continue;\\n\\n      if (obj.EnableVisualAnalysisMode(zmode, true))\\n        count++;\\n    }\\n    doc.Views.Redraw();\\n    RhinoApp.WriteLine(\\"{0} objects were put into Z-Analysis mode.\\", count);\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n\\n[System.Runtime.InteropServices.Guid(\\"0A8CE87D-A8CB-4A41-9DE2-5B3957436AEE\\")]\\npublic class AnalysisModeOffCommand : Rhino.Commands.Command\\n{\\n  public override string EnglishName { get { return \\"cs_analysismode_off\\"; } }\\n\\n  protected override Rhino.Commands.Result RunCommand(RhinoDoc doc, Rhino.Commands.RunMode mode)\\n  {\\n    var zmode = Rhino.Display.VisualAnalysisMode.Find(typeof(ZAnalysisMode));\\n    // If zmode is null, we\'ve never registered the mode so we know it hasn\'t been used\\n    if (zmode != null)\\n    {\\n      foreach (Rhino.DocObjects.RhinoObject obj in doc.Objects)\\n      {\\n        obj.EnableVisualAnalysisMode(zmode, false);\\n      }\\n      doc.Views.Redraw();\\n    }\\n    RhinoApp.WriteLine(\\"Z-Analysis is off.\\");\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n\\n\\n/// <summary>\\n/// This simple example provides a false color based on the world z-coordinate.\\n/// For details, see the implementation of the FalseColor() function.\\n/// </summary>\\npublic class ZAnalysisMode : Rhino.Display.VisualAnalysisMode\\n{\\n  Interval m_z_range = new Interval(-10,10);\\n  Interval m_hue_range = new Interval(0,4*Math.PI / 3);\\n  private const bool m_show_isocurves = true;\\n\\n  public override string Name { get { return \\"Z-Analysis\\"; } }\\n  public override Rhino.Display.VisualAnalysisMode.AnalysisStyle Style { get { return AnalysisStyle.FalseColor; } }\\n\\n  public override bool ObjectSupportsAnalysisMode(Rhino.DocObjects.RhinoObject obj)\\n  {\\n    if (obj is Rhino.DocObjects.MeshObject || obj is Rhino.DocObjects.BrepObject)\\n      return true;\\n    return false;\\n  }\\n\\n  protected override void UpdateVertexColors(Rhino.DocObjects.RhinoObject obj, Mesh[] meshes)\\n  {\\n    // A \\"mapping tag\\" is used to determine if the colors need to be set\\n    Rhino.Render.MappingTag mt = GetMappingTag(obj.RuntimeSerialNumber);\\n\\n    for (int mi = 0; mi < meshes.Length; mi++)\\n    {\\n      var mesh = meshes[mi];\\n      if( mesh.VertexColors.Tag.Id != this.Id )\\n      {\\n        // The mesh\'s mapping tag is different from ours. Either the mesh has\\n        // no false colors, has false colors set by another analysis mode, has\\n        // false colors set using different m_z_range[]/m_hue_range[] values, or\\n        // the mesh has been moved.  In any case, we need to set the false\\n        // colors to the ones we want.\\n        System.Drawing.Color[] colors = new System.Drawing.Color[mesh.Vertices.Count];\\n        for (int i = 0; i < mesh.Vertices.Count; i++)\\n        {\\n          double z = mesh.Vertices[i].Z;\\n          colors[i] = FalseColor(z);\\n        }\\n        mesh.VertexColors.SetColors(colors);\\n        // set the mesh\'s color tag \\n        mesh.VertexColors.Tag = mt;\\n      }\\n    }\\n  }\\n\\n  public override bool ShowIsoCurves\\n  {\\n    get\\n    {\\n      // Most shaded analysis modes that work on breps have the option of\\n      // showing or hiding isocurves.  Run the built-in Rhino ZebraAnalysis\\n      // to see how Rhino handles the user interface.  If controlling\\n      // iso-curve visability is a feature you want to support, then provide\\n      // user interface to set this member variable.\\n      return m_show_isocurves; \\n    }\\n  }\\n\\n  /// <summary>\\n  /// Returns a mapping tag that is used to detect when a mesh\'s colors need to\\n  /// be set.\\n  /// </summary>\\n  /// <returns></returns>\\n  Rhino.Render.MappingTag GetMappingTag(uint serialNumber)\\n  {\\n    Rhino.Render.MappingTag mt = new Rhino.Render.MappingTag();\\n    mt.Id = this.Id;\\n\\n    // Since the false colors that are shown will change if the mesh is\\n    // transformed, we have to initialize the transformation.\\n    mt.MeshTransform = Transform.Identity;\\n\\n    // This is a 32 bit CRC or the information used to set the false colors.\\n    // For this example, the m_z_range and m_hue_range intervals control the\\n    // colors, so we calculate their crc.\\n    uint crc = RhinoMath.CRC32(serialNumber, m_z_range.T0);\\n    crc = RhinoMath.CRC32(crc, m_z_range.T1);\\n    crc = RhinoMath.CRC32(crc, m_hue_range.T0);\\n    crc = RhinoMath.CRC32(crc, m_hue_range.T1);\\n    mt.MappingCRC = crc;\\n    return mt;\\n  }\\n\\n  System.Drawing.Color FalseColor(double z)\\n  {\\n    // Simple example of one way to change a number into a color.\\n    double s = m_z_range.NormalizedParameterAt(z);\\n    s = Rhino.RhinoMath.Clamp(s, 0, 1);\\n    return System.Drawing.Color.FromArgb((int)(s * 255), 0, 0);\\n  }\\n\\n}","members":[["Rhino.RhinoMath","static uint CRC32(uint currentRemainder, double value)"],["Rhino.Geometry.Collections.MeshVertexColorList","MappingTag Tag"],["Rhino.Geometry.Collections.MeshVertexColorList","bool SetColors(Color[] colors)"]]},{"name":"Arclengthpoint.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result ArcLengthPoint(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.DocObjects.ObjRef objref;\\n    Rhino.Commands.Result rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select curve\\",\\n      true, Rhino.DocObjects.ObjectType.Curve,out objref);\\n    if(rc!= Rhino.Commands.Result.Success)\\n      return rc;\\n    Rhino.Geometry.Curve crv = objref.Curve();\\n    if( crv==null )\\n      return Rhino.Commands.Result.Failure;\\n \\n    double crv_length = crv.GetLength();\\n    double length = 0;\\n    rc = Rhino.Input.RhinoGet.GetNumber(\\"Length from start\\", true, ref length, 0, crv_length);\\n    if(rc!= Rhino.Commands.Result.Success)\\n      return rc;\\n \\n    Rhino.Geometry.Point3d pt = crv.PointAtLength(length);\\n    if (pt.IsValid)\\n    {\\n      doc.Objects.AddPoint(pt);\\n      doc.Views.Redraw();\\n    }\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Geometry.Curve","double GetLength()"],["Rhino.Geometry.Curve","Point3d PointAtLength(double length)"]]},{"name":"Arraybydistance.cs","code":"using Rhino;\\n\\n[System.Runtime.InteropServices.Guid(\\"3CDCBB20-B4E4-4AB6-B870-C911C7435BD7\\")]\\npublic class ArrayByDistanceCommand : Rhino.Commands.Command\\n{\\n  public override string EnglishName\\n  {\\n    get { return \\"cs_ArrayByDistance\\"; }\\n  }\\n  \\n  double m_distance = 1;\\n  Rhino.Geometry.Point3d m_point_start;\\n  protected override Rhino.Commands.Result RunCommand(RhinoDoc doc, Rhino.Commands.RunMode mode)\\n  {\\n    Rhino.DocObjects.ObjRef objref;\\n    var rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select object\\", true, Rhino.DocObjects.ObjectType.AnyObject, out objref);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n\\n    rc = Rhino.Input.RhinoGet.GetPoint(\\"Start point\\", false, out m_point_start);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n\\n    var obj = objref.Object();\\n    if (obj == null)\\n      return Rhino.Commands.Result.Failure;\\n\\n    // create an instance of a GetPoint class and add a delegate\\n    // for the DynamicDraw event\\n    var gp = new Rhino.Input.Custom.GetPoint();\\n    gp.DrawLineFromPoint(m_point_start, true);\\n    var optdouble = new Rhino.Input.Custom.OptionDouble(m_distance);\\n    bool constrain = false;\\n    var optconstrain = new Rhino.Input.Custom.OptionToggle(constrain, \\"Off\\", \\"On\\");\\n    gp.AddOptionDouble(\\"Distance\\", ref optdouble);\\n    gp.AddOptionToggle(\\"Constrain\\", ref optconstrain);\\n    gp.DynamicDraw += ArrayByDistanceDraw;\\n    gp.Tag = obj;\\n    while (gp.Get() == Rhino.Input.GetResult.Option)\\n    {\\n      m_distance = optdouble.CurrentValue;\\n      if (constrain != optconstrain.CurrentValue)\\n      {\\n        constrain = optconstrain.CurrentValue;\\n        if (constrain)\\n        {\\n          var gp2 = new Rhino.Input.Custom.GetPoint();\\n          gp2.DrawLineFromPoint(m_point_start, true);\\n          gp2.SetCommandPrompt(\\"Second point on constraint line\\");\\n          if (gp2.Get() == Rhino.Input.GetResult.Point)\\n            gp.Constrain(m_point_start, gp2.Point());\\n          else\\n          {\\n            gp.ClearCommandOptions();\\n            optconstrain.CurrentValue = false;\\n            constrain = false;\\n            gp.AddOptionDouble(\\"Distance\\", ref optdouble);\\n            gp.AddOptionToggle(\\"Constrain\\", ref optconstrain);\\n          }\\n        }\\n        else\\n        {\\n          gp.ClearConstraints();\\n        }\\n      }\\n    }\\n\\n    if (gp.CommandResult() == Rhino.Commands.Result.Success)\\n    {\\n      m_distance = optdouble.CurrentValue;\\n      var pt = gp.Point();\\n      var vec = pt - m_point_start;\\n      double length = vec.Length;\\n      vec.Unitize();\\n      int count = (int)(length / m_distance);\\n      for (int i = 1; i < count; i++)\\n      {\\n        var translate = vec * (i * m_distance);\\n        var xf = Rhino.Geometry.Transform.Translation(translate);\\n        doc.Objects.Transform(obj, xf, false);\\n      }\\n      doc.Views.Redraw();\\n    }\\n\\n    return gp.CommandResult();\\n  }\\n\\n  // this function is called whenever the GetPoint\'s DynamicDraw\\n  // event occurs\\n  void ArrayByDistanceDraw(object sender, Rhino.Input.Custom.GetPointDrawEventArgs e)\\n  {\\n    Rhino.DocObjects.RhinoObject rhobj = e.Source.Tag as Rhino.DocObjects.RhinoObject;\\n    if (rhobj == null)\\n      return;\\n    var vec = e.CurrentPoint - m_point_start;\\n    double length = vec.Length;\\n    vec.Unitize();\\n    int count = (int)(length / m_distance);\\n    for (int i = 1; i < count; i++)\\n    {\\n      var translate = vec * (i * m_distance);\\n      var xf = Rhino.Geometry.Transform.Translation(translate);\\n      e.Display.DrawObject(rhobj, xf);\\n    }\\n  }\\n}\\n","members":[["Rhino.Display.DisplayPipeline","void DrawObject(RhinoObject rhinoObject, Transform xform)"],["Rhino.Input.Custom.GetBaseClass","void ClearCommandOptions()"],["Rhino.Input.Custom.GetPoint","object Tag"],["Rhino.Input.Custom.GetPoint","void ClearConstraints()"],["Rhino.Input.Custom.GetPoint","bool Constrain(Point3d from, Point3d to)"],["Rhino.Input.Custom.GetPointDrawEventArgs","GetPoint Source"]]},{"name":"Blockinsertionpoint.cs","code":"using Rhino.Commands;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result BlockInsertionPoint(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.DocObjects.ObjRef objref;\\n    Result rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select instance\\", true, Rhino.DocObjects.ObjectType.InstanceReference, out objref);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n    Rhino.DocObjects.InstanceObject instance = objref.Object() as Rhino.DocObjects.InstanceObject;\\n    if (instance != null)\\n    {\\n      Rhino.Geometry.Point3d pt = instance.InsertionPoint;\\n      doc.Objects.AddPoint(pt);\\n      doc.Views.Redraw();\\n    }\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.DocObjects.InstanceObject","Point3d InsertionPoint"]]},{"name":"Booleandifference.cs","code":"using System.Collections.Generic;\\nusing Rhino.Commands;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result BooleanDifference(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.DocObjects.ObjRef[] objrefs;\\n    Result rc = Rhino.Input.RhinoGet.GetMultipleObjects(\\"Select first set of polysurfaces\\",\\n                                                        false, Rhino.DocObjects.ObjectType.PolysrfFilter, out objrefs);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n    if (objrefs == null || objrefs.Length < 1)\\n      return Rhino.Commands.Result.Failure;\\n\\n    List<Rhino.Geometry.Brep> in_breps0 = new List<Rhino.Geometry.Brep>();\\n    for (int i = 0; i < objrefs.Length; i++)\\n    {\\n      Rhino.Geometry.Brep brep = objrefs[i].Brep();\\n      if (brep != null)\\n        in_breps0.Add(brep);\\n    }\\n\\n    doc.Objects.UnselectAll();\\n    rc = Rhino.Input.RhinoGet.GetMultipleObjects(\\"Select second set of polysurfaces\\",\\n      false, Rhino.DocObjects.ObjectType.PolysrfFilter, out objrefs);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n    if (objrefs == null || objrefs.Length < 1)\\n      return Rhino.Commands.Result.Failure;\\n\\n    List<Rhino.Geometry.Brep> in_breps1 = new List<Rhino.Geometry.Brep>();\\n    for (int i = 0; i < objrefs.Length; i++)\\n    {\\n      Rhino.Geometry.Brep brep = objrefs[i].Brep();\\n      if (brep != null)\\n        in_breps1.Add(brep);\\n    }\\n\\n    double tolerance = doc.ModelAbsoluteTolerance;\\n    Rhino.Geometry.Brep[] breps = Rhino.Geometry.Brep.CreateBooleanDifference(in_breps0, in_breps1, tolerance);\\n    if (breps.Length < 1)\\n      return Rhino.Commands.Result.Nothing;\\n    for (int i = 0; i < breps.Length; i++)\\n      doc.Objects.AddBrep(breps[i]);\\n    doc.Views.Redraw();\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Geometry.Brep","static Brep[] CreateBooleanDifference(IEnumerable<Brep> firstSet, IEnumerable<Brep> secondSet, double tolerance)"],["Rhino.Geometry.Brep","static Brep[] CreateBooleanDifference(IEnumerable<Brep> firstSet, IEnumerable<Brep> secondSet, double tolerance, bool manifoldOnly)"],["Rhino.DocObjects.ObjRef","Brep Brep()"],["Rhino.Input.RhinoGet","static Result GetMultipleObjects(string prompt, bool acceptNothing, ObjectType filter, out ObjRef[] rhObjects)"]]},{"name":"Circlecenter.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result CircleCenter(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.Input.Custom.GetObject go = new Rhino.Input.Custom.GetObject();\\n    go.SetCommandPrompt(\\"Select objects\\");\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve;\\n    go.GeometryAttributeFilter = Rhino.Input.Custom.GeometryAttributeFilter.ClosedCurve;\\n    go.GetMultiple(1, 0);\\n    if( go.CommandResult() != Rhino.Commands.Result.Success )\\n      return go.CommandResult();\\n\\n    Rhino.DocObjects.ObjRef[] objrefs = go.Objects();\\n    if( objrefs==null )\\n      return Rhino.Commands.Result.Nothing;\\n\\n    double tolerance = doc.ModelAbsoluteTolerance;\\n    for( int i=0; i<objrefs.Length; i++ )\\n    {\\n      // get the curve geometry\\n      Rhino.Geometry.Curve curve = objrefs[i].Curve();\\n      if( curve==null )\\n        continue;\\n      Rhino.Geometry.Circle circle;\\n      if( curve.TryGetCircle(out circle, tolerance) )\\n      {\\n        Rhino.RhinoApp.WriteLine(\\"Circle{0}: center = {1}\\", i+1, circle.Center);\\n      }\\n    }\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Geometry.Curve","bool TryGetCircle(out Circle circle, double tolerance)"],["Rhino.Input.Custom.GetObject","GeometryAttributeFilter GeometryAttributeFilter"]]},{"name":"Closestpoint.cs","code":"using Rhino;\\nusing Rhino.Geometry;\\n\\nnamespace examples_cs\\n{\\n  [System.Runtime.InteropServices.Guid(\\"0E82E6DA-5335-453A-AC94-2499BBBCBE55\\")]\\n  public class RTreeClosestPoint : Rhino.Commands.Command\\n  {\\n    public override string EnglishName { get { return \\"cs_RtreeClosestPoint\\"; } }\\n\\n    void SearchCallback(object sender, RTreeEventArgs e)\\n    {\\n      SearchData data = e.Tag as SearchData;\\n      if (data == null)\\n        return;\\n      data.HitCount = data.HitCount + 1;\\n      Point3f vertex = data.Mesh.Vertices[e.Id];\\n      double distance = data.Point.DistanceTo(vertex);\\n      if (data.Index == -1 || data.Distance > distance)\\n      {\\n        // shrink the sphere to help improve the test\\n        e.SearchSphere = new Sphere(data.Point, distance);\\n        data.Index = e.Id;\\n        data.Distance = distance;\\n      }\\n    }\\n\\n    class SearchData\\n    {\\n      public SearchData(Mesh mesh, Point3d point)\\n      {\\n        Point = point;\\n        Mesh = mesh;\\n        HitCount = 0;\\n        Index = -1;\\n        Distance = 0;\\n      }\\n\\n      public int HitCount { get; set; }\\n      public Point3d Point { get; private set; }\\n      public Mesh Mesh { get; private set; }\\n      public int Index { get; set; }\\n      public double Distance { get; set; }\\n    }\\n\\n    protected override Rhino.Commands.Result RunCommand(RhinoDoc doc, Rhino.Commands.RunMode mode)\\n    {\\n      Rhino.DocObjects.ObjRef objref;\\n      var rc = Rhino.Input.RhinoGet.GetOneObject(\\"select mesh\\", false, Rhino.DocObjects.ObjectType.Mesh, out objref);\\n      if (rc != Rhino.Commands.Result.Success)\\n        return rc;\\n\\n      Mesh mesh = objref.Mesh();\\n      objref.Object().Select(false);\\n      doc.Views.Redraw();\\n\\n      using (RTree tree = new RTree())\\n      {\\n        for (int i = 0; i < mesh.Vertices.Count; i++)\\n        {\\n          // we can make a C++ function that just builds an rtree from the\\n          // vertices in one quick shot, but for now...\\n          tree.Insert(mesh.Vertices[i], i);\\n        }\\n\\n        while (true)\\n        {\\n          Point3d point;\\n          rc = Rhino.Input.RhinoGet.GetPoint(\\"test point\\", false, out point);\\n          if (rc != Rhino.Commands.Result.Success)\\n            break;\\n\\n          SearchData data = new SearchData(mesh, point);\\n          // Use the first vertex in the mesh to define a start sphere\\n          double distance = point.DistanceTo(mesh.Vertices[0]);\\n          Sphere sphere = new Sphere(point, distance * 1.1);\\n          if (tree.Search(sphere, SearchCallback, data))\\n          {\\n            doc.Objects.AddPoint(mesh.Vertices[data.Index]);\\n            doc.Views.Redraw();\\n            RhinoApp.WriteLine(\\"Found point in {0} tests\\", data.HitCount);\\n          }\\n        }\\n      }\\n      return Rhino.Commands.Result.Success;\\n    }\\n  }\\n}\\n\\n","members":[["Rhino.Geometry.RTree","RTree()"],["Rhino.Geometry.RTree","bool Insert(Point3d point, int elementId)"],["Rhino.Geometry.RTree","bool Search(Sphere sphere, EventHandler<RTreeEventArgs> callback, object tag)"]]},{"name":"Commandlineoptions.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result CommandLineOptions(Rhino.RhinoDoc doc)\\n  {\\n    // For this example we will use a GetPoint class, but all of the custom\\n    // \\"Get\\" classes support command line options.\\n    Rhino.Input.Custom.GetPoint gp = new Rhino.Input.Custom.GetPoint();\\n    gp.SetCommandPrompt(\\"GetPoint with options\\");\\n\\n    // set up the options\\n    Rhino.Input.Custom.OptionInteger intOption = new Rhino.Input.Custom.OptionInteger(1, 1, 99);\\n    Rhino.Input.Custom.OptionDouble dblOption = new Rhino.Input.Custom.OptionDouble(2.2, 0, 99.9);\\n    Rhino.Input.Custom.OptionToggle boolOption = new Rhino.Input.Custom.OptionToggle(true, \\"Off\\", \\"On\\");\\n    string[] listValues = new string[] { \\"Item0\\", \\"Item1\\", \\"Item2\\", \\"Item3\\", \\"Item4\\" };\\n\\n    gp.AddOptionInteger(\\"Integer\\", ref intOption);\\n    gp.AddOptionDouble(\\"Double\\", ref dblOption);\\n    gp.AddOptionToggle(\\"Boolean\\", ref boolOption);\\n    int listIndex = 3;\\n    int opList = gp.AddOptionList(\\"List\\", listValues, listIndex);\\n\\n    while (true)\\n    {\\n      // perform the get operation. This will prompt the user to input a point, but also\\n      // allow for command line options defined above\\n      Rhino.Input.GetResult get_rc = gp.Get();\\n      if (gp.CommandResult() != Rhino.Commands.Result.Success)\\n        return gp.CommandResult();\\n\\n      if (get_rc == Rhino.Input.GetResult.Point)\\n      {\\n        doc.Objects.AddPoint(gp.Point());\\n        doc.Views.Redraw();\\n        Rhino.RhinoApp.WriteLine(\\"Command line option values are\\");\\n        Rhino.RhinoApp.WriteLine(\\" Integer = {0}\\", intOption.CurrentValue);\\n        Rhino.RhinoApp.WriteLine(\\" Double = {0}\\", dblOption.CurrentValue);\\n        Rhino.RhinoApp.WriteLine(\\" Boolean = {0}\\", boolOption.CurrentValue);\\n        Rhino.RhinoApp.WriteLine(\\" List = {0}\\", listValues[listIndex]);\\n      }\\n      else if (get_rc == Rhino.Input.GetResult.Option)\\n      {\\n        if (gp.OptionIndex() == opList)\\n          listIndex = gp.Option().CurrentListOptionIndex;\\n        continue;\\n      }\\n      break;\\n    }\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Input.Custom.GetBaseClass","int AddOptionDouble(LocalizeStringPair optionName, ref OptionDouble numberValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionDouble(string englishName, ref OptionDouble numberValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionInteger(LocalizeStringPair optionName, ref OptionInteger intValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionInteger(string englishName, ref OptionInteger intValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionToggle(LocalizeStringPair optionName, ref OptionToggle toggleValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionToggle(string englishName, ref OptionToggle toggleValue)"],["Rhino.Input.Custom.CommandLineOption","int CurrentListOptionIndex"],["Rhino.Input.Custom.OptionToggle","OptionToggle(bool initialValue, string offValue, string onValue)"],["Rhino.Input.Custom.OptionToggle","bool CurrentValue"],["Rhino.Input.Custom.OptionDouble","OptionDouble(double initialValue, double lowerLimit, double upperLimit)"],["Rhino.Input.Custom.OptionDouble","double CurrentValue"],["Rhino.Input.Custom.OptionInteger","OptionInteger(int initialValue, int lowerLimit, int upperLimit)"],["Rhino.Input.Custom.OptionInteger","int CurrentValue"]]},{"name":"Conduitarrowheads.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Geometry;\\nusing Rhino.Input.Custom;\\n\\nnamespace examples_cs\\n{\\n  class DrawArrowHeadsConduit : Rhino.Display.DisplayConduit\\n  {\\n    private readonly Line m_line;\\n    private readonly int m_screen_size;\\n    private readonly double m_world_size;\\n\\n    public DrawArrowHeadsConduit(Line line, int screenSize, double worldSize)\\n    {\\n      m_line = line;\\n      m_screen_size = screenSize;\\n      m_world_size = worldSize;\\n    }\\n\\n    protected override void DrawForeground(Rhino.Display.DrawEventArgs e)\\n    {\\n      e.Display.DrawArrow(m_line, System.Drawing.Color.Black, m_screen_size, m_world_size);\\n    }\\n  }\\n\\n\\n  public class DrawArrowheadsCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csDrawArrowHeads\\"; } }\\n\\n    DrawArrowHeadsConduit m_draw_conduit;\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      if (m_draw_conduit != null)\\n      {\\n        RhinoApp.WriteLine(\\"Turn off existing arrowhead conduit\\");\\n        m_draw_conduit.Enabled = false;\\n        m_draw_conduit = null;\\n      }\\n      else\\n      {\\n        // get arrow head size\\n        var go = new GetOption();\\n        go.SetCommandPrompt(\\"ArrowHead length in screen size (pixels) or world size (percentage of arrow length)?\\");\\n        go.AddOption(\\"screen\\");\\n        go.AddOption(\\"world\\");\\n        go.Get();\\n        if (go.CommandResult() != Result.Success)\\n          return go.CommandResult();\\n\\n        int screen_size = 0;\\n        double world_size = 0.0;\\n        if (go.Option().EnglishName == \\"screen\\")\\n        {\\n          var gi = new GetInteger();\\n          gi.SetLowerLimit(0, true);\\n          gi.SetCommandPrompt(\\"Length of arrow head in pixels\\");\\n          gi.Get();\\n          if (gi.CommandResult() != Result.Success)\\n            return gi.CommandResult();\\n          screen_size = gi.Number();\\n        }\\n        else\\n        {\\n          var gi = new GetInteger();\\n          gi.SetLowerLimit(0, true);\\n          gi.SetUpperLimit(100, false);\\n          gi.SetCommandPrompt(\\"Length of arrow head in percentage of total arrow length\\");\\n          gi.Get();\\n          if (gi.CommandResult() != Result.Success)\\n            return gi.CommandResult();\\n          world_size = gi.Number() / 100.0;\\n        }\\n\\n\\n        // get arrow start and end points\\n        var gp = new GetPoint();\\n        gp.SetCommandPrompt(\\"Start of line\\");\\n        gp.Get();\\n        if (gp.CommandResult() != Result.Success)\\n          return gp.CommandResult();\\n        var start_point = gp.Point();\\n\\n        gp.SetCommandPrompt(\\"End of line\\");\\n        gp.SetBasePoint(start_point, false);\\n        gp.DrawLineFromPoint(start_point, true);\\n        gp.Get();\\n        if (gp.CommandResult() != Result.Success)\\n          return gp.CommandResult();\\n        var end_point = gp.Point();\\n\\n        var v = end_point - start_point;\\n        if (v.IsTiny(Rhino.RhinoMath.ZeroTolerance))\\n          return Result.Nothing;\\n\\n        var line = new Line(start_point, end_point);\\n\\n        m_draw_conduit = new DrawArrowHeadsConduit(line, screen_size, world_size);\\n        // toggle conduit on/off\\n        m_draw_conduit.Enabled = true;\\n        RhinoApp.WriteLine(\\"Draw arrowheads conduit enabled.\\");\\n      }\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}\\n\\n","members":[["Rhino.Display.DisplayPipeline","void DrawArrow(Line line, Color color, double screenSize, double relativeSize)"]]},{"name":"Conduitbitmap.cs","code":"using System.Drawing;\\nusing Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Display;\\n\\nnamespace examples_cs\\n{\\n  public class DrawBitmapConduit : Rhino.Display.DisplayConduit\\n  {\\n    private readonly DisplayBitmap m_display_bitmap;\\n\\n    public DrawBitmapConduit()\\n    {\\n      var flag = new System.Drawing.Bitmap(100, 100);\\n      for( int x = 0; x <  flag.Height; ++x )\\n          for( int y = 0; y < flag.Width; ++y )\\n              flag.SetPixel(x, y, Color.White);\\n\\n      var g = Graphics.FromImage(flag);\\n      g.FillEllipse(Brushes.Blue, 25, 25, 50, 50);\\n      m_display_bitmap = new DisplayBitmap(flag);\\n    }\\n\\n    protected override void DrawForeground(Rhino.Display.DrawEventArgs e)\\n    {\\n      e.Display.DrawBitmap(m_display_bitmap, 50, 50, Color.White);\\n    }\\n  }\\n\\n  public class DrawBitmapCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csDrawBitmap\\"; } }\\n\\n    readonly DrawBitmapConduit m_conduit = new DrawBitmapConduit();\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      // toggle conduit on/off\\n      m_conduit.Enabled = !m_conduit.Enabled;\\n      \\n      RhinoApp.WriteLine(\\"Custom conduit enabled = {0}\\", m_conduit.Enabled);\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Display.DisplayPipeline","void DrawBitmap(DisplayBitmap bitmap, int left, int top)"]]},{"name":"Constrainedcopy.cs","code":"using System;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result ConstrainedCopy(Rhino.RhinoDoc doc)\\n  {\\n    // Get a single planar closed curve\\n    var go = new Rhino.Input.Custom.GetObject();\\n    go.SetCommandPrompt(\\"Select curve\\");\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve;\\n    go.GeometryAttributeFilter = Rhino.Input.Custom.GeometryAttributeFilter.ClosedCurve;\\n    go.Get();\\n    if( go.CommandResult() != Rhino.Commands.Result.Success )\\n      return go.CommandResult();\\n    var objref = go.Object(0);\\n    var base_curve = objref.Curve();\\n    var first_point = objref.SelectionPoint();\\n    if( base_curve==null || !first_point.IsValid )\\n      return Rhino.Commands.Result.Cancel;\\n\\n    Rhino.Geometry.Plane plane;\\n    if( !base_curve.TryGetPlane(out plane) )\\n      return Rhino.Commands.Result.Cancel;\\n\\n    // Get a point constrained to a line passing through the initial selection\\n    // point and parallel to the plane\'s normal\\n    var gp = new Rhino.Input.Custom.GetPoint();\\n    gp.SetCommandPrompt(\\"Offset point\\");\\n    gp.DrawLineFromPoint(first_point, true);\\n    var line = new Rhino.Geometry.Line(first_point, first_point+plane.Normal);\\n    gp.Constrain(line);\\n    gp.Get();\\n    if( gp.CommandResult() != Rhino.Commands.Result.Success )\\n      return gp.CommandResult();\\n    var second_point = gp.Point();\\n    Rhino.Geometry.Vector3d vec = second_point - first_point;\\n    if( vec.Length > 0.001 )\\n    {\\n      var xf = Rhino.Geometry.Transform.Translation(vec);\\n      Guid id = doc.Objects.Transform(objref, xf, false);\\n      if( id!=Guid.Empty )\\n      {\\n        doc.Views.Redraw();\\n        return Rhino.Commands.Result.Success;\\n      }\\n    }\\n    return Rhino.Commands.Result.Cancel;\\n  }\\n}\\n","members":[["Rhino.Geometry.Curve","bool TryGetPlane(out Plane plane)"],["Rhino.Geometry.Transform","static Transform Translation(Vector3d motion)"],["Rhino.DocObjects.ObjRef","Point3d SelectionPoint()"],["Rhino.Input.Custom.GetPoint","bool Constrain(Line line)"]]},{"name":"Createblock.cs","code":"using Rhino.DocObjects;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result CreateBlock(Rhino.RhinoDoc doc)\\n  {\\n    // Select objects to define block\\n    var go = new Rhino.Input.Custom.GetObject();\\n    go.SetCommandPrompt( \\"Select objects to define block\\" );\\n    go.ReferenceObjectSelect = false;\\n    go.SubObjectSelect = false;\\n    go.GroupSelect = true;\\n\\n    // Phantoms, grips, lights, etc., cannot be in blocks.\\n    const ObjectType forbidden_geometry_filter = Rhino.DocObjects.ObjectType.Light |\\n                                                 Rhino.DocObjects.ObjectType.Grip | Rhino.DocObjects.ObjectType.Phantom;\\n    const ObjectType geometry_filter = forbidden_geometry_filter ^ Rhino.DocObjects.ObjectType.AnyObject;\\n    go.GeometryFilter = geometry_filter;\\n    go.GetMultiple(1, 0);\\n    if (go.CommandResult() != Rhino.Commands.Result.Success)\\n      return go.CommandResult();\\n\\n    // Block base point\\n    Rhino.Geometry.Point3d base_point;\\n    var rc = Rhino.Input.RhinoGet.GetPoint(\\"Block base point\\", false, out base_point);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n\\n    // Block definition name\\n    string idef_name = \\"\\";\\n    rc = Rhino.Input.RhinoGet.GetString(\\"Block definition name\\", false, ref idef_name);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n    // Validate block name\\n    idef_name = idef_name.Trim();\\n    if (string.IsNullOrEmpty(idef_name))\\n      return Rhino.Commands.Result.Nothing;\\n\\n    // See if block name already exists\\n    Rhino.DocObjects.InstanceDefinition existing_idef = doc.InstanceDefinitions.Find(idef_name, true);\\n    if (existing_idef != null)\\n    {\\n      Rhino.RhinoApp.WriteLine(\\"Block definition {0} already exists\\", idef_name);\\n      return Rhino.Commands.Result.Nothing;\\n    }\\n\\n    // Gather all of the selected objects\\n    var geometry = new System.Collections.Generic.List<Rhino.Geometry.GeometryBase>();\\n    var attributes = new System.Collections.Generic.List<Rhino.DocObjects.ObjectAttributes>();\\n    for (int i = 0; i < go.ObjectCount; i++)\\n    {\\n      var rhinoObject = go.Object(i).Object();\\n      if (rhinoObject != null)\\n      {\\n        geometry.Add(rhinoObject.Geometry);\\n        attributes.Add(rhinoObject.Attributes);\\n      }\\n    }\\n\\n    // Gather all of the selected objects\\n    int idef_index = doc.InstanceDefinitions.Add(idef_name, string.Empty, base_point, geometry, attributes);\\n\\n    if( idef_index < 0 )\\n    {\\n      Rhino.RhinoApp.WriteLine(\\"Unable to create block definition\\", idef_name);\\n      return Rhino.Commands.Result.Failure;\\n    }\\n    return Rhino.Commands.Result.Failure;\\n  }\\n}\\n","members":[["Rhino.Input.Custom.GetObject","bool ReferenceObjectSelect"],["Rhino.DocObjects.Tables.InstanceDefinitionTable","int Add(string name, string description, Point3d basePoint, IEnumerable<GeometryBase> geometry, IEnumerable<ObjectAttributes> attributes)"],["Rhino.DocObjects.Tables.InstanceDefinitionTable","InstanceDefinition Find(string instanceDefinitionName)"],["Rhino.DocObjects.Tables.InstanceDefinitionTable","InstanceDefinition Find(string instanceDefinitionName, bool ignoreDeletedInstanceDefinitions)"]]},{"name":"Createmeshfrombrep.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Input;\\nusing Rhino.Geometry;\\nusing Rhino.DocObjects;\\n\\nnamespace examples_cs\\n{\\n  public class CreateMeshFromBrepCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csCreateMeshFromBrep\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef obj_ref;\\n      var rc = RhinoGet.GetOneObject(\\"Select surface or polysurface to mesh\\", true, ObjectType.Surface | ObjectType.PolysrfFilter, out obj_ref);\\n      if (rc != Result.Success)\\n        return rc;\\n      var brep = obj_ref.Brep();\\n      if (null == brep)\\n        return Result.Failure;\\n\\n      // you could choose anyone of these for example\\n      var jagged_and_faster = MeshingParameters.Coarse;\\n      var smooth_and_slower = MeshingParameters.Smooth;\\n      var default_mesh_params = MeshingParameters.Default;\\n      var minimal = MeshingParameters.Minimal;\\n\\n      var meshes = Mesh.CreateFromBrep(brep, smooth_and_slower);\\n      if (meshes == null || meshes.Length == 0)\\n        return Result.Failure;\\n\\n      var brep_mesh = new Mesh();\\n      foreach (var mesh in meshes)\\n        brep_mesh.Append(mesh);\\n      doc.Objects.AddMesh(brep_mesh);\\n      doc.Views.Redraw();\\n\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.MeshingParameters","static MeshingParameters Coarse"],["Rhino.Geometry.MeshingParameters","static MeshingParameters Default"],["Rhino.Geometry.MeshingParameters","static MeshingParameters Minimal"],["Rhino.Geometry.MeshingParameters","static MeshingParameters Smooth"],["Rhino.Geometry.Mesh","static Mesh[] CreateFromBrep(Brep brep, MeshingParameters meshingParameters)"],["Rhino.Geometry.Mesh","void Append(Mesh other)"]]},{"name":"Createsurfaceexample.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Geometry;\\n\\nnamespace examples_cs\\n{\\n  public class CreateSurfaceFromPointsAndKnotsCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csCreateSurfaceFromPointsAndKnots\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      const bool is_rational = false;\\n      const int number_of_dimensions = 3;\\n      const int u_degree = 2;\\n      const int v_degree = 3;\\n      const int u_control_point_count = 3;\\n      const int v_control_point_count = 5;\\n     \\n      // The knot vectors do NOT have the 2 superfluous knots\\n      // at the start and end of the knot vector.  If you are\\n      // coming from a system that has the 2 superfluous knots,\\n      // just ignore them when creating NURBS surfaces.\\n      var u_knots = new double[u_control_point_count + u_degree - 1];\\n      var v_knots = new double[v_control_point_count + v_degree - 1];\\n     \\n      // make up a quadratic knot vector with no interior knots\\n      u_knots[0] = u_knots[1] = 0.0;\\n      u_knots[2] = u_knots[3] = 1.0;\\n     \\n      // make up a cubic knot vector with one simple interior knot\\n      v_knots[0] = v_knots[1] = v_knots[2] = 0.0;\\n      v_knots[3] = 1.5;\\n      v_knots[4] = v_knots[5] = v_knots[6] = 2.0;\\n     \\n      // Rational control points can be in either homogeneous\\n      // or euclidean form. Non-rational control points do not\\n      // need to specify a weight.  \\n      var control_points = new Point3d[u_control_point_count, v_control_point_count];\\n\\n      for (int u = 0; u < u_control_point_count; u++)\\n      {\\n        for (int v = 0; v < v_control_point_count; v++)\\n        {\\n          control_points[u,v] = new Point3d(u, v, u-v);\\n        }\\n      }\\n     \\n      // creates internal uninitialized arrays for \\n      // control points and knots\\n      var nurbs_surface = NurbsSurface.Create(\\n        number_of_dimensions,\\n        is_rational,\\n        u_degree + 1,\\n        v_degree + 1,\\n        u_control_point_count,\\n        v_control_point_count\\n        );\\n     \\n      // add the knots\\n      for (int u = 0;  u < nurbs_surface.KnotsU.Count; u++)\\n        nurbs_surface.KnotsU[u] = u_knots[u];\\n      for (int v = 0; v < nurbs_surface.KnotsV.Count; v++)\\n        nurbs_surface.KnotsV[v] = v_knots[v];\\n\\n      // add the control points\\n      for (int u = 0; u < nurbs_surface.Points.CountU; u++)\\n      {\\n        for (int v = 0; v < nurbs_surface.Points.CountV; v++)\\n        {\\n          nurbs_surface.Points.SetControlPoint(u, v, control_points[u, v]);\\n        }\\n      }\\n\\n      if (nurbs_surface.IsValid)\\n      {\\n        doc.Objects.AddSurface(nurbs_surface);\\n        doc.Views.Redraw();\\n        return Result.Success;\\n      }\\n      return Result.Failure;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.NurbsSurface","NurbsSurfaceKnotList KnotsU"],["Rhino.Geometry.NurbsSurface","NurbsSurfaceKnotList KnotsV"],["Rhino.Geometry.NurbsSurface","NurbsSurfacePointList Points"],["Rhino.Geometry.NurbsSurface","static NurbsSurface Create(int dimension, bool isRational, int order0, int order1, int controlPointCount0, int controlPointCount1)"]]},{"name":"Crvdeviation.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.DocObjects;\\nusing Rhino.Geometry;\\nusing System.Drawing;\\nusing Rhino.Input;\\n\\nnamespace examples_cs\\n{\\n  class DeviationConduit : Rhino.Display.DisplayConduit\\n  {\\n    private readonly Curve m_curve_a;\\n    private readonly Curve m_curve_b;\\n    private readonly Point3d m_min_dist_point_a ;\\n    private readonly Point3d m_min_dist_point_b ;\\n    private readonly Point3d m_max_dist_point_a ;\\n    private readonly Point3d m_max_dist_point_b ;\\n\\n    public DeviationConduit(Curve curveA, Curve curveB, Point3d minDistPointA, Point3d minDistPointB, Point3d maxDistPointA, Point3d maxDistPointB)\\n    {\\n      m_curve_a = curveA;\\n      m_curve_b = curveB;\\n      m_min_dist_point_a = minDistPointA;\\n      m_min_dist_point_b = minDistPointB;\\n      m_max_dist_point_a = maxDistPointA;\\n      m_max_dist_point_b = maxDistPointB;\\n    }\\n\\n    protected override void DrawForeground(Rhino.Display.DrawEventArgs e)\\n    {\\n      e.Display.DrawCurve(m_curve_a, Color.Red);\\n      e.Display.DrawCurve(m_curve_b, Color.Red);\\n\\n      e.Display.DrawPoint(m_min_dist_point_a, Color.LawnGreen);\\n      e.Display.DrawPoint(m_min_dist_point_b, Color.LawnGreen);\\n      e.Display.DrawLine(new Line(m_min_dist_point_a, m_min_dist_point_b), Color.LawnGreen);\\n      e.Display.DrawPoint(m_max_dist_point_a, Color.Red);\\n      e.Display.DrawPoint(m_max_dist_point_b, Color.Red);\\n      e.Display.DrawLine(new Line(m_max_dist_point_a, m_max_dist_point_b), Color.Red);\\n    }\\n  }\\n\\n\\n  public class CurveDeviationCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csCurveDeviation\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      doc.Objects.UnselectAll();\\n\\n      ObjRef obj_ref1;\\n      var rc1 = RhinoGet.GetOneObject(\\"first curve\\", true, ObjectType.Curve, out obj_ref1);\\n      if (rc1 != Result.Success)\\n        return rc1;\\n      Curve curve_a = null;\\n      if (obj_ref1 != null)\\n        curve_a = obj_ref1.Curve();\\n      if (curve_a == null)\\n        return Result.Failure;\\n\\n      // Since you already selected a curve if you don\'t unselect it\\n      // the next GetOneObject won\'t stop as it considers that curve \\n      // input, i.e., curveA and curveB will point to the same curve.\\n      // Another option would be to use an instance of Rhino.Input.Custom.GetObject\\n      // instead of Rhino.Input.RhinoGet as GetObject has a DisablePreSelect() method.\\n      doc.Objects.UnselectAll();\\n\\n      ObjRef obj_ref2;\\n      var rc2 = RhinoGet.GetOneObject(\\"second curve\\", true, ObjectType.Curve, out obj_ref2);\\n      if (rc2 != Result.Success)\\n        return rc2;\\n      Curve curve_b = null;\\n      if (obj_ref2 != null)\\n        curve_b = obj_ref2.Curve();\\n      if (curve_b == null)\\n        return Result.Failure;\\n\\n      var tolerance = doc.ModelAbsoluteTolerance;\\n\\n      double max_distance;\\n      double max_distance_parameter_a;\\n      double max_distance_parameter_b;\\n      double min_distance;\\n      double min_distance_parameter_a;\\n      double min_distance_parameter_b;\\n\\n      DeviationConduit conduit;\\n      if (!Curve.GetDistancesBetweenCurves(curve_a, curve_b, tolerance, out max_distance, \\n                out max_distance_parameter_a, out max_distance_parameter_b,\\n                out min_distance, out min_distance_parameter_a, out min_distance_parameter_b))\\n      {\\n        RhinoApp.WriteLine(\\"Unable to find overlap intervals.\\");\\n        return Result.Success;\\n      }\\n      else\\n      {\\n        if (min_distance <= RhinoMath.ZeroTolerance)\\n          min_distance = 0.0;\\n        var max_dist_pt_a = curve_a.PointAt(max_distance_parameter_a);\\n        var max_dist_pt_b = curve_b.PointAt(max_distance_parameter_b);\\n        var min_dist_pt_a = curve_a.PointAt(min_distance_parameter_a);\\n        var min_dist_pt_b = curve_b.PointAt(min_distance_parameter_b);\\n\\n        conduit = new DeviationConduit(curve_a, curve_b, min_dist_pt_a, min_dist_pt_b, max_dist_pt_a, max_dist_pt_b) {Enabled = true};\\n        doc.Views.Redraw();\\n\\n        RhinoApp.WriteLine(\\"Minimum deviation = {0}   pointA({1}), pointB({2})\\", min_distance, min_dist_pt_a, min_dist_pt_b);\\n        RhinoApp.WriteLine(\\"Maximum deviation = {0}   pointA({1}), pointB({2})\\", max_distance, max_dist_pt_a, max_dist_pt_b);\\n      }\\n\\n      var str = \\"\\";\\n      RhinoGet.GetString(\\"Press Enter when done\\", true, ref str);\\n      conduit.Enabled = false;\\n\\n      return Result.Success;\\n    }\\n  }\\n}\\n","members":[["Rhino.Geometry.Curve","static bool GetDistancesBetweenCurves(Curve curveA, Curve curveB, double tolerance, out double maxDistance, out double maxDistanceParameterA, out double maxDistanceParameterB, out double minDistance, out double minDistanceParameterA, out double minDistanceParameterB)"],["Rhino.DocObjects.Tables.ObjectTable","int UnselectAll()"]]},{"name":"Curveboundingbox.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result CurveBoundingBox(Rhino.RhinoDoc doc)\\n  {\\n    // Select a curve object\\n    Rhino.DocObjects.ObjRef rhObject;\\n    var rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select curve\\", false, Rhino.DocObjects.ObjectType.Curve, out rhObject);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n\\n    // Validate selection\\n    var curve = rhObject.Curve();\\n    if (curve == null)\\n      return Rhino.Commands.Result.Failure;\\n\\n    // Get the active view\'s construction plane\\n    var view = doc.Views.ActiveView;\\n    if (view == null)\\n      return Rhino.Commands.Result.Failure;\\n    var plane = view.ActiveViewport.ConstructionPlane();\\n\\n    // Compute the tight bounding box of the curve in world coordinates\\n    var bbox = curve.GetBoundingBox(true);\\n    if (!bbox.IsValid)\\n      return Rhino.Commands.Result.Failure;\\n\\n    // Print the min and max box coordinates in world coordinates\\n    Rhino.RhinoApp.WriteLine(\\"World min: {0}\\", bbox.Min);\\n    Rhino.RhinoApp.WriteLine(\\"World max: {0}\\", bbox.Max);\\n\\n    // Compute the tight bounding box of the curve based on the \\n    // active view\'s construction plane\\n    bbox = curve.GetBoundingBox(plane);\\n\\n    // Print the min and max box coordinates in cplane coordinates\\n    Rhino.RhinoApp.WriteLine(\\"CPlane min: {0}\\", bbox.Min);\\n    Rhino.RhinoApp.WriteLine(\\"CPlane max: {0}\\", bbox.Max);\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Geometry.GeometryBase","BoundingBox GetBoundingBox(bool accurate)"],["Rhino.Geometry.GeometryBase","BoundingBox GetBoundingBox(Plane plane)"]]},{"name":"Curvebrepbox.cs","code":"using Rhino;\\nusing Rhino.Geometry;\\nusing Rhino.Commands;\\nusing Rhino.Input;\\nusing Rhino.DocObjects;\\n\\nnamespace examples_cs\\n{\\n  public class BrepFromCurveBBoxCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csBrepFromCurveBBox\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      Rhino.DocObjects.ObjRef objref;\\n      var rc = RhinoGet.GetOneObject(\\"Select Curve\\", false, ObjectType.Curve, out objref);\\n      if( rc != Result.Success )\\n        return rc;\\n      var curve = objref.Curve();\\n\\n      var view = doc.Views.ActiveView;\\n      var plane = view.ActiveViewport.ConstructionPlane();\\n      // Create a construction plane aligned bounding box\\n      var bbox = curve.GetBoundingBox(plane);\\n\\n      if (bbox.IsDegenerate(doc.ModelAbsoluteTolerance) > 0) {\\n        RhinoApp.WriteLine(\\"the curve\'s bounding box is degenerate (flat) in at least one direction so a box cannot be created.\\");\\n        return Result.Failure;\\n      }\\n      var brep = Brep.CreateFromBox(bbox);\\n      doc.Objects.AddBrep(brep);\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.BoundingBox","int IsDegenerate(double tolerance)"],["Rhino.Geometry.Brep","static Brep CreateFromBox(BoundingBox box)"]]},{"name":"Curvereverse.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Input;\\nusing Rhino.DocObjects;\\n\\nnamespace examples_cs\\n{\\n  public class ReverseCurveCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csReverseCurve\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef[] obj_refs; \\n      var rc = RhinoGet.GetMultipleObjects(\\"Select curves to reverse\\", true, ObjectType.Curve, out obj_refs);\\n      if (rc != Result.Success)\\n        return rc;\\n\\n      foreach (var obj_ref in obj_refs)\\n      {\\n        var curve_copy = obj_ref.Curve().DuplicateCurve();\\n        if (curve_copy != null)\\n        {\\n          curve_copy.Reverse();\\n          doc.Objects.Replace(obj_ref, curve_copy);\\n        }\\n      }\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Curve","Curve DuplicateCurve()"],["Rhino.Geometry.Curve","bool Reverse()"]]},{"name":"Curvesurfaceintersect.cs","code":"using Rhino;\\nusing Rhino.Geometry;\\nusing Rhino.Geometry.Intersect;\\nusing Rhino.Input.Custom;\\nusing Rhino.DocObjects;\\nusing Rhino.Commands;\\n\\nnamespace examples_cs\\n{\\n  public class CurveSurfaceIntersectCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csCurveSurfaceIntersect\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var gs = new GetObject();\\n      gs.SetCommandPrompt(\\"select brep\\");\\n      gs.GeometryFilter = ObjectType.Brep;\\n      gs.DisablePreSelect();\\n      gs.SubObjectSelect = false;\\n      gs.Get();\\n      if (gs.CommandResult() != Result.Success)\\n        return gs.CommandResult();\\n      var brep = gs.Object(0).Brep();\\n\\n      var gc = new GetObject();\\n      gc.SetCommandPrompt(\\"select curve\\");\\n      gc.GeometryFilter = ObjectType.Curve;\\n      gc.DisablePreSelect();\\n      gc.SubObjectSelect = false;\\n      gc.Get();\\n      if (gc.CommandResult() != Result.Success)\\n        return gc.CommandResult();\\n      var curve = gc.Object(0).Curve();\\n\\n      if (brep == null || curve == null)\\n        return Result.Failure;\\n\\n      var tolerance = doc.ModelAbsoluteTolerance;\\n\\n      Point3d[] intersection_points;\\n      Curve[] overlap_curves;\\n      if (!Intersection.CurveBrep(curve, brep, tolerance, out overlap_curves, out intersection_points))\\n      {\\n        RhinoApp.WriteLine(\\"curve brep intersection failed\\");\\n        return Result.Nothing;\\n      }\\n\\n      foreach (var overlap_curve in overlap_curves)\\n        doc.Objects.AddCurve(overlap_curve);\\n      foreach (var intersection_point in intersection_points)\\n        doc.Objects.AddPoint(intersection_point);\\n\\n      RhinoApp.WriteLine(\\"{0} overlap curves, and {1} intersection points\\", overlap_curves.Length, intersection_points.Length);\\n      doc.Views.Redraw();\\n\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Intersect.Intersection","static CurveIntersections CurveSurface(Curve curve, Surface surface, double tolerance, double overlapTolerance)"],["Rhino.Geometry.Intersect.IntersectionEvent","bool IsOverlap"],["Rhino.DocObjects.Tables.ObjectTable","int Select(IEnumerable<Guid> objectIds)"]]},{"name":"Customgeometryfilter.cs","code":"using Rhino;\\nusing Rhino.Geometry;\\nusing Rhino.Commands;\\nusing Rhino.Input.Custom;\\nusing Rhino.DocObjects;\\n\\nnamespace examples_cs\\n{\\n  public class CustomGeometryFilterCommand : Command\\n  {\\n    private double m_tolerance;\\n    public override string EnglishName { get { return \\"csCustomGeometryFilter\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      m_tolerance = doc.ModelAbsoluteTolerance;\\n      \\n      // only use a custom geometry filter if no simpler filter does the job\\n\\n      // only curves\\n      var gc = new GetObject();\\n      gc.SetCommandPrompt(\\"select curve\\");\\n      gc.GeometryFilter = ObjectType.Curve;\\n      gc.DisablePreSelect();\\n      gc.SubObjectSelect = false;\\n      gc.Get();\\n      if (gc.CommandResult() != Result.Success)\\n        return gc.CommandResult();\\n      if (null == gc.Object(0).Curve())\\n        return Result.Failure;\\n      Rhino.RhinoApp.WriteLine(\\"curve was selected\\");\\n\\n      // only closed curves\\n      var gcc = new GetObject();\\n      gcc.SetCommandPrompt(\\"select closed curve\\");\\n      gcc.GeometryFilter = ObjectType.Curve;\\n      gcc.GeometryAttributeFilter = GeometryAttributeFilter.ClosedCurve;\\n      gcc.DisablePreSelect();\\n      gcc.SubObjectSelect = false;\\n      gcc.Get();\\n      if (gcc.CommandResult() != Result.Success)\\n        return gcc.CommandResult();\\n      if (null == gcc.Object(0).Curve())\\n        return Result.Failure;\\n      Rhino.RhinoApp.WriteLine(\\"closed curve was selected\\");\\n\\n      // only circles with a radius of 10\\n      var gcc10 = new GetObject();\\n      gcc10.SetCommandPrompt(\\"select circle with radius of 10\\");\\n      gc.GeometryFilter = ObjectType.Curve;\\n      gcc10.SetCustomGeometryFilter(CircleWithRadiusOf10GeometryFilter); // custom geometry filter\\n      gcc10.DisablePreSelect();\\n      gcc10.SubObjectSelect = false;\\n      gcc10.Get();\\n      if (gcc10.CommandResult() != Result.Success)\\n        return gcc10.CommandResult();\\n      if (null == gcc10.Object(0).Curve())\\n        return Result.Failure;\\n      RhinoApp.WriteLine(\\"circle with radius of 10 was selected\\");\\n\\n      return Result.Success;\\n    }\\n\\n    private bool CircleWithRadiusOf10GeometryFilter (Rhino.DocObjects.RhinoObject rhObject, GeometryBase geometry,\\n      ComponentIndex componentIndex)\\n    {\\n      bool is_circle_with_radius_of10 = false;\\n      Circle circle;\\n      if (geometry is Curve && (geometry as Curve).TryGetCircle(out circle))\\n        is_circle_with_radius_of10 = circle.Radius <= 10.0 + m_tolerance && circle.Radius >= 10.0 - m_tolerance;\\n      return is_circle_with_radius_of10;\\n    }\\n  }\\n}\\n","members":[["Rhino.Geometry.Curve","bool TryGetCircle(out Circle circle)"],["Rhino.Input.Custom.GetObject","void SetCustomGeometryFilter(GetObjectGeometryFilter filter)"]]},{"name":"Customundo.cs","code":"using System;\\nusing System.Runtime.InteropServices;\\nusing Rhino;\\n\\n[Guid(\\"954B8E21-51F2-4115-BD6B-DE67EE874C74\\")]\\npublic class ex_customundoCommand : Rhino.Commands.Command\\n{\\n  public override string EnglishName { get { return \\"cs_CustomUndoCommand\\"; } }\\n\\n  double MyFavoriteNumber { get; set; }\\n\\n  protected override Rhino.Commands.Result RunCommand(RhinoDoc doc, Rhino.Commands.RunMode mode)\\n  {\\n    // Rhino automatically sets up an undo record when a command is run,\\n    // but... the undo record is not saved if nothing changes in the\\n    // document (objects added/deleted, layers changed,...)\\n    //\\n    // If we have a command that doesn\'t change things in the document,\\n    // but we want to have our own custom undo called then we need to do\\n    // a little extra work\\n\\n    double d = MyFavoriteNumber;\\n    if (Rhino.Input.RhinoGet.GetNumber(\\"Favorite number\\", true, ref d) == Rhino.Commands.Result.Success)\\n    {\\n      double current_value = MyFavoriteNumber;\\n      doc.AddCustomUndoEvent(\\"Favorite Number\\", OnUndoFavoriteNumber, current_value);\\n      MyFavoriteNumber = d;\\n    }\\n    return Rhino.Commands.Result.Success;\\n  }\\n\\n  // event handler for custom undo\\n  void OnUndoFavoriteNumber(object sender, Rhino.Commands.CustomUndoEventArgs e)\\n  {\\n    // !!!!!!!!!!\\n    // NEVER change any setting in the Rhino document or application.  Rhino\\n    // handles ALL changes to the application and document and you will break\\n    // the Undo/Redo commands if you make any changes to the application or\\n    // document. This is meant only for your own private plug-in data\\n    // !!!!!!!!!!\\n\\n    // This function can be called either by undo or redo\\n    // In order to get redo to work, add another custom undo event with the\\n    // current value.  If you don\'t want redo to work, just skip adding\\n    // a custom undo event here\\n    double current_value = MyFavoriteNumber;\\n    e.Document.AddCustomUndoEvent(\\"Favorite Number\\", OnUndoFavoriteNumber, current_value);\\n\\n    double old_value = (double)e.Tag;\\n    RhinoApp.WriteLine(\\"Going back to your favorite = {0}\\", old_value);\\n    MyFavoriteNumber = old_value;\\n  }\\n}\\n","members":[["Rhino.RhinoDoc","bool AddCustomUndoEvent(string description, EventHandler<CustomUndoEventArgs> handler, object tag)"]]},{"name":"Dimstyle.cs","code":"using Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Commands;\\nusing Rhino.Geometry;\\n\\nnamespace examples_cs\\n{\\n  public class ChangeDimensionStyleCommand : Rhino.Commands.Command\\n  {\\n    public override string EnglishName\\n    {\\n      get { return \\"csChangeDimensionStyle\\"; }\\n    }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      foreach (var rhino_object in doc.Objects.GetObjectList(ObjectType.Annotation))\\n      {\\n        var annotation_object = rhino_object as AnnotationObjectBase;\\n        if (annotation_object == null) continue;\\n\\n        var annotation = annotation_object.Geometry as AnnotationBase;\\n        if (annotation == null) continue;\\n\\n        if (annotation.Index == doc.DimStyles.CurrentDimensionStyleIndex) continue;\\n\\n        annotation.Index = doc.DimStyles.CurrentDimensionStyleIndex;\\n        annotation_object.CommitChanges();\\n      }\\n\\n      doc.Views.Redraw();\\n\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.RhinoDoc","DimStyleTable DimStyles"],["Rhino.DocObjects.Tables.DimStyleTable","int CurrentIndex"],["Rhino.DocObjects.Tables.ObjectTable","IEnumerable<RhinoObject> GetObjectList(Type typeFilter)"]]},{"name":"Displayorder.cs","code":"using System.Collections.Generic;\\nusing System.Drawing;\\nusing System.Linq;\\nusing Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Display;\\nusing Rhino.Geometry;\\nusing Rhino.Input;\\nusing Rhino.DocObjects;\\n\\nnamespace examples_cs\\n{\\n  public class DisplayOrderCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csDisplayOrder\\"; } }\\n\\n    private List<RhinoObject> m_line_objects = new List<RhinoObject>(); \\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      // make lines thick so draw order can be easily seen\\n      var dm = DisplayModeDescription.GetDisplayModes().Single(x => x.EnglishName == \\"Wireframe\\");\\n      var original_thikcness = dm.DisplayAttributes.CurveThickness;\\n      dm.DisplayAttributes.CurveThickness = 10;\\n      DisplayModeDescription.UpdateDisplayMode(dm);\\n\\n      AddLine(Point3d.Origin, new Point3d(10,10,0), Color.Red, doc);\\n      AddLine(new Point3d(10,0,0), new Point3d(0,10,0), Color.Blue, doc);\\n      AddLine(new Point3d(8,0,0), new Point3d(8,10,0), Color.Green, doc);\\n      AddLine(new Point3d(0,3,0), new Point3d(10,3,0), Color.Yellow, doc);\\n      doc.Views.Redraw();\\n      Pause(\\"draw order: 1st line drawn in front, last line drawn in the back.  Any key to continue ...\\");\\n\\n      //all objects have a DisplayOrder of 0 by default so changing it to 1 moves it to the front.  Here we move the 2nd line (blue) to the front\\n      m_line_objects[1].Attributes.DisplayOrder = 1;\\n      m_line_objects[1].CommitChanges();\\n      doc.Views.Redraw();\\n      Pause(\\"Second (blue) line now in front.  Any key to continue ...\\");\\n\\n      for (int i = 0; i < m_line_objects.Count; i++)\\n      {\\n        m_line_objects[i].Attributes.DisplayOrder = i;\\n        m_line_objects[i].CommitChanges();\\n      }\\n      doc.Views.Redraw();\\n      Pause(\\"Reverse order of original lines, i.e., Yellow 1st and Red last.  Any key to continue ...\\");\\n\\n      // restore original line thickness\\n      dm.DisplayAttributes.CurveThickness = original_thikcness;\\n      DisplayModeDescription.UpdateDisplayMode(dm);\\n\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n\\n    private void Pause(string msg)\\n    {\\n      ObjRef obj_ref;\\n      var rc = RhinoGet.GetOneObject(msg, true, ObjectType.AnyObject, out obj_ref);\\n    }\\n\\n    private void AddLine(Point3d from, Point3d to, Color color, RhinoDoc doc)\\n    {\\n      var guid = doc.Objects.AddLine(from, to);\\n      var obj = doc.Objects.Find(guid);\\n      m_line_objects.Add(obj);\\n      obj.Attributes.ObjectColor = color;\\n      obj.Attributes.ColorSource = ObjectColorSource.ColorFromObject;\\n      obj.CommitChanges();\\n    }\\n  }\\n}","members":[["Rhino.DocObjects.ObjectAttributes","int DisplayOrder"]]},{"name":"Displayprecision.cs","code":"using Rhino;\\nusing Rhino.Input.Custom;\\nusing Rhino.Commands;\\n\\nnamespace examples_cs\\n{\\n  public class DisplayPrecisionCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csDisplayPrecision\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var gi = new GetInteger();\\n      gi.SetCommandPrompt(\\"New display precision\\");\\n      gi.SetDefaultInteger(doc.ModelDistanceDisplayPrecision);\\n      gi.SetLowerLimit(0, false);\\n      gi.SetUpperLimit(7, false);\\n      gi.Get();\\n      if (gi.CommandResult() != Result.Success)\\n        return gi.CommandResult();\\n      var distance_display_precision = gi.Number();\\n\\n      if (distance_display_precision != doc.ModelDistanceDisplayPrecision)\\n        doc.ModelDistanceDisplayPrecision = distance_display_precision;\\n\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.RhinoDoc","int ModelDistanceDisplayPrecision"]]},{"name":"Dividebylength.cs","code":"using Rhino.DocObjects;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result DivideByLengthPoints(Rhino.RhinoDoc doc)\\n  {\\n    const ObjectType filter = Rhino.DocObjects.ObjectType.Curve; \\n    Rhino.DocObjects.ObjRef objref;\\n    Rhino.Commands.Result rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select curve to divide\\", false, filter, out objref);\\n    if (rc != Rhino.Commands.Result.Success || objref == null)\\n      return rc;\\n\\n    Rhino.Geometry.Curve crv = objref.Curve();\\n    if (crv == null || crv.IsShort(Rhino.RhinoMath.ZeroTolerance))\\n      return Rhino.Commands.Result.Failure;\\n\\n    double crv_length = crv.GetLength();\\n    string s = string.Format(\\"Curve length is {0:f3}. Segment length\\", crv_length);\\n\\n    double seg_length = crv_length / 2.0;\\n    rc = Rhino.Input.RhinoGet.GetNumber(s, false, ref seg_length, 0, crv_length);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n\\n    Rhino.Geometry.Point3d[] points;\\n    crv.DivideByLength(seg_length, true, out points);\\n    if (points == null)\\n      return Rhino.Commands.Result.Failure;\\n\\n    foreach (Rhino.Geometry.Point3d point in points)\\n      doc.Objects.AddPoint(point);\\n\\n    doc.Views.Redraw();\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Geometry.Curve","static Curve[] JoinCurves(IEnumerable<Curve> inputCurves, double joinTolerance)"],["Rhino.Geometry.Curve","double[] DivideByLength(double segmentLength, bool includeEnds)"],["Rhino.Geometry.Curve","double[] DivideByLength(double segmentLength, bool includeEnds, bool reverse)"],["Rhino.Geometry.Curve","double[] DivideByLength(double segmentLength, bool includeEnds, bool reverse, out Point3d[] points)"],["Rhino.Geometry.Curve","double[] DivideByLength(double segmentLength, bool includeEnds, out Point3d[] points)"],["Rhino.Geometry.Curve","bool IsShort(double tolerance)"],["Rhino.Input.RhinoGet","static Result GetNumber(string prompt, bool acceptNothing, ref double outputNumber)"],["Rhino.Input.RhinoGet","static Result GetNumber(string prompt, bool acceptNothing, ref double outputNumber, double lowerLimit, double upperLimit)"],["Rhino.Input.RhinoGet","static Result GetOneObject(string prompt, bool acceptNothing, ObjectType filter, out ObjRef rhObject)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddPoint(Point3d point)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddPoint(Point3f point)"],["Rhino.DocObjects.Tables.ObjectTable","bool Select(Guid objectId)"]]},{"name":"Drawstring.cs","code":"using Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Geometry;\\nusing Rhino.Commands;\\nusing Rhino.Input.Custom;\\n\\nnamespace examples_cs\\n{\\n  public class DrawStringCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csDrawString\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var gp = new GetDrawStringPoint();\\n      gp.SetCommandPrompt(\\"Point\\");\\n      gp.Get();\\n      return gp.CommandResult();\\n    }\\n  }\\n\\n  public class GetDrawStringPoint : GetPoint\\n  {\\n    protected override void OnDynamicDraw(GetPointDrawEventArgs e)\\n    {\\n      base.OnDynamicDraw(e);\\n      var xform = e.Viewport.GetTransform(CoordinateSystem.World, CoordinateSystem.Screen);\\n      var current_point = e.CurrentPoint;\\n      current_point.Transform(xform);\\n      var screen_point = new Point2d(current_point.X, current_point.Y);\\n      var msg = string.Format(\\"screen {0:F}, {1:F}\\", current_point.X, current_point.Y);\\n      e.Display.Draw2dText(msg, System.Drawing.Color.Blue, screen_point, false);\\n    }\\n  }\\n}","members":[["Rhino.Display.DisplayPipeline","void Draw2dText(string text, Color color, Point2d screenCoordinate, bool middleJustified)"]]},{"name":"Dupborder.cs","code":"using System;\\nusing Rhino.DocObjects;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result DupBorder(Rhino.RhinoDoc doc)\\n  {\\n    const ObjectType filter = Rhino.DocObjects.ObjectType.Surface | Rhino.DocObjects.ObjectType.PolysrfFilter;\\n    Rhino.DocObjects.ObjRef objref;\\n    Rhino.Commands.Result rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select surface or polysurface\\", false, filter, out objref);\\n    if (rc != Rhino.Commands.Result.Success || objref == null)\\n      return rc;\\n\\n    Rhino.DocObjects.RhinoObject rhobj = objref.Object();\\n    Rhino.Geometry.Brep brep = objref.Brep();\\n    if (rhobj == null || brep == null)\\n      return Rhino.Commands.Result.Failure;\\n\\n    rhobj.Select(false);\\n    Rhino.Geometry.Curve[] curves = brep.DuplicateEdgeCurves(true);\\n    double tol = doc.ModelAbsoluteTolerance * 2.1;\\n    curves = Rhino.Geometry.Curve.JoinCurves(curves, tol);\\n    for (int i = 0; i < curves.Length; i++)\\n    {\\n      Guid id = doc.Objects.AddCurve(curves[i]);\\n      doc.Objects.Select(id);\\n    }\\n    doc.Views.Redraw();\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Geometry.Brep","Curve[] DuplicateEdgeCurves(bool nakedOnly)"]]},{"name":"Duplicateobject.cs","code":"using System;\\nusing Rhino;\\nusing Rhino.Commands;\\nusing Rhino.DocObjects;\\nusing Rhino.Input;\\n\\nnamespace examples_cs\\n{\\n  public class DuplicateObjectCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csDuplicateObject\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef obj_ref;\\n      var rc = RhinoGet.GetOneObject(\\"Select object to duplicate\\", false, ObjectType.AnyObject, out obj_ref);\\n      if (rc != Result.Success)\\n        return rc;\\n      var rhino_object = obj_ref.Object();\\n\\n      var geometry_base = rhino_object.DuplicateGeometry();\\n      if (geometry_base != null)\\n        if (doc.Objects.Add(geometry_base) != Guid.Empty)\\n          doc.Views.Redraw();\\n\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.DocObjects.RhinoObject","GeometryBase DuplicateGeometry()"]]},{"name":"Dupmeshboundary.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Input.Custom;\\nusing Rhino.DocObjects;\\n\\nnamespace examples_cs\\n{\\n  public class DupMeshBoundaryCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csDupMeshBoundary\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var gm = new GetObject();\\n      gm.SetCommandPrompt(\\"Select open mesh\\");\\n      gm.GeometryFilter = ObjectType.Mesh;\\n      gm.GeometryAttributeFilter = GeometryAttributeFilter.OpenMesh;\\n      gm.Get();\\n      if (gm.CommandResult() != Result.Success)\\n        return gm.CommandResult();\\n      var mesh = gm.Object(0).Mesh();\\n      if (mesh == null)\\n        return Result.Failure;\\n\\n      var polylines = mesh.GetNakedEdges();\\n      foreach (var polyline in polylines)\\n      {\\n        doc.Objects.AddPolyline(polyline);\\n      }\\n\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Mesh","Polyline[] GetNakedEdges()"]]},{"name":"Edgesrf.cs","code":"using System.Linq;\\nusing Rhino;\\nusing Rhino.Commands;\\nusing Rhino.DocObjects;\\nusing Rhino.Geometry;\\nusing Rhino.Input.Custom;\\n\\nnamespace examples_cs\\n{\\n  public class EdgeSrfCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csEdgeSrf\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var go = new GetObject();\\n      go.SetCommandPrompt(\\"Select 2, 3, or 4 open curves\\");\\n      go.GeometryFilter = ObjectType.Curve;\\n      go.GeometryAttributeFilter = GeometryAttributeFilter.OpenCurve;\\n      go.GetMultiple(2, 4);\\n      if (go.CommandResult() != Result.Success)\\n        return go.CommandResult();\\n\\n      var curves = go.Objects().Select(o => o.Curve());\\n\\n      var brep = Brep.CreateEdgeSurface(curves);\\n\\n      if (brep != null)\\n      {\\n        doc.Objects.AddBrep(brep);\\n        doc.Views.Redraw();\\n      }\\n\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Brep","static Brep CreateEdgeSurface(IEnumerable<Curve> curves)"]]},{"name":"Elevation.cs","code":"using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Geometry;\\nusing Rhino.Geometry.Intersect;\\nusing Rhino.Input;\\nusing Rhino.Input.Custom;\\nusing Rhino.DocObjects;\\n\\nnamespace examples_cs\\n{\\n  public class FurthestZOnSurfaceCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csFurthestZOnSurfaceGivenXY\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      #region user input\\n      // select a surface\\n      var gs = new GetObject();\\n      gs.SetCommandPrompt(\\"select surface\\");\\n      gs.GeometryFilter = ObjectType.Surface;\\n      gs.DisablePreSelect();\\n      gs.SubObjectSelect = false;\\n      gs.Get();\\n      if (gs.CommandResult() != Result.Success)\\n        return gs.CommandResult();\\n      // get the brep\\n      var brep = gs.Object(0).Brep();\\n      if (brep == null)\\n        return Result.Failure;\\n\\n      // get X and Y\\n      double x = 0.0, y = 0.0;\\n      var rc = RhinoGet.GetNumber(\\"value of X coordinate\\", true, ref x);\\n      if (rc != Result.Success)\\n        return rc;\\n      rc = RhinoGet.GetNumber(\\"value of Y coordinate\\", true, ref y);\\n      if (rc != Result.Success)\\n        return rc;\\n      #endregion\\n      \\n      // an earlier version of this sample used a curve-brep intersection to find Z\\n      //var maxZ = maxZIntersectionMethod(brep, x, y, doc.ModelAbsoluteTolerance);\\n\\n      // projecting points is another way to find Z\\n      var max_z = MaxZProjectionMethod(brep, x, y, doc.ModelAbsoluteTolerance);\\n\\n      if (max_z != null)\\n      {\\n        RhinoApp.WriteLine(\\"Maximum surface Z coordinate at X={0}, Y={1} is {2}\\", x, y, max_z);\\n        doc.Objects.AddPoint(new Point3d(x, y, max_z.Value));\\n        doc.Views.Redraw();\\n      }\\n      else\\n        RhinoApp.WriteLine(\\"no maximum surface Z coordinate at X={0}, Y={1} found.\\", x, y);\\n\\n      return Result.Success;\\n    }\\n\\n    private static double? MaxZProjectionMethod(Brep brep, double x, double y, double tolerance)\\n    {\\n      double? max_z = null;\\n      var breps = new List<Brep> {brep};\\n      var points = new List<Point3d> {new Point3d(x, y, 0)};\\n      // grab all the points projected in Z dir.  Aggregate finds furthest Z from XY plane\\n      try {\\n        max_z = (from pt in Intersection.ProjectPointsToBreps(breps, points, new Vector3d(0, 0, 1), tolerance) select pt.Z)\\n                // Here you might be tempted to use .Max() to get the largest Z value but that doesn\'t work because\\n                // Z might be negative.  This custom aggregate returns the max Z independant of the sign.  If it had a name\\n                // it could be MaxAbs()\\n                .Aggregate((z1, z2) => Math.Abs(z1) > Math.Abs(z2) ? z1 : z2);\\n      } catch (InvalidOperationException) {/*Sequence contains no elements*/}\\n      return max_z;\\n    }\\n\\n    private double? MaxZIntersectionMethod(Brep brep, double x, double y, double tolerance)\\n    {\\n      double? max_z = null;\\n\\n      var bbox = brep.GetBoundingBox(true);\\n      var max_dist_from_xy = (from corner in bbox.GetCorners() select corner.Z)\\n                              // furthest Z from XY plane.\\n                              // Here you might be tempted to use .Max() to get the largest Z value but that doesn\'t work because\\n                              // Z might be negative.  This custom aggregate returns the max Z independant of the sign.  If it had a name\\n                              // it could be MaxAbs()\\n                              .Aggregate((z1, z2) => Math.Abs(z1) > Math.Abs(z2) ? z1 : z2);\\n      // multiply distance by 2 to make sure line intersects completely\\n      var line_curve = new LineCurve(new Point3d(x, y, 0), new Point3d(x, y, max_dist_from_xy*2));\\n\\n      Curve[] overlap_curves;\\n      Point3d[] inter_points;\\n      if (Intersection.CurveBrep(line_curve, brep, tolerance, out overlap_curves, out inter_points))\\n      {\\n        if (overlap_curves.Length > 0 || inter_points.Length > 0)\\n        {\\n          // grab all the points resulting frem the intersection. \\n          //    1st set: points from overlapping curves, \\n          //    2nd set: points when there was no overlap\\n          //    .Aggregate: furthest Z from XY plane.\\n          max_z = (from c in overlap_curves select Math.Abs(c.PointAtEnd.Z) > Math.Abs(c.PointAtStart.Z) ? c.PointAtEnd.Z : c.PointAtStart.Z)\\n                  .Union\\n                  (from p in inter_points select p.Z)\\n                   // Here you might be tempted to use .Max() to get the largest Z value but that doesn\'t work because\\n                   // Z might be negative.  This custom aggregate returns the max Z independant of the sign.  If it had a name\\n                   // it could be MaxAbs()\\n                  .Aggregate((z1, z2) => Math.Abs(z1) > Math.Abs(z2) ? z1 : z2);\\n        }\\n      }\\n      return max_z;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.BoundingBox","Point3d[] GetCorners()"],["Rhino.Geometry.Intersect.Intersection","static bool CurveBrep(Curve curve, Brep brep, double tolerance, out Curve[] overlapCurves, out Point3d[] intersectionPoints)"]]},{"name":"Evnormal.cs","code":"using Rhino;\\nusing Rhino.Input.Custom;\\nusing Rhino.DocObjects;\\nusing Rhino.Commands;\\n\\nnamespace examples_cs\\n{\\n  public class NormalDirectionOfBrepFaceCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csDetermineNormalDirectionOfBrepFace\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      // select a surface\\n      var gs = new GetObject();\\n      gs.SetCommandPrompt(\\"select surface\\");\\n      gs.GeometryFilter = ObjectType.Surface;\\n      gs.DisablePreSelect();\\n      gs.SubObjectSelect = false;\\n      gs.Get();\\n      if (gs.CommandResult() != Result.Success)\\n        return gs.CommandResult();\\n      // get the selected face\\n      var face = gs.Object(0).Face();\\n      if (face == null)\\n        return Result.Failure;\\n\\n      // pick a point on the surface.  Constain\\n      // picking to the face.\\n      var gp = new GetPoint();\\n      gp.SetCommandPrompt(\\"select point on surface\\");\\n      gp.Constrain(face, false);\\n      gp.Get();\\n      if (gp.CommandResult() != Result.Success)\\n        return gp.CommandResult();\\n\\n      // get the parameters of the point on the\\n      // surface that is clesest to gp.Point()\\n      double u, v;\\n      if (face.ClosestPoint(gp.Point(), out u, out v))\\n      {\\n        var direction = face.NormalAt(u, v);\\n        if (face.OrientationIsReversed)\\n          direction.Reverse();\\n        RhinoApp.WriteLine(\\n          string.Format(\\n            \\"Surface normal at uv({0:f},{1:f}) = ({2:f},{3:f},{4:f})\\", \\n            u, v, direction.X, direction.Y, direction.Z));\\n      }\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.BrepFace","bool OrientationIsReversed"],["Rhino.Geometry.Surface","Vector3d NormalAt(double u, double v)"]]},{"name":"Explodehatch.cs","code":"using Rhino.DocObjects;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result ExplodeHatch(Rhino.RhinoDoc doc)\\n  {\\n    const ObjectType filter = Rhino.DocObjects.ObjectType.Hatch;\\n    Rhino.DocObjects.ObjRef objref;\\n    Rhino.Commands.Result rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select hatch to explode\\", false, filter, out objref);\\n    if (rc != Rhino.Commands.Result.Success || objref == null)\\n      return rc;\\n\\n    Rhino.Geometry.Hatch hatch = objref.Geometry() as Rhino.Geometry.Hatch;\\n    if (null == hatch)\\n      return Rhino.Commands.Result.Failure;\\n\\n    Rhino.Geometry.GeometryBase[] hatch_geom = hatch.Explode();\\n    if (null != hatch_geom)\\n    {\\n      for (int i = 0; i < hatch_geom.Length; i++)\\n      {\\n        Rhino.Geometry.GeometryBase geom = hatch_geom[i];\\n        if (null != geom)\\n        {\\n          switch (geom.ObjectType)\\n          {\\n            case Rhino.DocObjects.ObjectType.Point:\\n              {\\n                Rhino.Geometry.Point point = geom as Rhino.Geometry.Point;\\n                if (null != point)\\n                  doc.Objects.AddPoint(point.Location);\\n              }\\n              break;\\n            case Rhino.DocObjects.ObjectType.Curve:\\n              {\\n                Rhino.Geometry.Curve curve = geom as Rhino.Geometry.Curve;\\n                if (null != curve)\\n                  doc.Objects.AddCurve(curve);\\n              }\\n              break;\\n            case Rhino.DocObjects.ObjectType.Brep:\\n              {\\n                Rhino.Geometry.Brep brep = geom as Rhino.Geometry.Brep;\\n                if (null != brep)\\n                  doc.Objects.AddBrep(brep);\\n              }\\n              break;\\n          }\\n        }\\n      }\\n    }\\n\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Geometry.Hatch","GeometryBase[] Explode()"]]},{"name":"Extendcurve.cs","code":"using System.Linq;\\nusing Rhino;\\nusing Rhino.Geometry;\\nusing Rhino.DocObjects;\\nusing Rhino.Commands;\\nusing Rhino.Input;\\nusing Rhino.Input.Custom;\\n\\nnamespace examples_cs\\n{\\n  public class ExtendCurveCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csExtendCurve\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef[] boundary_obj_refs;\\n      var rc = RhinoGet.GetMultipleObjects(\\"Select boundary objects\\", false, ObjectType.AnyObject, out boundary_obj_refs);\\n      if (rc != Result.Success)\\n        return rc;\\n      if (boundary_obj_refs == null || boundary_obj_refs.Length == 0)\\n        return Result.Nothing;\\n\\n      var gc = new GetObject();\\n      gc.SetCommandPrompt(\\"Select curve to extend\\");\\n      gc.GeometryFilter = ObjectType.Curve;\\n      gc.GeometryAttributeFilter = GeometryAttributeFilter.OpenCurve;\\n      gc.Get();\\n      if (gc.CommandResult() != Result.Success)\\n        return gc.CommandResult();\\n      var curve_obj_ref = gc.Object(0);\\n\\n      var curve = curve_obj_ref.Curve();\\n      if (curve == null) return Result.Failure;\\n      double t;\\n      if (!curve.ClosestPoint(curve_obj_ref.SelectionPoint(), out t))\\n        return Result.Failure;\\n      var curve_end = t <= curve.Domain.Mid ? CurveEnd.Start : CurveEnd.End;\\n\\n      var geometry = boundary_obj_refs.Select(obj=> obj.Geometry());\\n      var extended_curve = curve.Extend(curve_end, CurveExtensionStyle.Line, geometry);\\n      if (extended_curve != null && extended_curve.IsValid)\\n      {\\n        if (!doc.Objects.Replace(curve_obj_ref.ObjectId, extended_curve))\\n          return Result.Failure;\\n        doc.Views.Redraw();\\n      }\\n      else\\n      {\\n        RhinoApp.WriteLine(\\"No boundary object was intersected so curve not extended\\");\\n        return Result.Nothing;\\n      }\\n\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Curve","Curve Extend(CurveEnd side, CurveExtensionStyle style, IEnumerable<GeometryBase> geometry)"],["Rhino.Geometry.Interval","double Mid"]]},{"name":"Extractisocurve.cs","code":"using Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Commands;\\nusing Rhino.Input;\\nusing Rhino.Input.Custom;\\nusing Rhino.Geometry;\\n\\nnamespace examples_cs\\n{\\n  public class ExtractIsocurveCommand : Rhino.Commands.Command\\n  {\\n    public override string EnglishName\\n    {\\n      get { return \\"csExtractIsocurve\\"; }\\n    }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef obj_ref;\\n      var rc = RhinoGet.GetOneObject(\\"Select surface\\", false, ObjectType.Surface, out obj_ref);\\n      if (rc != Result.Success || obj_ref == null)\\n        return rc;\\n      var surface = obj_ref.Surface();\\n\\n      var gp = new GetPoint();\\n      gp.SetCommandPrompt(\\"Point on surface\\");\\n      gp.Constrain(surface, false);\\n      var option_toggle = new OptionToggle(false, \\"U\\", \\"V\\");\\n      gp.AddOptionToggle(\\"Direction\\", ref option_toggle);\\n      Point3d point = Point3d.Unset;\\n      while (true)\\n      {\\n        var grc = gp.Get();\\n        if (grc == GetResult.Option)\\n          continue;\\n        else if (grc == GetResult.Point)\\n        {\\n          point = gp.Point();\\n          break;\\n        }\\n        else\\n          return Result.Nothing;\\n      }\\n      if (point == Point3d.Unset)\\n        return Result.Nothing;\\n\\n      int direction = option_toggle.CurrentValue ? 1 : 0; // V : U\\n      double u_parameter, v_parameter;\\n      if (!surface.ClosestPoint(point, out u_parameter, out v_parameter)) return Result.Failure;\\n\\n      var iso_curve = surface.IsoCurve(direction, direction == 1 ? u_parameter : v_parameter);\\n      if (iso_curve == null) return Result.Failure;\\n\\n      doc.Objects.AddCurve(iso_curve);\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Surface","Curve IsoCurve(int direction, double constantParameter)"]]},{"name":"Extractthumbnail.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Input;\\nusing Rhino.Input.Custom;\\nusing System;\\nusing System.Windows;\\nusing System.Windows.Controls;\\n\\nnamespace examples_cs\\n{\\n  public class ExtractThumbnailCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csExtractThumbnail\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var gf = RhinoGet.GetFileName(GetFileNameMode.OpenImage, \\"*.3dm\\", \\"select file\\", null);\\n      if (gf == string.Empty || !System.IO.File.Exists(gf))\\n        return Result.Cancel;\\n\\n      var bitmap = Rhino.FileIO.File3dm.ReadPreviewImage(gf);\\n      // convert System.Drawing.Bitmap to BitmapSource\\n      var image_source = System.Windows.Interop.Imaging.CreateBitmapSourceFromHBitmap(bitmap.GetHbitmap(), IntPtr.Zero,\\n        Int32Rect.Empty, System.Windows.Media.Imaging.BitmapSizeOptions.FromEmptyOptions());\\n\\n      // show in WPF window\\n      var window = new Window();\\n      var image = new Image {Source = image_source};\\n      window.Content = image;\\n      window.Show();\\n\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.FileIO.File3dm","static System.Drawing.Bitmap ReadPreviewImage(string path)"],["Rhino.Input.RhinoGet","static string GetFileName(GetFileNameMode mode, string defaultName, string title, object parent)"],["Rhino.Input.RhinoGet","static string GetFileName(GetFileNameMode mode, string defaultName, string title, object parent, BitmapFileTypes fileTypes)"]]},{"name":"Filletcurves.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Geometry;\\nusing Rhino.Input;\\nusing Rhino.DocObjects;\\nusing Rhino.Input.Custom;\\n\\nnamespace examples_cs\\n{\\n  public class FilletCurvesCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csFilletCurves\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var gc1 = new GetObject();\\n      gc1.DisablePreSelect();\\n      gc1.SetCommandPrompt(\\"Select first curve to fillet (close to the end you want to fillet)\\");\\n      gc1.GeometryFilter = ObjectType.Curve;\\n      gc1.GeometryAttributeFilter = GeometryAttributeFilter.OpenCurve;\\n      gc1.Get();\\n      if (gc1.CommandResult() != Result.Success)\\n        return gc1.CommandResult();\\n      var curve1_obj_ref = gc1.Object(0);\\n      var curve1 = curve1_obj_ref.Curve();\\n      if (curve1 == null) return Result.Failure;\\n      var curve1_point_near_end = curve1_obj_ref.SelectionPoint();\\n      if (curve1_point_near_end == Point3d.Unset)\\n        return Result.Failure;\\n\\n      var gc2 = new GetObject();\\n      gc2.DisablePreSelect();\\n      gc2.SetCommandPrompt(\\"Select second curve to fillet (close to the end you want to fillet)\\");\\n      gc2.GeometryFilter = ObjectType.Curve;\\n      gc2.GeometryAttributeFilter = GeometryAttributeFilter.OpenCurve;\\n      gc2.Get();\\n      if (gc2.CommandResult() != Result.Success)\\n        return gc2.CommandResult();\\n      var curve2_obj_ref = gc2.Object(0);\\n      var curve2 = curve2_obj_ref.Curve();\\n      if (curve2 == null) return Result.Failure;\\n      var curve2_point_near_end = curve2_obj_ref.SelectionPoint();\\n      if (curve2_point_near_end == Point3d.Unset)\\n        return Result.Failure;\\n\\n      double radius = 0;\\n      var rc = RhinoGet.GetNumber(\\"fillet radius\\", false, ref radius);\\n      if (rc != Result.Success) return rc;\\n\\n      var join = false;\\n      var trim = true;\\n      var arc_extension = true;\\n      var fillet_curves = Curve.CreateFilletCurves(curve1, curve1_point_near_end, curve2, curve2_point_near_end, radius,\\n        join, trim, arc_extension, doc.ModelAbsoluteTolerance, doc.ModelAngleToleranceDegrees);\\n      if (fillet_curves == null /*|| fillet_curves.Length != 3*/)\\n        return Result.Failure;\\n\\n      foreach(var fillet_curve in fillet_curves)\\n        doc.Objects.AddCurve(fillet_curve);\\n      doc.Views.Redraw();\\n      return rc;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Curve","static Curve[] CreateFilletCurves(Curve curve0, Point3d point0, Curve curve1, Point3d point1, double radius, bool join, bool trim, bool arcExtension, double tolerance, double angleTolerance)"]]},{"name":"Findobjectsbyname.cs","code":"using System;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result FindObjectsByName(Rhino.RhinoDoc doc)\\n  {\\n    const string name = \\"abc\\";\\n    Rhino.DocObjects.ObjectEnumeratorSettings settings = new Rhino.DocObjects.ObjectEnumeratorSettings();\\n    settings.NameFilter = name;\\n    System.Collections.Generic.List<Guid> ids = new System.Collections.Generic.List<Guid>();\\n    foreach (Rhino.DocObjects.RhinoObject rhObj in doc.Objects.GetObjectList(settings))\\n      ids.Add(rhObj.Id);\\n\\n    if (ids.Count == 0)\\n    {\\n      Rhino.RhinoApp.WriteLine(\\"No objects with the name \\" + name);\\n      return Rhino.Commands.Result.Failure;\\n    }\\n\\n    Rhino.RhinoApp.WriteLine(\\"Found {0} objects\\", ids.Count);\\n    foreach (Guid id in ids)\\n      Rhino.RhinoApp.WriteLine(\\"  {0}\\", id);\\n\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.DocObjects.ObjectEnumeratorSettings","ObjectEnumeratorSettings()"],["Rhino.DocObjects.ObjectEnumeratorSettings","string NameFilter"]]},{"name":"Getpointdynamicdraw.cs","code":"using Rhino;\\nusing Rhino.Geometry;\\nusing Rhino.Commands;\\nusing Rhino.Input.Custom;\\n\\nnamespace examples_cs\\n{\\n  public class GetPointDynamicDrawCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csGetPointDynamicDraw\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var gp = new GetPoint();\\n      gp.SetCommandPrompt(\\"Center point\\");\\n      gp.Get();\\n      if (gp.CommandResult() != Result.Success)\\n        return gp.CommandResult();\\n      var center_point = gp.Point();\\n      if (center_point == Point3d.Unset)\\n        return Result.Failure;\\n\\n      var gcp = new GetCircleRadiusPoint(center_point);\\n      gcp.SetCommandPrompt(\\"Radius\\");\\n      gcp.ConstrainToConstructionPlane(false);\\n      gcp.SetBasePoint(center_point, true);\\n      gcp.DrawLineFromPoint(center_point, true);\\n      gcp.Get();\\n      if (gcp.CommandResult() != Result.Success)\\n        return gcp.CommandResult();\\n\\n      var radius = center_point.DistanceTo(gcp.Point());\\n      var cplane = doc.Views.ActiveView.ActiveViewport.ConstructionPlane();\\n      doc.Objects.AddCircle(new Circle(cplane, center_point, radius));\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n\\n  public class GetCircleRadiusPoint : GetPoint\\n  {\\n    private Point3d m_center_point;\\n \\n    public GetCircleRadiusPoint(Point3d centerPoint)\\n    {\\n      m_center_point = centerPoint;\\n    }\\n\\n    protected override void OnDynamicDraw(GetPointDrawEventArgs e)\\n    {\\n      base.OnDynamicDraw(e);\\n      var cplane = e.RhinoDoc.Views.ActiveView.ActiveViewport.ConstructionPlane();\\n      var radius = m_center_point.DistanceTo(e.CurrentPoint);\\n      var circle = new Circle(cplane, m_center_point, radius);\\n      e.Display.DrawCircle(circle, System.Drawing.Color.Black);\\n    }\\n  }\\n}","members":[["Rhino.Display.DisplayPipeline","void DrawCircle(Circle circle, Color color)"]]},{"name":"Gettext.cs","code":"using Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Commands;\\nusing Rhino.Input.Custom;\\n\\nnamespace examples_cs\\n{\\n  public class ReadDimensionTextCommand : Rhino.Commands.Command\\n  {\\n    public override string EnglishName\\n    {\\n      get { return \\"csReadDimensionText\\"; }\\n    }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var go = new GetObject();\\n      go.SetCommandPrompt(\\"Select annotation\\");\\n      go.GeometryFilter = ObjectType.Annotation;\\n      go.Get();\\n      if (go.CommandResult() != Result.Success) \\n        return Result.Failure;\\n      var annotation = go.Object(0).Object() as AnnotationObjectBase;\\n      if (annotation == null)\\n        return Result.Failure;\\n\\n      RhinoApp.WriteLine(\\"Annotation text = {0}\\", annotation.DisplayText);\\n\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.DocObjects.AnnotationObjectBase","string DisplayText"]]},{"name":"Hatchcurve.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result HatchCurve(Rhino.RhinoDoc doc)\\n  {\\n    var go = new Rhino.Input.Custom.GetObject();\\n    go.SetCommandPrompt(\\"Select closed planar curve\\");\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve;\\n    go.GeometryAttributeFilter = Rhino.Input.Custom.GeometryAttributeFilter.ClosedCurve;\\n    go.SubObjectSelect = false;\\n    go.Get();\\n    if( go.CommandResult() != Rhino.Commands.Result.Success )\\n      return go.CommandResult();\\n\\n    var curve = go.Object(0).Curve();\\n    if( curve==null || !curve.IsClosed || !curve.IsPlanar() )\\n      return Rhino.Commands.Result.Failure;\\n\\n    string hatch_name = doc.HatchPatterns[doc.HatchPatterns.CurrentHatchPatternIndex].Name;\\n    var rc = Rhino.Input.RhinoGet.GetString(\\"Hatch pattern\\", true, ref hatch_name);\\n    if( rc!= Rhino.Commands.Result.Success )\\n      return rc;\\n    hatch_name = hatch_name.Trim();\\n    if( string.IsNullOrWhiteSpace(hatch_name) )\\n      return Rhino.Commands.Result.Nothing;\\n    int index = doc.HatchPatterns.Find(hatch_name, true);\\n    if( index < 0 )\\n    {\\n      Rhino.RhinoApp.WriteLine(\\"Hatch pattern does not exist.\\");\\n      return Rhino.Commands.Result.Nothing;\\n    }\\n\\n    var hatches = Rhino.Geometry.Hatch.Create( curve, index, 0, 1);\\n    for( int i=0; i<hatches.Length; i++ )\\n      doc.Objects.AddHatch(hatches[i]);\\n    if( hatches.Length>0 )\\n      doc.Views.Redraw();\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.RhinoDoc","HatchPatternTable HatchPatterns"],["Rhino.Geometry.Hatch","static Hatch[] Create(Curve curve, int hatchPatternIndex, double rotationRadians, double scale)"],["Rhino.Geometry.Hatch","static Hatch[] Create(Curve curve, int hatchPatternIndex, double rotationRadians, double scale, double tolerance)"],["Rhino.DocObjects.ModelComponent","string Name"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddHatch(Hatch hatch)"],["Rhino.DocObjects.Tables.HatchPatternTable","int CurrentHatchPatternIndex"],["Rhino.DocObjects.Tables.HatchPatternTable","int Find(string name, bool ignoreDeleted)"],["Rhino.DocObjects.Tables.HatchPatternTable","HatchPattern FindName(string name)"]]},{"name":"Insertknot.cs","code":"using Rhino.Commands;\\nusing Rhino.DocObjects;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result InsertKnot(Rhino.RhinoDoc doc)\\n  {\\n    const ObjectType filter = Rhino.DocObjects.ObjectType.Curve;\\n    Rhino.DocObjects.ObjRef objref;\\n    Result rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select curve for knot insertion\\", false, filter, out objref);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n    Rhino.Geometry.Curve curve = objref.Curve();\\n    if (null == curve)\\n      return Rhino.Commands.Result.Failure;\\n    Rhino.Geometry.NurbsCurve nurb = curve.ToNurbsCurve();\\n    if (null == nurb)\\n      return Rhino.Commands.Result.Failure;\\n\\n    Rhino.Input.Custom.GetPoint gp = new Rhino.Input.Custom.GetPoint();\\n    gp.SetCommandPrompt(\\"Point on curve to add knot\\");\\n    gp.Constrain(nurb, false);\\n    gp.Get();\\n    if (gp.CommandResult() == Rhino.Commands.Result.Success)\\n    {\\n      double t;\\n      Rhino.Geometry.Curve crv = gp.PointOnCurve(out t);\\n      if( crv!=null && nurb.Knots.InsertKnot(t) )\\n      {\\n        doc.Objects.Replace(objref, nurb);\\n        doc.Views.Redraw();\\n      }\\n    }\\n    return Rhino.Commands.Result.Success;  \\n  }\\n}\\n","members":[["Rhino.Input.Custom.GetPoint","bool Constrain(Curve curve, bool allowPickingPointOffObject)"],["Rhino.Input.Custom.GetPoint","Curve PointOnCurve(out double t)"],["Rhino.Geometry.Collections.NurbsCurveKnotList","bool InsertKnot(double value)"],["Rhino.DocObjects.Tables.ObjectTable","bool Replace(ObjRef objref, Curve curve)"]]},{"name":"Instancedefinitionobjects.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result InstanceDefinitionObjects(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.DocObjects.ObjRef objref;\\n    var rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select instance\\", false, Rhino.DocObjects.ObjectType.InstanceReference, out objref);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n\\n    var iref = objref.Object() as Rhino.DocObjects.InstanceObject;\\n    if (iref != null)\\n    {\\n      var idef = iref.InstanceDefinition;\\n      if (idef != null)\\n      {\\n        var rhino_objects = idef.GetObjects();\\n        for (int i = 0; i < rhino_objects.Length; i++)\\n          Rhino.RhinoApp.WriteLine(\\"Object {0} = {1}\\", i, rhino_objects[i].Id);\\n      }\\n    }\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.DocObjects.InstanceObject","InstanceDefinition InstanceDefinition"],["Rhino.DocObjects.InstanceDefinition","RhinoObject[] GetObjects()"]]},{"name":"Intersectcurves.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result IntersectCurves(Rhino.RhinoDoc doc)\\n  {\\n    // Select two curves to intersect\\n    var go = new Rhino.Input.Custom.GetObject();\\n    go.SetCommandPrompt(\\"Select two curves\\");\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve;\\n    go.GetMultiple(2, 2);\\n    if (go.CommandResult() != Rhino.Commands.Result.Success)\\n      return go.CommandResult();\\n\\n    // Validate input\\n    var curveA = go.Object(0).Curve();\\n    var curveB = go.Object(1).Curve();\\n    if (curveA == null || curveB == null)\\n      return Rhino.Commands.Result.Failure;\\n\\n    // Calculate the intersection\\n    const double intersection_tolerance = 0.001;\\n    const double overlap_tolerance = 0.0;\\n    var events = Rhino.Geometry.Intersect.Intersection.CurveCurve(curveA, curveB, intersection_tolerance, overlap_tolerance);\\n\\n    // Process the results\\n    if (events != null)\\n    {\\n      for (int i = 0; i < events.Count; i++)\\n      {\\n        var ccx_event = events[i];\\n        doc.Objects.AddPoint(ccx_event.PointA);\\n        if (ccx_event.PointA.DistanceTo(ccx_event.PointB) > double.Epsilon)\\n        {\\n          doc.Objects.AddPoint(ccx_event.PointB);\\n          doc.Objects.AddLine(ccx_event.PointA, ccx_event.PointB);\\n        }\\n      }\\n      doc.Views.Redraw();\\n    }\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Geometry.Point3f","double DistanceTo(Point3f other)"],["Rhino.Geometry.Point3d","double DistanceTo(Point3d other)"],["Rhino.DocObjects.ObjRef","Curve Curve()"],["Rhino.Geometry.Intersect.Intersection","static CurveIntersections CurveCurve(Curve curveA, Curve curveB, double tolerance, double overlapTolerance)"]]},{"name":"Intersectlinecircle.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Input;\\nusing Rhino.Geometry;\\nusing Rhino.Geometry.Intersect;\\n\\nnamespace examples_cs\\n{\\n  public class IntersectLineCircleCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csIntersectLineCircle\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      Circle circle;\\n      var rc = RhinoGet.GetCircle(out circle);\\n      if (rc != Result.Success)\\n        return rc;\\n      doc.Objects.AddCircle(circle);\\n      doc.Views.Redraw();\\n\\n      Line line;\\n      rc = RhinoGet.GetLine(out line);\\n      if (rc != Result.Success)\\n        return rc;\\n      doc.Objects.AddLine(line);\\n      doc.Views.Redraw();\\n\\n      double t1, t2;\\n      Point3d point1, point2;\\n      var line_circle_intersect = Intersection.LineCircle(line, circle, out t1, out point1, out t2, out point2);\\n      string msg = \\"\\";\\n      switch (line_circle_intersect) {\\n        case LineCircleIntersection.None:\\n          msg = \\"line does not intersect circle\\";\\n          break;\\n        case LineCircleIntersection.Single:\\n          msg = string.Format(\\"line intersects circle at point ({0})\\", point1);\\n          doc.Objects.AddPoint(point1);\\n          break;\\n        case LineCircleIntersection.Multiple:\\n          msg = string.Format(\\"line intersects circle at points ({0}) and ({1})\\",\\n            point1, point2);\\n          doc.Objects.AddPoint(point1);\\n          doc.Objects.AddPoint(point2);\\n          break;\\n      }\\n      RhinoApp.WriteLine(msg);\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Intersect.Intersection","static LineCircleIntersection LineCircle(Line line, Circle circle, out double t1, out Point3d point1, out double t2, out Point3d point2)"]]},{"name":"Intersectlines.cs","code":"using Rhino.Geometry;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result IntersectLines(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.Input.Custom.GetObject go = new Rhino.Input.Custom.GetObject();\\n    go.SetCommandPrompt( \\"Select lines\\" );\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve;\\n    go.GetMultiple( 2, 2);\\n    if( go.CommandResult() != Rhino.Commands.Result.Success )\\n      return go.CommandResult();\\n    if( go.ObjectCount != 2 )\\n      return Rhino.Commands.Result.Failure;\\n\\n    LineCurve crv0 = go.Object(0).Geometry() as LineCurve;\\n    LineCurve crv1 = go.Object(1).Geometry() as LineCurve;\\n    if( crv0==null || crv1==null )\\n      return Rhino.Commands.Result.Failure;\\n\\n    Line line0 = crv0.Line;\\n    Line line1 = crv1.Line;\\n    Vector3d v0 = line0.Direction;\\n    v0.Unitize();\\n    Vector3d v1 = line1.Direction;\\n    v1.Unitize();\\n\\n    if( v0.IsParallelTo(v1) != 0 )\\n    {\\n      Rhino.RhinoApp.WriteLine(\\"Selected lines are parallel.\\");\\n      return Rhino.Commands.Result.Nothing;\\n    }\\n\\n    double a, b;\\n    if( !Rhino.Geometry.Intersect.Intersection.LineLine(line0, line1, out a, out b))\\n    {\\n      Rhino.RhinoApp.WriteLine(\\"No intersection found.\\");\\n      return Rhino.Commands.Result.Nothing;\\n    }\\n\\n    Point3d pt0 = line0.PointAt(a);\\n    Point3d pt1 = line1.PointAt(b);\\n    // pt0 and pt1 should be equal, so we will only add pt0 to the document\\n    doc.Objects.AddPoint( pt0 );\\n    doc.Views.Redraw();\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Geometry.Line","Vector3d Direction"],["Rhino.Geometry.Line","Point3d PointAt(double t)"],["Rhino.Geometry.Vector3d","int IsParallelTo(Vector3d other)"],["Rhino.Geometry.Intersect.Intersection","static bool LineLine(Line lineA, Line lineB, out double a, out double b)"]]},{"name":"Isbrepbox.cs","code":"using System;\\n\\npartial class Examples\\n{\\n  public static bool IsBrepBox(Rhino.Geometry.Brep brep)\\n  {\\n    const double zero_tolerance = 1.0e-6; // or whatever\\n    bool rc = brep.IsSolid;\\n    if( rc )\\n      rc = brep.Faces.Count == 6;\\n\\n    var N = new Rhino.Geometry.Vector3d[6];\\n    for (int i = 0; rc && i < 6; i++)\\n    {\\n      Rhino.Geometry.Plane plane;\\n      rc = brep.Faces[i].TryGetPlane(out plane, zero_tolerance);\\n      if( rc )\\n      {\\n        N[i] = plane.ZAxis;\\n        N[i].Unitize();\\n      }\\n    }\\n \\n    for (int i = 0; rc && i < 6; i++)\\n    {\\n      int count = 0;\\n      for (int j = 0; rc && j < 6; j++)\\n      {\\n        double dot = Math.Abs(N[i] * N[j]);\\n        if (dot <= zero_tolerance)\\n          continue;\\n        if (Math.Abs(dot - 1.0) <= zero_tolerance) \\n          count++;\\n        else\\n          rc = false;\\n      }\\n \\n      if (rc)\\n      {\\n        if (2 != count)\\n          rc = false;\\n      }\\n    }\\n    return rc;\\n  }\\n\\n  public static Rhino.Commands.Result TestBrepBox(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.DocObjects.ObjRef obj_ref;\\n    var rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select Brep\\", true, Rhino.DocObjects.ObjectType.Brep, out obj_ref);\\n    if (rc == Rhino.Commands.Result.Success)\\n    {\\n      var brep = obj_ref.Brep();\\n      if (brep != null)\\n      {\\n        Rhino.RhinoApp.WriteLine(IsBrepBox(brep) ? \\"Yes it is a box\\" : \\"No it is not a box\\");\\n      }\\n    }\\n    return rc;\\n  }\\n}\\n","members":[["Rhino.Geometry.Brep","bool IsSolid"],["Rhino.Geometry.Surface","bool TryGetPlane(out Plane plane, double tolerance)"]]},{"name":"Isocurvedensity.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result IsocurveDensity(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.DocObjects.ObjRef objref;\\n    var rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select surface\\", false, Rhino.DocObjects.ObjectType.Surface, out objref);\\n    if( rc!= Rhino.Commands.Result.Success )\\n      return rc;\\n\\n    var brep_obj = objref.Object() as Rhino.DocObjects.BrepObject;\\n    if( brep_obj!=null )\\n    {\\n      brep_obj.Attributes.WireDensity = 3;\\n      brep_obj.CommitChanges();\\n      doc.Views.Redraw();\\n    }\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.DocObjects.ObjectAttributes","int WireDensity"]]},{"name":"Issurfaceinplane.cs","code":"using System.Linq;\\nusing Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Geometry;\\nusing Rhino.Commands;\\nusing Rhino.Input;\\n\\nnamespace examples_cs\\n{\\n  public class IsPlanarSurfaceInPlaneCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csIsPlanarSurfaceInPlane\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef obj_ref;\\n      var rc = RhinoGet.GetOneObject(\\"select surface\\", true, ObjectType.Surface, out obj_ref);\\n      if (rc != Result.Success)\\n        return rc;\\n      var surface = obj_ref.Surface();\\n\\n      Point3d[] corners;\\n      rc = RhinoGet.GetRectangle(out corners);\\n      if (rc != Result.Success)\\n        return rc;\\n\\n      var plane = new Plane(corners[0], corners[1], corners[2]);\\n\\n      var is_or_isnt = \\"\\";\\n      if (IsSurfaceInPlane(surface, plane, doc.ModelAbsoluteTolerance))\\n        is_or_isnt = \\" not \\";\\n\\n      RhinoApp.WriteLine(\\"Surface is{0} in plane.\\", is_or_isnt);\\n      return Result.Success;\\n    }\\n\\n    private bool IsSurfaceInPlane(Surface surface, Plane plane, double tolerance)\\n    {\\n      if (!surface.IsPlanar(tolerance))\\n        return false;\\n     \\n      var bbox = surface.GetBoundingBox(true);\\n      return bbox.GetCorners().All(\\n        corner => System.Math.Abs(plane.DistanceTo(corner)) <= tolerance);\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Plane","double DistanceTo(Point3d testPoint)"],["Rhino.Geometry.Surface","bool IsPlanar()"]]},{"name":"Leader.cs","code":"using Rhino;\\nusing Rhino.Geometry;\\nusing Rhino.Commands;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\nnamespace examples_cs\\n{\\n  public class LeaderCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csLeader\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var points = new Point3d[]\\n      {\\n        new Point3d(1, 1, 0),\\n        new Point3d(5, 1, 0),\\n        new Point3d(5, 5, 0),\\n        new Point3d(9, 5, 0)\\n      };\\n\\n      var xy_plane = Plane.WorldXY;\\n\\n      var points2d = new List<Point2d>();\\n      foreach (var point3d in points)\\n      {\\n        double x, y;\\n        if (xy_plane.ClosestParameter(point3d, out x, out y))\\n        {\\n          var point2d = new Point2d(x, y);\\n          if (points2d.Count < 1 || point2d.DistanceTo(points2d.Last<Point2d>()) > RhinoMath.SqrtEpsilon)\\n            points2d.Add(point2d);\\n        }\\n      }\\n\\n      doc.Objects.AddLeader(xy_plane, points2d);\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Point2d","double DistanceTo(Point2d other)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddLeader(Plane plane, IEnumerable<Point2d> points)"]]},{"name":"Locklayer.cs","code":"using Rhino;\\nusing Rhino.Input;\\nusing Rhino.Commands;\\nusing System;\\nusing System.Linq;\\n\\nnamespace examples_cs\\n{\\n  public class LockLayerCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csLockLayer\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      string layer_name = \\"\\";\\n      var rc = RhinoGet.GetString(\\"Name of layer to lock\\", true, ref layer_name);\\n      if (rc != Result.Success)\\n        return rc;\\n      if (String.IsNullOrWhiteSpace(layer_name))\\n        return Result.Nothing;\\n     \\n      // because of sublayers it\'s possible that mone than one layer has the same name\\n      // so simply calling doc.Layers.Find(layerName) isn\'t good enough.  If \\"layerName\\" returns\\n      // more than one layer then present them to the user and let him decide.\\n      var matching_layers = (from layer in doc.Layers\\n                             where layer.Name == layer_name\\n                             select layer).ToList<Rhino.DocObjects.Layer>();\\n\\n      Rhino.DocObjects.Layer layer_to_lock = null;\\n      if (matching_layers.Count == 0)\\n      {\\n        RhinoApp.WriteLine(\\"Layer \'{0}\' does not exist.\\", layer_name);\\n        return Result.Nothing;\\n      }\\n      else if (matching_layers.Count == 1)\\n      {\\n        layer_to_lock = matching_layers[0];\\n      }\\n      else if (matching_layers.Count > 1)\\n      {\\n        for (int i = 0; i < matching_layers.Count; i++)\\n        {\\n          RhinoApp.WriteLine(\\"({0}) {1}\\", i+1, matching_layers[i].FullPath.Replace(\\"::\\", \\"->\\"));\\n        }\\n        int selected_layer = -1;\\n        rc = RhinoGet.GetInteger(\\"which layer?\\", true, ref selected_layer);\\n        if (rc != Result.Success)\\n          return rc;\\n        if (selected_layer > 0 && selected_layer <= matching_layers.Count)\\n          layer_to_lock = matching_layers[selected_layer - 1];\\n        else return Result.Nothing;\\n      }\\n\\n      if (layer_to_lock == null)\\n        return Result.Nothing;\\n\\n      if (!layer_to_lock.IsLocked)\\n      {\\n        layer_to_lock.IsLocked = true;\\n        layer_to_lock.CommitChanges();\\n        return Result.Success;\\n      }\\n      else\\n      {\\n        RhinoApp.WriteLine(\\"layer {0} is already locked.\\", layer_to_lock.FullPath);\\n        return Result.Nothing;\\n      } \\n    }\\n  }\\n}\\n","members":[["Rhino.DocObjects.Layer","string FullPath"],["Rhino.DocObjects.Layer","bool IsLocked"],["Rhino.DocObjects.Layer","bool CommitChanges()"]]},{"name":"Loft.cs","code":"using System.Linq;\\nusing Rhino;\\nusing Rhino.Input.Custom;\\nusing Rhino.DocObjects;\\nusing Rhino.Commands;\\nusing Rhino.Geometry;\\n\\nnamespace examples_cs\\n{\\n  public class LoftCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csLoft\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      // select curves to loft\\n      var gs = new GetObject();\\n      gs.SetCommandPrompt(\\"select curves to loft\\");\\n      gs.GeometryFilter = ObjectType.Curve;\\n      gs.DisablePreSelect();\\n      gs.SubObjectSelect = false;\\n      gs.GetMultiple(2, 0);\\n      if (gs.CommandResult() != Result.Success)\\n        return gs.CommandResult();\\n\\n      var curves = gs.Objects().Select(obj => obj.Curve()).ToList();\\n\\n      var breps = Brep.CreateFromLoft(curves, Point3d.Unset, Point3d.Unset, LoftType.Tight, false);\\n      foreach (var brep in breps)\\n        doc.Objects.AddBrep(brep);\\n\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Brep","static Brep[] CreateFromLoft(IEnumerable<Curve> curves, Point3d start, Point3d end, LoftType loftType, bool closed)"]]},{"name":"Makerhinocontours.cs","code":"using System;\\nusing Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Geometry;\\nusing Rhino.Input;\\nusing Rhino.Input.Custom;\\nusing Rhino.Commands;\\n\\nnamespace examples_cs\\n{\\n  public class ContourCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csContour\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var filter = ObjectType.Surface | ObjectType.PolysrfFilter | ObjectType.Mesh;\\n      ObjRef[] obj_refs;\\n      var rc = RhinoGet.GetMultipleObjects(\\"Select objects to contour\\", false, filter, out obj_refs);\\n      if (rc != Result.Success)\\n        return rc;\\n\\n      var gp = new GetPoint();\\n      gp.SetCommandPrompt(\\"Contour plane base point\\");\\n      gp.Get();\\n      if (gp.CommandResult() != Result.Success)\\n        return gp.CommandResult();\\n      var base_point = gp.Point();\\n\\n      gp.DrawLineFromPoint(base_point, true);\\n      gp.SetCommandPrompt(\\"Direction perpendicular to contour planes\\");\\n      gp.Get();\\n      if (gp.CommandResult() != Result.Success)\\n        return gp.CommandResult();\\n      var end_point = gp.Point();\\n\\n      if (base_point.DistanceTo(end_point) < RhinoMath.ZeroTolerance)\\n        return Result.Nothing;\\n\\n      double distance = 1.0;\\n      rc = RhinoGet.GetNumber(\\"Distance between contours\\", false, ref distance);\\n      if (rc != Result.Success)\\n        return rc;\\n\\n      var interval = Math.Abs(distance);\\n\\n      Curve[] curves = null;\\n      foreach (var obj_ref in obj_refs)\\n      {\\n        var geometry = obj_ref.Geometry();\\n        if (geometry == null)\\n          return Result.Failure;\\n\\n        if (geometry is Brep)\\n        {\\n          curves = Brep.CreateContourCurves(geometry as Brep, base_point, end_point, interval);\\n        }\\n        else\\n        {\\n          curves = Mesh.CreateContourCurves(geometry as Mesh, base_point, end_point, interval);\\n        }\\n\\n        foreach (var curve in curves)\\n        {\\n          var curve_object_id = doc.Objects.AddCurve(curve);\\n          doc.Objects.Select(curve_object_id);\\n        }\\n      }\\n\\n      if (curves != null)\\n        doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Brep","static Curve[] CreateContourCurves(Brep brepToContour, Point3d contourStart, Point3d contourEnd, double interval)"],["Rhino.Geometry.Mesh","static Curve[] CreateContourCurves(Mesh meshToContour, Point3d contourStart, Point3d contourEnd, double interval)"]]},{"name":"Meshdrawing.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Display;\\nusing Rhino.Geometry;\\nusing Rhino.Input.Custom;\\nusing Rhino.DocObjects;\\nusing System.Drawing;\\n\\nnamespace examples_cs\\n{\\n  public class MeshDrawingCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csDrawMesh\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var gs = new GetObject();\\n      gs.SetCommandPrompt(\\"select sphere\\");\\n      gs.GeometryFilter = ObjectType.Surface;\\n      gs.DisablePreSelect();\\n      gs.SubObjectSelect = false;\\n      gs.Get();\\n      if (gs.CommandResult() != Result.Success)\\n        return gs.CommandResult();\\n\\n      Sphere sphere;\\n      gs.Object(0).Surface().TryGetSphere(out sphere);\\n      if (sphere.IsValid)\\n      {\\n        var mesh = Mesh.CreateFromSphere(sphere, 10, 10);\\n        if (mesh == null)\\n          return Result.Failure;\\n\\n        var conduit = new DrawBlueMeshConduit(mesh) {Enabled = true};\\n        doc.Views.Redraw();\\n\\n        var in_str = \\"\\";\\n        Rhino.Input.RhinoGet.GetString(\\"press <Enter> to continue\\", true, ref in_str);\\n\\n        conduit.Enabled = false;\\n        doc.Views.Redraw();\\n        return Result.Success;\\n      }\\n      else\\n        return Result.Failure;\\n    }\\n  }\\n\\n  class DrawBlueMeshConduit : DisplayConduit\\n  {\\n    readonly Mesh m_mesh;\\n    readonly Color m_color;\\n    readonly DisplayMaterial m_material;\\n    readonly BoundingBox m_bbox;\\n\\n    public DrawBlueMeshConduit(Mesh mesh)\\n    {\\n      // set up as much data as possible so we do the minimum amount of work possible inside\\n      // the actual display code\\n      m_mesh = mesh;\\n      m_color = System.Drawing.Color.Blue;\\n      m_material = new DisplayMaterial();\\n      m_material.Diffuse = m_color;\\n      if (m_mesh != null && m_mesh.IsValid)\\n        m_bbox = m_mesh.GetBoundingBox(true);\\n    }\\n\\n    // this is called every frame inside the drawing code so try to do as little as possible\\n    // in order to not degrade display speed. Don\'t create new objects if you don\'t have to as this\\n    // will incur an overhead on the heap and garbage collection.\\n    protected override void CalculateBoundingBox(CalculateBoundingBoxEventArgs e)\\n    {\\n      base.CalculateBoundingBox(e);\\n      // Since we are dynamically drawing geometry, we needed to override\\n      // CalculateBoundingBox. Otherwise, there is a good chance that our\\n      // dynamically drawing geometry would get clipped.\\n \\n      // Union the mesh\'s bbox with the scene\'s bounding box\\n      e.IncludeBoundingBox(m_bbox);\\n    }\\n\\n    protected override void PreDrawObjects(DrawEventArgs e)\\n    {\\n      base.PreDrawObjects(e);\\n      var vp = e.Display.Viewport;\\n      if (vp.DisplayMode.EnglishName.ToLower() == \\"wireframe\\")\\n        e.Display.DrawMeshWires(m_mesh, m_color);\\n      else\\n        e.Display.DrawMeshShaded(m_mesh, m_material);\\n    }\\n  }\\n}","members":[["Rhino.Display.DisplayPipeline","void DrawMeshShaded(Mesh mesh, DisplayMaterial material)"],["Rhino.Display.DisplayPipeline","void DrawMeshWires(Mesh mesh, Color color)"]]},{"name":"Meshvolume.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Input.Custom;\\nusing Rhino.Geometry;\\nusing Rhino.DocObjects;\\n\\nnamespace examples_cs\\n{\\n  public class MeshVolumeCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csMeshVolume\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var gm = new GetObject();\\n      gm.SetCommandPrompt(\\"Select solid meshes for volume calculation\\");\\n      gm.GeometryFilter = ObjectType.Mesh;\\n      gm.GeometryAttributeFilter = GeometryAttributeFilter.ClosedMesh;\\n      gm.SubObjectSelect = false;\\n      gm.GroupSelect = true;\\n      gm.GetMultiple(1, 0);\\n      if (gm.CommandResult() != Result.Success)\\n        return gm.CommandResult();\\n\\n      double volume = 0.0;\\n      double volume_error = 0.0;\\n      foreach (var obj_ref in gm.Objects())\\n      {\\n        if (obj_ref.Mesh() != null)\\n        {\\n          var mass_properties = VolumeMassProperties.Compute(obj_ref.Mesh());\\n          if (mass_properties != null)\\n          {\\n            volume += mass_properties.Volume;\\n            volume_error += mass_properties.VolumeError;\\n          }\\n        }\\n      }\\n\\n      RhinoApp.WriteLine(\\"Total volume = {0:f} (+/- {1:f})\\", volume, volume_error);\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.VolumeMassProperties","double Volume"],["Rhino.Geometry.VolumeMassProperties","double VolumeError"]]},{"name":"Modifylightcolor.cs","code":"using Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Commands;\\nusing Rhino.Input;\\nusing Rhino.UI;\\n\\nnamespace examples_cs\\n{\\n  public class ChangeLightColorCommand : Rhino.Commands.Command\\n  {\\n    public override string EnglishName\\n    {\\n      get { return \\"csLightColor\\"; }\\n    }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef obj_ref;\\n      var rc = RhinoGet.GetOneObject(\\"Select light to change color\\", true,\\n        ObjectType.Light, out obj_ref);\\n      if (rc != Result.Success)\\n        return rc;\\n      var light = obj_ref.Light();\\n      if (light == null)\\n        return Result.Failure;\\n\\n      var diffuse_color = light.Diffuse;\\n      if (Dialogs.ShowColorDialog(ref diffuse_color))\\n      {\\n        light.Diffuse = diffuse_color;\\n      }\\n\\n      doc.Lights.Modify(obj_ref.ObjectId, light);\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Light","Color Diffuse"],["Rhino.UI.Dialogs","static bool ShowColorDialog(ref Color color)"],["Rhino.DocObjects.Tables.LightTable","bool Modify(Guid id, Light light)"]]},{"name":"Modifyobjectcolor.cs","code":"using System.Drawing;\\nusing Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Geometry;\\nusing Rhino.Input;\\nusing Rhino.Commands;\\n\\nnamespace examples_cs\\n{\\n  public class ModifyObjectColorCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csModifyObjectColor\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef obj_ref;\\n      var rc = RhinoGet.GetOneObject(\\"Select object\\", false, ObjectType.AnyObject, out obj_ref);\\n      if (rc != Result.Success)\\n        return rc;\\n      var rhino_object = obj_ref.Object();\\n      var color = rhino_object.Attributes.ObjectColor;\\n      bool b = Rhino.UI.Dialogs.ShowColorDialog(ref color);\\n      if (!b) return Result.Cancel;\\n\\n      rhino_object.Attributes.ObjectColor = color;\\n      rhino_object.Attributes.ColorSource = ObjectColorSource.ColorFromObject;\\n      rhino_object.CommitChanges();\\n\\n      // an object\'s color attributes can also be specified\\n      // when the object is added to Rhino\\n      var sphere = new Sphere(Point3d.Origin, 5.0);\\n      var attributes = new ObjectAttributes();\\n      attributes.ObjectColor = Color.CadetBlue;\\n      attributes.ColorSource = ObjectColorSource.ColorFromObject;\\n      doc.Objects.AddSphere(sphere, attributes);\\n\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.DocObjects.ObjectAttributes","ObjectColorSource ColorSource"],["Rhino.DocObjects.ObjectAttributes","Color ObjectColor"]]},{"name":"Moveobjectstocurrentlayer.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.DocObjects;\\n\\nnamespace examples_cs\\n{\\n  public class MoveSelectedObjectsToCurrentLayerCommand : Command\\n  {\\n    public override string EnglishName\\n    {\\n      get { return \\"csMoveSelectedObjectsToCurrentLayer\\"; }\\n    }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      // all non-light objects that are selected\\n      var object_enumerator_settings = new ObjectEnumeratorSettings();\\n      object_enumerator_settings.IncludeLights = false;\\n      object_enumerator_settings.IncludeGrips = true;\\n      object_enumerator_settings.NormalObjects = true;\\n      object_enumerator_settings.LockedObjects = true;\\n      object_enumerator_settings.HiddenObjects = true;\\n      object_enumerator_settings.ReferenceObjects = true;\\n      object_enumerator_settings.SelectedObjectsFilter = true;\\n      var selected_objects = doc.Objects.GetObjectList(object_enumerator_settings);\\n\\n      var current_layer_index = doc.Layers.CurrentLayerIndex;\\n      foreach (var selected_object in selected_objects)\\n      {\\n        selected_object.Attributes.LayerIndex = current_layer_index;\\n        selected_object.CommitChanges();\\n      }\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.DocObjects.ObjectAttributes","int LayerIndex"],["Rhino.DocObjects.Tables.LayerTable","int CurrentLayerIndex"]]},{"name":"Nestedblock.cs","code":"using System;\\n\\nusing Rhino;\\nusing Rhino.Geometry;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddNestedBlock(RhinoDoc doc)\\n  {\\n    var circle = new Circle(Point3d.Origin, 5);\\n    Curve[] curveList = { new ArcCurve(circle) };\\n    var circleIndex = doc.InstanceDefinitions.Add(\\"Circle\\", \\"Circle with radius of 5\\", Point3d.Origin, curveList);\\n    var transform = Transform.Identity;\\n    var irefId = doc.InstanceDefinitions[circleIndex].Id;\\n    var iref = new InstanceReferenceGeometry(irefId, transform);\\n    circle.Radius = circle.Radius * 2.0;\\n    GeometryBase[] blockList = { iref, new ArcCurve(circle) };\\n    var circle2Index = doc.InstanceDefinitions.Add(\\"TwoCircles\\", \\"Nested block test\\", Point3d.Origin, blockList);\\n    doc.Objects.AddInstanceObject(circle2Index, transform);\\n    doc.Views.Redraw();\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Geometry.InstanceReferenceGeometry","InstanceReferenceGeometry(Guid instanceDefinitionId, Transform transform)"],["Rhino.DocObjects.Tables.InstanceDefinitionTable","int Add(string name, string description, Point3d basePoint, IEnumerable<GeometryBase> geometry)"]]},{"name":"Nurbscurveincreasedegree.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Input;\\nusing Rhino.DocObjects;\\n\\nnamespace examples_cs\\n{\\n  public class NurbsCurveIncreaseDegreeCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csNurbsCrvIncreaseDegree\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef obj_ref;\\n      var rc = RhinoGet.GetOneObject(\\n        \\"Select curve\\", false, ObjectType.Curve, out obj_ref);\\n      if (rc != Result.Success) return rc;\\n      if (obj_ref == null) return Result.Failure;\\n      var curve = obj_ref.Curve();\\n      if (curve == null) return Result.Failure;\\n      var nurbs_curve = curve.ToNurbsCurve();\\n\\n      int new_degree = -1;\\n      rc = RhinoGet.GetInteger(string.Format(\\"New degree <{0}...11>\\", nurbs_curve.Degree), true, ref new_degree,\\n        nurbs_curve.Degree, 11);\\n      if (rc != Result.Success) return rc;\\n\\n      rc = Result.Failure;\\n      if (nurbs_curve.IncreaseDegree(new_degree))\\n        if (doc.Objects.Replace(obj_ref.ObjectId, nurbs_curve))\\n          rc = Result.Success;\\n\\n      RhinoApp.WriteLine(\\"Result: {0}\\", rc.ToString());\\n      doc.Views.Redraw();\\n      return rc;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.NurbsCurve","bool IncreaseDegree(int desiredDegree)"]]},{"name":"Nurbssurfaceincreasedegree.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Input;\\nusing Rhino.DocObjects;\\n\\nnamespace examples_cs\\n{\\n  public class NurbsSurfaceIncreaseDegreeCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csNurbsSrfIncreaseDegree\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef obj_ref;\\n      var rc = RhinoGet.GetOneObject(\\n        \\"Select surface\\", false, ObjectType.Surface, out obj_ref);\\n      if (rc != Result.Success) return rc;\\n      if (obj_ref == null) return Result.Failure;\\n      var surface = obj_ref.Surface();\\n      if (surface == null) return Result.Failure;\\n      var nurbs_surface = surface.ToNurbsSurface();\\n\\n      int new_u_degree = -1;\\n      rc = RhinoGet.GetInteger(string.Format(\\"New U degree <{0}...11>\\", nurbs_surface.Degree(0)), true, ref new_u_degree,\\n        nurbs_surface.Degree(0), 11);\\n      if (rc != Result.Success) return rc;\\n      \\n      int new_v_degree = -1;\\n      rc = RhinoGet.GetInteger(string.Format(\\"New V degree <{0}...11>\\", nurbs_surface.Degree(1)), true, ref new_v_degree,\\n        nurbs_surface.Degree(1), 11);\\n      if (rc != Result.Success) return rc;\\n\\n      rc = Result.Failure;\\n      if (nurbs_surface.IncreaseDegreeU(new_u_degree))\\n        if (nurbs_surface.IncreaseDegreeV(new_v_degree))\\n          if (doc.Objects.Replace(obj_ref.ObjectId, nurbs_surface))\\n            rc = Result.Success;\\n\\n      RhinoApp.WriteLine(\\"Result: {0}\\", rc.ToString());\\n      doc.Views.Redraw();\\n      return rc;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.NurbsSurface","bool IncreaseDegreeU(int desiredDegree)"],["Rhino.Geometry.NurbsSurface","bool IncreaseDegreeV(int desiredDegree)"]]},{"name":"Objectdecoration.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result ObjectDecoration(Rhino.RhinoDoc doc)\\n  {\\n    // Define a line\\n    var line = new Rhino.Geometry.Line(new Rhino.Geometry.Point3d(0, 0, 0), new Rhino.Geometry.Point3d(10, 0, 0));\\n\\n    // Make a copy of Rhino\'s default object attributes\\n    var attribs = doc.CreateDefaultAttributes();\\n\\n    // Modify the object decoration style\\n    attribs.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.BothArrowhead;\\n\\n    // Create a new curve object with our attributes\\n    doc.Objects.AddLine(line, attribs);\\n    doc.Views.Redraw();\\n\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.RhinoDoc","DocObjects.ObjectAttributes CreateDefaultAttributes()"]]},{"name":"Objectdisplaymode.cs","code":"using System;\\nusing Rhino;\\nusing Rhino.Commands;\\nusing Rhino.DocObjects;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result ObjectDisplayMode(Rhino.RhinoDoc doc)\\n  {\\n    const ObjectType filter = ObjectType.Mesh | ObjectType.Brep;\\n    ObjRef objref;\\n    Result rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select mesh or surface\\", true, filter, out objref);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n    Guid viewportId = doc.Views.ActiveView.ActiveViewportID;\\n\\n    ObjectAttributes attr = objref.Object().Attributes;\\n    if (attr.HasDisplayModeOverride(viewportId))\\n    {\\n      RhinoApp.WriteLine(\\"Removing display mode override from object\\");\\n      attr.RemoveDisplayModeOverride(viewportId);\\n    }\\n    else\\n    {\\n      Rhino.Display.DisplayModeDescription[] modes = Rhino.Display.DisplayModeDescription.GetDisplayModes();\\n      Rhino.Display.DisplayModeDescription mode = null;\\n      if (modes.Length == 1)\\n        mode = modes[0];\\n      else\\n      {\\n        Rhino.Input.Custom.GetOption go = new Rhino.Input.Custom.GetOption();\\n        go.SetCommandPrompt(\\"Select display mode\\");\\n        string[] str_modes = new string[modes.Length];\\n        for (int i = 0; i < modes.Length; i++)\\n          str_modes[i] = modes[i].EnglishName.Replace(\\" \\", \\"\\").Replace(\\"-\\", \\"\\");\\n        go.AddOptionList(\\"DisplayMode\\", str_modes, 0);\\n        if (go.Get() == Rhino.Input.GetResult.Option)\\n          mode = modes[go.Option().CurrentListOptionIndex];\\n      }\\n      if (mode == null)\\n        return Rhino.Commands.Result.Cancel;\\n      attr.SetDisplayModeOverride(mode, viewportId);\\n    }\\n    doc.Objects.ModifyAttributes(objref, attr, false);\\n    doc.Views.Redraw();\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.DocObjects.ObjectAttributes","bool HasDisplayModeOverride(Guid viewportId)"],["Rhino.DocObjects.ObjectAttributes","void RemoveDisplayModeOverride(Guid rhinoViewportId)"],["Rhino.DocObjects.ObjectAttributes","bool SetDisplayModeOverride(DisplayModeDescription mode, Guid rhinoViewportId)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionList(LocalizeStringPair optionName, IEnumerable<LocalizeStringPair> listValues, int listCurrentIndex)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionList(string englishOptionName, IEnumerable<string> listValues, int listCurrentIndex)"]]},{"name":"Objectiterator.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.DocObjects;\\n\\nnamespace examples_cs\\n{\\n  public class ObjectEnumeratorCommand : Command\\n  {\\n    public override string EnglishName\\n    {\\n      get { return \\"csObjectEnumerator\\"; }\\n    }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var object_enumerator_settings = new ObjectEnumeratorSettings();\\n      object_enumerator_settings.IncludeLights = true;\\n      object_enumerator_settings.IncludeGrips = false;\\n      var rhino_objects = doc.Objects.GetObjectList(object_enumerator_settings);\\n\\n      int count = 0;\\n      foreach (var rhino_object in rhino_objects)\\n      {\\n        if (rhino_object.IsSelectable() && rhino_object.IsSelected(false) == 0)\\n        {\\n          rhino_object.Select(true);\\n          count++;\\n        }\\n      }\\n      if (count > 0)\\n      {\\n        doc.Views.Redraw();\\n        RhinoApp.WriteLine(\\"{0} object{1} selected\\", count,\\n          count == 1 ? \\"\\" : \\"s\\");\\n      }\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.DocObjects.ObjectEnumeratorSettings","bool IncludeGrips"],["Rhino.DocObjects.ObjectEnumeratorSettings","bool IncludeLights"]]},{"name":"Orientonsrf.cs","code":"partial class Examples\\n{\\n  public static Rhino.Commands.Result OrientOnSrf(Rhino.RhinoDoc doc)\\n  {\\n    // Select objects to orient\\n    Rhino.Input.Custom.GetObject go = new Rhino.Input.Custom.GetObject();\\n    go.SetCommandPrompt(\\"Select objects to orient\\");\\n    go.SubObjectSelect = false;\\n    go.GroupSelect = true;\\n    go.GetMultiple(1, 0);\\n    if (go.CommandResult() != Rhino.Commands.Result.Success)\\n      return go.CommandResult();\\n\\n    // Point to orient from\\n    Rhino.Input.Custom.GetPoint gp = new Rhino.Input.Custom.GetPoint();\\n    gp.SetCommandPrompt(\\"Point to orient from\\");\\n    gp.Get();\\n    if (gp.CommandResult() != Rhino.Commands.Result.Success)\\n      return gp.CommandResult();\\n\\n    // Define source plane\\n    Rhino.Display.RhinoView view = gp.View();\\n    if (view == null)\\n    {\\n      view = doc.Views.ActiveView;\\n      if (view == null)\\n        return Rhino.Commands.Result.Failure;\\n    }\\n    Rhino.Geometry.Plane source_plane = view.ActiveViewport.ConstructionPlane();\\n    source_plane.Origin = gp.Point();\\n\\n    // Surface to orient on\\n    Rhino.Input.Custom.GetObject gs = new Rhino.Input.Custom.GetObject();\\n    gs.SetCommandPrompt(\\"Surface to orient on\\");\\n    gs.GeometryFilter = Rhino.DocObjects.ObjectType.Surface;\\n    gs.SubObjectSelect = true;\\n    gs.DeselectAllBeforePostSelect = false;\\n    gs.OneByOnePostSelect = true;\\n    gs.Get();\\n    if (gs.CommandResult() != Rhino.Commands.Result.Success)\\n      return gs.CommandResult();\\n\\n    Rhino.DocObjects.ObjRef objref = gs.Object(0);\\n    // get selected surface object\\n    Rhino.DocObjects.RhinoObject obj = objref.Object();\\n    if (obj == null)\\n      return Rhino.Commands.Result.Failure;\\n    // get selected surface (face)\\n    Rhino.Geometry.Surface surface = objref.Surface();\\n    if (surface == null)\\n      return Rhino.Commands.Result.Failure;\\n    // Unselect surface\\n    obj.Select(false);\\n\\n    // Point on surface to orient to\\n    gp.SetCommandPrompt(\\"Point on surface to orient to\\");\\n    gp.Constrain(surface, false);\\n    gp.Get();\\n    if (gp.CommandResult() != Rhino.Commands.Result.Success)\\n      return gp.CommandResult();\\n\\n    // Do transformation\\n    Rhino.Commands.Result rc = Rhino.Commands.Result.Failure;\\n    double u, v;\\n    if (surface.ClosestPoint(gp.Point(), out u, out v))\\n    {\\n      Rhino.Geometry.Plane target_plane;\\n      if (surface.FrameAt(u, v, out target_plane))\\n      {\\n        // Build transformation\\n        Rhino.Geometry.Transform xform = Rhino.Geometry.Transform.PlaneToPlane(source_plane, target_plane);\\n\\n        // Do the transformation. In this example, we will copy the original objects\\n        const bool delete_original = false;\\n        for (int i = 0; i < go.ObjectCount; i++)\\n          doc.Objects.Transform(go.Object(i), xform, delete_original);\\n\\n        doc.Views.Redraw();\\n        rc = Rhino.Commands.Result.Success;\\n      }\\n    }\\n    return rc;\\n  }\\n}\\n","members":[["Rhino.Geometry.Surface","bool ClosestPoint(Point3d testPoint, out double u, out double v)"],["Rhino.Geometry.Surface","bool FrameAt(double u, double v, out Plane frame)"],["Rhino.DocObjects.RhinoObject","int Select(bool on)"],["Rhino.DocObjects.ObjRef","RhinoObject Object()"],["Rhino.DocObjects.ObjRef","Surface Surface()"],["Rhino.Input.Custom.GetObject","bool DeselectAllBeforePostSelect"],["Rhino.Input.Custom.GetObject","ObjectType GeometryFilter"],["Rhino.Input.Custom.GetObject","bool GroupSelect"],["Rhino.Input.Custom.GetObject","bool OneByOnePostSelect"],["Rhino.Input.Custom.GetObject","bool SubObjectSelect"],["Rhino.Input.Custom.GetObject","ObjRef Object(int index)"],["Rhino.Input.Custom.GetPoint","bool Constrain(Surface surface, bool allowPickingPointOffObject)"],["Rhino.DocObjects.Tables.ObjectTable","Guid Transform(ObjRef objref, Transform xform, bool deleteOriginal)"]]},{"name":"Ortho.cs","code":"using Rhino;\\nusing Rhino.ApplicationSettings;\\nusing Rhino.Commands;\\nusing Rhino.Input.Custom;\\n\\nnamespace examples_cs\\n{\\n  public class OrthoCommand : Command\\n  {\\n    public override string EnglishName\\n    {\\n      get { return \\"csOrtho\\"; }\\n    }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var gp = new GetPoint();\\n      gp.SetCommandPrompt(\\"Start of line\\");\\n      gp.Get();\\n      if (gp.CommandResult() != Result.Success)\\n        return gp.CommandResult();\\n      var start_point = gp.Point();\\n  \\n      var original_ortho = ModelAidSettings.Ortho;\\n      if (!original_ortho)\\n        ModelAidSettings.Ortho = true;\\n\\n      gp.SetCommandPrompt(\\"End of line\\");\\n      gp.SetBasePoint(start_point, false);\\n      gp.DrawLineFromPoint(start_point, true);\\n      gp.Get();\\n      if (gp.CommandResult() != Result.Success)\\n        return gp.CommandResult();\\n      var end_point = gp.Point();\\n\\n      if (ModelAidSettings.Ortho != original_ortho)\\n        ModelAidSettings.Ortho = original_ortho;\\n\\n      doc.Objects.AddLine(start_point, end_point);\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.ApplicationSettings.ModelAidSettings","static bool Ortho"]]},{"name":"Planesurface.cs","code":"using Rhino;\\nusing Rhino.Geometry;\\nusing Rhino.Commands;\\n\\nnamespace examples_cs\\n{\\n  public class PlaneSurfaceCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csPlaneSurface\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      Point3d[] corners;\\n      var rc = Rhino.Input.RhinoGet.GetRectangle(out corners);\\n      if (rc != Result.Success)\\n        return rc;\\n\\n      var plane = new Plane(corners[0], corners[1], corners[2]);\\n\\n      var plane_surface = new PlaneSurface(plane, \\n        new Interval(0, corners[0].DistanceTo(corners[1])), \\n        new Interval(0, corners[1].DistanceTo(corners[2])));\\n\\n      doc.Objects.Add(plane_surface);\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.PlaneSurface","PlaneSurface(Plane plane, Interval xExtents, Interval yExtents)"]]},{"name":"Pointatcursor.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.DocObjects;\\nusing System;\\n\\nnamespace examples_cs\\n{\\n  public class PointAtCursorCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csPointAtCursor\\"; } }\\n\\n    [System.Runtime.InteropServices.DllImport(\\"user32.dll\\")]\\n    public static extern bool GetCursorPos(out System.Drawing.Point point);\\n \\n    [System.Runtime.InteropServices.DllImport(\\"user32.dll\\")]\\n    public static extern bool ScreenToClient(IntPtr hWnd, ref System.Drawing.Point point);\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var result = Result.Failure;\\n      var view = doc.Views.ActiveView;\\n      if (view == null) return result;\\n\\n      System.Drawing.Point windows_drawing_point;\\n      if (!GetCursorPos(out windows_drawing_point) || !ScreenToClient(view.Handle, ref windows_drawing_point))\\n        return result;\\n\\n      var xform = view.ActiveViewport.GetTransform(CoordinateSystem.Screen, CoordinateSystem.World);\\n      var point = new Rhino.Geometry.Point3d(windows_drawing_point.X, windows_drawing_point.Y, 0.0);\\n      RhinoApp.WriteLine(\\"screen point: ({0})\\", point);\\n      point.Transform(xform);\\n      RhinoApp.WriteLine(\\"world point: ({0})\\", point);\\n      result = Result.Success;\\n      return result;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Point3d","void Transform(Transform xform)"],["Rhino.Display.RhinoViewport","Transform GetTransform(CoordinateSystem sourceSystem, CoordinateSystem destinationSystem)"]]},{"name":"Principalcurvature.cs","code":"using Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Input;\\nusing Rhino.Commands;\\n\\nnamespace examples_cs\\n{\\n  public class PrincipalCurvatureCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csPrincipalCurvature\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef obj_ref;\\n      var rc = RhinoGet.GetOneObject(\\"Select surface for curvature measurement\\", true, \\n        ObjectType.Surface, out obj_ref);\\n      if (rc != Result.Success)\\n        return rc;\\n      var surface = obj_ref.Surface();\\n\\n      var gp = new Rhino.Input.Custom.GetPoint();\\n      gp.SetCommandPrompt(\\"Select point on surface for curvature measurement\\");\\n      gp.Constrain(surface, false);\\n      gp.Get();\\n      if (gp.CommandResult() != Result.Success)\\n        return gp.CommandResult();\\n      var point_on_surface = gp.Point();\\n\\n      double u, v;\\n      if (!surface.ClosestPoint(point_on_surface, out u, out v))\\n        return Result.Failure;\\n\\n      var surface_curvature = surface.CurvatureAt(u, v);\\n      if (surface_curvature == null)\\n        return Result.Failure;\\n\\n      RhinoApp.WriteLine(\\"Surface curvature evaluation at parameter: ({0}, {1})\\", u, v);\\n\\n      RhinoApp.WriteLine(\\"  3-D Point: ({0}, {1}, {2})\\",\\n        surface_curvature.Point.X,\\n        surface_curvature.Point.Y,\\n        surface_curvature.Point.Z);\\n\\n      RhinoApp.WriteLine(\\"  3-D Normal: ({0}, {1}, {2})\\",\\n        surface_curvature.Normal.X,\\n        surface_curvature.Normal.Y,\\n        surface_curvature.Normal.Z);\\n\\n      RhinoApp.WriteLine(string.Format(\\"  Maximum principal curvature: {0} ({1}, {2}, {3})\\", \\n        surface_curvature.Kappa(0), \\n        surface_curvature.Direction(0).X, \\n        surface_curvature.Direction(0).Y, \\n        surface_curvature.Direction(0).Z));\\n\\n      RhinoApp.WriteLine(string.Format(\\"  Minimum principal curvature: {0} ({1}, {2}, {3})\\", \\n        surface_curvature.Kappa(1), \\n        surface_curvature.Direction(1).X, \\n        surface_curvature.Direction(1).Y, \\n        surface_curvature.Direction(1).Z));\\n\\n      RhinoApp.WriteLine(\\"  Gaussian curvature: {0}\\", surface_curvature.Gaussian);\\n      RhinoApp.WriteLine(\\"  Mean curvature: {0}\\", surface_curvature.Mean);\\n\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.SurfaceCurvature","double Gaussian"],["Rhino.Geometry.SurfaceCurvature","double Mean"],["Rhino.Geometry.SurfaceCurvature","Vector3d Normal"],["Rhino.Geometry.SurfaceCurvature","Point3d Point"],["Rhino.Geometry.SurfaceCurvature","Vector3d Direction(int direction)"],["Rhino.Geometry.SurfaceCurvature","double Kappa(int direction)"],["Rhino.Geometry.Surface","SurfaceCurvature CurvatureAt(double u, double v)"]]},{"name":"Printinstancedefinitiontree.cs","code":"using Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.FileIO;\\nusing Rhino.Commands;\\n\\nnamespace examples_cs\\n{\\n  public class InstanceDefinitionTreeCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csInstanceDefinitionTree\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var instance_definitions = doc.InstanceDefinitions;\\n      var instance_definition_count = instance_definitions.Count;\\n\\n      if (instance_definition_count == 0)\\n      {\\n        RhinoApp.WriteLine(\\"Document contains no instance definitions.\\");\\n        return Result.Nothing;\\n      }\\n\\n      var dump = new TextLog();\\n      dump.IndentSize = 4;\\n\\n      for (int i = 0; i < instance_definition_count; i++)\\n        DumpInstanceDefinition(instance_definitions[i], ref dump, true);\\n\\n      RhinoApp.WriteLine(dump.ToString());\\n\\n      return Result.Success;\\n    }\\n\\n    private void DumpInstanceDefinition(InstanceDefinition instanceDefinition, ref TextLog dump, bool isRoot)\\n    {\\n      if (instanceDefinition != null && !instanceDefinition.IsDeleted)\\n      {\\n        string node = isRoot ? \\"\\" : \\"\\";\\n        dump.Print(string.Format(\\"{0} Instance definition {1} = {2}\\\\n\\", node, instanceDefinition.Index, instanceDefinition.Name));\\n\\n        if (instanceDefinition.ObjectCount  > 0)\\n        {\\n          dump.PushIndent();\\n          for (int i = 0; i < instanceDefinition.ObjectCount ; i++)\\n          {\\n            var obj = instanceDefinition.Object(i);\\n            if (obj == null) continue;\\n            if (obj is InstanceObject)\\n              DumpInstanceDefinition((obj as InstanceObject).InstanceDefinition, ref dump, false); // Recursive...\\n            else\\n              dump.Print(\\"\\\\u2514 Object {0} = {1}\\\\n\\", i, obj.ShortDescription(false));\\n          }\\n          dump.PopIndent();\\n        }\\n      }\\n    }\\n  }\\n}\\n\\n","members":[["Rhino.RhinoDoc","InstanceDefinitionTable InstanceDefinitions"],["Rhino.FileIO.TextLog","void PopIndent()"],["Rhino.FileIO.TextLog","void Print(string text)"],["Rhino.FileIO.TextLog","void PushIndent()"]]},{"name":"Projectpointstobreps.cs","code":"using Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Input.Custom;\\nusing Rhino.Commands;\\nusing System.Collections.Generic;\\nusing Rhino.Geometry;\\nusing Rhino.Geometry.Intersect;\\n\\nnamespace examples_cs\\n{\\n  public class ProjectPointsToBrepsCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csProjectPtointsToBreps\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var gs = new GetObject();\\n      gs.SetCommandPrompt(\\"select surface\\");\\n      gs.GeometryFilter = ObjectType.Surface | ObjectType.PolysrfFilter;\\n      gs.DisablePreSelect();\\n      gs.SubObjectSelect = false;\\n      gs.Get();\\n      if (gs.CommandResult() != Result.Success)\\n        return gs.CommandResult();\\n      var brep = gs.Object(0).Brep();\\n      if (brep == null)\\n        return Result.Failure;\\n\\n      var points = Intersection.ProjectPointsToBreps(\\n                   new List<Brep> {brep}, // brep on which to project\\n                   new List<Point3d> {new Point3d(0, 0, 0), new Point3d(3,0,3), new Point3d(-2,0,-2)}, // some random points to project\\n                   new Vector3d(0, 1, 0), // project on Y axis\\n                   doc.ModelAbsoluteTolerance);\\n\\n      if (points != null && points.Length > 0)\\n      {\\n        foreach (var point in points)\\n        {\\n          doc.Objects.AddPoint(point);\\n        }\\n      }\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Intersect.Intersection","static Point3d[] ProjectPointsToBreps(IEnumerable<Brep> breps, IEnumerable<Point3d> points, Vector3d direction, double tolerance)"]]},{"name":"Projectpointstomeshesex.cs","code":"using System.Collections.Generic;\\nusing Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Geometry;\\nusing Rhino.Geometry.Intersect;\\nusing Rhino.Input;\\nusing Rhino.DocObjects;\\n\\nnamespace examples_cs\\n{\\n  public class ProjectPointsToMeshesExCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csProjectPointsToMeshesEx\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef obj_ref;\\n      var rc = RhinoGet.GetOneObject(\\"mesh\\", false, ObjectType.Mesh, out obj_ref);\\n      if (rc != Result.Success) return rc;\\n      var mesh = obj_ref.Mesh();\\n\\n      ObjRef[] obj_ref_pts;\\n      rc = RhinoGet.GetMultipleObjects(\\"points\\", false, ObjectType.Point, out obj_ref_pts);\\n      if (rc != Result.Success) return rc;\\n      var points = new List<Point3d>();\\n      foreach (var obj_ref_pt in obj_ref_pts)\\n      {\\n        var pt = obj_ref_pt.Point().Location;\\n        points.Add(pt);\\n      }\\n\\n      int[] indices;\\n      var prj_points = Intersection.ProjectPointsToMeshesEx(new[] {mesh}, points, new Vector3d(0, 1, 0), 0, out indices);\\n      foreach (var prj_pt in prj_points) doc.Objects.AddPoint(prj_pt);\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.Intersect.Intersection","static Point3d[] ProjectPointsToMeshesEx(IEnumerable<Mesh> meshes, IEnumerable<Point3d> points, Vector3d direction, double tolerance, out int[] indices)"]]},{"name":"Renameblock.cs","code":"using Rhino;\\nusing Rhino.Input;\\nusing Rhino.Commands;\\n\\nnamespace examples_cs\\n{\\n  public class RenameBlockCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csRenameBlock\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      // Get the name of the insance definition to rename\\n      var instance_definition_name = \\"\\";\\n      var rc = RhinoGet.GetString(\\"Name of block to rename\\", true, ref instance_definition_name);\\n      if (rc != Result.Success)\\n        return rc;\\n      if (string.IsNullOrWhiteSpace(instance_definition_name))\\n        return Result.Nothing;\\n     \\n      // Verify instance definition exists\\n      var instance_definition = doc.InstanceDefinitions.Find(instance_definition_name, true);\\n      if (instance_definition == null) {\\n        RhinoApp.WriteLine(\\"Block \'{0}\' not found.\\", instance_definition_name);\\n        return Result.Nothing;\\n      }\\n\\n      // Verify instance definition is rename-able\\n      if (instance_definition.IsDeleted || instance_definition.IsReference) {\\n        RhinoApp.WriteLine(\\"Unable to rename block \'{0}\'.\\", instance_definition_name);\\n        return Result.Nothing;\\n      }\\n     \\n      // Get the new instance definition name\\n      string instance_definition_new_name = \\"\\";\\n      rc = RhinoGet.GetString(\\"Name of block to rename\\", true, ref instance_definition_new_name);\\n      if (rc != Result.Success)\\n        return rc;\\n      if (string.IsNullOrWhiteSpace(instance_definition_new_name))\\n        return Result.Nothing;\\n\\n      // Verify the new instance definition name is not already in use\\n      var existing_instance_definition = doc.InstanceDefinitions.Find(instance_definition_new_name, true);\\n      if (existing_instance_definition != null && !existing_instance_definition.IsDeleted) {\\n        RhinoApp.WriteLine(\\"Block \'{0}\' already exists.\\", existing_instance_definition);\\n        return Result.Nothing;\\n      }\\n     \\n      // change the block name\\n      if (!doc.InstanceDefinitions.Modify(instance_definition.Index, instance_definition_new_name, instance_definition.Description, true)) {\\n        RhinoApp.WriteLine(\\"Could not rename {0} to {1}\\", instance_definition.Name, instance_definition_new_name);\\n        return Result.Failure;\\n      }\\n\\n      return Result.Success;\\n    }\\n  }\\n}\\n","members":[["Rhino.DocObjects.InstanceDefinition","bool IsDeleted"],["Rhino.DocObjects.InstanceDefinition","bool IsReference"],["Rhino.DocObjects.Tables.InstanceDefinitionTable","bool Modify(int idefIndex, string newName, string newDescription, bool quiet)"]]},{"name":"Replacecolordialog.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.UI;\\nusing System.Windows.Forms;\\n\\nnamespace examples_cs\\n{\\n  public class ReplaceColorDialogCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csReplaceColorDialog\\"; } }\\n\\n    private ColorDialog m_dlg = null;\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      Dialogs.SetCustomColorDialog(OnSetCustomColorDialog);\\n      return Result.Success;\\n    }\\n\\n    void OnSetCustomColorDialog(object sender, GetColorEventArgs e)\\n    {\\n      m_dlg = new ColorDialog();\\n      if (m_dlg.ShowDialog(null) == DialogResult.OK)\\n      {\\n        var c = m_dlg.Color;\\n        e.SelectedColor = c;\\n      }\\n    }\\n  }\\n}","members":[["Rhino.UI.Dialogs","static void SetCustomColorDialog(EventHandler<GetColorEventArgs> handler)"]]},{"name":"Replacehatchpattern.cs","code":"using Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Commands;\\nusing Rhino.Input;\\nusing Rhino.Input.Custom;\\n\\nnamespace examples_cs\\n{\\n  public class ReplaceHatchPatternCommand : Rhino.Commands.Command\\n  {\\n    public override string EnglishName\\n    {\\n      get { return \\"csReplaceHatchPattern\\"; }\\n    }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef[] obj_refs;\\n      var rc = RhinoGet.GetMultipleObjects(\\"Select hatches to replace\\", false, ObjectType.Hatch, out obj_refs);\\n      if (rc != Result.Success || obj_refs == null)\\n        return rc;\\n\\n      var gs = new GetString();\\n      gs.SetCommandPrompt(\\"Name of replacement hatch pattern\\");\\n      gs.AcceptNothing(false);\\n      gs.Get();\\n      if (gs.CommandResult() != Result.Success)\\n        return gs.CommandResult();\\n      var hatch_name = gs.StringResult();\\n\\n      var pattern_index = doc.HatchPatterns.Find(hatch_name, true);\\n\\n      if (pattern_index < 0)\\n      {\\n        RhinoApp.WriteLine(\\"The hatch pattern \'{0}\' not found  in the document.\\", hatch_name);\\n        return Result.Nothing;\\n      }\\n\\n      foreach (var obj_ref in obj_refs)\\n      {\\n        var hatch_object = obj_ref.Object() as HatchObject;\\n        if (hatch_object.HatchGeometry.PatternIndex != pattern_index)\\n        {\\n          hatch_object.HatchGeometry.PatternIndex = pattern_index;\\n          hatch_object.CommitChanges();\\n        }\\n      }\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}\\n","members":[["Rhino.Geometry.Hatch","int PatternIndex"],["Rhino.DocObjects.HatchObject","Hatch HatchGeometry"]]},{"name":"Rhinogettransform.cs","code":"using Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Geometry;\\nusing Rhino.Commands;\\nusing Rhino.Input.Custom;\\nusing Rhino.Display;\\n\\nnamespace examples_cs\\n{\\n  public class GetTranslation : GetTransform\\n  {\\n    public override Transform CalculateTransform(RhinoViewport viewport, Point3d point)\\n    {\\n      var xform = Transform.Identity;\\n      Point3d base_point;\\n      if (TryGetBasePoint(out base_point))\\n      {\\n        var v = point - base_point;\\n        if (!v.IsZero)\\n        {\\n          xform = Transform.Translation(v);\\n          if (!xform.IsValid)\\n            xform = Transform.Identity;\\n        }\\n      }\\n      return xform;\\n    }\\n  }\\n\\n  public class RhinoGetTransformCommand : TransformCommand\\n  {\\n    public RhinoGetTransformCommand()\\n    {\\n      // simple example of handling the BeforeTransformObjects event\\n      RhinoDoc.BeforeTransformObjects += RhinoDocOnBeforeTransformObjects;\\n    }\\n\\n    private void RhinoDocOnBeforeTransformObjects(object sender, RhinoTransformObjectsEventArgs ea)\\n    {\\n      RhinoApp.WriteLine(\\"Transform Objects Count: {0}\\", ea.ObjectCount);\\n    }\\n\\n    public override string EnglishName { get { return \\"csGetTranslation\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var list = new Rhino.Collections.TransformObjectList();\\n      var rc = SelectObjects(\\"Select objects to move\\", list);\\n      if (rc != Rhino.Commands.Result.Success)\\n        return rc;\\n\\n      var gp = new GetPoint();\\n      gp.SetCommandPrompt(\\"Point to move from\\");\\n      gp.Get();\\n      if (gp.CommandResult() != Result.Success)\\n        return gp.CommandResult();\\n\\n\\n      var gt = new GetTranslation();\\n      gt.SetCommandPrompt(\\"Point to move to\\");\\n      gt.SetBasePoint(gp.Point(), true);\\n      gt.DrawLineFromPoint(gp.Point(), true);\\n      gt.AddTransformObjects(list);\\n      gt.GetXform();\\n      if (gt.CommandResult() != Result.Success)\\n        return gt.CommandResult();\\n\\n      var xform = gt.CalculateTransform(gt.View().ActiveViewport, gt.Point());\\n      TransformObjects(list, xform, false, false);\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}\\n","members":[["Rhino.RhinoDoc","static BeforeTransformObjects"]]},{"name":"Rhinopageviewwidthheight.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Input;\\n\\nnamespace examples_cs\\n{\\n  public class RhinoPageViewWidthHeightCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csSetRhinoPageViewWidthAndHeight\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var width = 1189;\\n      var height = 841;\\n      var page_views = doc.Views.GetPageViews();\\n      int page_number = (page_views==null) ? 1 : page_views.Length + 1;\\n      var pageview = doc.Views.AddPageView(string.Format(\\"A0_{0}\\",page_number), width, height);\\n\\n      int new_width = width;\\n      var rc = RhinoGet.GetInteger(\\"new width\\", false, ref new_width);\\n      if (rc != Result.Success || new_width <= 0) return rc;\\n\\n      int new_height = height;\\n      rc = RhinoGet.GetInteger(\\"new height\\", false, ref new_height);\\n      if (rc != Result.Success || new_height <= 0) return rc;\\n\\n      pageview.PageWidth = new_width;\\n      pageview.PageHeight = new_height;\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Display.RhinoPageView","double PageHeight"],["Rhino.Display.RhinoPageView","double PageWidth"]]},{"name":"Screencaptureview.cs","code":"using System;\\nusing System.Windows.Forms;\\nusing Rhino;\\nusing Rhino.Commands;\\n\\nnamespace examples_cs\\n{\\n  public class CaptureViewToBitmapCommand : Rhino.Commands.Command\\n  {\\n    public override string EnglishName\\n    {\\n      get { return \\"csCaptureViewToBitmap\\"; }\\n    }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var file_name = \\"\\";\\n\\n      var bitmap = doc.Views.ActiveView.CaptureToBitmap(true, true, true);\\n      bitmap.MakeTransparent();\\n\\n      // copy bitmap to clipboard\\n      Clipboard.SetImage(bitmap);\\n\\n      // save bitmap to file\\n      var save_file_dialog = new Rhino.UI.SaveFileDialog\\n      {\\n        Filter = \\"*.bmp\\",\\n        InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)\\n      };\\n      if (save_file_dialog.ShowDialog() == DialogResult.OK)\\n      {\\n        file_name = save_file_dialog.FileName;\\n      }\\n\\n      if (file_name != \\"\\")\\n        bitmap.Save(file_name);\\n\\n      return Rhino.Commands.Result.Success;\\n    }\\n  }\\n}\\n","members":[["Rhino.Display.RhinoView","System.Drawing.Bitmap CaptureToBitmap(bool grid, bool worldAxes, bool cplaneAxes)"],["Rhino.UI.SaveFileDialog","SaveFileDialog()"],["Rhino.UI.SaveFileDialog","string FileName"],["Rhino.UI.SaveFileDialog","string Filter"],["Rhino.UI.SaveFileDialog","string InitialDirectory"],["Rhino.UI.SaveFileDialog","bool ShowSaveDialog()"]]},{"name":"Sellayer.cs","code":"using Rhino.Commands;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result SelLayer(Rhino.RhinoDoc doc)\\n  {\\n    // Prompt for a layer name\\n    string layername = doc.Layers.CurrentLayer.Name;\\n    Result rc = Rhino.Input.RhinoGet.GetString(\\"Name of layer to select objects\\", true, ref layername);\\n    if (rc != Rhino.Commands.Result.Success)\\n      return rc;\\n\\n    // Get all of the objects on the layer. If layername is bogus, you will\\n    // just get an empty list back\\n    Rhino.DocObjects.RhinoObject[] rhobjs = doc.Objects.FindByLayer(layername);\\n    if (rhobjs == null || rhobjs.Length < 1)\\n      return Rhino.Commands.Result.Cancel;\\n\\n    for (int i = 0; i < rhobjs.Length; i++)\\n      rhobjs[i].Select(true);\\n    doc.Views.Redraw();\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.DocObjects.Layer","string Name"],["Rhino.DocObjects.Tables.ObjectTable","RhinoObject[] FindByLayer(string layerName)"],["Rhino.DocObjects.Tables.LayerTable","Layer CurrentLayer"]]},{"name":"Splitbrepwithplane.cs","code":"using Rhino;\\nusing Rhino.DocObjects;\\nusing Rhino.Commands;\\nusing Rhino.Input;\\nusing Rhino.Geometry;\\n\\nnamespace examples_cs\\n{\\n  public class SplitBrepsWithPlaneCommand : Rhino.Commands.Command\\n  {\\n    public override string EnglishName\\n    {\\n      get { return \\"csSplitBrepsWithPlane\\"; }\\n    }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      //First, collect all the breps to split\\n      ObjRef[] obj_refs;\\n      var rc = RhinoGet.GetMultipleObjects(\\"Select breps to split\\", false, ObjectType.Brep, out obj_refs);\\n      if (rc != Result.Success || obj_refs == null)\\n        return rc;\\n\\n      // Get the final plane\\n      Plane plane;\\n      rc = RhinoGet.GetPlane(out plane);\\n      if (rc != Result.Success)\\n        return rc;\\n\\n      //Iterate over all object references\\n      foreach (var obj_ref in obj_refs)\\n      {\\n        var brep = obj_ref.Brep();\\n        var bbox = brep.GetBoundingBox(false);\\n\\n        //Grow the boundingbox in all directions\\n        //If the boundingbox is flat (zero volume or even zero area) \\n        //then the CreateThroughBox method will fail.\\n        var min_point = bbox.Min;\\n        min_point.X -= 1.0;\\n        min_point.Y -= 1.0;\\n        min_point.Z -= 1.0;\\n        bbox.Min = min_point;\\n        var max_point = bbox.Max;\\n        max_point.X += 1.0;\\n        max_point.Y += 1.0;\\n        max_point.Z += 1.0;\\n        bbox.Max = max_point;\\n\\n        var plane_surface = PlaneSurface.CreateThroughBox(plane, bbox);\\n        if (plane_surface == null)\\n        {\\n          //This is rare, it will most likely not happen unless either the plane or the boundingbox are invalid\\n          RhinoApp.WriteLine(\\"Cutting plane could not be constructed.\\");\\n        }\\n        else\\n        {\\n          var breps = brep.Split(plane_surface.ToBrep(), doc.ModelAbsoluteTolerance);\\n          if (breps == null || breps.Length == 0)\\n          {\\n            RhinoApp.Write(\\"Plane does not intersect brep (id:{0})\\", obj_ref.ObjectId);\\n            continue;\\n          }\\n          foreach (var brep_piece in breps)\\n          {\\n            doc.Objects.AddBrep(brep_piece);\\n          }\\n          doc.Objects.AddSurface(plane_surface);\\n          doc.Objects.Delete(obj_ref, false);\\n        }\\n      }\\n\\n      doc.Views.Redraw();\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.PlaneSurface","static PlaneSurface CreateThroughBox(Plane plane, BoundingBox box)"],["Rhino.Input.RhinoGet","static Result GetPlane(out Plane plane)"]]},{"name":"Srfpt.cs","code":"using Rhino;\\nusing Rhino.Geometry;\\nusing Rhino.Commands;\\n\\nnamespace examples_cs\\n{\\n  public class SurfaceFromCornersCommand : Rhino.Commands.Command\\n  {\\n    public override string EnglishName\\n    {\\n      get { return \\"csSurfaceFromCorners\\"; }\\n    }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var surface = NurbsSurface.CreateFromCorners(\\n        new Point3d(5, 0, 0),\\n        new Point3d(5, 5, 5),\\n        new Point3d(0, 5, 0),\\n        new Point3d(0, 0, 0));\\n\\n      doc.Objects.AddSurface(surface);\\n      doc.Views.Redraw();\\n\\n      return Rhino.Commands.Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.NurbsSurface","static NurbsSurface CreateFromCorners(Point3d corner1, Point3d corner2, Point3d corner3, Point3d corner4)"]]},{"name":"Sweep1.cs","code":"using Rhino.Input;\\nusing System.Collections.Generic;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result Sweep1(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.DocObjects.ObjRef rail_ref;\\n    var rc = RhinoGet.GetOneObject(\\"Select rail curve\\", false, Rhino.DocObjects.ObjectType.Curve, out rail_ref);\\n    if(rc!=Rhino.Commands.Result.Success)\\n      return rc;\\n\\n    var rail_crv = rail_ref.Curve();\\n    if( rail_crv==null )\\n      return Rhino.Commands.Result.Failure;\\n\\n    var gx = new Rhino.Input.Custom.GetObject();\\n    gx.SetCommandPrompt(\\"Select cross section curves\\");\\n    gx.GeometryFilter = Rhino.DocObjects.ObjectType.Curve;\\n    gx.EnablePreSelect(false, true);\\n    gx.GetMultiple(1,0);\\n    if( gx.CommandResult() != Rhino.Commands.Result.Success )\\n      return gx.CommandResult();\\n    \\n    var cross_sections = new List<Rhino.Geometry.Curve>();\\n    for( int i=0; i<gx.ObjectCount; i++ )\\n    {\\n      var crv = gx.Object(i).Curve();\\n      if( crv!= null)\\n        cross_sections.Add(crv);\\n    }\\n    if( cross_sections.Count<1 )\\n      return Rhino.Commands.Result.Failure;\\n\\n    var sweep = new Rhino.Geometry.SweepOneRail();\\n    sweep.AngleToleranceRadians = doc.ModelAngleToleranceRadians;\\n    sweep.ClosedSweep = false;\\n    sweep.SweepTolerance = doc.ModelAbsoluteTolerance;\\n    sweep.SetToRoadlikeTop();\\n    var breps = sweep.PerformSweep(rail_crv, cross_sections);\\n    for( int i=0; i<breps.Length; i++ )\\n      doc.Objects.AddBrep(breps[i]);\\n    doc.Views.Redraw();\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Geometry.SweepOneRail","SweepOneRail()"],["Rhino.Geometry.SweepOneRail","Brep[] PerformSweep(Curve rail, IEnumerable<Curve> crossSections)"]]},{"name":"Textjustify.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing Rhino.Geometry;\\n\\nnamespace examples_cs\\n{\\n  public class TextJustifyCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csTextJustify\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var text_entity = new TextEntity\\n      {\\n        Plane = Plane.WorldXY,\\n        Text = \\"Hello Rhino!\\",\\n        Justification = TextJustification.MiddleCenter,\\n        FontIndex = doc.Fonts.FindOrCreate(\\"Arial\\", false, false)\\n      };\\n\\n      doc.Objects.AddText(text_entity);\\n      doc.Views.Redraw();\\n\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.TextEntity","TextEntity()"],["Rhino.Geometry.TextEntity","TextJustification Justification"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddText(Text3d text3d)"],["Rhino.DocObjects.Tables.FontTable","int FindOrCreate(string face, bool bold, bool italic)"]]},{"name":"Tightboundingbox.cs","code":"using Rhino;\\nusing Rhino.Commands;\\nusing System.Linq;\\nusing Rhino.Geometry;\\nusing Rhino.Input;\\nusing Rhino.DocObjects;\\nusing System.Collections.Generic;\\n\\nnamespace examples_cs\\n{\\n  public class TightBoundingBoxCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csTightBoundingBox\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      ObjRef obj_ref;\\n      var rc = RhinoGet.GetOneObject(\\n        \\"Select surface to split\\", true, ObjectType.Surface, out obj_ref);\\n      if (rc != Result.Success)\\n        return rc;\\n      var surface = obj_ref.Surface();\\n      if (surface == null)\\n        return Result.Failure;\\n\\n      obj_ref = null;\\n      rc = RhinoGet.GetOneObject(\\n        \\"Select cutting curve\\", true, ObjectType.Curve, out obj_ref);\\n      if (rc != Result.Success)\\n        return rc;\\n      var curve = obj_ref.Curve();\\n      if (curve == null)\\n        return Result.Failure;\\n\\n      var brep_face = surface as BrepFace;\\n      if (brep_face == null)\\n        return Result.Failure;\\n\\n      var split_brep = brep_face.Split(\\n        new List<Curve> {curve}, doc.ModelAbsoluteTolerance);\\n      if (split_brep == null)\\n      {\\n        RhinoApp.WriteLine(\\"Unable to split surface.\\");\\n        return Result.Nothing;\\n      }\\n\\n      var meshes = Mesh.CreateFromBrep(split_brep);\\n\\n      foreach (var mesh in meshes)\\n      {\\n        var bbox = mesh.GetBoundingBox(true);\\n        switch (bbox.IsDegenerate(doc.ModelAbsoluteTolerance))\\n        {\\n          case 3:\\n          case 2:\\n            return Result.Failure;\\n          case 1:\\n            // rectangle\\n            // box with 8 corners flattened to rectangle with 4 corners\\n            var rectangle_corners = bbox.GetCorners().Distinct().ToList();\\n            // add 1st point as last to close the loop\\n            rectangle_corners.Add(rectangle_corners[0]);\\n            doc.Objects.AddPolyline(rectangle_corners);\\n            doc.Views.Redraw();\\n            break;\\n          case 0: \\n            // box\\n            var brep_box = new Box(bbox).ToBrep();\\n            doc.Objects.AddBrep(brep_box);\\n            doc.Views.Redraw();\\n            break;\\n        }\\n      }\\n\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Geometry.BrepFace","Brep Split(IEnumerable<Curve> curves, double tolerance)"],["Rhino.Geometry.Mesh","static Mesh[] CreateFromBrep(Brep brep)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddPolyline(IEnumerable<Point3d> points)"]]},{"name":"Transformbrep.cs","code":"using Rhino.Input;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result TransformBrep(Rhino.RhinoDoc doc)\\n  {\\n    Rhino.DocObjects.ObjRef rhobj;\\n    var rc = RhinoGet.GetOneObject(\\"Select brep\\", true, Rhino.DocObjects.ObjectType.Brep, out rhobj);\\n    if(rc!= Rhino.Commands.Result.Success)\\n      return rc;\\n\\n    // Simple translation transformation\\n    var xform = Rhino.Geometry.Transform.Translation(18,-18,25);\\n    doc.Objects.Transform(rhobj, xform, true);\\n    doc.Views.Redraw();\\n    return Rhino.Commands.Result.Success;\\n  }\\n}\\n","members":[["Rhino.Geometry.Transform","static Transform Translation(double dx, double dy, double dz)"]]},{"name":"Viewportresolution.cs","code":"using Rhino;\\nusing Rhino.Commands;\\n\\nnamespace examples_cs\\n{\\n  public class ViewportResolutionCommand : Command\\n  {\\n    public override string EnglishName { get { return \\"csViewportResolution\\"; } }\\n\\n    protected override Result RunCommand(RhinoDoc doc, RunMode mode)\\n    {\\n      var active_viewport = doc.Views.ActiveView.ActiveViewport;\\n      RhinoApp.WriteLine(\\"Name = {0}: Width = {1}, Height = {2}\\", \\n        active_viewport.Name, active_viewport.Size.Width, active_viewport.Size.Height);\\n      return Result.Success;\\n    }\\n  }\\n}","members":[["Rhino.Display.RhinoViewport","Size Size"]]},{"name":"Activeviewport.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef ActiveViewport():\\n    view = scriptcontext.doc.Views.ActiveView\\n    if view is None: return\\n    if isinstance(view, Rhino.Display.RhinoPageView):\\n        if view.PageIsActive:\\n            print \\"The layout\\", view.PageName, \\"is active\\"\\n        else:\\n            detail_name = view.ActiveViewport.Name\\n            print \\"The detail\\", detail_name, \\"on layout\\", view.PageName, \\"is active\\"\\n    else:\\n        print \\"The viewport\\", view.MainViewport.Name, \\"is active\\"\\n\\n\\nif __name__ == \\"__main__\\":\\n    ActiveViewport()\\n","members":[["Rhino.Display.RhinoPageView","bool PageIsActive"],["Rhino.Display.RhinoPageView","string PageName"]]},{"name":"Addbackgroundbitmap.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Windows.Forms.DialogResult\\nimport System.Drawing.Image\\n\\ndef AddBackgroundBitmap():\\n    # Allow the user to select a bitmap file\\n    fd = Rhino.UI.OpenFileDialog()\\n    fd.Filter = \\"Image Files (*.bmp;*.png;*.jpg)|*.bmp;*.png;*.jpg\\"\\n    if fd.ShowDialog()!=System.Windows.Forms.DialogResult.OK:\\n        return Rhino.Commands.Result.Cancel\\n\\n    # Verify the file that was selected\\n    image = None\\n    try:\\n        image = System.Drawing.Image.FromFile(fd.FileName)\\n    except:\\n        return Rhino.Commands.Result.Failure\\n\\n    # Allow the user to pick the bitmap origin\\n    gp = Rhino.Input.Custom.GetPoint()\\n    gp.SetCommandPrompt(\\"Bitmap Origin\\")\\n    gp.ConstrainToConstructionPlane(True)\\n    gp.Get()\\n    if gp.CommandResult()!=Rhino.Commands.Result.Success:\\n        return gp.CommandResult()\\n\\n    # Get the view that the point was picked in.\\n    # This will be the view that the bitmap appears in.\\n    view = gp.View()\\n    if view is None:\\n        view = scriptcontext.doc.Views.ActiveView\\n        if view is None: return Rhino.Commands.Result.Failure\\n\\n    # Allow the user to specify the bitmap with in model units\\n    gn = Rhino.Input.Custom.GetNumber()\\n    gn.SetCommandPrompt(\\"Bitmap width\\")\\n    gn.SetLowerLimit(1.0, False)\\n    gn.Get()\\n    if gn.CommandResult()!=Rhino.Commands.Result.Success:\\n        return gn.CommandResult()\\n\\n    # Cook up some scale factors\\n    w = gn.Number()\\n    h = w * (image.Width / image.Height)\\n\\n    plane = view.ActiveViewport.ConstructionPlane()\\n    plane.Origin = gp.Point()\\n    view.ActiveViewport.SetTraceImage(fd.FileName, plane, w, h, False, False)\\n    view.Redraw()\\n    return Rhino.Commands.Result.Success\\n\\nif __name__==\\"__main__\\":\\n    AddBackgroundBitmap()\\n","members":[["Rhino.Display.RhinoView","RhinoViewport ActiveViewport"],["Rhino.Display.RhinoView","void Redraw()"],["Rhino.Display.RhinoViewport","Plane ConstructionPlane()"],["Rhino.Display.RhinoViewport","bool SetTraceImage(string bitmapFileName, Plane plane, double width, double height, bool grayscale, bool filtered)"],["Rhino.UI.OpenFileDialog","OpenFileDialog()"],["Rhino.UI.OpenFileDialog","string FileName"],["Rhino.UI.OpenFileDialog","string Filter"],["Rhino.UI.OpenFileDialog","bool ShowOpenDialog()"],["Rhino.Input.Custom.GetBaseClass","Result CommandResult()"],["Rhino.Input.Custom.GetBaseClass","double Number()"],["Rhino.Input.Custom.GetBaseClass","RhinoView View()"],["Rhino.Input.Custom.GetPoint","bool ConstrainToConstructionPlane(bool throughBasePoint)"],["Rhino.Input.Custom.GetNumber","GetNumber()"],["Rhino.Input.Custom.GetNumber","GetResult Get()"],["Rhino.Input.Custom.GetNumber","void SetLowerLimit(double lowerLimit, bool strictlyGreaterThan)"],["Rhino.DocObjects.Tables.ViewTable","RhinoView ActiveView"]]},{"name":"Addbrepbox.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef AddBrepBox():\\n    pt0 = Rhino.Geometry.Point3d(0, 0, 0)\\n    pt1 = Rhino.Geometry.Point3d(10, 10, 10)\\n    box = Rhino.Geometry.BoundingBox(pt0, pt1)\\n    brep = box.ToBrep()\\n    rc = Rhino.Commands.Result.Failure\\n    if( scriptcontext.doc.Objects.AddBrep(brep) != System.Guid.Empty ):\\n        rc = Rhino.Commands.Result.Success\\n        scriptcontext.doc.Views.Redraw()\\n    return rc\\n\\nif( __name__ == \\"__main__\\" ):\\n    AddBrepBox()\\n","members":[["Rhino.Geometry.BoundingBox","BoundingBox(Point3d min, Point3d max)"],["Rhino.Geometry.BoundingBox","Brep ToBrep()"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddBrep(Brep brep)"]]},{"name":"Addchildlayer.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Drawing.Color\\n\\ndef AddChildLayer():\\n    # Get an existing layer\\n    default_name = scriptcontext.doc.Layers.CurrentLayer.Name\\n    # Prompt the user to enter a layer name\\n    gs = Rhino.Input.Custom.GetString()\\n    gs.SetCommandPrompt(\\"Name of existing layer\\")\\n    gs.SetDefaultString(default_name)\\n    gs.AcceptNothing(True)\\n    gs.Get()\\n    if gs.CommandResult()!=Rhino.Commands.Result.Success:\\n        return gs.CommandResult()\\n\\n    # Was a layer named entered?\\n    layer_name = gs.StringResult().Trim()\\n    index = scriptcontext.doc.Layers.Find(layer_name, True)\\n    if index<0: return Rhino.Commands.Result.Cancel\\n\\n    parent_layer = scriptcontext.doc.Layers[index]\\n\\n    # Create a child layer\\n    child_name = parent_layer.Name + \\"_child\\"\\n    childlayer = Rhino.DocObjects.Layer()\\n    childlayer.ParentLayerId = parent_layer.Id\\n    childlayer.Name = child_name\\n    childlayer.Color = System.Drawing.Color.Red\\n\\n    index = scriptcontext.doc.Layers.Add(childlayer)\\n    if index<0:\\n      print \\"Unable to add\\", child_name, \\"layer.\\"\\n      return Rhino.Commands.Result.Failure\\n    return Rhino.Commands.Result.Success\\n\\nif __name__==\\"__main__\\":\\n    AddChildLayer()","members":[["Rhino.DocObjects.Layer","Guid ParentLayerId"],["Rhino.DocObjects.Tables.LayerTable","int Add(Layer layer)"]]},{"name":"Addcircle.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef AddCircle():\\n    center = Rhino.Geometry.Point3d(0, 0, 0)\\n    radius = 10.0\\n    c = Rhino.Geometry.Circle(center, radius)\\n    if scriptcontext.doc.Objects.AddCircle(c)!=System.Guid.Empty:\\n        scriptcontext.doc.Views.Redraw()\\n        return Rhino.Commands.Result.Success\\n    return Rhino.Commands.Result.Failure\\n\\nif __name__==\\"__main__\\":\\n    AddCircle()\\n","members":[["Rhino.Geometry.Circle","Circle(Plane plane, double radius)"],["Rhino.Geometry.Point3d","Point3d(double x, double y, double z)"],["Rhino.DocObjects.Tables.ViewTable","void Redraw()"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddCircle(Circle circle)"]]},{"name":"Addclippingplane.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef AddClippingPlane():\\n    # Define the corners of the clipping plane\\n    rc, corners = Rhino.Input.RhinoGet.GetRectangle()\\n    if rc!=Rhino.Commands.Result.Success: return rc\\n\\n    # Get the active view\\n    view = scriptcontext.doc.Views.ActiveView\\n    if view is None: return Rhino.Commands.Result.Failure\\n\\n    p0, p1, p2, p3 = corners\\n    # Create a plane from the corner points\\n    plane = Rhino.Geometry.Plane(p0, p1, p3)\\n\\n    # Add a clipping plane object to the document\\n    id = scriptcontext.doc.Objects.AddClippingPlane(plane, p0.DistanceTo(p1), p0.DistanceTo(p3), view.ActiveViewportID)\\n    if id!=System.Guid.Empty:\\n        scriptcontext.doc.Views.Redraw()\\n        return Rhino.Commands.Result.Success\\n    return Rhino.Commands.Result.Failure\\n\\nif __name__==\\"__main__\\":\\n    AddClippingPlane()\\n","members":[["Rhino.Geometry.Plane","Plane(Point3d origin, Point3d xPoint, Point3d yPoint)"],["Rhino.FileIO.File3dmObjectTable","Guid AddClippingPlane(Plane plane, double uMagnitude, double vMagnitude, Guid clippedViewportId)"],["Rhino.Input.RhinoGet","static Result GetRectangle(out Point3d[] corners)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddClippingPlane(Plane plane, double uMagnitude, double vMagnitude, Guid clippedViewportId)"]]},{"name":"Addcylinder.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef AddCylinder():\\n    center_point = Rhino.Geometry.Point3d(0, 0, 0)\\n    height_point = Rhino.Geometry.Point3d(0, 0, 10)\\n    zaxis = height_point-center_point\\n    plane = Rhino.Geometry.Plane(center_point, zaxis)\\n    radius = 5\\n    circle = Rhino.Geometry.Circle(plane, radius)\\n    cylinder = Rhino.Geometry.Cylinder(circle, zaxis.Length)\\n    brep = cylinder.ToBrep(True, True)\\n    if brep:\\n        if scriptcontext.doc.Objects.AddBrep(brep)!=System.Guid.Empty:\\n            scriptcontext.doc.Views.Redraw()\\n            return Rhino.Commands.Result.Success\\n    return Rhino.Commands.Result.Failure\\n\\nif __name__==\\"__main__\\":\\n    AddCylinder()\\n","members":[["Rhino.Geometry.Cylinder","Cylinder(Circle baseCircle, double height)"],["Rhino.Geometry.Cylinder","Brep ToBrep(bool capBottom, bool capTop)"],["Rhino.Geometry.Plane","Plane(Point3d origin, Vector3d normal)"]]},{"name":"Addlayer.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid, System.Drawing.Color\\n\\ndef AddLayer():\\n    # Cook up an unused layer name\\n    unused_name = scriptcontext.doc.Layers.GetUnusedLayerName(False)\\n\\n    # Prompt the user to enter a layer name\\n    gs = Rhino.Input.Custom.GetString()\\n    gs.SetCommandPrompt(\\"Name of layer to add\\")\\n    gs.SetDefaultString(unused_name)\\n    gs.AcceptNothing(True)\\n    gs.Get()\\n    if gs.CommandResult()!=Rhino.Commands.Result.Success:\\n        return gs.CommandResult()\\n\\n    # Was a layer named entered?\\n    layer_name = gs.StringResult().Trim()\\n    if not layer_name:\\n        print \\"Layer name cannot be blank.\\"\\n        return Rhino.Commands.Result.Cancel\\n\\n    # Is the layer name valid?\\n    if not Rhino.DocObjects.Layer.IsValidName(layer_name):\\n        print layer_name, \\"is not a valid layer name.\\"\\n        return Rhino.Commands.Result.Cancel\\n\\n    # Does a layer with the same name already exist?\\n    layer_index = scriptcontext.doc.Layers.Find(layer_name, True)\\n    if layer_index>=0:\\n        print \\"A layer with the name\\", layer_name, \\"already exists.\\"\\n        return Rhino.Commands.Result.Cancel\\n\\n    # Add a new layer to the document\\n    layer_index = scriptcontext.doc.Layers.Add(layer_name, System.Drawing.Color.Black)\\n    if layer_index<0:\\n        print \\"Unable to add\\", layer_name, \\"layer.\\"\\n        return Rhino.Commands.Result.Failure\\n\\n    return Rhino.Commands.Result.Success\\n\\n\\nif __name__==\\"__main__\\":\\n    AddLayer()\\n","members":[["Rhino.RhinoApp","static void WriteLine(string message)"],["Rhino.RhinoApp","static void WriteLine(string format, object arg0)"],["Rhino.DocObjects.Layer","static bool IsValidName(string name)"],["Rhino.Input.Custom.GetBaseClass","void AcceptNothing(bool enable)"],["Rhino.Input.Custom.GetBaseClass","void SetDefaultString(string defaultValue)"],["Rhino.Input.Custom.GetBaseClass","string StringResult()"],["Rhino.Input.Custom.GetString","GetString()"],["Rhino.Input.Custom.GetString","GetResult Get()"],["Rhino.DocObjects.Tables.LayerTable","int Add(string layerName, Color layerColor)"],["Rhino.DocObjects.Tables.LayerTable","int Find(string layerName, bool ignoreDeletedLayers)"],["Rhino.DocObjects.Tables.LayerTable","Layer FindName(string layerName)"],["Rhino.DocObjects.Tables.LayerTable","string GetUnusedLayerName()"],["Rhino.DocObjects.Tables.LayerTable","string GetUnusedLayerName(bool ignoreDeleted)"]]},{"name":"Addlayout.py","code":"import Rhino\\nimport scriptcontext\\n\\n# Generate a layout with a single detail view that zooms\\n# to a list of objects\\ndef AddLayout():\\n    scriptcontext.doc.PageUnitSystem = Rhino.UnitSystem.Millimeters\\n    page_views = scriptcontext.doc.Views.GetPageViews()\\n    page_number = 1\\n    if page_views: page_number = len(page_views) + 1\\n    pageview = scriptcontext.doc.Views.AddPageView(\\"A0_{0}\\".format(page_number), 1189, 841)\\n    if pageview:\\n        top_left = Rhino.Geometry.Point2d(20,821)\\n        bottom_right = Rhino.Geometry.Point2d(1169, 20)\\n        detail = pageview.AddDetailView(\\"ModelView\\", top_left, bottom_right, Rhino.Display.DefinedViewportProjection.Top)\\n        if detail:\\n            pageview.SetActiveDetail(detail.Id)\\n            detail.Viewport.ZoomExtents()\\n            detail.DetailGeometry.IsProjectionLocked = True\\n            detail.DetailGeometry.SetScale(1, scriptcontext.doc.ModelUnitSystem, 10, scriptcontext.doc.PageUnitSystem)\\n            # Commit changes tells the document to replace the document\'s detail object\\n            # with the modified one that we just adjusted\\n            detail.CommitChanges()\\n        pageview.SetPageAsActive()\\n        scriptcontext.doc.Views.ActiveView = pageview\\n        scriptcontext.doc.Views.Redraw()\\n\\nif __name__==\\"__main__\\":\\n    AddLayout()","members":[["Rhino.RhinoDoc","UnitSystem PageUnitSystem"],["Rhino.Geometry.DetailView","bool IsProjectionLocked"],["Rhino.Geometry.DetailView","bool SetScale(double modelLength, UnitSystem modelUnits, double pageLength, UnitSystem pageUnits)"],["Rhino.DocObjects.RhinoObject","bool CommitChanges()"],["Rhino.Display.RhinoPageView","DetailViewObject AddDetailView(string title, Point2d corner0, Point2d corner1, DefinedViewportProjection initialProjection)"],["Rhino.Display.RhinoPageView","bool SetActiveDetail(Guid detailId)"],["Rhino.Display.RhinoPageView","void SetPageAsActive()"],["Rhino.Display.RhinoViewport","bool ZoomExtents()"],["Rhino.DocObjects.Tables.ViewTable","RhinoPageView AddPageView(string title, double pageWidth, double pageHeight)"],["Rhino.DocObjects.Tables.ViewTable","RhinoPageView[] GetPageViews()"]]},{"name":"Addline.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef AddLine():\\n    gp = Rhino.Input.Custom.GetPoint()\\n    gp.SetCommandPrompt(\\"Start of line\\")\\n    gp.Get()\\n    if gp.CommandResult()!=Rhino.Commands.Result.Success:\\n        return gp.CommandResult()\\n    pt_start = gp.Point()\\n\\n    gp.SetCommandPrompt(\\"End of line\\")\\n    gp.SetBasePoint(pt_start, False)\\n    gp.DrawLineFromPoint(pt_start, True)\\n    gp.Get()\\n    if gp.CommandResult() != Rhino.Commands.Result.Success:\\n        return gp.CommandResult()\\n    pt_end = gp.Point()\\n    v = pt_end - pt_start\\n    if v.IsTiny(Rhino.RhinoMath.ZeroTolerance):\\n        return Rhino.Commands.Result.Nothing\\n    \\n    id = scriptcontext.doc.Objects.AddLine(pt_start, pt_end)\\n    if id!=System.Guid.Empty:\\n        scriptcontext.doc.Views.Redraw()\\n        return Rhino.Commands.Result.Success\\n    return Rhino.Commands.Result.Failure\\n\\nif __name__==\\"__main__\\":\\n    AddLine()\\n","members":[["Rhino.Geometry.Vector2d","bool IsTiny(double tolerance)"],["Rhino.Geometry.Vector3d","bool IsTiny(double tolerance)"],["Rhino.Input.Custom.GetBaseClass","Point3d Point()"],["Rhino.Input.Custom.GetBaseClass","void SetCommandPrompt(string prompt)"],["Rhino.Input.Custom.GetPoint","GetPoint()"],["Rhino.Input.Custom.GetPoint","void DrawLineFromPoint(Point3d startPoint, bool showDistanceInStatusBar)"],["Rhino.Input.Custom.GetPoint","GetResult Get()"],["Rhino.Input.Custom.GetPoint","void SetBasePoint(Point3d basePoint, bool showDistanceInStatusBar)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddLine(Point3d from, Point3d to)"]]},{"name":"Addlineardimension.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef AddLinearDimension():\\n    rc, dimension = Rhino.Input.RhinoGet.GetLinearDimension()\\n    if rc==Rhino.Commands.Result.Success:\\n        if scriptcontext.doc.Objects.AddLinearDimension(dimension)==System.Guid.Empty:\\n            rc = Rhino.Commands.Result.Failure\\n        else:\\n            scriptcontext.doc.Views.Redraw()\\n    return rc\\n\\n\\nif __name__==\\"__main__\\":\\n    AddLinearDimension()\\n","members":[["Rhino.Input.RhinoGet","static Result GetLinearDimension(out LinearDimension dimension)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddLinearDimension(LinearDimension dimension)"]]},{"name":"Addlineardimension2.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef AddLinearDimension2():\\n    origin = Rhino.Geometry.Point3d(1,1,0)\\n    offset = Rhino.Geometry.Point3d(11,1,0)\\n    pt = Rhino.Geometry.Point3d((offset.X-origin.X)/2.0,3,0)\\n    plane = Rhino.Geometry.Plane.WorldXY\\n    plane.Origin = origin\\n    \\n    rc, u, v = plane.ClosestParameter(origin)\\n    ext1 = Rhino.Geometry.Point2d(u,v)\\n    rc, u, v = plane.ClosestParameter(offset)\\n    ext2 = Rhino.Geometry.Point2d(u,v)\\n    rc, u, v = plane.ClosestParameter(pt)\\n    linePt = Rhino.Geometry.Point2d(u,v)\\n    \\n    dimension = Rhino.Geometry.LinearDimension(plane, ext1, ext2, linePt)\\n    if scriptcontext.doc.Objects.AddLinearDimension(dimension)!=System.Guid.Empty:\\n        scriptcontext.doc.Views.Redraw()\\n        return Rhino.Commands.Result.Success\\n    return Rhino.Commands.Result.Failure\\n\\nif __name__==\\"__main__\\":\\n    AddLinearDimension2()\\n","members":[["Rhino.Geometry.LinearDimension","LinearDimension(Plane dimensionPlane, Point2d extensionLine1End, Point2d extensionLine2End, Point2d pointOnDimensionLine)"],["Rhino.Geometry.Plane","bool ClosestParameter(Point3d testPoint, out double s, out double t)"]]},{"name":"Addmesh.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef AddMesh():\\n    mesh = Rhino.Geometry.Mesh()\\n    mesh.Vertices.Add(0.0, 0.0, 1.0) #0\\n    mesh.Vertices.Add(1.0, 0.0, 1.0) #1\\n    mesh.Vertices.Add(2.0, 0.0, 1.0) #2\\n    mesh.Vertices.Add(3.0, 0.0, 0.0) #3\\n    mesh.Vertices.Add(0.0, 1.0, 1.0) #4\\n    mesh.Vertices.Add(1.0, 1.0, 2.0) #5\\n    mesh.Vertices.Add(2.0, 1.0, 1.0) #6\\n    mesh.Vertices.Add(3.0, 1.0, 0.0) #7\\n    mesh.Vertices.Add(0.0, 2.0, 1.0) #8\\n    mesh.Vertices.Add(1.0, 2.0, 1.0) #9\\n    mesh.Vertices.Add(2.0, 2.0, 1.0) #10\\n    mesh.Vertices.Add(3.0, 2.0, 1.0) #11\\n    \\n    mesh.Faces.AddFace(0, 1, 5, 4)\\n    mesh.Faces.AddFace(1, 2, 6, 5)\\n    mesh.Faces.AddFace(2, 3, 7, 6)\\n    mesh.Faces.AddFace(4, 5, 9, 8)\\n    mesh.Faces.AddFace(5, 6, 10, 9)\\n    mesh.Faces.AddFace(6, 7, 11, 10)\\n    mesh.Normals.ComputeNormals()\\n    mesh.Compact()\\n    if scriptcontext.doc.Objects.AddMesh(mesh)!=System.Guid.Empty:\\n        scriptcontext.doc.Views.Redraw()\\n        return Rhino.Commands.Result.Success\\n    return Rhino.Commands.Result.Failure\\n\\n\\nif __name__==\\"__main__\\":\\n    AddMesh()\\n","members":[["Rhino.Geometry.Mesh","Mesh()"],["Rhino.Geometry.Mesh","MeshFaceList Faces"],["Rhino.Geometry.Mesh","MeshVertexNormalList Normals"],["Rhino.Geometry.Mesh","MeshVertexList Vertices"],["Rhino.Geometry.Mesh","bool Compact()"],["Rhino.Geometry.Collections.MeshVertexList","int Add(double x, double y, double z)"],["Rhino.Geometry.Collections.MeshVertexList","int Add(float x, float y, float z)"],["Rhino.Geometry.Collections.MeshVertexNormalList","bool ComputeNormals()"],["Rhino.Geometry.Collections.MeshFaceList","int AddFace(int vertex1, int vertex2, int vertex3, int vertex4)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddMesh(Mesh mesh)"]]},{"name":"Addnamedview.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef AddNamedView():\\n    rc, view = Rhino.Input.RhinoGet.GetView(\\"Select view to adjust\\")\\n    if rc!=Rhino.Commands.Result.Success: return rc\\n\\n    rc, location = Rhino.Input.RhinoGet.GetPoint(\\"Camera Location\\", False)\\n    if rc!=Rhino.Commands.Result.Success: return rc\\n    \\n    gp = Rhino.Input.Custom.GetPoint()\\n    gp.SetCommandPrompt(\\"Look At Location\\")\\n    gp.DrawLineFromPoint(location, False)\\n    gp.Get()\\n    if gp.CommandResult()!=Rhino.Commands.Result.Success:\\n        return gp.CommandResult()\\n    lookat = gp.Point()\\n\\n    name = view.ActiveViewport.Name\\n    rc, name = Rhino.Input.RhinoGet.GetString(\\"Name\\", True, name)\\n    if rc!=Rhino.Commands.Result.Success: return rc\\n\\n    vp = view.ActiveViewport\\n    # save the current viewport projection\\n    vp.PushViewProjection()\\n    vp.CameraUp = Rhino.Geometry.Vector3d.ZAxis\\n    vp.SetCameraLocation(location, False)\\n    vp.SetCameraDirection(lookat - location, True)\\n    vp.Name = name\\n    \\n    scriptcontext.doc.NamedViews.Add(name, vp.Id)\\n    view.Redraw()\\n    return Rhino.Commands.Result.Success\\n\\nif __name__==\\"__main__\\":\\n    AddNamedView()\\n","members":[["Rhino.RhinoDoc","NamedViewTable NamedViews"],["Rhino.Display.RhinoViewport","Vector3d CameraUp"],["Rhino.Display.RhinoViewport","string Name"],["Rhino.Display.RhinoViewport","bool PopViewProjection()"],["Rhino.Display.RhinoViewport","void PushViewProjection()"],["Rhino.Display.RhinoViewport","void SetCameraDirection(Vector3d cameraDirection, bool updateTargetLocation)"],["Rhino.Display.RhinoViewport","void SetCameraLocation(Point3d cameraLocation, bool updateTargetLocation)"],["Rhino.Input.RhinoGet","static Result GetPoint(string prompt, bool acceptNothing, out Point3d point)"],["Rhino.Input.RhinoGet","static Result GetString(string prompt, bool acceptNothing, ref string outputString)"],["Rhino.Input.RhinoGet","static Result GetView(string commandPrompt, out RhinoView view)"],["Rhino.DocObjects.Tables.NamedViewTable","int Add(string name, Guid viewportId)"]]},{"name":"Addnurbscircle.py","code":"using System;\\n\\npartial class Examples\\n{\\n  public static Rhino.Commands.Result AddNurbsCircle(Rhino.RhinoDoc doc)\\n  {\\n    // The easy way to get a NURBS curve from a circle is with\\n    // the following two lines of code.\\n    //\\n    // Rhino.Geometry.Circle c = new Rhino.Geometry.Circle(20);\\n    // Rhino.Geometry.NurbsCurve nc = c.ToNurbsCurve();\\n    //\\n    // This sample demonstrates creating a NURBS curve from scratch.\\n    int dimension = 3;\\n    bool isRational = true;\\n    int order = 3;\\n    int cv_count = 9;\\n    Rhino.Geometry.NurbsCurve nc = new Rhino.Geometry.NurbsCurve(dimension, isRational, order, cv_count);\\n    nc.Points.SetPoint(0, 1.0, 0.0, 0.0, 1.0);\\n    nc.Points.SetPoint(1, 0.707107, 0.707107, 0.0, 0.707107);\\n    nc.Points.SetPoint(2, 0.0, 1.0, 0.0, 1.0);\\n    nc.Points.SetPoint(3, -0.707107, 0.707107, 0.0, 0.707107);\\n    nc.Points.SetPoint(4, -1.0, 0.0, 0.0, 1.0);\\n    nc.Points.SetPoint(5, -0.707107, -0.707107, 0.0, 0.707107);\\n    nc.Points.SetPoint(6, 0.0, -1.0, 0.0, 1.0);\\n    nc.Points.SetPoint(7, 0.707107, -0.707107, 0.0, 0.707107);\\n    nc.Points.SetPoint(8, 1.0, 0.0, 0.0, 1.0);\\n    nc.Knots[0] = 0.0;\\n    nc.Knots[1] = 0.0;\\n    nc.Knots[2] = 0.5 * Math.PI;\\n    nc.Knots[3] = 0.5 * Math.PI;\\n    nc.Knots[4] = Math.PI;\\n    nc.Knots[5] = Math.PI;\\n    nc.Knots[6] = 1.5 * Math.PI;\\n    nc.Knots[7] = 1.5 * Math.PI;\\n    nc.Knots[8] = 2.0 * Math.PI;\\n    nc.Knots[9] = 2.0 * Math.PI;\\n    if (nc.IsValid)\\n    {\\n      doc.Objects.AddCurve(nc);\\n      doc.Views.Redraw();\\n      return Rhino.Commands.Result.Success;\\n    }\\n    return Rhino.Commands.Result.Failure;\\n  }\\n}\\n","members":[["Rhino.Geometry.NurbsCurve","NurbsCurve(int dimension, bool rational, int order, int pointCount)"],["Rhino.Geometry.NurbsCurve","NurbsCurveKnotList Knots"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddCurve(Curve curve)"]]},{"name":"Addnurbscurve.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef AddNurbsCurve():\\n    points = Rhino.Collections.Point3dList(5)\\n    points.Add(0, 0, 0)\\n    points.Add(0, 2, 0)\\n    points.Add(2, 3, 0)\\n    points.Add(4, 2, 0)\\n    points.Add(4, 0, 0)\\n\\n    nc = Rhino.Geometry.NurbsCurve.Create(False, 3, points)\\n    rc = Rhino.Commands.Result.Failure\\n    if nc and nc.IsValid:\\n        if scriptcontext.doc.Objects.AddCurve(nc)!=System.Guid.Empty:\\n            scriptcontext.doc.Views.Redraw()\\n            rc = Rhino.Commands.Result.Success\\n    return rc\\n\\nif __name__==\\"__main__\\":\\n    AddNurbsCurve()\\n","members":[["Rhino.Geometry.NurbsCurve","static NurbsCurve Create(bool periodic, int degree, IEnumerable<Point3d> points)"],["Rhino.Collections.Point3dList","Point3dList(int initialCapacity)"],["Rhino.Collections.Point3dList","void Add(double x, double y, double z)"]]},{"name":"Addobjectstogroup.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef AddObjectsToGroup():\\n    go = Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt(\\"Select objects to group\\")\\n    go.GroupSelect = True\\n    go.GetMultiple(1, 0)\\n    if go.CommandResult()!=Rhino.Commands.Result.Success:\\n        return go.CommandResult()\\n    \\n    ids = [go.Object(i).ObjectId for i in range(go.ObjectCount)]\\n    index = scriptcontext.doc.Groups.Add(ids)\\n    scriptcontext.doc.Views.Redraw()\\n    if index>=0: return Rhino.Commands.Result.Success\\n    return Rhino.Commands.Result.Failure\\n\\n\\nif __name__ == \\"__main__\\":\\n    AddObjectsToGroup()\\n","members":[["Rhino.RhinoDoc","GroupTable Groups"],["Rhino.Input.Custom.GetObject","GetObject()"],["Rhino.Input.Custom.GetObject","GetResult GetMultiple(int minimumNumber, int maximumNumber)"],["Rhino.DocObjects.Tables.GroupTable","int Add(IEnumerable<Guid> objectIds)"]]},{"name":"Addradialdimension.py","code":"from Rhino import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Geometry import *\\nfrom Rhino.Input import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  rc, obj_ref = RhinoGet.GetOneObject(\\"Select curve for radius dimension\\", \\n    True, ObjectType.Curve)\\n  if rc != Result.Success:\\n    return rc\\n  curve, curve_parameter = obj_ref.CurveParameter()\\n  if curve == None:\\n    return Result.Failure\\n\\n  if curve.IsLinear() or curve.IsPolyline():\\n    print \\"Curve must be non-linear.\\"\\n    return Result.Nothing\\n\\n  # in this example just deal with planar curves\\n  if not curve.IsPlanar():\\n    print \\"Curve must be planar.\\"\\n    return Result.Nothing\\n\\n  point_on_curve = curve.PointAt(curve_parameter)\\n  curvature_vector = curve.CurvatureAt(curve_parameter)\\n  len = curvature_vector.Length\\n  if len < RhinoMath.SqrtEpsilon:\\n    print \\"Curve is almost linear and therefore has no curvature.\\"\\n    return Result.Nothing\\n\\n  center = point_on_curve + (curvature_vector/(len*len))\\n  _, plane = curve.TryGetPlane()\\n  radial_dimension = \\\\\\n    RadialDimension(center, point_on_curve, plane.XAxis, plane.Normal, 5.0)\\n  doc.Objects.AddRadialDimension(radial_dimension)\\n  doc.Views.Redraw()\\n  return Result.Success\\n\\nif __name__==\\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.Curve","Vector3d CurvatureAt(double t)"],["Rhino.Geometry.Curve","bool IsLinear()"],["Rhino.Geometry.Curve","bool IsPlanar()"],["Rhino.Geometry.Curve","bool IsPolyline()"],["Rhino.Geometry.Curve","Point3d PointAt(double t)"],["Rhino.DocObjects.ObjRef","Curve CurveParameter(out double parameter)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddRadialDimension(RadialDimension dimension)"]]},{"name":"Addsphere.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef AddSphere():\\n    center = Rhino.Geometry.Point3d(0, 0, 0)\\n    radius = 5.0\\n    sphere = Rhino.Geometry.Sphere(center, radius)\\n    if scriptcontext.doc.Objects.AddSphere(sphere)!=System.Guid.Empty:\\n        scriptcontext.doc.Views.Redraw()\\n        return Rhino.Commands.Result.Success\\n    return Rhino.Commands.Result.Failure\\n\\n\\nif __name__ == \\"__main__\\":\\n    AddSphere()\\n","members":[["Rhino.Geometry.Sphere","Sphere(Point3d center, double radius)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddSphere(Sphere sphere)"]]},{"name":"Addtext.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef AddAnnotationText():\\n    pt = Rhino.Geometry.Point3d(10, 0, 0)\\n    text = \\"Hello RhinoCommon\\"\\n    height = 2.0\\n    font = \\"Arial\\"\\n    plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\\n    plane.Origin = pt\\n    id = scriptcontext.doc.Objects.AddText(text, plane, height, font, False, False)\\n    if id!=System.Guid.Empty:\\n        scriptcontext.doc.Views.Redraw()\\n        return Rhino.Commands.Result.Success\\n    return Rhino.Commands.Result.Failure\\n\\n\\nif __name__==\\"__main__\\":\\n    AddAnnotationText()\\n","members":[["Rhino.DocObjects.Tables.ObjectTable","Guid AddText(string text, Plane plane, double height, string fontName, bool bold, bool italic)"]]},{"name":"Addtorus.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef AddTorus():\\n    major_radius = 4.0\\n    minor_radius = 2.0\\n\\n    plane = Rhino.Geometry.Plane.WorldXY\\n    torus = Rhino.Geometry.Torus(plane, major_radius, minor_radius)\\n    revsrf = torus.ToRevSurface()\\n\\n    if scriptcontext.doc.Objects.AddSurface(revsrf)!=System.Guid.Empty:\\n        scriptcontext.doc.Views.Redraw()\\n        return Rhino.Commands.Result.Success\\n    return Rhino.Commands.Result.Failure\\n\\n\\nif __name__==\\"__main__\\":\\n    AddTorus()\\n","members":[["Rhino.Geometry.Torus","Torus(Plane basePlane, double majorRadius, double minorRadius)"],["Rhino.Geometry.Torus","RevSurface ToRevSurface()"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddSurface(Surface surface)"]]},{"name":"Addtruncatedcone.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef AddTruncatedCone():\\n    bottom_pt = Rhino.Geometry.Point3d(0,0,0)\\n    bottom_radius = 2\\n    bottom_circle = Rhino.Geometry.Circle(bottom_pt, bottom_radius)\\n\\n    top_pt = Rhino.Geometry.Point3d(0,0,10)\\n    top_radius = 6\\n    top_circle = Rhino.Geometry.Circle(top_pt, top_radius)\\n\\n    shapeCurve = Rhino.Geometry.LineCurve(bottom_circle.PointAt(0), top_circle.PointAt(0))\\n    axis = Rhino.Geometry.Line(bottom_circle.Center, top_circle.Center)\\n    revsrf = Rhino.Geometry.RevSurface.Create(shapeCurve, axis)\\n    tcone_brep = Rhino.Geometry.Brep.CreateFromRevSurface(revsrf, True, True)\\n\\n    if scriptcontext.doc.Objects.AddBrep(tcone_brep)!=System.Guid.Empty:\\n        scriptcontext.doc.Views.Redraw()\\n        return Rhino.Commands.Result.Success\\n    return Rhino.Commands.Result.Failure\\n\\n\\nif __name__==\\"__main__\\":\\n    AddTruncatedCone()\\n","members":[["Rhino.Geometry.Brep","static Brep CreateFromRevSurface(RevSurface surface, bool capStart, bool capEnd)"],["Rhino.Geometry.Circle","Circle(Point3d center, double radius)"],["Rhino.Geometry.LineCurve","LineCurve(Point3d from, Point3d to)"],["Rhino.Geometry.RevSurface","static RevSurface Create(Curve revoluteCurve, Line axisOfRevolution)"]]},{"name":"Advanceddisplay.py","code":"import Rhino\\nimport scriptcontext\\n\\n# The following example demonstrates how to modify advanced display settings\\n# using RhinoCommon. In this example, a display mode\'s mesh wireframe thickness\\n# (in pixels) will be modified.\\ndef AdvancedDisplay():\\n    # Use the display attributes manager to build a list of display modes.\\n    # Note, these are copies of the originals...\\n    display_modes = Rhino.Display.DisplayModeDescription.GetDisplayModes()\\n    if not display_modes: return Rhino.Commands.Result.Failure\\n    \\n    # Construct an options picker so the user can pick which\\n    # display mode they want modified\\n    go = Rhino.Input.Custom.GetOption()\\n    go.SetCommandPrompt(\\"Display mode to modify mesh thickness\\")\\n    opt_list = []\\n    for i, mode in enumerate(display_modes):\\n        english_name = mode.EnglishName\\n        english_name = english_name.translate(None, \\"_ -,.\\")\\n        opt_list.append( go.AddOption(english_name) )\\n    \\n    # Get the command option\\n    go.Get()\\n    if go.CommandResult()!=Rhino.Commands.Result.Success:\\n      return go.CommandResult();\\n\\n    selected_index = go.Option().Index\\n    selected_description = None\\n    for i,option in enumerate(opt_list):\\n        if option==selected_index:\\n            selected_description = display_modes[i]\\n            break\\n    # Validate...\\n    if not selected_description: return Rhino.Commands.Result.Failure\\n    \\n    # Modify the desired display mode. In this case, we\\n    # will just set the mesh wireframe thickness to zero.\\n    selected_description.DisplayAttributes.MeshSpecificAttributes.MeshWireThickness = 0\\n    # Use the display attributes manager to update the display mode.\\n    Rhino.Display.DisplayModeDescription.UpdateDisplayMode(selected_description)\\n    # Force the document to regenerate.\\n    scriptcontext.doc.Views.Redraw()\\n    return Rhino.Commands.Result.Success\\n\\nif __name__==\\"__main__\\":\\n    AdvancedDisplay()\\n","members":[["Rhino.Display.DisplayModeDescription","DisplayPipelineAttributes DisplayAttributes"],["Rhino.Display.DisplayModeDescription","static DisplayModeDescription[] GetDisplayModes()"],["Rhino.Display.DisplayModeDescription","static bool UpdateDisplayMode(DisplayModeDescription displayMode)"],["Rhino.Input.Custom.GetBaseClass","int AddOption(string englishOption)"]]},{"name":"Arclengthpoint.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef ArcLengthPoint():\\n    rc, objref = Rhino.Input.RhinoGet.GetOneObject(\\"Select curve\\", True, Rhino.DocObjects.ObjectType.Curve)\\n    if rc!=Rhino.Commands.Result.Success: return rc\\n    crv = objref.Curve()\\n    if not crv: return Rhino.Commands.Result.Failure\\n    crv_length = crv.GetLength()\\n    length = 0\\n    rc, length = Rhino.Input.RhinoGet.GetNumber(\\"Length from start\\", True, length, 0, crv_length)\\n    if rc!=Rhino.Commands.Result.Success: return rc\\n    pt = crv.PointAtLength(length)\\n    if pt.IsValid:\\n        scriptcontext.doc.Objects.AddPoint(pt)\\n        scriptcontext.doc.Views.Redraw()\\n    return Rhino.Commands.Result.Success\\n\\nif __name__==\\"__main__\\":\\n    ArcLengthPoint()\\n","members":[["Rhino.Geometry.Curve","double GetLength()"],["Rhino.Geometry.Curve","Point3d PointAtLength(double length)"]]},{"name":"Arraybydistance.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef dynamic_array():\\n    rc, objref = Rhino.Input.RhinoGet.GetOneObject(\\"Select object\\", True, Rhino.DocObjects.ObjectType.AnyObject)\\n    if rc!=Rhino.Commands.Result.Success: return\\n    \\n    rc, pt_start = Rhino.Input.RhinoGet.GetPoint(\\"Start point\\", False)\\n    if rc!=Rhino.Commands.Result.Success: return\\n    \\n    obj = objref.Object()\\n    if not obj: return\\n    \\n    dist = 1\\n    if scriptcontext.sticky.has_key(\\"dynamic_array_distance\\"):\\n        dist = scriptcontext.sticky[\\"dynamic_array_distance\\"]\\n    # This is a function that is called whenever the GetPoint\'s\\n    # DynamicDraw event occurs\\n    def ArrayByDistanceDraw( sender, args ):\\n        rhobj = args.Source.Tag\\n        if not rhobj: return\\n        vec = args.CurrentPoint - pt_start\\n        length = vec.Length\\n        vec.Unitize()\\n        count = int(length / dist)\\n        for i in range(1,count):\\n            translate = vec * (i*dist)\\n            xf = Rhino.Geometry.Transform.Translation(translate)\\n            args.Display.DrawObject(rhobj, xf)\\n\\n    # Create an instance of a GetPoint class and add a delegate\\n    # for the DynamicDraw event\\n    gp = Rhino.Input.Custom.GetPoint()\\n    gp.DrawLineFromPoint(pt_start, True)\\n    optdouble = Rhino.Input.Custom.OptionDouble(dist)\\n    constrain = False\\n    optconstrain = Rhino.Input.Custom.OptionToggle(constrain,\\"Off\\", \\"On\\")\\n    gp.AddOptionDouble(\\"Distance\\", optdouble)\\n    gp.AddOptionToggle(\\"Constrain\\", optconstrain)\\n    gp.DynamicDraw += ArrayByDistanceDraw\\n    gp.Tag = obj\\n    while gp.Get()==Rhino.Input.GetResult.Option:\\n        dist = optdouble.CurrentValue\\n        if constrain!=optconstrain.CurrentValue:\\n            constrain = optconstrain.CurrentValue\\n            if constrain:\\n                gp2 = Rhino.Input.Custom.GetPoint()\\n                gp2.DrawLineFromPoint(pt_start, True)\\n                gp2.SetCommandPrompt(\\"Second point on constraint line\\")\\n                if gp2.Get()==Rhino.Input.GetResult.Point:\\n                    gp.Constrain(pt_start, gp2.Point())\\n                else:\\n                    gp.ClearCommandOptions()\\n                    optconstrain.CurrentValue = False\\n                    constrain = False\\n                    gp.AddOptionDouble(\\"Distance\\", optdouble)\\n                    gp.AddOptionToggle(\\"Constrain\\", optconstrain)\\n            else:\\n                gp.ClearConstraints()\\n        continue\\n    if gp.CommandResult()==Rhino.Commands.Result.Success:\\n        scriptcontext.sticky[\\"dynamic_array_distance\\"] = dist\\n        pt = gp.Point()\\n        vec = pt - pt_start\\n        length = vec.Length\\n        vec.Unitize()\\n        count = int(length / dist)\\n        for i in range(1, count):\\n            translate = vec * (i*dist)\\n            xf = Rhino.Geometry.Transform.Translation(translate)\\n            scriptcontext.doc.Objects.Transform(obj,xf,False)\\n        scriptcontext.doc.Views.Redraw()\\n\\n\\nif( __name__ == \\"__main__\\" ):\\n    dynamic_array()","members":[["Rhino.Display.DisplayPipeline","void DrawObject(RhinoObject rhinoObject, Transform xform)"],["Rhino.Input.Custom.GetBaseClass","void ClearCommandOptions()"],["Rhino.Input.Custom.GetPoint","object Tag"],["Rhino.Input.Custom.GetPoint","void ClearConstraints()"],["Rhino.Input.Custom.GetPoint","bool Constrain(Point3d from, Point3d to)"],["Rhino.Input.Custom.GetPointDrawEventArgs","GetPoint Source"]]},{"name":"Blockinsertionpoint.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef BlockInsertionPoint():\\n    rc, objref = Rhino.Input.RhinoGet.GetOneObject(\\"Select instance\\", True, Rhino.DocObjects.ObjectType.InstanceReference)\\n    if rc!=Rhino.Commands.Result.Success: return rc;\\n    instance = objref.Object()\\n    if instance:\\n        pt = instance.InsertionPoint\\n        scriptcontext.doc.Objects.AddPoint(pt)\\n        scriptcontext.doc.Views.Redraw()\\n        return Rhino.Commands.Result.Success\\n    return Rhino.Commands.Result.Failure\\n\\nif __name__==\\"__main__\\":\\n    BlockInsertionPoint()\\n","members":[["Rhino.DocObjects.InstanceObject","Point3d InsertionPoint"]]},{"name":"Booleandifference.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef BooleanDifference():\\n    filter = Rhino.DocObjects.ObjectType.PolysrfFilter\\n    rc, objrefs = Rhino.Input.RhinoGet.GetMultipleObjects(\\"Select first set of polysurfaces\\", False, filter)\\n    if rc != Rhino.Commands.Result.Success: return rc\\n    if not objrefs: return Rhino.Commands.Result.Failure\\n\\n    in_breps0 = []\\n    for objref in objrefs:\\n        brep = objref.Brep()\\n        if brep: in_breps0.append(brep)\\n\\n    scriptcontext.doc.Objects.UnselectAll()\\n    rc, objrefs = Rhino.Input.RhinoGet.GetMultipleObjects(\\"Select second set of polysurfaces\\", False, filter)\\n    if rc != Rhino.Commands.Result.Success: return rc\\n    if not objrefs: return Rhino.Commands.Result.Failure\\n\\n    in_breps1 = []\\n    for objref in objrefs:\\n        brep = objref.Brep()\\n        if brep: in_breps1.append(brep)\\n\\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\\n    breps = Rhino.Geometry.Brep.CreateBooleanDifference(in_breps0, in_breps1, tolerance)\\n    if not breps: return Rhino.Commands.Result.Nothing\\n    for brep in breps: scriptcontext.doc.Objects.AddBrep(brep)\\n    scriptcontext.doc.Views.Redraw()\\n    return Rhino.Commands.Result.Success\\n\\nif __name__==\\"__main__\\":\\n    BooleanDifference()","members":[["Rhino.Geometry.Brep","static Brep[] CreateBooleanDifference(IEnumerable<Brep> firstSet, IEnumerable<Brep> secondSet, double tolerance)"],["Rhino.Geometry.Brep","static Brep[] CreateBooleanDifference(IEnumerable<Brep> firstSet, IEnumerable<Brep> secondSet, double tolerance, bool manifoldOnly)"],["Rhino.DocObjects.ObjRef","Brep Brep()"],["Rhino.Input.RhinoGet","static Result GetMultipleObjects(string prompt, bool acceptNothing, ObjectType filter, out ObjRef[] rhObjects)"]]},{"name":"Circlecenter.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef CircleCenter():\\n    go = Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt(\\"Select objects\\")\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\\n    go.GeometryAttributeFilter = Rhino.Input.Custom.GeometryAttributeFilter.ClosedCurve\\n    go.GetMultiple(1, 0)\\n    if go.CommandResult()!=Rhino.Commands.Result.Success:\\n        return go.CommandResult()\\n\\n    objrefs = go.Objects()\\n    if not objrefs: return Rhino.Commands.Result.Nothing\\n\\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\\n    for i, objref in enumerate(objrefs):\\n        # get the curve geometry\\n        curve = objref.Curve()\\n        if not curve: continue\\n        rc, circle = curve.TryGetCircle( tolerance )\\n        if rc:\\n            print \\"Circle\\", i+1, \\": center = \\", circle.Center\\n    return Rhino.Commands.Result.Success\\n\\nif __name__==\\"__main__\\":\\n    CircleCenter()","members":[["Rhino.Geometry.Curve","bool TryGetCircle(out Circle circle, double tolerance)"],["Rhino.Input.Custom.GetObject","GeometryAttributeFilter GeometryAttributeFilter"]]},{"name":"Closestpoint.py","code":"import Rhino\\nimport rhinoscriptsyntax as rs\\n\\n# data passed to the RTree\'s SearchCallback function that\\n# we can use for recording what is going on\\nclass SearchData:\\n    def __init__(self, mesh, point):\\n        self.HitCount = 0\\n        self.Mesh = mesh\\n        self.Point = point\\n        self.Index = -1\\n        self.Distance = 0\\n        \\n\\ndef SearchCallback(sender, e):\\n    data = e.Tag\\n    data.HitCount += 1\\n    vertex = data.Mesh.Vertices[e.Id]\\n    distance = data.Point.DistanceTo(vertex)\\n    if data.Index == -1 or data.Distance > distance:\\n        # shrink the sphere to help improve the test\\n        e.SearchSphere = Rhino.Geometry.Sphere(data.Point, distance)\\n        data.Index = e.Id\\n        data.Distance = distance\\n\\ndef RunSearch():\\n    id = rs.GetObject(\\"select mesh\\", rs.filter.mesh)\\n    mesh = rs.coercemesh(id)\\n    if mesh:\\n        rs.UnselectObject(id)\\n        tree = Rhino.Geometry.RTree()\\n        # I can add a RhinoCommon function that just builds an rtree from the\\n        # vertices in one quick shot, but for now...\\n        for i,vertex in enumerate(mesh.Vertices): tree.Insert(vertex, i)\\n        \\n        while(True):\\n            point = rs.GetPoint(\\"test point\\")\\n            if not point: break\\n            \\n            data = SearchData(mesh, point)\\n            # Use the first vertex in the mesh to define a start sphere\\n            distance = point.DistanceTo(mesh.Vertices[0])\\n            sphere = Rhino.Geometry.Sphere(point, distance * 1.1)\\n            if tree.Search(sphere, SearchCallback, data):\\n                rs.AddPoint(mesh.Vertices[data.Index])\\n                print \\"Found point in {0} tests\\".format(data.HitCount)\\n\\nif __name__==\\"__main__\\":\\n    RunSearch()\\n","members":[["Rhino.Geometry.RTree","RTree()"],["Rhino.Geometry.RTree","bool Insert(Point3d point, int elementId)"],["Rhino.Geometry.RTree","bool Search(Sphere sphere, EventHandler<RTreeEventArgs> callback, object tag)"]]},{"name":"Commandlineoptions.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef CommandLineOptions():\\n    # For this example we will use a GetPoint class, but all of the custom\\n    # \\"Get\\" classes support command line options.\\n    gp = Rhino.Input.Custom.GetPoint()\\n    gp.SetCommandPrompt(\\"GetPoint with options\\")\\n    \\n    # set up the options\\n    intOption = Rhino.Input.Custom.OptionInteger(1, 1, 99)\\n    dblOption = Rhino.Input.Custom.OptionDouble(2.2, 0, 99.9)\\n    boolOption = Rhino.Input.Custom.OptionToggle(True, \\"Off\\", \\"On\\")\\n    listValues = \\"Item0\\", \\"Item1\\", \\"Item2\\", \\"Item3\\", \\"Item4\\"\\n    \\n    gp.AddOptionInteger(\\"Integer\\", intOption)\\n    gp.AddOptionDouble(\\"Double\\", dblOption)\\n    gp.AddOptionToggle(\\"Boolean\\", boolOption)\\n    listIndex = 3\\n    opList = gp.AddOptionList(\\"List\\", listValues, listIndex)\\n    while True:\\n        # perform the get operation. This will prompt the user to\\n        # input a point, but also allow for command line options\\n        # defined above\\n        get_rc = gp.Get()\\n        if gp.CommandResult()!=Rhino.Commands.Result.Success:\\n            return gp.CommandResult()\\n        if get_rc==Rhino.Input.GetResult.Point:\\n            point = gp.Point()\\n            scriptcontext.doc.Objects.AddPoint(point)\\n            scriptcontext.doc.Views.Redraw()\\n            print \\"Command line option values are\\"\\n            print \\" Integer =\\", intOption.CurrentValue\\n            print \\" Double =\\", dblOption.CurrentValue\\n            print \\" Boolean =\\", boolOption.CurrentValue\\n            print \\" List =\\", listValues[listIndex]\\n        elif get_rc==Rhino.Input.GetResult.Option:\\n            if gp.OptionIndex()==opList:\\n              listIndex = gp.Option().CurrentListOptionIndex\\n            continue\\n        break\\n    return Rhino.Commands.Result.Success\\n\\n\\nif __name__ == \\"__main__\\":\\n    CommandLineOptions()\\n\\n","members":[["Rhino.Input.Custom.GetBaseClass","int AddOptionDouble(LocalizeStringPair optionName, ref OptionDouble numberValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionDouble(string englishName, ref OptionDouble numberValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionInteger(LocalizeStringPair optionName, ref OptionInteger intValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionInteger(string englishName, ref OptionInteger intValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionToggle(LocalizeStringPair optionName, ref OptionToggle toggleValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionToggle(string englishName, ref OptionToggle toggleValue)"],["Rhino.Input.Custom.CommandLineOption","int CurrentListOptionIndex"],["Rhino.Input.Custom.OptionToggle","OptionToggle(bool initialValue, string offValue, string onValue)"],["Rhino.Input.Custom.OptionToggle","bool CurrentValue"],["Rhino.Input.Custom.OptionDouble","OptionDouble(double initialValue, double lowerLimit, double upperLimit)"],["Rhino.Input.Custom.OptionDouble","double CurrentValue"],["Rhino.Input.Custom.OptionInteger","OptionInteger(int initialValue, int lowerLimit, int upperLimit)"],["Rhino.Input.Custom.OptionInteger","int CurrentValue"]]},{"name":"Conduitarrowheads.py","code":"import Rhino\\nimport System.Drawing\\nimport scriptcontext\\nimport rhinoscriptsyntax as rs\\n\\nclass DrawArrowHeadsConduit(Rhino.Display.DisplayConduit):\\n  def __init__(self, line, screenSize, worldSize):\\n    self.line = line\\n    self.screenSize = screenSize\\n    self.worldSize = worldSize\\n\\n  def DrawForeground(self, e):\\n    e.Display.DrawArrow(self.line, System.Drawing.Color.Black, self.screenSize, self.worldSize)\\n\\ndef RunCommand():\\n  # get arrow head size\\n  go = Rhino.Input.Custom.GetOption()\\n  go.SetCommandPrompt(\\"ArrowHead length in screen size (pixles) or world size (percentage of arrow lenght)?\\")\\n  go.AddOption(\\"screen\\")\\n  go.AddOption(\\"world\\")\\n  go.Get()\\n  if (go.CommandResult() != Rhino.Commands.Result.Success):\\n    return go.CommandResult()\\n\\n  screenSize = 0\\n  worldSize = 0.0\\n  if (go.Option().EnglishName == \\"screen\\"):\\n    gi = Rhino.Input.Custom.GetInteger()\\n    gi.SetLowerLimit(0,True)\\n    gi.SetCommandPrompt(\\"Length of arrow head in pixels\\")\\n    gi.Get()\\n    if (gi.CommandResult() != Rhino.Commands.Result.Success):\\n      return gi.CommandResult()\\n    screenSize = gi.Number()\\n  else:\\n    gi = Rhino.Input.Custom.GetInteger()\\n    gi.SetLowerLimit(0, True)\\n    gi.SetUpperLimit(100, False)\\n    gi.SetCommandPrompt(\\"Lenght of arrow head in percentage of total arrow lenght\\")\\n    gi.Get()\\n    if (gi.CommandResult() != Rhino.Commands.Result.Success):\\n      return gi.CommandResult()\\n    worldSize = gi.Number()/100.0\\n\\n\\n  # get arrow start and end points\\n  gp = Rhino.Input.Custom.GetPoint()\\n  gp.SetCommandPrompt(\\"Start of line\\")\\n  gp.Get()\\n  if (gp.CommandResult() != Rhino.Commands.Result.Success):\\n    return gp.CommandResult()\\n  ptStart = gp.Point()\\n\\n  gp.SetCommandPrompt(\\"End of line\\")\\n  gp.SetBasePoint(ptStart, False)\\n  gp.DrawLineFromPoint(ptStart, True)\\n  gp.Get()\\n  if (gp.CommandResult() != Rhino.Commands.Result.Success):\\n    return gp.CommandResult()\\n  ptEnd = gp.Point()\\n\\n\\n  v = ptEnd - ptStart\\n  if (v.IsTiny(Rhino.RhinoMath.ZeroTolerance)):\\n    return Rhino.Commands.Result.Nothing\\n\\n  line = Rhino.Geometry.Line(ptStart, ptEnd)\\n\\n  conduit = DrawArrowHeadsConduit(line, screenSize, worldSize)\\n  conduit.Enabled = True\\n  scriptcontext.doc.Views.Redraw()\\n  rs.GetString(\\"Pausing for user input\\")\\n  conduit.Enabled = False\\n  scriptcontext.doc.Views.Redraw()\\n\\n  return Rhino.Commands.Result.Success\\n\\nif __name__==\\"__main__\\":\\n  RunCommand()\\n","members":[["Rhino.Display.DisplayPipeline","void DrawArrow(Line line, Color color, double screenSize, double relativeSize)"]]},{"name":"Conduitbitmap.py","code":"import Rhino\\nfrom Rhino.Geometry import *\\nimport System.Drawing\\nimport Rhino.Display\\nimport scriptcontext\\nimport rhinoscriptsyntax as rs\\n\\nclass CustomConduit(Rhino.Display.DisplayConduit):\\n    def __init__(self):\\n      flag = System.Drawing.Bitmap(100,100)\\n      for x in range(0,100):\\n        for y in range(0,100):\\n          flag.SetPixel(x, y, System.Drawing.Color.Red)\\n      g = System.Drawing.Graphics.FromImage(flag)\\n      g.FillEllipse(System.Drawing.Brushes.Blue, 25, 25, 50, 50)\\n      self.display_bitmap = Rhino.Display.DisplayBitmap(flag)\\n\\n    def DrawForeground(self, e):\\n      e.Display.DrawBitmap(self.display_bitmap, 50, 50, System.Drawing.Color.Red)\\n\\nif __name__== \\"__main__\\":\\n    conduit = CustomConduit()\\n    conduit.Enabled = True\\n    scriptcontext.doc.Views.Redraw()\\n    rs.GetString(\\"Pausing for user input\\")\\n    conduit.Enabled = False\\n    scriptcontext.doc.Views.Redraw()","members":[["Rhino.Display.DisplayPipeline","void DrawBitmap(DisplayBitmap bitmap, int left, int top)"]]},{"name":"Constrainedcopy.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef constrainedcopy():\\n    #get a single closed curve\\n    go = Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt(\\"Select curve\\")\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\\n    go.GeometryAttributeFilter = Rhino.Input.Custom.GeometryAttributeFilter.ClosedCurve\\n    go.Get()\\n    if go.CommandResult() != Rhino.Commands.Result.Success: return\\n    objref = go.Object(0)\\n    base_curve = objref.Curve()\\n    first_point = objref.SelectionPoint()\\n    if not base_curve or not first_point.IsValid:\\n        return\\n    isplanar, plane = base_curve.TryGetPlane()\\n    if not isplanar: return\\n    \\n    gp = Rhino.Input.Custom.GetPoint()\\n    gp.SetCommandPrompt(\\"Offset point\\")\\n    gp.DrawLineFromPoint(first_point, True)\\n    line = Rhino.Geometry.Line(first_point, first_point + plane.Normal)\\n    gp.Constrain(line)\\n    gp.Get()\\n    if gp.CommandResult() != Rhino.Commands.Result.Success:\\n        return\\n    second_point = gp.Point()\\n    vec = second_point - first_point\\n    if vec.Length > 0.001:\\n        xf = Rhino.Geometry.Transform.Translation(vec)\\n        id = scriptcontext.doc.Objects.Transform(objref, xf, False)\\n        scriptcontext.doc.Views.Redraw()\\n        return id\\n\\nif __name__==\\"__main__\\":\\n    constrainedcopy()\\n","members":[["Rhino.Geometry.Curve","bool TryGetPlane(out Plane plane)"],["Rhino.Geometry.Transform","static Transform Translation(Vector3d motion)"],["Rhino.DocObjects.ObjRef","Point3d SelectionPoint()"],["Rhino.Input.Custom.GetPoint","bool Constrain(Line line)"]]},{"name":"Createblock.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef CreateBlock():\\n    # Select objects to define block\\n    go = Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt( \\"Select objects to define block\\" )\\n    go.ReferenceObjectSelect = False\\n    go.SubObjectSelect = False\\n    go.GroupSelect = True\\n\\n    # Phantoms, grips, lights, etc., cannot be in blocks.\\n    forbidden_geometry_filter = Rhino.DocObjects.ObjectType.Light | Rhino.DocObjects.ObjectType.Grip | Rhino.DocObjects.ObjectType.Phantom\\n    geometry_filter = forbidden_geometry_filter ^ Rhino.DocObjects.ObjectType.AnyObject\\n    go.GeometryFilter = geometry_filter\\n    go.GetMultiple(1, 0)\\n    if go.CommandResult() != Rhino.Commands.Result.Success:\\n        return go.CommandResult()\\n\\n    # Block base point\\n    rc, base_point = Rhino.Input.RhinoGet.GetPoint(\\"Block base point\\", False)\\n    if rc != Rhino.Commands.Result.Success: return rc\\n\\n    # Block definition name\\n    rc, idef_name = Rhino.Input.RhinoGet.GetString(\\"Block definition name\\", False, \\"\\")\\n    if rc != Rhino.Commands.Result.Success: return rc\\n    # Validate block name\\n    idef_name = idef_name.strip()\\n    if not idef_name: return Rhino.Commands.Result.Nothing\\n\\n    # See if block name already exists\\n    existing_idef = scriptcontext.doc.InstanceDefinitions.Find(idef_name, True)\\n    if existing_idef:\\n        print \\"Block definition\\", idef_name, \\"already exists\\"\\n        return Rhino.Commands.Result.Nothing\\n\\n    # Gather all of the selected objects\\n    objrefs = go.Objects()\\n    geometry = [item.Object().Geometry for item in objrefs]\\n    attributes = [item.Object().Attributes for item in objrefs]\\n\\n    # Add the instance definition\\n    idef_index = scriptcontext.doc.InstanceDefinitions.Add(idef_name, \\"\\", base_point, geometry, attributes)\\n\\n    if idef_index<0:\\n        print \\"Unable to create block definition\\", idef_name\\n        return Rhino.Commands.Result.Failure\\n    return Rhino.Commands.Result.Failure\\n\\n\\nif __name__==\\"__main__\\":\\n    CreateBlock()\\n","members":[["Rhino.Input.Custom.GetObject","bool ReferenceObjectSelect"],["Rhino.DocObjects.Tables.InstanceDefinitionTable","int Add(string name, string description, Point3d basePoint, IEnumerable<GeometryBase> geometry, IEnumerable<ObjectAttributes> attributes)"],["Rhino.DocObjects.Tables.InstanceDefinitionTable","InstanceDefinition Find(string instanceDefinitionName)"],["Rhino.DocObjects.Tables.InstanceDefinitionTable","InstanceDefinition Find(string instanceDefinitionName, bool ignoreDeletedInstanceDefinitions)"]]},{"name":"Createmeshfrombrep.py","code":"import Rhino\\nfrom Rhino.Geometry import *\\nfrom Rhino.Input import RhinoGet\\nfrom Rhino.Commands import Result\\nfrom Rhino.DocObjects import ObjectType\\nimport rhinoscriptsyntax as rs\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  rc, objRef = RhinoGet.GetOneObject(\\"Select surface or polysurface to mesh\\", True, \\n                                     ObjectType.Surface | ObjectType.PolysrfFilter)\\n  if rc <> Result.Success:\\n    return rc\\n  brep = objRef.Brep()\\n  if None == brep:\\n    return Result.Failure\\n\\n  jaggedAndFaster = MeshingParameters.Coarse\\n  smoothAndSlower = MeshingParameters.Smooth\\n  defaultMeshParams = MeshingParameters.Default\\n  minimal = MeshingParameters.Minimal\\n\\n  meshes = Mesh.CreateFromBrep(brep, smoothAndSlower)\\n  if meshes == None or meshes.Length == 0:\\n    return Result.Failure\\n\\n  brepMesh = Mesh()\\n  for mesh in meshes:\\n    brepMesh.Append(mesh)\\n  doc.Objects.AddMesh(brepMesh)\\n  doc.Views.Redraw()\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()\\n","members":[["Rhino.Geometry.MeshingParameters","static MeshingParameters Coarse"],["Rhino.Geometry.MeshingParameters","static MeshingParameters Default"],["Rhino.Geometry.MeshingParameters","static MeshingParameters Minimal"],["Rhino.Geometry.MeshingParameters","static MeshingParameters Smooth"],["Rhino.Geometry.Mesh","static Mesh[] CreateFromBrep(Brep brep, MeshingParameters meshingParameters)"],["Rhino.Geometry.Mesh","void Append(Mesh other)"]]},{"name":"Createsurfaceexample.py","code":"from Rhino.Geometry import Point3d, NurbsSurface, ControlPoint\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  bIsRational = False\\n  dim = 3\\n  u_degree = 2\\n  v_degree = 3\\n  u_cv_count = 3\\n  v_cv_count = 5\\n \\n  # make up a quadratic knot vector with no interior knots\\n  u_knot = [0.0, 0.0, 1.0, 1.0] \\n \\n  # make up a cubic knot vector with one simple interior knot\\n  v_knot = [0.0, 0.0, 0.0, 1.5, 2.0, 2.0, 2.0]\\n \\n  # Rational control points can be in either homogeneous\\n  # or euclidean form. Non-rational control points do not\\n  # need to specify a weight.  \\n  CV = dict( ((i,j),None) for i in range(2) for j in range(3) )\\n  for i in range(0, u_cv_count):\\n    for j in range(0, v_cv_count):\\n      CV[i,j] = Point3d(i, j, i-j)\\n \\n  # creates internal uninitialized arrays for \\n  # control points and knots\\n  nurbs_surface = NurbsSurface.Create(\\n    dim,\\n    bIsRational,\\n    u_degree + 1,\\n    v_degree + 1,\\n    u_cv_count,\\n    v_cv_count\\n    )\\n \\n  # add the knots\\n  for i in range(0, nurbs_surface.KnotsU.Count):\\n    nurbs_surface.KnotsU[i] = u_knot[i]\\n  for j in range(0, nurbs_surface.KnotsV.Count):\\n    nurbs_surface.KnotsV[j] = v_knot[j]\\n\\n  # add the control points\\n  for i in range(0, nurbs_surface.Points.CountU):\\n    for j in range(0, nurbs_surface.Points.CountV):\\n      nurbs_surface.Points.SetControlPoint(i, j, ControlPoint(CV[i, j]))\\n\\n  if nurbs_surface.IsValid:\\n    doc.Objects.AddSurface(nurbs_surface)\\n    doc.Views.Redraw()\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.NurbsSurface","NurbsSurfaceKnotList KnotsU"],["Rhino.Geometry.NurbsSurface","NurbsSurfaceKnotList KnotsV"],["Rhino.Geometry.NurbsSurface","NurbsSurfacePointList Points"],["Rhino.Geometry.NurbsSurface","static NurbsSurface Create(int dimension, bool isRational, int order0, int order1, int controlPointCount0, int controlPointCount1)"]]},{"name":"Crvdeviation.py","code":"import rhinoscriptsyntax as rs\\nimport scriptcontext\\nimport Rhino\\n\\ndef RunCommand():\\n  crvA = rs.GetCurveObject(\\"first curve\\")[0]\\n  crvA = rs.coercecurve(crvA)\\n  crvB = rs.GetCurveObject(\\"second curve\\")[0]\\n  crvB = rs.coercecurve(crvB)\\n  if crvA == None or crvB == None:\\n      return Rhino.Commands.Result.Failure\\n      \\n  maxa, maxb, maxd, mina, minb, mind = rs.CurveDeviation(crvA, crvB)\\n  \\n  if mind <= Rhino.RhinoMath.ZeroTolerance:\\n      mind = 0.0;\\n  maxDistPtA = crvA.PointAt(maxa)\\n  maxDistPtB = crvB.PointAt(maxb)\\n  minDistPtA = crvA.PointAt(mina)\\n  minDistPtB = crvB.PointAt(minb)\\n\\n  print \\"Minimum deviation = {0}   pointA({1}, {2}, {3}), pointB({4}, {5}, {6})\\".format(\\n    mind, minDistPtA.X, minDistPtA.Y, minDistPtA.Z, minDistPtB.X, minDistPtB.Y, minDistPtB.Z)\\n  print \\"Maximum deviation = {0}   pointA({1}, {2}, {3}), pointB({4}, {5}, {6})\\".format(\\n    maxd, maxDistPtA.X, maxDistPtA.Y, maxDistPtA.Z, maxDistPtB.X, maxDistPtB.Y, maxDistPtB.Z)\\n\\nif __name__==\\"__main__\\":\\n  RunCommand()\\n","members":[["Rhino.Geometry.Curve","static bool GetDistancesBetweenCurves(Curve curveA, Curve curveB, double tolerance, out double maxDistance, out double maxDistanceParameterA, out double maxDistanceParameterB, out double minDistance, out double minDistanceParameterA, out double minDistanceParameterB)"],["Rhino.DocObjects.Tables.ObjectTable","int UnselectAll()"]]},{"name":"Curveboundingbox.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef CurveBoundingBox():\\n    # Select a curve object\\n    rc, rhobject = Rhino.Input.RhinoGet.GetOneObject(\\"Select curve\\", False, Rhino.DocObjects.ObjectType.Curve)\\n    if rc!=Rhino.Commands.Result.Success: return\\n\\n    # Validate selection\\n    curve = rhobject.Curve()\\n    if not curve: return\\n\\n    ## Get the active view\'s construction plane\\n    view = scriptcontext.doc.Views.ActiveView\\n    if not view: return\\n    plane = view.ActiveViewport.ConstructionPlane()\\n\\n    # Compute the tight bounding box of the curve in world coordinates\\n    bbox = curve.GetBoundingBox(True)\\n    if not bbox.IsValid: return\\n\\n    # Print the min and max box coordinates in world coordinates\\n    print \\"World min:\\", bbox.Min\\n    print \\"World max:\\", bbox.Max\\n\\n    # Compute the tight bounding box of the curve based on the \\n    # active view\'s construction plane\\n    bbox = curve.GetBoundingBox(plane)\\n\\n    # Print the min and max box coordinates in cplane coordinates\\n    print \\"CPlane min:\\", bbox.Min\\n    print \\"CPlane max:\\", bbox.Max\\n\\nif __name__==\\"__main__\\":\\n    CurveBoundingBox()","members":[["Rhino.Geometry.GeometryBase","BoundingBox GetBoundingBox(bool accurate)"],["Rhino.Geometry.GeometryBase","BoundingBox GetBoundingBox(Plane plane)"]]},{"name":"Curvebrepbox.py","code":"import Rhino\\nfrom Rhino.Geometry import *\\nfrom Rhino.Commands import Result\\nfrom Rhino.Input import RhinoGet\\nfrom Rhino.DocObjects import ObjectType\\nimport rhinoscriptsyntax as rs\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  rc, objRef = RhinoGet.GetOneObject(\\"Select curve\\", False, ObjectType.Curve)\\n  if rc <> Result.Success:\\n    return rc\\n  curve = objRef.Curve()\\n  if None == curve:\\n    return Result.Failure\\n\\n  view = doc.Views.ActiveView\\n  plane = view.ActiveViewport.ConstructionPlane()\\n  # Create a construction plane aligned bounding box\\n  bbox = curve.GetBoundingBox(plane)\\n\\n  if bbox.IsDegenerate(doc.ModelAbsoluteTolerance) > 0:\\n    print \\"the curve\'s bounding box is degenerate (flat) in at least one direction so a box cannot be created.\\"\\n    return Result.Failure\\n\\n  brep = Brep.CreateFromBox(bbox)\\n  doc.Objects.AddBrep(brep)\\n  doc.Views.Redraw()\\n\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  print RunCommand()\\n","members":[["Rhino.Geometry.BoundingBox","int IsDegenerate(double tolerance)"],["Rhino.Geometry.Brep","static Brep CreateFromBox(BoundingBox box)"]]},{"name":"Curvereverse.py","code":"import rhinoscriptsyntax as rs\\nfrom scriptcontext import *\\nimport Rhino\\n\\ndef ReverseCurves():\\n    crvs = rs.GetObjects(\\"Select curves to reverse\\", rs.filter.curve)\\n    if not crvs: return\\n    \\n    for crvid in crvs:\\n        crv = rs.coercecurve(crvid)\\n        if not crv: continue\\n        dup = crv.DuplicateCurve()\\n        if dup:\\n            dup.Reverse()\\n        doc.Objects.Replace(crvid, dup)\\n\\nif __name__ == \\"__main__\\":\\n    ReverseCurves()","members":[["Rhino.Geometry.Curve","Curve DuplicateCurve()"],["Rhino.Geometry.Curve","bool Reverse()"]]},{"name":"Curvesurfaceintersect.py","code":"import rhinoscriptsyntax as rs\\nfrom scriptcontext import *\\nimport Rhino\\nimport System.Collections.Generic as scg\\nimport System as s\\n\\ndef RunCommand():\\n  srfid = rs.GetObject(\\"select surface\\", rs.filter.surface | rs.filter.polysurface)\\n  if not srfid: return\\n \\n  crvid = rs.GetObject(\\"select curve\\", rs.filter.curve)\\n  if not crvid: return\\n\\n  result = rs.CurveBrepIntersect(crvid, srfid)\\n  if result == None:\\n    print \\"no intersection\\"\\n    return\\n  \\n  curves, points = result\\n  for curve in curves:\\n    doc.Objects.AddCurve(rs.coercecurve(curve))\\n  for point in points:\\n    rs.AddPoint(point)\\n\\n  doc.Views.Redraw()\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()\\n","members":[["Rhino.Geometry.Intersect.Intersection","static CurveIntersections CurveSurface(Curve curve, Surface surface, double tolerance, double overlapTolerance)"],["Rhino.Geometry.Intersect.IntersectionEvent","bool IsOverlap"],["Rhino.DocObjects.Tables.ObjectTable","int Select(IEnumerable<Guid> objectIds)"]]},{"name":"Customgeometryfilter.py","code":"import rhinoscriptsyntax as rs\\nfrom scriptcontext import *\\nimport Rhino\\n\\ndef circleWithRadiusOf10GeometryFilter (rhObject, geometry, componentIndex):\\n  isCircleWithRadiusOf10 = False\\n  c = rs.coercecurve(geometry)\\n  if c:\\n    b, circle = c.TryGetCircle()\\n  if b:\\n    isCircleWithRadiusOf10 = circle.Radius <= 10.0 + Rhino.RhinoMath.ZeroTolerance and circle.Radius >= 10.0 - Rhino.RhinoMath.ZeroTolerance\\n  return isCircleWithRadiusOf10\\n\\ndef RunCommand():\\n  # only use a custom geometry filter if no simpler filter does the job\\n\\n  # for curves - only a simple filter is needed\\n  if rs.GetObject(\\"select curve\\", rs.filter.curve): #Rhino.DocObjects.ObjectType.Curve):\\n    print \\"curve vas selected\\"\\n\\n  # for circles with a radius of 10 - a custom geometry filter is needed\\n  if rs.GetObject(\\"select circle with radius of 10\\", rs.filter.curve, False, False, circleWithRadiusOf10GeometryFilter):\\n      print \\"circle with radius of 10 was selected\\"\\n\\nif __name__==\\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.Curve","bool TryGetCircle(out Circle circle)"],["Rhino.Input.Custom.GetObject","void SetCustomGeometryFilter(GetObjectGeometryFilter filter)"]]},{"name":"Customundo.py","code":"import Rhino\\nimport scriptcontext\\n\\n\\ndef OnUndoFavoriteNumber(sender, e):\\n    \\"\\"\\"!!!!!!!!!!\\n    NEVER change any setting in the Rhino document or application.  Rhino\\n    handles ALL changes to the application and document and you will break\\n    the Undo/Redo commands if you make any changes to the application or\\n    document. This is meant only for your own private plug-in data\\n    !!!!!!!!!!\\n\\n    This function can be called either by undo or redo\\n    In order to get redo to work, add another custom undo event with the\\n    current value.  If you don\'t want redo to work, just skip adding\\n    a custom undo event here\\n    \\"\\"\\"\\n    current_value = scriptcontext.sticky[\\"FavoriteNumber\\"]\\n    e.Document.AddCustomUndoEvent(\\"Favorite Number\\", OnUndoFavoriteNumber, current_value)\\n\\n    old_value = e.Tag\\n    print \\"Going back to your favorite =\\", old_value\\n    scriptcontext.sticky[\\"FavoriteNumber\\"]= old_value;\\n\\n\\ndef TestCustomUndo():\\n    \\"\\"\\"Rhino automatically sets up an undo record when a command is run,\\n       but... the undo record is not saved if nothing changes in the\\n       document (objects added/deleted, layers changed,...)\\n    \\n       If we have a command that doesn\'t change things in the document,\\n       but we want to have our own custom undo called then we need to do\\n       a little extra work\\n    \\"\\"\\"\\n    current_value = 0\\n    if scriptcontext.sticky.has_key(\\"FavoriteNumber\\"):\\n        current_value = scriptcontext.sticky[\\"FavoriteNumber\\"]\\n    rc, new_value = Rhino.Input.RhinoGet.GetNumber(\\"Favorite number\\", True, current_value)\\n    if rc!=Rhino.Commands.Result.Success: return\\n\\n    scriptcontext.doc.AddCustomUndoEvent(\\"Favorite Number\\", OnUndoFavoriteNumber, current_value);\\n    scriptcontext.sticky[\\"FavoriteNumber\\"] = new_value\\n\\nif __name__==\\"__main__\\":\\n    TestCustomUndo()\\n\\n","members":[["Rhino.RhinoDoc","bool AddCustomUndoEvent(string description, EventHandler<CustomUndoEventArgs> handler, object tag)"]]},{"name":"Dimstyle.py","code":"from Rhino import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Geometry import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  for annotation_object in doc.Objects.GetObjectList(ObjectType.Annotation):\\n    if not isinstance (annotation_object, AnnotationObjectBase):\\n      continue\\n\\n    annotation = annotation_object.Geometry\\n\\n    if annotation.Index == doc.DimStyles.CurrentDimensionStyleIndex:\\n      continue\\n\\n    annotation.Index = doc.DimStyles.CurrentDimensionStyleIndex\\n    annotation_object.CommitChanges()\\n\\n  doc.Views.Redraw()\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.RhinoDoc","DimStyleTable DimStyles"],["Rhino.DocObjects.Tables.DimStyleTable","int CurrentIndex"],["Rhino.DocObjects.Tables.ObjectTable","IEnumerable<RhinoObject> GetObjectList(Type typeFilter)"]]},{"name":"Displayorder.py","code":"from System.Collections.Generic import *\\nfrom System.Drawing import *\\nfrom Rhino import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Display import *\\nfrom Rhino.Geometry import *\\nfrom Rhino.Input import *\\nfrom Rhino.DocObjects import *\\nfrom scriptcontext import doc\\n\\nm_line_objects = []\\n\\ndef RunCommand():\\n  # make lines thick so draw order can be easily seen\\n  wfdm = [dm for dm in DisplayModeDescription.GetDisplayModes() if dm.EnglishName == \\"Wireframe\\"][0]\\n  original_thikcness = wfdm.DisplayAttributes.CurveThickness\\n  wfdm.DisplayAttributes.CurveThickness = 10\\n  DisplayModeDescription.UpdateDisplayMode(wfdm)\\n\\n  AddLine(Point3d.Origin, Point3d(10,10,0), Color.Red, doc)\\n  AddLine(Point3d(10,0,0), Point3d(0,10,0), Color.Blue, doc)\\n  AddLine(Point3d(8,0,0), Point3d(8,10,0), Color.Green, doc)\\n  AddLine(Point3d(0,3,0), Point3d(10,3,0), Color.Yellow, doc)\\n  doc.Views.Redraw()\\n  Pause(\\"draw order: 1st line drawn in front, last line drawn in the back.  Any key to continue ...\\")\\n\\n  #all objects have a DisplayOrder of 0 by default so changing it to 1 moves it to the front.  Here we move the 2nd line (blue) to the front\\n  m_line_objects[1].Attributes.DisplayOrder = 1\\n  m_line_objects[1].CommitChanges()\\n  doc.Views.Redraw()\\n  Pause(\\"Second (blue) line now in front.  Any key to continue ...\\")\\n\\n  for i in range(0, m_line_objects.Count - 1):\\n    m_line_objects[i].Attributes.DisplayOrder = i\\n    m_line_objects[i].CommitChanges()\\n\\n  doc.Views.Redraw()\\n  Pause(\\"Reverse order of original lines, i.e., Yellow 1st and Red last.  Any key to continue ...\\")\\n\\n  # restore original line thickness\\n  wfdm.DisplayAttributes.CurveThickness = original_thikcness\\n  DisplayModeDescription.UpdateDisplayMode(wfdm)\\n\\n  doc.Views.Redraw()\\n  return Result.Success\\n\\ndef Pause(msg):\\n  rc, obj_ref = RhinoGet.GetOneObject(msg, True, ObjectType.AnyObject)\\n\\ndef AddLine(from_pt, to_pt, color, doc):\\n  guid = doc.Objects.AddLine(from_pt, to_pt)\\n  obj = doc.Objects.Find(guid)\\n  m_line_objects.Add(obj)\\n  obj.Attributes.ObjectColor = color\\n  obj.Attributes.ColorSource = ObjectColorSource.ColorFromObject\\n  obj.CommitChanges()\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.DocObjects.ObjectAttributes","int DisplayOrder"]]},{"name":"Displayprecision.py","code":"from Rhino import *\\nfrom Rhino.Input.Custom import *\\nfrom Rhino.Commands import *\\nfrom scriptcontext import doc\\nimport rhinoscriptsyntax as rs\\n\\ndef RunCommand():\\n  distance_display_precision = rs.GetInteger(\\"Display precision\\",\\n    doc.ModelDistanceDisplayPrecision, 0, 7)\\n  if distance_display_precision == None: return Result.Nothing\\n\\n  if distance_display_precision <> doc.ModelDistanceDisplayPrecision:\\n    doc.ModelDistanceDisplayPrecision = distance_display_precision\\n\\n  return Result.Success\\n\\nif __name__ ==  \\"__main__\\":\\n  RunCommand()","members":[["Rhino.RhinoDoc","int ModelDistanceDisplayPrecision"]]},{"name":"Dividebylength.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef DivideByLengthPoints():\\n    filter = Rhino.DocObjects.ObjectType.Curve\\n    rc, objref = Rhino.Input.RhinoGet.GetOneObject(\\"Select curve to divide\\", False, filter)\\n    if not objref or rc!=Rhino.Commands.Result.Success: return rc\\n    \\n    crv = objref.Curve()\\n    if not crv or crv.IsShort(Rhino.RhinoMath.ZeroTolerance):\\n        return Rhino.Commands.Result.Failure\\n    \\n    crv_length = crv.GetLength()\\n    s = \\"Curve length is {0:.3f}. Segment length\\".format(crv_length)\\n    seg_length = crv_length / 2.0\\n    rc, length = Rhino.Input.RhinoGet.GetNumber(s, False, seg_length, 0, crv_length)\\n    if rc!=Rhino.Commands.Result.Success: return rc\\n    t_vals = crv.DivideByLength(length, True)\\n    if not t_vals:\\n        return Rhino.Commands.Result.Failure\\n    \\n    [scriptcontext.doc.Objects.AddPoint(crv.PointAt(t)) for t in t_vals]\\n    scriptcontext.doc.Views.Redraw()\\n    return Rhino.Commands.Result.Success\\n\\nif __name__==\\"__main__\\":\\n    DivideByLengthPoints()\\n","members":[["Rhino.Geometry.Curve","static Curve[] JoinCurves(IEnumerable<Curve> inputCurves, double joinTolerance)"],["Rhino.Geometry.Curve","double[] DivideByLength(double segmentLength, bool includeEnds)"],["Rhino.Geometry.Curve","double[] DivideByLength(double segmentLength, bool includeEnds, bool reverse)"],["Rhino.Geometry.Curve","double[] DivideByLength(double segmentLength, bool includeEnds, bool reverse, out Point3d[] points)"],["Rhino.Geometry.Curve","double[] DivideByLength(double segmentLength, bool includeEnds, out Point3d[] points)"],["Rhino.Geometry.Curve","bool IsShort(double tolerance)"],["Rhino.Input.RhinoGet","static Result GetNumber(string prompt, bool acceptNothing, ref double outputNumber)"],["Rhino.Input.RhinoGet","static Result GetNumber(string prompt, bool acceptNothing, ref double outputNumber, double lowerLimit, double upperLimit)"],["Rhino.Input.RhinoGet","static Result GetOneObject(string prompt, bool acceptNothing, ObjectType filter, out ObjRef rhObject)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddPoint(Point3d point)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddPoint(Point3f point)"],["Rhino.DocObjects.Tables.ObjectTable","bool Select(Guid objectId)"]]},{"name":"Drawstring.py","code":"from Rhino import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Geometry import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Input.Custom import *\\nfrom System.Drawing import Color\\n\\ndef RunCommand():\\n  gp = GetDrawStringPoint()\\n  gp.SetCommandPrompt(\\"Point\\")\\n  gp.Get()\\n  return gp.CommandResult()\\n\\nclass GetDrawStringPoint(GetPoint):\\n  def OnDynamicDraw(self, e):\\n    xform = e.Viewport.GetTransform(\\n      CoordinateSystem.World, CoordinateSystem.Screen)    \\n\\n    current_point = e.CurrentPoint\\n    current_point.Transform(xform)\\n    screen_point = Point2d(current_point.X, current_point.Y)\\n\\n    msg = \\"screen {0}, {1}\\".format(screen_point.X, screen_point.Y)\\n    e.Display.Draw2dText(msg, Color.Blue, screen_point, False)\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Display.DisplayPipeline","void Draw2dText(string text, Color color, Point2d screenCoordinate, bool middleJustified)"]]},{"name":"Dupborder.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef DupBorder():\\n    filter = Rhino.DocObjects.ObjectType.Surface | Rhino.DocObjects.ObjectType.PolysrfFilter\\n    rc, objref = Rhino.Input.RhinoGet.GetOneObject(\\"Select surface or polysurface\\", False, filter)\\n    if rc != Rhino.Commands.Result.Success: return rc\\n\\n    rhobj = objref.Object()\\n    brep = objref.Brep()\\n    if not rhobj or not brep: return Rhino.Commands.Result.Failure\\n    rhobj.Select(False)\\n    curves = brep.DuplicateEdgeCurves(True)\\n    tol = scriptcontext.doc.ModelAbsoluteTolerance * 2.1\\n    curves = Rhino.Geometry.Curve.JoinCurves(curves, tol)\\n    for curve in curves:\\n        id = scriptcontext.doc.Objects.AddCurve(curve)\\n        scriptcontext.doc.Objects.Select(id)\\n    scriptcontext.doc.Views.Redraw()\\n    return Rhino.Commands.Result.Success\\n\\nif __name__==\\"__main__\\":\\n    DupBorder()","members":[["Rhino.Geometry.Brep","Curve[] DuplicateEdgeCurves(bool nakedOnly)"]]},{"name":"Duplicateobject.py","code":"from System import *\\nfrom Rhino import *\\nfrom Rhino.Commands import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Input import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  \\n  rc, obj_ref = RhinoGet.GetOneObject(\\"Select object to duplicate\\", False, ObjectType.AnyObject)\\n  if rc <> Result.Success:\\n    return rc\\n  rhino_object = obj_ref.Object()\\n\\n  geometry_base = rhino_object.DuplicateGeometry()\\n  if geometry_base <> None:\\n    if doc.Objects.Add(geometry_base) <> Guid.Empty:\\n      doc.Views.Redraw()\\n\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.DocObjects.RhinoObject","GeometryBase DuplicateGeometry()"]]},{"name":"Dupmeshboundary.py","code":"from Rhino.Commands import *\\nfrom Rhino.Input.Custom import *\\nfrom Rhino.DocObjects import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  gm = GetObject()\\n  gm.SetCommandPrompt(\\"Select open mesh\\")\\n  gm.GeometryFilter = ObjectType.Mesh\\n  gm.GeometryAttributeFilter = GeometryAttributeFilter.OpenMesh\\n  gm.Get()\\n  if gm.CommandResult() != Result.Success:\\n    return gm.CommandResult()\\n  mesh = gm.Object(0).Mesh()\\n  if mesh == None:\\n    return Result.Failure\\n\\n  polylines = mesh.GetNakedEdges()\\n  for polyline in polylines:\\n    doc.Objects.AddPolyline(polyline)\\n  doc.Views.Redraw()\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n    RunCommand()","members":[["Rhino.Geometry.Mesh","Polyline[] GetNakedEdges()"]]},{"name":"Edgesrf.py","code":"from Rhino import *\\nfrom Rhino.Commands import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Geometry import *\\nfrom Rhino.Input.Custom import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  go = GetObject()\\n  go.SetCommandPrompt(\\"Select 2, 3, or 4 open curves\\")\\n  go.GeometryFilter = ObjectType.Curve\\n  go.GeometryAttributeFilter = GeometryAttributeFilter.OpenCurve\\n  go.GetMultiple(2, 4)\\n  if go.CommandResult() <> Result.Success:\\n    return go.CommandResult()\\n\\n  curves = [o.Curve() for o in go.Objects()]\\n\\n  brep = Brep.CreateEdgeSurface(curves)\\n\\n  if brep <> None:\\n    doc.Objects.AddBrep(brep)\\n    doc.Views.Redraw()\\n\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.Brep","static Brep CreateEdgeSurface(IEnumerable<Curve> curves)"]]},{"name":"Elevation.py","code":"import rhinoscriptsyntax as rs\\nfrom Rhino.Geometry import Intersect, Point3d, Vector3d\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  # select a surface\\n  srfid = rs.GetObject(\\"select serface\\", rs.filter.surface | rs.filter.polysurface)\\n  if not srfid: return\\n  # get the brep\\n  brep = rs.coercebrep(srfid)\\n  if not brep: return\\n\\n  x = rs.GetReal(\\"value of x\\", 0)\\n  y = rs.GetReal(\\"value of y\\", 0)\\n\\n  pts = [(abs(point.Z), point.Z) for point in Intersect.Intersection.ProjectPointsToBreps(\\n           [brep], [Point3d(x, y, 0)], Vector3d(0, 0, 1), doc.ModelAbsoluteTolerance)]\\n           \\n  pts.sort(reverse=True)\\n  \\n  if pts == []:\\n    print \\"no Z for given X, Y\\"\\n  else:\\n    rs.AddPoint(Point3d(x, y, pts[0][1]))\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.BoundingBox","Point3d[] GetCorners()"],["Rhino.Geometry.Intersect.Intersection","static bool CurveBrep(Curve curve, Brep brep, double tolerance, out Curve[] overlapCurves, out Point3d[] intersectionPoints)"]]},{"name":"Evnormal.py","code":"import rhinoscriptsyntax as rs\\nfrom scriptcontext import *\\nimport Rhino\\nfrom Rhino.Commands import Result\\n\\ndef RunCommand():\\n  # select a surface\\n  gs = Rhino.Input.Custom.GetObject()\\n  gs.SetCommandPrompt(\\"select surface\\")\\n  gs.GeometryFilter = Rhino.DocObjects.ObjectType.Surface\\n  gs.DisablePreSelect()\\n  gs.SubObjectSelect = False\\n  gs.Get()\\n  if gs.CommandResult() != Result.Success:\\n    return gs.CommandResult()\\n\\n  # get the selected face\\n  face = gs.Object(0).Face()\\n  if face == None:\\n    return\\n\\n  # pick a point on the surface.  Constain\\n  # picking to the face.\\n  gp = Rhino.Input.Custom.GetPoint()\\n  gp.SetCommandPrompt(\\"select point on surface\\")\\n  gp.Constrain(face, False)\\n  gp.Get()\\n  if gp.CommandResult() != Result.Success:\\n    return gp.CommandResult()\\n\\n  # get the parameters of the point on the\\n  # surface that is clesest to gp.Point()\\n  b, u, v = face.ClosestPoint(gp.Point())\\n  if b:\\n    dir = face.NormalAt(u, v)\\n    if face.OrientationIsReversed:\\n      dir.Reverse()\\n    print \\"Surface normal at uv({0:f},{1:f}) = ({2:f},{3:f},{4:f})\\".format(\\n        u, v, dir.X, dir.Y, dir.Z)\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()\\n","members":[["Rhino.Geometry.BrepFace","bool OrientationIsReversed"],["Rhino.Geometry.Surface","Vector3d NormalAt(double u, double v)"]]},{"name":"Explodehatch.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef ExplodeHatch():\\n    filter = Rhino.DocObjects.ObjectType.Hatch\\n    rc, objref = Rhino.Input.RhinoGet.GetOneObject(\\"Select hatch to explode\\", False, filter)\\n    if rc != Rhino.Commands.Result.Success: return\\n\\n    hatch = objref.Geometry()\\n    if not hatch: return\\n\\n    hatch_geom = hatch.Explode()\\n    if hatch_geom:\\n      for geom in hatch_geom:\\n          if geom.ObjectType == Rhino.DocObjects.ObjectType.Point:\\n              scriptcontext.doc.Objects.AddPoint(geom)\\n          elif geom.ObjectType == Rhino.DocObjects.ObjectType.Curve:\\n              scriptcontext.doc.Objects.AddCurve(geom)\\n          elif geom.ObjectType == Rhino.DocObjects.ObjectType.Brep:\\n              scriptcontext.doc.Objects.AddBrep(geom)\\n      scriptcontext.doc.Views.Redraw()\\n\\nif __name__==\\"__main__\\":\\n    ExplodeHatch()\\n","members":[["Rhino.Geometry.Hatch","GeometryBase[] Explode()"]]},{"name":"Extendcurve.py","code":"from Rhino import *\\nfrom Rhino.Geometry import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Input import *\\nfrom Rhino.Input.Custom import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  \\n  rc, boundary_obj_refs = RhinoGet.GetMultipleObjects(\\"Select boundary objects\\", False, ObjectType.AnyObject)\\n  if rc <> Result.Success:\\n    return rc\\n  if boundary_obj_refs == None or boundary_obj_refs.Length == 0:\\n    return Result.Nothing\\n\\n  gc = GetObject()\\n  gc.SetCommandPrompt(\\"Select curve to extend\\")\\n  gc.GeometryFilter = ObjectType.Curve\\n  gc.GeometryAttributeFilter = GeometryAttributeFilter.OpenCurve\\n  gc.Get()\\n  if gc.CommandResult() <> Result.Success:\\n    return gc.CommandResult()\\n  curve_obj_ref = gc.Object(0)\\n\\n  curve = curve_obj_ref.Curve()\\n  if curve == None: return Result.Failure\\n  b, t = curve.ClosestPoint(curve_obj_ref.SelectionPoint())\\n  if not b: return Result.Failure\\n  curve_end = CurveEnd.Start if t <= curve.Domain.Mid else CurveEnd.End\\n\\n  geometry = [obj.Geometry() for obj in boundary_obj_refs]\\n  extended_curve = curve.Extend(curve_end, CurveExtensionStyle.Line, geometry)\\n  if extended_curve <> None and extended_curve.IsValid:\\n    if not doc.Objects.Replace(curve_obj_ref.ObjectId, extended_curve):\\n      return Result.Failure\\n    doc.Views.Redraw()\\n    return Result.Success\\n  else:\\n    RhinoApp.WriteLine(\\"No boundary object was intersected so curve not extended\\")\\n    return Result.Nothing\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.Curve","Curve Extend(CurveEnd side, CurveExtensionStyle style, IEnumerable<GeometryBase> geometry)"],["Rhino.Geometry.Interval","double Mid"]]},{"name":"Extractisocurve.py","code":"from Rhino import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Input import *\\nfrom Rhino.Input.Custom import *\\nfrom Rhino.Geometry import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  rc, obj_ref = RhinoGet.GetOneObject(\\"Select surface\\", False, ObjectType.Surface)\\n  if rc <> Result.Success or obj_ref == None:\\n    return rc\\n  surface = obj_ref.Surface()\\n\\n  gp = GetPoint()\\n  gp.SetCommandPrompt(\\"Point on surface\\")\\n  gp.Constrain(surface, False)\\n  option_toggle = OptionToggle(False, \\"U\\", \\"V\\")\\n  gp.AddOptionToggle(\\"Direction\\", option_toggle)\\n  point = Point3d.Unset\\n\\n  while True:\\n    grc = gp.Get()\\n    if grc == GetResult.Option:\\n      continue\\n    elif grc == GetResult.Point:\\n      point = gp.Point()\\n      break\\n    else:\\n      return Result.Nothing\\n\\n  if point == Point3d.Unset:\\n    return Result.Nothing\\n\\n  direction = 1 if option_toggle.CurrentValue else 0\\n  b, u_parameter, v_parameter = surface.ClosestPoint(point)\\n  if not b: return Result.Failure\\n\\n  iso_curve = surface.IsoCurve(direction, u_parameter if direction == 1 else v_parameter)\\n  if iso_curve == None: \\n    return Result.Failure\\n\\n  doc.Objects.AddCurve(iso_curve)\\n  doc.Views.Redraw()\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.Surface","Curve IsoCurve(int direction, double constantParameter)"]]},{"name":"Extractthumbnail.py","code":"import Rhino\\nimport rhinoscriptsyntax as rs\\nfrom scriptcontext import doc\\n\\nimport clr\\nclr.AddReference(\\"System.Windows.Forms\\")\\nimport System.Windows.Forms\\n\\ndef RunCommand():\\n\\n  fn = rs.OpenFileName(title=\\"select file\\", filter=\\"Rhino files|*.3dm||\\")\\n  if fn == None:\\n    return\\n\\n  bitmap = doc.ExtractPreviewImage(fn)\\n\\n  f = System.Windows.Forms.Form()\\n  f.Height = bitmap.Height\\n  f.Width = bitmap.Width\\n  pb = System.Windows.Forms.PictureBox()\\n  pb.Image = bitmap\\n  pb.Height = bitmap.Height  #SizeMode = System.Windows.Forms.PictueBoxSizeMode.AutoSize\\n  pb.Width = bitmap.Width\\n  f.Controls.Add(pb);\\n  f.Show();\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()\\n","members":[["Rhino.FileIO.File3dm","static System.Drawing.Bitmap ReadPreviewImage(string path)"],["Rhino.Input.RhinoGet","static string GetFileName(GetFileNameMode mode, string defaultName, string title, object parent)"],["Rhino.Input.RhinoGet","static string GetFileName(GetFileNameMode mode, string defaultName, string title, object parent, BitmapFileTypes fileTypes)"]]},{"name":"Filletcurves.py","code":"from Rhino import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Geometry import *\\nfrom Rhino.Input import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Input.Custom import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  gc1 = GetObject()\\n  gc1.DisablePreSelect()\\n  gc1.SetCommandPrompt(\\"Select first curve to fillet (close to the end you want to fillet)\\")\\n  gc1.GeometryFilter = ObjectType.Curve\\n  gc1.GeometryAttributeFilter = GeometryAttributeFilter.OpenCurve\\n  gc1.Get()\\n  if gc1.CommandResult() != Result.Success:\\n    return gc1.CommandResult()\\n  curve1_obj_ref = gc1.Object(0)\\n  curve1 = curve1_obj_ref.Curve()\\n  if curve1 == None: return Result.Failure\\n  curve1_point_near_end = curve1_obj_ref.SelectionPoint()\\n  if curve1_point_near_end == Point3d.Unset:\\n    return Result.Failure\\n\\n  gc2 = GetObject()\\n  gc2.DisablePreSelect()\\n  gc2.SetCommandPrompt(\\"Select second curve to fillet (close to the end you want to fillet)\\")\\n  gc2.GeometryFilter = ObjectType.Curve\\n  gc2.GeometryAttributeFilter = GeometryAttributeFilter.OpenCurve\\n  gc2.Get()\\n  if gc2.CommandResult() != Result.Success:\\n    return gc2.CommandResult()\\n  curve2_obj_ref = gc2.Object(0)\\n  curve2 = curve2_obj_ref.Curve()\\n  if curve2 == None: return Result.Failure\\n  curve2_point_near_end = curve2_obj_ref.SelectionPoint()\\n  if curve2_point_near_end == Point3d.Unset:\\n    return Result.Failure\\n\\n  radius = 0.0\\n  rc, radius = RhinoGet.GetNumber(\\"fillet radius\\", False, radius)\\n  if rc != Result.Success: return rc\\n\\n  fillet_curve = Curve.CreateFilletCurves(curve1, curve1_point_near_end, curve2, curve2_point_near_end, radius,\\n    True, True, True, doc.ModelAbsoluteTolerance, doc.ModelAngleToleranceDegrees)\\n  if fillet_curve == None or fillet_curve.Length != 1:\\n    return Result.Failure\\n\\n  doc.Objects.AddCurve(fillet_curve[0])\\n  doc.Views.Redraw()\\n  return rc\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.Curve","static Curve[] CreateFilletCurves(Curve curve0, Point3d point0, Curve curve1, Point3d point1, double radius, bool join, bool trim, bool arcExtension, double tolerance, double angleTolerance)"]]},{"name":"Findobjectsbyname.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef FindObjectsByName():\\n    name = \\"abc\\"\\n    settings = Rhino.DocObjects.ObjectEnumeratorSettings()\\n    settings.NameFilter = name\\n    ids = [rhobj.Id for rhobj in scriptcontext.doc.Objects.GetObjectList(settings)]\\n    if not ids:\\n        print \\"No objects with the name\\", name\\n        return Rhino.Commands.Result.Failure\\n    else:\\n        print \\"Found\\", len(ids), \\"objects\\"\\n        for id in ids: print \\"  \\", id\\n    return Rhino.Commands.Result.Success\\n\\nif __name__ == \\"__main__\\":\\n    FindObjectsByName()\\n","members":[["Rhino.DocObjects.ObjectEnumeratorSettings","ObjectEnumeratorSettings()"],["Rhino.DocObjects.ObjectEnumeratorSettings","string NameFilter"]]},{"name":"Getpointdynamicdraw.py","code":"from Rhino import *\\nfrom Rhino.Geometry import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Input.Custom import *\\nfrom scriptcontext import doc\\nfrom System.Drawing import *\\n\\ndef RunCommand():\\n  gp = GetPoint()\\n  gp.SetCommandPrompt(\\"Center point\\")\\n  gp.Get()\\n  if gp.CommandResult() <> Result.Success:\\n    return gp.CommandResult()\\n  center_point = gp.Point()\\n  if center_point == Point3d.Unset:\\n    return Result.Failure\\n\\n  gcp = GetCircleRadiusPoint(center_point)\\n  gcp.SetCommandPrompt(\\"Radius\\")\\n  gcp.ConstrainToConstructionPlane(False)\\n  gcp.SetBasePoint(center_point, True)\\n  gcp.DrawLineFromPoint(center_point, True)\\n  gcp.Get()\\n  if gcp.CommandResult() <> Result.Success:\\n    return gcp.CommandResult()\\n\\n  radius = center_point.DistanceTo(gcp.Point())\\n  cplane = doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\\n  doc.Objects.AddCircle(Circle(cplane, center_point, radius))\\n  doc.Views.Redraw()\\n  return Result.Success\\n\\nclass GetCircleRadiusPoint (GetPoint):\\n  def __init__(self, centerPoint):\\n    self.m_center_point = centerPoint\\n  \\n  def OnDynamicDraw(self, e):\\n    cplane = e.RhinoDoc.Views.ActiveView.ActiveViewport.ConstructionPlane()\\n    radius = self.m_center_point.DistanceTo(e.CurrentPoint)\\n    circle = Circle(cplane, self.m_center_point, radius)\\n    e.Display.DrawCircle(circle, Color.Black)\\n\\nif __name__ == \\"__main__\\":\\n    RunCommand()","members":[["Rhino.Display.DisplayPipeline","void DrawCircle(Circle circle, Color color)"]]},{"name":"Gettext.py","code":"from Rhino import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Input.Custom import *\\nimport rhinoscriptsyntax as rs\\n\\ndef RunCommand():\\n  go = GetObject()\\n  go.SetCommandPrompt(\\"Select annotation\\")\\n  go.GeometryFilter = ObjectType.Annotation\\n  go.Get()\\n  if go.CommandResult() <> Result.Success:\\n    return Result.Failure\\n  annotation = go.Object(0).Object()\\n  if annotation == None or not isinstance(annotation, AnnotationObjectBase):\\n    return Result.Failure\\n\\n  print \\"Annotation text = {0}\\".format(annotation.DisplayText)\\n\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.DocObjects.AnnotationObjectBase","string DisplayText"]]},{"name":"Hatchcurve.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef HatchCurve():\\n    go = Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt(\\"Select closed planar curve\\")\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\\n    go.GeometryAttributeFilter = Rhino.Input.Custom.GeometryAttributeFilter.ClosedCurve\\n    go.SubObjectSelect = False\\n    go.Get()\\n    if go.CommandResult()!=Rhino.Commands.Result.Success: return\\n\\n    curve = go.Object(0).Curve()\\n    if (not curve or not curve.IsClosed or not curve.IsPlanar()): return\\n\\n    hatch_name = scriptcontext.doc.HatchPatterns[scriptcontext.doc.HatchPatterns.CurrentHatchPatternIndex].Name\\n    rc, hatch_name = Rhino.Input.RhinoGet.GetString(\\"Hatch pattern\\", True, hatch_name)\\n    if rc!=Rhino.Commands.Result.Success or not hatch_name: return\\n\\n    index = scriptcontext.doc.HatchPatterns.Find(hatch_name, True)\\n    if index<0:\\n        print \\"Hatch pattern does not exist.\\"\\n        return\\n\\n    hatches = Rhino.Geometry.Hatch.Create(curve, index, 0, 1)\\n    for hatch in hatches:\\n        scriptcontext.doc.Objects.AddHatch(hatch)\\n    if hatches: scriptcontext.doc.Views.Redraw()\\n\\nif __name__==\\"__main__\\":\\n    HatchCurve()","members":[["Rhino.RhinoDoc","HatchPatternTable HatchPatterns"],["Rhino.Geometry.Hatch","static Hatch[] Create(Curve curve, int hatchPatternIndex, double rotationRadians, double scale)"],["Rhino.Geometry.Hatch","static Hatch[] Create(Curve curve, int hatchPatternIndex, double rotationRadians, double scale, double tolerance)"],["Rhino.DocObjects.ModelComponent","string Name"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddHatch(Hatch hatch)"],["Rhino.DocObjects.Tables.HatchPatternTable","int CurrentHatchPatternIndex"],["Rhino.DocObjects.Tables.HatchPatternTable","int Find(string name, bool ignoreDeleted)"],["Rhino.DocObjects.Tables.HatchPatternTable","HatchPattern FindName(string name)"]]},{"name":"Insertknot.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef InsertKnot():\\n    filter = Rhino.DocObjects.ObjectType.Curve\\n    rc, objref = Rhino.Input.RhinoGet.GetOneObject(\\"Select curve for knot insertion\\", False, filter)\\n    if rc != Rhino.Commands.Result.Success: return rc\\n    \\n    curve = objref.Curve()\\n    if not curve: return Rhino.Commands.Result.Failure\\n    nurb = curve.ToNurbsCurve()\\n    if not nurb: return Rhino.Commands.Result.Failure\\n\\n    gp = Rhino.Input.Custom.GetPoint()\\n    gp.SetCommandPrompt(\\"Point on curve to add knot\\")\\n    gp.Constrain(nurb, False)\\n    gp.Get()\\n    if gp.CommandResult() == Rhino.Commands.Result.Success:\\n        crv, t = gp.PointOnCurve()\\n        if crv and nurb.Knots.InsertKnot(t):\\n            scriptcontext.doc.Objects.Replace(objref, nurb)\\n            scriptcontext.doc.Views.Redraw()\\n    return Rhino.Commands.Result.Success\\n\\nif __name__==\\"__main__\\":\\n    InsertKnot()","members":[["Rhino.Input.Custom.GetPoint","bool Constrain(Curve curve, bool allowPickingPointOffObject)"],["Rhino.Input.Custom.GetPoint","Curve PointOnCurve(out double t)"],["Rhino.Geometry.Collections.NurbsCurveKnotList","bool InsertKnot(double value)"],["Rhino.DocObjects.Tables.ObjectTable","bool Replace(ObjRef objref, Curve curve)"]]},{"name":"Instancedefinitionobjects.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef InstanceDefinitionObjects():\\n    rc, objref = Rhino.Input.RhinoGet.GetOneObject(\\"Select instance\\", False, Rhino.DocObjects.ObjectType.InstanceReference)\\n    if rc != Rhino.Commands.Result.Success: return\\n\\n    iref = objref.Object()\\n    if iref:\\n        idef = iref.InstanceDefinition\\n        if idef:\\n            rhino_objects = idef.GetObjects()\\n            for i, rhobj in enumerate(rhino_objects):\\n                print \\"Object\\", i, \\"=\\", rhobj.Id\\n\\nif __name__==\\"__main__\\":\\n    InstanceDefinitionObjects()","members":[["Rhino.DocObjects.InstanceObject","InstanceDefinition InstanceDefinition"],["Rhino.DocObjects.InstanceDefinition","RhinoObject[] GetObjects()"]]},{"name":"Intersectcurves.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef IntersectCurves():\\n    # Select two curves to intersect\\n    go = Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt(\\"Select two curves\\")\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\\n    go.GetMultiple(2, 2)\\n    if go.CommandResult()!=Rhino.Commands.Result.Success: return\\n\\n    # Validate input\\n    curveA = go.Object(0).Curve()\\n    curveB = go.Object(1).Curve()\\n    if not curveA or not curveB: return\\n\\n    # Calculate the intersection\\n    intersection_tolerance = 0.001\\n    overlap_tolerance = 0.0\\n    events = Rhino.Geometry.Intersect.Intersection.CurveCurve(curveA, curveB, intersection_tolerance, overlap_tolerance)\\n\\n    # Process the results\\n    if not events: return\\n    for ccx_event in events:\\n        scriptcontext.doc.Objects.AddPoint(ccx_event.PointA)\\n        if ccx_event.PointA.DistanceTo(ccx_event.PointB) > float.Epsilon:\\n            scriptcontext.doc.Objects.AddPoint(ccx_event.PointB)\\n            scriptcontext.doc.Objects.AddLine(ccx_event.PointA, ccx_event.PointB)\\n    scriptcontext.doc.Views.Redraw()\\n\\nif __name__==\\"__main__\\":\\n    IntersectCurves()","members":[["Rhino.Geometry.Point3f","double DistanceTo(Point3f other)"],["Rhino.Geometry.Point3d","double DistanceTo(Point3d other)"],["Rhino.DocObjects.ObjRef","Curve Curve()"],["Rhino.Geometry.Intersect.Intersection","static CurveIntersections CurveCurve(Curve curveA, Curve curveB, double tolerance, double overlapTolerance)"]]},{"name":"Intersectlinecircle.py","code":"import rhinoscriptsyntax as rs\\nfrom scriptcontext import doc\\nimport Rhino\\nfrom Rhino.Geometry.Intersect import Intersection, LineCircleIntersection\\n\\ndef RunCommand():\\n  rc, circle = Rhino.Input.RhinoGet.GetCircle()\\n  if rc != Rhino.Commands.Result.Success:\\n    return rc\\n  doc.Objects.AddCircle(circle)\\n  doc.Views.Redraw()\\n\\n  rc, line = Rhino.Input.RhinoGet.GetLine()\\n  if rc != Rhino.Commands.Result.Success:\\n    return rc\\n  doc.Objects.AddLine(line)\\n  doc.Views.Redraw()\\n\\n  lineCircleIntersect, t1, point1, t2, point2 = Intersection.LineCircle(line, circle)\\n  message = \\"\\"\\n  if lineCircleIntersect == LineCircleIntersection.None:\\n    message = \\"line does not intersect circle\\"\\n  elif lineCircleIntersect == LineCircleIntersection.Single:\\n    message = \\"line intersects circle at point ({0},{1},{2})\\".format(point1.X, point1.Y, point1.Z)\\n    doc.Objects.AddPoint(point1)\\n  elif lineCircleIntersect == LineCircleIntersection.Multiple:\\n    message = \\"line intersects circle at points ({0},{1},{2}) and ({3},{4},{5})\\".format(\\n      point1.X, point1.Y, point1.Z, point2.X, point2.Y, point2.Z)\\n    doc.Objects.AddPoint(point1)\\n    doc.Objects.AddPoint(point2)\\n    \\n  print message\\n  doc.Views.Redraw()\\n\\nif __name__ == \\"__main__\\":\\n    RunCommand()","members":[["Rhino.Geometry.Intersect.Intersection","static LineCircleIntersection LineCircle(Line line, Circle circle, out double t1, out Point3d point1, out double t2, out Point3d point2)"]]},{"name":"Intersectlines.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef IntersectLines():\\n    go = Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt( \\"Select lines\\" )\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\\n    go.GetMultiple( 2, 2)\\n    if go.CommandResult()!=Rhino.Commands.Result.Success:\\n      return go.CommandResult()\\n    if go.ObjectCount!=2: return Rhino.Commands.Result.Failure\\n\\n    crv0 = go.Object(0).Geometry()\\n    crv1 = go.Object(1).Geometry()\\n    if not crv0 or not crv1: return Rhino.Commands.Result.Failure\\n\\n    line0 = crv0.Line\\n    line1 = crv1.Line\\n    v0 = line0.Direction\\n    v0.Unitize()\\n    v1 = line1.Direction\\n    v1.Unitize()\\n\\n    if v0.IsParallelTo(v1)!=0:\\n        print \\"Selected lines are parallel.\\"\\n        return Rhino.Commands.Result.Nothing\\n\\n    rc, a, b = Rhino.Geometry.Intersect.Intersection.LineLine(line0, line1)\\n    if not rc:\\n        print \\"No intersection found.\\"\\n        return Rhino.Commands.Result.Nothing\\n\\n    pt0 = line0.PointAt(a)\\n    pt1 = line1.PointAt(b)\\n    # pt0 and pt1 should be equal, so we will only add pt0 to the document\\n    scriptcontext.doc.Objects.AddPoint(pt0)\\n    scriptcontext.doc.Views.Redraw()\\n    return Rhino.Commands.Result.Success\\n\\nif __name__==\\"__main__\\":\\n    IntersectLines()","members":[["Rhino.Geometry.Line","Vector3d Direction"],["Rhino.Geometry.Line","Point3d PointAt(double t)"],["Rhino.Geometry.Vector3d","int IsParallelTo(Vector3d other)"],["Rhino.Geometry.Intersect.Intersection","static bool LineLine(Line lineA, Line lineB, out double a, out double b)"]]},{"name":"Isbrepbox.py","code":"import Rhino\\n\\ndef IsBrepBox(brep):\\n    zero_tolerance = 1.0e-6 #or whatever\\n    rc = brep.IsSolid\\n    if rc: rc = brep.Faces.Count == 6\\n\\n    N = []\\n    for i in range(6):\\n        if not rc: break\\n        rc, plane = brep.Faces[i].TryGetPlane(zero_tolerance)\\n        if rc:\\n            v = plane.ZAxis\\n            v.Unitize()\\n            N.append(v)\\n \\n    for i in range(6):\\n        count = 0\\n        for j in range(6):\\n            if not rc: break\\n            dot = abs(N[i] * N[j])\\n            if dot<=zero_tolerance: continue\\n            if abs(dot-1.0)<=zero_tolerance:\\n              count += 1\\n            else:\\n              rc = False\\n\\n    if rc:\\n        if 2!=count: rc = False\\n    return rc\\n\\n\\nif __name__==\\"__main__\\":\\n    rc, objref = Rhino.Input.RhinoGet.GetOneObject(\\"Select Brep\\", True, Rhino.DocObjects.ObjectType.Brep)\\n    if rc==Rhino.Commands.Result.Success:\\n        brep = objref.Brep()\\n        if brep:\\n            if IsBrepBox(brep): print \\"Yes it is a box\\"\\n            else: print \\"No it is not a box\\"\\n","members":[["Rhino.Geometry.Brep","bool IsSolid"],["Rhino.Geometry.Surface","bool TryGetPlane(out Plane plane, double tolerance)"]]},{"name":"Isocurvedensity.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef IsocurveDensity():\\n    rc, objref = Rhino.Input.RhinoGet.GetOneObject(\\"Select surface\\", False, Rhino.DocObjects.ObjectType.Surface)\\n    if rc!= Rhino.Commands.Result.Success: return\\n\\n    brep_obj = objref.Object()\\n    if brep_obj:\\n        brep_obj.Attributes.WireDensity = 3\\n        brep_obj.CommitChanges()\\n        scriptcontext.doc.Views.Redraw()\\n\\nif __name__==\\"__main__\\":\\n    IsocurveDensity()","members":[["Rhino.DocObjects.ObjectAttributes","int WireDensity"]]},{"name":"Issurfaceinplane.py","code":"import Rhino\\nfrom Rhino.Geometry import *\\nimport rhinoscriptsyntax as rs\\nfrom scriptcontext import doc\\nimport math\\n\\ndef RunCommand():\\n  surface_id = rs.GetSurfaceObject()[0]\\n  if surface_id == None:\\n    return\\n  surface = rs.coercesurface(surface_id)\\n\\n  corners = rs.GetRectangle()\\n  if corners == None:\\n    return\\n    \\n  plane = Plane(corners[0], corners[1], corners[2])\\n\\n  is_or_isnt = \\"\\" if IsSurfaceInPlane(surface, plane, doc.ModelAbsoluteTolerance) else \\" not \\"\\n  print \\"Surface is{0} in plane.\\".format(is_or_isnt)\\n\\ndef IsSurfaceInPlane(surface, plane, tolerance):\\n  if not surface.IsPlanar(tolerance):\\n    return False\\n \\n  bbox = surface.GetBoundingBox(True)\\n  rc = True\\n  for corner in bbox.GetCorners():\\n      if math.fabs(plane.DistanceTo(corner)) > tolerance:\\n          rc = False\\n          break\\n          \\n  return rc\\n\\nif __name__ == \\"__main__\\":\\n    RunCommand()","members":[["Rhino.Geometry.Plane","double DistanceTo(Point3d testPoint)"],["Rhino.Geometry.Surface","bool IsPlanar()"]]},{"name":"Leader.py","code":"import rhinoscriptsyntax as rs\\n\\ndef RunCommand():\\n  points = [(1,1,0), (5,1,0), (5,5,0), (9,5,0)]\\n  rs.AddLeader(points)\\n\\nif __name__ == \\"__main__\\":\\n    RunCommand()","members":[["Rhino.Geometry.Point2d","double DistanceTo(Point2d other)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddLeader(Plane plane, IEnumerable<Point2d> points)"]]},{"name":"Locklayer.py","code":"import rhinoscriptsyntax as rs\\nfrom scriptcontext import doc\\n\\ndef lock():\\n    layerName = rs.GetString(\\"Name of layer to lock\\")\\n    \\n    matchingLayers = [layer for layer in doc.Layers if layer.Name == layerName]\\n    \\n    layerToLock = None\\n    if len(matchingLayers) == 0:\\n        print \\"Layer \\"{0}\\" does not exist.\\".format(layerName)\\n    elif len(matchingLayers) == 1:\\n        layerToLock = matchingLayers[0]\\n    elif len(matchingLayers) > 1:\\n        i = 0;\\n        for layer in matchingLayers:\\n            print \\"({0}) {1}\\".format(i+1, matchingLayers[i].FullPath.replace(\\"::\\", \\"->\\"))\\n            i += 1\\n            \\n        selectedLayer = rs.GetInteger(\\"which layer?\\", -1, 1, len(matchingLayers))\\n        if selectedLayer == None:\\n            return\\n        layerToLock = matchingLayers[selectedLayer - 1]\\n        \\n    if layerToLock.IsLocked:\\n        print \\"layer {0} is already locked.\\".format(layerToLock.FullPath)\\n    else:\\n        layerToLock.IsLocked = True\\n        layerToLock.CommitChanges()\\n          \\nif __name__ == \\"__main__\\":\\n    lock()\\n        ","members":[["Rhino.DocObjects.Layer","string FullPath"],["Rhino.DocObjects.Layer","bool IsLocked"],["Rhino.DocObjects.Layer","bool CommitChanges()"]]},{"name":"Loft.py","code":"import rhinoscriptsyntax as rs\\n\\ndef RunCommand():\\n  crvids = rs.GetObjects(message=\\"select curves to loft\\", filter=rs.filter.curve, minimum_count=2)\\n  if not crvids: return\\n\\n  rs.AddLoftSrf(object_ids=crvids, loft_type = 3) #3 = tight\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.Brep","static Brep[] CreateFromLoft(IEnumerable<Curve> curves, Point3d start, Point3d end, LoftType loftType, bool closed)"]]},{"name":"Makerhinocontours.py","code":"from System import *\\nfrom Rhino import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Geometry import *\\nfrom Rhino.Input import *\\nfrom Rhino.Input.Custom import *\\nfrom Rhino.Commands import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  filter = ObjectType.Surface | ObjectType.PolysrfFilter | ObjectType.Mesh\\n  rc, obj_refs = RhinoGet.GetMultipleObjects(\\"Select objects to contour\\", False, filter)\\n  if rc <> Result.Success:\\n    return rc\\n\\n  gp = GetPoint()\\n  gp.SetCommandPrompt(\\"Contour plane base point\\")\\n  gp.Get()\\n  if gp.CommandResult() <> Result.Success:\\n    return gp.CommandResult()\\n  base_point = gp.Point()\\n\\n  gp.DrawLineFromPoint(base_point, True)\\n  gp.SetCommandPrompt(\\"Direction perpendicular to contour planes\\")\\n  gp.Get()\\n  if gp.CommandResult() <> Result.Success:\\n    return gp.CommandResult()\\n  end_point = gp.Point()\\n\\n  if base_point.DistanceTo(end_point) < RhinoMath.ZeroTolerance:\\n    return Result.Nothing\\n\\n  distance = 1.0\\n  rc, distance = RhinoGet.GetNumber(\\"Distance between contours\\", False, distance)\\n  if rc <> Result.Success:\\n    return rc\\n\\n  interval = Math.Abs(distance)\\n\\n  for obj_ref in obj_refs:\\n    geometry = obj_ref.Geometry()\\n    if geometry == None:\\n      return Result.Failure\\n\\n    if type(geometry) == Brep:\\n      curves = Brep.CreateContourCurves(geometry, base_point, end_point, interval)\\n    else:\\n      curves = Mesh.CreateContourCurves(geometry, base_point, end_point, interval)\\n\\n    for curve in curves:\\n      curve_object_id = doc.Objects.AddCurve(curve)\\n      doc.Objects.Select(curve_object_id)\\n\\n  if curves <> None:\\n    doc.Views.Redraw()\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.Brep","static Curve[] CreateContourCurves(Brep brepToContour, Point3d contourStart, Point3d contourEnd, double interval)"],["Rhino.Geometry.Mesh","static Curve[] CreateContourCurves(Mesh meshToContour, Point3d contourStart, Point3d contourEnd, double interval)"]]},{"name":"Meshdrawing.py","code":"import rhinoscriptsyntax as rs\\nfrom scriptcontext import doc\\nimport Rhino\\nimport System\\nimport System.Drawing\\n\\ndef RunCommand():\\n  gs = Rhino.Input.Custom.GetObject()\\n  gs.SetCommandPrompt(\\"select sphere\\")\\n  gs.GeometryFilter = Rhino.DocObjects.ObjectType.Surface\\n  gs.DisablePreSelect()\\n  gs.SubObjectSelect = False\\n  gs.Get()\\n  if gs.CommandResult() != Rhino.Commands.Result.Success:\\n    return gs.CommandResult()\\n\\n  b, sphere = gs.Object(0).Surface().TryGetSphere()\\n  if sphere.IsValid:\\n    mesh = Rhino.Geometry.Mesh.CreateFromSphere(sphere, 10, 10)\\n    if mesh == None:\\n      return Rhino.Commands.Result.Failure\\n\\n    conduit = DrawBlueMeshConduit(mesh)\\n    conduit.Enabled = True\\n    doc.Views.Redraw()\\n\\n    inStr = rs.GetString(\\"press <Enter> to continue\\")\\n\\n    conduit.Enabled = False\\n    doc.Views.Redraw()\\n    return Rhino.Commands.Result.Success\\n  else:\\n    return Rhino.Commands.Result.Failure\\n\\nclass DrawBlueMeshConduit(Rhino.Display.DisplayConduit):\\n  def __init__(self, mesh):\\n    self.mesh = mesh\\n    self.color = System.Drawing.Color.Blue\\n    self.material = Rhino.Display.DisplayMaterial()\\n    self.material.Diffuse = self.color\\n    if mesh != None and mesh.IsValid:\\n      self.bbox = mesh.GetBoundingBox(True)\\n\\n  def CalculateBoundingBox(self, calculateBoundingBoxEventArgs):\\n    #super.CalculateBoundingBox(calculateBoundingBoxEventArgs)\\n    calculateBoundingBoxEventArgs.IncludeBoundingBox(self.bbox)\\n\\n  def PreDrawObjects(self, drawEventArgs):\\n    #base.PreDrawObjects(rawEventArgs)\\n    gvp = drawEventArgs.Display.Viewport\\n    if gvp.DisplayMode.EnglishName.ToLower() == \\"wireframe\\":\\n      drawEventArgs.Display.DrawMeshWires(self.mesh, self.color)\\n    else:\\n      drawEventArgs.Display.DrawMeshShaded(self.mesh, self.material)\\n\\nif __name__ == \\"__main__\\":\\n    RunCommand()","members":[["Rhino.Display.DisplayPipeline","void DrawMeshShaded(Mesh mesh, DisplayMaterial material)"],["Rhino.Display.DisplayPipeline","void DrawMeshWires(Mesh mesh, Color color)"]]},{"name":"Meshvolume.py","code":"from Rhino.Input.Custom import *\\nfrom Rhino.DocObjects import ObjectType\\nfrom Rhino.Geometry import *\\nfrom Rhino.Commands import Result\\n\\ndef RunCommand():\\n  gm = GetObject()\\n  gm.SetCommandPrompt(\\"Select solid meshes for volume calculation\\")\\n  gm.GeometryFilter = ObjectType.Mesh\\n  gm.GeometryAttributeFilter = GeometryAttributeFilter.ClosedMesh\\n  gm.SubObjectSelect = False\\n  gm.GroupSelect = True\\n  gm.GetMultiple(1, 0)\\n  if gm.CommandResult() != Result.Success:\\n    return gm.CommandResult()\\n\\n  volume = 0.0\\n  volume_error = 0.0\\n  for obj_ref in gm.Objects():\\n    if obj_ref.Mesh() != None:\\n      mass_properties = VolumeMassProperties.Compute(obj_ref.Mesh())\\n      if mass_properties != None:\\n        volume += mass_properties.Volume\\n        volume_error += mass_properties.VolumeError\\n\\n  print \\"Total volume = {0:f} (+/- {1:f})\\".format(volume, volume_error)\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.VolumeMassProperties","double Volume"],["Rhino.Geometry.VolumeMassProperties","double VolumeError"]]},{"name":"Modifylightcolor.py","code":"from Rhino import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Input import *\\nfrom Rhino.UI import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  rc, obj_ref = RhinoGet.GetOneObject(\\n    \\"Select light to change color\\", \\n    True,\\n    ObjectType.Light)\\n  if rc != Result.Success:\\n    return rc\\n  light = obj_ref.Light()\\n  if light == None:\\n    return Result.Failure\\n\\n  b, color = Dialogs.ShowColorDialog(light.Diffuse)\\n  if b:\\n    light.Diffuse = color\\n    \\n  doc.Lights.Modify(obj_ref.ObjectId, light)\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.Light","Color Diffuse"],["Rhino.UI.Dialogs","static bool ShowColorDialog(ref Color color)"],["Rhino.DocObjects.Tables.LightTable","bool Modify(Guid id, Light light)"]]},{"name":"Modifyobjectcolor.py","code":"from System.Drawing import *\\nfrom Rhino import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Geometry import *\\nfrom Rhino.Input import *\\nfrom Rhino.Commands import *\\nfrom Rhino.UI.Dialogs import ShowColorDialog\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  rc, obj_ref = RhinoGet.GetOneObject(\\"Select object\\", False, ObjectType.AnyObject)\\n  if rc <> Result.Success:\\n    return rc\\n  rhino_object = obj_ref.Object()\\n  color = rhino_object.Attributes.ObjectColor\\n  b, color = ShowColorDialog(color)\\n  if not b: return Result.Cancel\\n\\n  rhino_object.Attributes.ObjectColor = color\\n  rhino_object.Attributes.ColorSource = ObjectColorSource.ColorFromObject\\n  rhino_object.CommitChanges()\\n\\n  # an object\'s color attributes can also be specified\\n  # when the object is added to Rhino\\n  sphere = Sphere(Point3d.Origin, 5.0)\\n  attributes = ObjectAttributes()\\n  attributes.ObjectColor = Color.CadetBlue\\n  attributes.ColorSource = ObjectColorSource.ColorFromObject\\n  doc.Objects.AddSphere(sphere, attributes)\\n\\n  doc.Views.Redraw()\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.DocObjects.ObjectAttributes","ObjectColorSource ColorSource"],["Rhino.DocObjects.ObjectAttributes","Color ObjectColor"]]},{"name":"Moveobjectstocurrentlayer.py","code":"from Rhino import *\\nfrom Rhino.Commands import *\\nfrom Rhino.DocObjects import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  # all non-light objects that are selected\\n  object_enumerator_settings = ObjectEnumeratorSettings()\\n  object_enumerator_settings.IncludeLights = False\\n  object_enumerator_settings.IncludeGrips = True\\n  object_enumerator_settings.NormalObjects = True\\n  object_enumerator_settings.LockedObjects = True\\n  object_enumerator_settings.HiddenObjects = True\\n  object_enumerator_settings.ReferenceObjects = True\\n  object_enumerator_settings.SelectedObjectsFilter = True\\n  selected_objects = doc.Objects.GetObjectList(object_enumerator_settings)\\n\\n  current_layer_index = doc.Layers.CurrentLayerIndex\\n  for selected_object in selected_objects:\\n    selected_object.Attributes.LayerIndex = current_layer_index\\n    selected_object.CommitChanges()\\n\\n  doc.Views.Redraw()\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.DocObjects.ObjectAttributes","int LayerIndex"],["Rhino.DocObjects.Tables.LayerTable","int CurrentLayerIndex"]]},{"name":"Nurbscurveincreasedegree.py","code":"from Rhino import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Input import *\\nfrom Rhino.DocObjects import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  rc, obj_ref = RhinoGet.GetOneObject(\\"Select curve\\", False, ObjectType.Curve)\\n  if rc != Result.Success: return rc\\n  if obj_ref == None: return Result.Failure\\n  curve = obj_ref.Curve()\\n  if curve == None: return Result.Failure\\n  nurbs_curve = curve.ToNurbsCurve()\\n\\n  new_degree = -1\\n  rc, new_degree = RhinoGet.GetInteger(\\n    \\"New degree <{0}...11>\\".format(nurbs_curve.Degree), True, new_degree, nurbs_curve.Degree, 11)\\n  if rc != Result.Success: return rc\\n\\n  rc = Result.Failure\\n  if nurbs_curve.IncreaseDegree(new_degree):\\n    if doc.Objects.Replace(obj_ref.ObjectId, nurbs_curve):\\n      rc = Result.Success\\n\\n  print \\"Result: {0}\\".format(rc)\\n  doc.Views.Redraw()\\n  return rc\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.NurbsCurve","bool IncreaseDegree(int desiredDegree)"]]},{"name":"Nurbssurfaceincreasedegree.py","code":"from Rhino import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Input import *\\nfrom Rhino.DocObjects import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  rc, obj_ref = RhinoGet.GetOneObject(\\"Select surface\\", False, ObjectType.Surface)\\n  if rc != Result.Success: return rc\\n  if obj_ref == None: return Result.Failure\\n  surface = obj_ref.Surface()\\n  if surface == None: return Result.Failure\\n  nurbs_surface = surface.ToNurbsSurface()\\n\\n  new_u_degree = -1\\n  rc, new_u_degree = RhinoGet.GetInteger(\\n    \\"New U degree <{0}...11>\\".format(nurbs_surface.Degree(0)), True, new_u_degree, nurbs_surface.Degree(0), 11)\\n  if rc != Result.Success: return rc\\n  \\n  new_v_degree = -1\\n  rc, new_v_degree = RhinoGet.GetInteger(\\n    \\"New V degree <{0}...11>\\".format(nurbs_surface.Degree(1)), True, new_v_degree, nurbs_surface.Degree(1), 11)\\n  if rc != Result.Success: return rc\\n\\n  rc = Result.Failure\\n  if nurbs_surface.IncreaseDegreeU(new_u_degree):\\n    if nurbs_surface.IncreaseDegreeV(new_v_degree):\\n      if doc.Objects.Replace(obj_ref.ObjectId, nurbs_surface):\\n        rc = Result.Success\\n\\n  print \\"Result: {0}\\".format(rc)\\n  doc.Views.Redraw()\\n  return rc\\n\\nif __name__==\\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.NurbsSurface","bool IncreaseDegreeU(int desiredDegree)"],["Rhino.Geometry.NurbsSurface","bool IncreaseDegreeV(int desiredDegree)"]]},{"name":"Objectdecoration.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef ObjectDecoration():\\n    # Define a line\\n    line = Rhino.Geometry.Line(Rhino.Geometry.Point3d(0, 0, 0), Rhino.Geometry.Point3d(10, 0, 0))\\n\\n    # Make a copy of Rhino\'s default object attributes\\n    attribs = scriptcontext.doc.CreateDefaultAttributes()\\n\\n    # Modify the object decoration style\\n    attribs.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.BothArrowhead\\n\\n    # Create a new curve object with our attributes\\n    scriptcontext.doc.Objects.AddLine(line, attribs)\\n    scriptcontext.doc.Views.Redraw()\\n\\nif __name__ == \\"__main__\\":\\n    ObjectDecoration()","members":[["Rhino.RhinoDoc","DocObjects.ObjectAttributes CreateDefaultAttributes()"]]},{"name":"Objectdisplaymode.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef ObjectDisplayMode():\\n    filter = Rhino.DocObjects.ObjectType.Brep | Rhino.DocObjects.ObjectType.Mesh\\n    rc, objref = Rhino.Input.RhinoGet.GetOneObject(\\"Select mesh or surface\\", True, filter)\\n    if rc != Rhino.Commands.Result.Success: return rc;\\n    viewportId = scriptcontext.doc.Views.ActiveView.ActiveViewportID\\n\\n    attr = objref.Object().Attributes\\n    if attr.HasDisplayModeOverride(viewportId):\\n        print \\"Removing display mode override from object\\"\\n        attr.RemoveDisplayModeOverride(viewportId)\\n    else:\\n        modes = Rhino.Display.DisplayModeDescription.GetDisplayModes()\\n        mode = None\\n        if len(modes) == 1:\\n            mode = modes[0]\\n        else:\\n            go = Rhino.Input.Custom.GetOption()\\n            go.SetCommandPrompt(\\"Select display mode\\")\\n            str_modes = []\\n            for m in modes:\\n                s = m.EnglishName.replace(\\" \\",\\"\\").replace(\\"-\\",\\"\\")\\n                str_modes.append(s)\\n            go.AddOptionList(\\"DisplayMode\\", str_modes, 0)\\n            if go.Get()==Rhino.Input.GetResult.Option:\\n                mode = modes[go.Option().CurrentListOptionIndex]\\n        if not mode: return Rhino.Commands.Result.Cancel\\n        attr.SetDisplayModeOverride(mode, viewportId)\\n    scriptcontext.doc.Objects.ModifyAttributes(objref, attr, False)\\n    scriptcontext.doc.Views.Redraw()\\n\\n\\nif __name__==\\"__main__\\":\\n    ObjectDisplayMode()","members":[["Rhino.DocObjects.ObjectAttributes","bool HasDisplayModeOverride(Guid viewportId)"],["Rhino.DocObjects.ObjectAttributes","void RemoveDisplayModeOverride(Guid rhinoViewportId)"],["Rhino.DocObjects.ObjectAttributes","bool SetDisplayModeOverride(DisplayModeDescription mode, Guid rhinoViewportId)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionList(LocalizeStringPair optionName, IEnumerable<LocalizeStringPair> listValues, int listCurrentIndex)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionList(string englishOptionName, IEnumerable<string> listValues, int listCurrentIndex)"]]},{"name":"Objectiterator.py","code":"from Rhino import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Commands import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  object_enumerator_settings = ObjectEnumeratorSettings()\\n  object_enumerator_settings.IncludeLights = True\\n  object_enumerator_settings.IncludeGrips = False\\n  rhino_objects = doc.Objects.GetObjectList(object_enumerator_settings)\\n\\n  count = 0\\n  for rhino_object in rhino_objects:\\n    if rhino_object.IsSelectable() and rhino_object.IsSelected(False) == 0:\\n      rhino_object.Select(True)\\n      count += 1;\\n\\n  if count > 0:\\n    doc.Views.Redraw()\\n    RhinoApp.WriteLine(\\"{0} object{1} selected\\", count,\\n      \\"\\" if count == 1 else \\"s\\")\\n\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.DocObjects.ObjectEnumeratorSettings","bool IncludeGrips"],["Rhino.DocObjects.ObjectEnumeratorSettings","bool IncludeLights"]]},{"name":"Orientonsrf.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid\\n\\ndef OrientOnSrf():\\n    # Select objects to orient\\n    go = Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt(\\"Select objects to orient\\")\\n    go.SubObjectSelect = False\\n    go.GroupSelect = True\\n    go.GetMultiple(1, 0)\\n    if go.CommandResult()!=Rhino.Commands.Result.Success:\\n        return go.CommandResult()\\n\\n    # Point to orient from\\n    gp = Rhino.Input.Custom.GetPoint()\\n    gp.SetCommandPrompt(\\"Point to orient from\\")\\n    gp.Get()\\n    if gp.CommandResult()!=Rhino.Commands.Result.Success:\\n        return gp.CommandResult()\\n    \\n    # Define source plane\\n    view = gp.View()\\n    if not view:\\n        view = doc.Views.ActiveView\\n        if not view: return Rhino.Commands.Result.Failure\\n\\n    source_plane = view.ActiveViewport.ConstructionPlane()\\n    source_plane.Origin = gp.Point()\\n\\n    # Surface to orient on\\n    gs = Rhino.Input.Custom.GetObject()\\n    gs.SetCommandPrompt(\\"Surface to orient on\\")\\n    gs.GeometryFilter = Rhino.DocObjects.ObjectType.Surface\\n    gs.SubObjectSelect = True\\n    gs.DeselectAllBeforePostSelect = False\\n    gs.OneByOnePostSelect = True\\n    gs.Get()\\n    if gs.CommandResult()!=Rhino.Commands.Result.Success:\\n        return gs.CommandResult()\\n\\n    objref = gs.Object(0)\\n    # get selected surface object\\n    obj = objref.Object()\\n    if not obj: return Rhino.Commands.Result.Failure\\n    # get selected surface (face)\\n    surface = objref.Surface()\\n    if not surface: return Rhino.Commands.Result.Failure\\n    # Unselect surface\\n    obj.Select(False)\\n\\n    # Point on surface to orient to\\n    gp.SetCommandPrompt(\\"Point on surface to orient to\\")\\n    gp.Constrain(surface, False)\\n    gp.Get()\\n    if gp.CommandResult()!=Rhino.Commands.Result.Success:\\n        return gp.CommandResult()\\n\\n    # Do transformation\\n    rc = Rhino.Commands.Result.Failure\\n    getrc, u, v = surface.ClosestPoint(gp.Point())\\n    if getrc:\\n        getrc, target_plane = surface.FrameAt(u,v)\\n        if getrc:\\n            # Build transformation\\n            xform = Rhino.Geometry.Transform.PlaneToPlane(source_plane, target_plane)\\n            # Do the transformation. In this example, we will copy the original objects\\n            delete_original = False\\n            for i in range(go.ObjectCount):\\n                rhobj = go.Object(i)\\n                scriptcontext.doc.Objects.Transform(rhobj, xform, delete_original)\\n            scriptcontext.doc.Views.Redraw()\\n            rc = Rhino.Commands.Result.Success\\n    return rc\\n\\n\\nif __name__==\\"__main__\\":\\n    OrientOnSrf()\\n","members":[["Rhino.Geometry.Surface","bool ClosestPoint(Point3d testPoint, out double u, out double v)"],["Rhino.Geometry.Surface","bool FrameAt(double u, double v, out Plane frame)"],["Rhino.DocObjects.RhinoObject","int Select(bool on)"],["Rhino.DocObjects.ObjRef","RhinoObject Object()"],["Rhino.DocObjects.ObjRef","Surface Surface()"],["Rhino.Input.Custom.GetObject","bool DeselectAllBeforePostSelect"],["Rhino.Input.Custom.GetObject","ObjectType GeometryFilter"],["Rhino.Input.Custom.GetObject","bool GroupSelect"],["Rhino.Input.Custom.GetObject","bool OneByOnePostSelect"],["Rhino.Input.Custom.GetObject","bool SubObjectSelect"],["Rhino.Input.Custom.GetObject","ObjRef Object(int index)"],["Rhino.Input.Custom.GetPoint","bool Constrain(Surface surface, bool allowPickingPointOffObject)"],["Rhino.DocObjects.Tables.ObjectTable","Guid Transform(ObjRef objref, Transform xform, bool deleteOriginal)"]]},{"name":"Ortho.py","code":"from Rhino import *\\nfrom Rhino.ApplicationSettings import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Input.Custom import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  gp = GetPoint()\\n  gp.SetCommandPrompt(\\"Start of line\\")\\n  gp.Get()\\n  if gp.CommandResult() != Result.Success:\\n    return gp.CommandResult()\\n  start_point = gp.Point()\\n\\n  original_ortho = ModelAidSettings.Ortho\\n  if not original_ortho:\\n    ModelAidSettings.Ortho = True\\n\\n  gp.SetCommandPrompt(\\"End of line\\")\\n  gp.SetBasePoint(start_point, False)\\n  gp.DrawLineFromPoint(start_point, True)\\n  gp.Get()\\n  if gp.CommandResult() != Result.Success:\\n    return gp.CommandResult()\\n  end_point = gp.Point()\\n\\n  if ModelAidSettings.Ortho != original_ortho:\\n    ModelAidSettings.Ortho = original_ortho\\n\\n  doc.Objects.AddLine(start_point, end_point)\\n  doc.Views.Redraw()\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.ApplicationSettings.ModelAidSettings","static bool Ortho"]]},{"name":"Planesurface.py","code":"import Rhino;\\nimport rhinoscriptsyntax as rs\\n\\ndef RunCommand():\\n  rc, corners = Rhino.Input.RhinoGet.GetRectangle()\\n  if rc <> Rhino.Commands.Result.Success:\\n      return rc\\n\\n  plane = Rhino.Geometry.Plane(corners[0], corners[1], corners[2])\\n  u_dir = rs.Distance(corners[0], corners[1])\\n  v_dir = rs.Distance(corners[1], corners[2])\\n  rs.AddPlaneSurface(plane, u_dir, v_dir)\\n\\nif __name__ == \\"__main__\\":\\n    RunCommand()","members":[["Rhino.Geometry.PlaneSurface","PlaneSurface(Plane plane, Interval xExtents, Interval yExtents)"]]},{"name":"Principalcurvature.py","code":"import rhinoscriptsyntax as rs\\n\\nsurface_id,_,_,_,_,_ = rs.GetSurfaceObject(\\"Select surface for curvature measurement\\")\\npoint = rs.GetPointOnSurface(surface_id, \\n    \\"Select point on surface for curvature measurement\\")\\nu,v = rs.SurfaceClosestPoint(surface_id, point)\\n\\n#point, normal, kappa_u, direction_u, kappa_v, direction_v, gaussian, mean =\\nsurface_curvature = rs.SurfaceCurvature(surface_id, (u,v))\\n    \\npoint, normal, kappa_u, direction_u, kappa_v, direction_v, gaussian, mean = surface_curvature\\n\\nprint \\"Surface curvature evaluation at parameter: ({0}, {1})\\".format(u,v)\\n\\nprint \\"  3-D Point: ({0}, {1}, {2})\\".format(point.X, point.Y, point.Z)\\n\\nprint \\"  3-D Normal: ({0}, {1}, {2})\\".format(normal.X, normal.Y, normal.Z)\\n\\nprint \\"  Maximum principal curvature: {0} ({1}, {2}, {3})\\".format(\\n  kappa_u, direction_u.X, direction_u.Y, direction_u.Z)\\n\\nprint \\"  Minimum principal curvature: {0} ({1}, {2}, {3})\\".format(\\n  kappa_v, direction_v.X, direction_v.Y, direction_v.Z)\\n\\nprint \\"  Gaussian curvature: {0}\\".format(gaussian)\\nprint \\"  Mean curvature: {0}\\".format(mean)","members":[["Rhino.Geometry.SurfaceCurvature","double Gaussian"],["Rhino.Geometry.SurfaceCurvature","double Mean"],["Rhino.Geometry.SurfaceCurvature","Vector3d Normal"],["Rhino.Geometry.SurfaceCurvature","Point3d Point"],["Rhino.Geometry.SurfaceCurvature","Vector3d Direction(int direction)"],["Rhino.Geometry.SurfaceCurvature","double Kappa(int direction)"],["Rhino.Geometry.Surface","SurfaceCurvature CurvatureAt(double u, double v)"]]},{"name":"Printinstancedefinitiontree.py","code":"from scriptcontext import doc\\nimport Rhino\\n\\ndef RunCommand():\\n  instanceDefinitions = doc.InstanceDefinitions\\n  instanceDefinitionCount = instanceDefinitions.Count\\n\\n  if instanceDefinitionCount == 0:\\n    print \\"Document contains no instance definitions.\\"\\n    return\\n\\n  dump = Rhino.FileIO.TextLog()\\n  dump.IndentSize = 4\\n\\n  for i in range(0, instanceDefinitionCount):\\n    DumpInstanceDefinition(instanceDefinitions[i], dump, True)\\n\\n  print dump.ToString()\\n\\ndef DumpInstanceDefinition(instanceDefinition, dump, isRoot):\\n  if instanceDefinition != None and not instanceDefinition.IsDeleted:\\n    if isRoot:\\n      node = \'-\'\\n    else:\\n      node = \'+\'\\n    dump.Print(u\\"{0} Instance definition {1} = {2}\\\\n\\".format(node, instanceDefinition.Index, instanceDefinition.Name))\\n\\n    if instanceDefinition.ObjectCount  > 0:\\n      dump.PushIndent()\\n      for i in range(0, instanceDefinition.ObjectCount):\\n        obj = instanceDefinition.Object(i)\\n        if obj != None and type(obj) == Rhino.DocObjects.InstanceObject:\\n          DumpInstanceDefinition(obj.InstanceDefinition, dump, False) # Recursive...\\n        else:\\n          dump.Print(u\\"+ Object {0} = {1}\\\\n\\".format(i, obj.ShortDescription(False)))\\n      dump.PopIndent()\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()\\n","members":[["Rhino.RhinoDoc","InstanceDefinitionTable InstanceDefinitions"],["Rhino.FileIO.TextLog","void PopIndent()"],["Rhino.FileIO.TextLog","void Print(string text)"],["Rhino.FileIO.TextLog","void PushIndent()"]]},{"name":"Projectpointstobreps.py","code":"import rhinoscriptsyntax as rs\\nfrom scriptcontext import *\\nfrom Rhino.Geometry import *\\n\\ndef RunCommand():\\n  srfid = rs.GetObject(\\"select surface\\", rs.filter.surface | rs.filter.polysurface)\\n  if not srfid: return\\n  brep = rs.coercebrep(srfid)\\n  if not brep: return\\n  \\n  pts = Intersect.Intersection.ProjectPointsToBreps(\\n      [brep], # brep on which to project\\n      [Point3d(0, 0, 0), Point3d(3,0,3), Point3d(-2,0,-2)], # points to project\\n      Vector3d(0, 1, 0), # project on Y axis\\n      doc.ModelAbsoluteTolerance)\\n\\n  if pts != None and pts.Length > 0:\\n    for pt in pts:\\n      doc.Objects.AddPoint(pt)\\n\\n  doc.Views.Redraw()\\n\\nif __name__ == \\"__main__\\":\\n    RunCommand()","members":[["Rhino.Geometry.Intersect.Intersection","static Point3d[] ProjectPointsToBreps(IEnumerable<Brep> breps, IEnumerable<Point3d> points, Vector3d direction, double tolerance)"]]},{"name":"Projectpointstomeshesex.py","code":"from System.Collections.Generic import *\\nfrom Rhino import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Geometry import *\\nfrom Rhino.Geometry.Intersect import *\\nfrom Rhino.Input import *\\nfrom Rhino.DocObjects import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  rc, obj_ref = RhinoGet.GetOneObject(\\"mesh\\", False, ObjectType.Mesh)\\n  if rc != Result.Success: return rc\\n  mesh = obj_ref.Mesh()\\n\\n  rc, obj_ref_pts = RhinoGet.GetMultipleObjects(\\"points\\", False, ObjectType.Point)\\n  if rc != Result.Success: return rc\\n  points = []\\n  for obj_ref_pt in obj_ref_pts:\\n    pt = obj_ref_pt.Point().Location\\n    points.append(pt)\\n\\n  prj_points, indices = Intersection.ProjectPointsToMeshesEx({mesh}, points, Vector3d(0, 1, 0), 0)\\n  for prj_pt in prj_points: \\n    doc.Objects.AddPoint(prj_pt)\\n  doc.Views.Redraw()\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.Intersect.Intersection","static Point3d[] ProjectPointsToMeshesEx(IEnumerable<Mesh> meshes, IEnumerable<Point3d> points, Vector3d direction, double tolerance, out int[] indices)"]]},{"name":"Renameblock.py","code":"import rhinoscriptsyntax as rs\\nfrom scriptcontext import doc\\n\\ndef Rename():\\n    blockName = rs.GetString(\\"block to rename\\")\\n    instanceDefinition = doc.InstanceDefinitions.Find(blockName, True)\\n    if not instanceDefinition: \\n        print \\"{0} block does not exist\\".format(blockName)\\n        return\\n    \\n    newName = rs.GetString(\\"new name\\")\\n    instanceDefinition = doc.InstanceDefinitions.Find(newName, True)\\n    if instanceDefinition: \\n        print \\"the name \'{0}\' is already taken by another block\\".format(newName)\\n        return\\n\\n    rs.RenameBlock(blockName, newName)\\n    \\nif __name__ == \\"__main__\\":\\n    Rename()","members":[["Rhino.DocObjects.InstanceDefinition","bool IsDeleted"],["Rhino.DocObjects.InstanceDefinition","bool IsReference"],["Rhino.DocObjects.Tables.InstanceDefinitionTable","bool Modify(int idefIndex, string newName, string newDescription, bool quiet)"]]},{"name":"Replacecolordialog.py","code":"from Rhino import *\\nfrom Rhino.Commands import *\\nfrom Rhino.UI import *\\nfrom System.Windows.Forms import *\\n\\nm_dlg = None\\n\\ndef RunCommand():\\n  Dialogs.SetCustomColorDialog(OnSetCustomColorDialog)\\n  return Result.Success\\n\\ndef OnSetCustomColorDialog(sender, e):\\n  m_dlg = ColorDialog()\\n  if m_dlg.ShowDialog(None) == DialogResult.OK:\\n    c = m_dlg.Color\\n    e.SelectedColor = c\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.UI.Dialogs","static void SetCustomColorDialog(EventHandler<GetColorEventArgs> handler)"]]},{"name":"Replacehatchpattern.py","code":"from Rhino import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Input import *\\nfrom Rhino.Input.Custom import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  rc, obj_refs = RhinoGet.GetMultipleObjects(\\"Select hatches to replace\\", False, ObjectType.Hatch)\\n  if rc <> Result.Success or obj_refs == None:\\n    return rc\\n\\n  gs = GetString()\\n  gs.SetCommandPrompt(\\"Name of replacement hatch pattern\\")\\n  gs.AcceptNothing(False)\\n  gs.Get()\\n  if gs.CommandResult() <> Result.Success:\\n    return gs.CommandResult()\\n  hatch_name = gs.StringResult()\\n\\n  pattern_index = doc.HatchPatterns.Find(hatch_name, True)\\n\\n  if pattern_index < 0:\\n    RhinoApp.WriteLine(\\"The hatch pattern \\"{0}\\" not found  in the document.\\", hatch_name)\\n    return Result.Nothing\\n\\n  for obj_ref in obj_refs:\\n    hatch_object = obj_ref.Object()\\n    if hatch_object.HatchGeometry.PatternIndex <> pattern_index:\\n      hatch_object.HatchGeometry.PatternIndex = pattern_index\\n      hatch_object.CommitChanges()\\n\\n  doc.Views.Redraw()\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.Hatch","int PatternIndex"],["Rhino.DocObjects.HatchObject","Hatch HatchGeometry"]]},{"name":"Rhinopageviewwidthheight.py","code":"from Rhino import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Input import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  width = 1189\\n  height = 841\\n  page_views = doc.Views.GetPageViews()\\n  page_number = 1 if page_views==None else page_views.Length + 1\\n  pageview = doc.Views.AddPageView(\\"A0_{0}\\".format(page_number), width, height)\\n\\n  new_width = width\\n  rc, new_width = RhinoGet.GetInteger(\\"new width\\", False, new_width)\\n  if rc != Result.Success or new_width <= 0: return rc\\n\\n  new_height = height\\n  rc, new_height = RhinoGet.GetInteger(\\"new height\\", False, new_height)\\n  if rc != Result.Success or new_height <= 0: return rc\\n\\n  pageview.PageWidth = new_width\\n  pageview.PageHeight = new_height\\n  doc.Views.Redraw()\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Display.RhinoPageView","double PageHeight"],["Rhino.Display.RhinoPageView","double PageWidth"]]},{"name":"Screencaptureview.py","code":"from scriptcontext import doc\\nfrom System.Windows.Forms import *\\nimport Rhino.UI\\nfrom System import Environment\\n\\ndef RunCommand():\\n  file_name = \\"\\";\\n\\n  bitmap = doc.Views.ActiveView.CaptureToBitmap(True, True, True)\\n\\n  # copy bitmap to clipboard\\n  Clipboard.SetImage(bitmap)\\n\\n\\n  # save bitmap to file\\n  save_file_dialog = Rhino.UI.SaveFileDialog()\\n  save_file_dialog.Filter = \\"*.bmp\\"\\n  save_file_dialog.InitialDirectory = \\\\\\n    Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)\\n\\n  if save_file_dialog.ShowDialog() == DialogResult.OK:\\n    file_name = save_file_dialog.FileName\\n\\n  if file_name != \\"\\":\\n    bitmap.Save(file_name)\\n\\n  return Rhino.Commands.Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Display.RhinoView","System.Drawing.Bitmap CaptureToBitmap(bool grid, bool worldAxes, bool cplaneAxes)"],["Rhino.UI.SaveFileDialog","SaveFileDialog()"],["Rhino.UI.SaveFileDialog","string FileName"],["Rhino.UI.SaveFileDialog","string Filter"],["Rhino.UI.SaveFileDialog","string InitialDirectory"],["Rhino.UI.SaveFileDialog","bool ShowSaveDialog()"]]},{"name":"Sellayer.py","code":"import Rhino\\nimport scriptcontext\\nimport System.Guid, System.Drawing.Color\\n\\ndef SelLayer():\\n    # Prompt for a layer name\\n    layername = scriptcontext.doc.Layers.CurrentLayer.Name\\n    rc, layername = Rhino.Input.RhinoGet.GetString(\\"Name of layer to select objects\\", True, layername)\\n    if rc!=Rhino.Commands.Result.Success: return rc\\n    \\n    # Get all of the objects on the layer. If layername is bogus, you will\\n    # just get an empty list back\\n    rhobjs = scriptcontext.doc.Objects.FindByLayer(layername)\\n    if not rhobjs: Rhino.Commands.Result.Cancel\\n    \\n    for obj in rhobjs: obj.Select(True)\\n    scriptcontext.doc.Views.Redraw()\\n    return Rhino.Commands.Result.Success\\n\\nif __name__==\\"__main__\\":\\n    SelLayer()\\n","members":[["Rhino.DocObjects.Layer","string Name"],["Rhino.DocObjects.Tables.ObjectTable","RhinoObject[] FindByLayer(string layerName)"],["Rhino.DocObjects.Tables.LayerTable","Layer CurrentLayer"]]},{"name":"Splitbrepwithplane.py","code":"from Rhino import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Commands import *\\nfrom Rhino.Input import *\\nfrom Rhino.Geometry import *\\nfrom scriptcontext import doc\\n\\ndef RunCommand():\\n  #First, collect all the breps to split\\n  rc, obj_refs = RhinoGet.GetMultipleObjects(\\"Select breps to split\\", False, ObjectType.Brep)\\n  if rc <> Result.Success or obj_refs == None:\\n    return rc\\n\\n  # Get the final plane\\n  rc, plane = RhinoGet.GetPlane()\\n  if rc <> Result.Success:\\n    return rc\\n\\n  #Iterate over all object references\\n  for obj_ref in obj_refs:\\n    brep = obj_ref.Brep()\\n    bbox = brep.GetBoundingBox(False)\\n\\n    #Grow the boundingbox in all directions\\n    #If the boundingbox is flat (zero volume or even zero area) \\n    #then the CreateThroughBox method will fail.\\n    min_point = bbox.Min\\n    min_point.X -= 1.0\\n    min_point.Y -= 1.0\\n    min_point.Z -= 1.0\\n    bbox.Min = min_point\\n    max_point = bbox.Max\\n    max_point.X += 1.0\\n    max_point.Y += 1.0\\n    max_point.Z += 1.0\\n    bbox.Max = max_point\\n\\n    plane_surface = PlaneSurface.CreateThroughBox(plane, bbox)\\n    if plane_surface == None:\\n      #This is rare, it will most likely not happen unless either the plane or the boundingbox are invalid\\n      RhinoApp.WriteLine(\\"Cutting plane could not be constructed.\\")\\n    else:\\n      breps = brep.Split(plane_surface.ToBrep(), doc.ModelAbsoluteTolerance)\\n      if breps == None or breps.Length == 0:\\n        RhinoApp.Write(\\"Plane does not intersect brep (id:{0})\\", obj_ref.ObjectId)\\n        continue\\n      for brep_piece in breps:\\n        doc.Objects.AddBrep(brep_piece)\\n      doc.Objects.AddSurface(plane_surface)\\n      doc.Objects.Delete(obj_ref, False)\\n\\n  doc.Views.Redraw()\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.PlaneSurface","static PlaneSurface CreateThroughBox(Plane plane, BoundingBox box)"],["Rhino.Input.RhinoGet","static Result GetPlane(out Plane plane)"]]},{"name":"Srfpt.py","code":"from Rhino.Geometry import NurbsSurface, Point3d\\nfrom scriptcontext import doc\\n\\nsurface = NurbsSurface.CreateFromCorners(\\n  Point3d(5, 0, 0),\\n  Point3d(5, 5, 5),\\n  Point3d(0, 5, 0),\\n  Point3d(0, 0, 0));\\n\\ndoc.Objects.AddSurface(surface);\\ndoc.Views.Redraw();","members":[["Rhino.Geometry.NurbsSurface","static NurbsSurface CreateFromCorners(Point3d corner1, Point3d corner2, Point3d corner3, Point3d corner4)"]]},{"name":"Sweep1.py","code":"import rhinoscriptsyntax as rs\\nimport Rhino\\nimport scriptcontext\\n\\ndef Sweep1():\\n    rail = rs.GetObject(\\"Select rail curve\\", rs.filter.curve)\\n    rail_crv = rs.coercecurve(rail)\\n    if not rail_crv: return\\n\\n    cross_sections = rs.GetObjects(\\"Select cross section curves\\", rs.filter.curve)\\n    if not cross_sections: return\\n    cross_sections = [rs.coercecurve(crv) for crv in cross_sections]\\n\\n    sweep = Rhino.Geometry.SweepOneRail()\\n    sweep.AngleToleranceRadians = scriptcontext.doc.ModelAngleToleranceRadians\\n    sweep.ClosedSweep = False\\n    sweep.SweepTolerance = scriptcontext.doc.ModelAbsoluteTolerance\\n    sweep.SetToRoadlikeTop()\\n    breps = sweep.PerformSweep(rail_crv, cross_sections)\\n    for brep in breps: scriptcontext.doc.Objects.AddBrep(brep)\\n    scriptcontext.doc.Views.Redraw()\\n\\nif __name__ == \\"__main__\\":\\n    Sweep1()\\n","members":[["Rhino.Geometry.SweepOneRail","SweepOneRail()"],["Rhino.Geometry.SweepOneRail","Brep[] PerformSweep(Curve rail, IEnumerable<Curve> crossSections)"]]},{"name":"Textjustify.py","code":"from scriptcontext import doc\\nfrom Rhino.Geometry import *\\n\\ntext_entity = TextEntity()\\ntext_entity.Plane = Plane.WorldXY\\ntext_entity.Text = \\"Hello Rhino!\\"\\ntext_entity.Justification = TextJustification.MiddleCenter\\ntext_entity.FontIndex = doc.Fonts.FindOrCreate(\\"Arial\\", False, False)\\n\\ndoc.Objects.AddText(text_entity)\\ndoc.Views.Redraw()","members":[["Rhino.Geometry.TextEntity","TextEntity()"],["Rhino.Geometry.TextEntity","TextJustification Justification"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddText(Text3d text3d)"],["Rhino.DocObjects.Tables.FontTable","int FindOrCreate(string face, bool bold, bool italic)"]]},{"name":"Tightboundingbox.py","code":"from scriptcontext import doc\\nimport rhinoscriptsyntax as rs\\nfrom Rhino.Geometry import *\\nfrom Rhino.Input import *\\nfrom Rhino.DocObjects import *\\nfrom Rhino.Commands import *\\nfrom System.Collections.Generic import *\\n\\ndef RunCommand():\\n  rc, obj_ref = RhinoGet.GetOneObject(\\n    \\"Select surface to split\\", True, ObjectType.Surface)\\n  if rc != Result.Success:\\n    return rc\\n  brep_face = obj_ref.Surface()\\n  if brep_face == None:\\n    return Result.Failure\\n\\n  rc, obj_ref = RhinoGet.GetOneObject(\\n    \\"Select cutting curve\\", True, ObjectType.Curve)\\n  if rc != Result.Success:\\n    return rc\\n  curve = obj_ref.Curve()\\n  if curve == None:\\n    return Result.Failure\\n\\n  curves = List[Curve]([curve])\\n  split_brep = brep_face.Split(\\n    curves, doc.ModelAbsoluteTolerance)\\n\\n  if split_brep == None:\\n    RhinoApp.WriteLine(\\"Unable to split surface.\\")\\n    return Result.Nothing\\n\\n  meshes = Mesh.CreateFromBrep(split_brep)\\n  print type(meshes)\\n  for mesh in meshes:\\n    bbox = mesh.GetBoundingBox(True)\\n    bbox_type = bbox.IsDegenerate(doc.ModelAbsoluteTolerance)\\n    if bbox_type == 1: # rectangle\\n        # box with 8 corners flattened to rectangle with 4 corners\\n        box_corners = bbox.GetCorners()\\n        rectangle_corners = []\\n        for corner_point in box_corners:\\n          if corner_point not in rectangle_corners:\\n              rectangle_corners.append(corner_point)\\n        # add 1st point as last to close the loop\\n        rectangle_corners.append(rectangle_corners[0])\\n        doc.Objects.AddPolyline(rectangle_corners)\\n        doc.Views.Redraw()\\n    elif bbox_type == 0: # box\\n        brep_box = Box(bbox).ToBrep()\\n        doc.Objects.AddBrep(brep_box)\\n        doc.Views.Redraw()\\n    else: # bbox invalid, point, or line\\n      return Result.Failure\\n\\n  return Result.Success\\n\\nif __name__ == \\"__main__\\":\\n  RunCommand()","members":[["Rhino.Geometry.BrepFace","Brep Split(IEnumerable<Curve> curves, double tolerance)"],["Rhino.Geometry.Mesh","static Mesh[] CreateFromBrep(Brep brep)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddPolyline(IEnumerable<Point3d> points)"]]},{"name":"Transformbrep.py","code":"import Rhino\\nimport scriptcontext\\n\\ndef TransformBrep():\\n    rc, objref = Rhino.Input.RhinoGet.GetOneObject(\\"Select brep\\", True, Rhino.DocObjects.ObjectType.Brep)\\n    if rc!=Rhino.Commands.Result.Success: return\\n    \\n    # Simple translation transformation\\n    xform = Rhino.Geometry.Transform.Translation(18,-18,25)\\n    scriptcontext.doc.Objects.Transform(objref, xform, True)\\n    scriptcontext.doc.Views.Redraw()\\n\\nif __name__==\\"__main__\\":\\n    TransformBrep()","members":[["Rhino.Geometry.Transform","static Transform Translation(double dx, double dy, double dz)"]]},{"name":"Viewportresolution.py","code":"from scriptcontext import doc\\n\\nactiveViewport = doc.Views.ActiveView.ActiveViewport\\nprint \\"Name = {0}: Width = {1}, Height = {2}\\".format(\\n    activeViewport.Name, activeViewport.Size.Width, activeViewport.Size.Height)\\n","members":[["Rhino.Display.RhinoViewport","Size Size"]]},{"name":"Activeviewport.vb","code":"Partial Class Examples\\n  Public Shared Function ActiveViewport(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim view As Rhino.Display.RhinoView = doc.Views.ActiveView\\n    If view Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    Dim pageview As Rhino.Display.RhinoPageView = TryCast(view, Rhino.Display.RhinoPageView)\\n    If pageview IsNot Nothing Then\\n      Dim layout_name As String = pageview.PageName\\n      If pageview.PageIsActive Then\\n        Rhino.RhinoApp.WriteLine(\\"The layout {0} is active\\", layout_name)\\n      Else\\n        Dim detail_name As String = pageview.ActiveViewport.Name\\n        Rhino.RhinoApp.WriteLine(\\"The detail {0} on layout {1} is active\\", detail_name, layout_name)\\n      End If\\n    Else\\n      Dim viewport_name As String = view.MainViewport.Name\\n      Rhino.RhinoApp.WriteLine(\\"The viewport {0} is active\\", viewport_name)\\n    End If\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Display.RhinoPageView","bool PageIsActive"],["Rhino.Display.RhinoPageView","string PageName"]]},{"name":"Addbackgroundbitmap.vb","code":"Partial Class Examples\\n  Public Shared Function AddBackgroundBitmap(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    \' Allow the user to select a bitmap file\\n    Dim fd As New Rhino.UI.OpenFileDialog()\\n    fd.Filter = \\"Image Files (*.bmp;*.png;*.jpg)|*.bmp;*.png;*.jpg\\"\\n    If fd.ShowDialog() <> System.Windows.Forms.DialogResult.OK Then\\n      Return Rhino.Commands.Result.Cancel\\n    End If\\n\\n    \' Verify the file that was selected\\n    Dim image As System.Drawing.Image\\n    Try\\n      image = System.Drawing.Image.FromFile(fd.FileName)\\n    Catch generatedExceptionName As Exception\\n      Return Rhino.Commands.Result.Failure\\n    End Try\\n\\n    \' Allow the user to pick the bitmap origin\\n    Dim gp As New Rhino.Input.Custom.GetPoint()\\n    gp.SetCommandPrompt(\\"Bitmap Origin\\")\\n    gp.ConstrainToConstructionPlane(True)\\n    gp.Get()\\n    If gp.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return gp.CommandResult()\\n    End If\\n\\n    \' Get the view that the point was picked in.\\n    \' This will be the view that the bitmap appears in.\\n    Dim view As Rhino.Display.RhinoView = gp.View()\\n    If view Is Nothing Then\\n      view = doc.Views.ActiveView\\n      If view Is Nothing Then\\n        Return Rhino.Commands.Result.Failure\\n      End If\\n    End If\\n\\n    \' Allow the user to specify the bitmap with in model units\\n    Dim gn As New Rhino.Input.Custom.GetNumber()\\n    gn.SetCommandPrompt(\\"Bitmap width\\")\\n    gn.SetLowerLimit(1.0, False)\\n    gn.Get()\\n    If gn.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return gn.CommandResult()\\n    End If\\n\\n    \' Cook up some scale factors\\n    Dim w As Double = gn.Number()\\n    Dim image_width As Double = CDbl(image.Width)\\n    Dim image_height As Double = CDbl(image.Height)\\n    Dim h As Double = w * (image_height / image_width)\\n\\n    Dim plane As Rhino.Geometry.Plane = view.ActiveViewport.ConstructionPlane()\\n    plane.Origin = gp.Point()\\n    view.ActiveViewport.SetTraceImage(fd.FileName, plane, w, h, False, False)\\n    view.Redraw()\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Display.RhinoView","RhinoViewport ActiveViewport"],["Rhino.Display.RhinoView","void Redraw()"],["Rhino.Display.RhinoViewport","Plane ConstructionPlane()"],["Rhino.Display.RhinoViewport","bool SetTraceImage(string bitmapFileName, Plane plane, double width, double height, bool grayscale, bool filtered)"],["Rhino.UI.OpenFileDialog","OpenFileDialog()"],["Rhino.UI.OpenFileDialog","string FileName"],["Rhino.UI.OpenFileDialog","string Filter"],["Rhino.UI.OpenFileDialog","bool ShowOpenDialog()"],["Rhino.Input.Custom.GetBaseClass","Result CommandResult()"],["Rhino.Input.Custom.GetBaseClass","double Number()"],["Rhino.Input.Custom.GetBaseClass","RhinoView View()"],["Rhino.Input.Custom.GetPoint","bool ConstrainToConstructionPlane(bool throughBasePoint)"],["Rhino.Input.Custom.GetNumber","GetNumber()"],["Rhino.Input.Custom.GetNumber","GetResult Get()"],["Rhino.Input.Custom.GetNumber","void SetLowerLimit(double lowerLimit, bool strictlyGreaterThan)"],["Rhino.DocObjects.Tables.ViewTable","RhinoView ActiveView"]]},{"name":"Addbrepbox.vb","code":"Partial Class Examples\\n  Public Shared Function AddBrepBox(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim pt0 As New Rhino.Geometry.Point3d(0, 0, 0)\\n    Dim pt1 As New Rhino.Geometry.Point3d(10, 10, 10)\\n    Dim box As New Rhino.Geometry.BoundingBox(pt0, pt1)\\n    Dim brep As Rhino.Geometry.Brep = box.ToBrep()\\n    Dim rc As Rhino.Commands.Result = Rhino.Commands.Result.Failure\\n    If doc.Objects.AddBrep(brep) <> System.Guid.Empty Then\\n      rc = Rhino.Commands.Result.Success\\n      doc.Views.Redraw()\\n    End If\\n    Return rc\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.BoundingBox","BoundingBox(Point3d min, Point3d max)"],["Rhino.Geometry.BoundingBox","Brep ToBrep()"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddBrep(Brep brep)"]]},{"name":"Addchildlayer.vb","code":"Partial Class Examples\\n  Public Shared Function AddChildLayer(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    \' Get an existing layer\\n    Dim default_name As String = doc.Layers.CurrentLayer.Name\\n\\n    \' Prompt the user to enter a layer name\\n    Dim gs As New Rhino.Input.Custom.GetString()\\n    gs.SetCommandPrompt(\\"Name of existing layer\\")\\n    gs.SetDefaultString(default_name)\\n    gs.AcceptNothing(True)\\n    gs.[Get]()\\n    If gs.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return gs.CommandResult()\\n    End If\\n\\n    \' Was a layer named entered?\\n    Dim layer_name As String = gs.StringResult().Trim()\\n    Dim index As Integer = doc.Layers.Find(layer_name, True)\\n    If index < 0 Then\\n      Return Rhino.Commands.Result.Cancel\\n    End If\\n\\n    Dim parent_layer As Rhino.DocObjects.Layer = doc.Layers(index)\\n\\n    \' Create a child layer\\n    Dim child_name As String = parent_layer.Name + \\"_child\\"\\n    Dim childlayer As New Rhino.DocObjects.Layer()\\n    childlayer.ParentLayerId = parent_layer.Id\\n    childlayer.Name = child_name\\n    childlayer.Color = System.Drawing.Color.Red\\n\\n    index = doc.Layers.Add(childlayer)\\n    If index < 0 Then\\n      Rhino.RhinoApp.WriteLine(\\"Unable to add {0} layer.\\", child_name)\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class","members":[["Rhino.DocObjects.Layer","Guid ParentLayerId"],["Rhino.DocObjects.Tables.LayerTable","int Add(Layer layer)"]]},{"name":"Addcircle.vb","code":"Partial Class Examples\\n  Public Shared Function AddCircle(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim center As New Rhino.Geometry.Point3d(0, 0, 0)\\n    Const radius As Double = 10.0\\n    Dim c As New Rhino.Geometry.Circle(center, radius)\\n    If doc.Objects.AddCircle(c) <> Guid.Empty Then\\n      doc.Views.Redraw()\\n      Return Rhino.Commands.Result.Success\\n    End If\\n    Return Rhino.Commands.Result.Failure\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Circle","Circle(Plane plane, double radius)"],["Rhino.Geometry.Point3d","Point3d(double x, double y, double z)"],["Rhino.DocObjects.Tables.ViewTable","void Redraw()"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddCircle(Circle circle)"]]},{"name":"Addclippingplane.vb","code":"Partial Class Examples\\n  Public Shared Function AddClippingPlane(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    \' Define the corners of the clipping plane\\n    Dim corners As Rhino.Geometry.Point3d() = Nothing\\n    Dim rc As Rhino.Commands.Result = Rhino.Input.RhinoGet.GetRectangle(corners)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    \' Get the active view\\n    Dim view As Rhino.Display.RhinoView = doc.Views.ActiveView\\n    If view Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    Dim p0 As Rhino.Geometry.Point3d = corners(0)\\n    Dim p1 As Rhino.Geometry.Point3d = corners(1)\\n    Dim p3 As Rhino.Geometry.Point3d = corners(3)\\n\\n    \' Create a plane from the corner points\\n    Dim plane As New Rhino.Geometry.Plane(p0, p1, p3)\\n\\n    \' Add a clipping plane object to the document\\n    Dim id As Guid = doc.Objects.AddClippingPlane(plane, p0.DistanceTo(p1), p0.DistanceTo(p3), view.ActiveViewportID)\\n    If id <> Guid.Empty Then\\n      doc.Views.Redraw()\\n      Return Rhino.Commands.Result.Success\\n    End If\\n    Return Rhino.Commands.Result.Failure\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Plane","Plane(Point3d origin, Point3d xPoint, Point3d yPoint)"],["Rhino.FileIO.File3dmObjectTable","Guid AddClippingPlane(Plane plane, double uMagnitude, double vMagnitude, Guid clippedViewportId)"],["Rhino.Input.RhinoGet","static Result GetRectangle(out Point3d[] corners)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddClippingPlane(Plane plane, double uMagnitude, double vMagnitude, Guid clippedViewportId)"]]},{"name":"Addcylinder.vb","code":"Partial Class Examples\\n  Public Shared Function AddCylinder(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim center_point As New Rhino.Geometry.Point3d(0, 0, 0)\\n    Dim height_point As New Rhino.Geometry.Point3d(0, 0, 10)\\n    Dim zaxis As Rhino.Geometry.Vector3d = height_point - center_point\\n    Dim plane As New Rhino.Geometry.Plane(center_point, zaxis)\\n    Const radius As Double = 5\\n    Dim circle As New Rhino.Geometry.Circle(plane, radius)\\n    Dim cylinder As New Rhino.Geometry.Cylinder(circle, zaxis.Length)\\n    Dim brep As Rhino.Geometry.Brep = cylinder.ToBrep(True, True)\\n    If brep IsNot Nothing Then\\n      doc.Objects.AddBrep(brep)\\n      doc.Views.Redraw()\\n    End If\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Cylinder","Cylinder(Circle baseCircle, double height)"],["Rhino.Geometry.Cylinder","Brep ToBrep(bool capBottom, bool capTop)"],["Rhino.Geometry.Plane","Plane(Point3d origin, Vector3d normal)"]]},{"name":"Addlayer.vb","code":"Partial Class Examples\\n  Public Shared Function AddLayer(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    \' Cook up an unused layer name\\n    Dim unused_name As String = doc.Layers.GetUnusedLayerName(False)\\n\\n    \' Prompt the user to enter a layer name\\n    Dim gs As New Rhino.Input.Custom.GetString()\\n    gs.SetCommandPrompt(\\"Name of layer to add\\")\\n    gs.SetDefaultString(unused_name)\\n    gs.AcceptNothing(True)\\n    gs.Get()\\n    If gs.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return gs.CommandResult()\\n    End If\\n\\n    \' Was a layer named entered?\\n    Dim layer_name As String = gs.StringResult().Trim()\\n    If String.IsNullOrEmpty(layer_name) Then\\n      Rhino.RhinoApp.WriteLine(\\"Layer name cannot be blank.\\")\\n      Return Rhino.Commands.Result.Cancel\\n    End If\\n\\n    \' Is the layer name valid?\\n    If Not Rhino.DocObjects.Layer.IsValidName(layer_name) Then\\n      Rhino.RhinoApp.WriteLine(layer_name & \\" is not a valid layer name.\\")\\n      Return Rhino.Commands.Result.Cancel\\n    End If\\n\\n    \' Does a layer with the same name already exist?\\n    Dim layer_index As Integer = doc.Layers.Find(layer_name, True)\\n    If layer_index >= 0 Then\\n      Rhino.RhinoApp.WriteLine(\\"A layer with the name {0} already exists.\\", layer_name)\\n      Return Rhino.Commands.Result.Cancel\\n    End If\\n\\n    \' Add a new layer to the document\\n    layer_index = doc.Layers.Add(layer_name, System.Drawing.Color.Black)\\n    If layer_index < 0 Then\\n      Rhino.RhinoApp.WriteLine(\\"Unable to add {0} layer.\\", layer_name)\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.RhinoApp","static void WriteLine(string message)"],["Rhino.RhinoApp","static void WriteLine(string format, object arg0)"],["Rhino.DocObjects.Layer","static bool IsValidName(string name)"],["Rhino.Input.Custom.GetBaseClass","void AcceptNothing(bool enable)"],["Rhino.Input.Custom.GetBaseClass","void SetDefaultString(string defaultValue)"],["Rhino.Input.Custom.GetBaseClass","string StringResult()"],["Rhino.Input.Custom.GetString","GetString()"],["Rhino.Input.Custom.GetString","GetResult Get()"],["Rhino.DocObjects.Tables.LayerTable","int Add(string layerName, Color layerColor)"],["Rhino.DocObjects.Tables.LayerTable","int Find(string layerName, bool ignoreDeletedLayers)"],["Rhino.DocObjects.Tables.LayerTable","Layer FindName(string layerName)"],["Rhino.DocObjects.Tables.LayerTable","string GetUnusedLayerName()"],["Rhino.DocObjects.Tables.LayerTable","string GetUnusedLayerName(bool ignoreDeleted)"]]},{"name":"Addlayout.vb","code":"Partial Class Examples\\n  \'\'\' <summary>\\n  \'\'\' Generate a layout with a single detail view that zooms to a list of objects\\n  \'\'\' </summary>\\n  \'\'\' <param name=\\"doc\\"></param>\\n  \'\'\' <returns></returns>\\n  Public Shared Function AddLayout(doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    doc.PageUnitSystem = Rhino.UnitSystem.Millimeters\\n    Dim page_views = doc.Views.GetPageViews()\\n    Dim page_number As Integer = If((page_views Is Nothing), 1, page_views.Length + 1)\\n    Dim pageview = doc.Views.AddPageView(String.Format(\\"A0_{0}\\", page_number), 1189, 841)\\n    If pageview IsNot Nothing Then\\n      Dim top_left As New Rhino.Geometry.Point2d(20, 821)\\n      Dim bottom_right As New Rhino.Geometry.Point2d(1169, 20)\\n      Dim detail = pageview.AddDetailView(\\"ModelView\\", top_left, bottom_right, Rhino.Display.DefinedViewportProjection.Top)\\n      If detail IsNot Nothing Then\\n        pageview.SetActiveDetail(detail.Id)\\n        detail.Viewport.ZoomExtents()\\n        detail.DetailGeometry.IsProjectionLocked = True\\n        detail.DetailGeometry.SetScale(1, doc.ModelUnitSystem, 10, doc.PageUnitSystem)\\n        \' Commit changes tells the document to replace the document\'s detail object\\n        \' with the modified one that we just adjusted\\n        detail.CommitChanges()\\n      End If\\n      pageview.SetPageAsActive()\\n      doc.Views.ActiveView = pageview\\n      doc.Views.Redraw()\\n      Return Rhino.Commands.Result.Success\\n    End If\\n    Return Rhino.Commands.Result.Failure\\n  End Function\\nEnd Class\\n","members":[["Rhino.RhinoDoc","UnitSystem PageUnitSystem"],["Rhino.Geometry.DetailView","bool IsProjectionLocked"],["Rhino.Geometry.DetailView","bool SetScale(double modelLength, UnitSystem modelUnits, double pageLength, UnitSystem pageUnits)"],["Rhino.DocObjects.RhinoObject","bool CommitChanges()"],["Rhino.Display.RhinoPageView","DetailViewObject AddDetailView(string title, Point2d corner0, Point2d corner1, DefinedViewportProjection initialProjection)"],["Rhino.Display.RhinoPageView","bool SetActiveDetail(Guid detailId)"],["Rhino.Display.RhinoPageView","void SetPageAsActive()"],["Rhino.Display.RhinoViewport","bool ZoomExtents()"],["Rhino.DocObjects.Tables.ViewTable","RhinoPageView AddPageView(string title, double pageWidth, double pageHeight)"],["Rhino.DocObjects.Tables.ViewTable","RhinoPageView[] GetPageViews()"]]},{"name":"Addline.vb","code":"Partial Class Examples\\n  Public Shared Function AddLine(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim gp As New Rhino.Input.Custom.GetPoint()\\n    gp.SetCommandPrompt(\\"Start of line\\")\\n    gp.Get()\\n    If gp.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return gp.CommandResult()\\n    End If\\n\\n    Dim pt_start As Rhino.Geometry.Point3d = gp.Point()\\n\\n    gp.SetCommandPrompt(\\"End of line\\")\\n    gp.SetBasePoint(pt_start, False)\\n    gp.DrawLineFromPoint(pt_start, True)\\n    gp.Get()\\n    If gp.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return gp.CommandResult()\\n    End If\\n\\n    Dim pt_end As Rhino.Geometry.Point3d = gp.Point()\\n    Dim v As Rhino.Geometry.Vector3d = pt_end - pt_start\\n    If v.IsTiny(Rhino.RhinoMath.ZeroTolerance) Then\\n      Return Rhino.Commands.Result.[Nothing]\\n    End If\\n\\n    If doc.Objects.AddLine(pt_start, pt_end) <> Guid.Empty Then\\n      doc.Views.Redraw()\\n      Return Rhino.Commands.Result.Success\\n    End If\\n    Return Rhino.Commands.Result.Failure\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Vector2d","bool IsTiny(double tolerance)"],["Rhino.Geometry.Vector3d","bool IsTiny(double tolerance)"],["Rhino.Input.Custom.GetBaseClass","Point3d Point()"],["Rhino.Input.Custom.GetBaseClass","void SetCommandPrompt(string prompt)"],["Rhino.Input.Custom.GetPoint","GetPoint()"],["Rhino.Input.Custom.GetPoint","void DrawLineFromPoint(Point3d startPoint, bool showDistanceInStatusBar)"],["Rhino.Input.Custom.GetPoint","GetResult Get()"],["Rhino.Input.Custom.GetPoint","void SetBasePoint(Point3d basePoint, bool showDistanceInStatusBar)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddLine(Point3d from, Point3d to)"]]},{"name":"Addlineardimension.vb","code":"Partial Class Examples\\n  Public Shared Function AddLinearDimension(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim dimension As Rhino.Geometry.LinearDimension = Nothing\\n    Dim rc As Rhino.Commands.Result = Rhino.Input.RhinoGet.GetLinearDimension(dimension)\\n    If rc = Rhino.Commands.Result.Success AndAlso dimension IsNot Nothing Then\\n      If doc.Objects.AddLinearDimension(dimension) = Guid.Empty Then\\n        rc = Rhino.Commands.Result.Failure\\n      Else\\n        doc.Views.Redraw()\\n      End If\\n    End If\\n    Return rc\\n  End Function\\nEnd Class\\n","members":[["Rhino.Input.RhinoGet","static Result GetLinearDimension(out LinearDimension dimension)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddLinearDimension(LinearDimension dimension)"]]},{"name":"Addlineardimension2.vb","code":"Imports Rhino.Geometry\\n\\nPartial Class Examples\\n  Public Shared Function AddLinearDimension2(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim origin As New Point3d(1, 1, 0)\\n    Dim offset As New Point3d(11, 1, 0)\\n    Dim pt As New Point3d((offset.X - origin.X) / 2, 3, 0)\\n\\n    Dim plane__1 As Plane = Plane.WorldXY\\n    plane__1.Origin = origin\\n\\n    Dim u As Double, v As Double\\n    plane__1.ClosestParameter(origin, u, v)\\n    Dim ext1 As New Point2d(u, v)\\n\\n    plane__1.ClosestParameter(offset, u, v)\\n    Dim ext2 As New Point2d(u, v)\\n\\n    plane__1.ClosestParameter(pt, u, v)\\n    Dim linePt As New Point2d(u, v)\\n\\n    Dim dimension As New LinearDimension(plane__1, ext1, ext2, linePt)\\n    If doc.Objects.AddLinearDimension(dimension) <> Guid.Empty Then\\n      doc.Views.Redraw()\\n      Return Rhino.Commands.Result.Success\\n    End If\\n    Return Rhino.Commands.Result.Failure\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.LinearDimension","LinearDimension(Plane dimensionPlane, Point2d extensionLine1End, Point2d extensionLine2End, Point2d pointOnDimensionLine)"],["Rhino.Geometry.Plane","bool ClosestParameter(Point3d testPoint, out double s, out double t)"]]},{"name":"Addmesh.vb","code":"Partial Class Examples\\n  Public Shared Function AddMesh(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim mesh As New Rhino.Geometry.Mesh()\\n    mesh.Vertices.Add(0.0, 0.0, 1.0) \'0\\n    mesh.Vertices.Add(1.0, 0.0, 1.0) \'1\\n    mesh.Vertices.Add(2.0, 0.0, 1.0) \'2\\n    mesh.Vertices.Add(3.0, 0.0, 0.0) \'3\\n    mesh.Vertices.Add(0.0, 1.0, 1.0) \'4\\n    mesh.Vertices.Add(1.0, 1.0, 2.0) \'5\\n    mesh.Vertices.Add(2.0, 1.0, 1.0) \'6\\n    mesh.Vertices.Add(3.0, 1.0, 0.0) \'7\\n    mesh.Vertices.Add(0.0, 2.0, 1.0) \'8\\n    mesh.Vertices.Add(1.0, 2.0, 1.0) \'9\\n    mesh.Vertices.Add(2.0, 2.0, 1.0) \'10\\n    mesh.Vertices.Add(3.0, 2.0, 1.0) \'11\\n    mesh.Faces.AddFace(0, 1, 5, 4)\\n    mesh.Faces.AddFace(1, 2, 6, 5)\\n    mesh.Faces.AddFace(2, 3, 7, 6)\\n    mesh.Faces.AddFace(4, 5, 9, 8)\\n    mesh.Faces.AddFace(5, 6, 10, 9)\\n    mesh.Faces.AddFace(6, 7, 11, 10)\\n    mesh.Normals.ComputeNormals()\\n    mesh.Compact()\\n    If doc.Objects.AddMesh(mesh) <> Guid.Empty Then\\n      doc.Views.Redraw()\\n      Return Rhino.Commands.Result.Success\\n    End If\\n    Return Rhino.Commands.Result.Failure\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Mesh","Mesh()"],["Rhino.Geometry.Mesh","MeshFaceList Faces"],["Rhino.Geometry.Mesh","MeshVertexNormalList Normals"],["Rhino.Geometry.Mesh","MeshVertexList Vertices"],["Rhino.Geometry.Mesh","bool Compact()"],["Rhino.Geometry.Collections.MeshVertexList","int Add(double x, double y, double z)"],["Rhino.Geometry.Collections.MeshVertexList","int Add(float x, float y, float z)"],["Rhino.Geometry.Collections.MeshVertexNormalList","bool ComputeNormals()"],["Rhino.Geometry.Collections.MeshFaceList","int AddFace(int vertex1, int vertex2, int vertex3, int vertex4)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddMesh(Mesh mesh)"]]},{"name":"Addnamedview.vb","code":"Partial Class Examples\\n  Public Shared Function AddNamedView(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim view As Rhino.Display.RhinoView = Nothing\\n    Dim rc As Rhino.Commands.Result = Rhino.Input.RhinoGet.GetView(\\"Select view to adjust\\", view)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    Dim location As Rhino.Geometry.Point3d\\n    rc = Rhino.Input.RhinoGet.GetPoint(\\"Camera Location\\", False, location)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    Dim gp As New Rhino.Input.Custom.GetPoint()\\n    gp.SetCommandPrompt(\\"Look At Location\\")\\n    gp.DrawLineFromPoint(location, False)\\n    gp.Get()\\n    If gp.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return gp.CommandResult()\\n    End If\\n    Dim lookat As Rhino.Geometry.Point3d = gp.Point()\\n\\n    Dim name As String = view.ActiveViewport.Name\\n    rc = Rhino.Input.RhinoGet.GetString(\\"Name\\", True, name)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    Dim vp As Rhino.Display.RhinoViewport = view.ActiveViewport\\n    \' save the current viewport projection\\n    vp.PushViewProjection()\\n    vp.CameraUp = Rhino.Geometry.Vector3d.ZAxis\\n    vp.SetCameraLocation(location, False)\\n    vp.SetCameraDirection(lookat - location, True)\\n    vp.Name = name\\n\\n    doc.NamedViews.Add(name, vp.Id)\\n    view.Redraw()\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.RhinoDoc","NamedViewTable NamedViews"],["Rhino.Display.RhinoViewport","Vector3d CameraUp"],["Rhino.Display.RhinoViewport","string Name"],["Rhino.Display.RhinoViewport","bool PopViewProjection()"],["Rhino.Display.RhinoViewport","void PushViewProjection()"],["Rhino.Display.RhinoViewport","void SetCameraDirection(Vector3d cameraDirection, bool updateTargetLocation)"],["Rhino.Display.RhinoViewport","void SetCameraLocation(Point3d cameraLocation, bool updateTargetLocation)"],["Rhino.Input.RhinoGet","static Result GetPoint(string prompt, bool acceptNothing, out Point3d point)"],["Rhino.Input.RhinoGet","static Result GetString(string prompt, bool acceptNothing, ref string outputString)"],["Rhino.Input.RhinoGet","static Result GetView(string commandPrompt, out RhinoView view)"],["Rhino.DocObjects.Tables.NamedViewTable","int Add(string name, Guid viewportId)"]]},{"name":"Addnurbscircle.vb","code":"Partial Class Examples\\n  Public Shared Function AddNurbsCircle(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    \' The easy way to get a NURBS curve from a circle is with\\n    \' the following two lines of code.\\n    \'\\n    \' Dim c As New Rhino.Geometry.Circle(20)\\n    \' Dim nc As Rhino.Geometry.NurbsCurve = c.ToNurbsCurve()\\n    \'\\n    \' This sample demonstrates creating a NURBS curve from scratch.\\n    Const dimension As Integer = 3\\n    Const isRational As Boolean = True\\n    Const order As Integer = 3\\n    Const cv_count As Integer = 9\\n    Dim nc As New Rhino.Geometry.NurbsCurve(dimension, isRational, order, cv_count)\\n    nc.Points.SetPoint(0, 1.0, 0.0, 0.0, 1.0)\\n    nc.Points.SetPoint(1, 0.707107, 0.707107, 0.0, 0.707107)\\n    nc.Points.SetPoint(2, 0.0, 1.0, 0.0, 1.0)\\n    nc.Points.SetPoint(3, -0.707107, 0.707107, 0.0, 0.707107)\\n    nc.Points.SetPoint(4, -1.0, 0.0, 0.0, 1.0)\\n    nc.Points.SetPoint(5, -0.707107, -0.707107, 0.0, 0.707107)\\n    nc.Points.SetPoint(6, 0.0, -1.0, 0.0, 1.0)\\n    nc.Points.SetPoint(7, 0.707107, -0.707107, 0.0, 0.707107)\\n    nc.Points.SetPoint(8, 1.0, 0.0, 0.0, 1.0)\\n    nc.Knots(0) = 0.0\\n    nc.Knots(1) = 0.0\\n    nc.Knots(2) = 0.5 * Math.PI\\n    nc.Knots(3) = 0.5 * Math.PI\\n    nc.Knots(4) = Math.PI\\n    nc.Knots(5) = Math.PI\\n    nc.Knots(6) = 1.5 * Math.PI\\n    nc.Knots(7) = 1.5 * Math.PI\\n    nc.Knots(8) = 2.0 * Math.PI\\n    nc.Knots(9) = 2.0 * Math.PI\\n    If nc.IsValid Then\\n      doc.Objects.AddCurve(nc)\\n      doc.Views.Redraw()\\n      Return Rhino.Commands.Result.Success\\n    End If\\n    Return Rhino.Commands.Result.Failure\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.NurbsCurve","NurbsCurve(int dimension, bool rational, int order, int pointCount)"],["Rhino.Geometry.NurbsCurve","NurbsCurveKnotList Knots"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddCurve(Curve curve)"]]},{"name":"Addnurbscurve.vb","code":"Partial Class Examples\\n  Public Shared Function AddNurbsCurve(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim points As New Rhino.Collections.Point3dList(5)\\n    points.Add(0, 0, 0)\\n    points.Add(0, 2, 0)\\n    points.Add(2, 3, 0)\\n    points.Add(4, 2, 0)\\n    points.Add(4, 0, 0)\\n    Dim nc As Rhino.Geometry.NurbsCurve = Rhino.Geometry.NurbsCurve.Create(False, 3, points)\\n    Dim rc As Rhino.Commands.Result = Rhino.Commands.Result.Failure\\n    If nc IsNot Nothing AndAlso nc.IsValid Then\\n      If doc.Objects.AddCurve(nc) <> Guid.Empty Then\\n        doc.Views.Redraw()\\n        rc = Rhino.Commands.Result.Success\\n      End If\\n    End If\\n    Return rc\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.NurbsCurve","static NurbsCurve Create(bool periodic, int degree, IEnumerable<Point3d> points)"],["Rhino.Collections.Point3dList","Point3dList(int initialCapacity)"],["Rhino.Collections.Point3dList","void Add(double x, double y, double z)"]]},{"name":"Addobjectstogroup.vb","code":"Imports System.Collections.Generic\\n\\nPartial Class Examples\\n  Public Shared Function AddObjectsToGroup(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim go As New Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt(\\"Select objects to group\\")\\n    go.GroupSelect = True\\n    go.GetMultiple(1, 0)\\n    If go.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return go.CommandResult()\\n    End If\\n\\n    Dim ids As New List(Of Guid)()\\n    For i As Integer = 0 To go.ObjectCount - 1\\n      ids.Add(go.[Object](i).ObjectId)\\n    Next\\n    Dim index As Integer = doc.Groups.Add(ids)\\n    doc.Views.Redraw()\\n    If index >= 0 Then\\n      Return Rhino.Commands.Result.Success\\n    End If\\n    Return Rhino.Commands.Result.Failure\\n  End Function\\nEnd Class\\n","members":[["Rhino.RhinoDoc","GroupTable Groups"],["Rhino.Input.Custom.GetObject","GetObject()"],["Rhino.Input.Custom.GetObject","GetResult GetMultiple(int minimumNumber, int maximumNumber)"],["Rhino.DocObjects.Tables.GroupTable","int Add(IEnumerable<Guid> objectIds)"]]},{"name":"Addradialdimension.vb","code":"Imports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.Commands\\nImports Rhino.Geometry\\nImports Rhino.Input\\n\\nNamespace examples_vb\\n  Public Class AddRadialDimensionCommand\\n    Inherits Rhino.Commands.Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbAddRadialDimension\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim obj_ref As ObjRef = Nothing\\n      Dim rc = RhinoGet.GetOneObject(\\"Select curve for radius dimension\\", True, ObjectType.Curve, obj_ref)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      Dim curve_parameter As Double\\n      Dim curve = obj_ref.CurveParameter(curve_parameter)\\n      If curve Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      If curve.IsLinear() OrElse curve.IsPolyline() Then\\n        RhinoApp.WriteLine(\\"Curve must be non-linear.\\")\\n        Return Result.[Nothing]\\n      End If\\n\\n      \' in this example just deal with planar curves\\n      If Not curve.IsPlanar() Then\\n        RhinoApp.WriteLine(\\"Curve must be planar.\\")\\n        Return Result.[Nothing]\\n      End If\\n\\n      Dim point_on_curve = curve.PointAt(curve_parameter)\\n      Dim curvature_vector = curve.CurvatureAt(curve_parameter)\\n      Dim len = curvature_vector.Length\\n      If len < RhinoMath.SqrtEpsilon Then\\n        RhinoApp.WriteLine(\\"Curve is almost linear and therefore has no curvature.\\")\\n        Return Result.[Nothing]\\n      End If\\n\\n      Dim center = point_on_curve + (curvature_vector / (len * len))\\n      Dim plane As Plane\\n      curve.TryGetPlane(plane)\\n      Dim radial_dimension = New RadialDimension(center, point_on_curve, plane.XAxis, plane.Normal, 5.0)\\n      doc.Objects.AddRadialDimension(radial_dimension)\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Curve","Vector3d CurvatureAt(double t)"],["Rhino.Geometry.Curve","bool IsLinear()"],["Rhino.Geometry.Curve","bool IsPlanar()"],["Rhino.Geometry.Curve","bool IsPolyline()"],["Rhino.Geometry.Curve","Point3d PointAt(double t)"],["Rhino.DocObjects.ObjRef","Curve CurveParameter(out double parameter)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddRadialDimension(RadialDimension dimension)"]]},{"name":"Addsphere.vb","code":"Partial Class Examples\\n  Public Shared Function AddSphere(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim center As New Rhino.Geometry.Point3d(0, 0, 0)\\n    Const radius As Double = 5.0\\n    Dim sphere As New Rhino.Geometry.Sphere(center, radius)\\n    If doc.Objects.AddSphere(sphere) <> Guid.Empty Then\\n      doc.Views.Redraw()\\n      Return Rhino.Commands.Result.Success\\n    End If\\n    Return Rhino.Commands.Result.Failure\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Sphere","Sphere(Point3d center, double radius)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddSphere(Sphere sphere)"]]},{"name":"Addtext.vb","code":"Partial Class Examples\\n  Public Shared Function AddAnnotationText(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim pt As New Rhino.Geometry.Point3d(10, 0, 0)\\n    Const text As String = \\"Hello RhinoCommon\\"\\n    Const height As Double = 2.0\\n    Const font As String = \\"Arial\\"\\n    Dim plane As Rhino.Geometry.Plane = doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\\n    plane.Origin = pt\\n    Dim id As Guid = doc.Objects.AddText(text, plane, height, font, False, False)\\n    If id <> Guid.Empty Then\\n      doc.Views.Redraw()\\n      Return Rhino.Commands.Result.Success\\n    End If\\n    Return Rhino.Commands.Result.Failure\\n  End Function\\nEnd Class\\n","members":[["Rhino.DocObjects.Tables.ObjectTable","Guid AddText(string text, Plane plane, double height, string fontName, bool bold, bool italic)"]]},{"name":"Addtorus.vb","code":"Partial Class Examples\\n  Public Shared Function AddTorus(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Const major_radius As Double = 4.0\\n    Const minor_radius As Double = 2.0\\n\\n    Dim plane As Rhino.Geometry.Plane = Rhino.Geometry.Plane.WorldXY\\n    Dim torus As New Rhino.Geometry.Torus(plane, major_radius, minor_radius)\\n    Dim revsrf As Rhino.Geometry.RevSurface = torus.ToRevSurface()\\n    If doc.Objects.AddSurface(revsrf) <> Guid.Empty Then\\n      doc.Views.Redraw()\\n      Return Rhino.Commands.Result.Success\\n    End If\\n    Return Rhino.Commands.Result.Failure\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Torus","Torus(Plane basePlane, double majorRadius, double minorRadius)"],["Rhino.Geometry.Torus","RevSurface ToRevSurface()"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddSurface(Surface surface)"]]},{"name":"Addtruncatedcone.vb","code":"Imports Rhino.Geometry\\n\\nPartial Class Examples\\n  Public Shared Function AddTruncatedCone(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim bottom_pt As New Point3d(0, 0, 0)\\n    Const bottom_radius As Double = 2\\n    Dim bottom_circle As New Circle(bottom_pt, bottom_radius)\\n\\n    Dim top_pt As New Point3d(0, 0, 10)\\n    Const top_radius As Double = 6\\n    Dim top_circle As New Circle(top_pt, top_radius)\\n\\n    Dim shapeCurve As New LineCurve(bottom_circle.PointAt(0), top_circle.PointAt(0))\\n    Dim axis As New Line(bottom_circle.Center, top_circle.Center)\\n    Dim revsrf As RevSurface = RevSurface.Create(shapeCurve, axis)\\n    Dim tcone_brep As Brep = Brep.CreateFromRevSurface(revsrf, True, True)\\n    If doc.Objects.AddBrep(tcone_brep) <> Guid.Empty Then\\n      doc.Views.Redraw()\\n      Return Rhino.Commands.Result.Success\\n    End If\\n    Return Rhino.Commands.Result.Failure\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Brep","static Brep CreateFromRevSurface(RevSurface surface, bool capStart, bool capEnd)"],["Rhino.Geometry.Circle","Circle(Point3d center, double radius)"],["Rhino.Geometry.LineCurve","LineCurve(Point3d from, Point3d to)"],["Rhino.Geometry.RevSurface","static RevSurface Create(Curve revoluteCurve, Line axisOfRevolution)"]]},{"name":"Advanceddisplay.vb","code":"Imports System.Collections.Generic\\nImports Rhino.Display\\n\\nPartial Class Examples\\n  \' The following example demonstrates how to modify advanced display settings using\\n  \' RhinoCommon. In this example, a display mode\'s mesh wireframe thickness (in pixels)\\n  \' will be modified.\\n  Public Shared Function AdvancedDisplay(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    \' Use the display attributes manager to build a list of display modes.\\n    \' Note, these are copies of the originals...\\n    Dim display_modes As DisplayModeDescription() = DisplayModeDescription.GetDisplayModes()\\n    If display_modes Is Nothing OrElse display_modes.Length < 1 Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    \' Construct an options picker so the user can pick which\\n    \' display mode they want modified\\n    Dim go As New Rhino.Input.Custom.GetOption()\\n    go.SetCommandPrompt(\\"Display mode to modify mesh thickness\\")\\n    Dim opt_list As New List(Of Integer)()\\n\\n    For i As Integer = 0 To display_modes.Length - 1\\n      Dim english_name As String = display_modes(i).EnglishName\\n      english_name = english_name.Replace(\\"_\\", \\"\\")\\n      english_name = english_name.Replace(\\" \\", \\"\\")\\n      english_name = english_name.Replace(\\"-\\", \\"\\")\\n      english_name = english_name.Replace(\\",\\", \\"\\")\\n      english_name = english_name.Replace(\\".\\", \\"\\")\\n      Dim index As Integer = go.AddOption(english_name)\\n      opt_list.Add(index)\\n    Next\\n\\n    \' Get the command option\\n    go.[Get]()\\n    If go.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return go.CommandResult()\\n    End If\\n\\n    Dim selected_index As Integer = go.[Option]().Index\\n    Dim selected_description As DisplayModeDescription = Nothing\\n    For i As Integer = 0 To opt_list.Count - 1\\n      If opt_list(i) = selected_index Then\\n        selected_description = display_modes(i)\\n        Exit For\\n      End If\\n    Next\\n\\n    \' Validate...\\n    If selected_description Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    \' Modify the desired display mode. In this case, we\\n    \' will just set the mesh wireframe thickness to zero.\\n    selected_description.DisplayAttributes.MeshSpecificAttributes.MeshWireThickness = 0\\n    \' Use the display attributes manager to update the display mode.\\n    DisplayModeDescription.UpdateDisplayMode(selected_description)\\n\\n    \' Force the document to regenerate.\\n    doc.Views.Redraw()\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Display.DisplayModeDescription","DisplayPipelineAttributes DisplayAttributes"],["Rhino.Display.DisplayModeDescription","static DisplayModeDescription[] GetDisplayModes()"],["Rhino.Display.DisplayModeDescription","static bool UpdateDisplayMode(DisplayModeDescription displayMode)"],["Rhino.Input.Custom.GetBaseClass","int AddOption(string englishOption)"]]},{"name":"Analysismode.vb","code":"Imports Rhino.DocObjects\\nImports Rhino\\nImports Rhino.Geometry\\n\\n\\n<System.Runtime.InteropServices.Guid(\\"62dd8eec-5cce-42c7-9d80-8b01fc169b81\\")> _\\nPublic Class AnalysisModeOnCommand\\n  Inherits Rhino.Commands.Command\\n  Public Overrides ReadOnly Property EnglishName() As String\\n    Get\\n      Return \\"cs_analysismode_on\\"\\n    End Get\\n  End Property\\n\\n  Protected Overrides Function RunCommand(doc As RhinoDoc, mode As Rhino.Commands.RunMode) As Rhino.Commands.Result\\n    \' make sure our custom visual analysis mode is registered\\n    Dim zmode = Rhino.Display.VisualAnalysisMode.Register(GetType(ZAnalysisMode))\\n\\n    Const filter As ObjectType = Rhino.DocObjects.ObjectType.Surface Or Rhino.DocObjects.ObjectType.PolysrfFilter Or Rhino.DocObjects.ObjectType.Mesh\\n    Dim objs As Rhino.DocObjects.ObjRef() = Nothing\\n    Dim rc = Rhino.Input.RhinoGet.GetMultipleObjects(\\"Select objects for Z analysis\\", False, filter, objs)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    Dim count As Integer = 0\\n    For i As Integer = 0 To objs.Length - 1\\n      Dim obj = objs(i).[Object]()\\n\\n      \' see if this object is alreay in Z analysis mode\\n      If obj.InVisualAnalysisMode(zmode) Then\\n        Continue For\\n      End If\\n\\n      If obj.EnableVisualAnalysisMode(zmode, True) Then\\n        count += 1\\n      End If\\n    Next\\n    doc.Views.Redraw()\\n    RhinoApp.WriteLine(\\"{0} objects were put into Z-Analysis mode.\\", count)\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n\\n<System.Runtime.InteropServices.Guid(\\"0A8CE87D-A8CB-4A41-9DE2-5B3957436AEE\\")> _\\nPublic Class AnalysisModeOffCommand\\n  Inherits Rhino.Commands.Command\\n  Public Overrides ReadOnly Property EnglishName() As String\\n    Get\\n      Return \\"cs_analysismode_off\\"\\n    End Get\\n  End Property\\n\\n  Protected Overrides Function RunCommand(doc As RhinoDoc, mode As Rhino.Commands.RunMode) As Rhino.Commands.Result\\n    Dim zmode = Rhino.Display.VisualAnalysisMode.Find(GetType(ZAnalysisMode))\\n    \' If zmode is null, we\'ve never registered the mode so we know it hasn\'t been used\\n    If zmode IsNot Nothing Then\\n      For Each obj As Rhino.DocObjects.RhinoObject In doc.Objects\\n        obj.EnableVisualAnalysisMode(zmode, False)\\n      Next\\n      doc.Views.Redraw()\\n    End If\\n    RhinoApp.WriteLine(\\"Z-Analysis is off.\\")\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n\\n\\n\'\'\' <summary>\\n\'\'\' This simple example provides a false color based on the world z-coordinate.\\n\'\'\' For details, see the implementation of the FalseColor() function.\\n\'\'\' </summary>\\nPublic Class ZAnalysisMode\\n  Inherits Rhino.Display.VisualAnalysisMode\\n  Private m_z_range As New Interval(-10, 10)\\n  Private m_hue_range As New Interval(0, 4 * Math.PI / 3)\\n  Private Const m_show_isocurves As Boolean = True\\n\\n  Public Overrides ReadOnly Property Name() As String\\n    Get\\n      Return \\"Z-Analysis\\"\\n    End Get\\n  End Property\\n  Public Overrides ReadOnly Property Style() As Rhino.Display.VisualAnalysisMode.AnalysisStyle\\n    Get\\n      Return AnalysisStyle.FalseColor\\n    End Get\\n  End Property\\n\\n  Public Overrides Function ObjectSupportsAnalysisMode(obj As Rhino.DocObjects.RhinoObject) As Boolean\\n    If TypeOf obj Is Rhino.DocObjects.MeshObject OrElse TypeOf obj Is Rhino.DocObjects.BrepObject Then\\n      Return True\\n    End If\\n    Return False\\n  End Function\\n\\n  Protected Overrides Sub UpdateVertexColors(obj As Rhino.DocObjects.RhinoObject, meshes As Mesh())\\n    \' A \\"mapping tag\\" is used to determine if the colors need to be set\\n    Dim mt As Rhino.Render.MappingTag = GetMappingTag(obj.RuntimeSerialNumber)\\n\\n    For mi As Integer = 0 To meshes.Length - 1\\n      Dim mesh = meshes(mi)\\n      If mesh.VertexColors.Tag.Id <> Me.Id Then\\n        \' The mesh\'s mapping tag is different from ours. Either the mesh has\\n        \' no false colors, has false colors set by another analysis mode, has\\n        \' false colors set using different m_z_range[]/m_hue_range[] values, or\\n        \' the mesh has been moved.  In any case, we need to set the false\\n        \' colors to the ones we want.\\n        Dim colors As System.Drawing.Color() = New System.Drawing.Color(mesh.Vertices.Count - 1) {}\\n        For i As Integer = 0 To mesh.Vertices.Count - 1\\n          Dim z As Double = mesh.Vertices(i).Z\\n          colors(i) = FalseColor(z)\\n        Next\\n        mesh.VertexColors.SetColors(colors)\\n        \' set the mesh\'s color tag \\n        mesh.VertexColors.Tag = mt\\n      End If\\n    Next\\n  End Sub\\n\\n  Public Overrides ReadOnly Property ShowIsoCurves() As Boolean\\n    Get\\n      \' Most shaded analysis modes that work on breps have the option of\\n      \' showing or hiding isocurves.  Run the built-in Rhino ZebraAnalysis\\n      \' to see how Rhino handles the user interface.  If controlling\\n      \' iso-curve visability is a feature you want to support, then provide\\n      \' user interface to set this member variable.\\n      Return m_show_isocurves\\n    End Get\\n  End Property\\n\\n  \'\'\' <summary>\\n  \'\'\' Returns a mapping tag that is used to detect when a mesh\'s colors need to\\n  \'\'\' be set.\\n  \'\'\' </summary>\\n  \'\'\' <returns></returns>\\n  Private Function GetMappingTag(serialNumber As UInteger) As Rhino.Render.MappingTag\\n    Dim mt As New Rhino.Render.MappingTag()\\n    mt.Id = Me.Id\\n\\n    \' Since the false colors that are shown will change if the mesh is\\n    \' transformed, we have to initialize the transformation.\\n    mt.MeshTransform = Transform.Identity\\n\\n    \' This is a 32 bit CRC or the information used to set the false colors.\\n    \' For this example, the m_z_range and m_hue_range intervals control the\\n    \' colors, so we calculate their crc.\\n    Dim crc As UInteger = RhinoMath.CRC32(serialNumber, m_z_range.T0)\\n    crc = RhinoMath.CRC32(crc, m_z_range.T1)\\n    crc = RhinoMath.CRC32(crc, m_hue_range.T0)\\n    crc = RhinoMath.CRC32(crc, m_hue_range.T1)\\n    mt.MappingCRC = crc\\n    Return mt\\n  End Function\\n\\n  Private Function FalseColor(z As Double) As System.Drawing.Color\\n    \' Simple example of one way to change a number into a color.\\n    Dim s As Double = m_z_range.NormalizedParameterAt(z)\\n    s = Rhino.RhinoMath.Clamp(s, 0, 1)\\n    Return System.Drawing.Color.FromArgb(CInt(Math.Truncate(s * 255)), 0, 0)\\n  End Function\\nEnd Class\\n","members":[["Rhino.RhinoMath","static uint CRC32(uint currentRemainder, double value)"],["Rhino.Geometry.Collections.MeshVertexColorList","MappingTag Tag"],["Rhino.Geometry.Collections.MeshVertexColorList","bool SetColors(Color[] colors)"]]},{"name":"Arclengthpoint.vb","code":"Partial Class Examples\\n  Public Shared Function ArcLengthPoint(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim objref As Rhino.DocObjects.ObjRef = Nothing\\n    Dim rc As Rhino.Commands.Result = Rhino.Input.RhinoGet.GetOneObject(\\"Select curve\\", True, Rhino.DocObjects.ObjectType.Curve, objref)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n    Dim crv As Rhino.Geometry.Curve = objref.Curve()\\n    If crv Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    Dim crv_length As Double = crv.GetLength()\\n    Dim length As Double = 0\\n    rc = Rhino.Input.RhinoGet.GetNumber(\\"Length from start\\", True, length, 0, crv_length)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    Dim pt As Rhino.Geometry.Point3d = crv.PointAtLength(length)\\n    If pt.IsValid Then\\n      doc.Objects.AddPoint(pt)\\n      doc.Views.Redraw()\\n    End If\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Curve","double GetLength()"],["Rhino.Geometry.Curve","Point3d PointAtLength(double length)"]]},{"name":"Arraybydistance.vb","code":"Imports Rhino\\n\\n<System.Runtime.InteropServices.Guid(\\"03249FBF-75C9-4878-83CC-20C197E5A758\\")> _\\nPublic Class ArrayByDistanceCommand\\n  Inherits Rhino.Commands.Command\\n  Public Overrides ReadOnly Property EnglishName() As String\\n    Get\\n      Return \\"vb_ArrayByDistance\\"\\n    End Get\\n  End Property\\n\\n  Private m_distance As Double = 1\\n  Private m_point_start As Rhino.Geometry.Point3d\\n  Protected Overrides Function RunCommand(doc As RhinoDoc, mode As Rhino.Commands.RunMode) As Rhino.Commands.Result\\n    Dim objref As Rhino.DocObjects.ObjRef = Nothing\\n    Dim rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select object\\", True, Rhino.DocObjects.ObjectType.AnyObject, objref)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    rc = Rhino.Input.RhinoGet.GetPoint(\\"Start point\\", False, m_point_start)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    Dim obj = objref.Object()\\n    If obj Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    \' create an instance of a GetPoint class and add a delegate\\n    \' for the DynamicDraw event\\n    Dim gp = New Rhino.Input.Custom.GetPoint()\\n    gp.DrawLineFromPoint(m_point_start, True)\\n    Dim optdouble = New Rhino.Input.Custom.OptionDouble(m_distance)\\n    Dim constrain As Boolean = False\\n    Dim optconstrain = New Rhino.Input.Custom.OptionToggle(constrain, \\"Off\\", \\"On\\")\\n    gp.AddOptionDouble(\\"Distance\\", optdouble)\\n    gp.AddOptionToggle(\\"Constrain\\", optconstrain)\\n    AddHandler gp.DynamicDraw, AddressOf ArrayByDistanceDraw\\n    gp.Tag = obj\\n    While gp.Get() = Rhino.Input.GetResult.Option\\n      m_distance = optdouble.CurrentValue\\n      If constrain <> optconstrain.CurrentValue Then\\n        constrain = optconstrain.CurrentValue\\n        If constrain Then\\n          Dim gp2 = New Rhino.Input.Custom.GetPoint()\\n          gp2.DrawLineFromPoint(m_point_start, True)\\n          gp2.SetCommandPrompt(\\"Second point on constraint line\\")\\n          If gp2.Get() = Rhino.Input.GetResult.Point Then\\n            gp.Constrain(m_point_start, gp2.Point())\\n          Else\\n            gp.ClearCommandOptions()\\n            optconstrain.CurrentValue = False\\n            constrain = False\\n            gp.AddOptionDouble(\\"Distance\\", optdouble)\\n            gp.AddOptionToggle(\\"Constrain\\", optconstrain)\\n          End If\\n        Else\\n          gp.ClearConstraints()\\n        End If\\n      End If\\n    End While\\n\\n    If gp.CommandResult() = Rhino.Commands.Result.Success Then\\n      m_distance = optdouble.CurrentValue\\n      Dim pt = gp.Point()\\n      Dim vec = pt - m_point_start\\n      Dim length As Double = vec.Length\\n      vec.Unitize()\\n      Dim count As Integer = CInt(Math.Truncate(length / m_distance))\\n      For i As Integer = 1 To count - 1\\n        Dim translate = vec * (i * m_distance)\\n        Dim xf = Rhino.Geometry.Transform.Translation(translate)\\n        doc.Objects.Transform(obj, xf, False)\\n      Next\\n      doc.Views.Redraw()\\n    End If\\n\\n    Return gp.CommandResult()\\n  End Function\\n\\n  \' this function is called whenever the GetPoint\'s DynamicDraw\\n  \' event occurs\\n  Private Sub ArrayByDistanceDraw(sender As Object, e As Rhino.Input.Custom.GetPointDrawEventArgs)\\n    Dim rhobj As Rhino.DocObjects.RhinoObject = TryCast(e.Source.Tag, Rhino.DocObjects.RhinoObject)\\n    If rhobj Is Nothing Then\\n      Return\\n    End If\\n    Dim vec = e.CurrentPoint - m_point_start\\n    Dim length As Double = vec.Length\\n    vec.Unitize()\\n    Dim count As Integer = CInt(Math.Truncate(length / m_distance))\\n    For i As Integer = 1 To count - 1\\n      Dim translate = vec * (i * m_distance)\\n      Dim xf = Rhino.Geometry.Transform.Translation(translate)\\n      e.Display.DrawObject(rhobj, xf)\\n    Next\\n  End Sub\\nEnd Class\\n","members":[["Rhino.Display.DisplayPipeline","void DrawObject(RhinoObject rhinoObject, Transform xform)"],["Rhino.Input.Custom.GetBaseClass","void ClearCommandOptions()"],["Rhino.Input.Custom.GetPoint","object Tag"],["Rhino.Input.Custom.GetPoint","void ClearConstraints()"],["Rhino.Input.Custom.GetPoint","bool Constrain(Point3d from, Point3d to)"],["Rhino.Input.Custom.GetPointDrawEventArgs","GetPoint Source"]]},{"name":"Blockinsertionpoint.vb","code":"Partial Class Examples\\n  Public Shared Function BlockInsertionPoint(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim rc As Rhino.Commands.Result\\n    Dim objref As Rhino.DocObjects.ObjRef = Nothing\\n    rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select instance\\", True, Rhino.DocObjects.ObjectType.InstanceReference, objref)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n    Dim instance As Rhino.DocObjects.InstanceObject = TryCast(objref.[Object](), Rhino.DocObjects.InstanceObject)\\n    If instance IsNot Nothing Then\\n      Dim pt As Rhino.Geometry.Point3d = instance.InsertionPoint\\n      doc.Objects.AddPoint(pt)\\n      doc.Views.Redraw()\\n    End If\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.DocObjects.InstanceObject","Point3d InsertionPoint"]]},{"name":"Booleandifference.vb","code":"Imports System.Collections.Generic\\n\\nPartial Class Examples\\n  Public Shared Function BooleanDifference(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim rc As Rhino.Commands.Result\\n    Dim objrefs As Rhino.DocObjects.ObjRef() = Nothing\\n    rc = Rhino.Input.RhinoGet.GetMultipleObjects(\\"Select first set of polysurfaces\\", False, Rhino.DocObjects.ObjectType.PolysrfFilter, objrefs)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n    If objrefs Is Nothing OrElse objrefs.Length < 1 Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    Dim in_breps0 As New List(Of Rhino.Geometry.Brep)()\\n    For i As Integer = 0 To objrefs.Length - 1\\n      Dim brep As Rhino.Geometry.Brep = objrefs(i).Brep()\\n      If brep IsNot Nothing Then\\n        in_breps0.Add(brep)\\n      End If\\n    Next\\n\\n    doc.Objects.UnselectAll()\\n    rc = Rhino.Input.RhinoGet.GetMultipleObjects(\\"Select second set of polysurfaces\\", False, Rhino.DocObjects.ObjectType.PolysrfFilter, objrefs)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n    If objrefs Is Nothing OrElse objrefs.Length < 1 Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    Dim in_breps1 As New List(Of Rhino.Geometry.Brep)()\\n    For i As Integer = 0 To objrefs.Length - 1\\n      Dim brep As Rhino.Geometry.Brep = objrefs(i).Brep()\\n      If brep IsNot Nothing Then\\n        in_breps1.Add(brep)\\n      End If\\n    Next\\n\\n    Dim tolerance As Double = doc.ModelAbsoluteTolerance\\n    Dim breps As Rhino.Geometry.Brep() = Rhino.Geometry.Brep.CreateBooleanDifference(in_breps0, in_breps1, tolerance)\\n    If breps.Length < 1 Then\\n      Return Rhino.Commands.Result.[Nothing]\\n    End If\\n    For i As Integer = 0 To breps.Length - 1\\n      doc.Objects.AddBrep(breps(i))\\n    Next\\n    doc.Views.Redraw()\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Brep","static Brep[] CreateBooleanDifference(IEnumerable<Brep> firstSet, IEnumerable<Brep> secondSet, double tolerance)"],["Rhino.Geometry.Brep","static Brep[] CreateBooleanDifference(IEnumerable<Brep> firstSet, IEnumerable<Brep> secondSet, double tolerance, bool manifoldOnly)"],["Rhino.DocObjects.ObjRef","Brep Brep()"],["Rhino.Input.RhinoGet","static Result GetMultipleObjects(string prompt, bool acceptNothing, ObjectType filter, out ObjRef[] rhObjects)"]]},{"name":"Circlecenter.vb","code":"Partial Class Examples\\n  Public Shared Function CircleCenter(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim go As New Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt(\\"Select objects\\")\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\\n    go.GeometryAttributeFilter = Rhino.Input.[Custom].GeometryAttributeFilter.ClosedCurve\\n    go.GetMultiple(1, 0)\\n    If go.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return go.CommandResult()\\n    End If\\n\\n    Dim objrefs As Rhino.DocObjects.ObjRef() = go.Objects()\\n    If objrefs Is Nothing Then\\n      Return Rhino.Commands.Result.[Nothing]\\n    End If\\n\\n    Dim tolerance As Double = doc.ModelAbsoluteTolerance\\n    For i As Integer = 0 To objrefs.Length - 1\\n      \' get the curve geometry\\n      Dim curve As Rhino.Geometry.Curve = objrefs(i).Curve()\\n      If curve Is Nothing Then\\n        Continue For\\n      End If\\n      Dim circle As Rhino.Geometry.Circle\\n      If curve.TryGetCircle(circle, tolerance) Then\\n        Rhino.RhinoApp.WriteLine(\\"Circle{0}: center = {1}\\", i + 1, circle.Center)\\n      End If\\n    Next\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Curve","bool TryGetCircle(out Circle circle, double tolerance)"],["Rhino.Input.Custom.GetObject","GeometryAttributeFilter GeometryAttributeFilter"]]},{"name":"Closestpoint.vb","code":"Imports Rhino\\nImports Rhino.Geometry\\n\\nNamespace examples_vb\\n  <System.Runtime.InteropServices.Guid(\\"B89D4A42-A712-4FA4-9ABF-6BE1FB962D24\\")> _\\n  Public Class RTreeClosestPoint\\n    Inherits Rhino.Commands.Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vb_RtreeClosestPoint\\"\\n      End Get\\n    End Property\\n\\n    Private Sub SearchCallback(sender As Object, e As RTreeEventArgs)\\n      Dim data As SearchData = TryCast(e.Tag, SearchData)\\n      data.HitCount = data.HitCount + 1\\n      Dim vertex As Point3f = data.Mesh.Vertices(e.Id)\\n      Dim distance As Double = data.Point.DistanceTo(vertex)\\n      If data.Index = -1 OrElse data.Distance > distance Then\\n        \' shrink the sphere to help improve the test\\n        e.SearchSphere = New Sphere(data.Point, distance)\\n        data.Index = e.Id\\n        data.Distance = distance\\n      End If\\n    End Sub\\n\\n    Private Class SearchData\\n      Public Sub New(mesh__1 As Mesh, point__2 As Point3d)\\n        Point = point__2\\n        Mesh = mesh__1\\n        HitCount = 0\\n        Index = -1\\n        Distance = 0\\n      End Sub\\n\\n      Public Property HitCount As Integer\\n      Public Property Point As Point3d\\n      Public Property Mesh As Mesh\\n      Public Property Index As Integer\\n      Public Property Distance As Double\\n    End Class\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As Rhino.Commands.RunMode) As Rhino.Commands.Result\\n      Dim objref As Rhino.DocObjects.ObjRef = Nothing\\n      Dim rc = Rhino.Input.RhinoGet.GetOneObject(\\"select mesh\\", False, Rhino.DocObjects.ObjectType.Mesh, objref)\\n      If rc <> Rhino.Commands.Result.Success Then\\n        Return rc\\n      End If\\n\\n      Dim mesh As Mesh = objref.Mesh()\\n      objref.Object().Select(False)\\n      doc.Views.Redraw()\\n\\n      Using tree As New RTree()\\n        For i As Integer = 0 To mesh.Vertices.Count - 1\\n          \' we can make a C++ function that just builds an rtree from the\\n          \' vertices in one quick shot, but for now...\\n          tree.Insert(mesh.Vertices(i), i)\\n        Next\\n\\n        Dim point As Point3d\\n        While True\\n          rc = Rhino.Input.RhinoGet.GetPoint(\\"test point\\", False, point)\\n          If rc <> Rhino.Commands.Result.Success Then\\n            Exit While\\n          End If\\n\\n          Dim data As New SearchData(mesh, point)\\n          \' Use the first vertex in the mesh to define a start sphere\\n          Dim distance As Double = point.DistanceTo(mesh.Vertices(0))\\n          Dim sphere As New Sphere(point, distance * 1.1)\\n          If tree.Search(sphere, AddressOf SearchCallback, data) Then\\n            doc.Objects.AddPoint(mesh.Vertices(data.Index))\\n            doc.Views.Redraw()\\n            RhinoApp.WriteLine(\\"Found point in {0} tests\\", data.HitCount)\\n          End If\\n        End While\\n      End Using\\n      Return Rhino.Commands.Result.Success\\n    End Function\\n  End Class\\nEnd Namespace\\n","members":[["Rhino.Geometry.RTree","RTree()"],["Rhino.Geometry.RTree","bool Insert(Point3d point, int elementId)"],["Rhino.Geometry.RTree","bool Search(Sphere sphere, EventHandler<RTreeEventArgs> callback, object tag)"]]},{"name":"Commandlineoptions.vb","code":"Partial Class Examples\\n  Public Shared Function CommandLineOptions(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    \' For this example we will use a GetPoint class, but all of the custom\\n    \' \\"Get\\" classes support command line options.\\n    Dim gp As New Rhino.Input.Custom.GetPoint()\\n    gp.SetCommandPrompt(\\"GetPoint with options\\")\\n\\n    \' set up the options\\n    Dim intOption As New Rhino.Input.Custom.OptionInteger(1, 1, 99)\\n    Dim dblOption As New Rhino.Input.Custom.OptionDouble(2.2, 0, 99.9)\\n    Dim boolOption As New Rhino.Input.Custom.OptionToggle(True, \\"Off\\", \\"On\\")\\n    Dim listValues As String() = New String() {\\"Item0\\", \\"Item1\\", \\"Item2\\", \\"Item3\\", \\"Item4\\"}\\n\\n    gp.AddOptionInteger(\\"Integer\\", intOption)\\n    gp.AddOptionDouble(\\"Double\\", dblOption)\\n    gp.AddOptionToggle(\\"Boolean\\", boolOption)\\n    Dim listIndex As Integer = 3\\n    Dim opList As Integer = gp.AddOptionList(\\"List\\", listValues, listIndex)\\n\\n    While True\\n      \' perform the get operation. This will prompt the user to input a point, but also\\n      \' allow for command line options defined above\\n      Dim get_rc As Rhino.Input.GetResult = gp.[Get]()\\n      If gp.CommandResult() <> Rhino.Commands.Result.Success Then\\n        Return gp.CommandResult()\\n      End If\\n\\n      If get_rc = Rhino.Input.GetResult.Point Then\\n        doc.Objects.AddPoint(gp.Point())\\n        doc.Views.Redraw()\\n        Rhino.RhinoApp.WriteLine(\\"Command line option values are\\")\\n        Rhino.RhinoApp.WriteLine(\\" Integer = {0}\\", intOption.CurrentValue)\\n        Rhino.RhinoApp.WriteLine(\\" Double = {0}\\", dblOption.CurrentValue)\\n        Rhino.RhinoApp.WriteLine(\\" Boolean = {0}\\", boolOption.CurrentValue)\\n        Rhino.RhinoApp.WriteLine(\\" List = {0}\\", listValues(listIndex))\\n      ElseIf get_rc = Rhino.Input.GetResult.[Option] Then\\n        If gp.OptionIndex() = opList Then\\n          listIndex = gp.[Option]().CurrentListOptionIndex\\n        End If\\n        Continue While\\n      End If\\n      Exit While\\n    End While\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Input.Custom.GetBaseClass","int AddOptionDouble(LocalizeStringPair optionName, ref OptionDouble numberValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionDouble(string englishName, ref OptionDouble numberValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionInteger(LocalizeStringPair optionName, ref OptionInteger intValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionInteger(string englishName, ref OptionInteger intValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionToggle(LocalizeStringPair optionName, ref OptionToggle toggleValue)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionToggle(string englishName, ref OptionToggle toggleValue)"],["Rhino.Input.Custom.CommandLineOption","int CurrentListOptionIndex"],["Rhino.Input.Custom.OptionToggle","OptionToggle(bool initialValue, string offValue, string onValue)"],["Rhino.Input.Custom.OptionToggle","bool CurrentValue"],["Rhino.Input.Custom.OptionDouble","OptionDouble(double initialValue, double lowerLimit, double upperLimit)"],["Rhino.Input.Custom.OptionDouble","double CurrentValue"],["Rhino.Input.Custom.OptionInteger","OptionInteger(int initialValue, int lowerLimit, int upperLimit)"],["Rhino.Input.Custom.OptionInteger","int CurrentValue"]]},{"name":"Conduitarrowheads.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.Geometry\\nImports System.Collections.Generic\\nImports Rhino.Input.Custom\\n\\nNamespace examples_vb\\n  Class DrawArrowHeadsConduit\\n    Inherits Rhino.Display.DisplayConduit\\n    Private _line As Line\\n    Private _screenSize As Integer\\n    Private _worldSize As Double\\n\\n    Public Sub New(line As Line, screenSize As Integer, worldSize As Double)\\n      _line = line\\n      _screenSize = screenSize\\n      _worldSize = worldSize\\n    End Sub\\n\\n    Protected Overrides Sub DrawForeground(e As Rhino.Display.DrawEventArgs)\\n      e.Display.DrawArrow(_line, System.Drawing.Color.Black, _screenSize, _worldSize)\\n    End Sub\\n  End Class\\n\\n  Public Class DrawArrowheadsCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbDrawArrowHeads\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      \' get arrow head size\\n      Dim go = New Rhino.Input.Custom.GetOption()\\n      go.SetCommandPrompt(\\"ArrowHead length in screen size (pixles) or world size (percentage of arrow lenght)?\\")\\n      go.AddOption(\\"screen\\")\\n      go.AddOption(\\"world\\")\\n      go.[Get]()\\n      If go.CommandResult() <> Result.Success Then\\n        Return go.CommandResult()\\n      End If\\n\\n      Dim screenSize As Integer = 0\\n      Dim worldSize As Double = 0.0\\n      If go.[Option]().EnglishName = \\"screen\\" Then\\n        Dim gi = New Rhino.Input.Custom.GetInteger()\\n        gi.SetLowerLimit(0, True)\\n        gi.SetCommandPrompt(\\"Length of arrow head in pixels\\")\\n        gi.[Get]()\\n        If gi.CommandResult() <> Result.Success Then\\n          Return gi.CommandResult()\\n        End If\\n        screenSize = gi.Number()\\n      Else\\n        Dim gi = New Rhino.Input.Custom.GetInteger()\\n        gi.SetLowerLimit(0, True)\\n        gi.SetUpperLimit(100, False)\\n        gi.SetCommandPrompt(\\"Lenght of arrow head in percentage of total arrow lenght\\")\\n        gi.[Get]()\\n        If gi.CommandResult() <> Result.Success Then\\n          Return gi.CommandResult()\\n        End If\\n        worldSize = gi.Number() / 100.0\\n      End If\\n\\n\\n      \' get arrow start and end points\\n      Dim gp = New Rhino.Input.Custom.GetPoint()\\n      gp.SetCommandPrompt(\\"Start of line\\")\\n      gp.[Get]()\\n      If gp.CommandResult() <> Result.Success Then\\n        Return gp.CommandResult()\\n      End If\\n      Dim startPoint = gp.Point()\\n\\n      gp.SetCommandPrompt(\\"End of line\\")\\n      gp.SetBasePoint(startPoint, False)\\n      gp.DrawLineFromPoint(startPoint, True)\\n      gp.[Get]()\\n      If gp.CommandResult() <> Result.Success Then\\n        Return gp.CommandResult()\\n      End If\\n      Dim endPoint = gp.Point()\\n\\n      Dim v = endPoint - startPoint\\n      If v.IsTiny(Rhino.RhinoMath.ZeroTolerance) Then\\n        Return Result.[Nothing]\\n      End If\\n\\n      Dim line = New Line(startPoint, endPoint)\\n\\n      Dim conduit = New DrawArrowHeadsConduit(line, screenSize, worldSize)\\n      \' toggle conduit on/off\\n      conduit.Enabled = Not conduit.Enabled\\n      RhinoApp.WriteLine(\\"draw arrowheads conduit enabled = {0}\\", conduit.Enabled)\\n\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Display.DisplayPipeline","void DrawArrow(Line line, Color color, double screenSize, double relativeSize)"]]},{"name":"Conduitbitmap.vb","code":"Imports System.Drawing\\nImports Rhino\\nImports Rhino.Commands\\nImports Rhino.Display\\n\\nNamespace examples_vb\\n  Public Class DrawBitmapConduit\\n    Inherits Rhino.Display.DisplayConduit\\n    Private ReadOnly m_display_bitmap As DisplayBitmap\\n\\n    Public Sub New()\\n      Dim flag = New System.Drawing.Bitmap(100, 100)\\n      For x As Integer = 0 To flag.Height - 1\\n        For y As Integer = 0 To flag.Width - 1\\n          flag.SetPixel(x, y, Color.White)\\n        Next\\n      Next\\n\\n      Dim g = Graphics.FromImage(flag)\\n      g.FillEllipse(Brushes.Blue, 25, 25, 50, 50)\\n      m_display_bitmap = New DisplayBitmap(flag)\\n    End Sub\\n\\n    Protected Overrides Sub DrawForeground(e As Rhino.Display.DrawEventArgs)\\n      e.Display.DrawBitmap(m_display_bitmap, 50, 50, Color.White)\\n    End Sub\\n  End Class\\n\\n  Public Class DrawBitmapCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbDrawBitmap\\"\\n      End Get\\n    End Property\\n\\n    ReadOnly m_conduit As New DrawBitmapConduit()\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      \' toggle conduit on/off\\n      m_conduit.Enabled = Not m_conduit.Enabled\\n\\n      RhinoApp.WriteLine(\\"Custom conduit enabled = {0}\\", m_conduit.Enabled)\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Display.DisplayPipeline","void DrawBitmap(DisplayBitmap bitmap, int left, int top)"]]},{"name":"Constrainedcopy.vb","code":"Partial Class Examples\\n  Public Shared Function ConstrainedCopy(doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    \' Get a single planar closed curve\\n    Dim go = New Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt(\\"Select curve\\")\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\\n    go.GeometryAttributeFilter = Rhino.Input.Custom.GeometryAttributeFilter.ClosedCurve\\n    go.Get()\\n    If go.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return go.CommandResult()\\n    End If\\n    Dim objref = go.Object(0)\\n    Dim base_curve = objref.Curve()\\n    Dim first_point = objref.SelectionPoint()\\n    If base_curve Is Nothing OrElse Not first_point.IsValid Then\\n      Return Rhino.Commands.Result.Cancel\\n    End If\\n\\n    Dim plane As Rhino.Geometry.Plane\\n    If Not base_curve.TryGetPlane(plane) Then\\n      Return Rhino.Commands.Result.Cancel\\n    End If\\n\\n    \' Get a point constrained to a line passing through the initial selection\\n    \' point and parallel to the plane\'s normal\\n    Dim gp = New Rhino.Input.Custom.GetPoint()\\n    gp.SetCommandPrompt(\\"Offset point\\")\\n    gp.DrawLineFromPoint(first_point, True)\\n    Dim line = New Rhino.Geometry.Line(first_point, first_point + plane.Normal)\\n    gp.Constrain(line)\\n    gp.Get()\\n    If gp.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return gp.CommandResult()\\n    End If\\n    Dim second_point = gp.Point()\\n    Dim vec As Rhino.Geometry.Vector3d = second_point - first_point\\n    If vec.Length > 0.001 Then\\n      Dim xf = Rhino.Geometry.Transform.Translation(vec)\\n      Dim id As Guid = doc.Objects.Transform(objref, xf, False)\\n      If id <> Guid.Empty Then\\n        doc.Views.Redraw()\\n        Return Rhino.Commands.Result.Success\\n      End If\\n    End If\\n    Return Rhino.Commands.Result.Cancel\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Curve","bool TryGetPlane(out Plane plane)"],["Rhino.Geometry.Transform","static Transform Translation(Vector3d motion)"],["Rhino.DocObjects.ObjRef","Point3d SelectionPoint()"],["Rhino.Input.Custom.GetPoint","bool Constrain(Line line)"]]},{"name":"Createblock.vb","code":"Imports Rhino.DocObjects\\n\\nPartial Class Examples\\n  Public Shared Function CreateBlock(doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    \' Select objects to define block\\n    Dim go = New Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt(\\"Select objects to define block\\")\\n    go.ReferenceObjectSelect = False\\n    go.SubObjectSelect = False\\n    go.GroupSelect = True\\n\\n    \' Phantoms, grips, lights, etc., cannot be in blocks.\\n    Const forbidden_geometry_filter As ObjectType = Rhino.DocObjects.ObjectType.Light Or Rhino.DocObjects.ObjectType.Grip Or Rhino.DocObjects.ObjectType.Phantom\\n    Const geometry_filter As ObjectType = forbidden_geometry_filter Xor Rhino.DocObjects.ObjectType.AnyObject\\n    go.GeometryFilter = geometry_filter\\n    go.GetMultiple(1, 0)\\n    If go.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return go.CommandResult()\\n    End If\\n\\n    \' Block base point\\n    Dim base_point As Rhino.Geometry.Point3d\\n    Dim rc = Rhino.Input.RhinoGet.GetPoint(\\"Block base point\\", False, base_point)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    \' Block definition name\\n    Dim idef_name As String = \\"\\"\\n    rc = Rhino.Input.RhinoGet.GetString(\\"Block definition name\\", False, idef_name)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n    \' Validate block name\\n    idef_name = idef_name.Trim()\\n    If String.IsNullOrEmpty(idef_name) Then\\n      Return Rhino.Commands.Result.[Nothing]\\n    End If\\n\\n    \' See if block name already exists\\n    Dim existing_idef As Rhino.DocObjects.InstanceDefinition = doc.InstanceDefinitions.Find(idef_name, True)\\n    If existing_idef IsNot Nothing Then\\n      Rhino.RhinoApp.WriteLine(\\"Block definition {0} already exists\\", idef_name)\\n      Return Rhino.Commands.Result.[Nothing]\\n    End If\\n\\n    \' Gather all of the selected objects\\n    Dim geometry = New System.Collections.Generic.List(Of Rhino.Geometry.GeometryBase)()\\n    Dim attributes = New System.Collections.Generic.List(Of Rhino.DocObjects.ObjectAttributes)()\\n    For i As Integer = 0 To go.ObjectCount - 1\\n      Dim rhinoObject = go.Object(i).[Object]()\\n      If rhinoObject IsNot Nothing Then\\n        geometry.Add(rhinoObject.Geometry)\\n        attributes.Add(rhinoObject.Attributes)\\n      End If\\n    Next\\n\\n    \' Gather all of the selected objects\\n    Dim idef_index As Integer = doc.InstanceDefinitions.Add(idef_name, String.Empty, base_point, geometry, attributes)\\n\\n    If idef_index < 0 Then\\n      Rhino.RhinoApp.WriteLine(\\"Unable to create block definition\\", idef_name)\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n    Return Rhino.Commands.Result.Failure\\n  End Function\\nEnd Class\\n","members":[["Rhino.Input.Custom.GetObject","bool ReferenceObjectSelect"],["Rhino.DocObjects.Tables.InstanceDefinitionTable","int Add(string name, string description, Point3d basePoint, IEnumerable<GeometryBase> geometry, IEnumerable<ObjectAttributes> attributes)"],["Rhino.DocObjects.Tables.InstanceDefinitionTable","InstanceDefinition Find(string instanceDefinitionName)"],["Rhino.DocObjects.Tables.InstanceDefinitionTable","InstanceDefinition Find(string instanceDefinitionName, bool ignoreDeletedInstanceDefinitions)"]]},{"name":"Createmeshfrombrep.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.Geometry\\nImports Rhino.DocObjects\\n\\nNamespace examples_vb\\n  Public Class CreateMeshFromBrepCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbCreateMeshFromBrep\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim objRef As ObjRef = Nothing\\n      Dim rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select surface or polysurface to mesh\\", True, ObjectType.Surface Or ObjectType.PolysrfFilter, objRef)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      Dim brep = objRef.Brep()\\n      If brep Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      \' you could choose any one of these for example\\n      Dim jaggedAndFaster = MeshingParameters.Coarse\\n      Dim smoothAndSlower = MeshingParameters.Smooth\\n      Dim defaultMeshParams = MeshingParameters.Default\\n      Dim minimal = MeshingParameters.Minimal\\n\\n      Dim meshes = Mesh.CreateFromBrep(brep, smoothAndSlower)\\n      If meshes Is Nothing OrElse meshes.Length = 0 Then\\n        Return Result.Failure\\n      End If\\n\\n      Dim brepmesh = New Mesh()\\n      For Each facemesh As Mesh In meshes\\n        brepmesh.Append(facemesh)\\n      Next\\n\\n      doc.Objects.AddMesh(brepmesh)\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.MeshingParameters","static MeshingParameters Coarse"],["Rhino.Geometry.MeshingParameters","static MeshingParameters Default"],["Rhino.Geometry.MeshingParameters","static MeshingParameters Minimal"],["Rhino.Geometry.MeshingParameters","static MeshingParameters Smooth"],["Rhino.Geometry.Mesh","static Mesh[] CreateFromBrep(Brep brep, MeshingParameters meshingParameters)"],["Rhino.Geometry.Mesh","void Append(Mesh other)"]]},{"name":"Createsurfaceexample.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.Geometry\\n\\nNamespace examples_vb\\n  <System.Runtime.InteropServices.Guid(\\"652FCBE5-D8DC-4472-AB94-5A70998A3895\\")> _\\n  Public Class CreateSurfaceFromPointsAndKnotsCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbCreateSurfaceFromPointsAndKnots\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Const isRational As Boolean = False\\n      Const numberOfDimensions As Integer = 3\\n      Const uDegree As Integer = 2\\n      Const vDegree As Integer = 3\\n      Const uControlPointCount As Integer = 3\\n      Const vControlPointCount As Integer = 5\\n\\n      \' The knot vectors do NOT have the 2 superfluous knots\\n      \' at the start and end of the knot vector.  If you are\\n      \' coming from a system that has the 2 superfluous knots,\\n      \' just ignore them when creating NURBS surfaces.\\n      Dim uKnots = New Double(uControlPointCount + uDegree - 2) {}\\n      Dim vKnots = New Double(vControlPointCount + vDegree - 2) {}\\n\\n      \' make up a quadratic knot vector with no interior knots\\n      uKnots(0) = InlineAssignHelper(uKnots(1), 0.0)\\n      uKnots(2) = InlineAssignHelper(uKnots(3), 1.0)\\n\\n      \' make up a cubic knot vector with one simple interior knot\\n      vKnots(0) = InlineAssignHelper(vKnots(1), InlineAssignHelper(vKnots(2), 0.0))\\n      vKnots(3) = 1.5\\n      vKnots(4) = InlineAssignHelper(vKnots(5), InlineAssignHelper(vKnots(6), 2.0))\\n\\n      \' Rational control points can be in either homogeneous\\n      \' or euclidean form. Non-rational control points do not\\n      \' need to specify a weight.  \\n      Dim controlPoints = New Point3d(uControlPointCount - 1, vControlPointCount - 1) {}\\n\\n      For u As Integer = 0 To uControlPointCount - 1\\n        For v As Integer = 0 To vControlPointCount - 1\\n          controlPoints(u, v) = New Point3d(u, v, u - v)\\n        Next\\n      Next\\n\\n      \' creates internal uninitialized arrays for \\n      \' control points and knots\\n      Dim nurbsSurface__1 = NurbsSurface.Create(numberOfDimensions, isRational, uDegree + 1, vDegree + 1, uControlPointCount, vControlPointCount)\\n\\n      \' add the knots\\n      For u As Integer = 0 To nurbsSurface__1.KnotsU.Count - 1\\n        nurbsSurface__1.KnotsU(u) = uKnots(u)\\n      Next\\n      For v As Integer = 0 To nurbsSurface__1.KnotsV.Count - 1\\n        nurbsSurface__1.KnotsV(v) = vKnots(v)\\n      Next\\n\\n      \' add the control points\\n      For u As Integer = 0 To nurbsSurface__1.Points.CountU - 1\\n        For v As Integer = 0 To nurbsSurface__1.Points.CountV - 1\\n          nurbsSurface__1.Points.SetControlPoint(u, v, controlPoints(u, v))\\n        Next\\n      Next\\n\\n      If nurbsSurface__1.IsValid Then\\n        doc.Objects.AddSurface(nurbsSurface__1)\\n        doc.Views.Redraw()\\n        Return Result.Success\\n      Else\\n        Return Result.Failure\\n      End If\\n    End Function\\n    Private Shared Function InlineAssignHelper(Of T)(ByRef target As T, value As T) As T\\n      target = value\\n      Return value\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.NurbsSurface","NurbsSurfaceKnotList KnotsU"],["Rhino.Geometry.NurbsSurface","NurbsSurfaceKnotList KnotsV"],["Rhino.Geometry.NurbsSurface","NurbsSurfacePointList Points"],["Rhino.Geometry.NurbsSurface","static NurbsSurface Create(int dimension, bool isRational, int order0, int order1, int controlPointCount0, int controlPointCount1)"]]},{"name":"Crvdeviation.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.DocObjects\\nImports Rhino.Geometry\\nImports System.Drawing\\nImports Rhino.Input\\n\\nNamespace examples_vb\\n  Class DeviationConduit\\n    Inherits Rhino.Display.DisplayConduit\\n    Private ReadOnly _curveA As Curve\\n    Private ReadOnly _curveB As Curve\\n    Private ReadOnly _minDistPointA As Point3d\\n    Private ReadOnly _minDistPointB As Point3d\\n    Private ReadOnly _maxDistPointA As Point3d\\n    Private ReadOnly _maxDistPointB As Point3d\\n\\n    Public Sub New(curveA As Curve, curveB As Curve, minDistPointA As Point3d, minDistPointB As Point3d, maxDistPointA As Point3d, maxDistPointB As Point3d)\\n      _curveA = curveA\\n      _curveB = curveB\\n      _minDistPointA = minDistPointA\\n      _minDistPointB = minDistPointB\\n      _maxDistPointA = maxDistPointA\\n      _maxDistPointB = maxDistPointB\\n    End Sub\\n\\n    Protected Overrides Sub DrawForeground(e As Rhino.Display.DrawEventArgs)\\n      e.Display.DrawCurve(_curveA, Color.Red)\\n      e.Display.DrawCurve(_curveB, Color.Red)\\n\\n      e.Display.DrawPoint(_minDistPointA, Color.LawnGreen)\\n      e.Display.DrawPoint(_minDistPointB, Color.LawnGreen)\\n      e.Display.DrawLine(New Line(_minDistPointA, _minDistPointB), Color.LawnGreen)\\n      e.Display.DrawPoint(_maxDistPointA, Color.Red)\\n      e.Display.DrawPoint(_maxDistPointB, Color.Red)\\n      e.Display.DrawLine(New Line(_maxDistPointA, _maxDistPointB), Color.Red)\\n    End Sub\\n  End Class\\n\\n\\n  Public Class CurveDeviationCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbCurveDeviation\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      doc.Objects.UnselectAll()\\n\\n      Dim objRef1 As ObjRef = Nothing\\n      Dim rc1 = RhinoGet.GetOneObject(\\"first curve\\", True, ObjectType.Curve, objRef1)\\n      If rc1 <> Result.Success Then\\n        Return rc1\\n      End If\\n      Dim curveA As Curve = Nothing\\n      If objRef1 IsNot Nothing Then\\n        curveA = objRef1.Curve()\\n      End If\\n      If curveA Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      \' Since you already selected a curve if you don\'t unselect it\\n      \' the next GetOneObject won\'t stop as it considers that curve \\n      \' input, i.e., curveA and curveB will point to the same curve.\\n      \' Another option would be to use an instance of Rhino.Input.Custom.GetObject\\n      \' instead of Rhino.Input.RhinoGet as GetObject has a DisablePreSelect() method.\\n      doc.Objects.UnselectAll()\\n\\n      Dim objRef2 As ObjRef = Nothing\\n      Dim rc2 = RhinoGet.GetOneObject(\\"second curve\\", True, ObjectType.Curve, objRef2)\\n      If rc2 <> Result.Success Then\\n        Return rc2\\n      End If\\n      Dim curveB As Curve = Nothing\\n      If objRef2 IsNot Nothing Then\\n        curveB = objRef2.Curve()\\n      End If\\n      If curveB Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      Dim tolerance = doc.ModelAbsoluteTolerance\\n\\n      Dim maxDistance As Double\\n      Dim maxDistanceParameterA As Double\\n      Dim maxDistanceParameterB As Double\\n      Dim minDistance As Double\\n      Dim minDistanceParameterA As Double\\n      Dim minDistanceParameterB As Double\\n\\n      Dim conduit As DeviationConduit\\n      If Not Curve.GetDistancesBetweenCurves(curveA, curveB, tolerance, maxDistance, maxDistanceParameterA, maxDistanceParameterB, _\\n        minDistance, minDistanceParameterA, minDistanceParameterB) Then\\n        RhinoApp.WriteLine(\\"Unable to find overlap intervals.\\")\\n        Return Result.Success\\n      Else\\n        If minDistance <= RhinoMath.ZeroTolerance Then\\n          minDistance = 0.0\\n        End If\\n        Dim maxDistPtA = curveA.PointAt(maxDistanceParameterA)\\n        Dim maxDistPtB = curveB.PointAt(maxDistanceParameterB)\\n        Dim minDistPtA = curveA.PointAt(minDistanceParameterA)\\n        Dim minDistPtB = curveB.PointAt(minDistanceParameterB)\\n\\n        conduit = New DeviationConduit(curveA, curveB, minDistPtA, minDistPtB, maxDistPtA, maxDistPtB)\\n        conduit.Enabled = True\\n\\n        doc.Views.Redraw()\\n        RhinoApp.WriteLine(\\"Minimum deviation= {0}   pointA= {1}, pointB= {2}\\", minDistance, minDistPtA, minDistPtB)\\n        RhinoApp.WriteLine(\\"Maximum deviation= {0}   pointA= {1}, pointB= {2}\\", maxDistance, maxDistPtA, maxDistPtB)\\n      End If\\n\\n      Dim str As String = \\"\\"\\n      RhinoGet.GetString(\\"Press Enter when done\\", True, str)\\n      conduit.Enabled = False\\n\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Curve","static bool GetDistancesBetweenCurves(Curve curveA, Curve curveB, double tolerance, out double maxDistance, out double maxDistanceParameterA, out double maxDistanceParameterB, out double minDistance, out double minDistanceParameterA, out double minDistanceParameterB)"],["Rhino.DocObjects.Tables.ObjectTable","int UnselectAll()"]]},{"name":"Curveboundingbox.vb","code":"Partial Class Examples\\n  Public Shared Function CurveBoundingBox(doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    \' Select a curve object\\n    Dim rhObject As Rhino.DocObjects.ObjRef = Nothing\\n    Dim rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select curve\\", False, Rhino.DocObjects.ObjectType.Curve, rhObject)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    \' Validate selection\\n    Dim curve = rhObject.Curve()\\n    If curve Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    \' Get the active view\'s construction plane\\n    Dim view = doc.Views.ActiveView\\n    If view Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n    Dim plane = view.ActiveViewport.ConstructionPlane()\\n\\n    \' Compute the tight bounding box of the curve in world coordinates\\n    Dim bbox = curve.GetBoundingBox(True)\\n    If Not bbox.IsValid Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    \' Print the min and max box coordinates in world coordinates\\n    Rhino.RhinoApp.WriteLine(\\"World min: {0}\\", bbox.Min)\\n    Rhino.RhinoApp.WriteLine(\\"World max: {0}\\", bbox.Max)\\n\\n    \' Compute the tight bounding box of the curve based on the \\n    \' active view\'s construction plane\\n    bbox = curve.GetBoundingBox(plane)\\n\\n    \' Print the min and max box coordinates in cplane coordinates\\n    Rhino.RhinoApp.WriteLine(\\"CPlane min: {0}\\", bbox.Min)\\n    Rhino.RhinoApp.WriteLine(\\"CPlane max: {0}\\", bbox.Max)\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.GeometryBase","BoundingBox GetBoundingBox(bool accurate)"],["Rhino.Geometry.GeometryBase","BoundingBox GetBoundingBox(Plane plane)"]]},{"name":"Curvebrepbox.vb","code":"Imports Rhino\\nImports Rhino.Geometry\\nImports Rhino.Commands\\nImports Rhino.Input\\n\\nNamespace examples_vb\\n  Public Class BrepFromCurveBBoxCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbBrepFromCurveBBox\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim objref As DocObjects.ObjRef = Nothing\\n      Dim rc = RhinoGet.GetOneObject(\\"Select Curve\\", False, DocObjects.ObjectType.Curve, objref)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      Dim curve = objref.Curve()\\n\\n      Dim view = doc.Views.ActiveView\\n      Dim plane = view.ActiveViewport.ConstructionPlane()\\n      \' Create a construction plane aligned bounding box\\n      Dim bbox = curve.GetBoundingBox(plane)\\n\\n      If bbox.IsDegenerate(doc.ModelAbsoluteTolerance) > 0 Then\\n        RhinoApp.WriteLine(\\"the curve\'s bounding box is degenerate (flat) in at least one direction so a box cannot be created.\\")\\n        Return Result.Failure\\n      End If\\n      Dim brepbox = Brep.CreateFromBox(bbox)\\n      doc.Objects.AddBrep(brepbox)\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.BoundingBox","int IsDegenerate(double tolerance)"],["Rhino.Geometry.Brep","static Brep CreateFromBox(BoundingBox box)"]]},{"name":"Curvereverse.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.Input\\nImports Rhino.DocObjects\\n\\nNamespace examples_vb\\n  Public Class ReverseCurveCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbReverseCurve\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim objRefs As ObjRef() = Nothing\\n      Dim rc = RhinoGet.GetMultipleObjects(\\"Select curves to reverse\\", True, ObjectType.Curve, objRefs)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n\\n      For Each objRef As ObjRef In objRefs\\n        Dim curveCopy = objRef.Curve().DuplicateCurve()\\n        If curveCopy IsNot Nothing Then\\n          curveCopy.Reverse()\\n          doc.Objects.Replace(objRef, curveCopy)\\n        End If\\n      Next\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Curve","Curve DuplicateCurve()"],["Rhino.Geometry.Curve","bool Reverse()"]]},{"name":"Curvesurfaceintersect.vb","code":"Imports Rhino\\nImports Rhino.Geometry\\nImports Rhino.Geometry.Intersect\\nImports Rhino.Input.Custom\\nImports Rhino.DocObjects\\nImports Rhino.Commands\\n\\nNamespace examples_vb\\n  Public Class CurveSurfaceIntersectCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbCurveSurfaceIntersect\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim gs = New GetObject()\\n      gs.SetCommandPrompt(\\"select brep\\")\\n      gs.GeometryFilter = ObjectType.Brep\\n      gs.DisablePreSelect()\\n      gs.SubObjectSelect = False\\n      gs.Get()\\n      If gs.CommandResult() <> Result.Success Then\\n        Return gs.CommandResult()\\n      End If\\n      Dim brep = gs.[Object](0).Brep()\\n\\n      Dim gc = New GetObject()\\n      gc.SetCommandPrompt(\\"select curve\\")\\n      gc.GeometryFilter = ObjectType.Curve\\n      gc.DisablePreSelect()\\n      gc.SubObjectSelect = False\\n      gc.Get()\\n      If gc.CommandResult() <> Result.Success Then\\n        Return gc.CommandResult()\\n      End If\\n      Dim curve = gc.Object(0).Curve()\\n\\n      If brep Is Nothing OrElse curve Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      Dim tolerance = doc.ModelAbsoluteTolerance\\n\\n      Dim intersectionPoints As Point3d() = Nothing\\n      Dim overlapCurves As Curve() = Nothing\\n      If Not Intersection.CurveBrep(curve, brep, tolerance, overlapCurves, intersectionPoints) Then\\n        RhinoApp.WriteLine(\\"curve brep intersection failed\\")\\n        Return Result.Nothing\\n      End If\\n\\n      For Each overlapCurve As Curve In overlapCurves\\n        doc.Objects.AddCurve(overlapCurve)\\n      Next\\n      For Each intersectionPoint As Point3d In intersectionPoints\\n        doc.Objects.AddPoint(intersectionPoint)\\n      Next\\n\\n      RhinoApp.WriteLine(\\"{0} overlap curves, and {1} intersection points\\", overlapCurves.Length, intersectionPoints.Length)\\n      doc.Views.Redraw()\\n\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Intersect.Intersection","static CurveIntersections CurveSurface(Curve curve, Surface surface, double tolerance, double overlapTolerance)"],["Rhino.Geometry.Intersect.IntersectionEvent","bool IsOverlap"],["Rhino.DocObjects.Tables.ObjectTable","int Select(IEnumerable<Guid> objectIds)"]]},{"name":"Customgeometryfilter.vb","code":"Imports Rhino\\nImports Rhino.Geometry\\nImports Rhino.Commands\\nImports Rhino.Input.Custom\\nImports Rhino.DocObjects\\n\\nNamespace examples_vb\\n  Public Class CustomGeometryFilterCommand\\n    Inherits Command\\n    Private _tolerance As Double\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbCustomGeometryFilter\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      _tolerance = doc.ModelAbsoluteTolerance\\n\\n      \' only use a custom geometry filter if no simpler filter does the job\\n\\n      \' only curves\\n      Dim gc = New GetObject()\\n      gc.SetCommandPrompt(\\"select curve\\")\\n      gc.GeometryFilter = ObjectType.Curve\\n      gc.DisablePreSelect()\\n      gc.SubObjectSelect = False\\n      gc.[Get]()\\n      If gc.CommandResult() <> Result.Success Then\\n        Return gc.CommandResult()\\n      End If\\n      If gc.[Object](0).Curve() Is Nothing Then\\n        Return Result.Failure\\n      End If\\n      Rhino.RhinoApp.WriteLine(\\"curve was selected\\")\\n\\n      \' only closed curves\\n      Dim gcc = New GetObject()\\n      gcc.SetCommandPrompt(\\"select closed curve\\")\\n      gcc.GeometryFilter = ObjectType.Curve\\n      gcc.GeometryAttributeFilter = GeometryAttributeFilter.ClosedCurve\\n      gcc.DisablePreSelect()\\n      gcc.SubObjectSelect = False\\n      gcc.[Get]()\\n      If gcc.CommandResult() <> Result.Success Then\\n        Return gcc.CommandResult()\\n      End If\\n      If gcc.[Object](0).Curve() Is Nothing Then\\n        Return Result.Failure\\n      End If\\n      Rhino.RhinoApp.WriteLine(\\"closed curve was selected\\")\\n\\n      \' only circles with a radius of 10\\n      Dim gcc10 = New GetObject()\\n      gcc10.SetCommandPrompt(\\"select circle with radius of 10\\")\\n      gc.GeometryFilter = ObjectType.Curve\\n      gcc10.SetCustomGeometryFilter(AddressOf CircleWithRadiusOf10GeometryFilter)\\n      \' custom geometry filter\\n      gcc10.DisablePreSelect()\\n      gcc10.SubObjectSelect = False\\n      gcc10.[Get]()\\n      If gcc10.CommandResult() <> Result.Success Then\\n        Return gcc10.CommandResult()\\n      End If\\n      If gcc10.[Object](0).Curve() Is Nothing Then\\n        Return Result.Failure\\n      End If\\n      Rhino.RhinoApp.WriteLine(\\"circle with radius of 10 was selected\\")\\n\\n      Return Result.Success\\n    End Function\\n\\n    Private Function CircleWithRadiusOf10GeometryFilter(rhObject As Rhino.DocObjects.RhinoObject, geometry As GeometryBase, componentIndex As ComponentIndex) As Boolean\\n      Dim isCircleWithRadiusOf10 As Boolean = False\\n      Dim circle As Circle\\n      If TypeOf geometry Is Curve AndAlso TryCast(geometry, Curve).TryGetCircle(circle) Then\\n        isCircleWithRadiusOf10 = circle.Radius <= 10.0 + _tolerance AndAlso circle.Radius >= 10.0 - _tolerance\\n      End If\\n      Return isCircleWithRadiusOf10\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Curve","bool TryGetCircle(out Circle circle)"],["Rhino.Input.Custom.GetObject","void SetCustomGeometryFilter(GetObjectGeometryFilter filter)"]]},{"name":"Customundo.vb","code":"Imports System.Runtime.InteropServices\\nImports Rhino\\n\\n<Guid(\\"A6924FE1-2B94-4918-94F3-B8935B8DC80C\\")> _\\nPublic Class ex_customundoCommand\\n  Inherits Rhino.Commands.Command\\n  Public Overrides ReadOnly Property EnglishName() As String\\n    Get\\n      Return \\"vb_CustomUndoCommand\\"\\n    End Get\\n  End Property\\n\\n  Private Property MyFavoriteNumber() As Double\\n    Get\\n      Return m_MyFavoriteNumber\\n    End Get\\n    Set(value As Double)\\n      m_MyFavoriteNumber = value\\n    End Set\\n  End Property\\n  Private m_MyFavoriteNumber As Double\\n\\n  Protected Overrides Function RunCommand(doc As RhinoDoc, mode As Rhino.Commands.RunMode) As Rhino.Commands.Result\\n    \' Rhino automatically sets up an undo record when a command is run,\\n    \' but... the undo record is not saved if nothing changes in the\\n    \' document (objects added/deleted, layers changed,...)\\n    \'\\n    \' If we have a command that doesn\'t change things in the document,\\n    \' but we want to have our own custom undo called then we need to do\\n    \' a little extra work\\n\\n    Dim d As Double = MyFavoriteNumber\\n    If Rhino.Input.RhinoGet.GetNumber(\\"Favorite number\\", True, d) = Rhino.Commands.Result.Success Then\\n      Dim current_value As Double = MyFavoriteNumber\\n      doc.AddCustomUndoEvent(\\"Favorite Number\\", AddressOf OnUndoFavoriteNumber, current_value)\\n      MyFavoriteNumber = d\\n    End If\\n    Return Rhino.Commands.Result.Success\\n  End Function\\n\\n  \' event handler for custom undo\\n  Private Sub OnUndoFavoriteNumber(sender As Object, e As Rhino.Commands.CustomUndoEventArgs)\\n    \' !!!!!!!!!!\\n    \' NEVER change any setting in the Rhino document or application.  Rhino\\n    \' handles ALL changes to the application and document and you will break\\n    \' the Undo/Redo commands if you make any changes to the application or\\n    \' document. This is meant only for your own private plug-in data\\n    \' !!!!!!!!!!\\n\\n    \' This function can be called either by undo or redo\\n    \' In order to get redo to work, add another custom undo event with the\\n    \' current value.  If you don\'t want redo to work, just skip adding\\n    \' a custom undo event here\\n    Dim current_value As Double = MyFavoriteNumber\\n    e.Document.AddCustomUndoEvent(\\"Favorite Number\\", AddressOf OnUndoFavoriteNumber, current_value)\\n\\n    Dim old_value As Double = CDbl(e.Tag)\\n    RhinoApp.WriteLine(\\"Going back to your favorite = {0}\\", old_value)\\n    MyFavoriteNumber = old_value\\n  End Sub\\nEnd Class\\n","members":[["Rhino.RhinoDoc","bool AddCustomUndoEvent(string description, EventHandler<CustomUndoEventArgs> handler, object tag)"]]},{"name":"Dimstyle.vb","code":"Imports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.Commands\\nImports Rhino.Geometry\\n\\nNamespace examples_vb\\n  Public Class ChangeDimensionStyleCommand\\n    Inherits Rhino.Commands.Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbChangeDimensionStyle\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      For Each rhino_object As RhinoObject In doc.Objects.GetObjectList(ObjectType.Annotation)\\n        Dim annotation_object = TryCast(rhino_object, AnnotationObjectBase)\\n        If annotation_object Is Nothing Then\\n          Continue For\\n        End If\\n\\n        Dim annotation = TryCast(annotation_object.Geometry, AnnotationBase)\\n        If annotation Is Nothing Then\\n          Continue For\\n        End If\\n\\n        If annotation.Index = doc.DimStyles.CurrentDimensionStyleIndex Then\\n          Continue For\\n        End If\\n\\n        annotation.Index = doc.DimStyles.CurrentDimensionStyleIndex\\n        annotation_object.CommitChanges()\\n      Next\\n\\n      doc.Views.Redraw()\\n\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.RhinoDoc","DimStyleTable DimStyles"],["Rhino.DocObjects.Tables.DimStyleTable","int CurrentIndex"],["Rhino.DocObjects.Tables.ObjectTable","IEnumerable<RhinoObject> GetObjectList(Type typeFilter)"]]},{"name":"Displayorder.vb","code":"Imports System.Collections.Generic\\nImports System.Drawing\\nImports System.Linq\\nImports Rhino\\nImports Rhino.Commands\\nImports Rhino.Display\\nImports Rhino.Geometry\\nImports Rhino.Input\\nImports Rhino.DocObjects\\n\\nNamespace examples_vb\\n  Public Class DisplayOrderCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbDisplayOrder\\"\\n      End Get\\n    End Property\\n\\n    Private m_line_objects As New List(Of RhinoObject)()\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      \' make lines thick so draw order can be easily seen\\n      Dim dm = DisplayModeDescription.GetDisplayModes().[Single](Function(x) x.EnglishName = \\"Wireframe\\")\\n      Dim original_thikcness = dm.DisplayAttributes.CurveThickness\\n      dm.DisplayAttributes.CurveThickness = 10\\n      DisplayModeDescription.UpdateDisplayMode(dm)\\n\\n      AddLine(Point3d.Origin, New Point3d(10, 10, 0), Color.Red, doc)\\n      AddLine(New Point3d(10, 0, 0), New Point3d(0, 10, 0), Color.Blue, doc)\\n      AddLine(New Point3d(8, 0, 0), New Point3d(8, 10, 0), Color.Green, doc)\\n      AddLine(New Point3d(0, 3, 0), New Point3d(10, 3, 0), Color.Yellow, doc)\\n      doc.Views.Redraw()\\n      Pause(\\"draw order: 1st line drawn in front, last line drawn in the back.  Any key to continue ...\\")\\n\\n      \'all objects have a DisplayOrder of 0 by default so changing it to 1 moves it to the front.  Here we move the 2nd line (blue) to the front\\n      m_line_objects(1).Attributes.DisplayOrder = 1\\n      m_line_objects(1).CommitChanges()\\n      doc.Views.Redraw()\\n      Pause(\\"Second (blue) line now in front.  Any key to continue ...\\")\\n\\n      For i As Integer = 0 To m_line_objects.Count - 1\\n        m_line_objects(i).Attributes.DisplayOrder = i\\n        m_line_objects(i).CommitChanges()\\n      Next\\n      doc.Views.Redraw()\\n      Pause(\\"Reverse order of original lines, i.e., Yellow 1st and Red last.  Any key to continue ...\\")\\n\\n      \' restore original line thickness\\n      dm.DisplayAttributes.CurveThickness = original_thikcness\\n      DisplayModeDescription.UpdateDisplayMode(dm)\\n\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n\\n    Private Sub Pause(msg As String)\\n      Dim obj_ref As ObjRef = Nothing\\n      Dim rc = RhinoGet.GetOneObject(msg, True, ObjectType.AnyObject, obj_ref)\\n    End Sub\\n\\n    Private Sub AddLine(from As Point3d, [to] As Point3d, color As Color, doc As RhinoDoc)\\n      Dim guid = doc.Objects.AddLine(from, [to])\\n      Dim obj = doc.Objects.Find(guid)\\n      m_line_objects.Add(obj)\\n      obj.Attributes.ObjectColor = color\\n      obj.Attributes.ColorSource = ObjectColorSource.ColorFromObject\\n      obj.CommitChanges()\\n    End Sub\\n  End Class\\nEnd Namespace","members":[["Rhino.DocObjects.ObjectAttributes","int DisplayOrder"]]},{"name":"Displayprecision.vb","code":"Imports Rhino\\nImports Rhino.Input.Custom\\nImports Rhino.Commands\\n\\nNamespace examples_vb\\n  Public Class DisplayPrecisionCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbDisplayPrecision\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim gi = New GetInteger()\\n      gi.SetCommandPrompt(\\"New display precision\\")\\n      gi.SetDefaultInteger(doc.ModelDistanceDisplayPrecision)\\n      gi.SetLowerLimit(0, False)\\n      gi.SetUpperLimit(7, False)\\n      gi.[Get]()\\n      If gi.CommandResult() <> Result.Success Then\\n        Return gi.CommandResult()\\n      End If\\n      Dim distance_display_precision = gi.Number()\\n\\n      If distance_display_precision <> doc.ModelDistanceDisplayPrecision Then\\n        doc.ModelDistanceDisplayPrecision = distance_display_precision\\n      End If\\n\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.RhinoDoc","int ModelDistanceDisplayPrecision"]]},{"name":"Dividebylength.vb","code":"Imports Rhino.DocObjects\\n\\nPartial Class Examples\\n  Public Shared Function DivideByLengthPoints(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Const filter As ObjectType = Rhino.DocObjects.ObjectType.Curve\\n    Dim objref As Rhino.DocObjects.ObjRef = Nothing\\n    Dim rc As Rhino.Commands.Result = Rhino.Input.RhinoGet.GetOneObject(\\"Select curve to divide\\", False, filter, objref)\\n    If rc <> Rhino.Commands.Result.Success OrElse objref Is Nothing Then\\n      Return rc\\n    End If\\n\\n    Dim crv As Rhino.Geometry.Curve = objref.Curve()\\n    If crv Is Nothing OrElse crv.IsShort(Rhino.RhinoMath.ZeroTolerance) Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    Dim crv_length As Double = crv.GetLength()\\n    Dim s As String = String.Format(\\"Curve length is {0:f3}. Segment length\\", crv_length)\\n\\n    Dim seg_length As Double = crv_length / 2.0\\n    rc = Rhino.Input.RhinoGet.GetNumber(s, False, seg_length, 0, crv_length)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    Dim points As Rhino.Geometry.Point3d() = Nothing\\n    crv.DivideByLength(seg_length, True, points)\\n    If points Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    For Each point As Rhino.Geometry.Point3d In points\\n      doc.Objects.AddPoint(point)\\n    Next\\n\\n    doc.Views.Redraw()\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Curve","static Curve[] JoinCurves(IEnumerable<Curve> inputCurves, double joinTolerance)"],["Rhino.Geometry.Curve","double[] DivideByLength(double segmentLength, bool includeEnds)"],["Rhino.Geometry.Curve","double[] DivideByLength(double segmentLength, bool includeEnds, bool reverse)"],["Rhino.Geometry.Curve","double[] DivideByLength(double segmentLength, bool includeEnds, bool reverse, out Point3d[] points)"],["Rhino.Geometry.Curve","double[] DivideByLength(double segmentLength, bool includeEnds, out Point3d[] points)"],["Rhino.Geometry.Curve","bool IsShort(double tolerance)"],["Rhino.Input.RhinoGet","static Result GetNumber(string prompt, bool acceptNothing, ref double outputNumber)"],["Rhino.Input.RhinoGet","static Result GetNumber(string prompt, bool acceptNothing, ref double outputNumber, double lowerLimit, double upperLimit)"],["Rhino.Input.RhinoGet","static Result GetOneObject(string prompt, bool acceptNothing, ObjectType filter, out ObjRef rhObject)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddPoint(Point3d point)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddPoint(Point3f point)"],["Rhino.DocObjects.Tables.ObjectTable","bool Select(Guid objectId)"]]},{"name":"Drawstring.vb","code":"Imports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.Geometry\\nImports Rhino.Commands\\nImports Rhino.Input.Custom\\n\\nNamespace examples_vb\\n  Public Class DrawStringCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbDrawString\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim gp = New GetDrawStringPoint()\\n      gp.SetCommandPrompt(\\"Point\\")\\n      gp.[Get]()\\n      Return gp.CommandResult()\\n    End Function\\n  End Class\\n\\n  Public Class GetDrawStringPoint\\n    Inherits GetPoint\\n    Protected Overrides Sub OnDynamicDraw(e As GetPointDrawEventArgs)\\n      MyBase.OnDynamicDraw(e)\\n      Dim xform = e.Viewport.GetTransform(CoordinateSystem.World, CoordinateSystem.Screen)\\n      Dim current_point = e.CurrentPoint\\n      current_point.Transform(xform)\\n      Dim screen_point = New Point2d(current_point.X, current_point.Y)\\n      Dim msg = String.Format(\\"screen {0:F}, {1:F}\\", current_point.X, current_point.Y)\\n      e.Display.Draw2dText(msg, System.Drawing.Color.Blue, screen_point, False)\\n    End Sub\\n  End Class\\nEnd Namespace","members":[["Rhino.Display.DisplayPipeline","void Draw2dText(string text, Color color, Point2d screenCoordinate, bool middleJustified)"]]},{"name":"Dupborder.vb","code":"Imports Rhino.DocObjects\\n\\nPartial Class Examples\\n  Public Shared Function DupBorder(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Const filter As ObjectType = Rhino.DocObjects.ObjectType.Surface Or Rhino.DocObjects.ObjectType.PolysrfFilter\\n    Dim objref As Rhino.DocObjects.ObjRef = Nothing\\n    Dim rc As Rhino.Commands.Result = Rhino.Input.RhinoGet.GetOneObject(\\"Select surface or polysurface\\", False, filter, objref)\\n    If rc <> Rhino.Commands.Result.Success OrElse objref Is Nothing Then\\n      Return rc\\n    End If\\n\\n    Dim rhobj As Rhino.DocObjects.RhinoObject = objref.[Object]()\\n    Dim brep As Rhino.Geometry.Brep = objref.Brep()\\n    If rhobj Is Nothing OrElse brep Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    rhobj.[Select](False)\\n    Dim curves As Rhino.Geometry.Curve() = brep.DuplicateEdgeCurves(True)\\n    Dim tol As Double = doc.ModelAbsoluteTolerance * 2.1\\n    curves = Rhino.Geometry.Curve.JoinCurves(curves, tol)\\n    For i As Integer = 0 To curves.Length - 1\\n      Dim id As Guid = doc.Objects.AddCurve(curves(i))\\n      doc.Objects.[Select](id)\\n    Next\\n    doc.Views.Redraw()\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Brep","Curve[] DuplicateEdgeCurves(bool nakedOnly)"]]},{"name":"Duplicateobject.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.DocObjects\\nImports Rhino.Input\\n\\nNamespace examples_vb\\n  Public Class DuplicateObjectCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbDuplicateObject\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim obj_ref As ObjRef = Nothing\\n\\n      Dim rc = RhinoGet.GetOneObject(\\"Select object to duplicate\\", False, ObjectType.AnyObject, obj_ref)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      Dim rhino_object = obj_ref.[Object]()\\n\\n      Dim geometry_base = rhino_object.DuplicateGeometry()\\n      If geometry_base IsNot Nothing Then\\n        If doc.Objects.Add(geometry_base) <> Guid.Empty Then\\n          doc.Views.Redraw()\\n        End If\\n      End If\\n\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.DocObjects.RhinoObject","GeometryBase DuplicateGeometry()"]]},{"name":"Dupmeshboundary.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.Input.Custom\\nImports Rhino.Geometry\\nImports Rhino.DocObjects\\n\\nNamespace examples_vb\\n  Public Class DupMeshBoundaryCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbDupMeshBoundary\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim gm = New GetObject()\\n      gm.SetCommandPrompt(\\"Select open mesh\\")\\n      gm.GeometryFilter = ObjectType.Mesh\\n      gm.GeometryAttributeFilter = GeometryAttributeFilter.OpenMesh\\n      gm.[Get]()\\n      If gm.CommandResult() <> Result.Success Then\\n        Return gm.CommandResult()\\n      End If\\n      Dim mesh = gm.[Object](0).Mesh()\\n      If mesh Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      Dim polylines = mesh.GetNakedEdges()\\n      For Each polyline As Polyline In polylines\\n        doc.Objects.AddPolyline(polyline)\\n      Next\\n\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Mesh","Polyline[] GetNakedEdges()"]]},{"name":"Edgesrf.vb","code":"Imports System.Linq\\nImports Rhino\\nImports Rhino.Commands\\nImports Rhino.DocObjects\\nImports Rhino.Geometry\\nImports Rhino.Input.Custom\\n\\nNamespace examples_vb\\n  Public Class EdgeSrfCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbEdgeSrf\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim go = New GetObject()\\n      go.SetCommandPrompt(\\"Select 2, 3, or 4 open curves\\")\\n      go.GeometryFilter = ObjectType.Curve\\n      go.GeometryAttributeFilter = GeometryAttributeFilter.OpenCurve\\n      go.GetMultiple(2, 4)\\n      If go.CommandResult() <> Result.Success Then\\n        Return go.CommandResult()\\n      End If\\n\\n      Dim curves = go.Objects().[Select](Function(o) o.Curve())\\n\\n      Dim brep__1 = Brep.CreateEdgeSurface(curves)\\n\\n      If brep__1 IsNot Nothing Then\\n        doc.Objects.AddBrep(brep__1)\\n        doc.Views.Redraw()\\n      End If\\n\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Brep","static Brep CreateEdgeSurface(IEnumerable<Curve> curves)"]]},{"name":"Elevation.vb","code":"Imports System.Collections.Generic\\nImports System.Linq\\nImports Rhino\\nImports Rhino.Commands\\nImports Rhino.Geometry\\nImports Rhino.Geometry.Intersect\\nImports Rhino.Input\\nImports Rhino.Input.Custom\\nImports Rhino.DocObjects\\n\\nNamespace examples_vb\\n  Public Class FurthestZOnSurfaceCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbFurthestZOnSurfaceGivenXY\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      \'#Region \\"user input\\"\\n      \' select a surface\\n      Dim gs = New GetObject()\\n      gs.SetCommandPrompt(\\"select surface\\")\\n      gs.GeometryFilter = ObjectType.Surface\\n      gs.DisablePreSelect()\\n      gs.SubObjectSelect = False\\n      gs.[Get]()\\n      If gs.CommandResult() <> Result.Success Then\\n        Return gs.CommandResult()\\n      End If\\n      \' get the brep\\n      Dim brep = gs.[Object](0).Brep()\\n      If brep Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      \' get X and Y\\n      Dim x As Double = 0.0, y As Double = 0.0\\n      Dim rc = RhinoGet.GetNumber(\\"value of X coordinate\\", True, x)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      rc = RhinoGet.GetNumber(\\"value of Y coordinate\\", True, y)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      \'#End Region\\n\\n      \' an earlier version of this sample used a curve-brep intersection to find Z\\n      \'var maxZ = MaxZIntersectionMethod(brep, x, y, doc.ModelAbsoluteTolerance);\\n\\n      \' projecting points is another way to find Z\\n      Dim maxZ = MaxZProjectionMethod(brep, x, y, doc.ModelAbsoluteTolerance)\\n\\n      If maxZ IsNot Nothing Then\\n        RhinoApp.WriteLine(\\"Maximum surface Z coordinate at X={0}, Y={1} is {2}\\", x, y, maxZ)\\n        doc.Objects.AddPoint(New Point3d(x, y, maxZ.Value))\\n        doc.Views.Redraw()\\n      Else\\n        RhinoApp.WriteLine(\\"no maximum surface Z coordinate at X={0}, Y={1} found.\\", x, y)\\n      End If\\n\\n      Return Result.Success\\n    End Function\\n\\n    Private Function MaxZProjectionMethod(brep As Brep, x As Double, y As Double, tolerance As Double) As System.Nullable(Of Double)\\n      Dim maxZ As System.Nullable(Of Double) = Nothing\\n      Dim breps = New List(Of Brep)() From { _\\n        brep _\\n      }\\n      Dim points = New List(Of Point3d)() From { _\\n        New Point3d(x, y, 0) _\\n      }\\n      \' grab all the points projected in Z dir.  Aggregate finds furthest Z from XY plane\\n      Try\\n        maxZ = (From pt In Intersection.ProjectPointsToBreps(breps, points, New Vector3d(0, 0, 1), tolerance) Select pt.Z).Aggregate(Function(z1, z2) If(Math.Abs(z1) > Math.Abs(z2), z1, z2))\\n        \'Sequence contains no elements\\n      Catch generatedExceptionName As InvalidOperationException\\n      End Try\\n      Return maxZ\\n    End Function\\n\\n    Private Function MaxZIntersectionMethod(brep As Brep, x As Double, y As Double, tolerance As Double) As System.Nullable(Of Double)\\n      Dim maxZ As System.Nullable(Of Double) = Nothing\\n\\n      Dim bbox = brep.GetBoundingBox(True)\\n      \' furthest Z from XY plane.  Max() doesn\'t work because of possible negative Z values\\n      Dim maxDistFromXY = (From corner In bbox.GetCorners() Select corner.Z).Aggregate(Function(z1, z2) If(Math.Abs(z1) > Math.Abs(z2), z1, z2))\\n      \' multiply distance by 2 to make sure line intersects completely\\n      Dim lineCurve = New LineCurve(New Point3d(x, y, 0), New Point3d(x, y, maxDistFromXY * 2))\\n\\n      Dim overlapCurves As Curve() = Nothing\\n      Dim interPoints As Point3d() = Nothing\\n      If Intersection.CurveBrep(lineCurve, brep, tolerance, overlapCurves, interPoints) Then\\n        If overlapCurves.Length > 0 OrElse interPoints.Length > 0 Then\\n          \' grab all the points resulting frem the intersection. \\n          \'    1st set: points from overlapping curves, \\n          \'    2nd set: points when there was no overlap\\n          \'    .Aggregate: furthest Z from XY plane.\\n          Dim overlapCrvsZs As IEnumerable(Of Double) = (From c In overlapCurves Select DirectCast(IIf(Math.Abs(c.PointAtEnd.Z) > Math.Abs(c.PointAtStart.Z), c.PointAtEnd.Z, c.PointAtStart.Z), Double))\\n          Dim intersectPtsZs As IEnumerable(Of Double) = (From p In interPoints Select p.Z)\\n          Dim allZs = overlapCrvsZs.Union(intersectPtsZs).ToArray()\\n          maxZ = allZs.Aggregate(Function(runZ, nextZ) DirectCast(IIf(Math.Abs(runZ) > Math.Abs(nextZ), runZ, nextZ), Double))\\n        End If\\n      End If\\n      Return maxZ\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.BoundingBox","Point3d[] GetCorners()"],["Rhino.Geometry.Intersect.Intersection","static bool CurveBrep(Curve curve, Brep brep, double tolerance, out Curve[] overlapCurves, out Point3d[] intersectionPoints)"]]},{"name":"Evnormal.vb","code":"Imports Rhino\\nImports Rhino.Input.Custom\\nImports Rhino.DocObjects\\nImports Rhino.Commands\\n\\nNamespace examples_vb\\n  Public Class NormalDirectionOfBrepFaceCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbDetermineNormDirectionOfBrepFace\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      \' select a surface\\n      Dim gs = New GetObject()\\n      gs.SetCommandPrompt(\\"select surface\\")\\n      gs.GeometryFilter = ObjectType.Surface\\n      gs.DisablePreSelect()\\n      gs.SubObjectSelect = False\\n      gs.[Get]()\\n      If gs.CommandResult() <> Result.Success Then\\n        Return gs.CommandResult()\\n      End If\\n      \' get the selected face\\n      Dim face = gs.[Object](0).Face()\\n      If face Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      \' pick a point on the surface.  Constain\\n      \' picking to the face.\\n      Dim gp = New GetPoint()\\n      gp.SetCommandPrompt(\\"select point on surface\\")\\n      gp.Constrain(face, False)\\n      gp.[Get]()\\n      If gp.CommandResult() <> Result.Success Then\\n        Return gp.CommandResult()\\n      End If\\n\\n      \' get the parameters of the point on the\\n      \' surface that is clesest to gp.Point()\\n      Dim u As Double, v As Double\\n      If face.ClosestPoint(gp.Point(), u, v) Then\\n        Dim direction = face.NormalAt(u, v)\\n        If face.OrientationIsReversed Then\\n          direction.Reverse()\\n        End If\\n        RhinoApp.WriteLine(String.Format(\\"Surface normal at uv({0:f},{1:f}) = ({2:f},{3:f},{4:f})\\", u, v, direction.X, direction.Y, direction.Z))\\n      End If\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.BrepFace","bool OrientationIsReversed"],["Rhino.Geometry.Surface","Vector3d NormalAt(double u, double v)"]]},{"name":"Explodehatch.vb","code":"Imports Rhino.DocObjects\\n\\nPartial Class Examples\\n  Public Shared Function ExplodeHatch(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n\\n    Const filter As ObjectType = Rhino.DocObjects.ObjectType.Hatch\\n    Dim objref As Rhino.DocObjects.ObjRef = Nothing\\n    Dim rc As Rhino.Commands.Result = Rhino.Input.RhinoGet.GetOneObject(\\"Select hatch to explode\\", False, filter, objref)\\n    If rc <> Rhino.Commands.Result.Success OrElse objref Is Nothing Then\\n      Return rc\\n    End If\\n\\n    Dim hatch As Rhino.Geometry.Hatch = DirectCast(objref.Geometry(), Rhino.Geometry.Hatch)\\n    If hatch Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    Dim hatch_geom As Rhino.Geometry.GeometryBase() = hatch.Explode()\\n    If hatch_geom IsNot Nothing Then\\n      For i As Integer = 0 To hatch_geom.Length - 1\\n        Dim geom As Rhino.Geometry.GeometryBase = hatch_geom(i)\\n        If geom IsNot Nothing Then\\n          Select Case geom.ObjectType\\n            Case Rhino.DocObjects.ObjectType.Point\\n              If True Then\\n                Dim point As Rhino.Geometry.Point = TryCast(geom, Rhino.Geometry.Point)\\n                If point IsNot Nothing Then\\n                  doc.Objects.AddPoint(point.Location)\\n                End If\\n              End If\\n              Exit Select\\n            Case Rhino.DocObjects.ObjectType.Curve\\n              If True Then\\n                Dim curve As Rhino.Geometry.Curve = TryCast(geom, Rhino.Geometry.Curve)\\n                If curve IsNot Nothing Then\\n                  doc.Objects.AddCurve(curve)\\n                End If\\n              End If\\n              Exit Select\\n            Case Rhino.DocObjects.ObjectType.Brep\\n              If True Then\\n                Dim brep As Rhino.Geometry.Brep = TryCast(geom, Rhino.Geometry.Brep)\\n                If brep IsNot Nothing Then\\n                  doc.Objects.AddBrep(brep)\\n                End If\\n              End If\\n              Exit Select\\n          End Select\\n        End If\\n      Next\\n    End If\\n\\n    Return Rhino.Commands.Result.Success\\n  End Function\\n\\nEnd Class","members":[["Rhino.Geometry.Hatch","GeometryBase[] Explode()"]]},{"name":"Extendcurve.vb","code":"Imports System.Linq\\nImports Rhino\\nImports Rhino.Geometry\\nImports Rhino.DocObjects\\nImports Rhino.Commands\\nImports Rhino.Input\\nImports Rhino.Input.Custom\\n\\nNamespace examples_vb\\n  Public Class ExtendCurveCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbExtendCurve\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim boundary_obj_refs As ObjRef() = Nothing\\n      Dim rc = RhinoGet.GetMultipleObjects(\\"Select boundary objects\\", False, ObjectType.AnyObject, boundary_obj_refs)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      If boundary_obj_refs Is Nothing OrElse boundary_obj_refs.Length = 0 Then\\n        Return Result.[Nothing]\\n      End If\\n\\n      Dim gc = New GetObject()\\n      gc.SetCommandPrompt(\\"Select curve to extend\\")\\n      gc.GeometryFilter = ObjectType.Curve\\n      gc.GeometryAttributeFilter = GeometryAttributeFilter.OpenCurve\\n      gc.[Get]()\\n      If gc.CommandResult() <> Result.Success Then\\n        Return gc.CommandResult()\\n      End If\\n      Dim curve_obj_ref = gc.[Object](0)\\n\\n      Dim curve = curve_obj_ref.Curve()\\n      If curve Is Nothing Then\\n        Return Result.Failure\\n      End If\\n      Dim t As Double\\n      If Not curve.ClosestPoint(curve_obj_ref.SelectionPoint(), t) Then\\n        Return Result.Failure\\n      End If\\n      Dim curve_end = If(t <= curve.Domain.Mid, CurveEnd.Start, CurveEnd.[End])\\n\\n      Dim geometry = boundary_obj_refs.[Select](Function(obj) obj.Geometry())\\n      Dim extended_curve = curve.Extend(curve_end, CurveExtensionStyle.Line, geometry)\\n      If extended_curve IsNot Nothing AndAlso extended_curve.IsValid Then\\n        If Not doc.Objects.Replace(curve_obj_ref.ObjectId, extended_curve) Then\\n          Return Result.Failure\\n        End If\\n        doc.Views.Redraw()\\n      Else\\n        RhinoApp.WriteLine(\\"No boundary object was intersected so curve not extended\\")\\n        Return Result.[Nothing]\\n      End If\\n\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Curve","Curve Extend(CurveEnd side, CurveExtensionStyle style, IEnumerable<GeometryBase> geometry)"],["Rhino.Geometry.Interval","double Mid"]]},{"name":"Extractisocurve.vb","code":"Imports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.Commands\\nImports Rhino.Input\\nImports Rhino.Input.Custom\\nImports Rhino.Geometry\\n\\nNamespace examples_vb\\n  Public Class ExtractIsocurveCommand\\n    Inherits Rhino.Commands.Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbExtractIsocurve\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim obj_ref As ObjRef = Nothing\\n      Dim rc = RhinoGet.GetOneObject(\\"Select surface\\", False, ObjectType.Surface, obj_ref)\\n      If rc <> Result.Success OrElse obj_ref Is Nothing Then\\n        Return rc\\n      End If\\n      Dim surface = obj_ref.Surface()\\n\\n      Dim gp = New GetPoint()\\n      gp.SetCommandPrompt(\\"Point on surface\\")\\n      gp.Constrain(surface, False)\\n      \'gp.GeometryFilter = ObjectType.Point;\\n      Dim option_toggle = New OptionToggle(False, \\"U\\", \\"V\\")\\n      gp.AddOptionToggle(\\"Direction\\", option_toggle)\\n      Dim point As Point3d = Point3d.Unset\\n      While True\\n        Dim grc = gp.[Get]()\\n        If grc = GetResult.[Option] Then\\n          Continue While\\n        ElseIf grc = GetResult.Point Then\\n          point = gp.Point()\\n          Exit While\\n        Else\\n          Return Result.[Nothing]\\n        End If\\n      End While\\n      If point = Point3d.Unset Then\\n        Return Result.[Nothing]\\n      End If\\n\\n      Dim direction As Integer = If(option_toggle.CurrentValue, 1, 0)\\n      \' V : U\\n      Dim u_parameter As Double, v_parameter As Double\\n      If Not surface.ClosestPoint(point, u_parameter, v_parameter) Then\\n        Return Result.Failure\\n      End If\\n\\n      Dim iso_curve = surface.IsoCurve(direction, If(direction = 1, u_parameter, v_parameter))\\n      If iso_curve Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      doc.Objects.AddCurve(iso_curve)\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Surface","Curve IsoCurve(int direction, double constantParameter)"]]},{"name":"Extractthumbnail.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.Input\\nImports Rhino.Input.Custom\\nImports System.Windows\\nImports System.Windows.Controls\\n\\nNamespace examples_vb\\n  Public Class ExtractThumbnailCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbExtractThumbnail\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim gf = RhinoGet.GetFileName(GetFileNameMode.OpenImage, \\"*.3dm\\", \\"select file\\", Nothing)\\n      If gf = String.Empty OrElse Not System.IO.File.Exists(gf) Then\\n        Return Result.Cancel\\n      End If\\n\\n      Dim bitmap = Rhino.FileIO.File3dm.ReadPreviewImage(gf)\\n      \' convert System.Drawing.Bitmap to BitmapSource\\n      Dim imageSource = System.Windows.Interop.Imaging.CreateBitmapSourceFromHBitmap(bitmap.GetHbitmap(), IntPtr.Zero, Int32Rect.Empty, System.Windows.Media.Imaging.BitmapSizeOptions.FromEmptyOptions())\\n\\n      \' show in WPF window\\n      Dim window = New Window()\\n      Dim image = New Image()\\n      image.Source = imageSource\\n\\n      window.Content = image\\n      window.Show()\\n\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.FileIO.File3dm","static System.Drawing.Bitmap ReadPreviewImage(string path)"],["Rhino.Input.RhinoGet","static string GetFileName(GetFileNameMode mode, string defaultName, string title, object parent)"],["Rhino.Input.RhinoGet","static string GetFileName(GetFileNameMode mode, string defaultName, string title, object parent, BitmapFileTypes fileTypes)"]]},{"name":"Filletcurves.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.Geometry\\nImports Rhino.Input\\nImports Rhino.DocObjects\\nImports Rhino.Input.Custom\\n\\nNamespace examples_vb\\n  Public Class FilletCurvesCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbFilletCurves\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim gc1 = New GetObject()\\n      gc1.DisablePreSelect()\\n      gc1.SetCommandPrompt(\\"Select first curve to fillet (close to the end you want to fillet)\\")\\n      gc1.GeometryFilter = ObjectType.Curve\\n      gc1.GeometryAttributeFilter = GeometryAttributeFilter.OpenCurve\\n      gc1.[Get]()\\n      If gc1.CommandResult() <> Result.Success Then\\n        Return gc1.CommandResult()\\n      End If\\n      Dim curve1_obj_ref = gc1.[Object](0)\\n      Dim curve1 = curve1_obj_ref.Curve()\\n      If curve1 Is Nothing Then\\n        Return Result.Failure\\n      End If\\n      Dim curve1_point_near_end = curve1_obj_ref.SelectionPoint()\\n      If curve1_point_near_end = Point3d.Unset Then\\n        Return Result.Failure\\n      End If\\n\\n      Dim gc2 = New GetObject()\\n      gc2.DisablePreSelect()\\n      gc2.SetCommandPrompt(\\"Select second curve to fillet (close to the end you want to fillet)\\")\\n      gc2.GeometryFilter = ObjectType.Curve\\n      gc2.GeometryAttributeFilter = GeometryAttributeFilter.OpenCurve\\n      gc2.[Get]()\\n      If gc2.CommandResult() <> Result.Success Then\\n        Return gc2.CommandResult()\\n      End If\\n      Dim curve2_obj_ref = gc2.[Object](0)\\n      Dim curve2 = curve2_obj_ref.Curve()\\n      If curve2 Is Nothing Then\\n        Return Result.Failure\\n      End If\\n      Dim curve2_point_near_end = curve2_obj_ref.SelectionPoint()\\n      If curve2_point_near_end = Point3d.Unset Then\\n        Return Result.Failure\\n      End If\\n\\n      Dim radius As Double = 0\\n      Dim rc = RhinoGet.GetNumber(\\"fillet radius\\", False, radius)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n\\n      Dim fillet_curve = Curve.CreateFilletCurves(curve1, curve1_point_near_end, curve2, curve2_point_near_end, radius, True, _\\n        True, True, doc.ModelAbsoluteTolerance, doc.ModelAngleToleranceDegrees)\\n      If fillet_curve Is Nothing OrElse fillet_curve.Length <> 1 Then\\n        Return Result.Failure\\n      End If\\n\\n      doc.Objects.AddCurve(fillet_curve(0))\\n      doc.Views.Redraw()\\n      Return rc\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Curve","static Curve[] CreateFilletCurves(Curve curve0, Point3d point0, Curve curve1, Point3d point1, double radius, bool join, bool trim, bool arcExtension, double tolerance, double angleTolerance)"]]},{"name":"Findobjectsbyname.vb","code":"Partial Class Examples\\n  Public Shared Function FindObjectsByName(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Const name As String = \\"abc\\"\\n    Dim settings As New Rhino.DocObjects.ObjectEnumeratorSettings()\\n    settings.NameFilter = name\\n    Dim ids As New System.Collections.Generic.List(Of Guid)()\\n    For Each rhObj As Rhino.DocObjects.RhinoObject In doc.Objects.GetObjectList(settings)\\n      ids.Add(rhObj.Id)\\n    Next\\n\\n    If ids.Count = 0 Then\\n      Rhino.RhinoApp.WriteLine(\\"No objects with the name \\" & name)\\n      Return Rhino.Commands.Result.Failure\\n    Else\\n      Rhino.RhinoApp.WriteLine(\\"Found {0} objects\\", ids.Count)\\n      For i As Integer = 0 To ids.Count - 1\\n        Rhino.RhinoApp.WriteLine(\\"  {0}\\", ids(i))\\n      Next\\n    End If\\n\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.DocObjects.ObjectEnumeratorSettings","ObjectEnumeratorSettings()"],["Rhino.DocObjects.ObjectEnumeratorSettings","string NameFilter"]]},{"name":"Getpointdynamicdraw.vb","code":"Imports Rhino\\nImports Rhino.Geometry\\nImports Rhino.Commands\\nImports Rhino.Input.Custom\\n\\nNamespace examples_vb\\n  Public Class GetPointDynamicDrawCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbGetPointDynamicDraw\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim gp = New GetPoint()\\n      gp.SetCommandPrompt(\\"Center point\\")\\n      gp.[Get]()\\n      If gp.CommandResult() <> Result.Success Then\\n        Return gp.CommandResult()\\n      End If\\n      Dim center_point = gp.Point()\\n      If center_point = Point3d.Unset Then\\n        Return Result.Failure\\n      End If\\n\\n      Dim gcp = New GetCircleRadiusPoint(center_point)\\n      gcp.SetCommandPrompt(\\"Radius\\")\\n      gcp.ConstrainToConstructionPlane(False)\\n      gcp.SetBasePoint(center_point, True)\\n      gcp.DrawLineFromPoint(center_point, True)\\n      gcp.[Get]()\\n      If gcp.CommandResult() <> Result.Success Then\\n        Return gcp.CommandResult()\\n      End If\\n\\n      Dim radius = center_point.DistanceTo(gcp.Point())\\n      Dim cplane = doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\\n      doc.Objects.AddCircle(New Circle(cplane, center_point, radius))\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\n\\n  Public Class GetCircleRadiusPoint\\n    Inherits GetPoint\\n    Private m_center_point As Point3d\\n\\n    Public Sub New(centerPoint As Point3d)\\n      m_center_point = centerPoint\\n    End Sub\\n\\n    Protected Overrides Sub OnDynamicDraw(e As GetPointDrawEventArgs)\\n      MyBase.OnDynamicDraw(e)\\n      Dim cplane = e.RhinoDoc.Views.ActiveView.ActiveViewport.ConstructionPlane()\\n      Dim radius = m_center_point.DistanceTo(e.CurrentPoint)\\n      Dim circle = New Circle(cplane, m_center_point, radius)\\n      e.Display.DrawCircle(circle, System.Drawing.Color.Black)\\n    End Sub\\n  End Class\\nEnd Namespace","members":[["Rhino.Display.DisplayPipeline","void DrawCircle(Circle circle, Color color)"]]},{"name":"Gettext.vb","code":"Imports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.Commands\\nImports Rhino.Input.Custom\\n\\nNamespace examples_vb\\n  Public Class ReadDimensionTextCommand\\n    Inherits Rhino.Commands.Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbReadDimensionText\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim go = New GetObject()\\n      go.SetCommandPrompt(\\"Select annotation\\")\\n      go.GeometryFilter = ObjectType.Annotation\\n      go.[Get]()\\n      If go.CommandResult() <> Result.Success Then\\n        Return Result.Failure\\n      End If\\n      Dim annotation = TryCast(go.[Object](0).[Object](), AnnotationObjectBase)\\n      If annotation Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      RhinoApp.WriteLine(\\"Annotation text = {0}\\", annotation.DisplayText)\\n\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.DocObjects.AnnotationObjectBase","string DisplayText"]]},{"name":"Hatchcurve.vb","code":"Partial Class Examples\\n  Public Shared Function HatchCurve(doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim go = New Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt(\\"Select closed planar curve\\")\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\\n    go.GeometryAttributeFilter = Rhino.Input.[Custom].GeometryAttributeFilter.ClosedCurve\\n    go.SubObjectSelect = False\\n    go.Get()\\n    If go.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return go.CommandResult()\\n    End If\\n\\n    Dim curve = go.Object(0).Curve()\\n    If curve Is Nothing OrElse Not curve.IsClosed OrElse Not curve.IsPlanar() Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    Dim hatch_name As String = doc.HatchPatterns(doc.HatchPatterns.CurrentHatchPatternIndex).Name\\n    Dim rc = Rhino.Input.RhinoGet.GetString(\\"Hatch pattern\\", True, hatch_name)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n    hatch_name = hatch_name.Trim()\\n    If String.IsNullOrWhiteSpace(hatch_name) Then\\n      Return Rhino.Commands.Result.Nothing\\n    End If\\n    Dim index As Integer = doc.HatchPatterns.Find(hatch_name, True)\\n    If index < 0 Then\\n      Rhino.RhinoApp.WriteLine(\\"Hatch pattern does not exist.\\")\\n      Return Rhino.Commands.Result.Nothing\\n    End If\\n\\n    Dim hatches = Rhino.Geometry.Hatch.Create(curve, index, 0, 1)\\n    For i As Integer = 0 To hatches.Length - 1\\n      doc.Objects.AddHatch(hatches(i))\\n    Next\\n    If hatches.Length > 0 Then\\n      doc.Views.Redraw()\\n    End If\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.RhinoDoc","HatchPatternTable HatchPatterns"],["Rhino.Geometry.Hatch","static Hatch[] Create(Curve curve, int hatchPatternIndex, double rotationRadians, double scale)"],["Rhino.Geometry.Hatch","static Hatch[] Create(Curve curve, int hatchPatternIndex, double rotationRadians, double scale, double tolerance)"],["Rhino.DocObjects.ModelComponent","string Name"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddHatch(Hatch hatch)"],["Rhino.DocObjects.Tables.HatchPatternTable","int CurrentHatchPatternIndex"],["Rhino.DocObjects.Tables.HatchPatternTable","int Find(string name, bool ignoreDeleted)"],["Rhino.DocObjects.Tables.HatchPatternTable","HatchPattern FindName(string name)"]]},{"name":"Insertknot.vb","code":"Imports Rhino.DocObjects\\n\\nPartial Class Examples\\n  Public Shared Function InsertKnot(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim rc As Rhino.Commands.Result\\n    Const filter As ObjectType = Rhino.DocObjects.ObjectType.Curve\\n    Dim objref As Rhino.DocObjects.ObjRef = Nothing\\n    rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select curve for knot insertion\\", False, filter, objref)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n    Dim curve As Rhino.Geometry.Curve = objref.Curve()\\n    If curve Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n    Dim nurb As Rhino.Geometry.NurbsCurve = curve.ToNurbsCurve()\\n    If nurb Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    Dim gp As New Rhino.Input.Custom.GetPoint()\\n    gp.SetCommandPrompt(\\"Point on curve to add knot\\")\\n    gp.Constrain(nurb, False)\\n    gp.[Get]()\\n    If gp.CommandResult() = Rhino.Commands.Result.Success Then\\n      Dim t As Double\\n      Dim crv As Rhino.Geometry.Curve = gp.PointOnCurve(t)\\n      If crv IsNot Nothing AndAlso nurb.Knots.InsertKnot(t) Then\\n        doc.Objects.Replace(objref, nurb)\\n        doc.Views.Redraw()\\n      End If\\n    End If\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Input.Custom.GetPoint","bool Constrain(Curve curve, bool allowPickingPointOffObject)"],["Rhino.Input.Custom.GetPoint","Curve PointOnCurve(out double t)"],["Rhino.Geometry.Collections.NurbsCurveKnotList","bool InsertKnot(double value)"],["Rhino.DocObjects.Tables.ObjectTable","bool Replace(ObjRef objref, Curve curve)"]]},{"name":"Instancedefinitionobjects.vb","code":"Partial Class Examples\\n  Public Shared Function InstanceDefinitionObjects(doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim objref As Rhino.DocObjects.ObjRef = Nothing\\n    Dim rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select instance\\", False, Rhino.DocObjects.ObjectType.InstanceReference, objref)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    Dim iref = TryCast(objref.Object(), Rhino.DocObjects.InstanceObject)\\n    If iref IsNot Nothing Then\\n      Dim idef = iref.InstanceDefinition\\n      If idef IsNot Nothing Then\\n        Dim rhino_objects = idef.GetObjects()\\n        For i As Integer = 0 To rhino_objects.Length - 1\\n          Rhino.RhinoApp.WriteLine(\\"Object {0} = {1}\\", i, rhino_objects(i).Id)\\n        Next\\n      End If\\n    End If\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.DocObjects.InstanceObject","InstanceDefinition InstanceDefinition"],["Rhino.DocObjects.InstanceDefinition","RhinoObject[] GetObjects()"]]},{"name":"Intersectcurves.vb","code":"Partial Class Examples\\n  Public Shared Function IntersectCurves(doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    \' Select two curves to intersect\\n    Dim go = New Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt(\\"Select two curves\\")\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\\n    go.GetMultiple(2, 2)\\n    If go.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return go.CommandResult()\\n    End If\\n\\n    \' Validate input\\n    Dim curveA = go.[Object](0).Curve()\\n    Dim curveB = go.[Object](1).Curve()\\n    If curveA Is Nothing OrElse curveB Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    \' Calculate the intersection\\n    Const intersection_tolerance As Double = 0.001\\n    Const overlap_tolerance As Double = 0.0\\n    Dim events = Rhino.Geometry.Intersect.Intersection.CurveCurve(curveA, curveB, intersection_tolerance, overlap_tolerance)\\n\\n    \' Process the results\\n    If events IsNot Nothing Then\\n      For i As Integer = 0 To events.Count - 1\\n        Dim ccx_event = events(i)\\n        doc.Objects.AddPoint(ccx_event.PointA)\\n        If ccx_event.PointA.DistanceTo(ccx_event.PointB) > Double.Epsilon Then\\n          doc.Objects.AddPoint(ccx_event.PointB)\\n          doc.Objects.AddLine(ccx_event.PointA, ccx_event.PointB)\\n        End If\\n      Next\\n      doc.Views.Redraw()\\n    End If\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Point3f","double DistanceTo(Point3f other)"],["Rhino.Geometry.Point3d","double DistanceTo(Point3d other)"],["Rhino.DocObjects.ObjRef","Curve Curve()"],["Rhino.Geometry.Intersect.Intersection","static CurveIntersections CurveCurve(Curve curveA, Curve curveB, double tolerance, double overlapTolerance)"]]},{"name":"Intersectlinecircle.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.Geometry\\nImports Rhino.Geometry.Intersect\\n\\nNamespace examples_vb\\n  Public Class IntersectLineCircleCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbIntersectLineCircle\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim circle As Circle\\n      Dim rc = Rhino.Input.RhinoGet.GetCircle(circle)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      doc.Objects.AddCircle(circle)\\n      doc.Views.Redraw()\\n\\n      Dim line As Line\\n      rc = Rhino.Input.RhinoGet.GetLine(line)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      doc.Objects.AddLine(line)\\n      doc.Views.Redraw()\\n\\n      Dim t1 As Double, t2 As Double\\n      Dim point1 As Point3d, point2 As Point3d\\n      Dim lineCircleIntersect = Intersection.LineCircle(line, circle, t1, point1, t2, point2)\\n      Dim msg As String = \\"\\"\\n      Select Case lineCircleIntersect\\n        Case LineCircleIntersection.None\\n          msg = \\"line does not intersect circle\\"\\n          Exit Select\\n        Case LineCircleIntersection.[Single]\\n          msg = [String].Format(\\"line intersects circle at point ({0},{1},{2})\\", point1.X, point1.Y, point1.Z)\\n          doc.Objects.AddPoint(point1)\\n          Exit Select\\n        Case LineCircleIntersection.Multiple\\n          msg = [String].Format(\\"line intersects circle at points ({0},{1},{2}) and ({3},{4},{5})\\", point1.X, point1.Y, point1.Z, point2.X, point2.Y, _\\n            point2.Z)\\n          doc.Objects.AddPoint(point1)\\n          doc.Objects.AddPoint(point2)\\n          Exit Select\\n      End Select\\n      RhinoApp.WriteLine(msg)\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Intersect.Intersection","static LineCircleIntersection LineCircle(Line line, Circle circle, out double t1, out Point3d point1, out double t2, out Point3d point2)"]]},{"name":"Intersectlines.vb","code":"Imports Rhino.Geometry\\n\\nPartial Class Examples\\n  Public Shared Function IntersectLines(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim go As New Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt(\\"Select lines\\")\\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\\n    go.GetMultiple(2, 2)\\n    If go.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return go.CommandResult()\\n    End If\\n    If go.ObjectCount <> 2 Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    Dim crv0 As LineCurve = TryCast(go.Object(0).Geometry(), LineCurve)\\n    Dim crv1 As LineCurve = TryCast(go.Object(1).Geometry(), LineCurve)\\n    If crv0 Is Nothing OrElse crv1 Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    Dim line0 As Line = crv0.Line\\n    Dim line1 As Line = crv1.Line\\n    Dim v0 As Vector3d = line0.Direction\\n    v0.Unitize()\\n    Dim v1 As Vector3d = line1.Direction\\n    v1.Unitize()\\n\\n    If v0.IsParallelTo(v1) <> 0 Then\\n      Rhino.RhinoApp.WriteLine(\\"Selected lines are parallel.\\")\\n      Return Rhino.Commands.Result.[Nothing]\\n    End If\\n\\n    Dim a As Double, b As Double\\n    If Not Rhino.Geometry.Intersect.Intersection.LineLine(line0, line1, a, b) Then\\n      Rhino.RhinoApp.WriteLine(\\"No intersection found.\\")\\n      Return Rhino.Commands.Result.[Nothing]\\n    End If\\n\\n    Dim pt0 As Point3d = line0.PointAt(a)\\n    Dim pt1 As Point3d = line1.PointAt(b)\\n    \' pt0 and pt1 should be equal, so we will only add pt0 to the document\\n    doc.Objects.AddPoint(pt0)\\n    doc.Views.Redraw()\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Line","Vector3d Direction"],["Rhino.Geometry.Line","Point3d PointAt(double t)"],["Rhino.Geometry.Vector3d","int IsParallelTo(Vector3d other)"],["Rhino.Geometry.Intersect.Intersection","static bool LineLine(Line lineA, Line lineB, out double a, out double b)"]]},{"name":"Isbrepbox.vb","code":"Partial Class Examples\\n  Public Shared Function IsBrepBox(brep As Rhino.Geometry.Brep) As Boolean\\n    Const zero_tolerance As Double = 0.000001 \' or whatever\\n    Dim rc As Boolean = brep.IsSolid\\n    If rc Then\\n      rc = brep.Faces.Count = 6\\n    End If\\n\\n    Dim N = New Rhino.Geometry.Vector3d(5) {}\\n    Dim i As Integer = 0\\n    While rc AndAlso i < 6\\n      Dim plane As Rhino.Geometry.Plane\\n      rc = brep.Faces(i).TryGetPlane(plane, zero_tolerance)\\n      If rc Then\\n        N(i) = plane.ZAxis\\n        N(i).Unitize()\\n      End If\\n      i += 1\\n    End While\\n\\n    i = 0\\n    While rc AndAlso i < 6\\n      Dim count As Integer = 0\\n      Dim j As Integer = 0\\n      While rc AndAlso j < 6\\n        Dim dot As Double = Math.Abs(N(i) * N(j))\\n        If dot <= zero_tolerance Then\\n          Continue While\\n        End If\\n        If Math.Abs(dot - 1.0) <= zero_tolerance Then\\n          count += 1\\n        Else\\n          rc = False\\n        End If\\n        j += 1\\n      End While\\n\\n      If rc Then\\n        If 2 <> count Then\\n          rc = False\\n        End If\\n      End If\\n      i += 1\\n    End While\\n    Return rc\\n  End Function\\n\\n  Public Shared Function TestBrepBox(doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim obj_ref As Rhino.DocObjects.ObjRef = Nothing\\n    Dim rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select Brep\\", True, Rhino.DocObjects.ObjectType.Brep, obj_ref)\\n    If rc = Rhino.Commands.Result.Success Then\\n      Dim brep = obj_ref.Brep()\\n      If brep IsNot Nothing Then\\n        If IsBrepBox(brep) Then\\n          Rhino.RhinoApp.WriteLine(\\"Yes it is a box\\")\\n        Else\\n          Rhino.RhinoApp.WriteLine(\\"No it is not a box\\")\\n        End If\\n      End If\\n    End If\\n    Return rc\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Brep","bool IsSolid"],["Rhino.Geometry.Surface","bool TryGetPlane(out Plane plane, double tolerance)"]]},{"name":"Isocurvedensity.vb","code":"Partial Class Examples\\n  Public Shared Function IsocurveDensity(doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim objref As Rhino.DocObjects.ObjRef = Nothing\\n    Dim rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select surface\\", False, Rhino.DocObjects.ObjectType.Surface, objref)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    Dim brep_obj = TryCast(objref.Object(), Rhino.DocObjects.BrepObject)\\n    If brep_obj IsNot Nothing Then\\n      brep_obj.Attributes.WireDensity = 3\\n      brep_obj.CommitChanges()\\n      doc.Views.Redraw()\\n    End If\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.DocObjects.ObjectAttributes","int WireDensity"]]},{"name":"Issurfaceinplane.vb","code":"Imports System.Linq\\nImports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.Geometry\\nImports Rhino.Commands\\nImports Rhino.Input\\n\\nNamespace examples_vb\\n  Public Class IsPlanarSurfaceInPlaneCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbIsPlanarSurfaceInPlane\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim obj_ref As ObjRef = Nothing\\n      Dim rc = RhinoGet.GetOneObject(\\"select surface\\", True, ObjectType.Surface, obj_ref)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      Dim surface = obj_ref.Surface()\\n\\n      Dim corners As Point3d() = Nothing\\n      rc = RhinoGet.GetRectangle(corners)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n\\n      Dim plane = New Plane(corners(0), corners(1), corners(2))\\n\\n      Dim is_or_isnt = If(IsSurfaceInPlane(surface, plane, doc.ModelAbsoluteTolerance), \\"\\", \\" not \\")\\n      RhinoApp.WriteLine(\\"Surface is{0} in plane.\\", is_or_isnt)\\n      Return Result.Success\\n    End Function\\n\\n    Private Function IsSurfaceInPlane(surface As Surface, plane As Plane, tolerance As Double) As Boolean\\n      If Not surface.IsPlanar(tolerance) Then\\n        Return False\\n      End If\\n\\n      Dim bbox = surface.GetBoundingBox(True)\\n      Return bbox.GetCorners().All(Function(corner) Math.Abs(plane.DistanceTo(corner)) <= tolerance)\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Plane","double DistanceTo(Point3d testPoint)"],["Rhino.Geometry.Surface","bool IsPlanar()"]]},{"name":"Leader.vb","code":"Imports Rhino\\nImports Rhino.Geometry\\nImports Rhino.Commands\\nImports System.Collections.Generic\\nImports System.Linq\\n\\nNamespace examples_vb\\n  Public Class LeaderCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbLeader\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim points = New List(Of Point3d)() From { _\\n        New Point3d(1, 1, 0), _\\n        New Point3d(5, 1, 0), _\\n        New Point3d(5, 5, 0), _\\n        New Point3d(9, 5, 0) _\\n      }\\n\\n      Dim xyPlane = Plane.WorldXY\\n\\n      Dim points2d = New List(Of Point2d)()\\n      For Each point3d As Point3d In points\\n        Dim x As Double, y As Double\\n        If xyPlane.ClosestParameter(point3d, x, y) Then\\n          Dim point2d = New Point2d(x, y)\\n          If points2d.Count < 1 OrElse point2d.DistanceTo(points2d.Last()) > RhinoMath.SqrtEpsilon Then\\n            points2d.Add(point2d)\\n          End If\\n        End If\\n      Next\\n\\n      doc.Objects.AddLeader(xyPlane, points2d)\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Point2d","double DistanceTo(Point2d other)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddLeader(Plane plane, IEnumerable<Point2d> points)"]]},{"name":"Locklayer.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports System.Linq\\n\\nNamespace examples_vb\\n  Public Class LockLayerCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbLockLayer\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim layerName As String = \\"\\"\\n      Dim rc = Rhino.Input.RhinoGet.GetString(\\"Name of layer to lock\\", True, layerName)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      If [String].IsNullOrWhiteSpace(layerName) Then\\n        Return Result.[Nothing]\\n      End If\\n\\n      \' because of sublayers it\'s possible that mone than one layer has the same name\\n      \' so simply calling doc.Layers.Find(layerName) isn\'t good enough.  If \\"layerName\\" returns\\n      \' more than one layer then present them to the user and let him decide.\\n      Dim matchingLayers = (From layer In doc.Layers Where layer.Name = layerName Select layer).ToList()\\n\\n      Dim layerToLock As Rhino.DocObjects.Layer = Nothing\\n      If matchingLayers.Count = 0 Then\\n        RhinoApp.WriteLine([String].Format(\\"Layer \\"\\"{0}\\"\\" does not exist.\\", layerName))\\n        Return Result.[Nothing]\\n      ElseIf matchingLayers.Count = 1 Then\\n        layerToLock = matchingLayers(0)\\n      ElseIf matchingLayers.Count > 1 Then\\n        For i As Integer = 0 To matchingLayers.Count - 1\\n          RhinoApp.WriteLine([String].Format(\\"({0}) {1}\\", i + 1, matchingLayers(i).FullPath.Replace(\\"::\\", \\"->\\")))\\n        Next\\n        Dim selectedLayer As Integer = -1\\n        rc = Rhino.Input.RhinoGet.GetInteger(\\"which layer?\\", True, selectedLayer)\\n        If rc <> Result.Success Then\\n          Return rc\\n        End If\\n        If selectedLayer > 0 AndAlso selectedLayer <= matchingLayers.Count Then\\n          layerToLock = matchingLayers(selectedLayer - 1)\\n        Else\\n          Return Result.[Nothing]\\n        End If\\n      End If\\n\\n      If layerToLock Is Nothing Then\\n        Return Result.Nothing\\n      End If\\n\\n      If Not layerToLock.IsLocked Then\\n        layerToLock.IsLocked = True\\n        layerToLock.CommitChanges()\\n        Return Result.Success\\n      Else\\n        RhinoApp.WriteLine([String].Format(\\"layer {0} is already locked.\\", layerToLock.FullPath))\\n        Return Result.[Nothing]\\n      End If\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.DocObjects.Layer","string FullPath"],["Rhino.DocObjects.Layer","bool IsLocked"],["Rhino.DocObjects.Layer","bool CommitChanges()"]]},{"name":"Loft.vb","code":"Imports Rhino\\nImports Rhino.Input.Custom\\nImports Rhino.DocObjects\\nImports Rhino.Commands\\nImports System.Collections.Generic\\nImports Rhino.Geometry\\n\\nNamespace examples_vb\\n  Public Class LoftCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbLoft\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As Rhino.Commands.RunMode) As Result\\n      \' select curves to loft\\n      Dim gs = New GetObject()\\n      gs.SetCommandPrompt(\\"select curves to loft\\")\\n      gs.GeometryFilter = ObjectType.Curve\\n      gs.DisablePreSelect()\\n      gs.SubObjectSelect = False\\n      gs.GetMultiple(2, 0)\\n      If gs.CommandResult() <> Result.Success Then\\n        Return gs.CommandResult()\\n      End If\\n\\n      Dim curves = New List(Of Curve)()\\n      For Each obj As ObjRef In gs.Objects()\\n        curves.Add(obj.Curve())\\n      Next\\n\\n      Dim breps = Rhino.Geometry.Brep.CreateFromLoft(curves, Point3d.Unset, Point3d.Unset, LoftType.Tight, False)\\n      For Each brep As Brep In breps\\n        doc.Objects.AddBrep(brep)\\n      Next\\n\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Brep","static Brep[] CreateFromLoft(IEnumerable<Curve> curves, Point3d start, Point3d end, LoftType loftType, bool closed)"]]},{"name":"Makerhinocontours.vb","code":"Imports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.Geometry\\nImports Rhino.Input\\nImports Rhino.Input.Custom\\nImports Rhino.Commands\\n\\nNamespace examples_vb\\n  Public Class ContourCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbContour\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim filter = ObjectType.Surface Or ObjectType.PolysrfFilter Or ObjectType.Mesh\\n      Dim obj_refs As ObjRef() = Nothing\\n      Dim rc = RhinoGet.GetMultipleObjects(\\"Select objects to contour\\", False, filter, obj_refs)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n\\n      Dim gp = New GetPoint()\\n      gp.SetCommandPrompt(\\"Contour plane base point\\")\\n      gp.[Get]()\\n      If gp.CommandResult() <> Result.Success Then\\n        Return gp.CommandResult()\\n      End If\\n      Dim base_point = gp.Point()\\n\\n      gp.DrawLineFromPoint(base_point, True)\\n      gp.SetCommandPrompt(\\"Direction perpendicular to contour planes\\")\\n      gp.[Get]()\\n      If gp.CommandResult() <> Result.Success Then\\n        Return gp.CommandResult()\\n      End If\\n      Dim end_point = gp.Point()\\n\\n      If base_point.DistanceTo(end_point) < RhinoMath.ZeroTolerance Then\\n        Return Result.[Nothing]\\n      End If\\n\\n      Dim distance As Double = 1.0\\n      rc = RhinoGet.GetNumber(\\"Distance between contours\\", False, distance)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n\\n      Dim interval = Math.Abs(distance)\\n\\n      Dim curves As Curve() = Nothing\\n      For Each obj_ref As ObjRef In obj_refs\\n        Dim geometry = obj_ref.Geometry()\\n        If geometry Is Nothing Then\\n          Return Result.Failure\\n        End If\\n\\n        If TypeOf geometry Is Brep Then\\n          curves = Brep.CreateContourCurves(TryCast(geometry, Brep), base_point, end_point, interval)\\n        Else\\n          curves = Mesh.CreateContourCurves(TryCast(geometry, Mesh), base_point, end_point, interval)\\n        End If\\n\\n        For Each curve As Curve In curves\\n          Dim curve_object_id = doc.Objects.AddCurve(curve)\\n          doc.Objects.[Select](curve_object_id)\\n        Next\\n      Next\\n\\n      If curves IsNot Nothing Then\\n        doc.Views.Redraw()\\n      End If\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Brep","static Curve[] CreateContourCurves(Brep brepToContour, Point3d contourStart, Point3d contourEnd, double interval)"],["Rhino.Geometry.Mesh","static Curve[] CreateContourCurves(Mesh meshToContour, Point3d contourStart, Point3d contourEnd, double interval)"]]},{"name":"Meshdrawing.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.Display\\nImports Rhino.Geometry\\nImports Rhino.Input.Custom\\nImports Rhino.DocObjects\\nImports System.Drawing\\n\\nNamespace examples_vb\\n  Public Class MeshDrawingCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbDrawMesh\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim gs = New GetObject()\\n      gs.SetCommandPrompt(\\"select sphere\\")\\n      gs.GeometryFilter = ObjectType.Surface\\n      gs.DisablePreSelect()\\n      gs.SubObjectSelect = False\\n      gs.[Get]()\\n      If gs.CommandResult() <> Result.Success Then\\n        Return gs.CommandResult()\\n      End If\\n\\n      Dim sphere As Sphere\\n      gs.[Object](0).Surface().TryGetSphere(sphere)\\n      If sphere.IsValid Then\\n        Dim mesh__1 = Mesh.CreateFromSphere(sphere, 10, 10)\\n        If mesh__1 Is Nothing Then\\n          Return Result.Failure\\n        End If\\n        Dim conduit = New DrawBlueMeshConduit(mesh__1)\\n        conduit.Enabled = True\\n\\n        doc.Views.Redraw()\\n\\n        Dim inStr As String = \\"\\"\\n        Rhino.Input.RhinoGet.GetString(\\"press <Enter> to continue\\", True, inStr)\\n\\n        conduit.Enabled = False\\n        doc.Views.Redraw()\\n        Return Result.Success\\n      Else\\n        Return Result.Failure\\n      End If\\n    End Function\\n  End Class\\n\\n  Class DrawBlueMeshConduit\\n    Inherits DisplayConduit\\n    Private _mesh As Mesh = Nothing\\n    Private _color As Color\\n    Private _material As DisplayMaterial = Nothing\\n    Private _bbox As BoundingBox\\n\\n    Public Sub New(mesh As Mesh)\\n      \' set up as much data as possible so we do the minimum amount of work possible inside\\n      \' the actual display code\\n      _mesh = mesh\\n      _color = System.Drawing.Color.Blue\\n      _material = New DisplayMaterial()\\n      _material.Diffuse = _color\\n      If _mesh IsNot Nothing AndAlso _mesh.IsValid Then\\n        _bbox = _mesh.GetBoundingBox(True)\\n      End If\\n    End Sub\\n\\n    \' this is called every frame inside the drawing code so try to do as little as possible\\n    \' in order to not degrade display speed. Don\'t create new objects if you don\'t have to as this\\n    \' will incur an overhead on the heap and garbage collection.\\n    Protected Overrides Sub CalculateBoundingBox(e As CalculateBoundingBoxEventArgs)\\n      MyBase.CalculateBoundingBox(e)\\n      \' Since we are dynamically drawing geometry, we needed to override\\n      \' CalculateBoundingBox. Otherwise, there is a good chance that our\\n      \' dynamically drawing geometry would get clipped.\\n\\n      \' Union the mesh\'s bbox with the scene\'s bounding box\\n      e.IncludeBoundingBox(_bbox)\\n    End Sub\\n\\n    Protected Overrides Sub PreDrawObjects(e As DrawEventArgs)\\n      MyBase.PreDrawObjects(e)\\n      Dim vp = e.Display.Viewport\\n      If vp.DisplayMode.EnglishName.ToLower() = \\"wireframe\\" Then\\n        e.Display.DrawMeshWires(_mesh, _color)\\n      Else\\n        e.Display.DrawMeshShaded(_mesh, _material)\\n      End If\\n    End Sub\\n  End Class\\nEnd Namespace","members":[["Rhino.Display.DisplayPipeline","void DrawMeshShaded(Mesh mesh, DisplayMaterial material)"],["Rhino.Display.DisplayPipeline","void DrawMeshWires(Mesh mesh, Color color)"]]},{"name":"Meshvolume.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.Input.Custom\\nImports Rhino.Geometry\\nImports Rhino.DocObjects\\n\\nNamespace examples_vb\\n  Public Class MeshVolumeCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbMeshVolume\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim gm = New GetObject()\\n      gm.SetCommandPrompt(\\"Select solid meshes for volume calculation\\")\\n      gm.GeometryFilter = ObjectType.Mesh\\n      gm.GeometryAttributeFilter = GeometryAttributeFilter.ClosedMesh\\n      gm.SubObjectSelect = False\\n      gm.GroupSelect = True\\n      gm.GetMultiple(1, 0)\\n      If gm.CommandResult() <> Result.Success Then\\n        Return gm.CommandResult()\\n      End If\\n\\n      Dim volume As Double = 0.0\\n      Dim volume_error As Double = 0.0\\n      For Each obj_ref As ObjRef In gm.Objects()\\n        If obj_ref.Mesh() IsNot Nothing Then\\n          Dim mass_properties = VolumeMassProperties.Compute(obj_ref.Mesh())\\n          If mass_properties IsNot Nothing Then\\n            volume += mass_properties.Volume\\n            volume_error += mass_properties.VolumeError\\n          End If\\n        End If\\n      Next\\n\\n      RhinoApp.WriteLine(\\"Total volume = {0:f} (+/- {1:f})\\", volume, volume_error)\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.VolumeMassProperties","double Volume"],["Rhino.Geometry.VolumeMassProperties","double VolumeError"]]},{"name":"Modifylightcolor.vb","code":"Imports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.Commands\\nImports Rhino.Input\\nImports Rhino.UI\\n\\nNamespace examples_vb\\n  Public Class ChangeLightColorCommand\\n    Inherits Rhino.Commands.Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbLightColor\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim obj_ref As ObjRef = Nothing\\n      Dim rc = RhinoGet.GetOneObject(\\"Select light to change color\\", True, ObjectType.Light, obj_ref)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      Dim light = obj_ref.Light()\\n      If light Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      Dim diffuse_color = light.Diffuse\\n      If Dialogs.ShowColorDialog(diffuse_color) Then\\n        light.Diffuse = diffuse_color\\n      End If\\n\\n      doc.Lights.Modify(obj_ref.ObjectId, light)\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Light","Color Diffuse"],["Rhino.UI.Dialogs","static bool ShowColorDialog(ref Color color)"],["Rhino.DocObjects.Tables.LightTable","bool Modify(Guid id, Light light)"]]},{"name":"Modifyobjectcolor.vb","code":"Imports System.Drawing\\nImports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.Geometry\\nImports Rhino.Input\\nImports Rhino.Commands\\n\\nNamespace examples_vb\\n  Public Class ModifyObjectColorCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbModifyObjectColor\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim obj_ref As ObjRef = Nothing\\n      Dim rc = RhinoGet.GetOneObject(\\"Select object\\", False, ObjectType.AnyObject, obj_ref)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      Dim rhino_object = obj_ref.[Object]()\\n      Dim color__1 = rhino_object.Attributes.ObjectColor\\n      Dim b As Boolean = Rhino.UI.Dialogs.ShowColorDialog(color__1)\\n      If Not b Then\\n        Return Result.Cancel\\n      End If\\n\\n      rhino_object.Attributes.ObjectColor = color__1\\n      rhino_object.Attributes.ColorSource = ObjectColorSource.ColorFromObject\\n      rhino_object.CommitChanges()\\n\\n      \' an object\'s color attributes can also be specified\\n      \' when the object is added to Rhino\\n      Dim sphere = New Sphere(Point3d.Origin, 5.0)\\n      Dim attributes = New ObjectAttributes()\\n      attributes.ObjectColor = Color.CadetBlue\\n      attributes.ColorSource = ObjectColorSource.ColorFromObject\\n      doc.Objects.AddSphere(sphere, attributes)\\n\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.DocObjects.ObjectAttributes","ObjectColorSource ColorSource"],["Rhino.DocObjects.ObjectAttributes","Color ObjectColor"]]},{"name":"Moveobjectstocurrentlayer.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.DocObjects\\n\\nNamespace examples_vb\\n  Public Class MoveSelectedObjectsToCurrentLayerCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbMoveSelectedObjectsToCurrentLayer\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      \' all non-light objects that are selected\\n      Dim object_enumerator_settings = New ObjectEnumeratorSettings()\\n      object_enumerator_settings.IncludeLights = False\\n      object_enumerator_settings.IncludeGrips = True\\n      object_enumerator_settings.NormalObjects = True\\n      object_enumerator_settings.LockedObjects = True\\n      object_enumerator_settings.HiddenObjects = True\\n      object_enumerator_settings.ReferenceObjects = True\\n      object_enumerator_settings.SelectedObjectsFilter = True\\n      Dim selected_objects = doc.Objects.GetObjectList(object_enumerator_settings)\\n\\n      Dim current_layer_index = doc.Layers.CurrentLayerIndex\\n      For Each selected_object As RhinoObject In selected_objects\\n        selected_object.Attributes.LayerIndex = current_layer_index\\n        selected_object.CommitChanges()\\n      Next\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.DocObjects.ObjectAttributes","int LayerIndex"],["Rhino.DocObjects.Tables.LayerTable","int CurrentLayerIndex"]]},{"name":"Nurbscurveincreasedegree.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.Input\\nImports Rhino.DocObjects\\n\\nNamespace examples_vb\\n  Public Class NurbsCurveIncreaseDegreeCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbNurbsCrvIncreaseDegree\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim obj_ref As ObjRef\\n      Dim rc = RhinoGet.GetOneObject(\\"Select curve\\", False, ObjectType.Curve, obj_ref)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      If obj_ref Is Nothing Then\\n        Return Result.Failure\\n      End If\\n      Dim curve = obj_ref.Curve()\\n      If curve Is Nothing Then\\n        Return Result.Failure\\n      End If\\n      Dim nurbs_curve = curve.ToNurbsCurve()\\n\\n      Dim new_degree As Integer = -1\\n      rc = RhinoGet.GetInteger(String.Format(\\"New degree <{0}...11>\\", nurbs_curve.Degree), True, new_degree, nurbs_curve.Degree, 11)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n\\n      rc = Result.Failure\\n      If nurbs_curve.IncreaseDegree(new_degree) Then\\n        If doc.Objects.Replace(obj_ref.ObjectId, nurbs_curve) Then\\n          rc = Result.Success\\n        End If\\n      End If\\n\\n      RhinoApp.WriteLine(\\"Result: {0}\\", rc.ToString())\\n      doc.Views.Redraw()\\n      Return rc\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.NurbsCurve","bool IncreaseDegree(int desiredDegree)"]]},{"name":"Nurbssurfaceincreasedegree.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.Input\\nImports Rhino.DocObjects\\n\\nNamespace examples_vb\\n  Public Class NurbsSurfaceIncreaseDegreeCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbNurbsSrfIncreaseDegree\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim obj_ref As ObjRef\\n      Dim rc = RhinoGet.GetOneObject(\\"Select surface\\", False, ObjectType.Surface, obj_ref)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      If obj_ref Is Nothing Then\\n        Return Result.Failure\\n      End If\\n      Dim surface = obj_ref.Surface()\\n      If surface Is Nothing Then\\n        Return Result.Failure\\n      End If\\n      Dim nurbs_surface = surface.ToNurbsSurface()\\n\\n      Dim new_u_degree As Integer = -1\\n      rc = RhinoGet.GetInteger(String.Format(\\"New U degree <{0}...11>\\", nurbs_surface.Degree(0)), True, new_u_degree, nurbs_surface.Degree(0), 11)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n\\n      Dim new_v_degree As Integer = -1\\n      rc = RhinoGet.GetInteger(String.Format(\\"New V degree <{0}...11>\\", nurbs_surface.Degree(1)), True, new_v_degree, nurbs_surface.Degree(1), 11)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n\\n      rc = Result.Failure\\n      If nurbs_surface.IncreaseDegreeU(new_u_degree) Then\\n        If nurbs_surface.IncreaseDegreeV(new_v_degree) Then\\n          If doc.Objects.Replace(obj_ref.ObjectId, nurbs_surface) Then\\n            rc = Result.Success\\n          End If\\n        End If\\n      End If\\n\\n      RhinoApp.WriteLine(\\"Result: {0}\\", rc.ToString())\\n      doc.Views.Redraw()\\n      Return rc\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.NurbsSurface","bool IncreaseDegreeU(int desiredDegree)"],["Rhino.Geometry.NurbsSurface","bool IncreaseDegreeV(int desiredDegree)"]]},{"name":"Objectdecoration.vb","code":"Partial Class Examples\\n  Public Shared Function ObjectDecoration(doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    \' Define a line\\n    Dim line = New Rhino.Geometry.Line(New Rhino.Geometry.Point3d(0, 0, 0), New Rhino.Geometry.Point3d(10, 0, 0))\\n\\n    \' Make a copy of Rhino\'s default object attributes\\n    Dim attribs = doc.CreateDefaultAttributes()\\n\\n    \' Modify the object decoration style\\n    attribs.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.BothArrowhead\\n\\n    \' Create a new curve object with our attributes\\n    doc.Objects.AddLine(line, attribs)\\n    doc.Views.Redraw()\\n\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.RhinoDoc","DocObjects.ObjectAttributes CreateDefaultAttributes()"]]},{"name":"Objectdisplaymode.vb","code":"Imports Rhino\\nImports Rhino.DocObjects\\n\\nPartial Class Examples\\n  Public Shared Function ObjectDisplayMode(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim rc As Rhino.Commands.Result\\n    Const filter As ObjectType = ObjectType.Mesh Or ObjectType.Brep\\n    Dim objref As ObjRef = Nothing\\n    rc = Rhino.Input.RhinoGet.GetOneObject(\\"Select mesh or surface\\", True, filter, objref)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n    Dim viewportId As Guid = doc.Views.ActiveView.ActiveViewportID\\n\\n    Dim attr As ObjectAttributes = objref.[Object]().Attributes\\n    If attr.HasDisplayModeOverride(viewportId) Then\\n      RhinoApp.WriteLine(\\"Removing display mode override from object\\")\\n      attr.RemoveDisplayModeOverride(viewportId)\\n    Else\\n      Dim modes As Rhino.Display.DisplayModeDescription() = Rhino.Display.DisplayModeDescription.GetDisplayModes()\\n      Dim mode As Rhino.Display.DisplayModeDescription = Nothing\\n      If modes.Length = 1 Then\\n        mode = modes(0)\\n      Else\\n        Dim go As New Rhino.Input.Custom.GetOption()\\n        go.SetCommandPrompt(\\"Select display mode\\")\\n        Dim str_modes As String() = New String(modes.Length - 1) {}\\n        For i As Integer = 0 To modes.Length - 1\\n          str_modes(i) = modes(i).EnglishName.Replace(\\" \\", \\"\\").Replace(\\"-\\", \\"\\")\\n        Next\\n        go.AddOptionList(\\"DisplayMode\\", str_modes, 0)\\n        If go.[Get]() = Rhino.Input.GetResult.[Option] Then\\n          mode = modes(go.[Option]().CurrentListOptionIndex)\\n        End If\\n      End If\\n      If mode Is Nothing Then\\n        Return Rhino.Commands.Result.Cancel\\n      End If\\n      attr.SetDisplayModeOverride(mode, viewportId)\\n    End If\\n    doc.Objects.ModifyAttributes(objref, attr, False)\\n    doc.Views.Redraw()\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.DocObjects.ObjectAttributes","bool HasDisplayModeOverride(Guid viewportId)"],["Rhino.DocObjects.ObjectAttributes","void RemoveDisplayModeOverride(Guid rhinoViewportId)"],["Rhino.DocObjects.ObjectAttributes","bool SetDisplayModeOverride(DisplayModeDescription mode, Guid rhinoViewportId)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionList(LocalizeStringPair optionName, IEnumerable<LocalizeStringPair> listValues, int listCurrentIndex)"],["Rhino.Input.Custom.GetBaseClass","int AddOptionList(string englishOptionName, IEnumerable<string> listValues, int listCurrentIndex)"]]},{"name":"Objectiterator.vb","code":"\\nImports Rhino\\nImports Rhino.Commands\\nImports Rhino.DocObjects\\n\\nNamespace examples_vb\\n  Public Class ObjectEnumeratorCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbObjectEnumerator\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim object_enumerator_settings = New ObjectEnumeratorSettings()\\n      object_enumerator_settings.IncludeLights = True\\n      object_enumerator_settings.IncludeGrips = False\\n      Dim rhino_objects = doc.Objects.GetObjectList(object_enumerator_settings)\\n\\n      Dim count As Integer = 0\\n      For Each rhino_object As RhinoObject In rhino_objects\\n        If rhino_object.IsSelectable() AndAlso rhino_object.IsSelected(False) = 0 Then\\n          rhino_object.[Select](True)\\n          count += 1\\n        End If\\n      Next\\n      If count > 0 Then\\n        doc.Views.Redraw()\\n        RhinoApp.WriteLine(\\"{0} object{1} selected\\", count, If(count = 1, \\"\\", \\"s\\"))\\n      End If\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.DocObjects.ObjectEnumeratorSettings","bool IncludeGrips"],["Rhino.DocObjects.ObjectEnumeratorSettings","bool IncludeLights"]]},{"name":"Orientonsrf.vb","code":"Partial Class Examples\\n  Public Shared Function OrientOnSrf(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    \' Select objects to orient\\n    Dim go As New Rhino.Input.Custom.GetObject()\\n    go.SetCommandPrompt(\\"Select objects to orient\\")\\n    go.SubObjectSelect = False\\n    go.GroupSelect = True\\n    go.GetMultiple(1, 0)\\n    If go.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return go.CommandResult()\\n    End If\\n\\n    \' Point to orient from\\n    Dim gp As New Rhino.Input.Custom.GetPoint()\\n    gp.SetCommandPrompt(\\"Point to orient from\\")\\n    gp.Get()\\n    If gp.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return gp.CommandResult()\\n    End If\\n\\n    \' Define source plane\\n    Dim view As Rhino.Display.RhinoView = gp.View()\\n    If view Is Nothing Then\\n      view = doc.Views.ActiveView\\n      If view Is Nothing Then\\n        Return Rhino.Commands.Result.Failure\\n      End If\\n    End If\\n    Dim source_plane As Rhino.Geometry.Plane = view.ActiveViewport.ConstructionPlane()\\n    source_plane.Origin = gp.Point()\\n\\n    \' Surface to orient on\\n    Dim gs As New Rhino.Input.Custom.GetObject()\\n    gs.SetCommandPrompt(\\"Surface to orient on\\")\\n    gs.GeometryFilter = Rhino.DocObjects.ObjectType.Surface\\n    gs.SubObjectSelect = True\\n    gs.DeselectAllBeforePostSelect = False\\n    gs.OneByOnePostSelect = True\\n    gs.Get()\\n    If gs.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return gs.CommandResult()\\n    End If\\n\\n    Dim objref As Rhino.DocObjects.ObjRef = gs.[Object](0)\\n    \' get selected surface object\\n    Dim obj As Rhino.DocObjects.RhinoObject = objref.[Object]()\\n    If obj Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n    \' get selected surface (face)\\n    Dim surface As Rhino.Geometry.Surface = objref.Surface()\\n    If surface Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n    \' Unselect surface\\n    obj.[Select](False)\\n\\n    \' Point on surface to orient to\\n    gp.SetCommandPrompt(\\"Point on surface to orient to\\")\\n    gp.Constrain(surface, False)\\n    gp.Get()\\n    If gp.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return gp.CommandResult()\\n    End If\\n\\n    \' Do transformation\\n    Dim rc As Rhino.Commands.Result = Rhino.Commands.Result.Failure\\n    Dim u As Double, v As Double\\n    If surface.ClosestPoint(gp.Point(), u, v) Then\\n      Dim target_plane As Rhino.Geometry.Plane\\n      If surface.FrameAt(u, v, target_plane) Then\\n        \' Build transformation\\n        Dim xform As Rhino.Geometry.Transform = Rhino.Geometry.Transform.PlaneToPlane(source_plane, target_plane)\\n\\n        \' Do the transformation. In this example, we will copy the original objects\\n        Const delete_original As Boolean = False\\n        For i As Integer = 0 To go.ObjectCount - 1\\n          doc.Objects.Transform(go.[Object](i), xform, delete_original)\\n        Next\\n\\n        doc.Views.Redraw()\\n        rc = Rhino.Commands.Result.Success\\n      End If\\n    End If\\n    Return rc\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Surface","bool ClosestPoint(Point3d testPoint, out double u, out double v)"],["Rhino.Geometry.Surface","bool FrameAt(double u, double v, out Plane frame)"],["Rhino.DocObjects.RhinoObject","int Select(bool on)"],["Rhino.DocObjects.ObjRef","RhinoObject Object()"],["Rhino.DocObjects.ObjRef","Surface Surface()"],["Rhino.Input.Custom.GetObject","bool DeselectAllBeforePostSelect"],["Rhino.Input.Custom.GetObject","ObjectType GeometryFilter"],["Rhino.Input.Custom.GetObject","bool GroupSelect"],["Rhino.Input.Custom.GetObject","bool OneByOnePostSelect"],["Rhino.Input.Custom.GetObject","bool SubObjectSelect"],["Rhino.Input.Custom.GetObject","ObjRef Object(int index)"],["Rhino.Input.Custom.GetPoint","bool Constrain(Surface surface, bool allowPickingPointOffObject)"],["Rhino.DocObjects.Tables.ObjectTable","Guid Transform(ObjRef objref, Transform xform, bool deleteOriginal)"]]},{"name":"Ortho.vb","code":"Imports Rhino\\nImports Rhino.ApplicationSettings\\nImports Rhino.Commands\\nImports Rhino.Input.Custom\\n\\nNamespace examples_vb\\n  Public Class OrthoCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbOrtho\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim gp = New GetPoint()\\n      gp.SetCommandPrompt(\\"Start of line\\")\\n      gp.[Get]()\\n      If gp.CommandResult() <> Result.Success Then\\n        Return gp.CommandResult()\\n      End If\\n      Dim start_point = gp.Point()\\n\\n      Dim original_ortho = ModelAidSettings.Ortho\\n      If Not original_ortho Then\\n        ModelAidSettings.Ortho = True\\n      End If\\n\\n      gp.SetCommandPrompt(\\"End of line\\")\\n      gp.SetBasePoint(start_point, False)\\n      gp.DrawLineFromPoint(start_point, True)\\n      gp.[Get]()\\n      If gp.CommandResult() <> Result.Success Then\\n        Return gp.CommandResult()\\n      End If\\n      Dim end_point = gp.Point()\\n\\n      If ModelAidSettings.Ortho <> original_ortho Then\\n        ModelAidSettings.Ortho = original_ortho\\n      End If\\n\\n      doc.Objects.AddLine(start_point, end_point)\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.ApplicationSettings.ModelAidSettings","static bool Ortho"]]},{"name":"Planesurface.vb","code":"Imports Rhino\\nImports Rhino.Geometry\\nImports Rhino.Commands\\n\\nNamespace examples_vb\\n  Public Class PlaneSurfaceCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbPlaneSurface\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim corners As Point3d() = Nothing\\n      Dim rc = Input.RhinoGet.GetRectangle(corners)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n\\n      Dim plane = New Plane(corners(0), corners(1), corners(2))\\n      Dim plane_surface = New PlaneSurface(plane, New Interval(0, corners(0).DistanceTo(corners(1))), New Interval(0, corners(1).DistanceTo(corners(2))))\\n      doc.Objects.Add(plane_surface)\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.PlaneSurface","PlaneSurface(Plane plane, Interval xExtents, Interval yExtents)"]]},{"name":"Pointatcursor.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.DocObjects\\n\\nNamespace examples_vb\\n  Public Class PointAtCursorCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbPointAtCursor\\"\\n      End Get\\n    End Property\\n\\n    <System.Runtime.InteropServices.DllImport(\\"user32.dll\\")> _\\n    Public Shared Function GetCursorPos(ByRef point As System.Drawing.Point) As Boolean\\n    End Function\\n\\n    <System.Runtime.InteropServices.DllImport(\\"user32.dll\\")> _\\n    Public Shared Function ScreenToClient(hWnd As IntPtr, ByRef point As System.Drawing.Point) As Boolean\\n    End Function\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim result__1 = Result.Failure\\n      Dim view = doc.Views.ActiveView\\n      If view Is Nothing Then\\n        Return result__1\\n      End If\\n\\n      Dim windowsDrawingPoint As System.Drawing.Point\\n      If Not GetCursorPos(windowsDrawingPoint) OrElse Not ScreenToClient(view.Handle, windowsDrawingPoint) Then\\n        Return result__1\\n      End If\\n\\n      Dim xform = view.ActiveViewport.GetTransform(CoordinateSystem.Screen, CoordinateSystem.World)\\n      Dim point = New Rhino.Geometry.Point3d(windowsDrawingPoint.X, windowsDrawingPoint.Y, 0.0)\\n      RhinoApp.WriteLine([String].Format(\\"screen point: ({0}, {1}, {2})\\", point.X, point.Y, point.Z))\\n      point.Transform(xform)\\n      RhinoApp.WriteLine([String].Format(\\"world point: ({0}, {1}, {2})\\", point.X, point.Y, point.Z))\\n      result__1 = Result.Success\\n      Return result__1\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Point3d","void Transform(Transform xform)"],["Rhino.Display.RhinoViewport","Transform GetTransform(CoordinateSystem sourceSystem, CoordinateSystem destinationSystem)"]]},{"name":"Principalcurvature.vb","code":"Imports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.Input\\nImports Rhino.Commands\\n\\nNamespace examples_vb\\n  Public Class PrincipalCurvatureCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbPrincipalCurvature\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim obj_ref As ObjRef = Nothing\\n      Dim rc = RhinoGet.GetOneObject(\\"Select surface for curvature measurement\\", True,\\n                                     ObjectType.Surface, obj_ref)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      Dim surface = obj_ref.Surface()\\n\\n      Dim gp = New Rhino.Input.Custom.GetPoint()\\n      gp.SetCommandPrompt(\\"Select point on surface for curvature measurement\\")\\n      gp.Constrain(surface, False)\\n      gp.[Get]()\\n      If gp.CommandResult() <> Result.Success Then\\n        Return gp.CommandResult()\\n      End If\\n      Dim point_on_surface = gp.Point()\\n\\n      Dim u As Double, v As Double\\n      If Not surface.ClosestPoint(point_on_surface, u, v) Then\\n        Return Result.Failure\\n      End If\\n\\n      Dim surface_curvature = surface.CurvatureAt(u, v)\\n      If surface_curvature Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      RhinoApp.WriteLine(\\"Surface curvature evaluation at parameter: ({0}, {1})\\", u, v)\\n\\n      RhinoApp.WriteLine(\\"  3-D Point: {0}\\", surface_curvature.Point)\\n      RhinoApp.WriteLine(\\"  3-D Normal: {0}\\", surface_curvature.Normal)\\n      RhinoApp.WriteLine(\\"  Maximum principal curvature: {0} ({1})\\", surface_curvature.Kappa(0), surface_curvature.Direction(0))\\n      RhinoApp.WriteLine(\\"  Minimum principal curvature: {0} ({1})\\", surface_curvature.Kappa(1), surface_curvature.Direction(1))\\n      RhinoApp.WriteLine(\\"  Gaussian curvature: {0}\\", surface_curvature.Gaussian)\\n      RhinoApp.WriteLine(\\"  Mean curvature: {0}\\", surface_curvature.Mean)\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.SurfaceCurvature","double Gaussian"],["Rhino.Geometry.SurfaceCurvature","double Mean"],["Rhino.Geometry.SurfaceCurvature","Vector3d Normal"],["Rhino.Geometry.SurfaceCurvature","Point3d Point"],["Rhino.Geometry.SurfaceCurvature","Vector3d Direction(int direction)"],["Rhino.Geometry.SurfaceCurvature","double Kappa(int direction)"],["Rhino.Geometry.Surface","SurfaceCurvature CurvatureAt(double u, double v)"]]},{"name":"Printinstancedefinitiontree.vb","code":"Imports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.FileIO\\nImports Rhino.Commands\\n\\nNamespace examples_vb\\n  Public Class InstanceDefinitionTreeCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbInstanceDefinitionTree\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim instanceDefinitions = doc.InstanceDefinitions\\n      Dim instanceDefinitionCount = instanceDefinitions.Count\\n\\n      If instanceDefinitionCount = 0 Then\\n        RhinoApp.WriteLine(\\"Document contains no instance definitions.\\")\\n        Return Result.[Nothing]\\n      End If\\n\\n      Dim dump = New TextLog()\\n      dump.IndentSize = 4\\n\\n      For i As Integer = 0 To instanceDefinitionCount - 1\\n        DumpInstanceDefinition(instanceDefinitions(i), dump, True)\\n      Next\\n\\n      RhinoApp.WriteLine(dump.ToString())\\n\\n      Return Result.Success\\n    End Function\\n\\n    Private Sub DumpInstanceDefinition(instanceDefinition As InstanceDefinition, ByRef dump As TextLog, isRoot As Boolean)\\n      If instanceDefinition IsNot Nothing AndAlso Not instanceDefinition.IsDeleted Then\\n        Dim node As String\\n        If isRoot Then\\n          node = \\"\\"\\n        Else\\n          \'\\"\\\\u2500\\"; \\n          node = \\"\\"\\n        End If\\n        \'\\"\\\\u2514\\"; \\n        dump.Print(String.Format(\\"{0} Instance definition {1} = {2}\\" & vbLf, node, instanceDefinition.Index, instanceDefinition.Name))\\n\\n        If instanceDefinition.ObjectCount > 0 Then\\n          dump.PushIndent()\\n          For i As Integer = 0 To instanceDefinition.ObjectCount - 1\\n            Dim obj = instanceDefinition.[Object](i)\\n\\n            If obj Is Nothing Then Continue For\\n\\n            If TypeOf obj Is InstanceObject Then\\n              DumpInstanceDefinition(TryCast(obj, InstanceObject).InstanceDefinition, dump, False)\\n            Else\\n              \' Recursive...\\n              dump.Print(String.Format(\\" Object {0} = {1}\\" & vbLf, i, obj.ShortDescription(False)))\\n            End If\\n          Next\\n          dump.PopIndent()\\n        End If\\n      End If\\n    End Sub\\n  End Class\\nEnd Namespace","members":[["Rhino.RhinoDoc","InstanceDefinitionTable InstanceDefinitions"],["Rhino.FileIO.TextLog","void PopIndent()"],["Rhino.FileIO.TextLog","void Print(string text)"],["Rhino.FileIO.TextLog","void PushIndent()"]]},{"name":"Projectpointstobreps.vb","code":"Imports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.Input.Custom\\nImports Rhino.Commands\\nImports System.Collections.Generic\\nImports Rhino.Geometry\\nImports Rhino.Geometry.Intersect\\n\\nNamespace examples_vb\\n  Public Class ProjectPointsToBrepsCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbProjectPtointsToBreps\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim gs = New GetObject()\\n      gs.SetCommandPrompt(\\"select surface\\")\\n      gs.GeometryFilter = ObjectType.Surface Or ObjectType.PolysrfFilter\\n      gs.DisablePreSelect()\\n      gs.SubObjectSelect = False\\n      gs.[Get]()\\n      If gs.CommandResult() <> Result.Success Then\\n        Return gs.CommandResult()\\n      End If\\n      Dim brep = gs.[Object](0).Brep()\\n      If brep Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      \' brep on which to project\\n      \' some random points to project\\n      \' project on Y axis\\n      Dim points = Intersection.ProjectPointsToBreps(New List(Of Brep)() From { _\\n        brep _\\n      }, New List(Of Point3d)() From { _\\n        New Point3d(0, 0, 0), _\\n        New Point3d(3, 0, 3), _\\n        New Point3d(-2, 0, -2) _\\n      }, New Vector3d(0, 1, 0), doc.ModelAbsoluteTolerance)\\n\\n      If points IsNot Nothing AndAlso points.Length > 0 Then\\n        For Each point As Point3d In points\\n          doc.Objects.AddPoint(point)\\n        Next\\n      End If\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Intersect.Intersection","static Point3d[] ProjectPointsToBreps(IEnumerable<Brep> breps, IEnumerable<Point3d> points, Vector3d direction, double tolerance)"]]},{"name":"Projectpointstomeshesex.vb","code":"Imports System.Collections.Generic\\nImports Rhino\\nImports Rhino.Commands\\nImports Rhino.Geometry\\nImports Rhino.Geometry.Intersect\\nImports Rhino.Input\\nImports Rhino.DocObjects\\n\\nNamespace examples_vb\\n  Public Class ProjectPointsToMeshesExCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbProjectPointsToMeshesEx\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim obj_ref As ObjRef\\n      Dim rc = RhinoGet.GetOneObject(\\"mesh\\", False, ObjectType.Mesh, obj_ref)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      Dim mesh = obj_ref.Mesh()\\n\\n      Dim obj_ref_pts As ObjRef()\\n      rc = RhinoGet.GetMultipleObjects(\\"points\\", False, ObjectType.Point, obj_ref_pts)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      Dim points As New List(Of Point3d)()\\n      For Each obj_ref_pt As ObjRef In obj_ref_pts\\n        Dim pt = obj_ref_pt.Point().Location\\n        points.Add(pt)\\n      Next\\n\\n      Dim indices As Integer()\\n      Dim prj_points = Intersection.ProjectPointsToMeshesEx(New Mesh() {mesh}, points, New Vector3d(0, 1, 0), 0, indices)\\n      For Each prj_pt As Point3d In prj_points\\n        doc.Objects.AddPoint(prj_pt)\\n      Next\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace\\n\\n","members":[["Rhino.Geometry.Intersect.Intersection","static Point3d[] ProjectPointsToMeshesEx(IEnumerable<Mesh> meshes, IEnumerable<Point3d> points, Vector3d direction, double tolerance, out int[] indices)"]]},{"name":"Renameblock.vb","code":"Imports Rhino\\nImports Rhino.Commands\\n\\nNamespace examples_vb\\n  Public Class RenameBlockCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbRenameInstanceDefinition\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      \' Get the name of the insance definition to rename\\n      Dim instanceDefinitionName As String = \\"\\"\\n      Dim rc = Rhino.Input.RhinoGet.GetString(\\"Name of block to rename\\", True, instanceDefinitionName)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      If [String].IsNullOrWhiteSpace(instanceDefinitionName) Then\\n        Return Result.[Nothing]\\n      End If\\n\\n      \' Verify instance definition exists\\n      Dim instanceDefinition = doc.InstanceDefinitions.Find(instanceDefinitionName, True)\\n      If instanceDefinition Is Nothing Then\\n        RhinoApp.WriteLine([String].Format(\\"Block \\"\\"{0}\\"\\" not found.\\", instanceDefinitionName))\\n        Return Result.[Nothing]\\n      End If\\n\\n      \' Verify instance definition is rename-able\\n      If instanceDefinition.IsDeleted OrElse instanceDefinition.IsReference Then\\n        RhinoApp.WriteLine([String].Format(\\"Unable to rename block \\"\\"{0}\\"\\".\\", instanceDefinitionName))\\n        Return Result.[Nothing]\\n      End If\\n\\n      \' Get the new instance definition name\\n      Dim instanceDefinitionNewName As String = \\"\\"\\n      rc = Rhino.Input.RhinoGet.GetString(\\"Name of block to rename\\", True, instanceDefinitionNewName)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      If [String].IsNullOrWhiteSpace(instanceDefinitionNewName) Then\\n        Return Result.[Nothing]\\n      End If\\n\\n      \' Verify the new instance definition name is not already in use\\n      Dim existingInstanceDefinition = doc.InstanceDefinitions.Find(instanceDefinitionNewName, True)\\n      If existingInstanceDefinition IsNot Nothing AndAlso Not existingInstanceDefinition.IsDeleted Then\\n        RhinoApp.WriteLine([String].Format(\\"Block \\"\\"{0}\\"\\" already exists.\\", existingInstanceDefinition))\\n        Return Result.[Nothing]\\n      End If\\n\\n      \' change the block name\\n      If Not doc.InstanceDefinitions.Modify(instanceDefinition.Index, instanceDefinitionNewName, instanceDefinition.Description, True) Then\\n        RhinoApp.WriteLine([String].Format(\\"Could not rename {0} to {1}\\", instanceDefinition.Name, instanceDefinitionNewName))\\n        Return Result.Failure\\n      End If\\n\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.DocObjects.InstanceDefinition","bool IsDeleted"],["Rhino.DocObjects.InstanceDefinition","bool IsReference"],["Rhino.DocObjects.Tables.InstanceDefinitionTable","bool Modify(int idefIndex, string newName, string newDescription, bool quiet)"]]},{"name":"Replacecolordialog.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.UI\\nImports System.Windows.Forms\\n\\nNamespace examples_vb\\n  Public Class ReplaceColorDialogCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbReplaceColorDialog\\"\\n      End Get\\n    End Property\\n\\n    Private m_dlg As ColorDialog = Nothing\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dialogs.SetCustomColorDialog(AddressOf OnSetCustomColorDialog)\\n      Return Result.Success\\n    End Function\\n\\n    Private Sub OnSetCustomColorDialog(sender As Object, e As GetColorEventArgs)\\n\\n      m_dlg = New ColorDialog()\\n      If m_dlg.ShowDialog(Nothing) = DialogResult.OK Then\\n        Dim c = m_dlg.Color\\n        e.SelectedColor = c\\n      End If\\n    End Sub\\n  End Class\\nEnd Namespace","members":[["Rhino.UI.Dialogs","static void SetCustomColorDialog(EventHandler<GetColorEventArgs> handler)"]]},{"name":"Replacehatchpattern.vb","code":"Imports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.Commands\\nImports Rhino.Input\\nImports Rhino.Input.Custom\\n\\nNamespace examples_vb\\n  Public Class ReplaceHatchPatternCommand\\n    Inherits Rhino.Commands.Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbReplaceHatchPattern\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim obj_refs As ObjRef() = Nothing\\n      Dim rc = RhinoGet.GetMultipleObjects(\\"Select hatches to replace\\", False, ObjectType.Hatch, obj_refs)\\n      If rc <> Result.Success OrElse obj_refs Is Nothing Then\\n        Return rc\\n      End If\\n\\n      Dim gs = New GetString()\\n      gs.SetCommandPrompt(\\"Name of replacement hatch pattern\\")\\n      gs.AcceptNothing(False)\\n      gs.[Get]()\\n      If gs.CommandResult() <> Result.Success Then\\n        Return gs.CommandResult()\\n      End If\\n      Dim hatch_name = gs.StringResult()\\n\\n      Dim pattern_index = doc.HatchPatterns.Find(hatch_name, True)\\n\\n      If pattern_index < 0 Then\\n        RhinoApp.WriteLine(\\"The hatch pattern \\"\\"{0}\\"\\" not found  in the document.\\", hatch_name)\\n        Return Result.[Nothing]\\n      End If\\n\\n      For Each obj_ref As ObjRef In obj_refs\\n        Dim hatch_object = TryCast(obj_ref.[Object](), HatchObject)\\n        If hatch_object.HatchGeometry.PatternIndex <> pattern_index Then\\n          hatch_object.HatchGeometry.PatternIndex = pattern_index\\n          hatch_object.CommitChanges()\\n        End If\\n      Next\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.Hatch","int PatternIndex"],["Rhino.DocObjects.HatchObject","Hatch HatchGeometry"]]},{"name":"Rhinogettransform.vb","code":"Imports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.Geometry\\nImports Rhino.Commands\\nImports Rhino.Input.Custom\\nImports Rhino.Display\\n\\nNamespace examples_vb\\n  Public Class GetTranslation\\n    Inherits GetTransform\\n    Public Overrides Function CalculateTransform(viewport As RhinoViewport, point As Point3d) As Transform\\n      Dim xform = Transform.Identity\\n      Dim base_point As Point3d\\n      If TryGetBasePoint(base_point) Then\\n        Dim v = point - base_point\\n        If Not v.IsZero Then\\n          xform = Transform.Translation(v)\\n          If Not xform.IsValid Then\\n            xform = Transform.Identity\\n          End If\\n        End If\\n      End If\\n      Return xform\\n    End Function\\n  End Class\\n\\n  Public Class RhinoGetTransformCommand\\n    Inherits TransformCommand\\n    Public Sub New()\\n      \' simple example of handling the BeforeTransformObjects event\\n      AddHandler RhinoDoc.BeforeTransformObjects, AddressOf RhinoDocOnBeforeTransformObjects\\n    End Sub\\n\\n    Private Sub RhinoDocOnBeforeTransformObjects(sender As Object, ea As RhinoTransformObjectsEventArgs)\\n      RhinoApp.WriteLine(\\"Transform Objects Count: {0}\\", ea.ObjectCount)\\n    End Sub\\n\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbGetTranslation\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim list = New Rhino.Collections.TransformObjectList()\\n      Dim rc = SelectObjects(\\"Select objects to move\\", list)\\n      If rc <> Rhino.Commands.Result.Success Then\\n        Return rc\\n      End If\\n\\n      Dim gp = New GetPoint()\\n      gp.SetCommandPrompt(\\"Point to move from\\")\\n      gp.[Get]()\\n      If gp.CommandResult() <> Result.Success Then\\n        Return gp.CommandResult()\\n      End If\\n\\n\\n      Dim gt = New GetTranslation()\\n      gt.SetCommandPrompt(\\"Point to move to\\")\\n      gt.SetBasePoint(gp.Point(), True)\\n      gt.DrawLineFromPoint(gp.Point(), True)\\n      gt.AddTransformObjects(list)\\n      gt.GetXform()\\n      If gt.CommandResult() <> Result.Success Then\\n        Return gt.CommandResult()\\n      End If\\n\\n      Dim xform = gt.CalculateTransform(gt.View().ActiveViewport, gt.Point())\\n      TransformObjects(list, xform, False, False)\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace\\n","members":[["Rhino.RhinoDoc","static BeforeTransformObjects"]]},{"name":"Rhinopageviewwidthheight.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.Input\\n\\nNamespace examples_vb\\n  Public Class RhinoPageViewWidthHeightCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbSetRhinoPageViewWidthAndHeight\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim width = 1189\\n      Dim height = 841\\n      Dim page_views = doc.Views.GetPageViews()\\n      Dim page_number As Integer = If((page_views Is Nothing), 1, page_views.Length + 1)\\n      Dim pageview = doc.Views.AddPageView(String.Format(\\"A0_{0}\\", page_number), width, height)\\n\\n      Dim new_width As Integer = width\\n      Dim rc = RhinoGet.GetInteger(\\"new width\\", False, new_width)\\n      If rc <> Result.Success OrElse new_width <= 0 Then\\n        Return rc\\n      End If\\n\\n      Dim new_height As Integer = height\\n      rc = RhinoGet.GetInteger(\\"new height\\", False, new_height)\\n      If rc <> Result.Success OrElse new_height <= 0 Then\\n        Return rc\\n      End If\\n\\n      pageview.PageWidth = new_width\\n      pageview.PageHeight = new_height\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Display.RhinoPageView","double PageHeight"],["Rhino.Display.RhinoPageView","double PageWidth"]]},{"name":"Screencaptureview.vb","code":"Imports System.Windows.Forms\\nImports Rhino\\nImports Rhino.Commands\\n\\nNamespace examples_vb\\n  Public Class CaptureViewToBitmapCommand\\n    Inherits Rhino.Commands.Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbCaptureViewToBitmap\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim file_name = \\"\\"\\n\\n      Dim bitmap = doc.Views.ActiveView.CaptureToBitmap(True, True, True)\\n\\n      \' copy bitmap to clipboard\\n      Clipboard.SetImage(bitmap)\\n\\n      \' save bitmap to file\\n      Dim save_file_dialog = New Rhino.UI.SaveFileDialog()\\n      save_file_dialog.Filter = \\"*.bmp\\"\\n      save_file_dialog.InitialDirectory =\\n        Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)\\n\\n      If save_file_dialog.ShowDialog() = DialogResult.OK Then\\n        file_name = save_file_dialog.FileName\\n      End If\\n\\n      If file_name <> \\"\\" Then\\n        bitmap.Save(file_name)\\n      End If\\n\\n      Return Rhino.Commands.Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Display.RhinoView","System.Drawing.Bitmap CaptureToBitmap(bool grid, bool worldAxes, bool cplaneAxes)"],["Rhino.UI.SaveFileDialog","SaveFileDialog()"],["Rhino.UI.SaveFileDialog","string FileName"],["Rhino.UI.SaveFileDialog","string Filter"],["Rhino.UI.SaveFileDialog","string InitialDirectory"],["Rhino.UI.SaveFileDialog","bool ShowSaveDialog()"]]},{"name":"Sellayer.vb","code":"Partial Class Examples\\n  Public Shared Function SelLayer(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim rc As Rhino.Commands.Result\\n    \' Prompt for a layer name\\n    Dim layername As String = doc.Layers.CurrentLayer.Name\\n    rc = Rhino.Input.RhinoGet.GetString(\\"Name of layer to select objects\\", True, layername)\\n    If rc <> Rhino.Commands.Result.Success Then Return rc\\n\\n    \' Get all of the objects on the layer. If layername is bogus, you will\\n    \' just get an empty list back\\n    Dim rhobjs As Rhino.DocObjects.RhinoObject() = doc.Objects.FindByLayer(layername)\\n    If rhobjs Is Nothing OrElse rhobjs.Length < 1 Then\\n      Return Rhino.Commands.Result.Cancel\\n    End If\\n\\n    For i As Integer = 0 To rhobjs.Length - 1\\n      rhobjs(i).Select(True)\\n    Next\\n    doc.Views.Redraw()\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.DocObjects.Layer","string Name"],["Rhino.DocObjects.Tables.ObjectTable","RhinoObject[] FindByLayer(string layerName)"],["Rhino.DocObjects.Tables.LayerTable","Layer CurrentLayer"]]},{"name":"Splitbrepwithplane.vb","code":"Imports Rhino\\nImports Rhino.DocObjects\\nImports Rhino.Commands\\nImports Rhino.Input\\nImports Rhino.Geometry\\n\\nNamespace examples_vb\\n  Public Class SplitBrepsWithPlaneCommand\\n    Inherits Rhino.Commands.Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbSplitBrepsWithPlane\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      \'First, collect all the breps to split\\n      Dim obj_refs As ObjRef() = Nothing\\n      Dim rc = RhinoGet.GetMultipleObjects(\\"Select breps to split\\", False, ObjectType.Brep, obj_refs)\\n      If rc <> Result.Success OrElse obj_refs Is Nothing Then\\n        Return rc\\n      End If\\n\\n      \' Get the final plane\\n      Dim plane As Plane\\n      rc = RhinoGet.GetPlane(plane)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n\\n      \'Iterate over all object references\\n      For Each obj_ref As ObjRef In obj_refs\\n        Dim brep = obj_ref.Brep()\\n        Dim bbox = brep.GetBoundingBox(False)\\n\\n        \'Grow the boundingbox in all directions\\n        \'If the boundingbox is flat (zero volume or even zero area) \\n        \'then the CreateThroughBox method will fail.\\n        Dim min_point = bbox.Min\\n        min_point.X -= 1.0\\n        min_point.Y -= 1.0\\n        min_point.Z -= 1.0\\n        bbox.Min = min_point\\n        Dim max_point = bbox.Max\\n        max_point.X += 1.0\\n        max_point.Y += 1.0\\n        max_point.Z += 1.0\\n        bbox.Max = max_point\\n\\n        Dim plane_surface = PlaneSurface.CreateThroughBox(plane, bbox)\\n        If plane_surface Is Nothing Then\\n          \'This is rare, it will most likely not happen unless either the plane or the boundingbox are invalid\\n          RhinoApp.WriteLine(\\"Cutting plane could not be constructed.\\")\\n        Else\\n          Dim breps = brep.Split(plane_surface.ToBrep(), doc.ModelAbsoluteTolerance)\\n          If breps Is Nothing OrElse breps.Length = 0 Then\\n            RhinoApp.Write(\\"Plane does not intersect brep (id:{0})\\", obj_ref.ObjectId)\\n            Continue For\\n          End If\\n          For Each brep_piece As Brep In breps\\n            doc.Objects.AddBrep(brep_piece)\\n          Next\\n          doc.Objects.AddSurface(plane_surface)\\n          doc.Objects.Delete(obj_ref, False)\\n        End If\\n      Next\\n\\n      doc.Views.Redraw()\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.PlaneSurface","static PlaneSurface CreateThroughBox(Plane plane, BoundingBox box)"],["Rhino.Input.RhinoGet","static Result GetPlane(out Plane plane)"]]},{"name":"Srfpt.vb","code":"Imports Rhino\\nImports Rhino.Geometry\\nImports Rhino.Commands\\n\\nNamespace examples_vb\\n  Public Class SurfaceFromCornersCommand\\n    Inherits Rhino.Commands.Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbSurfaceFromCorners\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim surface = NurbsSurface.CreateFromCorners(\\n        New Point3d(5, 0, 0),\\n        New Point3d(5, 5, 5),\\n        New Point3d(0, 5, 0),\\n        New Point3d(0, 0, 0))\\n\\n      doc.Objects.AddSurface(surface)\\n      doc.Views.Redraw()\\n\\n      Return Rhino.Commands.Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.NurbsSurface","static NurbsSurface CreateFromCorners(Point3d corner1, Point3d corner2, Point3d corner3, Point3d corner4)"]]},{"name":"Sweep1.vb","code":"Imports Rhino.Input\\nImports System.Collections.Generic\\n\\nPartial Class Examples\\n  Public Shared Function Sweep1(doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim rail_ref As Rhino.DocObjects.ObjRef = Nothing\\n    Dim rc = RhinoGet.GetOneObject(\\"Select rail curve\\", False, Rhino.DocObjects.ObjectType.Curve, rail_ref)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    Dim rail_crv = rail_ref.Curve()\\n    If rail_crv Is Nothing Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    Dim gx = New Rhino.Input.Custom.GetObject()\\n    gx.SetCommandPrompt(\\"Select cross section curves\\")\\n    gx.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\\n    gx.EnablePreSelect(False, True)\\n    gx.GetMultiple(1, 0)\\n    If gx.CommandResult() <> Rhino.Commands.Result.Success Then\\n      Return gx.CommandResult()\\n    End If\\n\\n    Dim cross_sections = New List(Of Rhino.Geometry.Curve)()\\n    For i As Integer = 0 To gx.ObjectCount - 1\\n      Dim crv = gx.Object(i).Curve()\\n      If crv IsNot Nothing Then\\n        cross_sections.Add(crv)\\n      End If\\n    Next\\n    If cross_sections.Count < 1 Then\\n      Return Rhino.Commands.Result.Failure\\n    End If\\n\\n    Dim sweep = New Rhino.Geometry.SweepOneRail()\\n    sweep.AngleToleranceRadians = doc.ModelAngleToleranceRadians\\n    sweep.ClosedSweep = False\\n    sweep.SweepTolerance = doc.ModelAbsoluteTolerance\\n    sweep.SetToRoadlikeTop()\\n    Dim breps = sweep.PerformSweep(rail_crv, cross_sections)\\n    For i As Integer = 0 To breps.Length - 1\\n      doc.Objects.AddBrep(breps(i))\\n    Next\\n    doc.Views.Redraw()\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.SweepOneRail","SweepOneRail()"],["Rhino.Geometry.SweepOneRail","Brep[] PerformSweep(Curve rail, IEnumerable<Curve> crossSections)"]]},{"name":"Textjustify.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports Rhino.Geometry\\n\\nNamespace examples_vb\\n  Public Class TextJustifyCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbTextJustify\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim text_entity = New TextEntity()\\n      text_entity.Plane = Plane.WorldXY\\n      text_entity.Text = \\"Hello Rhino!\\"\\n      text_entity.Justification = TextJustification.MiddleCenter\\n      text_entity.FontIndex = doc.Fonts.FindOrCreate(\\"Arial\\", False, False)\\n\\n      doc.Objects.AddText(text_entity)\\n      doc.Views.Redraw()\\n\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Geometry.TextEntity","TextEntity()"],["Rhino.Geometry.TextEntity","TextJustification Justification"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddText(Text3d text3d)"],["Rhino.DocObjects.Tables.FontTable","int FindOrCreate(string face, bool bold, bool italic)"]]},{"name":"Tightboundingbox.vb","code":"Imports Rhino\\nImports Rhino.Commands\\nImports System.Linq\\nImports Rhino.Geometry\\nImports Rhino.Input\\nImports Rhino.DocObjects\\nImports System.Collections.Generic\\n\\nNamespace examples_vb\\n  Public Class TightBoundingBoxCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbTightBoundingBox\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim obj_ref As ObjRef = Nothing\\n      Dim rc = RhinoGet.GetOneObject(\\"Select surface to split\\", True, ObjectType.Surface, obj_ref)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      Dim surface = obj_ref.Surface()\\n      If surface Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      obj_ref = Nothing\\n      rc = RhinoGet.GetOneObject(\\"Select cutting curve\\", True, ObjectType.Curve, obj_ref)\\n      If rc <> Result.Success Then\\n        Return rc\\n      End If\\n      Dim curve = obj_ref.Curve()\\n      If curve Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      Dim brep_face = TryCast(surface, BrepFace)\\n      If brep_face Is Nothing Then\\n        Return Result.Failure\\n      End If\\n\\n      Dim split_brep = brep_face.Split(New List(Of Curve)() From { _\\n        curve _\\n      }, doc.ModelAbsoluteTolerance)\\n      If split_brep Is Nothing Then\\n        RhinoApp.WriteLine(\\"Unable to split surface.\\")\\n        Return Result.[Nothing]\\n      End If\\n\\n      Dim meshes = Mesh.CreateFromBrep(split_brep)\\n\\n      For Each mesh__1 As Mesh In meshes\\n        Dim bbox = mesh__1.GetBoundingBox(True)\\n        Select Case bbox.IsDegenerate(doc.ModelAbsoluteTolerance)\\n          Case 3, 2\\n            Return Result.Failure\\n            Exit Select\\n          Case 1\\n            \' rectangle\\n            \' box with 8 corners flattened to rectangle with 4 corners\\n            Dim rectangle_corners = bbox.GetCorners().Distinct().ToList()\\n            \' add 1st point as last to close the loop\\n            rectangle_corners.Add(rectangle_corners(0))\\n            doc.Objects.AddPolyline(rectangle_corners)\\n            doc.Views.Redraw()\\n            Exit Select\\n          Case 0\\n            \' box\\n            Dim brep_box = New Box(bbox).ToBrep()\\n            doc.Objects.AddBrep(brep_box)\\n            doc.Views.Redraw()\\n            Exit Select\\n        End Select\\n      Next\\n\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace\\n","members":[["Rhino.Geometry.BrepFace","Brep Split(IEnumerable<Curve> curves, double tolerance)"],["Rhino.Geometry.Mesh","static Mesh[] CreateFromBrep(Brep brep)"],["Rhino.DocObjects.Tables.ObjectTable","Guid AddPolyline(IEnumerable<Point3d> points)"]]},{"name":"Transformbrep.vb","code":"Imports Rhino.Input\\n\\nPartial Class Examples\\n  Public Shared Function TransformBrep(doc As Rhino.RhinoDoc) As Rhino.Commands.Result\\n    Dim rhobj As Rhino.DocObjects.ObjRef = Nothing\\n    Dim rc = RhinoGet.GetOneObject(\\"Select brep\\", True, Rhino.DocObjects.ObjectType.Brep, rhobj)\\n    If rc <> Rhino.Commands.Result.Success Then\\n      Return rc\\n    End If\\n\\n    \' Simple translation transformation\\n    Dim xform = Rhino.Geometry.Transform.Translation(18, -18, 25)\\n    doc.Objects.Transform(rhobj, xform, True)\\n    doc.Views.Redraw()\\n    Return Rhino.Commands.Result.Success\\n  End Function\\nEnd Class\\n","members":[["Rhino.Geometry.Transform","static Transform Translation(double dx, double dy, double dz)"]]},{"name":"Viewportresolution.vb","code":"Imports Rhino\\nImports Rhino.Commands\\n\\nNamespace examples_vb\\n  Public Class ViewportResolutionCommand\\n    Inherits Command\\n    Public Overrides ReadOnly Property EnglishName() As String\\n      Get\\n        Return \\"vbViewportResolution\\"\\n      End Get\\n    End Property\\n\\n    Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result\\n      Dim activeViewport = doc.Views.ActiveView.ActiveViewport\\n      RhinoApp.WriteLine([String].Format(\\"Name = {0}: Width = {1}, Height = {2}\\", activeViewport.Name, activeViewport.Size.Width, activeViewport.Size.Height))\\n      Return Result.Success\\n    End Function\\n  End Class\\nEnd Namespace","members":[["Rhino.Display.RhinoViewport","Size Size"]]}]')},95220:e=>{e.exports=JSON.parse('[{"name":"Rhino","dataType":"namespace","summary":"Contains commonly-used value types and classes used in Rhino."},{"name":"Rhino.ApplicationSettings","dataType":"namespace","summary":"Static settings global to the entire Rhino application"},{"name":"Rhino.Collections","dataType":"namespace"},{"name":"Rhino.Commands","dataType":"namespace"},{"name":"Rhino.Display","dataType":"namespace"},{"name":"Rhino.DocObjects","dataType":"namespace","summary":"The DocObjects namespace contains types that correspond to geometry that is found in a document.  \\nGenerally, these types reference an attribute and have a distinctive ID."},{"name":"Rhino.DocObjects.Custom","dataType":"namespace"},{"name":"Rhino.DocObjects.SnapShots","dataType":"namespace"},{"name":"Rhino.DocObjects.Tables","dataType":"namespace"},{"name":"Rhino.FileIO","dataType":"namespace"},{"name":"Rhino.Geometry","dataType":"namespace","summary":"The Geometry namespace contains geometric types used in Rhino.  \\nExamples are lines, curves, meshes and boundary representations."},{"name":"Rhino.Geometry.Collections","dataType":"namespace"},{"name":"Rhino.Geometry.Intersect","dataType":"namespace"},{"name":"Rhino.Geometry.MeshRefinements","dataType":"namespace"},{"name":"Rhino.Geometry.Morphs","dataType":"namespace"},{"name":"Rhino.Input","dataType":"namespace","summary":"Classes related to getting user input for things like points, objects, and numbers"},{"name":"Rhino.Input.Custom","dataType":"namespace"},{"name":"Rhino.NodeInCode","dataType":"namespace"},{"name":"Rhino.PlugIns","dataType":"namespace"},{"name":"Rhino.Render","dataType":"namespace"},{"name":"Rhino.Render.ChangeQueue","dataType":"namespace"},{"name":"Rhino.Render.ChildSlotNames","dataType":"namespace"},{"name":"Rhino.Render.DataSources","dataType":"namespace"},{"name":"Rhino.Render.Fields","dataType":"namespace"},{"name":"Rhino.Render.ParameterNames","dataType":"namespace"},{"name":"Rhino.Render.PostEffects","dataType":"namespace"},{"name":"Rhino.Render.UI","dataType":"namespace"},{"name":"Rhino.Runtime","dataType":"namespace"},{"name":"Rhino.Runtime.InProcess","dataType":"namespace"},{"name":"Rhino.Runtime.InteropWrappers","dataType":"namespace"},{"name":"Rhino.Runtime.Notifications","dataType":"namespace"},{"name":"Rhino.Runtime.RhinoAccounts","dataType":"namespace"},{"name":"Rhino.UI","dataType":"namespace"},{"name":"Rhino.UI.Controls","dataType":"namespace"},{"name":"Rhino.UI.Controls.DataSource","dataType":"namespace"},{"name":"Rhino.UI.Controls.Thumbnaillist","dataType":"namespace"},{"name":"Rhino.UI.Controls.ThumbnailUI","dataType":"namespace"},{"name":"Rhino.UI.Gumball","dataType":"namespace"},{"namespace":"Rhino","name":"AngleUnitSystem","dataType":"enum","summary":"ON::AngleUnitSystem identifies an angle unit system","values":[{"signature":"None = 0","summary":"ON::AngleUnitSystem::None indicates no angle unit system is specified and model angle unit system should be used."},{"signature":"Turns = 1","summary":"1 turn = 2pi radians."},{"signature":"Radians = 2","summary":"1 turn = 2pi radians."},{"signature":"Degrees = 3","summary":"360 arc degrees  = 1 turn = 2pi radians"},{"signature":"Minutes = 4","summary":"60 arc minutes = 1 arc degree"},{"signature":"Seconds = 5","summary":"60 arc seconds = 1 arc minute"},{"signature":"Gradians = 6","summary":"400 gradians = 2pi radians."},{"signature":"Unset = 255","summary":"The ON::AngleUnitSystem::Unset is used to indicates no angle unit system has been specified in user interface code."}]},{"namespace":"Rhino","name":"AntialiasLevel","dataType":"enum","summary":"Provides the anti-alias levels used for render quality","since":"6.0","values":[{"signature":"None = 0","summary":"Low quality"},{"signature":"Draft = 1","summary":"Draft quality"},{"signature":"Good = 2","summary":"Good quality"},{"signature":"High = 3","summary":"High quality"}]},{"namespace":"Rhino.ApplicationSettings","name":"AppearanceSettings","dataType":"class","summary":"Provides static methods and properties to deal with the appearance of the application.","properties":[{"signature":"static Color CommandPromptBackgroundColor","summary":"Gets or sets the color of the command prompt background.","since":"5.0","property":["get","set"]},{"signature":"static int CommandPromptFontSize","summary":"Size of font used in command prompt (in points)","since":"7.0","property":["get","set"]},{"signature":"static Color CommandPromptHypertextColor","summary":"Gets or sets the color of the command prompt hypertext.","since":"5.0","property":["get","set"]},{"signature":"static CommandPromptPosition CommandPromptPosition","summary":"Gets or sets the command prompt position.","since":"5.0","property":["get","set"]},{"signature":"static Color CommandPromptTextColor","summary":"Gets or sets the color of the command prompt text.","since":"5.0","property":["get","set"]},{"signature":"static Color CrosshairColor","summary":"Gets or sets the color of the crosshair icon.","since":"5.0","property":["get","set"]},{"signature":"static Color CurrentLayerBackgroundColor","summary":"Gets or sets the color used by the layer manager dialog as the background color for the current layer.","since":"5.0","property":["get","set"]},{"signature":"static string DefaultFontFaceName","summary":"Gets or sets the default font face name used in Rhino.","since":"5.0","property":["get"]},{"signature":"static Color DefaultLayerColor","summary":"Gets or sets the default layer color.","since":"5.0","property":["get","set"]},{"signature":"static Color DefaultObjectColor","summary":"Gets or sets the default color for new objects.","since":"5.0","property":["get","set"]},{"signature":"static bool EchoCommandsToHistoryWindow","summary":"Gets or sets a value that determines if command names are written to the history window.","since":"5.0","property":["get","set"]},{"signature":"static bool EchoPromptsToHistoryWindow","summary":"Gets or sets a value that determines if prompt messages are written to the history window.","since":"5.0","property":["get","set"]},{"signature":"static Color EditCandidateColor","summary":"Gets or sets the color of objects that are eligible to be edited.","since":"6.0","property":["get","set"]},{"signature":"static Color FeedbackColor","summary":"Gets or sets the feedback color.","since":"5.0","property":["get","set"]},{"signature":"static Color FrameBackgroundColor","summary":"Gets or sets the background color of the frame.","since":"5.0","property":["get","set"]},{"signature":"static Color GridThickLineColor","summary":"Gets or sets the color of the thick line of the grid.","since":"5.0","property":["get","set"]},{"signature":"static Color GridThinLineColor","summary":"Gets or sets the color of the thin line of the grid.","since":"5.0","property":["get","set"]},{"signature":"static Color GridXAxisLineColor","summary":"Gets or sets the color of the X axis of the grid.","since":"5.0","property":["get","set"]},{"signature":"static Color GridYAxisLineColor","summary":"Gets or sets the color of the Y axis of the grid.","since":"5.0","property":["get","set"]},{"signature":"static Color GridZAxisLineColor","summary":"Gets or sets the color of the Z axis of the grid.","since":"5.0","property":["get","set"]},{"signature":"static int LanguageIdentifier","summary":"Gets or sets the language identifier.","since":"5.0","property":["get","set"]},{"signature":"static Color LockedObjectColor","summary":"color used to draw locked objects.","since":"5.0","property":["get","set"]},{"signature":"static bool MenuVisible","summary":"Gets or sets a value that determines if the File menu is visible.","since":"5.0","property":["get","set"]},{"signature":"static Color PageviewPaperColor","summary":"Gets or sets the paper background. A rectangle is drawn into the background of page views to represent the printed area. The alpha portion of the color is used to draw the paper blended into the background","since":"5.0","property":["get","set"]},{"signature":"static int PreviousLanguageIdentifier","summary":"Gets or sets the previous language identifier.","since":"5.0","property":["get","set"]},{"signature":"static Color SelectedObjectColor","summary":"The color used to draw selected objects. The default is yellow, but this can be customized by the user.","since":"5.0","property":["get","set"]},{"signature":"static Color SelectionWindowCrossingFillColor","summary":"Color used to fill selection crossing window","since":"7.0","property":["get","set"]},{"signature":"static Color SelectionWindowCrossingStrokeColor","summary":"Color used to draw stroke for selection crossing window","since":"7.0","property":["get","set"]},{"signature":"static Color SelectionWindowFillColor","summary":"Color used to fill selection window","since":"7.0","property":["get","set"]},{"signature":"static Color SelectionWindowStrokeColor","summary":"Color used to draw stroke for selection window","since":"7.0","property":["get","set"]},{"signature":"static bool ShowCrosshairs","summary":"Gets or sets a value that determines if cross hairs are visible.","since":"5.0","property":["get","set"]},{"signature":"static bool ShowFullPathInTitleBar","summary":"Gets or sets a value that determines if the full path of the document is shown in the Rhino title bar.","since":"5.0","property":["get","set"]},{"signature":"static bool ShowOsnapBar","summary":"Shows or hides the object snap user interface.","since":"7.0","property":["get","set"]},{"signature":"static bool ShowSideBar","summary":"Shows or hides the side bar user interface.","since":"6.0","property":["get","set"]},{"signature":"static bool ShowStatusBar","summary":"Shows or hides the status bar user interface.","since":"7.0","property":["get","set"]},{"signature":"static Color TrackingColor","summary":"Gets or sets the tracking color.","since":"5.0","property":["get","set"]},{"signature":"static bool UsePaintColors","summary":"Gets or sets a value indicating if logical paint colors should be used.","since":"5.0","property":["get"]},{"signature":"static Color ViewportBackgroundColor","summary":"Gets or sets the viewport background color.","since":"5.0","property":["get","set"]},{"signature":"static Color WorldCoordIconXAxisColor","summary":"Gets or sets the color of the world coordinate X axis.","since":"5.0","property":["get","set"]},{"signature":"static Color WorldCoordIconYAxisColor","summary":"Gets or sets the color of the world coordinate Y axis.","since":"5.0","property":["get","set"]},{"signature":"static Color WorldCoordIconZAxisColor","summary":"Gets or sets the color of the world coordinate Z axis.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static Color DefaultPaintColor(PaintColor whichColor)","summary":"Get a default paint color for Rhino. The current paint color may be different than the default","since":"7.0","parameters":[{"name":"whichColor","summary":"The color to retrieve"}]},{"signature":"static AppearanceSettingsState GetCurrentState()","summary":"Gets the current settings of the application.","since":"5.0","returns":"An instance of a class that represents all the settings as they appear in the Rhino _Options dialog, joined in a single class."},{"signature":"static AppearanceSettingsState GetDefaultState()","summary":"Gets the factory settings of the application.","since":"5.0","returns":"An instance of a class that represents all the default settings joined together."},{"signature":"static Color GetPaintColor(PaintColor whichColor)","summary":"Gets the color that is currently associated with a paint color.","since":"5.0","parameters":[{"name":"whichColor","summary":"A color association."}],"returns":"A .Net library color."},{"signature":"static Color GetPaintColor(PaintColor whichColor, bool compute)","summary":"Gat a paint color. This overload provides a compute option for cases where colors are computed when they are \\"unset\\" colors.","parameters":[{"name":"whichColor","summary":""},{"name":"compute","summary":"if true, a color is computed in some cases"}]},{"signature":"static Color GetWidgetColor(WidgetColor whichColor)","summary":"Gets the .Net library color that is currently associated with a widget color.","since":"6.0","parameters":[{"name":"whichColor","summary":"A color association."}],"returns":"A .Net library color."},{"signature":"static bool InitialMainWindowPosition(out Rectangle bounds)","summary":"Location where the Main Rhino window attempts to show when the application is first started.","since":"6.0","parameters":[{"name":"bounds","summary":"The rectangle in which the main window attempts to shows is assigned to this out parameter during the call."}],"returns":"False if the information could not be retrieved."},{"signature":"static void RestoreDefaults()","summary":"Commits the default settings as the current settings.","since":"5.0"},{"signature":"static void SetPaintColor(PaintColor whichColor, Color c)","summary":"Sets the logical paint color association to a spacific .Net library color, without forced UI update.","since":"5.0","parameters":[{"name":"whichColor","summary":"A logical color association."},{"name":"c","summary":"A .Net library color."}]},{"signature":"static void SetPaintColor(PaintColor whichColor, Color c, bool forceUiUpdate)","summary":"Sets the logical paint color association to a spacific .Net library color.","since":"5.0","parameters":[{"name":"whichColor","summary":"A logical color association."},{"name":"c","summary":"A .Net library color."},{"name":"forceUiUpdate","summary":"True if the UI should be forced to update."}]},{"signature":"static void SetWidgetColor(WidgetColor whichColor, Color c)","summary":"Sets the logical widget color association to a spacific .Net library color, without forced UI update.","since":"6.0","parameters":[{"name":"whichColor","summary":"A logical color association."},{"name":"c","summary":"A .Net library color."}]},{"signature":"static void SetWidgetColor(WidgetColor whichColor, Color c, bool forceUiUpdate)","summary":"Sets the logical widget color association to a spacific .Net library color.","since":"6.0","parameters":[{"name":"whichColor","summary":"A logical color association."},{"name":"c","summary":"A .Net library color."},{"name":"forceUiUpdate","summary":"True if the UI should be forced to update."}]},{"signature":"static void UpdateFromState(AppearanceSettingsState state)","summary":"Sets all settings to a particular defined joined state.","since":"5.0","parameters":[{"name":"state","summary":"A joined settings object."}]}]},{"namespace":"Rhino.ApplicationSettings","name":"AppearanceSettingsState","dataType":"class","summary":"Represents a snapshot of the values in AppearanceSettings.","properties":[{"signature":"Color CommandPromptBackgroundColor","summary":"Gets or sets the command prompt background color.","since":"5.0","property":["get","set"]},{"signature":"int CommandPromptFontSize","summary":"Size of the font used in the command prompt (in points)","since":"7.0","property":["get","set"]},{"signature":"Color CommandPromptHypertextColor","summary":"Gets or sets the command prompt hypertext color.","since":"5.0","property":["get","set"]},{"signature":"Color CommandPromptTextColor","summary":"Gets or sets the command prompt text color.","since":"5.0","property":["get","set"]},{"signature":"Color CrosshairColor","summary":"Gets or sets the crosshair color.","since":"5.0","property":["get","set"]},{"signature":"Color CurrentLayerBackgroundColor","summary":"Gets or sets the color used by the layer manager dialog as the background color for the current layer.","since":"5.0","property":["get","set"]},{"signature":"string DefaultFontFaceName","summary":"Gets or sets the name of the default font face.","since":"5.0","property":["get","set"]},{"signature":"Color DefaultLayerColor","summary":"Gets or sets the default layer color.","since":"5.0","property":["get","set"]},{"signature":"Color DefaultObjectColor","summary":"Gets or sets the default object color.","since":"5.0","property":["get","set"]},{"signature":"bool EchoCommandsToHistoryWindow","summary":"Gets or sets a value that determines if command names are written to the history window.","since":"5.0","property":["get","set"]},{"signature":"bool EchoPromptsToHistoryWindow","summary":"Gets or sets a value that determines if prompt messages are written to the history window.","since":"5.0","property":["get","set"]},{"signature":"Color EditCandidateColor","summary":"Gets or sets the color of objects that are eligible to be edited.","since":"7.0","property":["get","set"]},{"signature":"Color FeedbackColor","summary":"Gets or sets the feedback color.","since":"5.0","property":["get","set"]},{"signature":"Color FrameBackgroundColor","summary":"Gets or sets the frame background color.","since":"5.0","property":["get","set"]},{"signature":"Color GridThickLineColor","summary":"Gets or sets the color of the thick line in the grid.","since":"5.0","property":["get","set"]},{"signature":"Color GridThinLineColor","summary":"Gets or sets the color of the thin line in the grid.","since":"5.0","property":["get","set"]},{"signature":"Color GridXAxisLineColor","summary":"Gets or sets the color of X axis line in the grid.","since":"5.0","property":["get","set"]},{"signature":"Color GridYAxisLineColor","summary":"Gets or sets the color of Y axis line in the grid.","since":"5.0","property":["get","set"]},{"signature":"Color GridZAxisLineColor","summary":"Gets or sets the color of Z axis line in the grid.","since":"5.0","property":["get","set"]},{"signature":"Color LockedObjectColor","summary":"Gets or sets the color used to draw locked objects.","since":"5.0","property":["get","set"]},{"signature":"Color PageviewPaperColor","summary":"CRhinoPageView paper background. A rectangle is drawn into the background of page views to represent the printed area. The alpha portion of the color is used to draw the paper blended into the background","since":"5.0","property":["get","set"]},{"signature":"Color SelectedObjectColor","summary":"The color used to draw selected objects. The default is yellow, but this can be customized by the user.","since":"5.0","property":["get","set"]},{"signature":"Color SelectionWindowCrossingFillColor","summary":"Gets or sets the color used to fill a crossing selection window","since":"7.0","property":["get","set"]},{"signature":"Color SelectionWindowCrossingStrokeColor","summary":"Gets or sets the color used to draw the stroke of a crossing selection window","since":"7.0","property":["get","set"]},{"signature":"Color SelectionWindowFillColor","summary":"Gets or sets the color used to fill a selection window","since":"7.0","property":["get","set"]},{"signature":"Color SelectionWindowStrokeColor","summary":"Gets or sets the color used to draw the stroke of a selection window","since":"7.0","property":["get","set"]},{"signature":"bool ShowCrosshairs","summary":"Gets or sets a value that determines if cross hairs are visible.","since":"5.0","property":["get","set"]},{"signature":"bool ShowFullPathInTitleBar","summary":"Gets or sets a value that determines if the full path of the document is shown in the Rhino title bar.","since":"5.0","property":["get","set"]},{"signature":"Color TrackingColor","summary":"Gets or sets the tracking color.","since":"5.0","property":["get","set"]},{"signature":"Color ViewportBackgroundColor","summary":"Gets or sets the viewport background color.","since":"5.0","property":["get","set"]},{"signature":"Color WorldCoordIconXAxisColor","summary":"Gets or sets the color of the world X axis of the world coordinates icon, appearing usually bottom left in viewports.","since":"5.0","property":["get","set"]},{"signature":"Color WorldCoordIconYAxisColor","summary":"Gets or sets the color of the world Y axis of the world coordinate icon, appearing usually bottom left in viewports.","since":"5.0","property":["get","set"]},{"signature":"Color WorldCoordIconZAxisColor","summary":"Gets or sets the color of the world Z axis of the world coordinate icon, appearing usually bottom left in viewports.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.ApplicationSettings","name":"ClipboardState","dataType":"enum","summary":"Defines enumerated constant values for different behavior that is related to clipboard data.","since":"5.0","values":[{"signature":"KeepData = 0","summary":"Always keep clipboard data, regardless of size and never prompt the user."},{"signature":"DeleteData","summary":"Always delete clipboard data, regardless of size and never prompt the user."},{"signature":"PromptWhenBig","summary":"Prompt user when clipboard memory is large."}]},{"namespace":"Rhino.ApplicationSettings","name":"CommandAliasList","dataType":"class","summary":"Contains static methods and properties to access command aliases.","properties":[{"signature":"static int Count","summary":"Returns the number of command alias in Rhino.","since":"5.0","property":["get"]}],"methods":[{"signature":"static bool Add(string alias, string macro)","summary":"Adds a new command alias to Rhino.","since":"5.0","parameters":[{"name":"alias","summary":"[in] The name of the command alias."},{"name":"macro","summary":"[in] The command macro to run when the alias is executed."}],"returns":"True if successful."},{"signature":"static void Clear()","summary":"Removes all aliases from the list.","since":"5.0"},{"signature":"static bool Delete(string alias)","summary":"Deletes an existing command alias from Rhino.","since":"5.0","parameters":[{"name":"alias","summary":"[in] The name of the command alias."}],"returns":"True if successful."},{"signature":"static System.Collections.Generic.Dictionary<string, string> GetDefaults()","summary":"Constructs a dictionary containing as keys the default names and as value the default macro.  \\nThe returned dictionary contains a copy of the settings.","since":"5.0","returns":"A new dictionary with the default name/macro combinations."},{"signature":"static string GetMacro(string alias)","summary":"Returns the macro of a command alias.","since":"5.0","parameters":[{"name":"alias","summary":"[in] The name of the command alias."}]},{"signature":"static string[] GetNames()","summary":"Returns a list of command alias names.","since":"5.0","returns":"An array of strings. This can be empty."},{"signature":"static bool IsAlias(string alias)","summary":"Verifies that a command alias exists in Rhino.","since":"5.0","parameters":[{"name":"alias","summary":"[in] The name of the command alias."}],"returns":"True if the alias exists."},{"signature":"static bool IsDefault()","summary":"Computes a value indicating if the current alias list is the same as the default alias list.","since":"5.0","returns":"True if the current alias list is exactly equal to the default alias list; False otherwise."},{"signature":"static bool SetMacro(string alias, string macro)","summary":"Modifies the macro of a command alias.","since":"5.0","parameters":[{"name":"alias","summary":"[in] The name of the command alias."},{"name":"macro","summary":"[in] The new command macro to run when the alias is executed."}],"returns":"True if successful."},{"signature":"static System.Collections.Generic.Dictionary<string,string> ToDictionary()","summary":"Constructs a new dictionary that contains: as keys all names and as values all macros.  \\nModifications to this dictionary do not affect any Rhino command alias.","since":"5.0","returns":"The new dictionary."}]},{"namespace":"Rhino.ApplicationSettings","name":"CommandPromptPosition","dataType":"enum","summary":"Defines enumerated constant values for default positions of the command prompt inside the frame of the full editor window.","since":"5.0","values":[{"signature":"Top = 0","summary":"The command prompt is shown on top."},{"signature":"Bottom = 1","summary":"The command prompt is shown at the bottom."},{"signature":"Floating = 2","summary":"The command prompt is shown floating."},{"signature":"Hidden = 3","summary":"The command prompt is shown hidden."}]},{"namespace":"Rhino.ApplicationSettings","name":"CursorMode","dataType":"enum","summary":"Defines enumerated constant values for particular OSnap cursor colors.","since":"5.0","values":[{"signature":"None = 0","summary":"No OSnap cursor."},{"signature":"BlackOnWhite","summary":"Black on white OSnap cursor."},{"signature":"WhiteOnBlack","summary":"White on black OSnap cursor."}]},{"namespace":"Rhino.ApplicationSettings","name":"CursorTooltipSettings","dataType":"class","summary":"Cursor tooltips place information at the cursor location. Note: Turning on cursor tooltips turns off object snap cursors.","properties":[{"signature":"static bool AutoSuppress","summary":"Attempts to display only the most useful tooltip.","since":"5.0","property":["get","set"]},{"signature":"static Color BackgroundColor","summary":"Tooltip background color.","since":"5.0","property":["get","set"]},{"signature":"static bool CommandPromptPane","summary":"Displays the current command prompt.","since":"5.0","property":["get","set"]},{"signature":"static bool DistancePane","summary":"Displays the distance from the last picked point.","since":"5.0","property":["get","set"]},{"signature":"static Point Offset","summary":"The x and y distances in pixels from the cursor location to the tooltip.","since":"5.0","property":["get","set"]},{"signature":"static bool OsnapPane","summary":"Displays the current object snap selection.","since":"5.0","property":["get","set"]},{"signature":"static bool PointPane","summary":"Displays the current construction plane coordinates.","since":"5.0","property":["get","set"]},{"signature":"static bool RelativePointPane","summary":"Displays the relative construction plane coordinates and angle from the last picked point.","since":"5.0","property":["get","set"]},{"signature":"static Color TextColor","summary":"Tooltip text color.","since":"5.0","property":["get","set"]},{"signature":"static bool TooltipsEnabled","summary":"Turns on/off cursor tooltips.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static CursorTooltipSettingsState GetCurrentState()","summary":"Gets the current settings.","since":"5.0","returns":"A new cursor tooltip state with current settings."},{"signature":"static CursorTooltipSettingsState GetDefaultState()","summary":"Gets the cursor tooltip factory settings.","since":"5.0","returns":"A new cursor tooltip state with factory settings."}]},{"namespace":"Rhino.ApplicationSettings","name":"CursorTooltipSettingsState","dataType":"class","summary":"Represents a snapshot of CursorTooltipSettings.","properties":[{"signature":"bool AutoSuppress","summary":"Attempts to display only the most useful tooltip.","since":"5.0","property":["get","set"]},{"signature":"Color BackgroundColor","summary":"Tooltip background color.","since":"5.0","property":["get","set"]},{"signature":"bool CommandPromptPane","summary":"Displays the current command prompt.","since":"5.0","property":["get","set"]},{"signature":"bool DistancePane","summary":"Displays the distance from the last picked point.","since":"5.0","property":["get","set"]},{"signature":"Point Offset","summary":"The x and y distances in pixels from the cursor location to the tooltip.","since":"5.0","property":["get","set"]},{"signature":"bool OsnapPane","summary":"Displays the current object snap selection.","since":"5.0","property":["get","set"]},{"signature":"bool PointPane","summary":"Displays the current construction plane coordinates.","since":"5.0","property":["get","set"]},{"signature":"bool RelativePointPane","summary":"Displays the relative construction plane coordinates and angle from the last picked point.","since":"5.0","property":["get","set"]},{"signature":"Color TextColor","summary":"Tooltip text color.","since":"5.0","property":["get","set"]},{"signature":"bool TooltipsEnabled","summary":"Turns on/off cursor tooltips.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.ApplicationSettings","name":"CurvatureAnalysisSettings","dataType":"class","summary":"Contains static methods and properties to modify curvature analysis-related commands.","properties":[{"signature":"static Interval GaussRange","summary":"Gets or sets the Gaussian curvature range.","since":"6.0","property":["get","set"]},{"signature":"static Interval MaxRadiusRange","summary":"Gets or sets the Maximum Radius curvature range.","since":"6.0","property":["get","set"]},{"signature":"static Interval MeanRange","summary":"Gets or sets the Mean curvature range.","since":"6.0","property":["get","set"]},{"signature":"static Interval MinRadiusRange","summary":"Gets or sets the Minimum Radius curvature range.","since":"6.0","property":["get","set"]},{"signature":"static CurvatureStyle Style","summary":"Gets or sets the curvature analysis style.","since":"6.0","property":["get","set"]}],"methods":[{"signature":"static bool CalculateCurvatureAutoRange(IEnumerable<Mesh> meshes, ref CurvatureAnalysisSettingsState settings)","since":"6.0"},{"signature":"static CurvatureAnalysisSettingsState GetCurrentState()","summary":"Gets the current settings of the application.","since":"6.0"},{"signature":"static CurvatureAnalysisSettingsState GetDefaultState()","summary":"Gets the factory settings of the application.","since":"6.0"},{"signature":"static void RestoreDefaults()","summary":"Commits the default settings as the current settings.","since":"6.0"},{"signature":"static void UpdateFromState(CurvatureAnalysisSettingsState state)","summary":"Sets all settings to a particular defined joined state.","since":"6.0","parameters":[{"name":"state","summary":"The particular state."}]}]},{"namespace":"Rhino.ApplicationSettings","name":"CurvatureAnalysisSettings.CurvatureStyle","dataType":"enum","summary":"Curvature analysis styles","since":"6.0","values":[{"signature":"Gaussian = 0","summary":"Gaussian curvature"},{"signature":"Mean = 1","summary":"Mean curvature"},{"signature":"MinRadius = 2","summary":"Minimum radius curvature"},{"signature":"MaxRadius = 3","summary":"Maximum radius curvature"}]},{"namespace":"Rhino.ApplicationSettings","name":"CurvatureAnalysisSettingsState","dataType":"class","summary":"Represents a snapshot of CurvatureAnalysisSettings.","properties":[{"signature":"Interval GaussRange","summary":"Gets or sets the Gaussian curvature range.","since":"6.0","property":["get","set"]},{"signature":"Interval MaxRadiusRange","summary":"Gets or sets the Maximum Radius curvature range.","since":"6.0","property":["get","set"]},{"signature":"Interval MeanRange","summary":"Gets or sets the Mean curvature range.","since":"6.0","property":["get","set"]},{"signature":"Interval MinRadiusRange","summary":"Gets or sets the Minimum Radius curvature range.","since":"6.0","property":["get","set"]},{"signature":"CurvatureStyle Style","summary":"Gets or sets the curvature analysis style.","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.ApplicationSettings","name":"DraftAngleAnalysisSettings","dataType":"class","properties":[{"signature":"static Interval AngleRange","summary":"The angle range.","since":"7.0","property":["get","set"]},{"signature":"static bool ShowIsoCurves","summary":"Show isoparametric curves.","since":"7.0","property":["get","set"]},{"signature":"static Vector3d UpDirection","summary":"The up direction.","since":"7.0","property":["get","set"]}],"methods":[{"signature":"static DraftAngleAnalysisSettingsState GetCurrentState()","summary":"Gets the current settings of the application.","since":"7.0"},{"signature":"static DraftAngleAnalysisSettingsState GetDefaultState()","summary":"Gets the factory settings of the application.","since":"7.0"},{"signature":"static void RestoreDefaults()","summary":"Commits the default settings as the current settings.","since":"7.0"},{"signature":"static void UpdateFromState(DraftAngleAnalysisSettingsState state)","summary":"Sets all settings to a particular defined joined state.","since":"7.0","parameters":[{"name":"state","summary":"The particular state."}]}]},{"namespace":"Rhino.ApplicationSettings","name":"DraftAngleAnalysisSettingsState","dataType":"class","summary":"Represents a snapshot of DraftAngleAnalysisSettings","properties":[{"signature":"Interval AngleRange","summary":"The angle range.","since":"7.0","property":["get","set"]},{"signature":"bool ShowIsoCurves","summary":"Show isoparametric curves.","since":"7.0","property":["get","set"]},{"signature":"Vector3d UpDirection","summary":"The up direction.","since":"7.0","property":["get","set"]}]},{"namespace":"Rhino.ApplicationSettings","name":"EdgeAnalysisSettings","dataType":"class","summary":"Contains static methods and properties to modify the visibility of edges in edge-related commands.","properties":[{"signature":"static Color ShowEdgeColor","summary":"Gets or sets a color used to enhance display edges in commands like _ShowEdges and _ShowNakedEdges.","since":"5.0","property":["get","set"]},{"signature":"static int ShowEdges","summary":"Gets or sets a value referring to the group of edges that are targeted.  \\n0 = all.  \\n1 = naked.  \\n2 = non-manifold.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static EdgeAnalysisSettingsState GetCurrentState()","summary":"Gets the current settings of the application.","since":"5.0"},{"signature":"static EdgeAnalysisSettingsState GetDefaultState()","summary":"Gets the factory settings of the application.","since":"5.0"},{"signature":"static void RestoreDefaults()","summary":"Commits the default settings as the current settings.","since":"5.0"},{"signature":"static void UpdateFromState(EdgeAnalysisSettingsState state)","summary":"Sets all settings to a particular defined joined state.","since":"5.0","parameters":[{"name":"state","summary":"The particular state."}]}]},{"namespace":"Rhino.ApplicationSettings","name":"EdgeAnalysisSettingsState","dataType":"class","summary":"Represents a snapshot of EdgeAnalysisSettings.","properties":[{"signature":"Color ShowEdgeColor","summary":"Gets or sets a color used to enhance display edges in commands like _ShowEdges and _ShowNakedEdges.","since":"5.0","property":["get","set"]},{"signature":"int ShowEdges","summary":"Gets or sets a value referring to the group of edges that are targeted.  \\n0 = all.  \\n1 = naked.  \\n2 = non-manifold.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.ApplicationSettings","name":"FileSettings","dataType":"class","summary":"Contains static methods and properties relating Rhino files.","properties":[{"signature":"static bool AutoSaveEnabled","summary":"Enables or disables Rhino\'s automatic file saving mechanism.","since":"5.0","property":["get","set"]},{"signature":"static string AutoSaveFile","summary":"the file name used by Rhino\'s automatic file saving mechanism.","since":"5.0","property":["get","set"]},{"signature":"static TimeSpan AutoSaveInterval","summary":"how often the document will be saved when Rhino\'s automatic file saving mechanism is enabled.","since":"5.0","property":["get","set"]},{"signature":"static bool AutoSaveMeshes","summary":"save render and display meshes in autosave file.","since":"5.0","property":["get","set"]},{"signature":"static bool ClipboardCopyToPreviousRhinoVersion","summary":"Gets or sets a value that decides if copies to the clipboard are performed in both the current and previous Rhino clipboard formats.  This means you will double the size of what is saved in the clipboard but will be able to copy from the current to the previous version using the clipboard.","since":"5.0","property":["get","set"]},{"signature":"static ClipboardState ClipboardOnExit","summary":"Gets or sets a value that determines what to do with clipboard data on exit.","since":"5.0","property":["get","set"]},{"signature":"static bool CreateBackupFiles","summary":"Gets or sets a value that controls the creation of backup files.","since":"5.0","property":["get","set"]},{"signature":"static string DefaultRuiFile","summary":"Gets the path to the default RUI file.","since":"5.0","property":["get"]},{"signature":"static string ExecutableFolder","summary":"Returns the directory where the main Rhino executable is located.","since":"5.0","property":["get"]},{"signature":"static bool FileLockingEnabled","summary":"Ensure that only one person at a time can have a file open for saving.","since":"5.0","property":["get","set"]},{"signature":"static bool FileLockingOpenWarning","summary":"Gets or sets whether to display the information dialog which identifies computer files.","since":"5.0","property":["get","set"]},{"signature":"static string HelpFilePath","summary":"Gets the Rhino help file path.","since":"5.0","property":["get"]},{"signature":"static DirectoryInfo InstallFolder","summary":"Returns Rhino\'s installation folder.","since":"5.0","property":["get"]},{"signature":"static string LocalProfileDataFolder","summary":"Get full path to a Rhino specific sub-folder under the per-user Local (non-roaming) Profile folder.  This is the folder where user-specific data is stored.  On Windows 7, 8, usually someplace like: \\"C:\\\\Users\\\\[USERNAME]\\\\AppData\\\\Local\\\\McNeel\\\\Rhinoceros\\\\[VERSION_NUMBER]\\\\\\"","since":"5.8","property":["get"]},{"signature":"static bool SaveViewChanges","summary":"True for users who consider view changes a document change.","since":"5.0","property":["get","set"]},{"signature":"static int SearchPathCount","summary":"Gets the amount of search paths that are currently defined.","since":"5.0","property":["get"]},{"signature":"static string TemplateFile","summary":"Returns or sets the location of Rhino\'s template file.","since":"5.0","property":["get","set"]},{"signature":"static string TemplateFolder","summary":"Returns or sets the location of Rhino\'s template files.","since":"5.0","property":["get","set"]},{"signature":"static string WorkingFolder","summary":"Returns or sets Rhino\'s working directory, or folder. The working folder is the default folder for all file operations.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static int AddSearchPath(string folder, int index)","summary":"Adds a new imagePath to Rhino\'s search imagePath list. See \\"Options Files settings\\" in the Rhino help file for more details.","since":"5.0","parameters":[{"name":"folder","summary":"[in] The valid folder, or imagePath, to add."},{"name":"index","summary":"[in] A zero-based position index in the search imagePath list to insert the string. If -1, the imagePath will be appended to the end of the list."}],"returns":"The index where the item was inserted if success.  \\n-1 on failure."},{"signature":"static string[] AutoSaveBeforeCommands()","summary":"Input list of commands that force AutoSave prior to running.","since":"5.0"},{"signature":"static bool DeleteSearchPath(string folder)","summary":"Removes an existing imagePath from Rhino\'s search imagePath list. See \\"Options Files settings\\" in the Rhino help file for more details.","since":"5.0","parameters":[{"name":"folder","summary":"[in] The valid folder, or imagePath, to remove."}],"returns":"True or False indicating success or failure."},{"signature":"static string FindFile(string fileName)","summary":"Searches for a file using Rhino\'s search imagePath. Rhino will look for a file in the following locations: 1. The current document\'s folder. 2. Folder\'s specified in Options dialog, File tab. 3. Rhino\'s System folders.","since":"5.0","parameters":[{"name":"fileName","summary":"short file name to search for."}],"returns":"full imagePath on success; None on error."},{"signature":"static FileSettingsState GetCurrentState()","summary":"Returns the current state.","since":"5.0","returns":"A new instance containing the current state."},{"signature":"static string GetDataFolder(bool currentUser)","summary":"Gets the data folder for machine or current user.","since":"5.0","parameters":[{"name":"currentUser","summary":"True if the query relates to the current user."}],"returns":"A directory to user or machine data."},{"signature":"static FileSettingsState GetDefaultState()","summary":"Returns the default state.","since":"5.0","returns":"A new instance containing the default state."},{"signature":"static string[] GetSearchPaths()","summary":"Returns all of the imagePath items in Rhino\'s search imagePath list. See \\"Options Files settings\\" in the Rhino help file for more details.","since":"5.0"},{"signature":"static string[] RecentlyOpenedFiles()","summary":"Returns a list of recently opened files. Note that this function does not check to make sure that these files still exist.","since":"5.0","returns":"An array of strings with the paths to the recently opened files."},{"signature":"static void SetAutoSaveBeforeCommands(string[] commands)","summary":"Set list of commands that force AutoSave prior to running.","since":"5.0"}]},{"namespace":"Rhino.ApplicationSettings","name":"FileSettingsState","dataType":"class","summary":"Represents a snapshot of FileSettings.","properties":[{"signature":"bool AutoSaveEnabled","summary":"Enables or disables Rhino\'s automatic file saving mechanism.","since":"5.0","property":["get","set"]},{"signature":"TimeSpan AutoSaveInterval","summary":"How often the document will be saved when Rhino\'s automatic file saving mechanism is enabled.","since":"5.0","property":["get","set"]},{"signature":"bool AutoSaveMeshes","summary":"Saves render and display meshes in autosave file.","since":"5.0","property":["get","set"]},{"signature":"bool ClipboardCopyToPreviousRhinoVersion","summary":"Gets or sets a value that decides if copies to the clipboard are performed in both the current and previous Rhino clipboard formats.  This means you will double the size of what is saved in the clipboard but will be able to copy from the current to the previous version using the clipboard.","since":"5.0","property":["get","set"]},{"signature":"ClipboardState ClipboardOnExit","summary":"Gets or sets a value that determines what to do with clipboard data on exit.","since":"5.0","property":["get","set"]},{"signature":"bool CreateBackupFiles","summary":"Gets or sets a value indicating whether to create backup files.","since":"5.0","property":["get","set"]},{"signature":"bool FileLockingEnabled","summary":"Ensures that only one person at a time can have a file open for saving.","since":"5.0","property":["get","set"]},{"signature":"bool FileLockingOpenWarning","summary":"Displays an information dialog which identifies computer file is open on.","since":"5.0","property":["get","set"]},{"signature":"bool SaveViewChanges","summary":"True for users who consider view changes a document change.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.ApplicationSettings","name":"GeneralSettings","dataType":"class","summary":"Contains static methods and properties to give access to Rhinoceros settings.","properties":[{"signature":"static bool AutoUpdateCommandHelp","summary":"Command help dialog auto-update feature.","since":"5.0","property":["get","set"]},{"signature":"static TimeSpan ContextMenuDelay","summary":"Time to wait before permitting context menu display.","since":"5.0","property":["get","set"]},{"signature":"static bool EnableContextMenu","summary":"True if right mouse down + delay will pop up context menu on a mouse up if no move happens.","since":"5.0","property":["get","set"]},{"signature":"static int MaximumPopupMenuLines","summary":"Gets or sets the maximum number of popup menu lines.","since":"5.0","property":["get","set"]},{"signature":"static int MaximumUndoMemoryMb","summary":"Gets or sets the minimum undo memory Mb.  \\nUndo records will be purged if there are more than MinimumUndoSteps and they use more than MaximumUndoMemoryMb.","since":"5.0","property":["get","set"]},{"signature":"static string MiddleMouseMacro","summary":"Gets or sets the toolbar to popup when the middle mouse is clicked on a view, this value is only used when MiddleMouseMode is set to PopupToolbar.","since":"5.0","property":["get","set"]},{"signature":"static MiddleMouseMode MiddleMouseMode","summary":"Gets or sets what happens when the user clicks the middle mouse.","since":"5.0","property":["get","set"]},{"signature":"static string MiddleMousePopupToolbar","summary":"Gets or sets the toolbar to popup when the middle mouse is clicked on a view, this value is only used when MiddleMouseMode is set to PopupToolbar.","since":"5.0","property":["get","set"]},{"signature":"static int MinimumUndoSteps","summary":"Gets or sets the minimum undo steps.  \\nUndo records will be purged if there are more than MinimumUndoSteps and they use more than MaximumUndoMemoryMb.","since":"5.0","property":["get","set"]},{"signature":"static MouseSelectMode MouseSelectMode","summary":"Gets or sets the current selection mode.","since":"5.0","property":["get","set"]},{"signature":"static int NewObjectIsoparmCount","summary":"Gets or sets the number of isoparm curves to show on new objects.","since":"5.0","property":["get","set"]},{"signature":"static bool UseExtrusions","summary":"Should extrusion objects be created for things like cylinders","since":"6.0","property":["get"]}],"methods":[{"signature":"static GeneralSettingsState GetCurrentState()","summary":"Gets the current settings.","since":"5.0","returns":"A new general state with current settings."},{"signature":"static GeneralSettingsState GetDefaultState()","summary":"Gets the factory settings.","since":"5.0","returns":"A new general state with factory settings."}]},{"namespace":"Rhino.ApplicationSettings","name":"GeneralSettingsState","dataType":"class","summary":"Represents a snapshot of GeneralSettings.","properties":[{"signature":"bool AutoUpdateCommandHelp","summary":"Gets or sets the command help dialog auto-update feature.","since":"5.0","property":["get","set"]},{"signature":"TimeSpan ContextMenuDelay","summary":"Gets or sets the time to wait before permitting context menu display.","since":"5.0","property":["get","set"]},{"signature":"bool EnableContextMenu","summary":"True if right mouse down + delay will pop up context menu on a mouse up if no move happens.","since":"5.0","property":["get","set"]},{"signature":"int MaximumPopupMenuLines","summary":"Gets or sets the maximum number of popup menu lines.","since":"5.0","property":["get","set"]},{"signature":"int MaximumUndoMemoryMb","summary":"Gets or sets the minimum undo memory Mb.  \\nUndo records will be purged if there are more than MinimumUndoSteps and they use more than MaximumUndoMemoryMb.","since":"5.0","property":["get","set"]},{"signature":"string MiddleMouseMacro","summary":"Gets or sets the toolbar to popup when the middle mouse is clicked on a view, this value is only used when MiddleMouseMode is set to PopupToolbar.","since":"5.0","property":["get","set"]},{"signature":"MiddleMouseMode MiddleMouseMode","summary":"Gets or sets what happens when the user clicks the middle mouse.","since":"5.0","property":["get","set"]},{"signature":"string MiddleMousePopupToolbar","summary":"Gets or sets the toolbar to popup when the middle mouse is clicked on a view, this value is only used when MiddleMouseMode is set to PopupToolbar.","since":"5.0","property":["get","set"]},{"signature":"int MinimumUndoSteps","summary":"Gets or sets the minimum undo steps.  \\nUndo records will be purged if there are more than MinimumUndoSteps and they use more than MaximumUndoMemoryMb.","since":"5.0","property":["get","set"]},{"signature":"MouseSelectMode MouseSelectMode","summary":"Gets or sets the current selection mode.","since":"5.0","property":["get","set"]},{"signature":"int NewObjectIsoparmCount","summary":"Gets or sets the number of isoparm curves to show on new objects.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.ApplicationSettings","name":"HistorySettings","dataType":"class","summary":"Provides static (Shared in Vb.Net) properties to modify Rhino History settings.","properties":[{"signature":"static bool BrokenRecordWarningEnabled","summary":"Displays a warning dialog when an action is taken that breaks the link between the output and input objects.","since":"6.10","property":["get","set"]},{"signature":"static bool ObjectLockingEnabled","summary":"When history object locking is enabled, objects with history on them act as if they were locked and the only way to modify these objects is to edit their inputs.","since":"5.0","property":["get","set"]},{"signature":"static bool RecordingEnabled","summary":"When history recording is enabled, new objects keep a record of how they were constructed so that they can be updated if an input object changes.","since":"5.0","property":["get","set"]},{"signature":"static bool UpdateEnabled","summary":"When history update is enabled, dependent objects are automatically updated when an antecedent is modified.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.ApplicationSettings","name":"Installation","dataType":"enum","summary":"The type of Rhino executable that is executing","since":"5.0","values":[{"signature":"Undefined = 0","summary":"Unknown"},{"signature":"Commercial"},{"signature":"Educational"},{"signature":"EducationalLab"},{"signature":"NotForResale"},{"signature":"NotForResaleLab"},{"signature":"Beta"},{"signature":"BetaLab"},{"signature":"Evaluation","summary":"25 Save limit evaluation version of Rhino"},{"signature":"Corporate"},{"signature":"EvaluationTimed","summary":"90 day time limit evaluation version of Rhino"}]},{"namespace":"Rhino.ApplicationSettings","name":"LicenseNode","dataType":"enum","summary":"License node types.","since":"5.0","values":[{"signature":"Standalone = 0","summary":"An independent node."},{"signature":"Network = 1","summary":"Network (obtains license from Zoo server)"},{"signature":"NetworkCheckedOut = 2","summary":"Network (has license checked out from Zoo server)"}]},{"namespace":"Rhino.ApplicationSettings","name":"MiddleMouseMode","dataType":"enum","summary":"Defines enumerated constant values to define what happens when either the middle mouse button on a three-button mouse is clicked or after pressing the wheel on a wheeled mouse.","since":"5.0","values":[{"signature":"PopupMenu = 0","summary":"Pops up two-part menu at the cursor location. You can list your favorite commands in the top section. The bottom section is the list of most recent commands used."},{"signature":"PopupToolbar = 1","summary":"Choose a toolbar to pop up at the cursor location. Create a toolbar containing your favorite commands or object snaps to use as a pop-up toolbar."},{"signature":"RunMacro = 2","summary":"Lists a series of commands that run when you click the middle mouse button."}]},{"namespace":"Rhino.ApplicationSettings","name":"ModelAidSettings","dataType":"class","summary":"Contains static methods and properties to modify model aid settings.","properties":[{"signature":"static bool AltPlusArrow","summary":"True means Alt+arrow is used for nudging.","since":"5.0","property":["get","set"]},{"signature":"static bool AutoGumballEnabled","summary":"When AutoGumball is on, a gumball automatically appears when objects are pre-picked.","since":"5.0","property":["get","set"]},{"signature":"static int ControlPolygonDisplayDensity","summary":"Gets or sets the control polygon display density.","since":"5.0","property":["get","set"]},{"signature":"static double CtrlNudgeKeyStep","summary":"Gets or sets the Ctrl-key based nudge step amount.","since":"5.0","property":["get","set"]},{"signature":"static bool DisplayControlPolygon","summary":"Gets or sets the enabled state of Rhino\'s display control polygon.","since":"5.0","property":["get","set"]},{"signature":"static bool ExtendToApparentIntersection","summary":"Gets or sets the enabled state of Rhino\'s extend to apparent intersections.","since":"5.0","property":["get","set"]},{"signature":"static bool ExtendTrimLines","summary":"Gets or sets the enabled state of Rhino\'s extend trim lines.","since":"5.0","property":["get","set"]},{"signature":"static bool GridSnap","summary":"Gets or sets the enabled state of Rhino\'s grid snap modeling aid.","since":"5.0","property":["get","set"]},{"signature":"static bool HighlightControlPolygon","summary":"Gets or sets the enabled state of Rhino\'s highlight dialog modeling aid.","since":"5.0","property":["get","set"]},{"signature":"static int MousePickboxRadius","summary":"radius of mouse pick box in pixels.","since":"5.0","property":["get","set"]},{"signature":"static double NudgeKeyStep","summary":"Gets or sets the nudge step amount.","since":"5.0","property":["get","set"]},{"signature":"static int NudgeMode","summary":"0 = world, 1 = cplane, 2 = view, 3 = UVN, -1 = not set.","since":"5.0","property":["get","set"]},{"signature":"static bool Ortho","summary":"Gets or sets the enabled state of Rhino\'s ortho modeling aid.","since":"5.0","property":["get","set"]},{"signature":"static double OrthoAngle","summary":"Gets or sets the base orthogonal angle.","since":"5.0","property":["get","set"]},{"signature":"static bool Osnap","summary":"Enables or disables Rhino\'s object snap modeling aid.","since":"5.0","property":["get","set"]},{"signature":"static CursorMode OsnapCursorMode","summary":"Gets or sets the OSnap cursor mode.","since":"5.0","property":["get","set"]},{"signature":"static OsnapModes OsnapModes","summary":"Returns or sets Rhino\'s current object snap mode. The mode is a bitwise value based on the OsnapModes enumeration.","since":"5.0","property":["get","set"]},{"signature":"static int OsnapPickboxRadius","summary":"Enables or disables Rhino\'s planar modeling aid.","since":"5.0","property":["get","set"]},{"signature":"static bool Planar","summary":"Gets or sets the enabled state of Rhino\'s Planar modeling aid.","since":"5.0","property":["get","set"]},{"signature":"static PointDisplayMode PointDisplay","summary":"Gets or sets the point display mode.","since":"5.0","property":["get","set"]},{"signature":"static bool ProjectSnapToCPlane","summary":"Gets or sets the enabled state of Rhino\'s Project modeling aid.","since":"5.0","property":["get","set"]},{"signature":"static double ShiftNudgeKeyStep","summary":"Gets or sets the Shift-key based nudge step amount.","since":"5.0","property":["get","set"]},{"signature":"static bool SnappyGumballEnabled","summary":"When SnappyGumball is on, a dragging a gumball moves the center point. When snappy gumball is off, dragging a gumball moves the mouse down point.","since":"5.0","property":["get","set"]},{"signature":"static bool SnapToLocked","summary":"Gets or sets the locked state of the snap modeling aid.","since":"5.0","property":["get","set"]},{"signature":"static bool UniversalConstructionPlaneMode","summary":"Gets or sets the locked state of the snap modeling aid.","since":"5.0","property":["get","set"]},{"signature":"static bool UseHorizontalDialog","summary":"Gets or sets the enabled state of Rhino\'s use horizontal dialog modeling aid.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static ModelAidSettingsState GetCurrentState()","summary":"Gets the current settings.","since":"5.0","returns":"A new model aid state with current settings."},{"signature":"static ModelAidSettingsState GetDefaultState()","summary":"Gets the factory settings.","since":"5.0","returns":"A new model aid state with factory settings."},{"signature":"static void UpdateFromState(ModelAidSettingsState state)","summary":"Updates from a particular setting state.","since":"5.0","parameters":[{"name":"state","summary":"The new states that will be set."}]}]},{"namespace":"Rhino.ApplicationSettings","name":"ModelAidSettingsState","dataType":"class","summary":"Represents a snapshot of ModelAidSettings.","properties":[{"signature":"bool AltPlusArrow","summary":"True mean Alt+arrow is used for nudging.","since":"5.0","property":["get","set"]},{"signature":"int ControlPolygonDisplayDensity","summary":"Gets or sets the control polygon display density.","since":"5.0","property":["get","set"]},{"signature":"double CtrlNudgeKeyStep","summary":"Gets or sets the Ctrl-key based nudge step amount.","since":"5.0","property":["get","set"]},{"signature":"bool DisplayControlPolygon","summary":"Gets or sets the enabled state of Rhino\'s display control polygon.","since":"5.0","property":["get","set"]},{"signature":"bool ExtendToApparentIntersection","summary":"Gets or sets the enabled state of Rhino\'s extend to apparent intersections.","since":"5.0","property":["get","set"]},{"signature":"bool ExtendTrimLines","summary":"Gets or sets the enabled state of Rhino\'s extend trim lines.","since":"5.0","property":["get","set"]},{"signature":"bool GridSnap","summary":"Gets or sets the enabled state of Rhino\'s grid snap modeling aid.","since":"5.0","property":["get","set"]},{"signature":"bool HighlightControlPolygon","summary":"Gets or sets the enabled state of Rhino\'s highlight dialog modeling aid.","since":"5.0","property":["get","set"]},{"signature":"int MousePickboxRadius","summary":"Gets or sets the radius of the mouse pick box in pixels.","since":"5.0","property":["get","set"]},{"signature":"double NudgeKeyStep","summary":"Gets or sets the nudge step amount.","since":"5.0","property":["get","set"]},{"signature":"int NudgeMode","summary":"0 = world, 1 = cplane, 2 = view, 3 = UVN, -1 = not set.","since":"5.0","property":["get","set"]},{"signature":"bool Ortho","summary":"Gets or sets the enabled state of Rhino\'s ortho modeling aid.","since":"5.0","property":["get","set"]},{"signature":"double OrthoAngle","summary":"Gets or sets the base orthogonal angle.","since":"5.0","property":["get","set"]},{"signature":"bool Osnap","summary":"Gets or sets the enabled state of Rhino\'s object snap modeling aid.","since":"5.0","property":["get","set"]},{"signature":"CursorMode OsnapCursorMode","summary":"Gets or sets the OSnap cursor mode.","since":"5.0","property":["get","set"]},{"signature":"OsnapModes OsnapModes","summary":"Returns or sets Rhino\'s current object snap mode.  \\nThe mode is a bitwise value based on the OsnapModes enumeration.","since":"5.0","property":["get","set"]},{"signature":"int OsnapPickboxRadius","summary":"Enables or disables Rhino\'s planar modeling aid.","since":"5.0","property":["get","set"]},{"signature":"bool Planar","summary":"Gets or sets the enabled state of Rhino\'s Planar modeling aid.","since":"5.0","property":["get","set"]},{"signature":"PointDisplayMode PointDisplay","summary":"Gets or sets the point display mode.","since":"5.0","property":["get","set"]},{"signature":"bool ProjectSnapToCPlane","summary":"Gets or sets the enabled state of Rhino\'s Project modeling aid.","since":"5.0","property":["get","set"]},{"signature":"double ShiftNudgeKeyStep","summary":"Gets or sets the Shift-key based nudge step amount.","since":"5.0","property":["get","set"]},{"signature":"bool SnapToLocked","summary":"Gets or sets the locked state of the snap modeling aid.","since":"5.0","property":["get","set"]},{"signature":"bool UniversalConstructionPlaneMode","summary":"Gets or sets the locked state of the snap modeling aid.","since":"5.0","property":["get","set"]},{"signature":"bool UseHorizontalDialog","summary":"Gets or sets the enabled state of Rhino\'s use horizontal dialog modeling aid.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.ApplicationSettings","name":"MouseSelectMode","dataType":"enum","summary":"Defines enumerated constant values to indicate a particular window selection mode.","since":"5.0","values":[{"signature":"Crossing = 0","summary":"Anything that crosses this window will be selected."},{"signature":"Window = 1","summary":"Anything that is inside this window will be selected."},{"signature":"Combo = 2","summary":"Drag a rectangle from left to right for window select. Drag a rectangle from right to left for crossing select."}]},{"namespace":"Rhino.ApplicationSettings","name":"NeverRepeatList","dataType":"class","summary":"Contains static methods and properties relating to the list of commands that are never repeated.","properties":[{"signature":"static bool UseNeverRepeatList","summary":"Only use the list if somebody modifies it via CRhinoAppSettings::SetDontRepeatCommands(). Return value of True means CRhinoCommand don\'t repeat flags will be ignored and the m_dont_repeat_list will be used instead.  False means the individual CRhinoCommands will determine if they are repeatable.","since":"5.0","property":["get"]}],"methods":[{"signature":"static string[] CommandNames()","summary":"The list of commands to not repeat.","since":"5.0"},{"signature":"static int SetList(string[] commandNames)","summary":"Puts the command name tokens in m_dont_repeat_list.","since":"5.0","returns":"Number of items added to m_dont_repeat_list."}]},{"namespace":"Rhino.ApplicationSettings","name":"OpenGLSettings","dataType":"class","summary":"Static methods and properties to control OpenGL settings","properties":[{"signature":"static AntialiasLevel AntialiasLevel","summary":"Gets or sets the anti-alias level used by OpenGL viewports","since":"6.1","property":["get","set"]}],"methods":[{"signature":"static OpenGLSettingsState GetCurrentState()","summary":"Gets the current settings.","since":"6.1","returns":"A new OpenGL state with current settings."},{"signature":"static OpenGLSettingsState GetDefaultState()","summary":"Gets the OpenGL factory settings.","since":"6.1","returns":"A new OpenGL state with factory settings."},{"signature":"static void RestoreDefaults()","summary":"Updates from the default setting state.","since":"6.1"},{"signature":"static void UpdateFromState(OpenGLSettingsState state)","summary":"Updates from a particular setting state.","since":"6.1","parameters":[{"name":"state","summary":"The new state that will be set."}]}]},{"namespace":"Rhino.ApplicationSettings","name":"OpenGLSettingsState","dataType":"class","summary":"Represents a snapshot of OpenGLSettings","properties":[{"signature":"AntialiasLevel AntialiasLevel","summary":"AA level used in OpenGL viewports","since":"6.1","property":["get","set"]}]},{"namespace":"Rhino.ApplicationSettings","name":"OsnapModes","dataType":"enum","summary":"Defines several bit masks for each of the OSnap that are defined.  \\nRefer to the Rhino Help file for further information.","since":"5.0","values":[{"signature":"None = 0","summary":"No OSnap."},{"signature":"Near = 2","summary":"Near OSnap."},{"signature":"Focus = 8","summary":"Focus OSnap."},{"signature":"Center = 0x20","summary":"Center OSnap."},{"signature":"Vertex = 0x40","summary":"Vertex OSnap."},{"signature":"Knot = 0x80","summary":"Knot OSnap."},{"signature":"Quadrant = 0x200","summary":"Quadrant OSnap."},{"signature":"Midpoint = 0x800","summary":"Midpoint OSnap."},{"signature":"Intersection = 0x2000","summary":"Intersection OSnap."},{"signature":"End = 0x20000","summary":"End OSnap."},{"signature":"Perpendicular = 0x80000","summary":"Perpendicular OSnap."},{"signature":"Tangent = 0x200000","summary":"Tangent OSnap."},{"signature":"Point =  0x8000000","summary":"Point OSnap."}]},{"namespace":"Rhino.ApplicationSettings","name":"PaintColor","dataType":"enum","summary":"Contains enumerated constant values to represent logical colors associated with elements of the user interface.","values":[{"signature":"NormalStart = 0","summary":"Gradient start for active toolbar tab and non-client area of Rhino."},{"signature":"NormalEnd = 1","summary":"Gradient end for active toolbar tab and non-client area of Rhino."},{"signature":"NormalBorder = 2","summary":"Edge color used for grippers, toolbar border, resize bars, status bar pane borders."},{"signature":"HotStart = 3","summary":"Gradient start for inactive toolbar tab."},{"signature":"HotEnd = 4","summary":"Gradient end for inactive toolbar tab."},{"signature":"HotBorder = 5","summary":"Inactive toolbar tab border."},{"signature":"PressedStart = 6","summary":"Pressed gradient start."},{"signature":"PressedEnd = 7","summary":"Pressed gradient end."},{"signature":"PressedBorder = 8","summary":"Pressed border."},{"signature":"TextEnabled = 9","summary":"Toolbar tab text and status bar text."},{"signature":"TextDisabled = 10","summary":"Disabled text color."},{"signature":"MouseOverControlStart = 11","summary":"Color for hovering gradient start."},{"signature":"MouseOverControlEnd = 12","summary":"Color for hovering gradient end."},{"signature":"MouseOverControlBorder = 13","summary":"Color for hovering border."},{"signature":"ActiveCaption = 14","summary":"Active floating window non-client area"},{"signature":"InactiveCaption = 15","summary":"Inactive floating window non-client area"},{"signature":"PanelBackground = 16","summary":"Background color of panels"},{"signature":"ActiveViewportTitle = 17","summary":"Active viewport title."},{"signature":"InactiveViewportTitle = 18","summary":"Inactive viewport title."},{"signature":"ModifiedValueControlColor = 19","summary":"Modified property value label text color"},{"signature":"EditBoxBackground = 20","summary":"Background fill for input elements (edit box, checkbox)"},{"signature":"GridLines = 21","summary":"Grid lines for options list"}]},{"namespace":"Rhino.ApplicationSettings","name":"PointDisplayMode","dataType":"enum","summary":"Defines enumerated constant values for world coordinates and CPlane point display modes.","since":"5.0","values":[{"signature":"WorldPoint = 0","summary":"Points are displayed in world coordinates."},{"signature":"CplanePoint","summary":"Points are displayed in CPlane coordinates."}]},{"namespace":"Rhino.ApplicationSettings","name":"SelectionFilterSettings","dataType":"class","summary":"Selection filter settings restrict any selection mode (SelWindow, SelCrossing, SelAll, etc.) to specified object types. Note, selection filter settings are not persistent.","properties":[{"signature":"static bool Enabled","summary":"Enables or disables the global object selection filter.","since":"7.0","property":["get","set"]},{"signature":"static ObjectType GlobalGeometryFilter","summary":"The global geometry type filter controls which types of geometry will be filtered. Note, the filter can be a bitwise combination of multiple object types.","since":"7.0","property":["get","set"]},{"signature":"static ObjectType OneShotGeometryFilter","summary":"The one-shot geometry type filter controls which types of geometry will be filtered for one selection. Note, the filter can be a bitwise combination of multiple object types.","since":"7.0","property":["get","set"]},{"signature":"static bool SubObjectSelect","summary":"Enables or disabled sub-object selection.","since":"7.0","property":["get","set"]}],"methods":[{"signature":"static SelectionFilterSettingsState GetCurrentState()","summary":"Gets the current settings of the application.","since":"7.0"},{"signature":"static SelectionFilterSettingsState GetDefaultState()","summary":"Gets the factory settings of the application.","since":"7.0"},{"signature":"static void RestoreDefaults()","summary":"Commits the default settings as the current settings.","since":"7.0"},{"signature":"static void UpdateFromState(SelectionFilterSettingsState state)","summary":"Sets all settings to a particular defined joined state.","since":"7.0","parameters":[{"name":"state","summary":"The particular state."}]}]},{"namespace":"Rhino.ApplicationSettings","name":"SelectionFilterSettingsState","dataType":"class","summary":"Represents a snapshot of SelectionFilterSettings.","properties":[{"signature":"bool Enabled","summary":"Enables or disables the global object selection filter.","since":"7.0","property":["get","set"]},{"signature":"ObjectType GlobalGeometryFilter","summary":"The global geometry type filter controls which types of geometry will be filtered. Note, the filter can be a bitwise combination of multiple object types.","since":"7.0","property":["get","set"]},{"signature":"ObjectType OneShotGeometryFilter","summary":"The one-shot geometry type filter controls which types of geometry will be filtered for one selection. Note, the filter can be a bitwise combination of multiple object types.","since":"7.0","property":["get","set"]},{"signature":"bool SubObjectSelect","summary":"Enables or disabled sub-object selection.","since":"7.0","property":["get","set"]}]},{"namespace":"Rhino.ApplicationSettings","name":"ShortcutKey","dataType":"enum","summary":"Shortcut key combinations","since":"5.0","values":[{"signature":"F1 = 0","summary":"F1"},{"signature":"F2","summary":"F2"},{"signature":"F3","summary":"F3"},{"signature":"F4","summary":"F4"},{"signature":"F5","summary":"F5"},{"signature":"F6","summary":"F6"},{"signature":"F7","summary":"F7"},{"signature":"F8","summary":"F8"},{"signature":"F9","summary":"F9"},{"signature":"F10","summary":"F10"},{"signature":"F11","summary":"F11"},{"signature":"F12","summary":"F12"},{"signature":"CtrlF1","summary":"Ctrl + F1"},{"signature":"CtrlF2","summary":"Ctrl + F2"},{"signature":"CtrlF3","summary":"Ctrl + F3"},{"signature":"CtrlF4","summary":"Ctrl + F4"},{"signature":"CtrlF5","summary":"Ctrl + F5"},{"signature":"CtrlF6","summary":"Ctrl + F6"},{"signature":"CtrlF7","summary":"Ctrl + F7"},{"signature":"CtrlF8","summary":"Ctrl + F8"},{"signature":"CtrlF9","summary":"Ctrl + F9"},{"signature":"CtrlF10","summary":"Ctrl + F10"},{"signature":"CtrlF11","summary":"Ctrl + F11"},{"signature":"CtrlF12","summary":"Ctrl + F12"},{"signature":"ShiftCtrlF1","summary":"Shift + Ctrl + F1"},{"signature":"ShiftCtrlF2","summary":"Shift + Ctrl + F2"},{"signature":"ShiftCtrlF3","summary":"Shift + Ctrl + F3"},{"signature":"ShiftCtrlF4","summary":"Shift + Ctrl + F4"},{"signature":"ShiftCtrlF5","summary":"Shift + Ctrl + F5"},{"signature":"ShiftCtrlF6","summary":"Shift + Ctrl + F6"},{"signature":"ShiftCtrlF7","summary":"Shift + Ctrl + F7"},{"signature":"ShiftCtrlF8","summary":"Shift + Ctrl + F8"},{"signature":"ShiftCtrlF9","summary":"Shift + Ctrl + F9"},{"signature":"ShiftCtrlF10","summary":"Shift + Ctrl + F10"},{"signature":"ShiftCtrlF11","summary":"Shift + Ctrl + F11"},{"signature":"ShiftCtrlF12","summary":"Shift + Ctrl + F12"},{"signature":"AltCtrlF1","summary":"Alt + Ctrl + F1"},{"signature":"AltCtrlF2","summary":"Alt + Ctrl + F2"},{"signature":"AltCtrlF3","summary":"Alt + Ctrl + F3"},{"signature":"AltCtrlF4","summary":"Alt + Ctrl + F4"},{"signature":"AltCtrlF5","summary":"Alt + Ctrl + F5"},{"signature":"AltCtrlF6","summary":"Alt + Ctrl + F6"},{"signature":"AltCtrlF7","summary":"Alt + Ctrl + F7"},{"signature":"AltCtrlF8","summary":"Alt + Ctrl + F8"},{"signature":"AltCtrlF9","summary":"Alt + Ctrl + F9"},{"signature":"AltCtrlF10","summary":"Alt + Ctrl + F10"},{"signature":"AltCtrlF11","summary":"Alt + Ctrl + F11"},{"signature":"AltCtrlF12","summary":"Alt + Ctrl + F12"},{"signature":"CtrlA","summary":"Ctrl + A"},{"signature":"CtrlB","summary":"Ctrl + B"},{"signature":"CtrlC","summary":"Ctrl + C"},{"signature":"CtrlD","summary":"Ctrl + D"},{"signature":"CtrlE","summary":"Ctrl + E"},{"signature":"CtrlF","summary":"Ctrl + F"},{"signature":"CtrlG","summary":"Ctrl + G"},{"signature":"CtrlH","summary":"Ctrl + H"},{"signature":"CtrlI","summary":"Ctrl + I"},{"signature":"CtrlJ","summary":"Ctrl + J"},{"signature":"CtrlK","summary":"Ctrl + K"},{"signature":"CtrlL","summary":"Ctrl + L"},{"signature":"CtrlM","summary":"Ctrl + M"},{"signature":"CtrlN","summary":"Ctrl + N"},{"signature":"CtrlO","summary":"Ctrl + O"},{"signature":"CtrlP","summary":"Ctrl + P"},{"signature":"CtrlQ","summary":"Ctrl + Q"},{"signature":"CtrlR","summary":"Ctrl + R"},{"signature":"CtrlS","summary":"Ctrl + S"},{"signature":"CtrlT","summary":"Ctrl + T"},{"signature":"CtrlU","summary":"Ctrl + U"},{"signature":"CtrlV","summary":"Ctrl + V"},{"signature":"CtrlW","summary":"Ctrl + W"},{"signature":"CtrlX","summary":"Ctrl + X"},{"signature":"CtrlY","summary":"Ctrl + Y"},{"signature":"CtrlZ","summary":"Ctrl + Z"},{"signature":"ShiftCtrlA","summary":"Shift + Ctrl + A"},{"signature":"ShiftCtrlB","summary":"Shift + Ctrl + B"},{"signature":"ShiftCtrlC","summary":"Shift + Ctrl + C"},{"signature":"ShiftCtrlD","summary":"Shift + Ctrl + D"},{"signature":"ShiftCtrlE","summary":"Shift + Ctrl + E"},{"signature":"ShiftCtrlF","summary":"Shift + Ctrl + F"},{"signature":"ShiftCtrlG","summary":"Shift + Ctrl + G"},{"signature":"ShiftCtrlH","summary":"Shift + Ctrl + H"},{"signature":"ShiftCtrlI","summary":"Shift + Ctrl + I"},{"signature":"ShiftCtrlJ","summary":"Shift + Ctrl + J"},{"signature":"ShiftCtrlK","summary":"Shift + Ctrl + K"},{"signature":"ShiftCtrlL","summary":"Shift + Ctrl + L"},{"signature":"ShiftCtrlM","summary":"Shift + Ctrl + M"},{"signature":"ShiftCtrlN","summary":"Shift + Ctrl + N"},{"signature":"ShiftCtrlO","summary":"Shift + Ctrl + O"},{"signature":"ShiftCtrlP","summary":"Shift + Ctrl + P"},{"signature":"ShiftCtrlQ","summary":"Shift + Ctrl + Q"},{"signature":"ShiftCtrlR","summary":"Shift + Ctrl + R"},{"signature":"ShiftCtrlS","summary":"Shift + Ctrl + S"},{"signature":"ShiftCtrlT","summary":"Shift + Ctrl + T"},{"signature":"ShiftCtrlU","summary":"Shift + Ctrl + U"},{"signature":"ShiftCtrlV","summary":"Shift + Ctrl + V"},{"signature":"ShiftCtrlW","summary":"Shift + Ctrl + W"},{"signature":"ShiftCtrlX","summary":"Shift + Ctrl + X"},{"signature":"ShiftCtrlY","summary":"Shift + Ctrl + Y"},{"signature":"ShiftCtrlZ","summary":"Shift + Ctrl + Z"},{"signature":"AltCtrlA","summary":"Alt + Ctrl + A"},{"signature":"AltCtrlB","summary":"Alt + Ctrl + B"},{"signature":"AltCtrlC","summary":"Alt + Ctrl + C"},{"signature":"AltCtrlD","summary":"Alt + Ctrl + D"},{"signature":"AltCtrlE","summary":"Alt + Ctrl + E"},{"signature":"AltCtrlF","summary":"Alt + Ctrl + F"},{"signature":"AltCtrlG","summary":"Alt + Ctrl + G"},{"signature":"AltCtrlH","summary":"Alt + Ctrl + H"},{"signature":"AltCtrlI","summary":"Alt + Ctrl + I"},{"signature":"AltCtrlJ","summary":"Alt + Ctrl + J"},{"signature":"AltCtrlK","summary":"Alt + Ctrl + K"},{"signature":"AltCtrlL","summary":"Alt + Ctrl + L"},{"signature":"AltCtrlM","summary":"Alt + Ctrl + M"},{"signature":"AltCtrlN","summary":"Alt + Ctrl + N"},{"signature":"AltCtrlO","summary":"Alt + Ctrl + O"},{"signature":"AltCtrlP","summary":"Alt + Ctrl + P"},{"signature":"AltCtrlQ","summary":"Alt + Ctrl + Q"},{"signature":"AltCtrlR","summary":"Alt + Ctrl + R"},{"signature":"AltCtrlS","summary":"Alt + Ctrl + S"},{"signature":"AltCtrlT","summary":"Alt + Ctrl + T"},{"signature":"AltCtrlU","summary":"Alt + Ctrl + U"},{"signature":"AltCtrlV","summary":"Alt + Ctrl + V"},{"signature":"AltCtrlW","summary":"Alt + Ctrl + W"},{"signature":"AltCtrlX","summary":"Alt + Ctrl + X"},{"signature":"AltCtrlY","summary":"Alt + Ctrl + Y"},{"signature":"AltCtrlZ","summary":"Alt + Ctrl + Z"},{"signature":"Ctrl0","summary":"Ctrl + 0"},{"signature":"Ctrl1","summary":"Ctrl + 1"},{"signature":"Ctrl2","summary":"Ctrl + 2"},{"signature":"Ctrl3","summary":"Ctrl + 3"},{"signature":"Ctrl4","summary":"Ctrl + 4"},{"signature":"Ctrl5","summary":"Ctrl + 5"},{"signature":"Ctrl6","summary":"Ctrl + 6"},{"signature":"Ctrl7","summary":"Ctrl + 7"},{"signature":"Ctrl8","summary":"Ctrl + 8"},{"signature":"Ctrl9","summary":"Ctrl + 9"},{"signature":"ShiftCtrl0","summary":"Shift + Ctrl + 0"},{"signature":"ShiftCtrl1","summary":"Shift + Ctrl + 1"},{"signature":"ShiftCtrl2","summary":"Shift + Ctrl + 2"},{"signature":"ShiftCtrl3","summary":"Shift + Ctrl + 3"},{"signature":"ShiftCtrl4","summary":"Shift + Ctrl + 4"},{"signature":"ShiftCtrl5","summary":"Shift + Ctrl + 5"},{"signature":"ShiftCtrl6","summary":"Shift + Ctrl + 6"},{"signature":"ShiftCtrl7","summary":"Shift + Ctrl + 7"},{"signature":"ShiftCtrl8","summary":"Shift + Ctrl + 8"},{"signature":"ShiftCtrl9","summary":"Shift + Ctrl + 9"},{"signature":"AltCtrl0","summary":"Alt + Ctrl + 0"},{"signature":"AltCtrl1","summary":"Alt + Ctrl + 1"},{"signature":"AltCtrl2","summary":"Alt + Ctrl + 2"},{"signature":"AltCtrl3","summary":"Alt + Ctrl + 3"},{"signature":"AltCtrl4","summary":"Alt + Ctrl + 4"},{"signature":"AltCtrl5","summary":"Alt + Ctrl + 5"},{"signature":"AltCtrl6","summary":"Alt + Ctrl + 6"},{"signature":"AltCtrl7","summary":"Alt + Ctrl + 7"},{"signature":"AltCtrl8","summary":"Alt + Ctrl + 8"},{"signature":"AltCtrl9","summary":"Alt + Ctrl + 9"},{"signature":"Home","summary":"Home"},{"signature":"End","summary":"End"},{"signature":"CtrlHome","summary":"Ctrl + Home"},{"signature":"CtrlEnd","summary":"Ctrl + End"},{"signature":"ShiftHome","summary":"Shift + Home"},{"signature":"ShiftEnd","summary":"Shift + End"},{"signature":"ShiftCtrlHome","summary":"Shift + Ctrl + Home"},{"signature":"ShiftCtrlEnd","summary":"Shift + Ctrl + End"},{"signature":"AltCtrlHome","summary":"Alt + Ctrl + Home"},{"signature":"AltCtrlEnd","summary":"Alt + Ctrl + End"},{"signature":"PageUp","summary":"Page Up"},{"signature":"PageDown","summary":"Page Down"},{"signature":"ShiftPageUp","summary":"Shift + Page Up"},{"signature":"ShiftPageDown","summary":"Shift + Page Down"},{"signature":"CtrlPageUp","summary":"Ctrl + Page Up"},{"signature":"CtrlPageDown","summary":"Ctrl + Page Down"},{"signature":"ShiftCtrlPageUp","summary":"Shift + Ctrl + Page Up"},{"signature":"ShiftCtrlPageDown","summary":"Shift + Ctrl + Page Down"},{"signature":"AltCtrlPageUp","summary":"Alt + Ctrl + Page Up"},{"signature":"AltCtrlPageDown","summary":"Alt + Ctrl + Page Down"}]},{"namespace":"Rhino.ApplicationSettings","name":"ShortcutKeySettings","dataType":"class","summary":"Contains static methods and properties to control keyboard shortcut keys","methods":[{"signature":"static string GetMacro(ShortcutKey key)","summary":"Get macro associated with a given keyboard shortcut","since":"5.0"},{"signature":"static void SetMacro(ShortcutKey key, string macro)","summary":"Set macro associated with a keyboard shortcut","since":"5.0"}]},{"namespace":"Rhino.ApplicationSettings","name":"SmartTrackSettings","dataType":"class","summary":"Contains static methods and properties that target the Smart Track feature behavior.","properties":[{"signature":"static int ActivationDelayMilliseconds","summary":"Gets or sets the activation delay in milliseconds.","since":"5.0","property":["get","set"]},{"signature":"static Color ActivePointColor","summary":"Gets or sets the active point color.","since":"5.0","property":["get","set"]},{"signature":"static Color LineColor","summary":"Gets or sets the smart track line color.","since":"5.0","property":["get","set"]},{"signature":"static int MaxSmartPoints","summary":"Gets or sets the maximum number of smart points.","since":"5.0","property":["get","set"]},{"signature":"static Color PointColor","summary":"Gets or sets the point color.","since":"5.0","property":["get","set"]},{"signature":"static bool SmartOrtho","summary":"Gets or sets a value indicating if the \'Smart Ortho\' feature is active.  \\nOrthogonal lines are then drawn automatically.","since":"5.0","property":["get","set"]},{"signature":"static bool SmartTangents","summary":"Gets or sets a value indicating if the \'Smart Tangents\' feature is active.","since":"5.0","property":["get","set"]},{"signature":"static Color TanPerpLineColor","summary":"Gets or sets the tangent and perpendicular line color.","since":"5.0","property":["get","set"]},{"signature":"static bool UseDottedLines","summary":"Gets or sets a value indicating if lines are drawn dotted.","since":"5.0","property":["get","set"]},{"signature":"static bool UseSmartTrack","summary":"Gets or sets if the Smart Track feature is active.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static SmartTrackSettingsState GetCurrentState()","summary":"Gets the current settings.","since":"5.0","returns":"A new Smart Track state with current settings."},{"signature":"static SmartTrackSettingsState GetDefaultState()","summary":"Gets the Smart Track factory settings.","since":"5.0","returns":"A new Smart Track state with factory settings."},{"signature":"static void UpdateFromState(SmartTrackSettingsState state)","summary":"Updates from a particular setting state.","since":"5.0","parameters":[{"name":"state","summary":"The new state that will be set."}]}]},{"namespace":"Rhino.ApplicationSettings","name":"SmartTrackSettingsState","dataType":"class","summary":"Represents a snapshot of SmartTrackSettings.","properties":[{"signature":"static int MaxSmartPoints","summary":"Gets or sets the maximum number of smart points.","since":"5.0","property":["get","set"]},{"signature":"int ActivationDelayMilliseconds","summary":"Gets or sets the activation delay in milliseconds.","since":"5.0","property":["get","set"]},{"signature":"Color ActivePointColor","summary":"Gets or sets the active point color.","since":"5.0","property":["get","set"]},{"signature":"Color LineColor","summary":"Gets or sets the smart track line color.","since":"5.0","property":["get","set"]},{"signature":"Color PointColor","summary":"Gets or sets the point color.","since":"5.0","property":["get","set"]},{"signature":"bool SmartOrtho","summary":"Gets or sets a value indicating if the \'Smart Ortho\' feature is active.","since":"5.0","property":["get","set"]},{"signature":"bool SmartTangents","summary":"Gets or sets a value indicating if the \'Smart Tangents\' feature is active.","since":"5.0","property":["get","set"]},{"signature":"Color TanPerpLineColor","summary":"Gets or sets the tangent and perpendicular line color.","since":"5.0","property":["get","set"]},{"signature":"bool UseDottedLines","summary":"Gets or sets a value indicating if lines are drawn dotted.","since":"5.0","property":["get","set"]},{"signature":"bool UseSmartTrack","summary":"Gets or sets if the \'smart track\' feature is active.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.ApplicationSettings","name":"ViewSettings","dataType":"class","summary":"Contains static methods and properties to control view settings.","properties":[{"signature":"static bool AlwaysPanParallelViews","summary":"Gets or sets the \'always pan parallel views\' value.  \\nIf the view is not looking straight at the construction plane, then sets parallel viewports so they will not rotate.","since":"5.0","property":["get","set"]},{"signature":"static bool DefinedViewSetCPlane","summary":"Gets or sets the \'named views set CPlane\' value.  \\nWhen true, restoring a named view causes the construction plane saved with that view to also restore.","since":"5.0","property":["get","set"]},{"signature":"static bool DefinedViewSetProjection","summary":"Gets or sets the \'named views set projection\' value.  \\nWhen true, restoring a named view causes the viewport projection saved with the view to also restore.","since":"5.0","property":["get","set"]},{"signature":"static bool LinkedViewports","summary":"Gets or sets the \'linked views\' activated setting.  \\nTrue enables real-time view synchronization. When a standard view is manipulated, the camera lens length of all parallel projection viewports are set to match the current viewport.","since":"5.0","property":["get","set"]},{"signature":"static bool PanReverseKeyboardAction","summary":"Gets or sets if panning with the keyboard is reversed.  \\nfalse, then Rhino pans the camera in the direction of the arrow key you press. true, then Rhino pans the scene instead.","since":"5.0","property":["get","set"]},{"signature":"static double PanScreenFraction","summary":"Gets or sets the faction used as multiplier to pan the screen.","since":"5.0","property":["get","set"]},{"signature":"static int RotateCircleIncrement","summary":"Gets or sets the rotation increment.  \\nWhen the user rotates a view with the keyboard, Rhino rotates the view in steps. The usual step is 1/60th of a circle, which equals six degrees.","since":"5.0","property":["get","set"]},{"signature":"static bool RotateReverseKeyboard","summary":"Gets or sets the rotation direction.  \\nIf true, then Rhino rotates the camera around the scene, otherwise, rotates the scene itself.","since":"5.0","property":["get","set"]},{"signature":"static bool RotateToView","summary":"Gets or sets the rotation reference.  \\nIf true, then the views rotates relative to the view axes; false, than relative to the world x, y, and z axes.","since":"5.0","property":["get","set"]},{"signature":"static bool SingleClickMaximize","summary":"Gets or sets the \'single-click maximize\' value.  \\nWhen true, maximizing a viewport needs a single click on the viewport title rather than a double-click.","since":"5.0","property":["get","set"]},{"signature":"static double ZoomExtentsParallelViewBorder","summary":"Border amount to apply to parallel viewport during zoom extents","since":"6.3","property":["get","set"]},{"signature":"static double ZoomExtentsPerspectiveViewBorder","summary":"Border amount to apply to perspective viewport during zoom extents","since":"6.3","property":["get","set"]},{"signature":"static double ZoomScale","summary":"Gets or sets the step size for zooming with a wheeled mouse or the Page Up and Page Down keys.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static ViewSettingsState GetCurrentState()","summary":"Gets the current settings.","since":"5.0","returns":"A new view state with current settings."},{"signature":"static ViewSettingsState GetDefaultState()","summary":"Gets the view factory settings.","since":"5.0","returns":"A new view state with factory settings."},{"signature":"static void RestoreDefaults()","summary":"Updates from the default setting state.","since":"5.0"},{"signature":"static void UpdateFromState(ViewSettingsState state)","summary":"Updates from a particular setting state.","since":"5.0","parameters":[{"name":"state","summary":"The new state that will be set."}]}]},{"namespace":"Rhino.ApplicationSettings","name":"ViewSettingsState","dataType":"class","summary":"Represents a snapshot of ViewSettings.","properties":[{"signature":"bool AlwaysPanParallelViews","summary":"Gets or sets the \'always pan parallel views\' value.  \\nIf the view is not looking straight at the construction plane, then sets parallel viewports so they will not rotate.","since":"5.0","property":["get","set"]},{"signature":"bool DefinedViewSetCPlane","summary":"Gets or sets the \'named views set CPlane\' value.  \\nWhen true, restoring a named view causes the construction plane saved with that view to also restore.","since":"5.0","property":["get","set"]},{"signature":"bool DefinedViewSetProjection","summary":"Gets or sets the \'named views set projection\' value.  \\nWhen true, restoring a named view causes the viewport projection saved with the view to also restore.","since":"5.0","property":["get","set"]},{"signature":"bool LinkedViewports","summary":"Gets or sets the \'linked views\' activated setting.  \\nTrue enables real-time view synchronization. When a standard view is manipulated, the camera lens length of all parallel projection viewports are set to match the current viewport.","since":"5.0","property":["get","set"]},{"signature":"bool PanReverseKeyboardAction","summary":"Gets or sets if panning with the keyboard is reversed.  \\nfalse, then Rhino pans the camera in the direction of the arrow key you press. true, then Rhino pans the scene instead.","since":"5.0","property":["get","set"]},{"signature":"double PanScreenFraction","summary":"Gets or sets the faction used as multiplier to pan the screen.","since":"5.0","property":["get","set"]},{"signature":"int RotateCircleIncrement","summary":"Gets or sets the rotation increment.  \\nWhen the user rotates a view with the keyboard, Rhino rotates the view in steps. The usual step is 1/60th of a circle, which equals six degrees.","since":"5.0","property":["get","set"]},{"signature":"bool RotateReverseKeyboard","summary":"Gets or sets the rotation direction.  \\nIf true, then Rhino rotates the camera around the scene, otherwise, rotates the scene itself.","since":"5.0","property":["get","set"]},{"signature":"bool RotateToView","summary":"Gets or sets the rotation reference.  \\nIf true, then the views rotates relative to the view axes; false, than relative to the world x, y, and z axes.","since":"5.0","property":["get","set"]},{"signature":"bool SingleClickMaximize","summary":"Gets or sets the \'single-click maximize\' value.  \\nWhen true, maximizing a viewport needs a single click on the viewport title rather than a double-click.","since":"5.0","property":["get","set"]},{"signature":"double ZoomExtentsParallelViewBorder","summary":"Border amount to apply to parallel viewport during zoom extents","since":"6.3","property":["get","set"]},{"signature":"double ZoomExtentsPerspectiveViewBorder","summary":"Border amount to apply to perspective viewport during zoom extents","since":"6.3","property":["get","set"]},{"signature":"double ZoomScale","summary":"Gets or sets the step size for zooming with a wheeled mouse or the Page Up and Page Down keys.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.ApplicationSettings","name":"WidgetColor","dataType":"enum","summary":"Contains enumerated constant values to represent logical colors associated with elements of the user interface.","values":[{"signature":"UAxisColor = 0","summary":"The color of the mapping widget u-axis."},{"signature":"VAxisColor = 1","summary":"The color of the mapping widget v-axis.."},{"signature":"WAxisColor = 2","summary":"The color of the mapping widget w-axis."}]},{"namespace":"Rhino.Collections","name":"ArchivableDictionary","dataType":"class","summary":"Represents a dictionary class that can be attached to objects and can be serialized (saved) at necessity.  \\nSee remarks for layout.","remarks":"This is the layout of this object:  \\n.  \\nBEGINCHUNK (TCODE_ANONYMOUS_CHUNK)  \\n|- version (int)  \\n|- entry count (int)  \\nfor entry count entries  \\n|- BEGINCHUNK (TCODE_ANONYMOUS_CHUNK)  \\n|- key (string)  \\n|- entry contents  \\n|- ENDCHUNK (TCODE_ANONYMOUS_CHUNK)  \\nENDCHUNK (TCODE_ANONYMOUS_CHUNK)","interfaces":["ICloneable","IDictionary<string, object>","ISerializable"],"constructors":[{"signature":"ArchivableDictionary()","summary":"Initializes an instance of a dictionary for writing to a 3dm archive.","since":"5.0"},{"signature":"ArchivableDictionary(int version)","summary":"Initializes an instance of a dictionary for writing to a 3dm archive.","since":"5.0","parameters":[{"name":"version","summary":"Custom version used to help the plug-in developer determine which version of a dictionary is being written. One good way to write version information is to use a date style integer (YYYYMMDD)"}]},{"signature":"ArchivableDictionary(int version, string name)","summary":"Initializes an instance of a dictionary for writing to a 3dm archive.","since":"5.0","parameters":[{"name":"version","summary":"custom version used to help the plug-in developer determine which version of a dictionary is being written. One good way to write version information is to use a date style integer (YYYYMMDD)"},{"name":"name","summary":"Optional name to associate with this dictionary. NOTE: if this dictionary is set as a sub-dictionary, the name will be changed to the sub-dictionary key entry"}]},{"signature":"ArchivableDictionary(UserData parentUserData)","summary":"Initializes an instance of a dictionary for writing to a 3dm archive","since":"5.0","parameters":[{"name":"parentUserData","summary":"parent user data if this dictionary is associated with user data"}]}],"properties":[{"signature":"int Count","summary":"Gets the number of key/value pairs contained in the dictionary.","since":"5.0","property":["get"]},{"signature":"string[] Keys","summary":"Gets all entry names or keys.","since":"5.0","property":["get"]},{"signature":"string Name","summary":"Gets or sets the name string of this ArchivableDictionary.","since":"5.0","property":["get","set"]},{"signature":"UserData ParentUserData","summary":"If this dictionary is part of user-data (or is a UserDictionary), then this is the parent user data. None if this dictionary is not part of user-data","since":"5.0","property":["get"]},{"signature":"object[] Values","summary":"Gets all values in this dictionary.","since":"5.0","property":["get"]},{"signature":"int Version","summary":"Gets or sets the version of this ArchivableDictionary.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"bool AddContentsFrom(ArchivableDictionary source)","summary":"Add the contents from the source dictionary.","since":"5.4"},{"signature":"void Clear()","summary":"Removes all keys and values from the dictionary.","since":"5.0"},{"signature":"ArchivableDictionary Clone()","summary":"Constructs a deep copy of this object.","since":"5.0","returns":"The copy of this object."},{"signature":"bool ContainsKey(string key)","summary":"Determines whether the dictionary contains the specified key.","since":"5.0","parameters":[{"name":"key","summary":"The key to locate."}],"returns":"True if the dictionary contains an element with the specified key; otherwise, false."},{"signature":"bool GetBool(string key)","summary":"Get value as Boolean, will only succeed if value was created using Set(string key, Boolean value)","since":"5.0"},{"signature":"bool GetBool(string key, bool defaultValue)","summary":"Get value as Boolean, will return defaultValue unless value was created using Set(string key, Boolean value)","since":"5.0"},{"signature":"byte[] GetBytes(string key)","summary":"Get value as byte[], will only succeed if value was created using Set(string key, byte[] value)","since":"5.9"},{"signature":"byte[] GetBytes(string key, byte[] defaultValue)","summary":"Get value as byte[], will return defaultValue unless value was created using Set(string key, byte[] value)","since":"5.9"},{"signature":"ArchivableDictionary GetDictionary(string key)","summary":"Get value as ArchivableDictionary, will only succeed if value was created using Set(string key, ArchivableDictionary value)","since":"5.9"},{"signature":"ArchivableDictionary GetDictionary(string key, ArchivableDictionary defaultValue)","summary":"Get value as ArchivableDictionary, will return defaultValue unless value was created using Set(string key, ArchivableDictionary value)","since":"5.9"},{"signature":"double GetDouble(string key)","summary":"Get value as double, will only succeed if value was created using Set(string key, double value)","since":"5.0"},{"signature":"double GetDouble(string key, double defaultValue)","summary":"Get value as double, will only succeed if value was created using Set(string key, double value)","since":"5.10"},{"signature":"IEnumerator<KeyValuePair<string, object>> GetEnumerator()","summary":"Gets the enumerator of this dictionary.","since":"5.0","returns":"A IEnumerator{T}, where T is an instance of KeyValuePair{T0,T1}, with T0 set as string, and T1 as Syste.Object."},{"signature":"T GetEnumValue()","summary":"Get an enum value","since":"5.4"},{"signature":"T GetEnumValue(string key)","summary":"Get an enum value from the dictionary using a custom key.","since":"5.4"},{"signature":"float GetFloat(string key)","summary":"Get value as float, will only succeed if value was created using Set(string key, float value)","since":"5.0"},{"signature":"float GetFloat(string key, float defaultValue)","summary":"Get value as float, will return defaultValue unless value was created using Set(string key, float value)","since":"5.0"},{"signature":"Guid GetGuid(string key)","summary":"Get value as Guid, will only succeed if value was created using Set(string key, Guid value)","since":"5.0"},{"signature":"Guid GetGuid(string key, Guid defaultValue)","summary":"Get value as Guid, will return defaultValue unless value was created using Set(string key, Guid value)","since":"5.0"},{"signature":"int Getint(string key, int defaultValue)","summary":"Get value as int, will return defaultValue unless value was created using Set(string key, int value)","since":"5.0"},{"signature":"int GetInteger(string key)","summary":"Get value as int, will only succeed if value was created using Set(string key, int value)","since":"5.0"},{"signature":"int GetInteger(string key, int defaultValue)","summary":"Get value as int, will return defaultValue unless value was created using Set(string key, int value)","since":"5.0"},{"signature":"void GetObjectData(SerializationInfo info, StreamingContext context)","summary":"Populates a System.Runtime.Serialization.SerializationInfo with the data needed to serialize the target object.","since":"7.0","parameters":[{"name":"info","summary":"The System.Runtime.Serialization.SerializationInfo to populate with data."},{"name":"context","summary":"The destination (see System.Runtime.Serialization.StreamingContext) for this serialization."}]},{"signature":"Geometry.Plane GetPlane(string key)","summary":"Get value as Plane, will return defaultValue unless value was created using Set(string key, Plane value)","since":"6.11","parameters":[{"name":"key","summary":"The key."}],"returns":"The value as Plane."},{"signature":"Geometry.Plane GetPlane(string key, Plane defaultValue)","summary":"Get value as Plane, will return defaultValue unless value was created using Set(string key, Plane value)","since":"6.11","parameters":[{"name":"key","summary":"The key."},{"name":"defaultValue","summary":"The default value."}],"returns":"The value as Plane."},{"signature":"Geometry.Point3d GetPoint3d(string key)","summary":"Get value as Point3d, will only succeed if value was created using Set(string key, Point3d value)","since":"5.0"},{"signature":"Geometry.Point3d GetPoint3d(string key, Point3d defaultValue)","summary":"Get value as Point3d, will return defaultValue unless value was created using Set(string key, Point3d value)","since":"5.0"},{"signature":"Geometry.Point3f GetPoint3f(string key)","summary":"Get value as Point3f, will only succeed if value was created using Set(string key, Point3f value)","since":"5.0"},{"signature":"Geometry.Point3f GetPoint3f(string key, Point3f defaultValue)","summary":"Get value as Point3f, will return defaultValue unless value was created using Set(string key, Point3f value)","since":"5.0"},{"signature":"string GetString(string key)","summary":"Get value as string, will only succeed if value was created using Set(string key, string value)","since":"5.0","parameters":[{"name":"key","summary":"The key which points to the string"}],"returns":"The string"},{"signature":"string GetString(string key, string defaultValue)","summary":"Get value as string, will return defaultValue unless value was created using Set(string key, string value)","since":"5.0","parameters":[{"name":"key","summary":"The key which points to the string"},{"name":"defaultValue","summary":"The string"}]},{"signature":"Geometry.Vector3d GetVector3d(string key)","summary":"Get value as Vector3d, will only succeed if value was created using Set(string key, Vector3d value)","since":"5.0"},{"signature":"Geometry.Vector3d GetVector3d(string key, Vector3d defaultValue)","summary":"Get value as Vector3d, will return defaultValue unless value was created using Set(string key, Vector3d value)","since":"5.0"},{"signature":"bool Remove(string key)","summary":"Removes the value with the specified key from the dictionary.","since":"5.0","parameters":[{"name":"key","summary":"The key of the element to remove."}],"returns":"True if the element is successfully found and removed; otherwise, false. This method returns False if key is not found."},{"signature":"bool RemoveEnumValue()","summary":"Remove an enum value from the dictionary.","since":"5.4"},{"signature":"bool ReplaceContentsWith(ArchivableDictionary source)","summary":"Replace the contents of the dictionary with that of the given source dictionary.","since":"5.4"},{"signature":"bool Set(string key, ArchivableDictionary val)","summary":"Sets another ArchivableDictionaryas entry in this dictionary.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"An object for that key.  \\nBecause this class is a reference type and is mutable, changes to this object will propagate to the object inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate."}]},{"signature":"bool Set(string key, bool val)","summary":"Sets a bool.","since":"5.0","parameters":[{"name":"key","summary":"The text key."},{"name":"val","summary":"A boolvalue.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, BoundingBox val)","summary":"Sets a Rhino.Geometry.BoundingBox.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, byte val)","summary":"Sets a byte.","since":"5.0","parameters":[{"name":"key","summary":"The text key."},{"name":"val","summary":"A byte.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, Color val)","summary":"Sets a System.Drawing.Color.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, double val)","summary":"Sets a double.","since":"5.0","parameters":[{"name":"key","summary":"The text key."},{"name":"val","summary":"A double.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, float val)","summary":"Sets a float.","since":"5.0","parameters":[{"name":"key","summary":"The text key."},{"name":"val","summary":"A float.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, Font val)","summary":"Sets a System.Drawing.Font.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  is immutable, it is not possible to modify the object while it is in this dictionary."}]},{"signature":"bool Set(string key, GeometryBase val)","summary":"Sets any class deriving from the Rhino.Geometry.GeometryBasebase class.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A geometry object for that key.  \\nBecause this class is a reference type and is mutable, changes to this object will propagate to the object inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate. You can use  for this."}]},{"signature":"bool Set(string key, Guid val)","summary":"Sets a Guid.","since":"5.0","parameters":[{"name":"key","summary":"The text key."},{"name":"val","summary":"A Guid.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, IEnumerable<bool> val)","summary":"Sets a list, an array or any enumerable of bool.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, IEnumerable<byte> val)","summary":"Sets a list, an array or any enumerable of byte.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key  \\nBecause this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, IEnumerable<double> val)","summary":"Sets a list, an array or any enumerable of double.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, IEnumerable<float> val)","summary":"Sets a list, an array or any enumerable of float.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, IEnumerable<GeometryBase> val)","summary":"Sets an array of Rhino.Geometry.GeometryBase","since":"7.0","parameters":[{"name":"key","summary":"A text key"},{"name":"val","summary":"An object for that key  \\nBecause this class is a reference type and is mutable, changes to this object will propagate to the object inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate."}],"returns":"True if successful, False otherwise."},{"signature":"bool Set(string key, IEnumerable<Guid> val)","summary":"Sets a list, an array or any enumerable of Guid.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, IEnumerable<int> val)","summary":"Sets a list, an array or any enumerable of int.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, IEnumerable<ObjRef> val)","summary":"Sets an array of Rhino.DocObjects.ObjRef","since":"5.8","parameters":[{"name":"key","summary":"A text key"},{"name":"val","summary":"An object for that key  \\nBecause this class is a reference type and is mutable, changes to this object will propagate to the object inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate."}]},{"signature":"bool Set(string key, IEnumerable<sbyte> val)","summary":"Sets a list, an array or any enumerable of sbyte.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, IEnumerable<short> val)","summary":"Sets a list, an array or any enumerable of short.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, IEnumerable<string> val)","summary":"Sets a list, an array or any enumerable of string.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, int val)","summary":"Sets a int.","since":"5.0","parameters":[{"name":"key","summary":"The text key."},{"name":"val","summary":"A int.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, Int64 val)","summary":"Sets a long.","since":"5.0","parameters":[{"name":"key","summary":"The text key."},{"name":"val","summary":"A long.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, Interval val)","summary":"Sets an Rhino.Geometry.Interval.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, Line val)","summary":"Sets a Rhino.Geometry.Line.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, MeshingParameters val)","summary":"Sets a Rhino.Geometry.MeshingParameters.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"An object for that key.  \\nBecause this class is a reference type and is mutable, changes to this object will propagate to the object inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate."}]},{"signature":"bool Set(string key, ObjRef val)","summary":"Sets a Rhino.DocObjects.ObjRef","since":"5.8","parameters":[{"name":"key","summary":"A text key"},{"name":"val","summary":"An object for that key  \\nBecause this class is a reference type and is mutable, changes to this object will propagate to the object inside the dictionary.  \\nIt is up to the user to clone this entry when appropriate."}]},{"signature":"bool Set(string key, Plane val)","summary":"Sets a Rhino.Geometry.Plane.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A plane for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, Point val)","summary":"Sets a System.Drawing.Point.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, Point2d val)","summary":"Sets a Rhino.Geometry.Point2d.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A point for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, Point3d val)","summary":"Sets a Rhino.Geometry.Point3d.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A point for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, Point3f val)","summary":"Sets a Rhino.Geometry.Point3f.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, Point4d val)","summary":"Sets a Rhino.Geometry.Point4d.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, PointF val)","summary":"Sets a System.Drawing.PointF.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, Ray3d val)","summary":"Sets a Rhino.Geometry.Ray3d.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics and is immutable, no changes to this object are possible."}]},{"signature":"bool Set(string key, Rectangle val)","summary":"Sets a System.Drawing.Rectangle.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, RectangleF val)","summary":"Sets a System.Drawing.RectangleF.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, sbyte val)","summary":"Sets a sbyte.","since":"5.0","parameters":[{"name":"key","summary":"The text key."},{"name":"val","summary":"A sbyte.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, short val)","summary":"Sets a short.","since":"5.0","parameters":[{"name":"key","summary":"The text key."},{"name":"val","summary":"A short.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, Size val)","summary":"Sets a System.Drawing.Size.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, SizeF val)","summary":"Sets a System.Drawing.SizeF.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, string val)","summary":"Sets a string.","since":"5.0","parameters":[{"name":"key","summary":"The text key."},{"name":"val","summary":"A string.  \\nBecause  is immutable, it is not possible to modify the object while it is in this dictionary."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, Transform val)","summary":"Sets a Rhino.Geometry.Transform.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A transform for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, uint val)","summary":"Sets a uint.","since":"5.0","parameters":[{"name":"key","summary":"The text key."},{"name":"val","summary":"A uint.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, ushort val)","summary":"Sets a ushort.","since":"5.0","parameters":[{"name":"key","summary":"The text key."},{"name":"val","summary":"A ushort.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}],"returns":"True if set operation succeeded, otherwise false."},{"signature":"bool Set(string key, Vector2d val)","summary":"Sets a Rhino.Geometry.Vector2d.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, Vector3d val)","summary":"Sets a Rhino.Geometry.Vector3d.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool Set(string key, Vector3f val)","summary":"Sets a Rhino.Geometry.Vector3f.","since":"5.0","parameters":[{"name":"key","summary":"A text key."},{"name":"val","summary":"A value for that key.  \\nBecause  has value semantics, changes to the assigning value will leave this entry unchanged."}]},{"signature":"bool SetEnumValue(string key, T enumValue)","summary":"Set an enum value in the dictionary with a custom key.","since":"5.4"},{"signature":"bool SetEnumValue(T enumValue)","summary":"Set an enum value","since":"5.4"},{"signature":"bool TryGetBool(string key, out bool value)","summary":"Get value as Boolean, will only succeed if value was created using Set(string key, Boolean value)","since":"5.0"},{"signature":"bool TryGetBytes(string key, out byte[] value)","summary":"Get value as byte[], will only succeed if value was created using Set(string key, byte[] value)","since":"5.9"},{"signature":"bool TryGetDictionary(string key, out ArchivableDictionary value)","summary":"Get value as ArchivableDictionary, will only succeed if value was created using Set(string key, ArchivableDictionary value)","since":"5.9"},{"signature":"bool TryGetDouble(string key, out double value)","summary":"Get value as double, will only succeed if value was created using Set(string key, double value)","since":"5.0"},{"signature":"bool TryGetEnumValue(string key, out T enumValue)","summary":"Attempt to get an enum value from the dictionary using a custom key.","since":"5.4"},{"signature":"bool TryGetFloat(string key, out float value)","summary":"Get value as float, will only succeed if value was created using Set(string key, float value)","since":"5.0"},{"signature":"bool TryGetGuid(string key, out Guid value)","summary":"Get value as Guid, will only succeed if value was created using Set(string key, Guid value)","since":"5.0"},{"signature":"bool TryGetInteger(string key, out int value)","summary":"Get value as int, will only succeed if value was created using Set(string key, int value)","since":"5.0"},{"signature":"bool TryGetPlane(string key, out Plane value)","summary":"Get value as Plane, will only succeed if value was created using Set(string key, Plane value)","since":"6.11","parameters":[{"name":"key","summary":"The key."},{"name":"value","summary":"The value."}],"returns":"The value as Plane."},{"signature":"bool TryGetPoint3d(string key, out Point3d value)","summary":"Get value as Point3d, will only succeed if value was created using Set(string key, Point3d value)","since":"5.0"},{"signature":"bool TryGetPoint3f(string key, out Point3f value)","summary":"Get value as Point3f, will only succeed if value was created using Set(string key, Point3f value)","since":"5.0"},{"signature":"bool TryGetString(string key, out string value)","summary":"Get value as string, will only succeed if value was created using Set(string key, string value)","since":"5.0"},{"signature":"bool TryGetValue(string key, out object value)","summary":"Gets the value associated with the specified key.","since":"5.0","parameters":[{"name":"key","summary":"The key of the value to get."},{"name":"value","summary":"When this method returns and if the key is found, contains the value associated with the specified key; otherwise, null. This parameter is passed uninitialized."}],"returns":"True if the dictionary contains an element with the specified key; otherwise, false."},{"signature":"bool TryGetVector3d(string key, out Vector3d value)","summary":"Get value as Vector3d, will only succeed if value was created using Set(string key, Vector3d value)","since":"5.0"}]},{"namespace":"Rhino.Collections","name":"CurveList","dataType":"class","summary":"Represents a list of curves.","baseclass":"RhinoList<Curve>","constructors":[{"signature":"CurveList()","summary":"Initializes a new empty list of curves.","since":"5.0"},{"signature":"CurveList(IEnumerable<Curve> collection)","summary":"Initializes a new list that is filled with all items of the input enumerable.  \\nInput items are not explicitly duplicated (this is a shallow copy).","since":"5.0","parameters":[{"name":"collection","summary":"A list, an array or any enumerable set of Curve."}]},{"signature":"CurveList(int initialCapacity)","summary":"Initializes a new empty list of curves with a predefined capacity.  \\nThis is the amount of items the list will accept before resizing.","since":"5.0"}],"methods":[{"signature":"void Add(Arc arc)","summary":"Adds an arc to this list.","since":"5.0","parameters":[{"name":"arc","summary":"An arc value that will be the model of the new internal curve."}]},{"signature":"void Add(Circle circle)","summary":"Adds a circle to this list.","since":"5.0","parameters":[{"name":"circle","summary":"A circle value that will be the model of the new internal curve."}]},{"signature":"void Add(Ellipse ellipse)","summary":"Adds an ellipse to this list.","since":"5.0","parameters":[{"name":"ellipse","summary":"An ellipse that will be the model of the new internal curve."}]},{"signature":"void Add(IEnumerable<Point3d> polyline)","summary":"Adds a polyline to this list.","since":"5.0","parameters":[{"name":"polyline","summary":"A polyline value that will be copied in a new polyline.  \\nThis argument can be null, an array, a list or any enumerable set of ."}]},{"signature":"void Add(Line line)","summary":"Adds a line to this list.","since":"5.0","parameters":[{"name":"line","summary":"A line value that will be the model of the new internal curve."}]},{"signature":"void Insert(int index, Arc arc)","summary":"Inserts an arc at a given index of this list.","since":"5.0","parameters":[{"name":"index","summary":"A 0-based position in the list."},{"name":"arc","summary":"The arc value from which to construct the new curve."}]},{"signature":"void Insert(int index, Circle circle)","summary":"Inserts a line at a given index of this list.","since":"5.0","parameters":[{"name":"index","summary":"A 0-based position in the list."},{"name":"circle","summary":"The circle value from which to construct the new curve."}]},{"signature":"void Insert(int index, Ellipse ellipse)","summary":"Inserts an ellipse at a given index of this list.","since":"5.0","parameters":[{"name":"index","summary":"A 0-based position in the list."},{"name":"ellipse","summary":"The ellipse value from which to construct the new curve."}]},{"signature":"void Insert(int index, IEnumerable<Point3d> polyline)","summary":"Inserts a polyline at a given index of this list.","since":"5.0","parameters":[{"name":"index","summary":"A 0-based position in the list."},{"name":"polyline","summary":"The polyline enumerable from which to construct a copy curve.  \\nThis argument can be null, an array, a list or any enumerable set of ."}]},{"signature":"void Insert(int index, Line line)","summary":"Inserts a line at a given index of this list.","since":"5.0","parameters":[{"name":"index","summary":"A 0-based position in the list."},{"name":"line","summary":"The line value from which to construct the new curve."}]},{"signature":"bool Transform(Transform xform)","summary":"Transform all the curves in this list. If at least a single transform failed this function returns false.","since":"5.0","parameters":[{"name":"xform","summary":"Transformation to apply to all curves."}]}]},{"namespace":"Rhino.Collections","name":"IResizableList","dataType":"interface","summary":"Provides the ability to resize a generic list by setting the Count property.","properties":[{"signature":"int Count","summary":"Gets or sets the length of the list. This hides (Shadows in Vb.Net) the read-only Count property of the generic list.","property":["get","set"]}]},{"namespace":"Rhino.Collections","name":"Point3dList","dataType":"class","summary":"Represents a list of Point3d.","baseclass":"RhinoList<Point3d>","interfaces":["ICloneable"],"constructors":[{"signature":"Point3dList()","summary":"Initializes a new empty list with default capacity.","since":"5.0"},{"signature":"Point3dList(IEnumerable<Point3d> collection)","summary":"Initializes a new point list by copying the values from another set.","since":"5.0","parameters":[{"name":"collection","summary":"The collection to copy from."}]},{"signature":"Point3dList(int initialCapacity)","summary":"Initializes a new point list with a preallocated initial capacity.","since":"5.0","parameters":[{"name":"initialCapacity","summary":"The number of added items before which the underlying array will be resized."}]},{"signature":"Point3dList(Point3d[] initialPoints)","summary":"Constructs a new point list from values in a point array.","since":"5.0","parameters":[{"name":"initialPoints","summary":"Points to add to the list."}]}],"properties":[{"signature":"BoundingBox BoundingBox","summary":"Even though this is a property, it is not a \\"fast\\" calculation. Every point is evaluated in order to get the bounding box of the list.","since":"5.0","property":["get"]},{"signature":"XAccess X","summary":"Returns an indexer with all X coordinates in this list.","since":"5.0","property":["get"]},{"signature":"YAccess Y","summary":"Returns an indexer with all Y coordinates in this list.","since":"5.0","property":["get"]},{"signature":"ZAccess Z","summary":"Returns an indexer with all Z coordinates in this list.","since":"5.0","property":["get"]}],"methods":[{"signature":"static int ClosestIndexInList(IList<Point3d> list, Point3d testPoint)","summary":"Finds the index of the point in a list of points that is closest to a test point.","since":"5.0","parameters":[{"name":"list","summary":"A list of points."},{"name":"testPoint","summary":"Point to compare against."}],"returns":"Index of closest point in the list on success or -1 on error."},{"signature":"static Point3d ClosestPointInList(IList<Point3d> list, Point3d testPoint)","summary":"Finds the point in a list of points that is closest to a test point.","since":"5.0","parameters":[{"name":"list","summary":"A list of points."},{"name":"testPoint","summary":"Point to compare against."}],"returns":"A point."},{"signature":"void Add(double x, double y, double z)","summary":"Adds a Point3d to the end of the list with given x,y,z coordinates.","since":"5.0","parameters":[{"name":"x","summary":"The X coordinate."},{"name":"y","summary":"The Y coordinate."},{"name":"z","summary":"The Z coordinate."}]},{"signature":"int ClosestIndex(Point3d testPoint)","summary":"Finds the index of the point that is closest to a test point in this list.","since":"5.0","parameters":[{"name":"testPoint","summary":"point to compare against."}],"returns":"index of closest point in the list on success. -1 on error."},{"signature":"Point3dList Duplicate()","summary":"Returns a deep copy of this point list instance.","since":"6.0","returns":"The duplicated list."},{"signature":"void SetAllX(double xValue)","summary":"Set all the X values for the points to a single value","since":"5.6"},{"signature":"void SetAllY(double yValue)","summary":"Set all the Y values for the points to a single value","since":"5.6"},{"signature":"void SetAllZ(double zValue)","summary":"Set all the Z values for the points to a single value","since":"5.6"},{"signature":"void Transform(Transform xform)","summary":"Applies a transform to all the points in the list.","since":"5.0","parameters":[{"name":"xform","summary":"Transform to apply."}]}]},{"namespace":"Rhino.Collections","name":"Point3dList.XAccess","dataType":"class","summary":"Utility class for easy-access of x-components of points inside an ON_3dPointList."},{"namespace":"Rhino.Collections","name":"Point3dList.YAccess","dataType":"class","summary":"Utility class for easy-access of x-components of points inside an ON_3dPointList."},{"namespace":"Rhino.Collections","name":"Point3dList.ZAccess","dataType":"class","summary":"Utility class for easy-access of z-components of points inside an ON_3dPointList."},{"namespace":"Rhino.Collections","name":"RhinoList","dataType":"class","summary":"Provides helper methods to work with RhinoList<T>and other collections.","methods":[{"signature":"static IEnumerable<int[]> Point2dKNeighbors(IEnumerable<Point2d> hayPoints, IEnumerable<Point2d> needlePoints, int amount)","summary":"Finds a certain amour of points in a list of single-precision 2D points that are the k-closest to a test point. This method searches needlePoints by computing all distances from each point cloud point and keeping a \\"short list\\".","since":"6.0","parameters":[{"name":"hayPoints","summary":"A point cloud to be searched."},{"name":"needlePoints","summary":"Points to search for."},{"name":"amount","summary":"The required amount of closest neighbors to find."}],"returns":"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{"signature":"static IEnumerable<int[]> Point2fKNeighbors(IEnumerable<Point2f> hayPoints, IEnumerable<Point2f> needlePoints, int amount)","summary":"Finds a certain amour of points in a list of single-precision 2D points that are the k-closest to a test point. This method searches needlePoints by computing all distances from each point cloud point and keeping a \\"short list\\".","since":"6.0","parameters":[{"name":"hayPoints","summary":"A point cloud to be searched."},{"name":"needlePoints","summary":"Points to search for."},{"name":"amount","summary":"The required amount of closest neighbors to find."}],"returns":"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{"signature":"static IEnumerable<int[]> Point3dKNeighbors(IEnumerable<Point3d> hayPoints, IEnumerable<Point3d> needlePoints, int amount)","summary":"Finds a certain amour of points in a list of 3D points that are the k-closest to a test point. This method searches needlePoints by computing all distances from each point cloud point and keeping a \\"short list\\". See RTree KNeighbors for alternatives.","since":"6.0","parameters":[{"name":"hayPoints","summary":"A point cloud to be searched."},{"name":"needlePoints","summary":"Points to search for."},{"name":"amount","summary":"The required amount of closest neighbors to find."}],"returns":"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{"signature":"static IEnumerable<int[]> Point3fKNeighbors(IEnumerable<Point3f> hayPoints, IEnumerable<Point3f> needlePoints, int amount)","summary":"Finds a certain amour of points in a list of single-precision 3D points that are the k-closest to a test point. This method searches needlePoints by computing all distances from each point cloud point and keeping a \\"short list\\".","since":"6.0","parameters":[{"name":"hayPoints","summary":"A point cloud to be searched."},{"name":"needlePoints","summary":"Points to search for."},{"name":"amount","summary":"The required amount of closest neighbors to find."}],"returns":"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{"signature":"static IEnumerable<int[]> PointCloudKNeighbors(PointCloud pointcloud, IEnumerable<Point3d> needlePoints, int amount)","summary":"Finds a certain amount of points in a list of 3D points that are the k-closest to a test point. This method searches needlePoints by computing all distances from each point cloud point and keeping a short list.","since":"6.0","parameters":[{"name":"pointcloud","summary":"A point cloud to be searched."},{"name":"needlePoints","summary":"Points to search for."},{"name":"amount","summary":"The required amount of closest neighbors to find."}],"returns":"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."}]},{"namespace":"Rhino.Collections","name":"RhinoList<T>","dataType":"class","summary":"Represents a list of generic data. This class is similar to System.Collections.Generic.List(T) but exposes a few more methods.","interfaces":["IList<T>","IList","ICloneable"],"constructors":[{"signature":"RhinoList<T>()","summary":"Initializes a new, empty list."},{"signature":"RhinoList<T>(IEnumerable<T> collection)","summary":"Initializes this list as a shallow duplicate of another list, array or any other enumerable set of T.","parameters":[{"name":"collection","summary":"Collection of items to duplicate."}]},{"signature":"RhinoList<T>(int initialCapacity)","summary":"Initializes an empty list with a certain capacity.","parameters":[{"name":"initialCapacity","summary":"Number of items this list can store without resizing."}]},{"signature":"RhinoList<T>(int amount, T defaultValue)","summary":"Initializes a new list with a specified amount of values.","parameters":[{"name":"amount","summary":"Number of values to add to this list. Must be equal to or larger than zero."},{"name":"defaultValue","summary":"Value to add, for reference types, the same item will be added over and over again."}]},{"signature":"RhinoList<T>(RhinoList<T> list)","summary":"Initializes an new list by shallow duplicating another list.","parameters":[{"name":"list","summary":"List to mimic."}]}],"properties":[{"signature":"int Capacity","summary":"Gets or sets the total number of elements the internal data structure can hold without resizing.","property":["get","set"]},{"signature":"int Count","summary":"Gets the number of elements actually contained in the List.","property":["get"]},{"signature":"T First","summary":"Gets or sets the first item in the list. This is synonymous to calling List[0].","property":["get","set"]},{"signature":"T Last","summary":"Gets or sets the last item in the list. This is synonymous to calling List[Count-1].","property":["get","set"]},{"signature":"int NullCount","summary":"Gets the number of None references (Nothing in Visual Basic) in this list. If T is a ValueType, this property always return zero.","property":["get"]}],"methods":[{"signature":"void Add(T item)","summary":"Adds an object to the end of the List.","parameters":[{"name":"item","summary":"Item to append."}]},{"signature":"void AddRange(IEnumerable collection)","summary":"Adds the elements of the specified collection to the end of the List.","parameters":[{"name":"collection","summary":"The collection whose elements should be added to the end of the List. The collection itself cannot be a None reference (Nothing in Visual Basic), but it can contain elements that are a None reference (Nothing in Visual Basic). Objects in collection which cannot be represented as T will throw exceptions."}]},{"signature":"void AddRange(IEnumerable<T> collection)","summary":"Adds the elements of the specified collection to the end of the List.","parameters":[{"name":"collection","summary":"The collection whose elements should be added to the end of the List. The collection itself cannot be a None reference (Nothing in Visual Basic), but it can contain elements that are a None reference (Nothing in Visual Basic), if type T is a reference type."}]},{"signature":"ReadOnlyCollection<T> AsReadOnly()","summary":"Constructs a read-only wrapper of this class.","returns":"A wrapper."},{"signature":"int BinarySearch(int index, int count, T item, IComparer<T> comparer)","summary":"Searches the entire sorted List for an element using the specified comparer and returns the zero-based index of the element.","parameters":[{"name":"index","summary":"The zero-based starting index of the range to search."},{"name":"count","summary":"The length of the range to search."},{"name":"item","summary":"The object to locate. The value can be a None reference (Nothing in Visual Basic) for reference types."},{"name":"comparer","summary":"The IComparer(T) implementation to use when comparing elements. Or a None reference (Nothing in Visual Basic) to use the default comparer Comparer(T)::Default."}],"returns":"The zero-based index of item in the sorted List, if item is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than item or, if there is no larger element, the bitwise complement of Count."},{"signature":"int BinarySearch(T item)","summary":"Searches the entire sorted List for an element using the default comparer and returns the zero-based index of the element.","parameters":[{"name":"item","summary":"The object to locate. The value can be a None reference (Nothing in Visual Basic) for reference types."}],"returns":"The zero-based index of item in the sorted List, if item is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than item or, if there is no larger element, the bitwise complement of Count."},{"signature":"int BinarySearch(T item, IComparer<T> comparer)","summary":"Searches the entire sorted List for an element using the specified comparer and returns the zero-based index of the element.","parameters":[{"name":"item","summary":"The object to locate. The value can be a None reference (Nothing in Visual Basic) for reference types."},{"name":"comparer","summary":"The IComparer(T) implementation to use when comparing elements. Or a None reference (Nothing in Visual Basic) to use the default comparer Comparer(T)::Default."}],"returns":"The zero-based index of item in the sorted List, if item is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than item or, if there is no larger element, the bitwise complement of Count."},{"signature":"void Clear()","summary":"Removes all elements from the List."},{"signature":"bool Contains(T item)","summary":"Determines whether an element is in the List.","parameters":[{"name":"item","summary":"The object to locate in the List. The value can be a None reference (Nothing in Visual Basic) for reference types."}],"returns":"True if item is found in the List; otherwise, false."},{"signature":"RhinoList<TOutput> ConvertAll(Converter<T, TOutput> converter)","summary":"Aggregates all results of a conversion function over this table into a new list.","parameters":[{"name":"converter","summary":"A conversion function that can transform from T to TOutput."}],"returns":"The new list."},{"signature":"void CopyTo(int index, T[] array, int arrayIndex, int count)","summary":"Copies a range of elements from the List to a compatible one-dimensional array, starting at the specified index of the target array.","parameters":[{"name":"index","summary":"The zero-based index in the source List at which copying begins."},{"name":"array","summary":"The one-dimensional Array that is the destination of the elements copied from List. The Array must have zero-based indexing."},{"name":"arrayIndex","summary":"The zero-based index in array at which copying begins."},{"name":"count","summary":"The number of elements to copy."}]},{"signature":"void CopyTo(T[] array)","summary":"Copies the entire List to a compatible one-dimensional array, starting at the beginning of the target array.","parameters":[{"name":"array","summary":"The one-dimensional Array that is the destination of the elements copied from List. The Array must have zero-based indexing."}]},{"signature":"void CopyTo(T[] array, int arrayIndex)","summary":"Copies the entire List to a compatible one-dimensional array, starting at the specified index of the target array.","parameters":[{"name":"array","summary":"The one-dimensional Array that is the destination of the elements copied from List. The Array must have zero-based indexing."},{"name":"arrayIndex","summary":"The zero-based index in array at which copying begins."}]},{"signature":"RhinoList<T> Duplicate()","summary":"Returns a shallow copy of this instance. If the generic type is comprised of only value types (struct, enum, ptr), then the result will be a deep copy.","returns":"The duplicated list."},{"signature":"bool Exists(Predicate<T> match)","summary":"Determines whether the List contains elements that match the conditions defined by the specified predicate.","parameters":[{"name":"match","summary":"The Predicate(T) delegate that defines the conditions of the elements to search for."}],"returns":"True if the List contains one or more elements that match the conditions defined by the specified predicate; otherwise, false."},{"signature":"T Find(Predicate<T> match)","summary":"Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire List.","parameters":[{"name":"match","summary":"The Predicate(T) delegate that defines the conditions of the element to search for."}],"returns":"The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type T."},{"signature":"RhinoList<T> FindAll(Predicate<T> match)","summary":"Retrieves all the elements that match the conditions defined by the specified predicate.","parameters":[{"name":"match","summary":"The Predicate(T) delegate that defines the conditions of the elements to search for."}],"returns":"A ON_List(T) containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty ON_List(T)."},{"signature":"int FindIndex(int startIndex, int count, Predicate<T> match)","summary":"Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the List that extends from the specified index to the last element.","parameters":[{"name":"startIndex","summary":"The zero-based starting index of the search."},{"name":"count","summary":"The number of elements in the section to search."},{"name":"match","summary":"The Predicate(T) delegate that defines the conditions of the element to search for."}],"returns":"The zero-based index of the first occurrence of an element that matches the conditions defined by match, if found; otherwise, -1."},{"signature":"int FindIndex(int startIndex, Predicate<T> match)","summary":"Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire List.","parameters":[{"name":"startIndex","summary":"The zero-based starting index of the search."},{"name":"match","summary":"The Predicate(T) delegate that defines the conditions of the element to search for."}],"returns":"The zero-based index of the first occurrence of an element that matches the conditions defined by match, if found; otherwise, -1."},{"signature":"int FindIndex(Predicate<T> match)","summary":"Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire List.","parameters":[{"name":"match","summary":"The Predicate(T) delegate that defines the conditions of the element to search for."}],"returns":"The zero-based index of the first occurrence of an element that matches the conditions defined by match, if found; otherwise, -1."},{"signature":"T FindLast(Predicate<T> match)","summary":"Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire List.","parameters":[{"name":"match","summary":"The Predicate(T) delegate that defines the conditions of the element to search for."}],"returns":"The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type T."},{"signature":"int FindLastIndex(int startIndex, int count, Predicate<T> match)","summary":"Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire List.","parameters":[{"name":"startIndex","summary":"The zero-based starting index of the backward search."},{"name":"count","summary":"The number of elements in the section to search."},{"name":"match","summary":"The Predicate(T) delegate that defines the conditions of the element to search for."}],"returns":"The zero-based index of the last occurrence of an element that matches the conditions defined by match, if found; otherwise, -1."},{"signature":"int FindLastIndex(int startIndex, Predicate<T> match)","summary":"Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire List.","parameters":[{"name":"startIndex","summary":"The zero-based starting index of the backward search."},{"name":"match","summary":"The Predicate(T) delegate that defines the conditions of the element to search for."}],"returns":"The zero-based index of the last occurrence of an element that matches the conditions defined by match, if found; otherwise, -1."},{"signature":"int FindLastIndex(Predicate<T> match)","summary":"Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire List.","parameters":[{"name":"match","summary":"The Predicate(T) delegate that defines the conditions of the element to search for."}],"returns":"The zero-based index of the last occurrence of an element that matches the conditions defined by match, if found; otherwise, -1."},{"signature":"void ForEach(Action<T> action)","summary":"Performs the specified action on each element of the List.","parameters":[{"name":"action","summary":"The Action(T) delegate to perform on each element of the List."}]},{"signature":"IEnumerator<T> GetEnumerator()","summary":"Constructs an enumerator that is capable of iterating over all items in this list.","returns":"The new enumerator."},{"signature":"RhinoList<T> GetRange(int index, int count)","summary":"Constructs a shallow copy of a range of elements in the source List.","parameters":[{"name":"index","summary":"The zero-based List index at which the range starts."},{"name":"count","summary":"The number of elements in the range."}],"returns":"A shallow copy of a range of elements in the source List."},{"signature":"int IndexOf(T item)","summary":"Searches for the specified object and returns the zero-based index of the first occurrence within the entire List.","parameters":[{"name":"item","summary":"The object to locate in the List. The value can be a None reference (Nothing in Visual Basic) for reference types."}],"returns":"The zero-based index of the first occurrence of item within the entire List, if found; otherwise, -1."},{"signature":"int IndexOf(T item, int index)","summary":"Searches for the specified object and returns the zero-based index of the first occurrence within the range of elements in the List that extends from the specified index to the last element.","parameters":[{"name":"item","summary":"The object to locate in the List. The value can be a None reference (Nothing in Visual Basic) for reference types."},{"name":"index","summary":"The zero-based starting index of the search."}],"returns":"The zero-based index of the first occurrence of item within the entire List, if found; otherwise, -1."},{"signature":"int IndexOf(T item, int index, int count)","summary":"Searches for the specified object and returns the zero-based index of the first occurrence within the range of elements in the List that starts at the specified index and contains the specified number of elements.","parameters":[{"name":"item","summary":"The object to locate in the List. The value can be a None reference (Nothing in Visual Basic) for reference types."},{"name":"index","summary":"The zero-based starting index of the search."},{"name":"count","summary":"The number of elements in the section to search."}],"returns":"The zero-based index of the first occurrence of item within the entire List, if found; otherwise, -1."},{"signature":"void Insert(int index, T item)","summary":"Inserts an element into the List at the specified index.","parameters":[{"name":"index","summary":"The zero-based index at which item should be inserted."},{"name":"item","summary":"The object to insert. The value can be a None reference (Nothing in Visual Basic) for reference types."}]},{"signature":"void InsertRange(int index, IEnumerable<T> collection)","summary":"Inserts the elements of a collection into the List at the specified index.","parameters":[{"name":"index","summary":"The zero-based index at which the new elements should be inserted."},{"name":"collection","summary":"The collection whose elements should be inserted into the List. The collection itself cannot be a None reference (Nothing in Visual Basic), but it can contain elements that are a None reference (Nothing in Visual Basic), if type T is a reference type."}]},{"signature":"int LastIndexOf(T item)","summary":"Searches for the specified object and returns the zero-based index of the last occurrence within the entire List.","parameters":[{"name":"item","summary":"The object to locate in the List. The value can be a None reference (Nothing in Visual Basic) for reference types."}],"returns":"The zero-based index of the last occurrence of item within the entire the List, if found; otherwise, -1."},{"signature":"int LastIndexOf(T item, int index)","summary":"Searches for the specified object and returns the zero-based index of the last occurrence within the range of elements in the List that extends from the first element to the specified index.","parameters":[{"name":"item","summary":"The object to locate in the List. The value can be a None reference (Nothing in Visual Basic) for reference types."},{"name":"index","summary":"The zero-based starting index of the backward search."}],"returns":"The zero-based index of the last occurrence of item within the entire the List, if found; otherwise, -1."},{"signature":"int LastIndexOf(T item, int index, int count)","summary":"Searches for the specified object and returns the zero-based index of the last occurrence within the range of elements in the List that contains the specified number of elements and ends at the specified index.","parameters":[{"name":"item","summary":"The object to locate in the List. The value can be a None reference (Nothing in Visual Basic) for reference types."},{"name":"index","summary":"The zero-based starting index of the backward search."},{"name":"count","summary":"The number of elements in the section to search."}],"returns":"The zero-based index of the last occurrence of item within the entire the List, if found; otherwise, -1."},{"signature":"int RemapIndex(int index)","summary":"Remap an index in the infinite range onto the List index range.","parameters":[{"name":"index","summary":"Index to remap."}],"returns":"Remapped index."},{"signature":"bool Remove(T item)","summary":"Removes the first occurrence of a specific object from the List.","parameters":[{"name":"item","summary":"The object to remove from the List. The value can be a None reference (Nothing in Visual Basic) for reference types."}],"returns":"True if item is successfully removed; otherwise, false. This method also returns False if item was not found in the List."},{"signature":"int RemoveAll(Predicate<T> match)","summary":"Removes the all the elements that match the conditions defined by the specified predicate.","parameters":[{"name":"match","summary":"The Predicate(T) delegate that defines the conditions of the elements to remove."}],"returns":"The number of elements removed from the List."},{"signature":"void RemoveAt(int index)","summary":"Removes the element at the specified index of the List.","parameters":[{"name":"index","summary":"The zero-based index of the element to remove."}]},{"signature":"int RemoveNulls()","summary":"Removes all elements from the List that are None references (Nothing in Visual Basic). This function will not do anything if T is not a Reference type.","returns":"The number of nulls removed from the List."},{"signature":"void RemoveRange(int index, int count)","summary":"Removes a range of elements from the List.","parameters":[{"name":"index","summary":"The zero-based starting index of the range of elements to remove."},{"name":"count","summary":"The number of elements to remove."}]},{"signature":"void Reverse()","summary":"Reverses the order of the elements in the entire List."},{"signature":"void Reverse(int index, int count)","summary":"Reverses the order of the elements in the specified range.","parameters":[{"name":"index","summary":"The zero-based starting index of the range to reverse."},{"name":"count","summary":"The number of elements in the range to reverse."}]},{"signature":"void Sort()","summary":"Sorts the elements in the entire List using the default comparer."},{"signature":"void Sort(Comparison<T> comparison)","summary":"Sorts the elements in the entire list using the specified comparer.","parameters":[{"name":"comparison","summary":"The System.Comparison(T) to use when comparing elements."}]},{"signature":"void Sort(double[] keys)","summary":"Sort this list based on a list of numeric keys of equal length. The keys array will not be altered.","parameters":[{"name":"keys","summary":"Numeric keys to sort with."}]},{"signature":"void Sort(IComparer<T> comparer)","summary":"Sorts the elements in the entire list using the specified System.Comparison(T)","parameters":[{"name":"comparer","summary":"The IComparer(T) implementation to use when comparing elements, or a None reference (Nothing in Visual Basic) to use the default comparer Comparer(T).Default."}]},{"signature":"void Sort(int index, int count, IComparer<T> comparer)","summary":"Sorts the elements in a range of elements in list using the specified comparer.","parameters":[{"name":"index","summary":"The zero-based starting index of the range to sort."},{"name":"count","summary":"The length of the range to sort."},{"name":"comparer","summary":"The IComparer(T) implementation to use when comparing elements, or a None reference (Nothing in Visual Basic) to use the default comparer Comparer(T).Default."}]},{"signature":"void Sort(int[] keys)","summary":"Sort this list based on a list of numeric keys of equal length. The keys array will not be altered.","parameters":[{"name":"keys","summary":"Numeric keys to sort with."}]},{"signature":"T[] ToArray()","summary":"Constructs an array that contains all items in this list.","returns":"An array containing all items in this list."},{"signature":"void TrimExcess()","summary":"Sets the capacity to the actual number of elements in the List, if that number is less than a threshold value."},{"signature":"bool TrueForAll(Predicate<T> match)","summary":"Determines whether every element in the List matches the conditions defined by the specified predicate.","parameters":[{"name":"match","summary":"The Predicate(T) delegate that defines the conditions to check against the elements."}],"returns":"True if every element in the List matches the conditions defined by the specified predicate; otherwise, false. If the list has no elements, the return value is true."}]},{"namespace":"Rhino.Collections","name":"TransformObjectList","dataType":"class","summary":"A collection of Rhino object, grip objects, and the Rhino objects that owns the grips. Used by the TransformCommand and GetTransform classes.","interfaces":["IDisposable"],"constructors":[{"signature":"TransformObjectList()","since":"5.0"}],"properties":[{"signature":"int Count","summary":"Number of elements in this list","since":"5.10","property":["get"]},{"signature":"bool DisplayFeedbackEnabled","since":"5.0","property":["get","set"]},{"signature":"int GripCount","summary":"Number of elements in grip list","since":"6.0","property":["get"]},{"signature":"int GripOwnerCount","summary":"Number of elements in grip owner list","since":"6.0","property":["get"]}],"methods":[{"signature":"void Add(ObjRef objref)","summary":"Add an ObjRef to this list. Use this to add polyedges so the references are properly counted","since":"5.10"},{"signature":"void Add(RhinoObject rhinoObject)","summary":"Add a RhinoObject to this list","since":"5.10"},{"signature":"int AddObjects(GetObject go, bool allowGrips)","summary":"Add objects to list with a GetObject","since":"6.0","parameters":[{"name":"go","summary":"Setup the GetObject, i.e. prompt, geometry filter, allow pre/post select before passing it as an argument."},{"name":"allowGrips","summary":"Specifically allow grips to be selected.  if true, grips must also be included in geometry filter of the GetObject in order to be selected."}],"returns":"Number of objects selected."},{"signature":"void Clear()","summary":"Remove all elements from this list","since":"5.10"},{"signature":"void Dispose()","since":"5.0"},{"signature":"BoundingBox GetBoundingBox(bool regularObjects, bool grips)","summary":"Gets the bounding box of all of the objects that this list contains.","since":"5.0","parameters":[{"name":"regularObjects","summary":"True if any object except grips should be included; otherwise false."},{"name":"grips","summary":"True if grips should be included; otherwise false."}],"returns":"Unset BoundingBox if this list is empty."},{"signature":"GripObject[] GripArray()","summary":"Gets access to the internal GripObject array of the TransformObjectList object.","since":"6.0","returns":"An array of grip objects, or an empty array if there were no grip objects."},{"signature":"RhinoObject[] GripOwnerArray()","summary":"Gets access to the internal GripOwner array of the TransformObjectList object.","since":"6.0","returns":"A n array of Rhino objects that are the owners of the grip objects the collection, or an empty array if there were no Rhino objects."},{"signature":"RhinoObject[] ObjectArray()","summary":"Gets access to the internal RhinoObject array of the TransformObjectList object.","since":"7.0","returns":"An array of Rhino objects, or an empty array if there were no Rhino objects."},{"signature":"bool UpdateDisplayFeedbackTransform(Transform xform)","since":"5.0"}]},{"namespace":"Rhino.Commands","name":"Command","dataType":"class","summary":"Defines a base class for all commands. This class is abstract.","properties":[{"signature":"static Guid LastCommandId","summary":"Gets the ID of the last commands.","since":"5.0","property":["get"]},{"signature":"static Result LastCommandResult","summary":"Gets the result code of the last command.","since":"5.0","property":["get"]},{"signature":"string EnglishName","summary":"Gets the name of the command. This method is abstract.","since":"5.0","property":["get"]},{"signature":"Guid Id","summary":"Gets the  unique ID of this command. It is best to use a Guid attribute for each custom derived command class since this will keep the id consistent between sessions of Rhino  System.Runtime.InteropServices.GuidAttribute","since":"5.0","property":["get"]},{"signature":"string LocalName","summary":"Gets the local name of the command.","since":"5.0","property":["get"]},{"signature":"PlugIn PlugIn","summary":"Gets the plug-in where this commands is placed.","since":"5.0","property":["get","set"]},{"signature":"PersistentSettings Settings","summary":"Gets the settings of the command.","since":"5.0","property":["get"]}],"methods":[{"signature":"static void DisplayHelp(Guid commandId)","summary":"Displays help for a command.","since":"5.0","parameters":[{"name":"commandId","summary":"A command ID."}]},{"signature":"static string[] GetCommandNames(bool english, bool loaded)","summary":"Gets list of command names in Rhino. This list does not include Test, Alpha, or System commands.","since":"5.0","parameters":[{"name":"english","summary":"if true, retrieve the English name for every command. if false, retrieve the local name for every command."},{"name":"loaded","summary":"if true, only get names of currently loaded commands. if false, get names of all registered (may not be currently loaded) commands."}],"returns":"An array instance with command names. This array could be empty, but not null."},{"signature":"static Guid[] GetCommandStack()","summary":"Determines if Rhino is currently running a command. Because Rhino allow for transparent commands (commands that can be run from inside of other commands), this method returns the total ids of active commands.","since":"5.0","returns":"Ids of running commands or None if no commands are currently running. The \\"active\\" command is at the end of this list."},{"signature":"static MostRecentCommandDescription[] GetMostRecentCommands()","summary":"Gets an array of most recent command descriptions.","since":"5.0","returns":"An array of command descriptions."},{"signature":"static bool InCommand()","summary":"Determines if Rhino is currently running a command.","since":"5.0","returns":"True if a command is currently running, False if no commands are currently running."},{"signature":"static bool InScriptRunnerCommand()","summary":"This is a low level tool to determine if Rhino is currently running a script running command like \\"ReadCommandFile\\" or the RhinoScript plug-in\'s \\"RunScript\\".","since":"5.0","returns":"True if a script running command is active."},{"signature":"static bool IsCommand(string name)","summary":"Determines is a string is a command.","since":"5.0","parameters":[{"name":"name","summary":"A string."}],"returns":"True if the string is a command."},{"signature":"static bool IsValidCommandName(string name)","summary":"Determines if a string is a valid command name.","since":"5.0","parameters":[{"name":"name","summary":"A string."}],"returns":"True if the string is a valid command name."},{"signature":"static Guid LookupCommandId(string name, bool searchForEnglishName)","summary":"Returns the ID of a command.","since":"5.0","parameters":[{"name":"name","summary":"The name of the command."},{"name":"searchForEnglishName","summary":"True if the name is to searched in English. This ensures that a \'_\' is prepended to the name."}],"returns":"An of the command, or Guid.Emptyon error."},{"signature":"static string LookupCommandName(Guid commandId, bool englishName)","summary":"Returns the command name given a command ID.","since":"5.0","parameters":[{"name":"commandId","summary":"A command ID."},{"name":"englishName","summary":"True if the requested command is in English."}],"returns":"The command name, or None on error."},{"signature":"static void RunProxyCommand(RunCommandDelegate commandCallback, RhinoDoc doc, object data)","summary":"Execute some code as if it were running in a command","since":"6.13","parameters":[{"name":"commandCallback","summary":""},{"name":"doc","summary":""},{"name":"data","summary":"optional extra data to pass to callback"}]}],"events":[{"signature":"static BeginCommand","summary":"Called just before command.RunCommand().","since":"5.0"},{"signature":"static EndCommand","summary":"Called immediately after command.RunCommand().","since":"5.0"},{"signature":"static UndoRedo","summary":"Used to monitor Rhino\'s built in undo/redo support.","since":"5.0"}]},{"namespace":"Rhino.Commands","name":"CommandEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"string CommandEnglishName","summary":"Gets the English name of the command that raised this event.","since":"5.0","property":["get"]},{"signature":"Guid CommandId","summary":"Gets the ID of the command that raised this event.","since":"5.0","property":["get"]},{"signature":"string CommandLocalName","summary":"Gets the name of the command that raised this event in the local language.","since":"5.0","property":["get"]},{"signature":"string CommandPluginName","summary":"Gets the name of the plug-in that this command belongs to.  If the command is internal to Rhino, then this property is an empty string.","since":"5.0","property":["get"]},{"signature":"Result CommandResult","summary":"Gets the result of the command that raised this event. This value is only meaningful during EndCommand events.","since":"5.0","property":["get"]},{"signature":"RhinoDoc Document","since":"6.0","property":["get"]},{"signature":"uint DocumentRuntimeSerialNumber","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Commands","name":"CommandStyleAttribute","dataType":"class","summary":"Decorates Commandto provide styles.","baseclass":"Attribute","constructors":[{"signature":"CommandStyleAttribute(Style styles)","summary":"Initializes a new command style attribute class.","since":"5.0","parameters":[{"name":"styles","summary":"Set of values combined using a bitwise OR operation to get the desired combination of command styles."}]}],"properties":[{"signature":"Style Styles","summary":"Gets the associated style.","since":"5.0","property":["get"]}]},{"namespace":"Rhino.Commands","name":"CustomUndoEventArgs","dataType":"class","summary":"Argument package that is passed to a custom undo delegate","baseclass":"EventArgs","properties":[{"signature":"string ActionDescription","since":"5.0","property":["get"]},{"signature":"Guid CommandId","since":"5.0","property":["get"]},{"signature":"bool CreatedByRedo","since":"5.0","property":["get"]},{"signature":"RhinoDoc Document","since":"5.0","property":["get"]},{"signature":"object Tag","since":"5.0","property":["get"]},{"signature":"uint UndoSerialNumber","since":"5.0","property":["get"]}]},{"namespace":"Rhino.Commands","name":"MostRecentCommandDescription","dataType":"class","summary":"Stores the macro and display string of the most recent command.","properties":[{"signature":"string DisplayString","since":"5.0","property":["get","set"]},{"signature":"string Macro","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.Commands","name":"Result","dataType":"enum","summary":"Defines enumerated constant values for several command result types.","since":"5.0","values":[{"signature":"Success = 0","summary":"Command worked."},{"signature":"Cancel  = 1","summary":"User canceled command."},{"signature":"Nothing = 2","summary":"Command did nothing but cancel was not pressed."},{"signature":"Failure","summary":"Command failed (bad input, computational problem, etc.)"},{"signature":"UnknownCommand","summary":"Command not found (user probably had a typo in command name)."},{"signature":"CancelModelessDialog","summary":"Commands canceled and modeless dialog."},{"signature":"ExitRhino = 0x0FFFFFFF","summary":"exit RhinoCommon."}]},{"namespace":"Rhino.Commands","name":"RunMode","dataType":"enum","summary":"Provides enumerated constants for a command running mode. This is currently interactive or scripted.","since":"5.0","values":[{"signature":"Interactive = 0","summary":"Can use dialogs for input. Must use message boxes to report serious error conditions."},{"signature":"Scripted = 1","summary":"All input must come from command line, GetPoint, GetObject, GetString, etc.  Must use message boxes to report serious error conditions.  Script mode gets used when a command is run with a hyphen (-) prefix."}]},{"namespace":"Rhino.Commands","name":"SelCommand","dataType":"class","summary":"For adding nestable selection commands that work like the native Rhino SelCrv command, derive your command from SelCommand and override the virtual SelFilter function.","baseclass":"Rhino.Commands.Command","properties":[{"signature":"bool BeQuiet","since":"5.0","property":["get","set"]},{"signature":"bool TestGrips","since":"5.0","property":["get","set"]},{"signature":"bool TestLights","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.Commands","name":"Style","dataType":"enum","summary":"Defines bitwise mask flags for different styles of commands, such as  Style.Hiddenor Style.DoNotRepeat.","since":"5.0","values":[{"signature":"None = 0","summary":"No flag is defined."},{"signature":"Hidden = 1","summary":"Also known as a \\"test\\" command. The command name does not auto-complete when typed on the command line an is therefore not discoverable. Useful for writing commands that users don\'t normally have access to."},{"signature":"ScriptRunner = 2","summary":"For commands that want to run scripts as if they were typed at the command line (like RhinoScript\'s RunScript command)"},{"signature":"Transparent = 4","summary":"Transparent commands can be run inside of other commands. The command does not modify the contents of the model\'s geometry in any way. Examples of transparent commands include commands that change views and toggle snap states.  Any command that adds or deletes, a view cannot be transparent."},{"signature":"DoNotRepeat = 8","summary":"The command should not be repeated by pressing \\"ENTER\\" immediately after the command finishes."},{"signature":"NotUndoable = 16","summary":"By default, all commands are undo-able."}]},{"namespace":"Rhino.Commands","name":"TransformCommand","dataType":"class","baseclass":"Rhino.Commands.Command"},{"namespace":"Rhino.Commands","name":"UndoRedoEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"Guid CommandId","since":"5.0","property":["get"]},{"signature":"bool IsBeginRecording","since":"5.0","property":["get"]},{"signature":"bool IsBeginRedo","since":"5.0","property":["get"]},{"signature":"bool IsBeginUndo","since":"5.0","property":["get"]},{"signature":"bool IsEndRecording","since":"5.0","property":["get"]},{"signature":"bool IsEndRedo","since":"5.0","property":["get"]},{"signature":"bool IsEndUndo","since":"5.0","property":["get"]},{"signature":"bool IsPurgeRecord","since":"5.0","property":["get"]},{"signature":"uint UndoSerialNumber","since":"5.0","property":["get"]}]},{"namespace":"Rhino.Display","name":"BackgroundStyle","dataType":"enum","summary":"Constants that define how the background of a viewport should be filled.","since":"5.0","values":[{"signature":"SolidColor = 0","summary":"Single solid color fill."},{"signature":"WallpaperImage = 1","summary":"Simple image background wallpaper."},{"signature":"Gradient = 2","summary":"Two color top/bottom color gradient."},{"signature":"Environment = 3","summary":"Using a special environment."}]},{"namespace":"Rhino.Display","name":"BlendMode","dataType":"enum","summary":"Defines enumerated constants for display blend modes.","since":"5.0","values":[{"signature":"Zero = 0","summary":"Blends using 0."},{"signature":"One = 1","summary":"Blends using 1."},{"signature":"SourceColor = 0x0300","summary":"Blends using source color."},{"signature":"OneMinusSourceColor = 0x0301","summary":"Blends using 1-source color."},{"signature":"SourceAlpha = 0x0302","summary":"Blends using the source alpha channel."},{"signature":"OneMinusSourceAlpha = 0x0303","summary":"Blends using 1-the source alpha channel."},{"signature":"DestinationAlpha = 0x0304","summary":"Blends using the destination alpha channel."},{"signature":"OneMinusDestinationAlpha = 0x0305","summary":"Blends using 1-the destination alpha channel."},{"signature":"DestinationColor = 0x0306","summary":"Blends using the destination color."},{"signature":"OneMinusDestinationColor = 0x0307","summary":"Blends using 1-the destination color."},{"signature":"SourceAlphaSaturate = 0x0308","summary":"Blends using the source alpha saturation."}]},{"namespace":"Rhino.Display","name":"CalculateBoundingBoxEventArgs","dataType":"class","baseclass":"Rhino.Display.DrawEventArgs","properties":[{"signature":"BoundingBox BoundingBox","summary":"Gets the current bounding box.","since":"5.0","property":["get"]}],"methods":[{"signature":"void IncludeBoundingBox(BoundingBox box)","summary":"Unites a bounding box with the current display bounding box in order to ensure dynamic objects in \\"box\\" are drawn.","since":"5.0","parameters":[{"name":"box","summary":"The box to unite."}]}]},{"namespace":"Rhino.Display","name":"Color4f","dataType":"struct","summary":"Color defined by 4 floating point values.","constructors":[{"signature":"Color4f(Color color)","since":"5.0"},{"signature":"Color4f(Color4f color)","since":"5.0"},{"signature":"Color4f(float red, float green, float blue, float alpha)","since":"5.0"},{"signature":"Color4f(int argb)","since":"7.0"}],"properties":[{"signature":"static Color4f Black","since":"5.0","property":["get"]},{"signature":"static Color4f Empty","since":"5.0","property":["get"]},{"signature":"static Color4f White","since":"5.0","property":["get"]},{"signature":"float A","since":"5.0","property":["get"]},{"signature":"float B","since":"5.0","property":["get"]},{"signature":"float G","since":"5.0","property":["get"]},{"signature":"float L","since":"6.3","property":["get"]},{"signature":"float R","since":"5.0","property":["get"]}],"methods":[{"signature":"static Color4f ApplyGamma(Color4f col, float gamma)","since":"6.0"},{"signature":"static Color4f FromArgb(float a, Color4f color)","since":"5.11"},{"signature":"static Color4f FromArgb(float a, float r, float g, float b)","since":"5.11"},{"signature":"System.Drawing.Color AsSystemColor()","since":"5.0"},{"signature":"Color4f BlendTo(float t, Color4f col)","since":"5.0"},{"signature":"bool Equals(object obj)"},{"signature":"int GetHashCode()"}]},{"namespace":"Rhino.Display","name":"ColorCMYK","dataType":"struct","summary":"Represents a CMYK (Cyan, Magenta, Yellow, Key) color with double precision floating point channels. CMYK colors are used primarily in printing environments as they provide a good simulation of physical ink.","constructors":[{"signature":"ColorCMYK(Color rgb)","summary":"Initializes a new instance of ColorCMYK that is equivalent to an RGB color.","since":"5.0","parameters":[{"name":"rgb","summary":"RGB color to mimic."}]},{"signature":"ColorCMYK(double cyan, double magenta, double yellow)","summary":"Initializes a new instance of ColorCMYK with custom channel values. The cyan, magenta and yellow values will be adjusted based on their combined darkness.","since":"5.0","parameters":[{"name":"cyan","summary":"Cyan channel hint."},{"name":"magenta","summary":"Magenta channel hint."},{"name":"yellow","summary":"Yellow channel hint."}]},{"signature":"ColorCMYK(double cyan, double magenta, double yellow, double key)","summary":"Initializes a new instance of ColorCMYK with custom channel values.","since":"5.0","parameters":[{"name":"cyan","summary":"Cyan channel value. Cyan channels are limited to the 0.0 and 1.0 range."},{"name":"magenta","summary":"Magenta channel value. Magenta channels are limited to the 0.0 and 1.0 range."},{"name":"yellow","summary":"Yellow channel value. Yellow channels are limited to the 0.0 and 1.0 range."},{"name":"key","summary":"Key channel value. Key channels are limited to the 0.0 and 1.0 range."}]},{"signature":"ColorCMYK(double alpha, double cyan, double magenta, double yellow, double key)","summary":"Initializes a new instance of ColorCMYK with custom channel values.","since":"5.0","parameters":[{"name":"alpha","summary":"Alpha channel value. Alpha channels are limited to the 0.0 and 1.0 range."},{"name":"cyan","summary":"Cyan channel value. Cyan channels are limited to the 0.0 and 1.0 range."},{"name":"magenta","summary":"Magenta channel value. Magenta channels are limited to the 0.0 and 1.0 range."},{"name":"yellow","summary":"Yellow channel value. Yellow channels are limited to the 0.0 and 1.0 range."},{"name":"key","summary":"Key channel value. Key channels are limited to the 0.0 and 1.0 range."}]}],"properties":[{"signature":"double A","summary":"Gets or sets the Alpha channel value. Alpha channels are limited to the 0~1 range.","since":"5.0","property":["get","set"]},{"signature":"double C","summary":"Gets or sets the Cyan channel value. Cyan channels are limited to the 0~1 range.","since":"5.0","property":["get","set"]},{"signature":"double K","summary":"Gets or sets the Key channel value. Key channels are limited to the 0~1 range.","since":"5.0","property":["get","set"]},{"signature":"double M","summary":"Gets or sets the Magenta channel value. Magenta channels are limited to the 0~1 range.","since":"5.0","property":["get","set"]},{"signature":"double Y","summary":"Gets or sets the Yellow channel value. Yellow channels are limited to the 0~1 range.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static ColorCMYK CreateFromHSL(ColorHSL hsl)","summary":"Constructs the nearest CMYK equivalent of an HSL color.","since":"5.0","parameters":[{"name":"hsl","summary":"Target color in HSL space."}],"returns":"The CMYK equivalent of the HSL color."},{"signature":"static ColorCMYK CreateFromHSV(ColorHSV hsv)","summary":"Constructs the nearest CMYK equivalent of an HSV color.","since":"6.0","parameters":[{"name":"hsv","summary":"Target color in HSV space."}],"returns":"The CMYK equivalent of the HSV color."},{"signature":"static ColorCMYK CreateFromLAB(ColorLAB lab)","summary":"Constructs the nearest CMYK equivalent of a LAB color.","since":"5.0","parameters":[{"name":"lab","summary":"Target color in LAB space."}],"returns":"The CMYK equivalent of the LAB color."},{"signature":"static ColorCMYK CreateFromLCH(ColorLCH lch)","summary":"Constructs the nearest CMYK equivalent of a LCH color.","since":"5.0","parameters":[{"name":"lch","summary":"Target color in LCH space."}],"returns":"The CMYK equivalent of the LCH color."},{"signature":"static ColorCMYK CreateFromXYZ(ColorXYZ xyz)","summary":"Constructs the nearest CMYK equivalent of an XYZ color.","since":"5.0","parameters":[{"name":"xyz","summary":"Target color in XYZ space."}],"returns":"The CMYK equivalent of the XYZ color."}]},{"namespace":"Rhino.Display","name":"ColorGradient","dataType":"class","properties":[{"signature":"Point3d EndPoint","summary":"End point of gradient","since":"7.0","property":["get","set"]},{"signature":"GradientType GradientType","summary":"Gradient fill type associated with this hatch","since":"7.0","property":["get","set"]},{"signature":"double Repeat","summary":"Repeat factor for gradient. Factors greater than 1 define a reflected repeat factor while values less than -1 define a wrapped repeat factor.","since":"7.0","property":["get","set"]},{"signature":"Point3d StartPoint","summary":"Start point of gradient","since":"7.0","property":["get","set"]}],"methods":[{"signature":"ColorStop[] GetColorStops()","summary":"Get sorted list of colors / positions that a gradient is defined over","since":"7.0"},{"signature":"void SetColorStops(IEnumerable<ColorStop> stops)","summary":"Set color stops for the gradient","since":"7.0"}]},{"namespace":"Rhino.Display","name":"ColorHSL","dataType":"struct","summary":"Represents an HSL (Hue, Saturation, Luminance) color with double precision floating point channels. HSL colors are used primarily in Graphical User Interface environments as they provide a very natural approach to picking colors.","constructors":[{"signature":"ColorHSL(Color rgb)","summary":"Constructs a new instance of ColorHSL that is equivalent to an RGB color.","since":"5.0","parameters":[{"name":"rgb","summary":"RGB color to mimic."}]},{"signature":"ColorHSL(double hue, double saturation, double luminance)","summary":"Constructs a new instance of ColorHSL with custom channel values.","since":"5.0","parameters":[{"name":"hue","summary":"Hue channel value. Hue channels rotate between 0.0 and 1.0."},{"name":"saturation","summary":"Saturation channel value. Channel will be limited to 0~1."},{"name":"luminance","summary":"Luminance channel value. Channel will be limited to 0~1."}]},{"signature":"ColorHSL(double alpha, double hue, double saturation, double luminance)","summary":"Constructs a new instance of ColorHSL with custom channel values.","since":"5.0","parameters":[{"name":"alpha","summary":"Alpha channel value. Channel will be limited to 0~1."},{"name":"hue","summary":"Hue channel value. Hue channels rotate between 0.0 and 1.0."},{"name":"saturation","summary":"Saturation channel value. Channel will be limited to 0~1."},{"name":"luminance","summary":"Luminance channel value. Channel will be limited to 0~1."}]}],"properties":[{"signature":"double A","summary":"Gets or sets the alpha channel value. Alpha channels are limited to a 0~1 range.","since":"5.0","property":["get","set"]},{"signature":"double H","summary":"Gets or sets the hue channel value. Hue channels rotate between 0.0 and 1.0.","since":"5.0","property":["get","set"]},{"signature":"double L","summary":"Gets or sets the luminance channel value. Luminance channels are limited to a 0~1 range.","since":"5.0","property":["get","set"]},{"signature":"double S","summary":"Gets or sets the saturation channel value. Saturation channels are limited to a 0~1 range.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static ColorHSL CreateFromCMYK(ColorCMYK cmyk)","summary":"Create the nearest HSL equivalent of a CMYK color.","since":"5.0","parameters":[{"name":"cmyk","summary":"Target color in CMYK space."}],"returns":"The HSL equivalent of the CMYK color."},{"signature":"static ColorHSL CreateFromHSV(ColorHSV hsv)","summary":"Constructs the nearest HSL equivalent of an HSV color.","since":"6.0","parameters":[{"name":"hsv","summary":"Target color in HSV space."}],"returns":"The HSL equivalent of the HSV color."},{"signature":"static ColorHSL CreateFromLAB(ColorLAB lab)","summary":"Create the nearest HSL equivalent of a LAB color.","since":"5.0","parameters":[{"name":"lab","summary":"Target color in LAB space."}],"returns":"The HSL equivalent of the LAB color."},{"signature":"static ColorHSL CreateFromLCH(ColorLCH lch)","summary":"Create the nearest HSL equivalent of a LCH color.","since":"5.0","parameters":[{"name":"lch","summary":"Target color in LCH space."}],"returns":"The HSL equivalent of the LCH color."},{"signature":"static ColorHSL CreateFromXYZ(ColorXYZ xyz)","summary":"Create the nearest HSL equivalent of an XYZ color.","since":"5.0","parameters":[{"name":"xyz","summary":"Target color in XYZ space."}],"returns":"The HSL equivalent of the XYZ color."},{"signature":"System.Drawing.Color ToArgbColor()","summary":"Convert HSL color to an equivalent System.Drawing.Color.","since":"5.0","returns":"A .Net framework library color value."}]},{"namespace":"Rhino.Display","name":"ColorHSV","dataType":"struct","summary":"Represents an HSV (Hue, Saturation, Value) color with double precision floating point channels. HSV colors (also sometimes called HSB, where B means Brightness) are similar to HSL colors in that they represent colors in a cylindrical color space, and are intended to provide intuitive means to edit the brightness of a particular color over RGB color space where each color channel would need to be modified to affect the color brightness.","constructors":[{"signature":"ColorHSV(Color rgb)","summary":"Constructs a new instance of ColorHSV that is equivalent to an RGB color.","since":"6.0","parameters":[{"name":"rgb","summary":"RGB color to mimic."}]},{"signature":"ColorHSV(double hue, double saturation, double value)","summary":"Constructs a new instance of ColorHSV with custom channel values.","since":"6.0","parameters":[{"name":"hue","summary":"Hue channel value. Hue channels rotate between 0.0 and 1.0."},{"name":"saturation","summary":"Saturation channel value. Channel will be limited to 0~1."},{"name":"value","summary":"Value (Brightness) channel value. Channel will be limited to 0~1."}]},{"signature":"ColorHSV(double alpha, double hue, double saturation, double value)","summary":"Constructs a new instance of ColorHSV with custom channel values.","since":"6.0","parameters":[{"name":"alpha","summary":"Alpha channel value. Channel will be limited to 0~1."},{"name":"hue","summary":"Hue channel value. Hue channels rotate between 0.0 and 1.0."},{"name":"saturation","summary":"Saturation channel value. Channel will be limited to 0~1."},{"name":"value","summary":"Value (Brightness) channel value. Channel will be limited to 0~1."}]}],"properties":[{"signature":"double A","summary":"Gets or sets the alpha channel value. Alpha channels are limited to a 0~1 range.","since":"6.0","property":["get","set"]},{"signature":"double H","summary":"Gets or sets the hue channel value. Hue channels rotate between 0.0 and 1.0.","since":"6.0","property":["get","set"]},{"signature":"double S","summary":"Gets or sets the saturation channel value. Saturation channels are limited to a 0~1 range.","since":"6.0","property":["get","set"]},{"signature":"double V","summary":"Gets or sets the value (brightness) channel value. Value channels are limited to a 0~1 range.","since":"6.0","property":["get","set"]}],"methods":[{"signature":"static ColorHSV CreateFromCMYK(ColorCMYK cmyk)","summary":"Create the nearest HSV equivalent of a CMYK color.","since":"6.0","parameters":[{"name":"cmyk","summary":"Target color in CMYK space."}],"returns":"The HSV equivalent of the CMYK color."},{"signature":"static ColorHSV CreateFromHSL(ColorHSL hsl)","summary":"Constructs the nearest CMYK equivalent of an HSV color.","since":"6.0","parameters":[{"name":"hsl","summary":"Target color in HSL space."}],"returns":"The HSV equivalent of the HSL color."},{"signature":"static ColorHSV CreateFromLAB(ColorLAB lab)","summary":"Create the nearest HSV equivalent of a LAB color.","since":"6.0","parameters":[{"name":"lab","summary":"Target color in LAB space."}],"returns":"The HSV equivalent of the LAB color."},{"signature":"static ColorHSV CreateFromLCH(ColorLCH lch)","summary":"Create the nearest HSV equivalent of a LCH color.","since":"6.0","parameters":[{"name":"lch","summary":"Target color in LCH space."}],"returns":"The HSV equivalent of the LCH color."},{"signature":"static ColorHSV CreateFromXYZ(ColorXYZ xyz)","summary":"Create the nearest HSV equivalent of an XYZ color.","since":"6.0","parameters":[{"name":"xyz","summary":"Target color in XYZ space."}],"returns":"The HSV equivalent of the XYZ color."},{"signature":"System.Drawing.Color ToArgbColor()","summary":"Convert HSV color to an equivalent System.Drawing.Color.","since":"6.0","returns":"A .Net framework library color value."}]},{"namespace":"Rhino.Display","name":"ColorLAB","dataType":"struct","summary":"Represents a LAB (Lightness, A, B) color with double precision floating point channels. LAB colors are based on nonlinearly compressed CIE XYZ color space coordinates. The A and B parameters of a LAB color represent the opponents.","constructors":[{"signature":"ColorLAB(Color rgb)","summary":"Constructs a new instance of ColorLAB that is equivalent to an RGB color.","since":"5.0","parameters":[{"name":"rgb","summary":"RGB color to mimic."}]},{"signature":"ColorLAB(double lightness, double a, double b)","summary":"Constructs a new instance of ColorLAB with custom channel values.","since":"5.0"},{"signature":"ColorLAB(double alpha, double lightness, double a, double b)","summary":"Constructs a new instance of ColorLAB with custom channel values.","since":"5.0"}],"properties":[{"signature":"double A","summary":"Gets or sets the Base channel. The channel is limited to 0~1.","since":"5.0","property":["get","set"]},{"signature":"double Alpha","summary":"Gets or sets the Alpha channel. The channel is limited to 0~1.","since":"5.0","property":["get","set"]},{"signature":"double B","summary":"Gets or sets the Opponent channel. The channel is limited to 0~1.","since":"5.0","property":["get","set"]},{"signature":"double L","summary":"Gets or sets the lightness channel. The channel is limited to 0~1.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static ColorLAB CreateFromCMYK(ColorCMYK cmyk)","summary":"Create the nearest LAB equivalent of a CMYK color.","since":"5.0","parameters":[{"name":"cmyk","summary":"Target color in CMYK space."}],"returns":"The LAB equivalent of the CMYK color."},{"signature":"static ColorLAB CreateFromHSL(ColorHSL hsl)","summary":"Create the nearest LAB equivalent of an HSL color.","since":"5.0","parameters":[{"name":"hsl","summary":"Target color in HSL space."}],"returns":"The LAB equivalent of the HSL color."},{"signature":"static ColorLAB CreateFromHSV(ColorHSV hsv)","summary":"Constructs the nearest LAB equivalent of an HSV color.","since":"6.0","parameters":[{"name":"hsv","summary":"Target color in HSV space."}],"returns":"The LAB equivalent of the HSV color."},{"signature":"static ColorLAB CreateFromLCH(ColorLCH lch)","summary":"Create the nearest LAB equivalent of an LCH color.","since":"5.0","parameters":[{"name":"lch","summary":"Target color in LCH space."}],"returns":"The LAB equivalent of the LCH color."},{"signature":"static ColorLAB CreateFromXYZ(ColorXYZ xyz)","summary":"Create the nearest LAB equivalent of an XYZ color.","since":"5.0","parameters":[{"name":"xyz","summary":"Target color in XYZ space."}],"returns":"The LAB equivalent of the XYZ color."}]},{"namespace":"Rhino.Display","name":"ColorLCH","dataType":"struct","summary":"Represents an LCH (Lightness, A, B) color with double precision floating point channels. LCH colors (also sometimes called CIELUV) are transformation of the 1931 CIE XYZ color space, in order to approach perceptual uniformity. They are primarily used in computer graphics which deal with colored lights.","constructors":[{"signature":"ColorLCH(Color rgb)","summary":"Constructs a new instance of ColorLCH that is equivalent to an RGB color.","since":"5.0","parameters":[{"name":"rgb","summary":"RGB color to mimic."}]},{"signature":"ColorLCH(double lightness, double chroma, double hue)","summary":"Constructs a new instance of ColorLCH with custom channel values.","since":"5.0","parameters":[{"name":"lightness","summary":"Value of lightness channel. This channel is limited to 0~1."},{"name":"chroma","summary":"Value of chroma channel. This channel is limited to -1~1."},{"name":"hue","summary":"Value of chroma channel. This channel is limited to 0~360."}]},{"signature":"ColorLCH(double alpha, double lightness, double chroma, double hue)","summary":"Constructs a new instance of ColorLCH with custom channel values.","since":"5.0","parameters":[{"name":"alpha","summary":"Value of Alpha channel. This channel is limited to 0~1."},{"name":"lightness","summary":"Value of Lightness channel. This channel is limited to 0~1."},{"name":"chroma","summary":"Value of Chroma channel. This channel is limited to -1~1."},{"name":"hue","summary":"Value of Hue channel. This channel is limited to 0~360."}]}],"properties":[{"signature":"double A","summary":"Gets or sets the Alpha channel. The Alpha channel is limited to the 0~1 range.","since":"5.0","property":["get","set"]},{"signature":"double C","summary":"Gets or sets the Chroma channel. Chroma is defined from -1.0 to +1.0.","since":"5.0","property":["get","set"]},{"signature":"double H","summary":"Gets or sets the Hue channel. The hue channel is limited to the 0~360 degree range.","since":"5.0","property":["get","set"]},{"signature":"double L","summary":"Gets or sets the Lightness channel.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static ColorLCH CreateFromCMYK(ColorCMYK cmyk)","summary":"Create the nearest LCH equivalent of a CMYK color.","since":"5.0","parameters":[{"name":"cmyk","summary":"Target color in CMYK space."}],"returns":"The LCH equivalent of the CMYK color."},{"signature":"static ColorLCH CreateFromHSL(ColorHSL hsl)","summary":"Create the nearest LCH equivalent of an HSL color.","since":"5.0","parameters":[{"name":"hsl","summary":"Target color in HSL space."}],"returns":"The LCH equivalent of the HSL color."},{"signature":"static ColorLCH CreateFromLAB(ColorLAB lab)","summary":"Create the nearest LCH equivalent of a LAB color.","since":"5.0","parameters":[{"name":"lab","summary":"Target color in LAB space."}],"returns":"The LCH equivalent of the LAB color."},{"signature":"static ColorLCH CreateFromXYZ(ColorXYZ xyz)","summary":"Create the nearest LCH equivalent of an XYZ color.","since":"5.0","parameters":[{"name":"xyz","summary":"Target color in XYZ space."}],"returns":"The LCH equivalent of the XYZ color."},{"signature":"void MakePositive()","summary":"Ensure the Chromaticity of this color is positive.","since":"5.0"}]},{"namespace":"Rhino.Display","name":"ColorStop","dataType":"struct","summary":"Combination of a color and position. Used in defining gradient fills","constructors":[{"signature":"ColorStop(Color color, double t)","summary":"Create color stop from a color and position","since":"7.0"}],"properties":[{"signature":"Color Color","since":"7.0","property":["get","set"]},{"signature":"double Position","summary":"Parameter that Color is defined at","since":"7.0","property":["get","set"]}]},{"namespace":"Rhino.Display","name":"ColorXYZ","dataType":"struct","summary":"Represents an XYZ (Hue, Saturation, Luminance) color with double precision floating point channels. XYZ colors are based on the CIE 1931 XYZ color space standard and they mimic the natural sensitivity of cones in the human retina.","constructors":[{"signature":"ColorXYZ(Color rgb)","summary":"Constructs a new instance of ColorXYZ that is equivalent to an RGB color.","since":"5.0","parameters":[{"name":"rgb","summary":"RGB color to mimic."}]},{"signature":"ColorXYZ(double x, double y, double z)","summary":"Constructs a new instance of ColorXYZ with custom channel values.","since":"5.0","parameters":[{"name":"x","summary":"X channel value, channel will be limited to 0~1."},{"name":"y","summary":"Y channel value, channel will be limited to 0~1."},{"name":"z","summary":"Z channel value, channel will be limited to 0~1."}]},{"signature":"ColorXYZ(double alpha, double x, double y, double z)","summary":"Constructs a new instance of ColorXYZ with custom channel values.","since":"5.0","parameters":[{"name":"alpha","summary":"Alpha channel value, channel will be limited to 0~1."},{"name":"x","summary":"X channel value, channel will be limited to 0~1."},{"name":"y","summary":"Y channel value, channel will be limited to 0~1."},{"name":"z","summary":"Z channel value, channel will be limited to 0~1."}]}],"properties":[{"signature":"double A","summary":"Gets or set the Alpha channel value. Channel will be limited to 0~1.","since":"5.0","property":["get","set"]},{"signature":"double X","summary":"Gets or set the X channel value. Channel will be limited to 0~1.","since":"5.0","property":["get","set"]},{"signature":"double Y","summary":"Gets or set the Y channel value. Channel will be limited to 0~1.","since":"5.0","property":["get","set"]},{"signature":"double Z","summary":"Gets or set the Z channel value. Channel will be limited to 0~1.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static ColorXYZ CreateFromCMYK(ColorCMYK cmyk)","summary":"Create the nearest XYZ equivalent of a CMYK color.","since":"5.0","parameters":[{"name":"cmyk","summary":"Target color in CMYK space."}],"returns":"The XYZ equivalent of the CMYK color."},{"signature":"static ColorXYZ CreateFromHSL(ColorHSL hsl)","summary":"Create the nearest XYZ equivalent of an HSL color.","since":"5.0","parameters":[{"name":"hsl","summary":"Target color in HSL space."}],"returns":"The XYZ equivalent of the HSL color."},{"signature":"static ColorXYZ CreateFromHSV(ColorHSV hsv)","summary":"Constructs the nearest XYZ equivalent of an HSV color.","since":"6.0","parameters":[{"name":"hsv","summary":"Target color in HSV space."}],"returns":"The XYZ equivalent of the HSV color."},{"signature":"static ColorXYZ CreateFromLAB(ColorLAB lab)","summary":"Create the nearest XYZ equivalent of a Lab color.","since":"5.0","parameters":[{"name":"lab","summary":"Target color in LAB space."}],"returns":"The XYZ equivalent of the LAB color."},{"signature":"static ColorXYZ CreateFromLCH(ColorLCH lch)","summary":"Create the nearest XYZ equivalent of an LCH color.","since":"5.0","parameters":[{"name":"lch","summary":"Target color in LCH space."}],"returns":"The XYZ equivalent of the LCH color."}]},{"namespace":"Rhino.Display","name":"CullFaceMode","dataType":"enum","since":"5.0","values":[{"signature":"DrawFrontAndBack = 0"},{"signature":"DrawFrontFaces = 1"},{"signature":"DrawBackFaces = 2"}]},{"namespace":"Rhino.Display","name":"CullObjectEventArgs","dataType":"class","baseclass":"Rhino.Display.DrawEventArgs","properties":[{"signature":"bool CullObject","since":"5.3","property":["get","set"]},{"signature":"RhinoObject RhinoObject","since":"5.3","property":["get"]},{"signature":"uint RhinoObjectSerialNumber","summary":"Gets the rhino object runtime serial number.","since":"6.14","property":["get"]}]},{"namespace":"Rhino.Display","name":"CustomDisplay","dataType":"class","summary":"Provides some basic (indeed, very basic) mechanisms for drawing custom geometry in viewports.","interfaces":["IDisposable"],"constructors":[{"signature":"CustomDisplay(bool enable)","summary":"Constructs a new CustomDisplay instance. Youmustcall Dispose() when you are done with this instance, otherwise the display methods will never be switched off.","since":"5.0","parameters":[{"name":"enable","summary":"If true, the display will be enabled immediately."}]}],"properties":[{"signature":"BoundingBox ClippingBox","summary":"Gets the clipping box of this CustomDisplay.","since":"5.0","property":["get"]},{"signature":"bool Enabled","summary":"Gets or sets the Enabled state of this CustomDisplay instance. If you wish to terminate this CustomDisplay, place a call to Dispose() instead.","since":"5.0","property":["get","set"]},{"signature":"bool IsDisposed","summary":"Gets a value indicating whether this CustomDisplay instance has been disposed. Once a CustomDisplay has been disposed, you can no longer use it.","since":"5.0","property":["get"]}],"methods":[{"signature":"void AddArc(Arc arc)","summary":"Adds a new, black arc to the display list.","since":"5.0","parameters":[{"name":"arc","summary":"Arc to add."}]},{"signature":"void AddArc(Arc arc, Color color)","summary":"Adds a new, colored arc to the display list.","since":"5.0","parameters":[{"name":"arc","summary":"Arc to add."},{"name":"color","summary":"Color of arc."}]},{"signature":"void AddArc(Arc arc, Color color, int thickness)","summary":"Adds a new, colored arc to the display list.","since":"5.0","parameters":[{"name":"arc","summary":"Arc to add."},{"name":"color","summary":"Color of arc."},{"name":"thickness","summary":"Thickness of arc."}]},{"signature":"void AddCircle(Circle circle)","summary":"Adds a new, black circle to the display list.","since":"5.0","parameters":[{"name":"circle","summary":"Circle to add."}]},{"signature":"void AddCircle(Circle circle, Color color)","summary":"Adds a new, colored arc to the display list.","since":"5.0","parameters":[{"name":"circle","summary":"Circle to add."},{"name":"color","summary":"Color of circle."}]},{"signature":"void AddCircle(Circle circle, Color color, int thickness)","summary":"Adds a new, colored circle to the display list.","since":"5.0","parameters":[{"name":"circle","summary":"Circle to add."},{"name":"color","summary":"Color of circle."},{"name":"thickness","summary":"Thickness of circle."}]},{"signature":"void AddCurve(Curve curve)","summary":"Adds a new, black curve to the display list. The curve will be duplicated so changes to the original will not affect the display.","since":"5.0","parameters":[{"name":"curve","summary":"Curve to add."}]},{"signature":"void AddCurve(Curve curve, Color color)","summary":"Adds a new, colored curve to the display list. The curve will be duplicated so changes to the original will not affect the display.","since":"5.0","parameters":[{"name":"curve","summary":"Curve to add."},{"name":"color","summary":"Color of curve."}]},{"signature":"void AddCurve(Curve curve, Color color, int thickness)","summary":"Adds a new, colored curve to the display list. The curve will be duplicated so changes to the original will not affect the display.","since":"5.0","parameters":[{"name":"curve","summary":"Curve to add."},{"name":"color","summary":"Color of curve."},{"name":"thickness","summary":"Thickness of curve."}]},{"signature":"void AddLine(Line line)","summary":"Adds a new, black line to the display list.","since":"5.0","parameters":[{"name":"line","summary":"Line to add."}]},{"signature":"void AddLine(Line line, Color color)","summary":"Adds a new, colored line to the display list.","since":"5.0","parameters":[{"name":"line","summary":"Line to add."},{"name":"color","summary":"Color of line."}]},{"signature":"void AddLine(Line line, Color color, int thickness)","summary":"Adds a new, colored line to the display list.","since":"5.0","parameters":[{"name":"line","summary":"Line to add."},{"name":"color","summary":"Color of line."},{"name":"thickness","summary":"Thickness of line."}]},{"signature":"void AddPoint(Point3d point)","summary":"Adds a new, black point to the display list.","since":"5.0","parameters":[{"name":"point","summary":"Point to add."}]},{"signature":"void AddPoint(Point3d point, Color color)","summary":"Adds a new colored point to the display list.","since":"5.0","parameters":[{"name":"point","summary":"Point to add."},{"name":"color","summary":"Color of point."}]},{"signature":"void AddPoint(Point3d point, Color color, PointStyle style, int radius)","summary":"Adds a new stylized point to the display list.","since":"5.0","parameters":[{"name":"point","summary":"Point to add."},{"name":"color","summary":"Color of point."},{"name":"style","summary":"Display style of point."},{"name":"radius","summary":"Radius of point widget."}]},{"signature":"void AddPoints(IEnumerable<Point3d> points)","summary":"Adds a collection of black points to the display list.","since":"5.0","parameters":[{"name":"points","summary":"Points to add."}]},{"signature":"void AddPoints(IEnumerable<Point3d> points, Color color)","summary":"Adds a collection of colored points to the display list.","since":"5.0","parameters":[{"name":"points","summary":"Points to add."},{"name":"color","summary":"Color of points."}]},{"signature":"void AddPoints(IEnumerable<Point3d> points, Color color, PointStyle style, int radius)","summary":"Adds a collection of stylized points to the display list.","since":"5.0","parameters":[{"name":"points","summary":"Points to add."},{"name":"color","summary":"Color of points."},{"name":"style","summary":"Display style of points."},{"name":"radius","summary":"Radius of point widgets."}]},{"signature":"void AddPolygon(IEnumerable<Point3d> polygon, Color fillColor, Color edgeColor, bool drawFill, bool drawEdge)","summary":"Adds a polygon to the drawing list. Polygons are not like Hatches, when you supply a concave polygon, the shading probably won\'t work.","since":"5.0","parameters":[{"name":"polygon","summary":"Points that define the corners of the polygon."},{"name":"fillColor","summary":"Fill color of polygon."},{"name":"edgeColor","summary":"Edge color of polygon."},{"name":"drawFill","summary":"If true, the polygon contents will be drawn."},{"name":"drawEdge","summary":"If true, the polygon edge will be drawn."}]},{"signature":"void AddText(string text, Plane plane, double size)","summary":"Adds a new, black 3D text object to the display list.","since":"5.0","parameters":[{"name":"text","summary":"Text to add."},{"name":"plane","summary":"Plane for text orientation."},{"name":"size","summary":"Height (in units) of font."}]},{"signature":"void AddText(string text, Plane plane, double size, Color color)","summary":"Adds a new, colored 3D text object to the display list.","since":"5.0","parameters":[{"name":"text","summary":"Text to add."},{"name":"plane","summary":"Plane for text orientation."},{"name":"size","summary":"Height (in units) of font."},{"name":"color","summary":"Color of text."}]},{"signature":"void AddText(Text3d text, Color color)","summary":"Adds a new 3D text object to the display list.","since":"5.0","parameters":[{"name":"text","summary":"Text object to add."},{"name":"color","summary":"Color of text object."}]},{"signature":"void AddVector(Point3d anchor, Vector3d span)","summary":"Adds a new, black vector to the display list.","since":"5.0","parameters":[{"name":"anchor","summary":"Anchor point of vector."},{"name":"span","summary":"Direction and magnitude of vector."}]},{"signature":"void AddVector(Point3d anchor, Vector3d span, Color color)","summary":"Adds a new, colored vector to the display list.","since":"5.0","parameters":[{"name":"anchor","summary":"Anchor point of vector."},{"name":"span","summary":"Direction and magnitude of vector."},{"name":"color","summary":"Color of vector."}]},{"signature":"void AddVector(Point3d anchor, Vector3d span, Color color, bool drawAnchor)","summary":"Adds a new, colored vector to the display list.","since":"5.0","parameters":[{"name":"anchor","summary":"Anchor point of vector."},{"name":"span","summary":"Direction and magnitude of vector."},{"name":"color","summary":"Color of vector."},{"name":"drawAnchor","summary":"Include a point at the vector anchor."}]},{"signature":"void Clear()","summary":"Clear the drawing lists.","since":"5.0"},{"signature":"void Dispose()","summary":"Dispose this CustomDisplay instance. You must call this function in order to properly shut down the CustomDisplay.","since":"5.0"}]},{"namespace":"Rhino.Display","name":"DefinedViewportProjection","dataType":"enum","summary":"Parallel and perspective projections that are \\"standard\\" in Rhino","since":"5.0","values":[{"signature":"None = 0"},{"signature":"Top = 1"},{"signature":"Bottom = 2"},{"signature":"Left = 3"},{"signature":"Right = 4"},{"signature":"Front = 5"},{"signature":"Back = 6"},{"signature":"Perspective = 7"},{"signature":"TwoPointPerspective = 8"}]},{"namespace":"Rhino.Display","name":"DepthMode","dataType":"enum","since":"5.0","values":[{"signature":"Neutral = 0"},{"signature":"AlwaysInFront = 1"},{"signature":"AlwaysInBack = 2"}]},{"namespace":"Rhino.Display","name":"DisplayBitmap","dataType":"class","summary":"A bitmap resource that can be used by the display pipeline (currently only in OpenGL display).  Reuse DisplayBitmaps for drawing if possible; it is much more expensive to construct new DisplayBitmaps than it is to reuse existing DisplayBitmaps.","interfaces":["IDisposable"],"constructors":[{"signature":"DisplayBitmap(Bitmap bitmap)","summary":"Constructs a DisplayBitmap from an existing bitmap.","since":"5.0","parameters":[{"name":"bitmap","summary":"The original bitmap."}]}],"properties":[{"signature":"Size Size","summary":"Size of the underlying bitmap image","since":"7.0","property":["get"]}],"methods":[{"signature":"static DisplayBitmap Load(string path)","summary":"Load a DisplayBitmap from and image file on disk or from URL. If path starts with http:// or https:// then an attempt is made to load the bitmap from an online resource","since":"5.0","parameters":[{"name":"path","summary":"A location from which to load the file."}],"returns":"The new display bitmap, or None on error."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"void GetBlendModes(out BlendMode source, out BlendMode destination)","summary":"Gets the source and destination blend modes.","since":"5.0","parameters":[{"name":"source","summary":"The source blend mode is assigned to this out parameter."},{"name":"destination","summary":"The destination blend mode is assigned to this out parameter."}]},{"signature":"void SetBlendFunction(BlendMode source, BlendMode destination)","summary":"Sets blending function used to determine how this bitmap is blended with the current frame buffer color.  The default setting is SourceAlpha for source and OneMinusSourceAlpha for destination.  See OpenGL\'s glBlendFunc for details.  \\nhttp://www.opengl.org/sdk/docs/man/xhtml/glBlendFunc.xml","since":"5.0","parameters":[{"name":"source","summary":"The source blend mode."},{"name":"destination","summary":"The destination blend mode."}]}]},{"namespace":"Rhino.Display","name":"DisplayBitmapDrawList","dataType":"class","constructors":[{"signature":"DisplayBitmapDrawList()","since":"5.0"}],"properties":[{"signature":"BoundingBox BoundingBox","since":"5.0","property":["get"]},{"signature":"int MaximumCachedSortLists","summary":"Maximum number of cached sort order index lists stored on this class. Default is 10, but depending on the number of points in this list you may get better performance by setting this value to a certain percentage of the point count.","since":"5.0","property":["get","set"]},{"signature":"double SortAngleTolerance","summary":"Angle in radians used to determine if an index list is \\"parallel enough\\" to a viewports camera angle. Default is 0.0873 radians (5 degrees)","since":"5.0","property":["get","set"]}],"methods":[{"signature":"void SetPoints(IEnumerable<Point3d> points)","since":"5.0"},{"signature":"void SetPoints(IEnumerable<Point3d> points, Color blendColor)","since":"5.0"},{"signature":"void SetPoints(IEnumerable<Point3d> points, IEnumerable<Color> colors)","since":"5.0"},{"signature":"int[] Sort(Vector3d cameraDirection)","since":"5.0"}]},{"namespace":"Rhino.Display","name":"DisplayConduit","dataType":"class","properties":[{"signature":"bool Enabled","since":"5.0","property":["get","set"]},{"signature":"ObjectType GeometryFilter","summary":"The geometry filter will ensure that your conduit\'s per-object functions will only be called for objects that are of certain geometry type","since":"7.0","property":["get","set"]},{"signature":"ActiveSpace SpaceFilter","summary":"If you want this conduit to only work in a specific space (model or page), then set this filter to that specific space. The default is None meaning no filter is applied","since":"6.0","property":["get","set"]}],"methods":[{"signature":"void GetSelectionFilter(out bool on, out bool checkSubObjects)","summary":"The selection filter will make per-object conduit functions only be called for selected objects (when the filter is turned on)","since":"7.0"},{"signature":"void SetObjectIdFilter(Guid id)","summary":"Set an object Id that this conduit\'s per-object functions will only be called for","since":"7.0"},{"signature":"void SetObjectIdFilter(IEnumerable<Guid> ids)","summary":"Set object Ids that this conduit\'s per-object functions will only be called for","since":"7.0"},{"signature":"void SetSelectionFilter(bool on, bool checkSubObjects)","summary":"The selection filter will make per-object conduit functions only be called for selected objects (when the filter is turned on)","since":"7.0"}]},{"namespace":"Rhino.Display","name":"DisplayEngine","dataType":"class","interfaces":["IDisposable"],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"}]},{"namespace":"Rhino.Display","name":"DisplayMaterial","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"DisplayMaterial()","summary":"Constructs a default material.","since":"5.0"},{"signature":"DisplayMaterial(Color diffuse)","summary":"Constructs a default material with a specific diffuse color.","since":"5.0","parameters":[{"name":"diffuse","summary":"Diffuse color of material. The alpha component of the Diffuse color is ignored."}]},{"signature":"DisplayMaterial(Color diffuse, Color specular, Color ambient, Color emission, double shine, double transparency)","summary":"Constructs a material with custom properties.","since":"5.0","parameters":[{"name":"diffuse","summary":"Diffuse color of material. The alpha component of the Diffuse color is ignored."},{"name":"specular","summary":"Specular color of material. The alpha component of the Specular color is ignored."},{"name":"ambient","summary":"Ambient color of material. The alpha component of the Ambient color is ignored."},{"name":"emission","summary":"Emission color of material. The alpha component of the Emission color is ignored."},{"name":"shine","summary":"Shine (highlight size) of material."},{"name":"transparency","summary":"Transparency of material (0.0 = opaque, 1.0 = transparent)"}]},{"signature":"DisplayMaterial(Color diffuse, double transparency)","summary":"Constructs a default material with a specific diffuse color and transparency.","since":"5.0","parameters":[{"name":"diffuse","summary":"Diffuse color of material. The alpha component of the Diffuse color is ignored."},{"name":"transparency","summary":"Transparency factor (0.0 = opaque, 1.0 = transparent)"}]},{"signature":"DisplayMaterial(DisplayMaterial other)","summary":"Duplicate another material.","since":"5.0"},{"signature":"DisplayMaterial(Material material)","since":"5.0"}],"properties":[{"signature":"Color Ambient","summary":"Gets or sets the Ambient color of the Material. The alpha component of the color will be ignored.","since":"5.0","property":["get","set"]},{"signature":"Color BackAmbient","summary":"Gets or sets the Ambient color of the back side of the Material. The alpha component of the color will be ignored.","since":"5.0","property":["get","set"]},{"signature":"Color BackDiffuse","summary":"Gets or sets the Diffuse color of the back side of the Material. The alpha component of the color will be ignored.","since":"5.0","property":["get","set"]},{"signature":"Color BackEmission","summary":"Gets or sets the Emissive color of the back side of the Material. The alpha component of the color will be ignored.","since":"5.0","property":["get","set"]},{"signature":"double BackShine","summary":"Gets or sets the shine factor of the back side of the material (0.0 to 1.0)","since":"5.0","property":["get","set"]},{"signature":"Color BackSpecular","summary":"Gets or sets the Specular color of the back side of the Material. The alpha component of the color will be ignored.","since":"5.0","property":["get","set"]},{"signature":"double BackTransparency","summary":"Gets or sets the transparency of the back side material (0.0 = opaque to 1.0 = transparent)","since":"5.0","property":["get","set"]},{"signature":"Color Diffuse","summary":"Gets or sets the Diffuse color of the Material. The alpha component of the color will be ignored.","since":"5.0","property":["get","set"]},{"signature":"Color Emission","summary":"Gets or sets the Emissive color of the Material. The alpha component of the color will be ignored.","since":"5.0","property":["get","set"]},{"signature":"bool IsTwoSided","since":"5.0","property":["get","set"]},{"signature":"double Shine","summary":"Gets or sets the shine factor of the material (0.0 to 1.0)","since":"5.0","property":["get","set"]},{"signature":"Color Specular","summary":"Gets or sets the Specular color of the Material. The alpha component of the color will be ignored.","since":"5.0","property":["get","set"]},{"signature":"double Transparency","summary":"Gets or sets the transparency of the material (0.0 = opaque to 1.0 = transparent)","since":"5.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","since":"5.0"},{"signature":"Rhino.DocObjects.Texture GetBitmapTexture(bool front)","since":"5.0"},{"signature":"Rhino.DocObjects.Texture GetBumpTexture(bool front)","summary":"Gets the bump texture for this display material.","since":"5.0","returns":"The texture, or None if no bump texture has been added to this material."},{"signature":"Rhino.DocObjects.Texture GetEnvironmentTexture(bool front)","since":"5.0"},{"signature":"Rhino.DocObjects.Texture GetTransparencyTexture(bool front)","since":"5.0"},{"signature":"bool SetBitmapTexture(string filename, bool front)","since":"5.0"},{"signature":"bool SetBitmapTexture(Texture texture, bool front)","since":"5.0"},{"signature":"bool SetBumpTexture(string filename, bool front)","since":"5.0"},{"signature":"bool SetBumpTexture(Texture texture, bool front)","since":"5.0"},{"signature":"bool SetEnvironmentTexture(string filename, bool front)","since":"5.0"},{"signature":"bool SetEnvironmentTexture(Texture texture, bool front)","since":"5.0"},{"signature":"bool SetTransparencyTexture(string filename, bool front)","since":"5.0"},{"signature":"bool SetTransparencyTexture(Texture texture, bool front)","since":"5.0"}]},{"namespace":"Rhino.Display","name":"DisplayModeChangedEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"Guid ChangedDisplayModeId","since":"6.18","property":["get"]},{"signature":"Guid OldDisplayModeId","since":"6.18","property":["get"]},{"signature":"RhinoDoc RhinoDoc","since":"6.18","property":["get"]},{"signature":"RhinoViewport Viewport","since":"6.18","property":["get"]}]},{"namespace":"Rhino.Display","name":"DisplayModeDescription","dataType":"class","summary":"Description of a how Rhino will display in a viewport. These are the modes that are listed under \\"Advanced display\\" in the options dialog.","interfaces":["IDisposable","ISerializable"],"properties":[{"signature":"static Guid AmbientOcclusionId","since":"6.0","property":["get"]},{"signature":"static Guid ArtisticId","since":"6.26","property":["get"]},{"signature":"static Guid GhostedId","since":"6.0","property":["get"]},{"signature":"static Guid PenId","since":"6.0","property":["get"]},{"signature":"static Guid RaytracedId","since":"6.0","property":["get"]},{"signature":"static Guid RenderedId","since":"6.0","property":["get"]},{"signature":"static Guid RenderedShadowsId","since":"6.0","property":["get"]},{"signature":"static Guid ShadedId","since":"6.0","property":["get"]},{"signature":"static Guid TechId","since":"6.0","property":["get"]},{"signature":"static Guid WireframeId","since":"6.0","property":["get"]},{"signature":"static Guid XRayId","since":"6.0","property":["get"]},{"signature":"bool AllowObjectAssignment","since":"5.0","property":["get","set"]},{"signature":"DisplayPipelineAttributes DisplayAttributes","since":"5.0","property":["get"]},{"signature":"string EnglishName","since":"5.0","property":["get","set"]},{"signature":"Guid Id","since":"5.0","property":["get"]},{"signature":"bool InMenu","since":"5.0","property":["get","set"]},{"signature":"string LocalName","since":"5.0","property":["get"]},{"signature":"bool PipelineLocked","since":"5.0","property":["get","set"]},{"signature":"bool ShadedPipelineRequired","since":"5.0","property":["get","set"]},{"signature":"bool SupportsShadeCommand","since":"5.0","property":["get","set"]},{"signature":"bool SupportsShading","since":"5.0","property":["get","set"]},{"signature":"bool WireframePipelineRequired","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static Guid AddDisplayMode(DisplayModeDescription displayMode)","since":"5.0"},{"signature":"static Guid AddDisplayMode(string name)","summary":"Adds a new display mode.","since":"6.7","parameters":[{"name":"name","summary":"The name of the new display mode."}],"returns":"The id of the new display mode if successful. Guid.Empty on error."},{"signature":"static Guid CopyDisplayMode(Guid id, string name)","summary":"Copies an existing display mode.","since":"6.7","parameters":[{"name":"id","summary":"The id of the existing display mode to copy."},{"name":"name","summary":"The name of the new display mode."}],"returns":"The id of the new display mode if successful. Guid.Empty on error."},{"signature":"static bool DeleteDiplayMode(Guid id)","summary":"Deletes an existing display mode.","since":"5.0","deprecated":"7.0","parameters":[{"name":"id","summary":"The id of the existing display mode to delete."}],"returns":"True if successful, False otherwise."},{"signature":"static bool DeleteDisplayMode(Guid id)","summary":"Deletes an existing display mode.","since":"7.0","parameters":[{"name":"id","summary":"The id of the existing display mode to delete."}],"returns":"True if successful, False otherwise."},{"signature":"static bool ExportToFile(DisplayModeDescription displayMode, string filename)","summary":"Exports a DisplayModeDescription to a Windows-style .ini file.","since":"6.0","parameters":[{"name":"displayMode","summary":"The DisplayModeDescription to export."},{"name":"filename","summary":"The name of the file to create."}]},{"signature":"static DisplayModeDescription FindByName(string englishName)","since":"5.0"},{"signature":"static DisplayModeDescription GetDisplayMode(Guid id)","since":"5.0"},{"signature":"static DisplayModeDescription[] GetDisplayModes()","summary":"Gets all display mode descriptions that Rhino currently knows about.","since":"5.0","returns":"Copies of all of the display mode descriptions. If you want to modify these descriptions, you must call UpdateDisplayMode or AddDisplayMode."},{"signature":"static Guid ImportFromFile(string filename)","summary":"Imports a DisplayModeDescription from a Windows-style .ini file.","since":"6.0","parameters":[{"name":"filename","summary":"The name of the file to import."}],"returns":"The id of the DisplayModeDescription if successful."},{"signature":"static bool UpdateDisplayMode(DisplayModeDescription displayMode)","since":"5.0"},{"signature":"void Dispose()","since":"5.0"}]},{"namespace":"Rhino.Display","name":"DisplayPipeline","dataType":"class","summary":"The display pipeline calls events during specific phases of drawing During the drawing of a single frame the events are called in the following order.  [Begin Drawing of a Frame] CalculateBoundingBoxCalculateClippingPanesSetupFrustumSetupLightingInitializeFrameBufferDrawBackgroundIf this is a layout and detail objects exist the channels are called in the same order for each detail object (drawn as a nested viewport)PreDrawObjectsFor Each Visible Non Highlighted ObjectSetupObjectDisplayAttributesPreDrawObjectDrawObjectPostDrawObjectPostDrawObjects - depth writing/testing onDrawForeGround - depth writing/testing offFor Each Visible Highlighted ObjectSetupObjectDisplayAttributesPreDrawObjectDrawObjectPostDrawObjectPostProcessFrameBuffer (If a delegate exists that requires this)DrawOverlay (if Rhino is in a feedback mode) [End of Drawing of a Frame]  \\nNOTE: There may be multiple DrawObject calls for a single object. An example of when this could happen would be with a shaded sphere. The shaded mesh is first drawn and these channels would be processed; then at a later time the isocurves for the sphere would be drawn.","properties":[{"signature":"RhinoObject ActiveObject","since":"6.7","property":["get"]},{"signature":"int ActiveObjectNestingLevel","since":"6.7","property":["get"]},{"signature":"RhinoObject[] ActiveObjectNestingStack","since":"6.7","property":["get"]},{"signature":"RhinoObject ActiveTopLevelObject","since":"6.7","property":["get"]},{"signature":"int DefaultCurveThickness","summary":"Gets the curve thickness as defined by the current display mode. Note: this only applies to curve objects, Brep and Mesh wires may have different settings.","since":"5.0","property":["get"]},{"signature":"DepthMode DepthMode","since":"5.0","property":["get","set"]},{"signature":"DisplayPipelineAttributes DisplayPipelineAttributes","since":"5.3","property":["get"]},{"signature":"float DpiScale","summary":"Scale factor used for high resolution displays. When a monitor that this pipeline is drawing to is at a DPI of 96, this value is one. On high DPI monitors, this value will commonly be greater than one.","since":"6.0","property":["get"]},{"signature":"bool DrawingGrips","summary":"Gets a value that indicates whether the pipeline is currently in a grip drawing operation.","since":"5.0","property":["get"]},{"signature":"bool DrawingSurfaces","summary":"Gets a value that indicates whether the pipeline is currently in a surface drawing operation.  Surface drawing means draw the shaded triangles of a mesh representing the surface (mesh, extrusion, or brep).  This is useful when inside of a draw event or display conduit to check and see if the geometry is about to be drawn as a shaded set of triangles representing the geometry. See DrawingWires to check and see if the wireframe representation of the geometry is going to be drawn.","since":"5.0","property":["get"]},{"signature":"bool DrawingWires","summary":"Gets a value that indicates whether the pipeline is currently in a curve drawing operation. This is useful when inside of a draw event or display conduit to check and see if the geometry is about to be drawn is going to be drawing the wire representation of the geometry (mesh, extrusion, or brep).  See DrawingSurfaces to check and see if the shaded mesh representation of the geometry is going to be drawn.","since":"5.0","property":["get"]},{"signature":"Bitmap FrameBuffer","summary":"Gets the contents of the frame buffer that this pipeline is drawing to.","since":"6.0","property":["get"]},{"signature":"Size FrameSize","summary":"Gets the size of the frame buffer that this pipeline is drawing to.","since":"5.0","property":["get"]},{"signature":"bool IsDynamicDisplay","summary":"Gets a value that indicates whether the viewport is in Dynamic Display state. Dynamic display is the state a viewport is in when it is rapidly redrawing because of an operation like panning or rotating. The pipeline will drop some level of detail while inside a dynamic display state to keep the frame rate as high as possible.","since":"5.0","property":["get"]},{"signature":"bool IsInViewCapture","summary":"Gets a value that indicates whether this pipeline is currently drawing for ViewCaptureToFile or ViewCaptureToClipboard","since":"6.0","property":["get"]},{"signature":"bool IsOpen","summary":"Is True of the pipeline is open, False otherwise.","since":"7.0","property":["get"]},{"signature":"bool IsOpenGL","summary":"Gets a value indicating whether or not this pipeline is drawing into an OpenGL context.","since":"5.0","property":["get"]},{"signature":"bool IsPrinting","summary":"Gets a value that indicates whether this pipeline is currently drawing for printing purposes.","since":"5.0","property":["get"]},{"signature":"bool IsStereoMode","summary":"Gets a value that indicates whether this pipeline is currently using an engine that is performing stereo style drawing. Stereo drawing is for providing an \\"enhanced 3-D\\" effect through stereo viewing devices.","since":"5.0","property":["get"]},{"signature":"Transform ModelTransform","summary":"Gets or sets the current model transformation that is applied to vertices when drawing.","since":"5.0","property":["get","set"]},{"signature":"bool ModelTransformIsIdentity","summary":"Gets a value that indicates whether the Model Transform is an Identity transformation.","since":"5.0","property":["get"]},{"signature":"int NestLevel","summary":"Gets the current nested viewport drawing level. This is used to know if you are currently inside the drawing of a nested viewport (detail object in Rhino).  \\nNest level = 0 Drawing is occurring in a standard Rhino viewport or on the page viewport.  \\nNest level = 1 Drawing is occurring inside a detail view object.","since":"5.0","property":["get"]},{"signature":"int RenderPass","summary":"Gets the current pass that the pipeline is in for drawing a frame. Typically drawing a frame requires a single pass through the DrawFrameBuffer function, but some special display effects can be achieved through drawing with multiple passes.","since":"5.0","property":["get"]},{"signature":"bool ShadingRequired","summary":"Gets or sets the \\"ShadingRequired\\" flag. This flag gets set inside the pipeline when a request is made to draw a shaded mesh but the current render engine doesn\'t support shaded mesh drawing...at this point the redraw mechanism will make sure everything will work the next time around.","since":"5.0","property":["get","set"]},{"signature":"int StereoProjection","summary":"Gets the current stereo projection if stereo mode is on.  \\n0 = left  \\n1 = right If stereo mode is not enables, this property always returns 0.","since":"5.0","property":["get"]},{"signature":"bool SupportsShading","summary":"Gets whether or not this pipeline supports shaded meshes.","since":"5.0","property":["get"]},{"signature":"RhinoViewport Viewport","since":"5.0","property":["get"]},{"signature":"ZBiasMode ZBiasMode","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static uint AvailableOpenGLVersion(out bool coreProfile)","summary":"If Rhino is using OpenGL for display, this function will return major.minor version of OpenGL available for this instance of Rhino","since":"6.21","parameters":[{"name":"coreProfile","summary":"If true, OpenGL is being used in \\"core profile\\" mode"}],"returns":"major version * 10 + minor version For example, OpenGL 4.5 returns 45"},{"signature":"static bool CullControlPolygon()","summary":"Returns a value indicating if only points on the side of the surface that face the camera are displayed.","since":"5.0","returns":"True if back faces of surface and mesh control polygons are culled. This value is determined by the _CullControlPolygon command."},{"signature":"static System.Drawing.Bitmap DrawToBitmap(RhinoViewport viewport, int width, int height)","summary":"Draw a given viewport to an off-screen bitmap.","since":"5.0","parameters":[{"name":"viewport","summary":"Viewport to draw."},{"name":"width","summary":"Width of target image."},{"name":"height","summary":"Height of target image."}],"returns":"A bitmap containing the given view, or None on error."},{"signature":"static void GetDrawListSerialNumbers(out uint modelSerialNumber, out uint pageSerialNumber)","summary":"Gets the current model and page view draw list serial numbers, which can be used to determine if a model or page view needs to be redrawn.","since":"7.0","parameters":[{"name":"modelSerialNumber","summary":"The current model draw list serial number."},{"name":"pageSerialNumber","summary":"The current page view draw list serial number."}]},{"signature":"static bool MakeDefaultOpenGLContextCurrent()","summary":"Make a \\"default\\" OpenGL context current","since":"7.0"},{"signature":"int AddClippingPlane(Point3d point, Vector3d normal)","summary":"Add a clipping plane to be used during the drawing of this frame","since":"6.3","parameters":[{"name":"point","summary":"point on the plane"},{"name":"normal","summary":"vector perpendicular to the plane"}],"returns":"index for the added clipping plane"},{"signature":"DisplayPipeline Clone(RhinoViewport viewport)","summary":"Clones the pipeline. Creates an identical copy of \\"this\\" pipeline. Copies all conduits from \\"this\\" pipeline to the new pipeline.","since":"7.0","returns":"The newly cloned pipeline if successful, None otherwise. or failed to close."},{"signature":"bool Close()","summary":"Closes the pipeline.","since":"7.0","returns":"True if the pipeline was closed, False if it was already closed or failed to close."},{"signature":"void Draw2dLine(Point from, Point to, Color color, float thickness)","since":"6.0"},{"signature":"void Draw2dLine(PointF from, PointF to, Color color, float thickness)","since":"6.0"},{"signature":"void Draw2dRectangle(Rectangle rectangle, Color strokeColor, int thickness, Color fillColor)","since":"5.10"},{"signature":"void Draw2dText(string text, Color color, Point2d screenCoordinate, bool middleJustified)","summary":"Draws 2D text on the viewport.","since":"5.0","parameters":[{"name":"text","summary":"the string to draw."},{"name":"color","summary":"text color."},{"name":"screenCoordinate","summary":"definition point in screen coordinates (0,0 is top-left corner)"},{"name":"middleJustified","summary":"if True text is centered around the definition point, otherwise it is lower-left justified."}]},{"signature":"void Draw2dText(string text, Color color, Point2d screenCoordinate, bool middleJustified, int height)","summary":"Draws 2D text on the viewport.","since":"5.0","parameters":[{"name":"text","summary":"the string to draw."},{"name":"color","summary":"text color."},{"name":"screenCoordinate","summary":"definition point in screen coordinates (0,0 is top-left corner)"},{"name":"middleJustified","summary":"if True text is centered around the definition point, otherwise it is lower-left justified."},{"name":"height","summary":"height in pixels (good default is 12)"}]},{"signature":"void Draw2dText(string text, Color color, Point2d screenCoordinate, bool middleJustified, int height, string fontface)","summary":"Draws 2D text on the viewport.","since":"5.0","parameters":[{"name":"text","summary":"the string to draw."},{"name":"color","summary":"text color."},{"name":"screenCoordinate","summary":"definition point in screen coordinates (0,0 is top-left corner)"},{"name":"middleJustified","summary":"if True text is centered around the definition point, otherwise it is lower-left justified."},{"name":"height","summary":"height in pixels (good default is 12)"},{"name":"fontface","summary":"font name (good default is \\"Arial\\")"}]},{"signature":"void Draw2dText(string text, Color color, Point3d worldCoordinate, bool middleJustified)","summary":"Draws 2D text on the viewport.","since":"5.0","parameters":[{"name":"text","summary":"the string to draw."},{"name":"color","summary":"text color."},{"name":"worldCoordinate","summary":"definition point in world coordinates."},{"name":"middleJustified","summary":"if True text is centered around the definition point, otherwise it is lower-left justified."}]},{"signature":"void Draw2dText(string text, Color color, Point3d worldCoordinate, bool middleJustified, int height)","summary":"Draws 2D text on the viewport.","since":"5.0","parameters":[{"name":"text","summary":"the string to draw."},{"name":"color","summary":"text color."},{"name":"worldCoordinate","summary":"definition point in world coordinates."},{"name":"middleJustified","summary":"if True text is centered around the definition point, otherwise it is lower-left justified."},{"name":"height","summary":"height in pixels (good default is 12)"}]},{"signature":"void Draw2dText(string text, Color color, Point3d worldCoordinate, bool middleJustified, int height, string fontface)","summary":"Draws 2D text on the viewport.","since":"5.0","parameters":[{"name":"text","summary":"The string to draw."},{"name":"color","summary":"Text color."},{"name":"worldCoordinate","summary":"Definition point in world coordinates."},{"name":"middleJustified","summary":"If True text is centered around the definition point, otherwise it is lower-left justified."},{"name":"height","summary":"Height in pixels (good default is 12)."},{"name":"fontface","summary":"Font name (good default is \\"Arial\\")."}]},{"signature":"void Draw3dText(string text, Color color, Plane textPlane, double height, string fontface)","since":"5.0"},{"signature":"void Draw3dText(string text, Color color, Plane textPlane, double height, string fontface, bool bold, bool italic)","since":"6.0"},{"signature":"void Draw3dText(string text, Color color, Plane textPlane, double height, string fontface, bool bold, bool italic, TextHorizontalAlignment horizontalAlignment, TextVerticalAlignment verticalAlignment)","since":"6.4"},{"signature":"void Draw3dText(Text3d text, Color color)","since":"5.0"},{"signature":"void Draw3dText(Text3d text, Color color, Plane textPlane)","summary":"Draws 3d text with a different plane than what is defined in the Text3d class.","since":"5.0","parameters":[{"name":"text","summary":"The string to draw."},{"name":"color","summary":"Text color."},{"name":"textPlane","summary":"The plane for the text object."}]},{"signature":"void Draw3dText(Text3d text, Color color, Point3d textPlaneOrigin)","summary":"Draws 3d text using the Text3d plane with an adjusted origin.","since":"5.0","parameters":[{"name":"text","summary":"The string to draw."},{"name":"color","summary":"Text color."},{"name":"textPlaneOrigin","summary":"The origin of the plane to draw."}]},{"signature":"void DrawActivePoint(Point3d point)","summary":"Draws a point in style used during \\"GetPoint\\" operations","since":"6.0","parameters":[{"name":"point","summary":"Location of the point in world coordinates"}]},{"signature":"void DrawAnnotation(AnnotationBase annotation, Color color)","since":"6.0"},{"signature":"void DrawAnnotationArrowhead(Arrowhead arrowhead, Transform xform, Color color)","since":"6.0"},{"signature":"void DrawArc(Arc arc, Color color)","summary":"Draw a single arc object.","since":"5.0","parameters":[{"name":"arc","summary":"Arc to draw."},{"name":"color","summary":"Color to draw with."}]},{"signature":"void DrawArc(Arc arc, Color color, int thickness)","summary":"Draw a single arc object.","since":"5.0","parameters":[{"name":"arc","summary":"Arc to draw."},{"name":"color","summary":"Color to draw with."},{"name":"thickness","summary":"Thickness (in pixels) of arc."}]},{"signature":"void DrawArrow(Line line, Color color)","summary":"Draws a single arrow object. An arrow consists of a Shaft and an Arrow head at the end of the shaft.","since":"5.0","parameters":[{"name":"line","summary":"Arrow shaft."},{"name":"color","summary":"Color of arrow."}]},{"signature":"void DrawArrow(Line line, Color color, double screenSize, double relativeSize)","summary":"Draws a single arrow object. An arrow consists of a Shaft and an Arrow head at the end of the shaft.","since":"5.0","parameters":[{"name":"line","summary":"Arrow shaft."},{"name":"color","summary":"Color of arrow."},{"name":"screenSize","summary":"If screenSize != 0.0 then the size (in screen pixels) of the arrow head will be equal to screenSize."},{"name":"relativeSize","summary":"If relativeSize != 0.0 and screen size == 0.0 the size of the arrow head will be proportional to the arrow shaft length."}]},{"signature":"void DrawArrowHead(Point3d tip, Vector3d direction, Color color, double screenSize, double worldSize)","summary":"Draws a single arrow head.","since":"5.0","parameters":[{"name":"tip","summary":"Point of arrow head tip."},{"name":"direction","summary":"Direction in which arrow head is pointing."},{"name":"color","summary":"Color of arrow head."},{"name":"screenSize","summary":"If screenSize != 0.0, then the size (in screen pixels) of the arrow head will be equal to the screenSize."},{"name":"worldSize","summary":"If worldSize != 0.0 and screen size == 0.0 the size of the arrow head will be equal to the number of units in worldSize."}]},{"signature":"void DrawArrows(IEnumerable<Line> lines, Color color)","summary":"Draws a collection of arrow objects. An arrow consists of a Shaft and an Arrow head at the end of the shaft.","since":"5.0","parameters":[{"name":"lines","summary":"Arrow shafts."},{"name":"color","summary":"Color of arrows."}]},{"signature":"void DrawArrows(Line[] lines, Color color)","summary":"Draws a collection of arrow objects. An arrow consists of a Shaft and an Arrow head at the end of the shaft.","since":"5.0","parameters":[{"name":"lines","summary":"Arrow shafts."},{"name":"color","summary":"Color of arrows."}]},{"signature":"void DrawBitmap(DisplayBitmap bitmap, int left, int top)","summary":"Draws a bitmap in screen coordinates","since":"5.10","parameters":[{"name":"bitmap","summary":"bitmap to draw"},{"name":"left","summary":"where top/left corner of bitmap should appear in screen coordinates"},{"name":"top","summary":"where top/left corner of bitmap should appear in screen coordinates"}]},{"signature":"void DrawBox(BoundingBox box, Color color)","summary":"Draws the edges of a BoundingBox.","since":"5.0","parameters":[{"name":"box","summary":"Box to draw."},{"name":"color","summary":"Color to draw in."}]},{"signature":"void DrawBox(BoundingBox box, Color color, int thickness)","summary":"Draws the edges of a BoundingBox.","since":"5.0","parameters":[{"name":"box","summary":"Box to draw."},{"name":"color","summary":"Color to draw in."},{"name":"thickness","summary":"Thickness (in pixels) of box edges."}]},{"signature":"void DrawBox(Box box, Color color)","summary":"Draws the edges of a Box object.","since":"5.0","parameters":[{"name":"box","summary":"Box to draw."},{"name":"color","summary":"Color to draw in."}]},{"signature":"void DrawBox(Box box, Color color, int thickness)","summary":"Draws the edges of a Box object.","since":"5.0","parameters":[{"name":"box","summary":"Box to draw."},{"name":"color","summary":"Color to draw in."},{"name":"thickness","summary":"Thickness (in pixels) of box edges."}]},{"signature":"void DrawBoxCorners(BoundingBox box, Color color)","summary":"Draws corner widgets of a world aligned bounding box. Widget size will be 5% of the Box diagonal.","since":"5.0","parameters":[{"name":"box","summary":"Box to draw."},{"name":"color","summary":"Color to draw with."}]},{"signature":"void DrawBoxCorners(BoundingBox box, Color color, double size)","summary":"Draws corner widgets of a world aligned bounding box.","since":"5.0","parameters":[{"name":"box","summary":"Box to draw."},{"name":"color","summary":"Color to draw with."},{"name":"size","summary":"Size (in model units) of the corner widgets."}]},{"signature":"void DrawBoxCorners(BoundingBox box, Color color, double size, int thickness)","summary":"Draws corner widgets of a world aligned bounding box.","since":"5.0","parameters":[{"name":"box","summary":"Box to draw."},{"name":"color","summary":"Color to draw with."},{"name":"size","summary":"Size (in model units) of the corner widgets."},{"name":"thickness","summary":"Thickness (in pixels) of the corner widgets."}]},{"signature":"void DrawBrepShaded(Brep brep, DisplayMaterial material)","summary":"Draws a shaded mesh representation of a brep.","since":"5.0","parameters":[{"name":"brep","summary":"Brep to draw."},{"name":"material","summary":"Material to draw faces with."}]},{"signature":"void DrawBrepWires(Brep brep, Color color)","summary":"Draws all the wireframe curves of a brep object.","since":"5.0","parameters":[{"name":"brep","summary":"Brep to draw."},{"name":"color","summary":"Color of Wireframe curves."}]},{"signature":"void DrawBrepWires(Brep brep, Color color, int wireDensity)","summary":"Draws all the wireframe curves of a brep object.","since":"5.0","parameters":[{"name":"brep","summary":"Brep to draw."},{"name":"color","summary":"Color of Wireframe curves."},{"name":"wireDensity","summary":"\\"Density\\" of wireframe curves.  \\n-1 = no internal wires.  \\n0 = default internal wires.  \\n>0 = custom high density."}]},{"signature":"void DrawCircle(Circle circle, Color color)","summary":"Draw a single circle object.","since":"5.0","parameters":[{"name":"circle","summary":"Circle to draw."},{"name":"color","summary":"Color to draw with."}]},{"signature":"void DrawCircle(Circle circle, Color color, int thickness)","summary":"Draw a single circle object.","since":"5.0","parameters":[{"name":"circle","summary":"Circle to draw."},{"name":"color","summary":"Color to draw with."},{"name":"thickness","summary":"Thickness (in pixels) of circle."}]},{"signature":"void DrawCone(Cone cone, Color color)","summary":"Draw a wireframe cone.","since":"5.0","parameters":[{"name":"cone","summary":"Cone to draw."},{"name":"color","summary":"Color to draw with."}]},{"signature":"void DrawCone(Cone cone, Color color, int thickness)","summary":"Draw a wireframe cone.","since":"5.0","parameters":[{"name":"cone","summary":"Cone to draw."},{"name":"color","summary":"Color to draw with."},{"name":"thickness","summary":"Thickness (in pixels) of Cone wires."}]},{"signature":"void DrawConstructionPlane(ConstructionPlane constructionPlane)","since":"5.0"},{"signature":"void DrawCurvatureGraph(Curve curve, Color color)","summary":"Draw a typical Rhino Curvature Graph.","since":"5.0","parameters":[{"name":"curve","summary":"Base curve for curvature graph."},{"name":"color","summary":"Color of curvature graph."}]},{"signature":"void DrawCurvatureGraph(Curve curve, Color color, int hairScale)","summary":"Draw a typical Rhino Curvature Graph.","since":"5.0","parameters":[{"name":"curve","summary":"Base curve for curvature graph."},{"name":"color","summary":"Color of curvature graph."},{"name":"hairScale","summary":"100 = True length, > 100 magnified, < 100 shortened."}]},{"signature":"void DrawCurvatureGraph(Curve curve, Color color, int hairScale, int hairDensity, int sampleDensity)","summary":"Draw a typical Rhino Curvature Graph.","since":"5.0","parameters":[{"name":"curve","summary":"Base curve for curvature graph."},{"name":"color","summary":"Color of curvature graph."},{"name":"hairScale","summary":"100 = True length, > 100 magnified, < 100 shortened."},{"name":"hairDensity","summary":">= 0 larger numbers = more hairs (good default is 1)."},{"name":"sampleDensity","summary":"Between 1 and 10. Higher numbers draw smoother outer curves. (good default is 2)."}]},{"signature":"void DrawCurve(Curve curve, Color color)","summary":"Draw a single Curve object.","since":"5.0","parameters":[{"name":"curve","summary":"Curve to draw."},{"name":"color","summary":"Color to draw with."}]},{"signature":"void DrawCurve(Curve curve, Color color, int thickness)","summary":"Draw a single Curve object.","since":"5.0","parameters":[{"name":"curve","summary":"Curve to draw."},{"name":"color","summary":"Color to draw with."},{"name":"thickness","summary":"Thickness (in pixels) of curve."}]},{"signature":"void DrawCylinder(Cylinder cylinder, Color color)","summary":"Draw a wireframe cylinder.","since":"5.0","parameters":[{"name":"cylinder","summary":"Cylinder to draw."},{"name":"color","summary":"Color to draw with."}]},{"signature":"void DrawCylinder(Cylinder cylinder, Color color, int thickness)","summary":"Draw a wireframe cylinder.","since":"5.0","parameters":[{"name":"cylinder","summary":"Cylinder to draw."},{"name":"color","summary":"Color to draw with."},{"name":"thickness","summary":"Thickness (in pixels) of cylinder wires."}]},{"signature":"void DrawDirectionArrow(Point3d location, Vector3d direction, Color color)","since":"5.0"},{"signature":"void DrawDot(float screenX, float screenY, string text)","summary":"Draws a text dot in screen coordinates.","since":"6.0","parameters":[{"name":"screenX","summary":"X coordinate (in pixels) of dot center."},{"name":"screenY","summary":"Y coordinate (in pixels) of dot center."},{"name":"text","summary":"Text content of dot."}]},{"signature":"void DrawDot(float screenX, float screenY, string text, Color dotColor, Color textColor)","summary":"Draws a text dot in screen coordinates.","since":"6.0","parameters":[{"name":"screenX","summary":"X coordinate (in pixels) of dot center."},{"name":"screenY","summary":"Y coordinate (in pixels) of dot center."},{"name":"text","summary":"Text content of dot."},{"name":"dotColor","summary":"Dot background color."},{"name":"textColor","summary":"Dot foreground color."}]},{"signature":"void DrawDot(Point3d worldPosition, string text)","summary":"Draws a text dot in world coordinates.","since":"5.0","parameters":[{"name":"worldPosition","summary":"Location of dot in world coordinates."},{"name":"text","summary":"Text content of dot."}]},{"signature":"void DrawDot(Point3d worldPosition, string text, Color dotColor, Color textColor)","summary":"Draw a text dot in world coordinates.","since":"5.0","parameters":[{"name":"worldPosition","summary":"Location of dot in world coordinates."},{"name":"text","summary":"Text content of dot."},{"name":"dotColor","summary":"Dot background color."},{"name":"textColor","summary":"Dot foreground color."}]},{"signature":"void DrawDot(TextDot dot, Color fillColor, Color textColor, Color borderColor)","summary":"Draw a text dot as defined by the text dot class","since":"6.0"},{"signature":"void DrawDottedLine(Line line, Color color)","summary":"Draws a single dotted line.","since":"5.0","parameters":[{"name":"line","summary":"Line to draw."},{"name":"color","summary":"Color of line."}]},{"signature":"void DrawDottedLine(Point3d from, Point3d to, Color color)","summary":"Draws a single dotted line.","since":"5.0","parameters":[{"name":"from","summary":"Line start point."},{"name":"to","summary":"Line end point."},{"name":"color","summary":"Color of line."}]},{"signature":"void DrawDottedPolyline(IEnumerable<Point3d> points, Color color, bool close)","summary":"Draws a set of connected lines (polyline) in a dotted pattern (0x00001111).","since":"5.0","parameters":[{"name":"points","summary":"End points of each line segment."},{"name":"color","summary":"Color of polyline."},{"name":"close","summary":"Draw a line between the first and last points."}]},{"signature":"void DrawExtrusionWires(Extrusion extrusion, Color color)","summary":"Draws all the wireframe curves of an extrusion object.","since":"6.0","parameters":[{"name":"extrusion","summary":"Extrusion to draw."},{"name":"color","summary":"Color of Wireframe curves."}]},{"signature":"void DrawExtrusionWires(Extrusion extrusion, Color color, int wireDensity)","summary":"Draws all the wireframe curves of an extrusion object.","since":"6.0","parameters":[{"name":"extrusion","summary":"Extrusion to draw."},{"name":"color","summary":"Color of Wireframe curves."},{"name":"wireDensity","summary":"\\"Density\\" of wireframe curves.  \\n-1 = no internal wires.  \\n0 = default internal wires.  \\n>0 = custom high density."}]},{"signature":"void DrawGradientHatch(Hatch hatch, Color color1, Color color2, Point3d point1, Point3d point2, bool linearGradient, float boundaryThickness, Color boundaryColor)","summary":"Draw a two point gradient filled hatch","since":"7.0"},{"signature":"void DrawGradientHatch(Hatch hatch, IEnumerable<ColorStop> stops, Point3d point1, Point3d point2, bool linearGradient, float repeat, float boundaryThickness, Color boundaryColor)","since":"7.0"},{"signature":"void DrawGradientLines(IEnumerable<Line> lines, float strokeWidth, IEnumerable<ColorStop> stops, Point3d point1, Point3d point2, bool linearGradient, float repeat)","since":"7.0"},{"signature":"void DrawGradientMesh(Mesh mesh, IEnumerable<ColorStop> stops, Point3d point1, Point3d point2, bool linearGradient, float repeat)","since":"7.0"},{"signature":"void DrawHatch(Hatch hatch, Color hatchColor, Color boundaryColor)","since":"6.0"},{"signature":"void DrawLine(Line line, Color color)","summary":"Draws a single line object.","since":"5.0","parameters":[{"name":"line","summary":"Line to draw."},{"name":"color","summary":"Color to draw line in."}]},{"signature":"void DrawLine(Line line, Color color, int thickness)","summary":"Draws a single line object.","since":"5.0","parameters":[{"name":"line","summary":"Line to draw."},{"name":"color","summary":"Color to draw line in."},{"name":"thickness","summary":"Thickness (in pixels) of line."}]},{"signature":"void DrawLine(Point3d from, Point3d to, Color color)","summary":"Draws a single line object.","since":"5.0","parameters":[{"name":"from","summary":"Line from point."},{"name":"to","summary":"Line to point."},{"name":"color","summary":"Color to draw line in."}]},{"signature":"void DrawLine(Point3d from, Point3d to, Color color, int thickness)","summary":"Draws a single line object.","since":"5.0","parameters":[{"name":"from","summary":"Line from point."},{"name":"to","summary":"Line to point."},{"name":"color","summary":"Color to draw line in."},{"name":"thickness","summary":"Thickness (in pixels) of line."}]},{"signature":"void DrawLineArrow(Line line, Color color, int thickness, double size)","summary":"Draws an arrow made up of three line segments.","since":"5.0","parameters":[{"name":"line","summary":"Base line for arrow."},{"name":"color","summary":"Color of arrow."},{"name":"thickness","summary":"Thickness (in pixels) of the arrow line segments."},{"name":"size","summary":"Size (in world units) of the arrow tip lines."}]},{"signature":"void DrawLines(IEnumerable<Line> lines, Color color)","summary":"Draws a set of lines with a given color and thickness. If you want the fastest possible set of lines to be drawn, pass a Line[] for lines.","since":"5.0","parameters":[{"name":"lines","summary":"Lines to draw."},{"name":"color","summary":"Color to draw with."}]},{"signature":"void DrawLines(IEnumerable<Line> lines, Color color, int thickness)","summary":"Draws a set of lines with a given color and thickness. If you want the fastest possible set of lines to be drawn, pass a Line[] for lines.","since":"5.0","parameters":[{"name":"lines","summary":"Lines to draw."},{"name":"color","summary":"Color to draw with."},{"name":"thickness","summary":"Thickness (in pixels) of lines."}]},{"signature":"void DrawMarker(Point3d tip, Vector3d direction, Color color)","summary":"Draws an arrow marker as a view-aligned widget.","since":"5.0","parameters":[{"name":"tip","summary":"Location of arrow tip point."},{"name":"direction","summary":"Direction of arrow."},{"name":"color","summary":"Color of arrow widget."}]},{"signature":"void DrawMarker(Point3d tip, Vector3d direction, Color color, int thickness)","summary":"Draws an arrow marker as a view-aligned widget.","since":"5.0","parameters":[{"name":"tip","summary":"Location of arrow tip point."},{"name":"direction","summary":"Direction of arrow."},{"name":"color","summary":"Color of arrow widget."},{"name":"thickness","summary":"Thickness of arrow widget lines."}]},{"signature":"void DrawMarker(Point3d tip, Vector3d direction, Color color, int thickness, double size)","summary":"Draws an arrow marker as a view-aligned widget.","since":"5.0","parameters":[{"name":"tip","summary":"Location of arrow tip point."},{"name":"direction","summary":"Direction of arrow."},{"name":"color","summary":"Color of arrow widget."},{"name":"thickness","summary":"Thickness of arrow widget lines."},{"name":"size","summary":"Size (in pixels) of the arrow shaft."}]},{"signature":"void DrawMarker(Point3d tip, Vector3d direction, Color color, int thickness, double size, double rotation)","summary":"Draws an arrow marker as a view-aligned widget.","since":"5.0","parameters":[{"name":"tip","summary":"Location of arrow tip point."},{"name":"direction","summary":"Direction of arrow."},{"name":"color","summary":"Color of arrow widget."},{"name":"thickness","summary":"Thickness of arrow widget lines."},{"name":"size","summary":"Size (in pixels) of the arrow shaft."},{"name":"rotation","summary":"Rotational angle adjustment (in radians, counter-clockwise of direction."}]},{"signature":"void DrawMeshFalseColors(Mesh mesh)","summary":"Draws the mesh faces as False color patches. The mesh must have Vertex Colors defined for this to work.","since":"5.0","parameters":[{"name":"mesh","summary":"Mesh to draw."}]},{"signature":"void DrawMeshShaded(Mesh mesh, DisplayMaterial material)","summary":"Draws the shaded faces of a given mesh.","since":"5.0","parameters":[{"name":"mesh","summary":"Mesh to draw."},{"name":"material","summary":"Material to draw faces with."}]},{"signature":"void DrawMeshShaded(Mesh mesh, DisplayMaterial material, int[] faceIndices)","summary":"Draws the shaded faces of a given mesh.","since":"5.0","parameters":[{"name":"mesh","summary":"Mesh to draw."},{"name":"material","summary":"Material to draw faces with."},{"name":"faceIndices","summary":"Indices of specific faces to draw"}]},{"signature":"void DrawMeshVertices(Mesh mesh, Color color)","summary":"Draws all the vertices in a given mesh.","since":"5.0","parameters":[{"name":"mesh","summary":"Mesh for vertex drawing."},{"name":"color","summary":"Color of mesh vertices."}]},{"signature":"void DrawMeshWires(Mesh mesh, Color color)","summary":"Draws all the wires in a given mesh.","since":"5.0","parameters":[{"name":"mesh","summary":"Mesh for wire drawing."},{"name":"color","summary":"Color of mesh wires."}]},{"signature":"void DrawMeshWires(Mesh mesh, Color color, int thickness)","summary":"Draws all the wires in a given mesh.","since":"5.0","parameters":[{"name":"mesh","summary":"Mesh for wire drawing."},{"name":"color","summary":"Color of mesh wires."},{"name":"thickness","summary":"Thickness (in pixels) of mesh wires."}]},{"signature":"void DrawObject(RhinoObject rhinoObject)","since":"5.0"},{"signature":"void DrawObject(RhinoObject rhinoObject, Transform xform)","summary":"Draws a DocObjects.RhinoObjectwith an applied transformation.","since":"5.0","parameters":[{"name":"rhinoObject","summary":"The Rhino object."},{"name":"xform","summary":"The transformation."}]},{"signature":"void DrawParticles(ParticleSystem particles)","since":"5.0"},{"signature":"void DrawParticles(ParticleSystem particles, DisplayBitmap bitmap)","since":"5.0"},{"signature":"void DrawParticles(ParticleSystem particles, DisplayBitmap[] bitmaps)","since":"5.0"},{"signature":"void DrawPatternedLine(Line line, Color color, int pattern, int thickness)","summary":"Draws a single line with specified pattern.","since":"6.0","parameters":[{"name":"line","summary":"Line to draw."},{"name":"color","summary":"Color of line."},{"name":"pattern","summary":"Pattern of the line (like 0x00001111 for dotted line)."},{"name":"thickness","summary":"Thickness (in pixels) of lines."}]},{"signature":"void DrawPatternedLine(Point3d from, Point3d to, Color color, int pattern, int thickness)","summary":"Draws a single line with specified pattern.","since":"6.0","parameters":[{"name":"from","summary":"Line start point."},{"name":"to","summary":"Line end point."},{"name":"color","summary":"Color of line."},{"name":"pattern","summary":"Pattern of the line (like 0x00001111 for dotted line)."},{"name":"thickness","summary":"Thickness (in pixels) of lines."}]},{"signature":"void DrawPatternedPolyline(IEnumerable<Point3d> points, Color color, int pattern, int thickness, bool close)","summary":"Draws a set of connected lines (polyline) with specified pattern.","since":"6.0","parameters":[{"name":"points","summary":"End points of each line segment."},{"name":"color","summary":"Color of polyline."},{"name":"pattern","summary":"Pattern to use for the line (like 0x00001111 for dotted)."},{"name":"thickness","summary":"Thickness (in pixels) of lines."},{"name":"close","summary":"Draw a line between the first and last points."}]},{"signature":"void DrawPoint(Point3d point)","summary":"Draws a point using the current display attribute size, style and color","since":"6.0","parameters":[{"name":"point","summary":"Location of point in world coordinates."}]},{"signature":"void DrawPoint(Point3d point, Color color)","summary":"Draws a point with a given radius, style and color.","since":"5.0","parameters":[{"name":"point","summary":"Location of point in world coordinates."},{"name":"color","summary":"Color of point."}]},{"signature":"void DrawPoint(Point3d point, PointStyle style, Color strokeColor, Color fillColor, float radius, float strokeWidth, float secondarySize, float rotationRadians, bool diameterIsInPixels, bool autoScaleForDpi)","since":"6.0"},{"signature":"void DrawPoint(Point3d point, PointStyle style, float radius, Color color)","summary":"Draws a point with a given radius, style and color.","since":"6.0","parameters":[{"name":"point","summary":"Location of point in world coordinates."},{"name":"style","summary":"Point display style."},{"name":"radius","summary":"Point size in pixels."},{"name":"color","summary":"Color of point. If style is ControlPoint, this will be the border color."}]},{"signature":"void DrawPoint(Point3d point, PointStyle style, int radius, Color color)","summary":"Draws a point with a given radius, style and color.","since":"5.0","parameters":[{"name":"point","summary":"Location of point in world coordinates."},{"name":"style","summary":"Point display style."},{"name":"radius","summary":"Point size in pixels."},{"name":"color","summary":"Color of point. If style is ControlPoint, this will be the border color."}]},{"signature":"void DrawPointCloud(PointCloud cloud, float size)","summary":"Draws a point cloud.","since":"6.0","parameters":[{"name":"cloud","summary":"Point cloud to draw, if the cloud has a color array, it will be used, otherwise the points will be black."},{"name":"size","summary":"Size of points."}]},{"signature":"void DrawPointCloud(PointCloud cloud, float size, Color color)","summary":"Draws a point cloud.","since":"6.0","parameters":[{"name":"cloud","summary":"Point cloud to draw."},{"name":"size","summary":"Size of points."},{"name":"color","summary":"Color of points in the cloud, if the cloud has a color array this setting is ignored."}]},{"signature":"void DrawPointCloud(PointCloud cloud, int size)","summary":"Draws a point cloud.","since":"5.0","parameters":[{"name":"cloud","summary":"Point cloud to draw, if the cloud has a color array, it will be used, otherwise the points will be black."},{"name":"size","summary":"Size of points."}]},{"signature":"void DrawPointCloud(PointCloud cloud, int size, Color color)","summary":"Draws a point cloud.","since":"5.0","parameters":[{"name":"cloud","summary":"Point cloud to draw."},{"name":"size","summary":"Size of points."},{"name":"color","summary":"Color of points in the cloud, if the cloud has a color array this setting is ignored."}]},{"signature":"void DrawPoints(IEnumerable<Point3d> points, PointStyle style, Color strokeColor, Color fillColor, float radius, float strokeWidth, float secondarySize, float rotationRadians, bool diameterIsInPixels, bool autoScaleForDpi)","since":"6.0"},{"signature":"void DrawPoints(IEnumerable<Point3d> points, PointStyle style, float radius, Color color)","summary":"Draw a set of points with a given radius, style and color.","since":"6.0","parameters":[{"name":"points","summary":"Location of points in world coordinates."},{"name":"style","summary":"Point display style."},{"name":"radius","summary":"Point size in pixels."},{"name":"color","summary":"Color of points. If style is ControlPoint, this will be the border color."}]},{"signature":"void DrawPoints(IEnumerable<Point3d> points, PointStyle style, int radius, Color color)","summary":"Draw a set of points with a given radius, style and color.","since":"5.0","parameters":[{"name":"points","summary":"Location of points in world coordinates."},{"name":"style","summary":"Point display style."},{"name":"radius","summary":"Point size in pixels."},{"name":"color","summary":"Color of points. If style is ControlPoint, this will be the border color."}]},{"signature":"void DrawPolygon(IEnumerable<Point3d> points, Color color, bool filled)","summary":"Draws a filled, convex polygon from a collection of points.","since":"5.0","parameters":[{"name":"points","summary":"Collection of world coordinate points that are connected by lines to form a closed shape. Collection must contain at least 3 points."},{"name":"color","summary":"Color to draw with."},{"name":"filled","summary":"True if the closed area should be filled with color. False if you want to draw just the border of the closed shape."}]},{"signature":"void DrawPolyline(IEnumerable<Point3d> polyline, Color color)","summary":"Draws a single Polyline object.","since":"5.0","parameters":[{"name":"polyline","summary":"Polyline to draw."},{"name":"color","summary":"Color to draw in."}]},{"signature":"void DrawPolyline(IEnumerable<Point3d> polyline, Color color, int thickness)","summary":"Draws a single Polyline object.","since":"5.0","parameters":[{"name":"polyline","summary":"Polyline to draw."},{"name":"color","summary":"Color to draw in."},{"name":"thickness","summary":"Thickness (in pixels) of the Polyline."}]},{"signature":"void DrawRoundedRectangle(PointF center, float pixelWidth, float pixelHeight, float cornerRadius, Color strokeColor, float strokeWidth, Color fillColor)","since":"6.0"},{"signature":"void DrawSphere(Sphere sphere, Color color)","summary":"Draw a wireframe sphere.","since":"5.0","parameters":[{"name":"sphere","summary":"Sphere to draw."},{"name":"color","summary":"Color to draw with."}]},{"signature":"void DrawSphere(Sphere sphere, Color color, int thickness)","summary":"Draw a wireframe sphere.","since":"5.0","parameters":[{"name":"sphere","summary":"Sphere to draw."},{"name":"color","summary":"Color to draw with."},{"name":"thickness","summary":"Thickness (in pixels) of Sphere wires."}]},{"signature":"void DrawSprite(DisplayBitmap bitmap, Point2d screenLocation, float size)","since":"5.0"},{"signature":"void DrawSprite(DisplayBitmap bitmap, Point2d screenLocation, float size, Color blendColor)","since":"5.0"},{"signature":"void DrawSprite(DisplayBitmap bitmap, Point2d screenLocation, float width, float height)","summary":"Draw screen oriented image centered at 2d screen location","since":"7.0"},{"signature":"void DrawSprite(DisplayBitmap bitmap, Point3d worldLocation, float size, bool sizeInWorldSpace)","since":"5.0"},{"signature":"void DrawSprite(DisplayBitmap bitmap, Point3d worldLocation, float size, Color blendColor, bool sizeInWorldSpace)","since":"5.0"},{"signature":"void DrawSprites(DisplayBitmap bitmap, DisplayBitmapDrawList items, float size, bool sizeInWorldSpace)","since":"5.0"},{"signature":"void DrawSprites(DisplayBitmap bitmap, DisplayBitmapDrawList items, float size, Vector3d translation, bool sizeInWorldSpace)","since":"5.0"},{"signature":"bool DrawStereoFrameBuffer(ViewportInfo viewportLeft, ViewportInfo viewportRight, out uint handleLeft, out uint handleRight)","summary":"Draws the viewport as seen from the left and the right eye viewports and returns the result as OpenGL texture handles.","since":"6.8","parameters":[{"name":"viewportLeft","summary":"The viewport representing the left eye location and look direction."},{"name":"viewportRight","summary":"The viewport representing the right eye location and look direction."},{"name":"handleLeft","summary":"Will contain the OpenGL texture handle which references the left output color buffer."},{"name":"handleRight","summary":"Will contain the OpenGL texture handle which references the right output color buffer."}],"returns":"True if drawing succeeded, False otherwise."},{"signature":"void DrawSubDShaded(SubD subd, DisplayMaterial material)","summary":"Draw a shaded mesh representation of a SubD","since":"7.0","parameters":[{"name":"subd","summary":"SubD to draw"},{"name":"material","summary":"Material to draw faces with"}]},{"signature":"void DrawSubDWires(SubD subd, Color color, float thickness)","summary":"Draws all the wireframe curves of a SubD object","since":"7.0","parameters":[{"name":"subd","summary":"SubD to draw"},{"name":"color","summary":"wire color"},{"name":"thickness","summary":"wire thickness"}]},{"signature":"void DrawSurface(Surface surface, Color wireColor, int wireDensity)","summary":"Draw wireframe display for a single surface.","since":"5.0","parameters":[{"name":"surface","summary":"Surface to draw."},{"name":"wireColor","summary":"Color to draw with."},{"name":"wireDensity","summary":"Thickness (in pixels) or wires to draw."}]},{"signature":"void DrawText(TextEntity text, Color color)","since":"6.0"},{"signature":"void DrawText(TextEntity text, Color color, double scale)","since":"6.0"},{"signature":"void DrawText(TextEntity text, Color color, Transform xform)","since":"6.0"},{"signature":"void DrawTorus(Torus torus, Color color)","summary":"Draw a wireframe torus.","since":"5.0","parameters":[{"name":"torus","summary":"Torus to draw."},{"name":"color","summary":"Color to draw with."}]},{"signature":"void DrawTorus(Torus torus, Color color, int thickness)","summary":"Draw a wireframe torus.","since":"5.0","parameters":[{"name":"torus","summary":"Torus to draw."},{"name":"color","summary":"Color to draw with."},{"name":"thickness","summary":"Thickness (in pixels) of torus wires."}]},{"signature":"void DrawZebraPreview(Brep brep, Color color)","summary":"Draws a shaded Brep with Zebra stripe preview.","since":"6.16","parameters":[{"name":"brep","summary":"Brep to draw."},{"name":"color","summary":"Object color."}]},{"signature":"void EnableClippingPlanes(bool enable)","summary":"Enable or disable the Clipping Plane logic of the engine.","since":"5.0","parameters":[{"name":"enable","summary":"True to enable Clipping Planes, False to disable."}]},{"signature":"void EnableColorWriting(bool enable)","summary":"Enable or disable the ColorWriting behavior of the engine.","since":"5.0","parameters":[{"name":"enable","summary":"True to enable ColorWriting, False to disable."}]},{"signature":"void EnableDepthTesting(bool enable)","summary":"Enable or disable the DepthTesting behavior of the engine. When DepthTesting is disabled, objects in front will no longer occlude objects behind them.","since":"5.0","parameters":[{"name":"enable","summary":"True to enable DepthTesting, False to disable."}]},{"signature":"void EnableDepthWriting(bool enable)","summary":"Enable or disable the DepthWriting behavior of the engine. When DepthWriting is disabled, drawn geometry does not affect the Z-Buffer.","since":"5.0","parameters":[{"name":"enable","summary":"True to enable DepthWriting, False to disable."}]},{"signature":"void EnableLighting(bool enable)","summary":"Enable or disable the Lighting logic of the engine.","since":"5.0","parameters":[{"name":"enable","summary":"True to enable Lighting, False to disable."}]},{"signature":"void Flush()","summary":"Force the pipeline to immediately flush any cached geometry to the display","since":"7.0"},{"signature":"Light[] GetLights()","summary":"Get lights that this pipeline is current using","since":"6.3"},{"signature":"float[] GetOpenGLCameraToClip()","summary":"Get an array of 16 floats that represents the \\"camera\\" to \\"clip\\" coordinate transformation in OpenGL\'s right handed coordinate system","since":"6.0"},{"signature":"float[] GetOpenGLWorldToCamera(bool includeModelTransform)","summary":"Get an array of 16 floats that represents the \\"world\\" to \\"camera\\" coordinate transformation in OpenGL\'s right handed coordinate system","since":"6.0"},{"signature":"float[] GetOpenGLWorldToClip(bool includeModelTransform)","summary":"Get an array of 16 floats that represents the \\"world\\" to \\"clip\\" coordinate transformation in OpenGL\'s right handed coordinate system","since":"6.0"},{"signature":"bool InterruptDrawing()","summary":"Tests to see if the pipeline should stop drawing more geometry and just show what it has so far. If a drawing operation is taking a long time, this function will return True and tell Rhino it should just finish up and show the frame buffer. This is used in dynamic drawing operations.","since":"5.0","returns":"True if the pipeline should stop attempting to draw more geometry and just show the frame buffer."},{"signature":"bool IsActive(RhinoObject rhinoObject)","summary":"Determines if an object can be visible in this viewport based on it\'s object type and display attributes. This test does not check for visibility based on location of the object. NOTE: Use CRhinoDisplayPipeline::IsVisible() to perform \\"visibility\\" tests based on location (is some part of the object in the view frustum). Use CRhinoDisplayPipeline::IsActive() to perform \\"visibility\\" tests based on object type.","since":"5.0","parameters":[{"name":"rhinoObject","summary":"Object to test."}],"returns":"True if this object can be drawn in the pipeline\'s viewport based on it\'s object type and display attributes."},{"signature":"bool IsVisible(BoundingBox bbox)","summary":"Test a given box for visibility inside the view frustum under the current viewport and model transformation settings.","since":"5.0","parameters":[{"name":"bbox","summary":"Box to test for visibility."}],"returns":"True if at least some portion of the box is visible, False if not."},{"signature":"bool IsVisible(Point3d worldCoordinate)","summary":"Test a given 3d world coordinate point for visibility inside the view frustum under the current viewport and model transformation settings.","since":"5.0","parameters":[{"name":"worldCoordinate","summary":"Point to test for visibility."}],"returns":"True if the point is visible, False if it is not."},{"signature":"bool IsVisible(RhinoObject rhinoObject)","summary":"Test a given object for visibility inside the view frustum under the current viewport and model transformation settings. This function calls a virtual IsVisibleFinal function that sub-classed pipelines can add extra tests to. In the base class, this test only tests visibility based on the objects world coordinates location and does not pay attention to the object\'s attributes.  NOTE: Use CRhinoDisplayPipeline::IsVisible() to perform \\"visibility\\" tests based on location (is some part of the object in the view frustum). Use CRhinoDisplayPipeline::IsActive() to perform \\"visibility\\" tests based on object type.","since":"5.0","parameters":[{"name":"rhinoObject","summary":"Object to test."}],"returns":"True if the object is visible, False if not."},{"signature":"System.Drawing.Rectangle Measure2dText(string text, Point2d definitionPoint, bool middleJustified, double rotationRadians, int height, string fontFace)","summary":"Determines screen rectangle that would be drawn to using the Draw2dText(..) function with the same parameters.","since":"5.10","parameters":[{"name":"text","summary":"text to measure."},{"name":"definitionPoint","summary":"either lower-left or middle of text."},{"name":"middleJustified","summary":"true=middle justified. false=lower-left justified."},{"name":"rotationRadians","summary":"text rotation in radians"},{"name":"height","summary":"height in pixels (good default is 12)"},{"name":"fontFace","summary":"font name (good default is \\"Arial\\")"}],"returns":"rectangle in the viewport\'s screen coordinates on success."},{"signature":"bool Open()","summary":"Opens the pipeline.","since":"7.0","returns":"True if the pipeline was opened, False if it was already open or failed to open."},{"signature":"void PopClipTesting()","summary":"Pop a ClipTesting flag off the engine\'s stack.","since":"5.0","deprecated":"6.0"},{"signature":"void PopCullFaceMode()","summary":"Pop a FaceCull flag off the engine\'s stack.","since":"5.0"},{"signature":"void PopDepthTesting()","summary":"Pop a DepthTesting flag off the engine\'s stack.","since":"5.0"},{"signature":"void PopDepthWriting()","summary":"Pop a DepthWriting flag off the engine\'s stack.","since":"5.0"},{"signature":"void PopModelTransform()","summary":"Pop a model transformation off the engine\'s model transform stack.","since":"5.0"},{"signature":"void PushClipTesting(bool enable)","summary":"Push a ClipTesting flag on the engine\'s stack.","since":"5.0","deprecated":"6.0","parameters":[{"name":"enable","summary":"ClipTesting flag."}]},{"signature":"void PushCullFaceMode(CullFaceMode mode)","summary":"Push a FaceCull flag on the engine\'s stack.","since":"5.0","parameters":[{"name":"mode","summary":"FaceCull flag."}]},{"signature":"void PushDepthTesting(bool enable)","summary":"Push a DepthTesting flag on the engine\'s stack.","since":"5.0","parameters":[{"name":"enable","summary":"DepthTesting flag."}]},{"signature":"void PushDepthWriting(bool enable)","summary":"Push a DepthWriting flag on the engine\'s stack.","since":"5.0","parameters":[{"name":"enable","summary":"DepthWriting flag."}]},{"signature":"void PushModelTransform(Transform xform)","summary":"Push a model transformation on the engine\'s model transform stack.","since":"5.0","parameters":[{"name":"xform","summary":"Transformation to push."}]},{"signature":"void RemoveClippingPlane(int index)","summary":"Remove a clipping plane from the pipeline for this frame","since":"6.3"}],"events":[{"signature":"static CalculateBoundingBox","since":"5.0"},{"signature":"static CalculateBoundingBoxZoomExtents","summary":"Calculate a bounding to include in the Zoom Extents command.","since":"5.0"},{"signature":"static DisplayModeChanged","since":"6.18"},{"signature":"static DrawForeground","summary":"Called after all non-highlighted objects have been drawn and PostDrawObjects has been called. Depth writing and testing are turned OFF. If you want to draw with depth writing/testing, see PostDrawObjects.","since":"5.0"},{"signature":"static DrawOverlay","summary":"If Rhino is in a feedback mode, the draw overlay call allows for temporary geometry to be drawn on top of everything in the scene. This is similar to the dynamic draw routine that occurs with custom get point.","since":"5.0"},{"signature":"static InitFrameBuffer","since":"6.18"},{"signature":"static ObjectCulling","since":"5.3"},{"signature":"static PostDrawObject","summary":"Called right after an individual object has been drawn. NOTE: Do not use this event unless you absolutely need to.  It is called for every object in the document and can slow display down if a large number of objects exist in the document","since":"7.0"},{"signature":"static PostDrawObjects","summary":"Called after all non-highlighted objects have been drawn. Depth writing and testing are still turned on. If you want to draw without depth writing/testing, see DrawForeground.","since":"5.0"},{"signature":"static PreDrawObject","summary":"Called right before an individual object is being drawn. NOTE: Do not use this event unless you absolutely need to.  It is called for every object in the document and can slow display down if a large number of objects exist in the document","since":"5.0"},{"signature":"static PreDrawObjects","summary":"Called before objects are been drawn. Depth writing and testing are on.","since":"5.0"},{"signature":"static PreDrawTransparentObjects","summary":"Called before transparent objects have been drawn. Depth writing and testing are on.","since":"6.12"},{"signature":"static ViewportProjectionChanged","summary":"Called when the projection changes for a viewport being drawn.","since":"6.18"}]},{"namespace":"Rhino.Display","name":"DisplayPipelineAttributes","dataType":"class","summary":"Represents display pipeline settings, such as \\"show transparency\\" and \\"show grips\\".","interfaces":["IDisposable","ISerializable"],"properties":[{"signature":"Color AmbientLightingColor","since":"6.3","property":["get","set"]},{"signature":"BoundingBoxDisplayMode BoundingBoxMode","since":"6.1","property":["get","set"]},{"signature":"bool CastShadows","summary":"Cast shadows.","since":"6.4","property":["get","set"]},{"signature":"ContextsForDraw ContextForDraw","since":"6.5","property":["get"]},{"signature":"Color CurveColor","summary":"Color used for drawing curves","since":"5.1","property":["get","set"]},{"signature":"int CurveThickness","summary":"Pixel thickness for curves","since":"5.1","property":["get","set"]},{"signature":"bool DisableConduits","since":"5.0","property":["get","set"]},{"signature":"bool DisableTransparency","since":"5.0","property":["get","set"]},{"signature":"string EnglishName","since":"5.0","property":["get","set"]},{"signature":"FrameBufferFillMode FillMode","summary":"Get or set the frame buffer fill mode.","since":"6.0","property":["get","set"]},{"signature":"Guid Id","since":"5.0","property":["get"]},{"signature":"bool IgnoreHighlights","since":"5.0","property":["get","set"]},{"signature":"string LocalName","since":"5.0","property":["get"]},{"signature":"bool LockedObjectsDrawBehindOthers","summary":"Locked object are drawn behind other objects","since":"5.1","property":["get","set"]},{"signature":"MeshDisplayAttributes MeshSpecificAttributes","since":"5.0","property":["get"]},{"signature":"Color ObjectColor","since":"5.0","property":["get","set"]},{"signature":"float PointRadius","since":"6.0","property":["get","set"]},{"signature":"PointStyle PointStyle","since":"6.0","property":["get","set"]},{"signature":"Guid RealtimeDisplayId","summary":"Get the ID of the real-time display engine attached to the view. This will be Guid.Empty if no real-time display engine is in use. This can be the case for instance when starting a _Render session for a real-time viewport integration. That still would cause this ID to be Guid.Empty.","since":"6.0","property":["get"]},{"signature":"int RealtimeRenderPasses","summary":"Get or set the real-time passes amount","since":"6.0","property":["get","set"]},{"signature":"bool ShadeVertexColors","summary":"Shade using vertex colors.","since":"6.4","property":["get","set"]},{"signature":"bool ShadingEnabled","summary":"Draw shaded meshes and surfaces. Set to False to use Flat Shading.","since":"5.1","property":["get","set"]},{"signature":"Color ShadowColor","since":"6.3","property":["get","set"]},{"signature":"bool ShowAnnotations","summary":"Show annotations.","since":"6.4","property":["get","set"]},{"signature":"bool ShowClippingPlanes","summary":"Show clipping planes.","since":"6.4","property":["get","set"]},{"signature":"bool ShowCurves","summary":"Draw curves","since":"5.1","property":["get","set"]},{"signature":"bool ShowGrips","since":"5.0","property":["get","set"]},{"signature":"bool ShowIsoCurves","summary":"Draw surface ISO curves.","since":"6.4","property":["get","set"]},{"signature":"bool ShowLights","summary":"Show light widgets.","since":"6.4","property":["get","set"]},{"signature":"bool ShowPointClouds","summary":"Show point clouds.","since":"6.4","property":["get","set"]},{"signature":"bool ShowPoints","summary":"Show points.","since":"6.4","property":["get","set"]},{"signature":"bool ShowRealtimeRenderProgressBar","summary":"Get or set whether the display is used for preview rendering or not.","since":"6.0","property":["get","set"]},{"signature":"bool ShowSurfaceEdges","summary":"Show surface edges.","since":"6.4","property":["get","set"]},{"signature":"bool ShowTangentEdges","summary":"Show tangent edges.","since":"6.4","property":["get","set"]},{"signature":"bool ShowTangentSeams","summary":"Show tangent seams.","since":"6.4","property":["get","set"]},{"signature":"bool ShowText","summary":"Show text.","since":"6.4","property":["get","set"]},{"signature":"StereoContext StereoContext","summary":"Get or set the stereo render context.","since":"7.0","property":["get","set"]},{"signature":"int SurfaceEdgeThickness","summary":"Thickness for surface edges","since":"6.1","property":["get","set"]},{"signature":"bool UseAssignedObjectMaterial","summary":"Gets whether objects ought to be drawn using their assigned rendering material.","since":"6.0","property":["get"]},{"signature":"bool UseCustomObjectColor","summary":"Gets whether objects ought to be drawn using a custom color.","since":"6.0","property":["get"]},{"signature":"bool UseCustomObjectMaterial","summary":"Gets whether objects ought to be drawn using a custom material.","since":"6.0","property":["get"]},{"signature":"bool UseSingleCurveColor","summary":"Use a single color for drawing curves","since":"6.3","property":["get","set"]},{"signature":"ViewDisplayAttributes ViewSpecificAttributes","since":"5.0","property":["get"]},{"signature":"bool XrayAllObjects","since":"5.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","since":"5.0"},{"signature":"void GetFill(out Color topLeft, out Color bottomLeft, out Color topRight, out Color bottomRight)","summary":"Get fill colors used for clearing the frame buffer","since":"6.23"},{"signature":"void GetObjectData(SerializationInfo info, StreamingContext context)","since":"5.0"},{"signature":"void SetFill(Color singleColor)","summary":"Set fill mode to solid color and set the fill color","since":"6.23"},{"signature":"void SetFill(Color gradientTop, Color gradientBottom)","summary":"Set fill mode to two color and set the colors","since":"6.23"},{"signature":"void SetFill(Color gradientTopLeft, Color gradientBottomLeft, Color gradientTopRight, Color gradientBottomRight)","summary":"Set the fill mode to four color gradient and set the colors","since":"6.23"}]},{"namespace":"Rhino.Display","name":"DisplayPipelineAttributes.BoundingBoxDisplayMode","dataType":"enum","since":"6.1","values":[{"signature":"None = UnsafeNativeMethods.DisplayPipelineAttributesBBox.BBoxOff"},{"signature":"OnDuringDynamicDisplay = UnsafeNativeMethods.DisplayPipelineAttributesBBox.BBoxOnDynamicDisplay"},{"signature":"OnAlways = UnsafeNativeMethods.DisplayPipelineAttributesBBox.BBoxOnAlways"}]},{"namespace":"Rhino.Display","name":"DisplayPipelineAttributes.ContextsForDraw","dataType":"enum","since":"6.5","values":[{"signature":"Unset = 0"},{"signature":"FilePreview = 1"},{"signature":"ViewCapture = 2"},{"signature":"Printing = 3"},{"signature":"UIPreview = 4"},{"signature":"Mask = 5"},{"signature":"RenderOverlays = 6"}]},{"namespace":"Rhino.Display","name":"DisplayPipelineAttributes.FrameBufferFillMode","dataType":"enum","since":"6.0","values":[{"signature":"DefaultColor = UnsafeNativeMethods.FrameBufferFillMode.DEFAULT_COLOR"},{"signature":"SolidColor = UnsafeNativeMethods.FrameBufferFillMode.SOLID_COLOR"},{"signature":"Gradient2Color = UnsafeNativeMethods.FrameBufferFillMode.GRADIENT_2_COLOR"},{"signature":"Gradient4Color = UnsafeNativeMethods.FrameBufferFillMode.GRADIENT_4_COLOR"},{"signature":"Bitmap = UnsafeNativeMethods.FrameBufferFillMode.BITMAP"},{"signature":"Renderer = UnsafeNativeMethods.FrameBufferFillMode.RENDERER"},{"signature":"Transparent = UnsafeNativeMethods.FrameBufferFillMode.TRANSPARENT"}]},{"namespace":"Rhino.Display","name":"DisplayPipelineAttributes.MeshDisplayAttributes","dataType":"class","properties":[{"signature":"Color AllMeshWiresColor","summary":"Color.Empty means that we are NOT using a single color for all mesh wires.","since":"5.0","property":["get","set"]},{"signature":"bool HighlightMeshes","since":"5.0","property":["get","set"]},{"signature":"int MeshWireThickness","since":"5.0","property":["get","set"]},{"signature":"bool ShowMeshVertices","since":"5.0","property":["get","set"]},{"signature":"bool ShowMeshWires","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.Display","name":"DisplayPipelineAttributes.ViewDisplayAttributes","dataType":"class","properties":[{"signature":"bool BlendGrid","since":"5.0","property":["get","set"]},{"signature":"bool DrawGrid","since":"5.0","property":["get","set"]},{"signature":"bool DrawGridAxes","since":"5.0","property":["get","set"]},{"signature":"bool DrawTransparentGridPlane","since":"5.0","property":["get","set"]},{"signature":"bool DrawWorldAxes","since":"5.0","property":["get","set"]},{"signature":"bool DrawZAxis","since":"5.0","property":["get","set"]},{"signature":"double HorizontalViewportScale","since":"5.0","property":["get","set"]},{"signature":"bool ShowGridOnTop","since":"5.0","property":["get","set"]},{"signature":"bool UseDocumentGrid","since":"5.0","property":["get","set"]},{"signature":"double VerticalViewportScale","since":"5.0","property":["get","set"]},{"signature":"Color WorldAxisColorX","since":"5.0","property":["get","set"]},{"signature":"Color WorldAxisColorY","since":"5.0","property":["get","set"]},{"signature":"Color WorldAxisColorZ","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.Display","name":"DisplayTechnology","dataType":"enum","summary":"Graphics display techologies.","since":"7.0","values":[{"signature":"None = 0"},{"signature":"OpenGL = 1"},{"signature":"Metal = 2"},{"signature":"DirectX = 3"},{"signature":"Software = 4"},{"signature":"Vulkan = 5"}]},{"namespace":"Rhino.Display","name":"DrawEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"DisplayPipeline Display","since":"5.0","property":["get"]},{"signature":"RhinoDoc RhinoDoc","since":"5.0","property":["get"]},{"signature":"RhinoViewport Viewport","since":"5.0","property":["get"]}]},{"namespace":"Rhino.Display","name":"DrawForegroundEventArgs","dataType":"class","baseclass":"Rhino.Display.DrawEventArgs","properties":[{"signature":"bool DrawWorldAxes","since":"5.0","property":["get","set"]},{"signature":"bool WorldAxesDrawn","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.Display","name":"DrawFrameStages","dataType":"enum","since":"5.0","values":[{"signature":"InitializeFrameBuffer = 0x00000001"},{"signature":"SetupFrustum = 0x00000002"},{"signature":"ObjectCulling = 0x00000004"},{"signature":"CalculateBoundingBox = 0x00000008"},{"signature":"CalculateClippingPlanes = 0x00000010"},{"signature":"SetupLighting = 0x00000020"},{"signature":"DrawBackground = 0x00000040"},{"signature":"PreDrawObjects = 0x00000080"},{"signature":"DrawObject = 0x00000100"},{"signature":"PostDrawObjects = 0x00000200"},{"signature":"DrawForeGround = 0x00000400"},{"signature":"DrawOverlay = 0x00000800"},{"signature":"PostProcessFrameBuffer = 0x00001000"},{"signature":"MeshingParameters = 0x00002000"},{"signature":"ObjectDisplayAttributes = 0x00004000"},{"signature":"PreObjectDraw = 0x00008000"},{"signature":"PostObjectDraw = 0x00010000"},{"signature":"ViewExtents = 0x00020000"},{"signature":"DrawMiddleGround = PreDrawObjects | DrawObject | PostDrawObjects"},{"signature":"ObjectBasedChannel = ObjectCulling | DrawObject | ObjectDisplayAttributes | PreObjectDraw | PostObjectDraw"},{"signature":"All = 0xFFFFFFFF & ~ViewExtents"}]},{"namespace":"Rhino.Display","name":"DrawObjectEventArgs","dataType":"class","baseclass":"Rhino.Display.DrawEventArgs","properties":[{"signature":"bool DrawObject","since":"5.0","property":["get","set"]},{"signature":"RhinoObject RhinoObject","since":"5.0","property":["get"]}]},{"namespace":"Rhino.Display","name":"GradientType","dataType":"enum","summary":"Style of color gradient","since":"7.0","values":[{"signature":"None = 0","summary":"No gradient"},{"signature":"Linear = 1","summary":"Linear (or axial) gradient between two points"},{"signature":"Radial = 2","summary":"Radial (or spherical) gradient using a center point and a radius"},{"signature":"LinearDisabled = 3","summary":"Disabled linear gradient. Useful for keeping gradient information around, but not having it displayed"},{"signature":"RadialDisabled = 4","summary":"Disabled radial gradient. Useful for keeping gradient information around, but not having it displayed"}]},{"namespace":"Rhino.Display","name":"InitFrameBufferEventArgs","dataType":"class","baseclass":"EventArgs","methods":[{"signature":"void SetFill(Color color)","since":"6.18"},{"signature":"void SetFill(Color top, Color bottom)","since":"6.18"},{"signature":"void SetFill(Color topLeft, Color bottomLeft, Color topRight, Color bottomRight)","since":"6.18"}]},{"namespace":"Rhino.Display","name":"PageViewSpaceChangeEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"Guid NewActiveDetailId","summary":"The id of the detail object was set active.  Note, if this id is equal to Guid.Empty, then the active detail object is the page view itself.","since":"5.0","property":["get","set"]},{"signature":"Guid OldActiveDetailId","summary":"The id of the previously active detail object. Note, if this id is equal to Guid.Empty, then the active detail object was the page view itself.","since":"5.0","property":["get","set"]},{"signature":"RhinoPageView PageView","summary":"The page view on which a different detail object was set active.","since":"5.0","property":["get"]}]},{"namespace":"Rhino.Display","name":"PointStyle","dataType":"enum","summary":"Defines styles used for drawing points.","values":[{"signature":"Simple = 0","summary":"Square"},{"signature":"ControlPoint = 1","summary":"Square with white center"},{"signature":"ActivePoint = 2","summary":"Like a control point but includes vertical/horizontal crosshair lines."},{"signature":"X = 3","summary":"X shape"},{"signature":"RoundSimple = 4","summary":"Circular"},{"signature":"RoundControlPoint = 5","summary":"Circular with white center"},{"signature":"RoundActivePoint = 6","summary":"Round control point with crosshair lines"},{"signature":"Circle = RoundSimple","summary":"Circle or ring shape when secondarySize is set"},{"signature":"Square = Simple","summary":"Square or diamond shape when rotated"},{"signature":"Triangle = 7","summary":"Triangular shape"},{"signature":"Heart = 8","summary":"Heart shape"},{"signature":"Chevron = 9","summary":"Chevron shape (two directional arrows)"},{"signature":"Clover = 10","summary":"Three unioned circles"},{"signature":"Tag = 11","summary":"Tag shape"},{"signature":"Asterisk = 12","summary":"* shape"},{"signature":"Pin = 13","summary":"Map style pin symbol. secondarySize defines hole zie in pin"},{"signature":"ArrowTail = 14","summary":"Arrow shape with tail as definition point. Shape is offset from tail by secondarySize."},{"signature":"ArrowTip = 15","summary":"Arrow shape with tip as definition point. Shape is offset from tip by secondarySize."}]},{"namespace":"Rhino.Display","name":"RhinoPageView","dataType":"class","summary":"A window that contains a single layout \'page\'","baseclass":"Rhino.Display.RhinoView","properties":[{"signature":"DetailViewObject ActiveDetail","summary":"Returns the active detail object. If no detail is active, or if the page is active, then None is returned.","since":"7.0","property":["get"]},{"signature":"Guid ActiveDetailId","summary":"Returns the id of the active detail. If no detail is active, or if the page is active, then Guid.Empty is returned.","since":"7.0","property":["get"]},{"signature":"RhinoViewport ActiveViewport","summary":"Gets the active viewport. The ActiveViewport is the same as the MainViewport for standard RhinoViews. In a RhinoPageView, the active viewport may be the RhinoViewport of a child detail object. Most of the time, you will use ActiveViewport unless you explicitly need to work with the main viewport.","since":"5.0","property":["get"]},{"signature":"double PageHeight","summary":"Height of the page in the document\'s PageUnitSystem","since":"5.10","property":["get","set"]},{"signature":"bool PageIsActive","summary":"Returns True if the page is active, rather than any detail view. This occurs when the MainViewport.Id == ActiveViewportID.","since":"5.0","property":["get"]},{"signature":"string PageName","summary":"Same as the MainViewport.Name.","since":"5.0","property":["get","set"]},{"signature":"int PageNumber","summary":"Gets or sets the runtime page number and updates the page number for all of the other pages. The first page has a value of 0.","since":"5.0","property":["get","set"]},{"signature":"double PageWidth","summary":"Width of the page in the document\'s PageUnitSystem","since":"5.10","property":["get","set"]},{"signature":"string PaperName","summary":"Returns the name of the layout\'s media, or paper (e.g. Letter, Legal, A1, etc.), used to determine the page width and page height.","since":"6.15","property":["get"]},{"signature":"string PrinterName","summary":"Returns the name of the layout\'s destination printer.","since":"6.15","property":["get"]}],"methods":[{"signature":"DetailViewObject AddDetailView(string title, Point2d corner0, Point2d corner1, DefinedViewportProjection initialProjection)","summary":"Creates a detail view object that is displayed on this page and adds it to the document.","since":"5.0","parameters":[{"name":"title","summary":"The detail view title."},{"name":"corner0","summary":"Corners of the detail view in world coordinates."},{"name":"corner1","summary":"Corners of the detail view in world coordinates."},{"name":"initialProjection","summary":"The defined initial projection type."}],"returns":"Newly created detail view on success, None on error."},{"signature":"RhinoPageView Duplicate(bool duplicatePageGeometry)","summary":"Copies a page view.","since":"6.3","parameters":[{"name":"duplicatePageGeometry","summary":"Set True if you want the page view geometry copied, along with the view."}],"returns":"The new page view if successful, None otherwise."},{"signature":"DetailViewObject[] GetDetailViews()","summary":"Gets a list of the detail view objects associated with this layout.","since":"5.0","returns":"An array of detail view objects if successful, an empty array if the layout has no details."},{"signature":"System.Drawing.Bitmap GetPreviewImage(Size size, bool grayScale)","summary":"Creates a preview image of the page.","since":"7.0","parameters":[{"name":"size","summary":"The size of the preview image."},{"name":"grayScale","summary":"Set True to produce a grayscale image, False to produce a color image."}],"returns":"A bitmap if successful, None otherwise."},{"signature":"bool SetActiveDetail(Guid detailId)","summary":"Sets the active detail.","since":"5.0","parameters":[{"name":"detailId","summary":"The id of the detail view object to set active."}],"returns":"True if successful, False otherwise."},{"signature":"bool SetActiveDetail(string detailName, bool compareCase)","summary":"Sets the active detail.","since":"5.0","parameters":[{"name":"detailName","summary":"The name, or title, of the detail to set active."},{"name":"compareCase","summary":"Unused."}],"returns":"True if successful, False otherwise."},{"signature":"void SetPageAsActive()","summary":"Deactivates the active details and sets the page view as active.","since":"5.0"}],"events":[{"signature":"static PageViewSpaceChange","since":"5.0"}]},{"namespace":"Rhino.Display","name":"RhinoView","dataType":"class","summary":"A RhinoView represents a single \\"window\\" display of a document. A view could contain one or many RhinoViewports (many in the case of Layout views with detail viewports). Standard Rhino modeling views have one viewport.","properties":[{"signature":"static bool EnableDrawing","summary":"Gets or sets the \'drawing enabled\' flag. By default, drawing is enabled.  \\nThere are some rare situations where scripts want to disable drawing for a while.","since":"5.0","property":["get","set"]},{"signature":"RhinoViewport ActiveViewport","summary":"The ActiveViewport is the same as the MainViewport for standard RhinoViews. In a RhinoPageView, the active viewport may be the RhinoViewport of a child detail object. Most of the time, you will use ActiveViewport unless you explicitly need to work with the main viewport.","since":"5.0","property":["get"]},{"signature":"Guid ActiveViewportID","summary":"Returns viewport ID for the active viewport. Faster than ActiveViewport function when working with page views.","since":"5.0","property":["get"]},{"signature":"Rectangle Bounds","summary":"Gets the size and location of the view including its non-client elements, in pixels, relative to the parent control.","since":"5.0","property":["get"]},{"signature":"Rectangle ClientRectangle","summary":"Gets the rectangle that represents the client area of the view.","since":"5.0","property":["get"]},{"signature":"DisplayPipeline DisplayPipeline","summary":"Gets the display pipeline used for this view.","since":"6.0","property":["get"]},{"signature":"RhinoDoc Document","since":"5.0","property":["get"]},{"signature":"bool Floating","summary":"Floating state of RhinoView. if true, then the view will be in a floating frame window. Otherwise the view will be embedded in the main frame.","since":"5.0","property":["get","set"]},{"signature":"IntPtr Handle","summary":"Gets the window handle that this view is bound to.","since":"5.0","property":["get"]},{"signature":"RhinoViewport MainViewport","summary":"A RhinoView contains a \\"main viewport\\" that fills the entire view client window. RhinoPageViews may also contain nested child RhinoViewports for implementing detail viewports. The MainViewport will always return this RhinoView\'s m_vp.","since":"5.0","property":["get"]},{"signature":"bool Maximized","since":"5.0","property":["get","set"]},{"signature":"RealtimeDisplayMode RealtimeDisplayMode","summary":"Gets the RealtimeDisplayMode active for this view. None if the view doesn\'t have a RealtimeDisplayMode set.","since":"6.0","property":["get"]},{"signature":"uint RuntimeSerialNumber","since":"6.0","property":["get"]},{"signature":"Rectangle ScreenRectangle","summary":"Gets the rectangle that represents the client area of the view in screen coordinates.","since":"5.0","property":["get"]},{"signature":"Size Size","summary":"Gets or sets the size of the view","since":"6.0","property":["get","set"]},{"signature":"bool TitleVisible","summary":"Visibility of the viewport title window.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static RhinoView FromRuntimeSerialNumber(uint serialNumber)","summary":"Get a RhinoView from it\'s unique runtime serial number","since":"6.0","returns":"RhinoView or None if no view exists for a given serial number"},{"signature":"System.Drawing.Bitmap CaptureToBitmap()","summary":"Capture View contents to a bitmap.","since":"5.0","returns":"The bitmap of the complete view."},{"signature":"System.Drawing.Bitmap CaptureToBitmap(bool grid, bool worldAxes, bool cplaneAxes)","summary":"Captures the view contents to a bitmap allowing for visibility of grid and axes.","since":"5.0","parameters":[{"name":"grid","summary":"True if the construction plane grid should be visible."},{"name":"worldAxes","summary":"True if the world axis should be visible."},{"name":"cplaneAxes","summary":"True if the construction plane close the grid should be visible."}],"returns":"A new bitmap."},{"signature":"System.Drawing.Bitmap CaptureToBitmap(DisplayModeDescription mode)","summary":"Capture View contents to a bitmap using a display mode description to define how drawing is performed.","since":"5.0","parameters":[{"name":"mode","summary":"The display mode."}],"returns":"A new bitmap."},{"signature":"System.Drawing.Bitmap CaptureToBitmap(DisplayPipelineAttributes attributes)","summary":"Captures view contents to a bitmap using display attributes to define how drawing is performed.","since":"5.0","parameters":[{"name":"attributes","summary":"The specific display mode attributes."}],"returns":"A new bitmap."},{"signature":"System.Drawing.Bitmap CaptureToBitmap(Size size)","summary":"Capture View contents to a bitmap.","since":"5.0","parameters":[{"name":"size","summary":"Size of Bitmap to capture to."}],"returns":"The bitmap of the specified part of the view."},{"signature":"System.Drawing.Bitmap CaptureToBitmap(Size size, bool grid, bool worldAxes, bool cplaneAxes)","summary":"Captures a part of the view contents to a bitmap allowing for visibility of grid and axes.","since":"5.0","parameters":[{"name":"size","summary":"The width and height of the returned bitmap."},{"name":"grid","summary":"True if the construction plane grid should be visible."},{"name":"worldAxes","summary":"True if the world axis should be visible."},{"name":"cplaneAxes","summary":"True if the construction plane close the grid should be visible."}],"returns":"A new bitmap."},{"signature":"System.Drawing.Bitmap CaptureToBitmap(Size size, DisplayModeDescription mode)","summary":"Capture View contents to a bitmap using a display mode description to define how drawing is performed.","since":"5.0","parameters":[{"name":"size","summary":"The width and height of the returned bitmap."},{"name":"mode","summary":"The display mode."}],"returns":"A new bitmap."},{"signature":"System.Drawing.Bitmap CaptureToBitmap(Size size, DisplayPipelineAttributes attributes)","summary":"Capture View contents to a bitmap using display attributes to define how drawing is performed.","since":"5.0","parameters":[{"name":"size","summary":"The width and height of the returned bitmap."},{"name":"attributes","summary":"The specific display mode attributes."}],"returns":"A new bitmap."},{"signature":"System.Drawing.Point ClientToScreen(Point clientPoint)","since":"5.0"},{"signature":"Geometry.Point2d ClientToScreen(Point2d clientPoint)","since":"5.0"},{"signature":"bool Close()","summary":"Remove this View from Rhino. DO NOT attempt to use this instance of this class after calling Close.","since":"5.0","returns":"True on success"},{"signature":"bool CreateShadedPreviewImage(string imagePath, Size size, bool ignoreHighlights, bool drawConstructionPlane, bool useGhostedShading)","summary":"Creates a bitmap preview image of model.","since":"5.0","parameters":[{"name":"imagePath","summary":"[in] The name of the bitmap file to create.  The extension of the imagePath controls the format of the bitmap file created (BMP, TGA, JPG, PCX, PNG, TIF)."},{"name":"size","summary":"[in] The width and height of the bitmap in pixels."},{"name":"ignoreHighlights","summary":"True if highlighted elements should be drawn normally."},{"name":"drawConstructionPlane","summary":"True if the CPlane should be drawn."},{"name":"useGhostedShading","summary":"True if ghosted shading (partially transparent shading) should be used."}],"returns":"True if successful."},{"signature":"bool CreateWireframePreviewImage(string imagePath, Size size, bool ignoreHighlights, bool drawConstructionPlane)","summary":"Creates a bitmap preview image of model.","since":"5.0","parameters":[{"name":"imagePath","summary":"[in] The name of the bitmap file to create.  The extension of the imagePath controls the format of the bitmap file created (BMP, TGA, JPG, PCX, PNG, TIF)."},{"name":"size","summary":"[in] The width and height of the bitmap in pixels."},{"name":"ignoreHighlights","summary":"True if highlighted elements should be drawn normally."},{"name":"drawConstructionPlane","summary":"True if the CPlane should be drawn."}],"returns":"True if successful."},{"signature":"bool Equals(object obj)"},{"signature":"int GetHashCode()"},{"signature":"bool MouseCaptured(bool bIncludeMovement)","summary":"Returns whether or not the mouse is captured in this view.","since":"6.0","parameters":[{"name":"bIncludeMovement","summary":"If captured, test if the mouse has moved between mouse button down and mouse button up."}],"returns":"True if captured, False otherwise."},{"signature":"void Redraw()","summary":"Redraws this view.","since":"5.0"},{"signature":"System.Drawing.Point ScreenToClient(Point screenPoint)","summary":"Converts a point in screen coordinates to client coordinates for this view.","since":"5.0","parameters":[{"name":"screenPoint","summary":"The 2D screen point."}],"returns":"A 2D point in client coordinates."},{"signature":"Geometry.Point2d ScreenToClient(Point2d screenPoint)","since":"5.8"},{"signature":"double SpeedTest(int frameCount, bool freezeDrawList, int direction, double angleDeltaRadians)","since":"5.8"}],"events":[{"signature":"static Create","since":"5.0"},{"signature":"static Destroy","since":"5.0"},{"signature":"static Modified","since":"7.0"},{"signature":"static Rename","since":"5.0"},{"signature":"static SetActive","since":"5.0"}]},{"namespace":"Rhino.Display","name":"RhinoViewport","dataType":"class","summary":"Displays geometry with a given projection. In standard modeling views there is a one to one relationship between RhinoView and RhinoViewports. In a page layout, there may be multiple RhinoViewports for a single layout.","interfaces":["IDisposable"],"constructors":[{"signature":"RhinoViewport()","since":"5.0"},{"signature":"RhinoViewport(RhinoViewport other)","since":"5.0"}],"properties":[{"signature":"Rectangle Bounds","summary":"Gets the size and location of the viewport, in pixels, relative to the parent view.","since":"5.0","property":["get"]},{"signature":"double Camera35mmLensLength","since":"5.0","property":["get","set"]},{"signature":"Vector3d CameraDirection","since":"5.0","property":["get"]},{"signature":"Point3d CameraLocation","since":"5.0","property":["get"]},{"signature":"Point3d CameraTarget","summary":"Viewport target point.","since":"5.0","property":["get"]},{"signature":"Vector3d CameraUp","since":"5.0","property":["get","set"]},{"signature":"Vector3d CameraX","summary":"Gets the \\"unit to the right\\" vector.","since":"5.0","property":["get"]},{"signature":"Vector3d CameraY","summary":"Gets the \\"unit up\\" vector.","since":"5.0","property":["get"]},{"signature":"Vector3d CameraZ","summary":"Gets the unit vector in CameraDirection.","since":"5.0","property":["get"]},{"signature":"uint ChangeCounter","summary":"The value of change counter is incremented every time the view projection or construction plane changes. The user can the mouse and nestable view manipulation commands to change a view at any time. The value of change counter can be used to detect these changes in code that is sensitive to the view projection.","since":"5.0","property":["get"]},{"signature":"bool ConstructionAxesVisible","since":"5.0","property":["get","set"]},{"signature":"bool ConstructionGridVisible","since":"5.0","property":["get","set"]},{"signature":"DisplayModeDescription DisplayMode","since":"5.0","property":["get","set"]},{"signature":"double FrustumAspect","summary":"Gets the width/height ratio of the frustum.","since":"5.0","property":["get"]},{"signature":"Guid Id","summary":"Unique id for this viewport.","since":"5.0","property":["get"]},{"signature":"bool IsParallelProjection","since":"5.0","property":["get"]},{"signature":"bool IsPerspectiveProjection","since":"5.0","property":["get"]},{"signature":"bool IsPlanView","summary":"True if construction plane z axis is parallel to camera direction.","since":"5.0","property":["get"]},{"signature":"bool IsTwoPointPerspectiveProjection","since":"5.0","property":["get"]},{"signature":"bool IsValidCamera","since":"5.0","property":["get"]},{"signature":"bool IsValidFrustum","since":"5.0","property":["get"]},{"signature":"string Name","summary":"Name associated with this viewport.","since":"5.0","property":["get","set"]},{"signature":"RhinoView ParentView","summary":"Gets the parent view, if there is one  Every RhinoView has an associated RhinoViewport that does all the 3d display work. Those associated viewports return the RhinoView as their parent view. However, RhinoViewports are used in other image creating contexts that do not have a parent RhinoView.  If you call ParentView, you MUST check for NULL return values.","since":"5.0","property":["get"]},{"signature":"double ScreenPortAspect","summary":"screen port\'s width/height.","since":"5.0","property":["get"]},{"signature":"Size Size","summary":"Gets or sets the height and width of the viewport (in pixels)","since":"5.0","property":["get","set"]},{"signature":"int UserStringCount","since":"6.18","property":["get"]},{"signature":"ViewportType ViewportType","since":"5.0","property":["get"]},{"signature":"string WallpaperFilename","since":"5.0","property":["get"]},{"signature":"bool WallpaperGrayscale","since":"5.0","property":["get"]},{"signature":"bool WallpaperVisible","since":"5.0","property":["get"]},{"signature":"bool WorldAxesVisible","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static RhinoViewport FromId(Guid id)","summary":"Call this method to get the viewport with the specified Id.","since":"6.0","parameters":[{"name":"id","summary":"Id to search for."}],"returns":"Returns a RhinoViewport if the Id is found otherwise null."},{"signature":"bool ChangeToParallelProjection(bool symmetricFrustum)","summary":"Use this function to change projections of valid viewports from perspective to parallel. It will make common additional adjustments to the frustum so the resulting views are similar. The camera location and direction will not be changed.","since":"5.0","parameters":[{"name":"symmetricFrustum","summary":"True if you want the resulting frustum to be symmetric."}],"returns":"If the current projection is parallel and bSymmetricFrustum, FrustumIsLeftRightSymmetric() and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned."},{"signature":"bool ChangeToPerspectiveProjection(bool symmetricFrustum, double lensLength)","summary":"Use this function to change projections of valid viewports from parallel to perspective. It will make common additional adjustments to the frustum and camera location so the resulting views are similar. The camera direction and target point are not be changed.","since":"5.0","parameters":[{"name":"symmetricFrustum","summary":"True if you want the resulting frustum to be symmetric."},{"name":"lensLength","summary":"(pass 50.0 when in doubt) 35 mm lens length to use when changing from parallel to perspective projections. If the current projection is perspective or lens_length is <= 0.0, then this parameter is ignored."}],"returns":"If the current projection is perspective and bSymmetricFrustum, FrustumIsLeftRightSymmetric() and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned."},{"signature":"bool ChangeToPerspectiveProjection(double targetDistance, bool symmetricFrustum, double lensLength)","summary":"Use this function to change projections of valid viewports from parallel to perspective. It will make common additional adjustments to the frustum and camera location so the resulting views are similar. The camera direction and target point are not be changed.","since":"5.0","parameters":[{"name":"targetDistance","summary":"If RhinoMath.UnsetValue this parameter is ignored. Otherwise it must be > 0 and indicates which plane in the current view frustum should be preserved."},{"name":"symmetricFrustum","summary":"True if you want the resulting frustum to be symmetric."},{"name":"lensLength","summary":"(pass 50.0 when in doubt) 35 mm lens length to use when changing from parallel to perspective projections. If the current projection is perspective or lens_length is <= 0.0, then this parameter is ignored."}],"returns":"If the current projection is perspective and bSymmetricFrustum, FrustumIsLeftRightSymmetric() and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned."},{"signature":"bool ChangeToTwoPointPerspectiveProjection(double lensLength)","summary":"Use this function to change projections of valid viewports to a two point perspective.  It will make common additional adjustments to the frustum and camera location and direction so the resulting views are similar.","since":"6.0","parameters":[{"name":"lensLength","summary":"(pass 50.0 when in doubt) 35 mm lens length to use when changing from parallel to perspective projections. If the current projection is perspective or lens_length is <= 0.0, then this parameter is ignored."}],"returns":"If the current projection is perspective and bSymmetricFrustum, FrustumIsLeftRightSymmetric() and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned."},{"signature":"bool ChangeToTwoPointPerspectiveProjection(double targetDistance, Vector3d up, double lensLength)","summary":"Use this function to change projections of valid viewports to a two point perspective.  It will make common additional adjustments to the frustum and camera location and direction so the resulting views are similar.","since":"6.0","parameters":[{"name":"targetDistance","summary":"If RhinoMath.UnsetValue this parameter is ignored. Otherwise it must be > 0 and indicates which plane in the current view frustum should be preserved."},{"name":"up","summary":"This direction will be the locked up direction.  Pass ON_3dVector::ZeroVector if you want to use the world axis direction that is closest to the current up direction. Pass CameraY() if you want to preserve the current up direction."},{"name":"lensLength","summary":"(pass 50.0 when in doubt) 35 mm lens length to use when changing from parallel to perspective projections. If the current projection is perspective or lens_length is <= 0.0, then this parameter is ignored."}],"returns":"If the current projection is perspective and bSymmetricFrustum, FrustumIsLeftRightSymmetric() and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned."},{"signature":"void ClearTraceImage()","summary":"Remove trace image (background bitmap) for this viewport if one exists.","since":"5.0"},{"signature":"System.Drawing.Point ClientToScreen(Point clientPoint)","since":"5.0"},{"signature":"System.Drawing.Point ClientToScreen(Point2d clientPoint)","since":"5.0"},{"signature":"Line ClientToWorld(Point clientPoint)","since":"5.0"},{"signature":"Line ClientToWorld(Point2d clientPoint)","since":"5.0"},{"signature":"Plane ConstructionPlane()","summary":"Simple plane information for this viewport\'s construction plane. If you want detailed construction plane information, use GetConstructionPlane.","since":"5.0"},{"signature":"void DeleteAllUserStrings()","since":"6.18"},{"signature":"bool DeleteUserString(string key)","since":"6.18"},{"signature":"void Dispose()","since":"5.0"},{"signature":"bool GetCameraAngle(out double halfDiagonalAngle, out double halfVerticalAngle, out double halfHorizontalAngle)","since":"5.0"},{"signature":"BoundingBox GetCameraExtents(IEnumerable<Point3d> points)","since":"5.0"},{"signature":"bool GetCameraFrame(out Plane frame)","summary":"Gets the camera plane.","since":"5.0","parameters":[{"name":"frame","summary":"A plane is assigned to this out parameter during the call, if the operation succeeded."}],"returns":"True if current camera orientation is valid."},{"signature":"DocObjects.ConstructionPlane GetConstructionPlane()","since":"5.0"},{"signature":"bool GetDepth(BoundingBox bbox, out double nearDistance, out double farDistance)","summary":"Gets near and far clipping distances of a bounding box.","since":"5.0","parameters":[{"name":"bbox","summary":"The bounding box."},{"name":"nearDistance","summary":"The near distance is assigned to this out parameter during this call."},{"name":"farDistance","summary":"The far distance is assigned to this out parameter during this call."}],"returns":"True if the bounding box intersects the view frustum and near_dist/far_dist were set. False if the bounding box does not intersect the view frustum."},{"signature":"bool GetDepth(Point3d point, out double distance)","summary":"Gets clipping distance of a point.","since":"5.0","parameters":[{"name":"point","summary":"A 3D point."},{"name":"distance","summary":"A computed distance is assigned to this out parameter if this call succeeds."}],"returns":"True if the point is in the view frustum and near_dist/far_dist were set. False if the bounding box does not intersect the view frustum."},{"signature":"bool GetDepth(Sphere sphere, out double nearDistance, out double farDistance)","summary":"Gets near and far clipping distances of a sphere.","since":"5.0","parameters":[{"name":"sphere","summary":"The sphere."},{"name":"nearDistance","summary":"The near distance is assigned to this out parameter during this call."},{"name":"farDistance","summary":"The far distance is assigned to this out parameter during this call."}],"returns":"True if the sphere intersects the view frustum and near_dist/far_dist were set. False if the sphere does not intersect the view frustum."},{"signature":"Point3d[] GetFarRect()","summary":"Get corners of far clipping plane rectangle.","since":"5.0","returns":"[left_bottom, right_bottom, left_top, right_top] points on success None on failure."},{"signature":"bool GetFrustum(out double left, out double right, out double bottom, out double top, out double nearDistance, out double farDistance)","summary":"Gets the view frustum.","since":"5.0","parameters":[{"name":"left","summary":"left < right."},{"name":"right","summary":"left < right."},{"name":"bottom","summary":"bottom < top."},{"name":"top","summary":"bottom < top."},{"name":"nearDistance","summary":"0 < nearDistance < farDistance."},{"name":"farDistance","summary":"0 < nearDistance < farDistance."}],"returns":"True if operation succeeded."},{"signature":"bool GetFrustumBottomPlane(out Plane plane)","summary":"Get bottom world frustum clipping plane.","since":"5.0","parameters":[{"name":"plane","summary":"frustum bottom side clipping plane. The normal points into the visible region of the frustum. If the projection is perspective, the origin is at the camera location, otherwise the origin is the point on the plane that is closest to the camera location."}],"returns":"True if camera and frustum are valid and plane was set."},{"signature":"BoundingBox GetFrustumBoundingBox()","since":"5.0"},{"signature":"bool GetFrustumCenter(out Point3d center)","summary":"Returns world coordinates of frustum\'s center.","since":"5.0","parameters":[{"name":"center","summary":"The center coordinate is assigned to this out parameter if this call succeeds."}],"returns":"True if the center was successfully computed."},{"signature":"bool GetFrustumFarPlane(out Plane plane)","summary":"Get far clipping plane.","since":"5.0","parameters":[{"name":"plane","summary":"far clipping plane if camera and frustum are valid. The plane\'s frame is the same as the camera\'s frame. The origin is located at the intersection of the camera direction ray and the far clipping plane."}],"returns":"True if camera and frustum are valid."},{"signature":"bool GetFrustumLeftPlane(out Plane plane)","summary":"Get left world frustum clipping plane.","since":"5.0","parameters":[{"name":"plane","summary":"frustum left side clipping plane. The normal points into the visible region of the frustum. If the projection is perspective, the origin is at the camera location, otherwise the origin is the point on the plane that is closest to the camera location."}],"returns":"True if camera and frustum are valid and plane was set."},{"signature":"bool GetFrustumLine(double screenX, double screenY, out Line worldLine)","summary":"Gets the world coordinate line in the view frustum that projects to a point on the screen.","since":"5.0","parameters":[{"name":"screenX","summary":"(screenx,screeny) = screen location."},{"name":"screenY","summary":"(screenx,screeny) = screen location."},{"name":"worldLine","summary":"3d world coordinate line segment starting on the near clipping plane and ending on the far clipping plane."}],"returns":"True if successful. False if view projection or frustum is invalid."},{"signature":"bool GetFrustumNearPlane(out Plane plane)","summary":"Get near clipping plane.","since":"5.0","parameters":[{"name":"plane","summary":"near clipping plane if camera and frustum are valid. The plane\'s frame is the same as the camera\'s frame. The origin is located at the intersection of the camera direction ray and the near clipping plane."}],"returns":"True if camera and frustum are valid."},{"signature":"bool GetFrustumRightPlane(out Plane plane)","summary":"Get right world frustum clipping plane.","since":"5.0","parameters":[{"name":"plane","summary":"frustum right side clipping plane. The normal points into the visible region of the frustum. If the projection is perspective, the origin is at the camera location, otherwise the origin is the point on the plane that is closest to the camera location."}],"returns":"True if camera and frustum are valid and plane was set."},{"signature":"bool GetFrustumTopPlane(out Plane plane)","summary":"Get top world frustum clipping plane.","since":"5.0","parameters":[{"name":"plane","summary":"frustum top side clipping plane. The normal points into the visible region of the frustum. If the projection is perspective, the origin is at the camera location, otherwise the origin is the point on the plane that is closest to the camera location."}],"returns":"True if camera and frustum are valid and plane was set."},{"signature":"Point3d[] GetNearRect()","summary":"Get corners of near clipping plane rectangle.","since":"5.0","returns":"[left_bottom, right_bottom, left_top, right_top] points on success None on failure."},{"signature":"Transform GetPickTransform(int clientX, int clientY)","summary":"Takes a rectangle in screen coordinates and returns a transformation that maps the 3d frustum defined by the rectangle to a -1/+1 clipping coordinate box. This takes a single point and inflates it by Rhino.ApplicationSettings.ModelAidSettings.MousePickBoxRadius to define the screen rectangle.","since":"5.0","parameters":[{"name":"clientX","summary":"The client point X coordinate."},{"name":"clientY","summary":"The client point Y coordinate."}],"returns":"A transformation matrix."},{"signature":"Transform GetPickTransform(Point clientPoint)","summary":"Takes a rectangle in screen coordinates and returns a transformation that maps the 3d frustum defined by the rectangle to a -1/+1 clipping coordinate box. This takes a single point and inflates it by Rhino.ApplicationSettings.ModelAidSettings.MousePickBoxRadius to define the screen rectangle.","since":"5.0","parameters":[{"name":"clientPoint","summary":"The client point."}],"returns":"A transformation matrix."},{"signature":"Transform GetPickTransform(Rectangle clientRectangle)","summary":"Takes a rectangle in screen coordinates and returns a transformation that maps the 3d frustum defined by the rectangle to a -1/+1 clipping coordinate box.","since":"5.0","parameters":[{"name":"clientRectangle","summary":"The client rectangle."}],"returns":"A transformation matrix."},{"signature":"bool GetScreenPort(out int portLeft, out int portRight, out int portBottom, out int portTop, out int portNear, out int portFar)","summary":"Location of viewport in pixels.  These are provided so you can set the port you are using and get the appropriate transformations to and from screen space.","since":"5.0","parameters":[{"name":"portLeft","summary":"portLeft != portRight."},{"name":"portRight","summary":"portLeft != portRight."},{"name":"portBottom","summary":"portTop != portBottom."},{"name":"portTop","summary":"portTop != portBottom."},{"name":"portNear","summary":"The viewport near value."},{"name":"portFar","summary":"The viewport far value."}],"returns":"True if the operation is successful."},{"signature":"Transform GetTransform(CoordinateSystem sourceSystem, CoordinateSystem destinationSystem)","summary":"Gets a transform from origin coordinate system to a target coordinate system.","since":"5.0","parameters":[{"name":"sourceSystem","summary":"The origin coordinate system."},{"name":"destinationSystem","summary":"The target coordinate system."}],"returns":"4x4 transformation matrix (acts on the left) Identity matrix is returned if this function fails."},{"signature":"string GetUserString(string key)","summary":"Gets a user string.","since":"6.18","parameters":[{"name":"key","summary":"id used to retrieve the string."}],"returns":"string associated with the key if successful. None if no key was found."},{"signature":"System.Collections.Specialized.NameValueCollection GetUserStrings()","summary":"Gets an independent copy of the collection of (user text key, user text value) pairs attached to this object.","since":"6.18","returns":"A collection of key strings and values strings. This"},{"signature":"bool GetWorldToScreenScale(Point3d pointInFrustum, out double pixelsPerUnit)","summary":"Gets the world to screen size scaling factor at a point in frustum.","since":"5.0","parameters":[{"name":"pointInFrustum","summary":"A point in frustum."},{"name":"pixelsPerUnit","summary":"scale = number of pixels per world unit at the 3d point.  \\nThis out parameter is assigned during this call."}],"returns":"True if the operation is successful."},{"signature":"bool IsVisible(BoundingBox bbox)","summary":"Returns True if some portion of a world coordinate bounding box is potentially visible in the viewing frustum.","since":"5.0","parameters":[{"name":"bbox","summary":"A bounding box that is tested for visibility."}],"returns":"True if the box is potentially visible; otherwise false."},{"signature":"bool IsVisible(Point3d point)","summary":"Determines if a world coordinate point is visible in the viewing frustum.","since":"5.0","parameters":[{"name":"point","summary":"A point that is tested for visibility."}],"returns":"True if the point is visible; otherwise false."},{"signature":"bool KeyboardDolly(bool leftRight, double amount)","summary":"Emulates the keyboard arrow key in terms of interaction.","since":"5.0","parameters":[{"name":"leftRight","summary":"left/right dolly if true, up/down dolly if false."},{"name":"amount","summary":"The dolly amount."}],"returns":"True if operation succeeded; otherwise false."},{"signature":"bool KeyboardDollyInOut(double amount)","summary":"Emulates the keyboard arrow key in terms of interaction.","since":"5.0","parameters":[{"name":"amount","summary":"The dolly amount."}],"returns":"True if operation succeeded; otherwise false."},{"signature":"bool KeyboardRotate(bool leftRight, double angleRadians)","summary":"Emulates the keyboard arrow key in terms of interaction.","since":"5.0","parameters":[{"name":"leftRight","summary":"left/right rotate if true, up/down rotate if false."},{"name":"angleRadians","summary":"If less than 0, rotation is to left or down. If greater than 0, rotation is to right or up."}],"returns":"True if operation succeeded; otherwise false."},{"signature":"bool Magnify(double magnificationFactor, bool mode)","summary":"Zooms or dollies in order to scale the viewport projection of observed objects.","since":"5.0","parameters":[{"name":"magnificationFactor","summary":"The scale factor."},{"name":"mode","summary":"False = perform a \\"dolly\\" magnification by moving the camera towards/away from the target so that the amount of the screen subtended by an object changes. True = perform a \\"zoom\\" magnification by adjusting the \\"lens\\" angle"}],"returns":"True if operation succeeded; otherwise false."},{"signature":"bool Magnify(double magnificationFactor, bool mode, Point fixedScreenPoint)","summary":"Zooms or dollies in order to scale the viewport projection of observed objects.","since":"5.0","parameters":[{"name":"magnificationFactor","summary":"The scale factor."},{"name":"mode","summary":"False = perform a \\"dolly\\" magnification by moving the camera towards/away from the target so that the amount of the screen subtended by an object changes. True = perform a \\"zoom\\" magnification by adjusting the \\"lens\\" angle"},{"name":"fixedScreenPoint","summary":"A point in the screen that should remain fixed."}],"returns":"True if operation succeeded; otherwise false."},{"signature":"bool MouseAdjustLensLength(Point mousePreviousPoint, Point mouseCurrentPoint, bool moveTarget)","summary":"Adjusts the camera lens length.","since":"6.0","parameters":[{"name":"mousePreviousPoint","summary":"The mouse previous point."},{"name":"mouseCurrentPoint","summary":"The mouse current point."},{"name":"moveTarget","summary":"Should this operation move the target?"}]},{"signature":"bool MouseDollyZoom(Point mousePreviousPoint, Point mouseCurrentPoint)","summary":"Zooms lens (thus adjusting the field of view) while moving the camera.","since":"5.0","parameters":[{"name":"mousePreviousPoint","summary":"The mouse previous point."},{"name":"mouseCurrentPoint","summary":"The mouse current point."}]},{"signature":"bool MouseInOutDolly(Point mousePreviousPoint, Point mouseCurrentPoint)","summary":"Moves the camera towards or away from the view maintaining focus on the view.","since":"5.0","parameters":[{"name":"mousePreviousPoint","summary":"The mouse previous point."},{"name":"mouseCurrentPoint","summary":"The mouse current point."}]},{"signature":"bool MouseLateralDolly(Point mousePreviousPoint, Point mouseCurrentPoint)","summary":"Pans the camera","since":"6.0","parameters":[{"name":"mousePreviousPoint","summary":"The mouse previous point."},{"name":"mouseCurrentPoint","summary":"The mouse current point."}]},{"signature":"bool MouseMagnify(Point mousePreviousPoint, Point mouseCurrentPoint)","summary":"Moves the camera towards or away from the view.","since":"5.0","parameters":[{"name":"mousePreviousPoint","summary":"The mouse previous point."},{"name":"mouseCurrentPoint","summary":"The mouse current point."}]},{"signature":"bool MouseRotateAroundTarget(Point mousePreviousPoint, Point mouseCurrentPoint)","summary":"Rotates the viewport around target.","since":"5.0","parameters":[{"name":"mousePreviousPoint","summary":"The mouse previous point."},{"name":"mouseCurrentPoint","summary":"The mouse current point."}]},{"signature":"bool MouseRotateCamera(Point mousePreviousPoint, Point mouseCurrentPoint)","summary":"Rotates the view around the camera location.","since":"5.0","parameters":[{"name":"mousePreviousPoint","summary":"The mouse previous point."},{"name":"mouseCurrentPoint","summary":"The mouse current point."}]},{"signature":"bool MouseTilt(Point mousePreviousPoint, Point mouseCurrentPoint)","summary":"Tilts the camera view.","since":"5.0","parameters":[{"name":"mousePreviousPoint","summary":"The mouse previous point."},{"name":"mouseCurrentPoint","summary":"The mouse current point."}]},{"signature":"bool NextConstructionPlane()","summary":"Sets the construction plane to the plane that was active before the last call to PreviousConstructionPlane.","since":"5.0","returns":"True if successful."},{"signature":"bool NextViewProjection()","summary":"Sets the view projection and target to the settings that were active before the last call to PrevView.","since":"5.0","returns":"True if the view stack was popped."},{"signature":"bool PopConstructionPlane()","summary":"Sets the construction plane to the plane that was active before the last call to PushConstructionPlane.","since":"5.0","returns":"True if a construction plane was popped."},{"signature":"bool PopViewProjection()","summary":"Sets the view projection and target to the settings at the top of the view stack and removes those settings from the view stack.","since":"5.0","returns":"True if there were settings that could be popped from the stack."},{"signature":"bool PreviousConstructionPlane()","summary":"Sets the construction plane to the plane that was active before the last call to NextConstructionPlane or SetConstructionPlane.","since":"5.0","returns":"True if successful."},{"signature":"bool PreviousViewProjection()","summary":"Sets the view projection and target to the settings that were active before the last call to NextViewProjection.","since":"5.0","returns":"True if the view stack was popped."},{"signature":"void PushConstructionPlane(ConstructionPlane cplane)","summary":"Pushes the current construction plane on the viewport\'s construction plane stack and sets the construction plane to cplane.","since":"5.0","parameters":[{"name":"cplane","summary":"The construction plane to push."}]},{"signature":"bool PushViewInfo(ViewInfo viewinfo, bool includeTraceImage)","since":"5.0"},{"signature":"void PushViewProjection()","summary":"Appends the current view projection and target to the viewport\'s view stack.","since":"5.0"},{"signature":"bool Rotate(double angleRadians, Vector3d rotationAxis, Point3d rotationCenter)","summary":"Rotates about the specified axis. A positive rotation angle results in a counter-clockwise rotation about the axis (right hand rule).","since":"5.0","parameters":[{"name":"angleRadians","summary":"angle of rotation in radians."},{"name":"rotationAxis","summary":"direction of the axis of rotation."},{"name":"rotationCenter","summary":"point on the axis of rotation."}],"returns":"True if geometry successfully rotated."},{"signature":"System.Drawing.Point ScreenToClient(Point screenPoint)","since":"5.0"},{"signature":"void SetCameraDirection(Vector3d cameraDirection, bool updateTargetLocation)","summary":"Set viewport camera direction. By default the target location is changed so that the vector from the camera location to the target is parallel to the camera direction.","since":"5.0","parameters":[{"name":"cameraDirection","summary":"new camera direction."},{"name":"updateTargetLocation","summary":"if true, the target location is changed so that the vector from the camera location to the target is parallel to the camera direction. If false, the target location is not changed. See the remarks section of RhinoViewport.SetTarget for important details."}]},{"signature":"void SetCameraLocation(Point3d cameraLocation, bool updateTargetLocation)","summary":"Set viewport camera location. By default the target location is changed so that the vector from the camera location to the target is parallel to the camera direction vector.","since":"5.0","parameters":[{"name":"cameraLocation","summary":"new camera location."},{"name":"updateTargetLocation","summary":"if true, the target location is changed so that the vector from the camera location to the target is parallel to the camera direction vector. If false, the target location is not changed. See the remarks section of RhinoViewport.SetTarget for important details."}]},{"signature":"void SetCameraLocations(Point3d targetLocation, Point3d cameraLocation)","summary":"Set viewport camera location and target location. The camera direction vector is changed so that it is parallel to the vector from the camera location to the target location.","since":"5.0","parameters":[{"name":"targetLocation","summary":"new target location."},{"name":"cameraLocation","summary":"new camera location."}]},{"signature":"void SetCameraTarget(Point3d targetLocation, bool updateCameraLocation)","summary":"Set viewport target point. By default the camera location is translated so that the camera direction vector is parallel to the vector from the camera location to the target location.","since":"5.0","parameters":[{"name":"targetLocation","summary":"new target location."},{"name":"updateCameraLocation","summary":"if true, the camera location is translated so that the camera direction vector is parallel to the vector from the camera location to the target location. If false, the camera location is not changed."}]},{"signature":"void SetClippingPlanes(BoundingBox box)","summary":"Sets optimal clipping planes to view objects in a world coordinate 3d bounding box.","since":"5.0","parameters":[{"name":"box","summary":"The bounding box"}]},{"signature":"void SetConstructionPlane(ConstructionPlane cplane)","summary":"Sets the construction plane to cplane.","since":"5.0","parameters":[{"name":"cplane","summary":"The construction plane to set."}]},{"signature":"void SetConstructionPlane(Plane plane)","since":"5.0"},{"signature":"bool SetProjection(DefinedViewportProjection projection, string viewName, bool updateConstructionPlane)","summary":"Set viewport to a defined projection.","since":"5.0","parameters":[{"name":"projection","summary":"The \\"standard\\" projection type."},{"name":"viewName","summary":"If not None or empty, the name is set."},{"name":"updateConstructionPlane","summary":"If true, the construction plane is set to the viewport plane."}],"returns":"True if successful."},{"signature":"bool SetToPlanView(Point3d planeOrigin, Vector3d planeXaxis, Vector3d planeYaxis, bool setConstructionPlane)","since":"5.0"},{"signature":"bool SetTraceImage(string bitmapFileName, Plane plane, double width, double height, bool grayscale, bool filtered)","summary":"Set trace image (background bitmap) for this viewport.","since":"5.0","parameters":[{"name":"bitmapFileName","summary":"The bitmap file name."},{"name":"plane","summary":"A picture plane."},{"name":"width","summary":"The picture width."},{"name":"height","summary":"The picture height."},{"name":"grayscale","summary":"True if the picture should be in grayscale."},{"name":"filtered","summary":"True if image should be filtered (bilinear) before displayed."}],"returns":"True if successful."},{"signature":"bool SetUserString(string key, string value)","summary":"Attach a user string (key,value combination) to this geometry.","since":"6.18","parameters":[{"name":"key","summary":"id used to retrieve this string."},{"name":"value","summary":"string associated with key. If null, the key will be removed"}],"returns":"True on success."},{"signature":"bool SetViewProjection(ViewportInfo projection, bool updateTargetLocation)","summary":"Sets the viewport camera projection.","since":"5.0","parameters":[{"name":"projection","summary":"The \\"standard\\" projection type."},{"name":"updateTargetLocation","summary":"if true, the target location is changed so that the vector from the camera location to the target is parallel to the camera direction vector.  If false, the target location is not changed."}],"returns":"True on success."},{"signature":"bool SetWallpaper(string imageFilename, bool grayscale)","since":"5.0"},{"signature":"bool SetWallpaper(string imageFilename, bool grayscale, bool visible)","since":"5.0"},{"signature":"Point2d WorldToClient(Point3d worldPoint)","summary":"Convert a point from world coordinates in the viewport to a 2d screen point in the local coordinates of the viewport (X/Y of point is relative to top left corner of viewport on screen)","since":"5.0","parameters":[{"name":"worldPoint","summary":"The 3D point in world coordinates."}],"returns":"The 2D point on the screen."},{"signature":"bool ZoomBoundingBox(BoundingBox box)","summary":"Zooms the viewport to the given bounding box.","since":"5.0","parameters":[{"name":"box","summary":"The bounding box to zoom."}],"returns":"True if operation succeeded; otherwise false."},{"signature":"bool ZoomExtents()","summary":"Dollies the camera location and so that the view frustum contains all of the selected document objects that can be seen in view. If the projection is perspective, the camera angle is not changed.","since":"5.0","returns":"True if successful."},{"signature":"bool ZoomExtentsSelected()","summary":"Dollies the camera location and so that the view frustum contains all of the selected document objects that can be seen in view. If the projection is perspective, the camera angle is not changed.","since":"5.0","returns":"True if successful."}]},{"namespace":"Rhino.Display","name":"ShaderLanguage","dataType":"enum","summary":"Graphics Shader Language https://en.wikipedia.org/wiki/OpenGL_Shading_Language#Versions","values":[{"signature":"GLSL_ES100 = 1","summary":"Used for OpenGL ES 2.0 and WebGL 1.0"},{"signature":"GLSL_ES300 = 2","summary":"Used for OpenGL ES 3.0 and WebGL 2.0"},{"signature":"GLSL_ES310 = 3"},{"signature":"GLSL_120 = 4","summary":"Used for OpenGL 2.1"},{"signature":"GLSL_130 = 5","summary":"Used for OpenGL 3.0"},{"signature":"GLSL_140 = 6","summary":"Used for OpenGL 3.1"},{"signature":"GLSL_150 = 7","summary":"Used for OpenGL 3.2"},{"signature":"GLSL_330 = 8","summary":"Used for OpenGL 3.3"},{"signature":"GLSL_400 = 9","summary":"Used for OpenGL 4.0"},{"signature":"GLSL_410 = 10","summary":"Used for OpenGL 4.1"},{"signature":"GLSL_420 = 11","summary":"Used for OpenGL 4.2"},{"signature":"GLSL_430 = 12","summary":"Used for OpenGL 4.3"},{"signature":"GLSL_440 = 13","summary":"Used for OpenGL 4.4"},{"signature":"Metal = 14","summary":"Metal for Apple"}]},{"namespace":"Rhino.Display","name":"StereoContext","dataType":"enum","since":"7.0","values":[{"signature":"None = 0"},{"signature":"LeftEye = 1"},{"signature":"RightEye = 2"},{"signature":"BothEyes = 3"}]},{"namespace":"Rhino.Display","name":"Text3d","dataType":"class","summary":"3D aligned text with font settings.","interfaces":["IDisposable"],"constructors":[{"signature":"Text3d(string text)","summary":"Constructs a new instance of Text3d.","since":"5.0","parameters":[{"name":"text","summary":"Text string."}]},{"signature":"Text3d(string text, Plane plane, double height)","summary":"Constructs a new instance of Text3d.","since":"5.0","parameters":[{"name":"text","summary":"Text string."},{"name":"plane","summary":"3D Plane for text."},{"name":"height","summary":"Height (in units) for text."}]}],"properties":[{"signature":"bool Bold","summary":"Gets or sets whether this Text3d object will be drawn in Bold.","since":"5.0","property":["get","set"]},{"signature":"BoundingBox BoundingBox","summary":"Gets the bounding box for this Text3d object.","since":"5.0","property":["get"]},{"signature":"string FontFace","summary":"Gets or sets the FontFace name.","since":"5.0","property":["get","set"]},{"signature":"double Height","summary":"Gets or sets the height (in units) of this Text3d object. The height should be a positive number larger than zero.","since":"5.0","property":["get","set"]},{"signature":"TextHorizontalAlignment HorizontalAlignment","summary":"Horizontal alignment that this Text3d is drawn with","since":"6.4","property":["get","set"]},{"signature":"bool Italic","summary":"Gets or sets whether this Text3d object will be drawn in Italics.","since":"5.0","property":["get","set"]},{"signature":"string Text","summary":"Gets or sets the text string for this Text3d object.","since":"5.0","property":["get","set"]},{"signature":"Plane TextPlane","summary":"Gets or sets the 3D aligned plane for this Text3d object.","since":"5.0","property":["get","set"]},{"signature":"TextVerticalAlignment VerticalAlignment","summary":"Vertical alignment that this Text3d is drawn with","since":"6.4","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"}]},{"namespace":"Rhino.Display","name":"ViewCapture","dataType":"class","constructors":[{"signature":"ViewCapture()","since":"6.0"}],"properties":[{"signature":"bool DrawAxes","since":"6.0","property":["get","set"]},{"signature":"bool DrawGrid","since":"6.0","property":["get","set"]},{"signature":"bool DrawGridAxes","since":"6.0","property":["get","set"]},{"signature":"int Height","summary":"Height of capture in Pixels","since":"6.0","property":["get","set"]},{"signature":"bool Preview","since":"6.0","property":["get","set"]},{"signature":"int RealtimeRenderPasses","since":"6.0","property":["get","set"]},{"signature":"bool ScaleScreenItems","since":"6.0","property":["get","set"]},{"signature":"bool TransparentBackground","since":"6.0","property":["get","set"]},{"signature":"int Width","summary":"Width of capture in Pixels","since":"6.0","property":["get","set"]}],"methods":[{"signature":"static Bitmap CaptureToBitmap(ViewCaptureSettings settings)","since":"6.0"},{"signature":"static System.Xml.XmlDocument CaptureToSvg(ViewCaptureSettings settings)","since":"6.0"},{"signature":"Bitmap CaptureToBitmap(RhinoView sourceView)","since":"6.0"}]},{"namespace":"Rhino.Display","name":"ViewCaptureSettings","dataType":"class","summary":"Used to hold the information required to generate high resolution output of a RhinoViewport.  This is used for generating paper prints or image files","interfaces":["IDisposable"],"constructors":[{"signature":"ViewCaptureSettings()","since":"6.0"},{"signature":"ViewCaptureSettings(RhinoPageView sourcePageView, double dpi)","since":"6.0"},{"signature":"ViewCaptureSettings(RhinoView sourceView, Size mediaSize, double dpi)","since":"6.0"}],"properties":[{"signature":"double ArrowheadSizeMillimeters","summary":"arrowhead size in millimeters","since":"6.15","property":["get","set"]},{"signature":"Rectangle CropRectangle","summary":"Actual area of output rectangle that view capture is sent to.","since":"6.0","property":["get"]},{"signature":"double DefaultPrintWidthMillimeters","summary":"Line thickness used to print objects with no defined thickness (in mm)","since":"6.15","property":["get","set"]},{"signature":"RhinoDoc Document","since":"6.15","property":["get","set"]},{"signature":"bool DrawAxis","since":"6.0","property":["get","set"]},{"signature":"bool DrawBackground","since":"6.0","property":["get","set"]},{"signature":"bool DrawBackgroundBitmap","since":"6.2","property":["get","set"]},{"signature":"bool DrawClippingPlanes","since":"6.0","property":["get","set"]},{"signature":"bool DrawGrid","since":"6.0","property":["get","set"]},{"signature":"bool DrawLights","since":"6.0","property":["get","set"]},{"signature":"bool DrawLockedObjects","since":"6.0","property":["get","set"]},{"signature":"bool DrawMargins","since":"6.0","property":["get","set"]},{"signature":"bool DrawSelectedObjectsOnly","since":"6.0","property":["get","set"]},{"signature":"bool DrawWallpaper","since":"6.2","property":["get","set"]},{"signature":"bool IsScaleToFit","summary":"Returns True if the model has been scaled to fit.","since":"6.21","property":["get"]},{"signature":"bool IsValid","since":"6.0","property":["get"]},{"signature":"Size MediaSize","summary":"Total size of the image or page in dots","since":"6.0","property":["get"]},{"signature":"int ModelScaleType","since":"6.21","property":["get","set"]},{"signature":"AnchorLocation OffsetAnchor","since":"6.2","property":["get","set"]},{"signature":"ColorMode OutputColor","since":"6.8","property":["get","set"]},{"signature":"double PointSizeMillimeters","summary":"size of point objects in millimeters if scale <= 0 the size is minimized so points are always drawn as small as possible","since":"6.15","property":["get","set"]},{"signature":"bool RasterMode","since":"6.17","property":["get","set"]},{"signature":"double Resolution","summary":"Capture \\"density\\" in dots per inch","since":"6.0","property":["get","set"]},{"signature":"bool UsePrintWidths","since":"6.15","property":["get","set"]},{"signature":"double WireThicknessScale","summary":"scaling factor to apply to object print widths (typically 1.0). This is helpful when printing something at 1/2 scale and having all of the curves print 1/2 as thick","since":"6.15","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"},{"signature":"bool GetMargins(UnitSystem lengthUnits, out double left, out double top, out double right, out double bottom)","summary":"Get distances from the edge of the paper (MediaSize) to the CropRectangle in a defined unit system","since":"6.2","parameters":[{"name":"lengthUnits","summary":"Units to get distances in"},{"name":"left","summary":"Distance from left edge of paper to left edge of CropRectangle"},{"name":"top","summary":"Distance from top edge of paper to top edge of CropRectangle"},{"name":"right","summary":"Distance from right edge of paper to right edge of CropRectangle"},{"name":"bottom","summary":"Distance from bottom edge of paper to bottom edge of CropRectangle"}],"returns":"True if successful. False if unsuccessful (this could happen if there is no set device_dpi)"},{"signature":"double GetModelScale(UnitSystem pageUnits, UnitSystem modelUnits)","summary":"Returns the model scale factor.","since":"6.21","parameters":[{"name":"pageUnits","summary":"The current page units."},{"name":"modelUnits","summary":"The current model units."}],"returns":"The model scale factor."},{"signature":"void GetOffset(UnitSystem lengthUnits, out bool fromMargin, out double x, out double y)","since":"6.2"},{"signature":"void SetLayout(Size mediaSize, Rectangle cropRectangle)","since":"6.0"},{"signature":"bool SetMargins(UnitSystem lengthUnits, double left, double top, double right, double bottom)","summary":"Set distances from the edge of the paper (MediaSize) to the CropRectange in a defined unit system","since":"6.2","parameters":[{"name":"lengthUnits","summary":"Units that left, top, right, and bottom are defined in"},{"name":"left","summary":"Distance from left edge of paper to left edge of CropRectangle"},{"name":"top","summary":"Distance from top edge of paper to top edge of CropRectangle"},{"name":"right","summary":"Distance from right edge of paper to right edge of CropRectangle"},{"name":"bottom","summary":"Distance from bottom edge of paper to bottom edge of CropRectangle"}],"returns":"True if successful. False if unsuccessful (this could happen if there is no set device_dpi)"},{"signature":"void SetModelScaleToFit(bool promptOnChange)","summary":"Scales the model to fit.","since":"6.21","parameters":[{"name":"promptOnChange","summary":"Prompt the user if the model scale will change."}]},{"signature":"void SetModelScaleToValue(double scale)","summary":"Sets the model scale to a value.","since":"6.21","parameters":[{"name":"scale","summary":"The scale value."}]},{"signature":"void SetOffset(UnitSystem lengthUnits, bool fromMargin, double x, double y)","since":"6.2"},{"signature":"void SetViewport(RhinoViewport viewport)","since":"6.15"}]},{"namespace":"Rhino.Display","name":"ViewCaptureSettings.AnchorLocation","dataType":"enum","since":"6.2","values":[{"signature":"LowerLeft = UnsafeNativeMethods.PrintInfoAnchor.LowerLeft"},{"signature":"LowerRight = UnsafeNativeMethods.PrintInfoAnchor.LowerRight"},{"signature":"UpperLeft = UnsafeNativeMethods.PrintInfoAnchor.UpperLeft"},{"signature":"UpperRight = UnsafeNativeMethods.PrintInfoAnchor.UpperRight"},{"signature":"Center = UnsafeNativeMethods.PrintInfoAnchor.Center"}]},{"namespace":"Rhino.Display","name":"ViewCaptureSettings.ColorMode","dataType":"enum","since":"6.8","values":[{"signature":"DisplayColor"},{"signature":"PrintColor"},{"signature":"BlackAndWhite"}]},{"namespace":"Rhino.Display","name":"ViewEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"RhinoView View","since":"5.0","property":["get"]}]},{"namespace":"Rhino.Display","name":"ViewportType","dataType":"enum","since":"5.0","values":[{"signature":"StandardModelingViewport = 0"},{"signature":"PageViewMainViewport = 1"},{"signature":"DetailViewport = 2"}]},{"namespace":"Rhino.Display","name":"VisualAnalysisMode","dataType":"class","summary":"Represents a base class for visual analysis modes.  \\nThis class is abstract.","properties":[{"signature":"static Guid RhinoCurvatureColorAnalyisModeId","summary":"Id for Rhino\'s built-in curvature color analysis mode.  Surface curvature is shown using False color mapping.","since":"5.0","property":["get"]},{"signature":"static Guid RhinoCurvatureGraphAnalysisModeId","summary":"Id for Rhino\'s built-in curvature graphs analysis mode. Curvature hair is shown on curves and surfaces.","since":"5.0","property":["get"]},{"signature":"static Guid RhinoDraftAngleAnalysisModeId","summary":"Id for Rhino\'s built-in draft angle analysis mode.  Draft angle is displayed using False colors.","since":"5.0","property":["get"]},{"signature":"static Guid RhinoEdgeAnalysisModeId","summary":"Id for Rhino\'s built-in edge analysis mode. Brep and mesh edges are shown in a selected color.","since":"5.0","property":["get"]},{"signature":"static Guid RhinoEdgeContinuityAlalysisModeId","summary":"Id for Rhino\'s built-in edge continuity analysis mode.","since":"7.0","property":["get"]},{"signature":"static Guid RhinoEmapAnalysisModeId","summary":"Id for Rhino\'s built-in emap analysis mode.  An environment map is shown on surfaces and meshes.","since":"5.0","property":["get"]},{"signature":"static Guid RhinoThicknessAnalysisModeId","summary":"Id for Rhino\'s built-in thickness analysis mode.","since":"5.0","property":["get"]},{"signature":"static Guid RhinoZebraStripeAnalysisModeId","summary":"Id for Rhino\'s built-in zebra stripe analysis mode. Zebra stripes are shown on surfaces and meshes.","since":"5.0","property":["get"]},{"signature":"Guid Id","summary":"Gets the visual analysis mode GUID. The Guid is specified with the System.Runtime.InteropServices.GuidAttribute applied to the class.","since":"5.0","property":["get"]},{"signature":"string Name","summary":"Gets the name of the analysis mode. It is used by the _What command and the object properties details window to describe the object.","since":"5.0","property":["get"]},{"signature":"bool ShowIsoCurves","summary":"Gets True if this visual analysis mode will show isocuves on shaded surface objects.  Often a mode\'s user interface will provide a way to change this setting.  \\nThe default is false.","since":"5.0","property":["get"]},{"signature":"AnalysisStyle Style","summary":"Gets the visual analysis mode style.","since":"5.0","property":["get"]}],"methods":[{"signature":"static bool AdjustAnalysisMeshes(RhinoDoc doc, Guid analysisModeId)","summary":"Interactively adjusts surface analysis meshes of objects using a Rhino built-in analysis mode.","since":"7.0","parameters":[{"name":"doc","summary":"The Rhino document."},{"name":"analysisModeId","summary":"The id of the analysis mode."}],"returns":"True if successful, False otherwise."},{"signature":"static VisualAnalysisMode Find(Guid id)","summary":"Finds a visual analysis mode by guid.","since":"5.0","parameters":[{"name":"id","summary":"The globally unique identifier to search for."}],"returns":"The found visual analysis mode, or None if it was not found, or on error."},{"signature":"static VisualAnalysisMode Find(Type t)","summary":"Finds a visual analysis mode by type.","since":"5.0","parameters":[{"name":"t","summary":"A visual analysis mode type."}],"returns":"A visual analysis mode on success, or None on error."},{"signature":"static VisualAnalysisMode Register(Type customAnalysisModeType)","summary":"Registers a custom visual analysis mode for use in Rhino.  It is OK to call register multiple times for a single custom analysis mode type, since subsequent register calls will notice that the type has already been registered.","since":"5.0","parameters":[{"name":"customAnalysisModeType","summary":"Must be a type that is a subclass of VisualAnalysisMode."}],"returns":"An instance of registered analysis mode on success."},{"signature":"void EnableUserInterface(bool on)","summary":"Turns the analysis mode\'s user interface on and off. For Rhino\'s built in modes this opens or closes the modeless dialog that controls the analysis mode\'s display settings.","since":"5.0","parameters":[{"name":"on","summary":"True if the interface should be shown; False if it should be concealed."}]},{"signature":"bool ObjectSupportsAnalysisMode(RhinoObject obj)","summary":"Gets a value indicating if this visual analysis mode can be used on a given Rhino object.","since":"5.0","parameters":[{"name":"obj","summary":"The object to be tested."}],"returns":"True if this mode can indeed be used on the object; otherwise false."}]},{"namespace":"Rhino.Display","name":"VisualAnalysisMode.AnalysisStyle","dataType":"enum","summary":"Contains enumerated values for analysis styles, such as wireframe, texture or False colors..","since":"5.0","values":[{"signature":"Wireframe = 1","summary":"The analysis is showing with wires."},{"signature":"Texture = 2","summary":"The analysis is showing with textures."},{"signature":"FalseColor = 4","summary":"The analysis is showing with False colors."}]},{"namespace":"Rhino.Display","name":"VisualAnalysisMode.EdgeContinuityMode","dataType":"enum","summary":"Continuity mode to report","values":[{"signature":"Distance = 0","summary":"G0 Continuity"},{"signature":"Tangency = 1","summary":"G1 Continuity"},{"signature":"Curvature = 2","summary":"G2 Continuity"}]},{"namespace":"Rhino.Display","name":"ZBiasMode","dataType":"enum","summary":"Biasing applied to geometry to attempt to get coplanar items to draw on top of or below other geometry","since":"5.0","values":[{"signature":"Neutral = 0"},{"signature":"TowardsCamera = 1"},{"signature":"AwayFromCamera = 2"}]},{"namespace":"Rhino.Display","name":"ZBufferCapture","dataType":"class","summary":"Provides functionality for getting the z-buffer values from a viewport and a given display mode","interfaces":["IDisposable"],"constructors":[{"signature":"ZBufferCapture(RhinoViewport viewport)","since":"5.3"}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.3"},{"signature":"System.Drawing.Bitmap GrayscaleDib()","since":"5.3"},{"signature":"int HitCount()","since":"5.3"},{"signature":"float MaxZ()","since":"5.3"},{"signature":"float MinZ()","since":"5.3"},{"signature":"void SetDisplayMode(Guid modeId)","since":"5.3"},{"signature":"void ShowAnnotations(bool on)","since":"5.3"},{"signature":"void ShowCurves(bool on)","since":"5.3"},{"signature":"void ShowIsocurves(bool on)","since":"5.3"},{"signature":"void ShowLights(bool on)","since":"5.3"},{"signature":"void ShowMeshWires(bool on)","since":"5.3"},{"signature":"void ShowPoints(bool on)","since":"5.3"},{"signature":"void ShowText(bool on)","since":"5.3"},{"signature":"Point3d WorldPointAt(int x, int y)","since":"5.3"},{"signature":"float ZValueAt(int x, int y)","since":"5.3"}]},{"namespace":"Rhino.DocObjects","name":"ActiveSpace","dataType":"enum","summary":"Defines the current working space.","since":"5.0","values":[{"signature":"None = 0","summary":"There is no working space."},{"signature":"ModelSpace = 1","summary":"3d modeling or \\"world\\" space."},{"signature":"PageSpace = 2","summary":"page/layout/paper/printing space."}]},{"namespace":"Rhino.DocObjects","name":"AngleDisplayMode","dataType":"enum","summary":"Defines enumerated values for the display of angles.","since":"6.0","values":[{"signature":"Degrees = 0","summary":"Shows angle in decimal degrees"},{"signature":"DMS = 1","summary":"Show angle as degree,minute,second."},{"signature":"Grads = 2","summary":"Show angle as grads."}]},{"namespace":"Rhino.DocObjects","name":"AngularDimensionObject","dataType":"class","summary":"Rhino Object that represents an angular dimension geometry and attributes","baseclass":"Rhino.DocObjects.DimensionObject","properties":[{"signature":"AngularDimension AngularDimensionGeometry","summary":"Get the dimension geometry for this object.","since":"6.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"AnimationProperties","dataType":"class","summary":"Contains information used by the Animation Tools to create sun, season, turntable and fly through animations.","interfaces":["IDisposable"],"constructors":[{"signature":"AnimationProperties()","summary":"Initializes a new instance of the AnimationPropertiesclass.","since":"6.11"},{"signature":"AnimationProperties(AnimationProperties source)","summary":"Initialize new instance of the AnimationProperties class.","since":"6.11","parameters":[{"name":"source","summary":"If not null, settings are copied from source"}]}],"properties":[{"signature":"string AnimationName","summary":"Gets or sets the name of the animation sequence.","since":"6.11","property":["get","set"]},{"signature":"Guid CameraPathId","summary":"Gets or sets the object ID of the camera path.","since":"6.11","property":["get","set"]},{"signature":"Point3d[] CameraPoints","summary":"Gets or sets points of the camera path.","since":"6.11","property":["get","set"]},{"signature":"string CaptureMethod","summary":"Gets or sets the capture method of the animation which is either preview or full.","since":"6.11","property":["get","set"]},{"signature":"CaptureTypes CaptureType","summary":"Gets or sets the capture type of the animation.","since":"6.11","property":["get","set"]},{"signature":"string[] Dates","summary":"Gets or sets the dates that are calculated for seasonal/one day sun animations.","since":"6.11","property":["get","set"]},{"signature":"int DaysBetweenFrames","summary":"Gets or sets the days between captured frames for seasonal sun animation.","since":"6.11","property":["get","set"]},{"signature":"Guid DisplayMode","summary":"Gets or sets the ID of the view display mode (wireframe, shaded...).","since":"6.11","property":["get","set"]},{"signature":"int EndDay","summary":"Gets or sets the end day for seasonal day sun animation in the range 1 to 31.","since":"6.11","property":["get","set"]},{"signature":"int EndHour","summary":"Gets or sets the end hour for one day sun animation in the range 0 to 23.","since":"6.11","property":["get","set"]},{"signature":"int EndMinutes","summary":"Gets or sets the end minutes for one day sun animation in the range 0 to 59.","since":"6.11","property":["get","set"]},{"signature":"int EndMonth","summary":"Gets or sets the end month for seasonal day sun animation in the range 1 to 12.","since":"6.11","property":["get","set"]},{"signature":"int EndSeconds","summary":"Gets or sets the end seconds for one day sun animation in the range 0 to 59.","since":"6.11","property":["get","set"]},{"signature":"int EndYear","summary":"Gets or sets the end year for seasonal day sun animation in the range 1800 to 2199.","since":"6.11","property":["get","set"]},{"signature":"string FileExtension","summary":"Gets or sets the file extension of the saved frames created by the animation.","since":"6.11","property":["get","set"]},{"signature":"string FolderName","summary":"Gets or sets the location for the saved frames.","since":"6.11","property":["get","set"]},{"signature":"int FrameCount","summary":"Gets or sets the number of frames to be captured.","since":"6.11","property":["get","set"]},{"signature":"string[] Images","summary":"Gets or sets the full path to the saved frames of an animation.","since":"6.11","property":["get","set"]},{"signature":"double Latitude","summary":"Gets or sets the latitude for sun animations in the range of -90 to +90.","since":"6.11","property":["get","set"]},{"signature":"int LightIndex","summary":"Internal value used while previewing animation.","since":"6.11","property":["get","set"]},{"signature":"double Longitude","summary":"Gets or sets the longitude for sun animations in the range of -180 to +180.","since":"6.11","property":["get","set"]},{"signature":"int MinutesBetweenFrames","summary":"Gets or sets the minutes between captured frames for one day sun animation.","since":"6.11","property":["get","set"]},{"signature":"double NorthAngle","summary":"Gets or sets the world angle corresponding to North in degrees. This angle is zero along the x-axis and increases anticlockwise.","since":"6.11","property":["get","set"]},{"signature":"bool RenderFull","summary":"Gets or sets a value indicating whether to capture a frame in rendered mode.","since":"6.11","property":["get","set"]},{"signature":"bool RenderPreview","summary":"Gets or sets a value indicating whether to capture a frame in preview rendered mode.","since":"6.11","property":["get","set"]},{"signature":"int StartDay","summary":"Gets or sets the start day for seasonal/one day sun animation in the range 1 to 31.","since":"6.11","property":["get","set"]},{"signature":"int StartHour","summary":"Gets or sets the start hour for seasonal/one day sun animation in the range 0 to 23.","since":"6.11","property":["get","set"]},{"signature":"int StartMinutes","summary":"Gets or sets the start minutes for seasonal/one day sun animation in the range 0 to 59.","since":"6.11","property":["get","set"]},{"signature":"int StartMonth","summary":"Gets or sets the start month for seasonal/one day sun animation in the range 1 to 12.","since":"6.11","property":["get","set"]},{"signature":"int StartSeconds","summary":"Gets or sets the start seconds for seasonal/one day sun animation in the range 0 to 59.","since":"6.11","property":["get","set"]},{"signature":"int StartYear","summary":"Gets or sets the start year for seasonal/one day sun animation in the range 1800 to 2199.","since":"6.11","property":["get","set"]},{"signature":"Guid TargetPathId","summary":"Gets or sets the object ID of the target path.","since":"6.11","property":["get","set"]},{"signature":"Point3d[] TargetPoints","summary":"Gets or sets points of the target path.","since":"6.11","property":["get","set"]},{"signature":"string ViewportName","summary":"Gets or sets the viewport that will be captured.","since":"6.11","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.11"}]},{"namespace":"Rhino.DocObjects","name":"AnimationProperties.CaptureTypes","dataType":"enum","summary":"Constants that define the mode of the animation tools.","since":"6.11","values":[{"signature":"Path = UnsafeNativeMethods.AnimationPropertiesCaptureTypes.Path","summary":"Camera and target movement along separate path curves"},{"signature":"Turntable = UnsafeNativeMethods.AnimationPropertiesCaptureTypes.Turntable","summary":"Rotate a view around the target."},{"signature":"Flythrough = UnsafeNativeMethods.AnimationPropertiesCaptureTypes.Flythrough","summary":"Camera and target movement along a path curve"},{"signature":"DaySunStudy = UnsafeNativeMethods.AnimationPropertiesCaptureTypes.DaySunStudy","summary":"Sun movement through a specified calendar day"},{"signature":"SeasonalSunStudy = UnsafeNativeMethods.AnimationPropertiesCaptureTypes.SeasonalSunStudy","summary":"Sun movement through a specified week, month, or year"},{"signature":"None = UnsafeNativeMethods.AnimationPropertiesCaptureTypes.None","summary":"No capture type specified"}]},{"namespace":"Rhino.DocObjects","name":"AnnotationObjectBase","dataType":"class","summary":"Base class for all annotation objects (text and dimensions)","baseclass":"Rhino.DocObjects.RhinoObject","properties":[{"signature":"AnnotationBase AnnotationGeometry","summary":"Get the annotation base geometry for this object","since":"6.0","property":["get"]},{"signature":"string DisplayText","summary":"Gets the text that is displayed to users.","since":"5.0","property":["get"]},{"signature":"bool HasMeasurableTextFields","summary":"Test if the text in the annotation object contains fields that involve length, area, or volume measurements","since":"7.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"BasepointZero","dataType":"enum","summary":"Specifies enumerated constants used to indicate the zero level convention relating to a location on Earth.  \\nThis is used in conjunction with the  class.","since":"5.0","values":[{"signature":"GroundLevel = 0","summary":"The ground level is the convention for 0."},{"signature":"MeanSeaLevel = 1","summary":"The mean sea level is the convention for 0."},{"signature":"CenterOfEarth = 2","summary":"The center of the planet is the convention for 0."}]},{"namespace":"Rhino.DocObjects","name":"BitmapEntry","dataType":"class","summary":"Rhino.DocObjects.Tables.BitmapTable entry","baseclass":"Rhino.DocObjects.ModelComponent","properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.Image.","since":"6.0","property":["get"]},{"signature":"string FileName","summary":"The name of this bitmap.","since":"5.1","property":["get"]},{"signature":"bool IsReference","summary":"Gets a value indicting whether this bitmap is a referenced bitmap. Referenced bitmaps are part of referenced documents.","since":"5.1","property":["get"]}],"methods":[{"signature":"bool Save(string fileName)","since":"5.1"}]},{"namespace":"Rhino.DocObjects","name":"BrepObject","dataType":"class","summary":"Represents a Rhino.Geometry.Brepin a document.","baseclass":"Rhino.DocObjects.RhinoObject","properties":[{"signature":"Brep BrepGeometry","summary":"Gets the Brep geometry linked with this object.","since":"5.0","property":["get"]}],"methods":[{"signature":"Brep DuplicateBrepGeometry()","summary":"Constructs a new deep copy of the Brep geometry.","since":"5.0","returns":"The copy of the geometry."}]},{"namespace":"Rhino.DocObjects","name":"CentermarkObject","dataType":"class","summary":"Rhino Object that represents a centermark geometry and attributes","baseclass":"Rhino.DocObjects.DimensionObject","properties":[{"signature":"Centermark CentermarkGeometry","summary":"Get the dimension geometry for this object.","since":"6.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"ClippingPlaneObject","dataType":"class","summary":"Represents the object of a Rhino.Geometry.ClippingPlaneSurface, stored in the Rhino document and with attributes.","baseclass":"Rhino.DocObjects.RhinoObject","properties":[{"signature":"ClippingPlaneSurface ClippingPlaneGeometry","summary":"Gets the clipping plane surface.","since":"5.0","property":["get"]}],"methods":[{"signature":"bool AddClipViewport(RhinoViewport viewport, bool commit)","summary":"Adds a viewport to the list of viewports that this clipping plane clips.","since":"6.1","parameters":[{"name":"viewport","summary":"The viewport to add."},{"name":"commit","summary":"Commit the change. When in doubt, set this parameter to true."}],"returns":"True if the viewport was added, False if the viewport is already in the list."},{"signature":"bool RemoveClipViewport(RhinoViewport viewport, bool commit)","summary":"Removes a viewport from the list of viewports that this clipping plane clips.","since":"6.1","parameters":[{"name":"viewport","summary":"The viewport to remove."},{"name":"commit","summary":"Commit the change. When in doubt, set this parameter to true."}],"returns":"True if the viewport was removed, False if the viewport was not in the list."}]},{"namespace":"Rhino.DocObjects","name":"ConstructionPlane","dataType":"class","summary":"Represents a construction plane inside the document.  \\nUse Rhino.DocObjects.Tables.NamedConstructionPlaneTable methods and indexers to add and access a .","constructors":[{"signature":"ConstructionPlane()","summary":"Initializes a new instance of ConstructionPlane.","since":"5.0"}],"properties":[{"signature":"bool DepthBuffered","summary":"Gets or sets whether the grid is drawn on top of geometry.  \\nfalse=grid is always drawn behind 3d geometry  \\ntrue=grid is drawn at its depth as a 3d plane and grid lines obscure things behind the grid.","since":"5.0","property":["get","set"]},{"signature":"int GridLineCount","summary":"Gets or sets the total amount of grid lines in each direction.","since":"5.0","property":["get","set"]},{"signature":"double GridSpacing","summary":"Gets or sets the distance between grid lines.","since":"5.0","property":["get","set"]},{"signature":"Color GridXColor","summary":"Gets or sets the color of the grid X-axis mark.","since":"5.0","property":["get","set"]},{"signature":"Color GridYColor","summary":"Gets or sets the color of the grid Y-axis mark.","since":"5.0","property":["get","set"]},{"signature":"Color GridZColor","summary":"Gets or sets the color of the grid Z-axis mark.","since":"5.0","property":["get","set"]},{"signature":"string Name","summary":"Gets or sets the name of the construction plane.","since":"5.0","property":["get","set"]},{"signature":"Plane Plane","summary":"Gets or sets the geometric plane to use for construction.","since":"5.0","property":["get","set"]},{"signature":"bool ShowAxes","summary":"Gets or sets whether the axes of the grid should be visible.","since":"5.0","property":["get","set"]},{"signature":"bool ShowGrid","summary":"Gets or sets whether the grid itself should be visible.","since":"5.0","property":["get","set"]},{"signature":"bool ShowZAxis","summary":"Gets or sets whether the Z axis of the grid should be visible.","since":"6.0","property":["get","set"]},{"signature":"double SnapSpacing","summary":"when \\"grid snap\\" is enabled, the distance between snap points. Typically this is the same distance as grid spacing.","since":"5.0","property":["get","set"]},{"signature":"Color ThickLineColor","summary":"Gets or sets the color of the thicker, wider line.","since":"5.0","property":["get","set"]},{"signature":"int ThickLineFrequency","summary":"Gets or sets the recurrence of a wider line on the grid.  \\n0: No lines are thick, all are drawn thin.  \\n1: All lines are thick.  \\n2: Every other line is thick.  \\n3: One line in three lines is thick (and two are thin).  \\n4: ...","since":"5.0","property":["get","set"]},{"signature":"Color ThinLineColor","summary":"Gets or sets the color of the thinner, less prominent line.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.DocObjects","name":"CoordinateSystem","dataType":"enum","summary":"Defines enumerated values for coordinate systems to use as references.","since":"5.0","values":[{"signature":"World = 0","summary":"The world coordinate system. This has origin (0,0,0), X unit axis is (1, 0, 0) and Y unit axis is (0, 1, 0)."},{"signature":"Camera = 1","summary":"The camera coordinate system."},{"signature":"Clip = 2","summary":"The clip coordinate system."},{"signature":"Screen = 3","summary":"The screen coordinate system."}]},{"namespace":"Rhino.DocObjects","name":"CurveObject","dataType":"class","summary":"A Rhino Object that represents curve geometry and attributes","baseclass":"Rhino.DocObjects.RhinoObject","properties":[{"signature":"Curve CurveGeometry","summary":"Returns the underlying curve geometry.","since":"5.0","property":["get"]}],"methods":[{"signature":"Curve DuplicateCurveGeometry()","summary":"Returns a copy of the underlying curve geometry.","since":"5.0"}]},{"namespace":"Rhino.DocObjects.Custom","name":"ClassIdAttribute","dataType":"class","summary":"Useful for legacy UserData","baseclass":"Attribute","constructors":[{"signature":"ClassIdAttribute(string id)","summary":"Initializes a class id attribute.","since":"6.0","parameters":[{"name":"id","summary":"String in the form of a Guid."}]}],"properties":[{"signature":"Guid Id","summary":"Gets the associated style.","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.DocObjects.Custom","name":"CustomBrepObject","dataType":"class","baseclass":"Rhino.DocObjects.BrepObject","interfaces":["IDisposable"]},{"namespace":"Rhino.DocObjects.Custom","name":"CustomCurveObject","dataType":"class","baseclass":"Rhino.DocObjects.CurveObject","interfaces":["IDisposable"],"methods":[{"signature":"void Dispose()","since":"5.0"}]},{"namespace":"Rhino.DocObjects.Custom","name":"CustomGripObject","dataType":"class","baseclass":"Rhino.DocObjects.GripObject","interfaces":["IDisposable"],"constructors":[{"signature":"CustomGripObject()","since":"5.0"}],"properties":[{"signature":"int Index","since":"5.0","property":["get","set"]},{"signature":"Point3d OriginalLocation","since":"5.0","property":["get","set"]},{"signature":"double Weight","since":"5.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","since":"5.0"},{"signature":"void NewLocation()","since":"5.0"}]},{"namespace":"Rhino.DocObjects.Custom","name":"CustomMeshObject","dataType":"class","baseclass":"Rhino.DocObjects.MeshObject","interfaces":["IDisposable"],"methods":[{"signature":"void Dispose()","since":"5.0"}]},{"namespace":"Rhino.DocObjects.Custom","name":"CustomObjectGrips","dataType":"class","interfaces":["IDisposable"],"properties":[{"signature":"int GripCount","since":"5.0","property":["get"]},{"signature":"bool GripsMoved","summary":"If GripsMoved is True if some of the grips have ever been moved GripObject.NewLocation() sets GripsMoved=true.","since":"5.0","property":["get"]},{"signature":"bool NewLocation","summary":"True if some of the grips have been moved. GripObject.NewLocation() sets NewLocation=true.  Derived classes can set NewLocation to False after updating temporary display information.","since":"5.0","property":["get","set"]},{"signature":"RhinoObject OwnerObject","summary":"Owner of the grips.","since":"5.0","property":["get"]}],"methods":[{"signature":"static bool Dragging()","summary":"Determines if grips are currently being dragged.","since":"5.0","returns":"True if grips are dragged."},{"signature":"static void RegisterGripsEnabler(TurnOnGripsEventHandler enabler, Type customGripsType)","since":"5.0"},{"signature":"void Dispose()","since":"5.0"},{"signature":"CustomGripObject Grip(int index)","since":"5.0"}]},{"namespace":"Rhino.DocObjects.Custom","name":"CustomPointObject","dataType":"class","baseclass":"Rhino.DocObjects.PointObject","interfaces":["IDisposable"],"methods":[{"signature":"void Dispose()","since":"5.6"}]},{"namespace":"Rhino.DocObjects.Custom","name":"GripsDrawEventArgs","dataType":"class","baseclass":"Rhino.Display.DrawEventArgs","properties":[{"signature":"int ControlPolygonStyle","summary":"What kind of line is used to display things like control polygons. 0 = no control polygon,  1 = solid control polygon,  2 = dotted control polygon.","since":"5.0","property":["get","set"]},{"signature":"bool DrawDynamicStuff","summary":"If true, then draw stuff that does not move when grips are dragged, like the control polygon of the \\"original\\" curve.","since":"5.0","property":["get"]},{"signature":"bool DrawStaticStuff","summary":"If true, then draw stuff that moves when grips are dragged, like the curve being bent by a dragged control point.","since":"5.0","property":["get"]},{"signature":"Color GripColor","since":"5.0","property":["get","set"]},{"signature":"int GripStatusCount","since":"5.0","property":["get"]},{"signature":"Color LockedGripColor","since":"5.0","property":["get","set"]},{"signature":"Color SelectedGripColor","since":"5.0","property":["get","set"]}],"methods":[{"signature":"void DrawControlPolygonLine(Line line, GripStatus startStatus, GripStatus endStatus)","summary":"Draws the lines in a control polygons.  \\nThis is an helper function.","since":"5.0","parameters":[{"name":"line","summary":"Line between two grips."},{"name":"startStatus","summary":"Grip status at start of line."},{"name":"endStatus","summary":"Grip status at end of line."}]},{"signature":"void DrawControlPolygonLine(Line line, int startStatus, int endStatus)","summary":"Draws the lines in a control polygons.  \\nThis is an helper function.","since":"5.0","parameters":[{"name":"line","summary":"Line between two grips."},{"name":"startStatus","summary":"Index of Grip status at start of line."},{"name":"endStatus","summary":"Index if Grip status at end of line."}]},{"signature":"void DrawControlPolygonLine(Point3d start, Point3d end, int startStatus, int endStatus)","summary":"Draws the lines in a control polygons.  \\nThis is an helper function.","since":"5.0","parameters":[{"name":"start","summary":"The point start."},{"name":"end","summary":"The point end."},{"name":"startStatus","summary":"Index of Grip status at start of line defined by start and end."},{"name":"endStatus","summary":"Index if Grip status at end of line defined by start and end."}]},{"signature":"GripStatus GripStatus(int index)","since":"5.0"},{"signature":"void RestoreViewportSettings()","since":"5.0"}]},{"namespace":"Rhino.DocObjects.Custom","name":"GripStatus","dataType":"class","properties":[{"signature":"bool Culled","since":"5.0","property":["get","set"]},{"signature":"bool Visible","since":"5.0","property":["get"]}]},{"namespace":"Rhino.DocObjects.Custom","name":"UnknownUserData","dataType":"class","summary":"Represents user data with unknown origin.","baseclass":"Rhino.DocObjects.Custom.UserData","constructors":[{"signature":"UnknownUserData(IntPtr pointerNativeUserData)","summary":"Constructs a new unknown data entity.","since":"5.0","parameters":[{"name":"pointerNativeUserData","summary":"A pointer to the entity."}]}]},{"namespace":"Rhino.DocObjects.Custom","name":"UserData","dataType":"class","summary":"Provides a base class for custom classes of information which may be attached to geometry or attribute classes.","interfaces":["IDisposable"],"properties":[{"signature":"string Description","summary":"Descriptive name of the user data.","since":"5.0","property":["get"]},{"signature":"bool ShouldWrite","summary":"If you want to save this user data in a 3dm file, override ShouldWrite and return true.  If you do support serialization, you must also override the Read and Write functions.","since":"5.0","property":["get"]},{"signature":"Transform Transform","summary":"Updated if user data is attached to a piece of geometry that is transformed and the virtual OnTransform() is not overridden.  If you override OnTransform() and want Transform to be updated, then call the base class OnTransform() in your override. The default constructor sets Transform to the identity.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static void Copy(CommonObject source, CommonObject destination)","summary":"Expert user tool that copies user data that has a positive CopyCount from the source object to a destination object. Generally speaking you don\'t need to use Copy(). Simply rely on things like the copy constructors to do the right thing.","since":"5.0","parameters":[{"name":"source","summary":"A source object for the data."},{"name":"destination","summary":"A destination object for the data."}]},{"signature":"static Guid MoveUserDataFrom(CommonObject objectWithUserData)","summary":"Moves the user data from objectWithUserData to a temporary data storage identified by the return Guid.  When MoveUserDataFrom returns, the objectWithUserData will not have any user data.","since":"5.0","parameters":[{"name":"objectWithUserData","summary":"Object with user data attached."}],"returns":"Guid identifier for storage of UserData that is held in a temporary list by this class. This function should be used in conjunction with MoveUserDataTo to transfer the user data to a different object. Returns Guid.Empty if there was no user data to transfer."},{"signature":"static void MoveUserDataTo(CommonObject objectToGetUserData, Guid id, bool append)","summary":"Moves the user data.  \\nSee  for more information.","since":"5.0","parameters":[{"name":"objectToGetUserData","summary":"Object data source."},{"name":"id","summary":"Target."},{"name":"append","summary":"If the data should be appended or replaced."}]},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"}]},{"namespace":"Rhino.DocObjects.Custom","name":"UserDataList","dataType":"class","summary":"Represents a collection of user data.","interfaces":["IEnumerable<UserData>"],"properties":[{"signature":"int Count","summary":"Number of UserData objects in this list.","since":"5.0","property":["get"]}],"methods":[{"signature":"bool Add(UserData userdata)","summary":"If the user-data is already in a different UserDataList, it will be removed from that list and added to this list.","since":"5.0","parameters":[{"name":"userdata","summary":"Data element."}],"returns":"Whether this operation succeeded."},{"signature":"bool Contains(Guid userdataId)","summary":"Checks for the existence of a specific type of user-data in this list Both .NET and native user-data is checked","since":"6.1"},{"signature":"UserData Find(Type userdataType)","summary":"Finds a specific data type in this regulated collection.","since":"5.0","parameters":[{"name":"userdataType","summary":"A data type."}],"returns":"The found data, or None of nothing was found."},{"signature":"IEnumerator<UserData> GetEnumerator()","summary":"Get enumerator for UserDataList","since":"6.0"},{"signature":"void Purge()","summary":"Removes all user data from this geometry.","since":"6.0"},{"signature":"bool Remove(UserData userdata)","summary":"Remove the user-data from this list","since":"5.6","returns":"True if the user data was successfully removed"}]},{"namespace":"Rhino.DocObjects.Custom","name":"UserDataListEnumerator","dataType":"class","summary":"Enumerator for UserDataList","interfaces":["IEnumerator<UserData>"],"constructors":[{"signature":"UserDataListEnumerator(UserDataList udl)","summary":"Create new UserDataListEnumerator","since":"6.0","parameters":[{"name":"udl","summary":"UserDataList to enumerate"}]}],"properties":[{"signature":"UserData Current","summary":"Get current UserData on the enumerator.","since":"6.0","property":["get"]}],"methods":[{"signature":"void Dispose()","summary":"Implement Dispose(). NOP.","since":"6.0"},{"signature":"bool MoveNext()","summary":"Advance enumerator to next UserData item.","since":"6.0","returns":"True if there is a next item."},{"signature":"void Reset()","summary":"Reset the enumerator","since":"6.0"}]},{"namespace":"Rhino.DocObjects.Custom","name":"UserDictionary","dataType":"class","summary":"Defines the storage data class for a Rhino.Collections.ArchivableDictionary.","baseclass":"Rhino.DocObjects.Custom.UserData","properties":[{"signature":"string Description","summary":"Gets the text \\"RhinoCommon UserDictionary\\".","since":"5.0","property":["get"]},{"signature":"ArchivableDictionary Dictionary","summary":"Gets the dictionary that is associated with this class.  \\nThis dictionary is unique.","since":"5.0","property":["get"]},{"signature":"bool ShouldWrite","summary":"Writes this entity if the count is larger than 0.","since":"5.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"DetailViewObject","dataType":"class","summary":"A detail view object is a nested Rhino viewport placed on a page view with a 2D closed curve boundary. It can be any type of modeling view.","baseclass":"Rhino.DocObjects.RhinoObject","properties":[{"signature":"string DescriptiveTitle","summary":"Detail objects have two strings that can be used to describe the detail: 1. The name string that is part of the object\'s attributes 2. The viewport projection title that is part of the viewport This function combines these two strings to create a single \\"description\\" string in the form of attribute_name - projection_title.","since":"7.0","property":["get"]},{"signature":"DetailView DetailGeometry","summary":"Returns the detail view geometry.","since":"5.0","property":["get"]},{"signature":"bool IsActive","summary":"Gets or sets the active state of the detail view.","since":"5.0","property":["get","set"]},{"signature":"Transform PageToWorldTransform","summary":"Returns the page coordinate to world coordinate transformation.","since":"6.0","property":["get"]},{"signature":"RhinoViewport Viewport","summary":"Gets the detail view\'s viewport.","since":"5.0","property":["get"]},{"signature":"Transform WorldToPageTransform","summary":"Gets the world coordinate to page coordinate transformation.","since":"6.0","property":["get"]}],"methods":[{"signature":"bool CommitViewportChanges()","since":"5.0"},{"signature":"bool GetFormattedScale(ScaleFormat format, out string value)","summary":"Returns the detail view object\'s scale as a formatted string. The detail view object\'s viewport must be to parallel projection.","since":"7.0","parameters":[{"name":"format","summary":"The scale format."},{"name":"value","summary":"The formatted string"}],"returns":"True if successful, False otherwise"}]},{"namespace":"Rhino.DocObjects","name":"DetailViewObject.ScaleFormat","dataType":"enum","summary":"Detail view object scale formats.","since":"7.0","values":[{"signature":"None","summary":"No formatting"},{"signature":"PageLengthToOne","summary":"#:1"},{"signature":"OneToModelLength","summary":"1:#"},{"signature":"OneInchToModelLengthFeet","summary":"1\\" = #\'"},{"signature":"ModelLengthInchToOneFoot","summary":"#\\" = 1\'"},{"signature":"ModelLengthInchToOneFootInch","summary":"#\' = 1\'-0\\""}]},{"namespace":"Rhino.DocObjects","name":"DimensionObject","dataType":"class","summary":"Rhino Object that represents dimension geometry and attributes","baseclass":"Rhino.DocObjects.AnnotationObjectBase","properties":[{"signature":"DimensionStyle DimensionStyle","summary":"Gets the DimensionStyle associated with this OrdinateDimensionObject.","since":"6.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle","dataType":"class","summary":"Can also be considered an annotation style since it is used for more than just dimensions","baseclass":"Rhino.DocObjects.ModelComponent","constructors":[{"signature":"DimensionStyle()","summary":"Create a new non-document controlled annotation style","since":"5.0"}],"properties":[{"signature":"bool AlternateBelowLine","since":"6.0","property":["get","set"]},{"signature":"LengthDisplay AlternateDimensionLengthDisplay","since":"6.0","property":["get","set"]},{"signature":"double AlternateLengthFactor","since":"5.0","property":["get","set"]},{"signature":"int AlternateLengthResolution","since":"6.0","property":["get","set"]},{"signature":"string AlternatePrefix","since":"6.0","property":["get","set"]},{"signature":"double AlternateRoundoff","since":"6.0","property":["get","set"]},{"signature":"string AlternateSuffix","since":"6.0","property":["get","set"]},{"signature":"int AlternateToleranceResolution","since":"6.0","property":["get","set"]},{"signature":"bool AlternateUnitsDisplay","since":"6.0","property":["get","set"]},{"signature":"ZeroSuppression AlternateZeroSuppress","since":"6.0","property":["get","set"]},{"signature":"AngleDisplayFormat AngleFormat","since":"6.0","property":["get","set"]},{"signature":"int AngleResolution","since":"5.0","property":["get","set"]},{"signature":"ZeroSuppression AngleZeroSuppress","since":"6.0","property":["get","set"]},{"signature":"double AngularRoundoff","since":"6.0","property":["get","set"]},{"signature":"int ArcLengthSymbol","since":"6.0","property":["get","set"]},{"signature":"Guid ArrowBlockId1","since":"6.0","property":["get","set"]},{"signature":"Guid ArrowBlockId2","since":"6.0","property":["get","set"]},{"signature":"double ArrowLength","since":"5.0","property":["get","set"]},{"signature":"ArrowType ArrowType1","since":"6.0","property":["get","set"]},{"signature":"ArrowType ArrowType2","since":"6.0","property":["get","set"]},{"signature":"double BaselineSpacing","since":"6.0","property":["get","set"]},{"signature":"double CentermarkSize","since":"5.0","property":["get","set"]},{"signature":"CenterMarkStyle CenterMarkType","since":"6.0","property":["get","set"]},{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.ModelGeometry.","since":"6.0","property":["get"]},{"signature":"char DecimalSeparator","since":"7.0","property":["get","set"]},{"signature":"LengthDisplay DimensionLengthDisplay","since":"6.0","property":["get","set"]},{"signature":"double DimensionLineExtension","since":"6.0","property":["get","set"]},{"signature":"double DimensionScale","since":"6.0","property":["get","set"]},{"signature":"ScaleValue DimensionScaleValue","since":"6.0","property":["get","set"]},{"signature":"LeaderContentAngleStyle DimRadialTextAngleType","since":"6.0","property":["get","set"]},{"signature":"TextLocation DimRadialTextLocation","since":"6.0","property":["get","set"]},{"signature":"TextOrientation DimRadialTextOrientation","since":"6.0","property":["get","set"]},{"signature":"LeaderContentAngleStyle DimTextAngleType","since":"6.0","property":["get","set"]},{"signature":"TextLocation DimTextLocation","since":"6.0","property":["get","set"]},{"signature":"TextOrientation DimTextOrientation","since":"6.0","property":["get","set"]},{"signature":"bool DrawForward","since":"6.0","property":["get","set"]},{"signature":"bool DrawTextMask","since":"6.0","property":["get","set"]},{"signature":"double ExtensionLineExtension","since":"5.0","property":["get","set"]},{"signature":"double ExtensionLineOffset","since":"5.0","property":["get","set"]},{"signature":"ArrowFit FitArrow","since":"6.20","property":["get","set"]},{"signature":"TextFit FitText","since":"6.20","property":["get","set"]},{"signature":"double FixedExtensionLength","since":"6.0","property":["get","set"]},{"signature":"bool FixedExtensionOn","since":"6.0","property":["get","set"]},{"signature":"Font Font","since":"6.0","property":["get","set"]},{"signature":"bool ForceDimensionLineBetweenExtensionLines","since":"6.20","property":["get","set"]},{"signature":"bool HasFieldOverrides","summary":"Checks if any fields in this DimensionStyle are overrides","since":"6.0","property":["get"]},{"signature":"bool IsChild","summary":"Tests if this DimensionStyle is a child of any other DimensionStyle","since":"6.0","property":["get"]},{"signature":"bool IsDeleted","since":"6.0","property":["get"]},{"signature":"bool IsReference","since":"5.0","property":["get"]},{"signature":"Guid LeaderArrowBlockId","since":"6.0","property":["get","set"]},{"signature":"double LeaderArrowLength","since":"5.0","property":["get","set"]},{"signature":"ArrowType LeaderArrowType","since":"5.6","property":["get","set"]},{"signature":"LeaderContentAngleStyle LeaderContentAngleType","summary":"Style of leader content angle Horizontal Aligned Rotated","since":"6.0","property":["get","set"]},{"signature":"LeaderCurveStyle LeaderCurveType","since":"6.0","property":["get","set"]},{"signature":"bool LeaderHasLanding","since":"6.0","property":["get","set"]},{"signature":"double LeaderLandingLength","since":"6.0","property":["get","set"]},{"signature":"TextHorizontalAlignment LeaderTextHorizontalAlignment","since":"6.0","property":["get","set"]},{"signature":"TextOrientation LeaderTextOrientation","since":"6.0","property":["get","set"]},{"signature":"double LeaderTextRotationDegrees","since":"6.0","property":["get","set"]},{"signature":"double LeaderTextRotationRadians","summary":"Angle of leader text for Rotated style","since":"6.0","property":["get","set"]},{"signature":"TextVerticalAlignment LeaderTextVerticalAlignment","since":"6.0","property":["get","set"]},{"signature":"double LengthFactor","since":"5.0","property":["get","set"]},{"signature":"int LengthResolution","since":"5.0","property":["get","set"]},{"signature":"Color MaskColor","since":"6.0","property":["get","set"]},{"signature":"MaskType MaskColorSource","since":"6.0","property":["get","set"]},{"signature":"MaskFrame MaskFrameType","since":"7.0","property":["get","set"]},{"signature":"double MaskOffset","since":"6.0","property":["get","set"]},{"signature":"Guid ParentId","summary":"Get or Set the Id of this DimensionStyle\'s parent. If ParentId is Guid.Empty, this DimensionStyle has no parent","since":"6.0","property":["get","set"]},{"signature":"string Prefix","since":"5.0","property":["get","set"]},{"signature":"double Roundoff","since":"6.0","property":["get","set"]},{"signature":"double ScaleLeftLengthMillimeters","since":"6.0","property":["get","set"]},{"signature":"double ScaleRightLengthMillimeters","since":"6.0","property":["get","set"]},{"signature":"StackDisplayFormat StackFractionFormat","since":"6.0","property":["get","set"]},{"signature":"double StackHeightScale","since":"6.0","property":["get","set"]},{"signature":"string Suffix","since":"5.0","property":["get","set"]},{"signature":"bool SuppressArrow1","since":"6.0","property":["get","set"]},{"signature":"bool SuppressArrow2","since":"6.0","property":["get","set"]},{"signature":"bool SuppressExtension1","since":"6.0","property":["get","set"]},{"signature":"bool SuppressExtension2","since":"6.0","property":["get","set"]},{"signature":"double TextGap","since":"5.0","property":["get","set"]},{"signature":"double TextHeight","since":"5.0","property":["get","set"]},{"signature":"TextHorizontalAlignment TextHorizontalAlignment","since":"6.0","property":["get","set"]},{"signature":"int TextMoveLeader","since":"6.0","property":["get","set"]},{"signature":"TextOrientation TextOrientation","since":"6.0","property":["get","set"]},{"signature":"double TextRotation","since":"6.0","property":["get","set"]},{"signature":"bool TextUnderlined","since":"6.0","property":["get","set"]},{"signature":"TextVerticalAlignment TextVerticalAlignment","since":"6.0","property":["get","set"]},{"signature":"ToleranceDisplayFormat ToleranceFormat","since":"6.0","property":["get","set"]},{"signature":"double ToleranceHeightScale","since":"6.0","property":["get","set"]},{"signature":"double ToleranceLowerValue","since":"6.0","property":["get","set"]},{"signature":"int ToleranceResolution","since":"6.0","property":["get","set"]},{"signature":"double ToleranceUpperValue","since":"6.0","property":["get","set"]},{"signature":"ZeroSuppression ToleranceZeroSuppress","since":"6.0","property":["get","set"]},{"signature":"ZeroSuppression ZeroSuppress","since":"6.0","property":["get","set"]}],"methods":[{"signature":"UnitSystem AlternateDimensionLengthDisplayUnit(uint model_serial_number)","since":"6.0"},{"signature":"void ClearAllFieldOverrides()","summary":"Sets all the fields in this DimensionStyle to be not overridden Does not change any dimstyle_id\'s or parent_id\'s","since":"6.0"},{"signature":"void ClearFieldOverride(Field field)","summary":"Set the field as not overridden","since":"6.0"},{"signature":"void CopyFrom(DimensionStyle source)","summary":"Copy settings from source dimension style without changing the name, Id or index of this DimensionStyle.","since":"6.0","parameters":[{"name":"source","summary":"DimensionStyle to copy settings from."}]},{"signature":"Bitmap CreatePreviewBitmap(int width, int height)","since":"6.0"},{"signature":"UnitSystem DimensionLengthDisplayUnit(uint model_serial_number)","since":"6.0"},{"signature":"DimensionStyle Duplicate()","summary":"Construct a deep (full) copy of this object.","since":"6.0","returns":"An object of the same type as this, with the same properties and behavior."},{"signature":"DimensionStyle Duplicate(string newName, Guid newId, Guid newParentId)","summary":"Construct a deep (full) copy of this object.","since":"6.0","returns":"An object of the same type as this, with the same properties and behavior."},{"signature":"bool IsChildOf(Guid parentId)","summary":"Tests if this DimensionStyle is a child of a specific DimensionStyle","since":"6.0","returns":"True if this is a child of the DimensionStyle with Parent False otherwise."},{"signature":"bool IsFieldOverriden(Field field)"},{"signature":"void ScaleLengthValues(double scale)","summary":"Scales all length values by \'scale\'","since":"6.0"},{"signature":"void SetFieldOverride(Field field)","summary":"Set a field as overridden","since":"6.0"}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.AngleDisplayFormat","dataType":"enum","summary":"Display format for angles","values":[{"signature":"DecimalDegrees   = 0","summary":"Decimal Degrees"},{"signature":"DegMinSec        = 1","summary":"Degrees Minutes Seconds"},{"signature":"Radians          = 2","summary":"Decimal Radians"},{"signature":"Grads            = 3","summary":"Decimal Gradians"}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.ArrowFit","dataType":"enum","summary":"Arrow display position inside or outside extension lines","values":[{"signature":"Auto = 0","summary":"Auto - Display when space permits"},{"signature":"ArrowsInside = 1","summary":"Force arrows inside extensions"},{"signature":"ArrowsOutside = 2","summary":"Force arrows outside extensions"}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.ArrowType","dataType":"enum","summary":"Defines enumerated values for arrowhead shapes.","values":[{"signature":"None = 0"},{"signature":"UserBlock = 1"},{"signature":"SolidTriangle = 2"},{"signature":"Dot = 3"},{"signature":"Tick = 4"},{"signature":"ShortTriangle = 5"},{"signature":"OpenArrow = 6"},{"signature":"Rectangle = 7"},{"signature":"LongTriangle = 8"},{"signature":"LongerTriangle = 9"}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.CenterMarkStyle","dataType":"enum","summary":"Style for drawing centermark for Radial dimensions and Centermark objects","values":[{"signature":"None = 0","summary":"No centermark display"},{"signature":"Mark = 1","summary":"+ mark only"},{"signature":"MarkAndLines = 2","summary":"+ mark and lines to radius"}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.Field","dataType":"enum","summary":"Field identifiers used for file i/o and getting/setting values","values":[{"signature":"Unset                          = 0"},{"signature":"Name                           = 1","summary":"Dimension style Name property. Cannot be inherited from parent."},{"signature":"Index                          = 2","summary":"Dimension style runtime model component index property. Cannot be inherited from parent."},{"signature":"ExtensionLineExtension         = 3"},{"signature":"ExtensionLineOffset            = 4"},{"signature":"Arrowsize                      = 5"},{"signature":"LeaderArrowsize                = 6"},{"signature":"Centermark                     = 7"},{"signature":"TextGap                        = 8"},{"signature":"TextHeight                     = 9"},{"signature":"DimTextLocation                = 10","summary":"Linear, angular, and ordinate dimension text location above/in/below"},{"signature":"MaskFrameType                  = 11","summary":"Text mask frame"},{"signature":"LengthResolution               = 12"},{"signature":"AngleFormat                    = 13"},{"signature":"AngleResolution                = 14"},{"signature":"Font                           = 15"},{"signature":"LengthFactor                   = 16","summary":"LengthFactor is a rarely used. It applies when a model is being drawn to a scale and the dimension length values should be reverse scaled. For example, if a model is drawn at 1/4 scale, a line 5 units long indicates the real world line is 20 units long. In this case setting LengthFactor to 4 would cause a linear dimension applied to that line to display a value of 20."},{"signature":"Alternate                      = 17"},{"signature":"AlternateLengthFactor          = 18","summary":"AlternateLengthFactor is a rarely used. See Length factor for a discription of this property."},{"signature":"AlternateLengthResolution      = 20"},{"signature":"Prefix                         = 21"},{"signature":"Suffix                         = 22"},{"signature":"AlternatePrefix                = 23"},{"signature":"AlternateSuffix                = 24"},{"signature":"DimensionLineExtension         = 25"},{"signature":"SuppressExtension1             = 26"},{"signature":"SuppressExtension2             = 27"},{"signature":"ExtLineColorSource             = 28"},{"signature":"DimLineColorSource             = 29"},{"signature":"ArrowColorSource               = 30"},{"signature":"TextColorSource                = 31"},{"signature":"ExtLineColor                   = 32"},{"signature":"DimLineColor                   = 33"},{"signature":"ArrowColor                     = 34"},{"signature":"TextColor                      = 35"},{"signature":"ExtLinePlotColorSource         = 36"},{"signature":"DimLinePlotColorSource         = 37"},{"signature":"ArrowPlotColorSource           = 38"},{"signature":"TextPlotColorSource            = 39"},{"signature":"ExtLinePlotColor               = 40"},{"signature":"DimLinePlotColor               = 41"},{"signature":"ArrowPlotColor                 = 42"},{"signature":"TextPlotColor                  = 43"},{"signature":"ExtLinePlotWeightSource        = 44"},{"signature":"DimLinePlotWeightSource        = 45"},{"signature":"ExtLinePlotWeight_mm           = 46"},{"signature":"DimLinePlotWeight_mm           = 47"},{"signature":"ToleranceFormat                = 48"},{"signature":"ToleranceResolution            = 49"},{"signature":"ToleranceUpperValue            = 50"},{"signature":"ToleranceLowerValue            = 51"},{"signature":"AltToleranceResolution         = 52"},{"signature":"ToleranceHeightScale           = 53"},{"signature":"BaselineSpacing                = 54"},{"signature":"DrawMask                       = 55"},{"signature":"MaskColorSource                = 56"},{"signature":"MaskColor                      = 57"},{"signature":"MaskBorder                     = 58"},{"signature":"DimensionScale                 = 59"},{"signature":"DimscaleSource                 = 60"},{"signature":"FixedExtensionLength           = 61"},{"signature":"FixedExtensionOn               = 62"},{"signature":"TextRotation                   = 63"},{"signature":"SuppressArrow1                 = 64"},{"signature":"SuppressArrow2                 = 65"},{"signature":"TextmoveLeader                 = 66"},{"signature":"ArclengthSymbol                = 67"},{"signature":"StackTextheightScale           = 68"},{"signature":"StackFormat                    = 69"},{"signature":"AltRound                       = 70"},{"signature":"Round                          = 71"},{"signature":"AngularRound                   = 72"},{"signature":"AltZeroSuppress                = 73"},{"signature":"AngleZeroSuppress              = 75"},{"signature":"ZeroSuppress                   = 76"},{"signature":"AltBelow                       = 77"},{"signature":"ArrowType1                     = 78"},{"signature":"ArrowType2                     = 79"},{"signature":"LeaderArrowType                = 80"},{"signature":"ArrowBlockId1                  = 81"},{"signature":"ArrowBlockId2                  = 82"},{"signature":"LeaderArrowBlock               = 83"},{"signature":"DimRadialTextLocation          = 84","summary":"Radial dimension text location above/in/below"},{"signature":"TextVerticalAlignment          = 85"},{"signature":"LeaderTextVerticalAlignment    = 86"},{"signature":"LeaderContentAngleStyle        = 87"},{"signature":"LeaderCurveType                = 88"},{"signature":"LeaderContentAngle             = 89"},{"signature":"LeaderHasLanding               = 90"},{"signature":"LeaderLandingLength            = 91"},{"signature":"MaskFlags                      = 92"},{"signature":"CentermarkStyle                = 93"},{"signature":"TextHorizontalAlignment        = 94"},{"signature":"LeaderTextHorizontalAlignment  = 95"},{"signature":"DrawForward                    = 96"},{"signature":"SignedOrdinate                 = 97"},{"signature":"UnitSystem                     = 98","summary":"Unit system for dimension rendering sizes like  TextHeight, TextGap, ArrowSize, ExtOffset, and dozens of other properties that control the appearance and placement of the components used to render a dimension."},{"signature":"TextMask                       = 99"},{"signature":"TextOrientation                = 100"},{"signature":"LeaderTextOrientation          = 101"},{"signature":"DimTextOrientation             = 102"},{"signature":"DimRadialTextOrientation       = 103"},{"signature":"DimTextAngleStyle              = 104"},{"signature":"DimRadialTextAngleStyle        = 105"},{"signature":"TextUnderlined                 = 106"},{"signature":"DimensionLengthDisplay = 109","summary":"Dimension length display. See ON_DimStyle::DimensionLengthDisplay() for a descpription of this parameter."},{"signature":"AlternateDimensionLengthDisplay = 110","summary":"Alternate dimension length display. See ON_DimStyle::AlternateDimensionLengthDisplay() for a descpription of this parameter."},{"signature":"ForceDimLine = 111","summary":"Force dimension line to draw when text is moved outside"},{"signature":"ArrowFit = 112","summary":"Arrow position when arrows won\'t fit between extensions"},{"signature":"TextFit = 113","summary":"Text position when text won\'t fit between extensions"},{"signature":"DecimalSeparator = 114","summary":"Character to use for decimal separator in dimension text"},{"signature":"Count = 115","summary":"Every enum UINT value that identifies a valid dimension style property is less than the UINT value of Count."}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.LeaderContentAngleStyle","dataType":"enum","summary":"Angle for text or other leader or dimension content","values":[{"signature":"Horizontal = 0","summary":"Annotation text is horizontal in annotation object\'s plane"},{"signature":"Aligned = 1","summary":"Aligned with last leader direction or dimension line"},{"signature":"Rotated = 2","summary":"Explicit angle"}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.LeaderCurveStyle","dataType":"enum","summary":"Type of leader curve","values":[{"signature":"None = 0"},{"signature":"Polyline = 1"},{"signature":"Spline = 2"}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.LengthDisplay","dataType":"enum","summary":"Dimension display length unit system and style","values":[{"signature":"ModelUnits = 0","summary":"Decimal current model units"},{"signature":"Millmeters = 3","summary":"Decimal Millimeters"},{"signature":"Centimeters = 4","summary":"Decimal Centimeters"},{"signature":"Meters = 5","summary":"Decimal Meters"},{"signature":"Kilometers = 6","summary":"Decimal Kilometers"},{"signature":"InchesDecimal = 7","summary":"Decimal Inches"},{"signature":"InchesFractional = 1","summary":"Fractional Inches ( 1.75 inches displays as 1-3/4 )"},{"signature":"FeetDecimal = 8","summary":"Decimal Feet"},{"signature":"FeetAndInches = 2","summary":"Feet and Inches ( 14.75 inches displays as 1\'-2-3/4\\" )"},{"signature":"Miles = 9","summary":"Decimal Miles"}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.LengthDisplayFormat","dataType":"enum","summary":"Obsolete format for length display - use ON_DimStyle::DimensionLengthDisplay instead","values":[{"signature":"Decimal       = 0","summary":"Obsolete - use ON_DimStyle::DimensionLengthDisplay::ModelUnits."},{"signature":"Fractional    = 1","summary":"Obsolete - use ON_DimStyle::DimensionLengthDisplay::InchesFractional"},{"signature":"FeetInches = 2","summary":"Obsolete - use ON_DimStyle::DimensionLengthDisplay::FeetAndInches"},{"signature":"FeetDecimalInches = 3","summary":"Obsolete - use ON_DimStyle::DimensionLengthDisplay::FeetAndInches enum."}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.MaskFrame","dataType":"enum","summary":"Draw a frame stroke around the text mask area","values":[{"signature":"NoFrame = 0","summary":"Text mask frame not drawn"},{"signature":"RectFrame = 1","summary":"Text mask frame outline rectangle drawn"}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.MaskType","dataType":"enum","summary":"Text mask drawn with background color or explicit color","values":[{"signature":"BackgroundColor = 0","summary":"Text mask drawn with background color"},{"signature":"MaskColor = 1","summary":"Text mask drawn with explicit color"}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.StackDisplayFormat","dataType":"enum","summary":"Format of stacked fractions","values":[{"signature":"None               = 0","summary":"No stacking"},{"signature":"StackHorizontal    = 1","summary":"Stack with horizontal line"},{"signature":"StackDiagonal      = 2","summary":"Stack with angled line"}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.TextFit","dataType":"enum","summary":"Text display position inside or outside extension lines","values":[{"signature":"Auto = 0","summary":"Auto - Display inside when space permits"},{"signature":"TextInside = 1","summary":"Force text inside extensions"},{"signature":"TextRight = 2","summary":"Force text outside to the right of extensions"},{"signature":"TextLeft = 3","summary":"Force text outside to the left of extensions"},{"signature":"TextHintRight = 4","summary":"Move text outside to the right of extensions when it won\'t fit inside"},{"signature":"TextHintLeft = 5","summary":"Move text outside to the left of extensions when it won\'t fit inside"}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.TextLocation","dataType":"enum","summary":"The location of text in linear, angular, radial, and ordinate dimensions.","values":[{"signature":"AboveDimLine = 0","summary":"Text is above dimension line."},{"signature":"InDimLine = 1","summary":"Text is centered in dimension line."},{"signature":"BelowDimLine = 2","summary":"Text is below dimension line."}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.ToleranceDisplayFormat","dataType":"enum","summary":"Style of tolerance display for dimensions","values":[{"signature":"None = 0","summary":"No tolerance display"},{"signature":"Symmetrical = 1","summary":"Symmetrical +/- tolerance"},{"signature":"Deviation = 2","summary":"Distance +tol, -tol"},{"signature":"Limits = 3","summary":"Distance upper and lower limits"}]},{"namespace":"Rhino.DocObjects","name":"DimensionStyle.ZeroSuppression","dataType":"enum","summary":"Marks leading and trailing zeros for removal.","values":[{"signature":"None                          = 0","summary":"No zero suppression."},{"signature":"SuppressLeading               = 1","summary":"Suppress leading zeros."},{"signature":"SuppressTrailing              = 2","summary":"Suppress trailing zeros."},{"signature":"SuppressLeadingAndTrailing    = 3","summary":"Suppress leading and trailing zeros."},{"signature":"SuppressZeroFeet              = 4","summary":"Suppress zero feet."},{"signature":"SuppressZeroInches            = 8","summary":"Suppress zero inches."},{"signature":"SuppressZeroFeetAndZeroInches = 12","summary":"Suppress zero feet and zero inches."}]},{"namespace":"Rhino.DocObjects","name":"DisplayMode","dataType":"enum","summary":"Defines enumerated values for display modes, such as wireframe or shaded.","since":"5.0","values":[{"signature":"Default = 0","summary":"The default display mode."},{"signature":"Wireframe = 1","summary":"The wireframe display mode.  \\nObjects are generally only outlined by their corresponding isocurves and edges."},{"signature":"Shaded = 2","summary":"The shaded display mode.  \\nObjects are generally displayed with their corresponding isocurves and edges, and are filled with their display colors."},{"signature":"RenderPreview = 3","summary":"The render display mode.  \\nObjects are generally displayed in a similar way to the one that will be resulting from rendering."}]},{"namespace":"Rhino.DocObjects","name":"DistanceDisplayMode","dataType":"enum","summary":"Defines enumerated values for the display of distances in US customary and Imperial units.","since":"5.0","values":[{"signature":"Decimal = 0","summary":"Shows distance decimals."},{"signature":"Feet = 1","summary":"Show feet."},{"signature":"FeetAndInches = 2","summary":"Show feet and inches."}]},{"namespace":"Rhino.DocObjects","name":"EarthAnchorPoint","dataType":"class","summary":"Contains information about the model\'s position in latitude, longitude, and elevation for GIS mapping applications.","interfaces":["IDisposable"],"constructors":[{"signature":"EarthAnchorPoint()","summary":"Initializes a new instance of the EarthAnchorPointclass.","since":"5.0"}],"properties":[{"signature":"string Description","summary":"Gets or sets the long form of the identifying information about this location.","since":"5.0","property":["get","set"]},{"signature":"double EarthBasepointElevation","summary":"Gets or sets the point elevation on earth, in meters.","since":"5.0","property":["get","set"]},{"signature":"BasepointZero EarthBasepointElevationZero","summary":"Gets or sets a value indicating the zero level convention relating to a location on Earth.","since":"5.0","property":["get","set"]},{"signature":"double EarthBasepointLatitude","summary":"Gets or sets a point latitude on earth, in degrees. +90 = north pole, 0 = equator, -90 = south pole.","since":"5.0","property":["get","set"]},{"signature":"double EarthBasepointLongitude","summary":"Gets or sets the point longitude on earth, in degrees.","since":"5.0","property":["get","set"]},{"signature":"Point3d ModelBasePoint","summary":"Corresponding model point in model coordinates.","since":"5.0","property":["get","set"]},{"signature":"Vector3d ModelEast","summary":"Earth directions in model coordinates.","since":"5.0","property":["get","set"]},{"signature":"Vector3d ModelNorth","summary":"Earth directions in model coordinates.","since":"5.0","property":["get","set"]},{"signature":"string Name","summary":"Gets or sets the short form of the identifying information about this location.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"bool EarthLocationIsSet()","summary":"Checks if the earth location is set or not.","since":"6.0","returns":"Boolean value, True if set else false"},{"signature":"Plane GetEarthAnchorPlane(out Vector3d anchorNorth)","summary":"Returns the earth anchor plane","since":"6.0","returns":"A plane value."},{"signature":"Plane GetModelCompass()","summary":"Returns a plane in model coordinates whose X axis points East, Y axis points North and Z axis points Up. The origin is set to ModelBasepoint.","since":"5.0","returns":"A plane value. This might be invalid on error."},{"signature":"Transform GetModelToEarthTransform(UnitSystem modelUnitSystem)","summary":"Gets a transformation from model coordinates to earth coordinates. This transformation assumes the model is small enough that the curvature of the earth can be ignored.","since":"5.0","parameters":[{"name":"modelUnitSystem","summary":"The model unit system."}],"returns":"Transform on success. Invalid Transform on error."}]},{"namespace":"Rhino.DocObjects","name":"ExtrusionObject","dataType":"class","baseclass":"Rhino.DocObjects.RhinoObject","properties":[{"signature":"Extrusion ExtrusionGeometry","since":"5.0","property":["get"]}],"methods":[{"signature":"Extrusion DuplicateExtrusionGeometry()","since":"5.0"}]},{"namespace":"Rhino.DocObjects","name":"Font","dataType":"class","summary":"Defines a format for text.","constructors":[{"signature":"Font(string familyName)","since":"6.0"},{"signature":"Font(string familyName, FontWeight weight, FontStyle style, bool underlined, bool strikethrough)","since":"6.0"}],"properties":[{"signature":"bool Bold","since":"5.0","property":["get"]},{"signature":"string Description","summary":"Returns a long description that includes family, face, weight, stretch and style information. Generally not useful for finding matching fonts.","since":"6.5","property":["get"]},{"signature":"string EnglishFaceName","summary":"Returns English Face name","since":"6.9","property":["get"]},{"signature":"string EnglishFamilyName","since":"6.9","property":["get"]},{"signature":"string EnglishQuartetName","since":"6.12","property":["get"]},{"signature":"string FaceName","summary":"Returns Face name","since":"5.0","property":["get"]},{"signature":"string FamilyName","since":"6.5","property":["get"]},{"signature":"string FamilyPlusFaceName","summary":"Returns concatenated Family and Face names","since":"6.9","property":["get"]},{"signature":"bool IsEngravingFont","since":"6.10","property":["get"]},{"signature":"bool IsSimulated","since":"6.5","property":["get"]},{"signature":"bool IsSingleStrokeFont","since":"6.5","property":["get"]},{"signature":"bool IsSymbolFont","since":"6.5","property":["get"]},{"signature":"bool Italic","since":"5.0","property":["get"]},{"signature":"string LogfontName","summary":"Returns Windows LOGFONT Face name","since":"6.5","property":["get"]},{"signature":"double PointSize","since":"6.0","property":["get"]},{"signature":"string PostScriptName","summary":"Returns the Font PostScriptName - \\"Apple font name\\"","since":"6.5","property":["get"]},{"signature":"string QuartetName","since":"6.7","property":["get"]},{"signature":"string RichTextFontName","summary":"Returns the Font RichTextFontName used in RTF strings: {\\\\\\\\fonttbl...{\\\\\\\\fN RichTextFontName;}...}","since":"6.5","property":["get"]},{"signature":"bool Strikeout","since":"6.0","property":["get"]},{"signature":"FontStyle Style","since":"6.0","property":["get"]},{"signature":"bool Underlined","since":"6.0","property":["get"]},{"signature":"FontWeight Weight","since":"6.0","property":["get"]}],"methods":[{"signature":"static string[] AvailableFontFaceNames()","since":"5.0"},{"signature":"static Font FromQuartetProperties(string quartetName, bool bold, bool italic)","since":"6.7"},{"signature":"static Font[] InstalledFonts()","since":"6.5"},{"signature":"static Font[] InstalledFonts(string familyName)","since":"6.5"},{"signature":"static FontQuartet[] InstalledFontsAsQuartets()","since":"6.7"}]},{"namespace":"Rhino.DocObjects","name":"Font.FontOrigin","dataType":"enum","summary":"Platform where font originated. This information is useful when searching for appropriate substitues.","values":[{"signature":"Unset = 0","summary":"Not set."},{"signature":"Unknown = 1","summary":"Origin unknown. Changing an ON_Font characteristic like weight or sytle sets the origin to unknown."},{"signature":"WindowsFont = 2","summary":"Set from a Windows IDWriteFont by ON_Font::SetFromDWriteFont() or a Windows LOGFONT by ON_Font::SetFromWindowsLogFont() and FaceName and WindowLogfontName match a font installed on a Windows device."},{"signature":"AppleFont = 3","summary":"Set from an Apple CTFont. The PostScriptName() and FamilyName() match a font installed on device running MacOS or iOS. The FaceName() matches the \\"typeface\\" name shonw in the MacOS FontBook app."}]},{"namespace":"Rhino.DocObjects","name":"Font.FontStretch","dataType":"enum","summary":"Horizontal expansion or contraction of font","values":[{"signature":"Unset = 0","summary":"Not set."},{"signature":"Ultracondensed = 1"},{"signature":"Extracondensed = 2"},{"signature":"Condensed = 3"},{"signature":"Semicondensed = 4"},{"signature":"Medium = 5","summary":"Default font stretch."},{"signature":"Semiexpanded = 6"},{"signature":"Expanded = 7"},{"signature":"Extraexpanded = 8"},{"signature":"Ultraexpanded = 9"}]},{"namespace":"Rhino.DocObjects","name":"Font.FontStyle","dataType":"enum","summary":"Vertical angle of font Upright, Italic, or Oblique","values":[{"signature":"Unset = 0","summary":"Not set."},{"signature":"Upright = 1","summary":"Default font style."},{"signature":"Italic = 2","summary":"The face is sloped so the top is to the right of the base. Face names sometimes use the word \\"oblique\\" for italic faces."},{"signature":"Oblique = 3","summary":"The face is sloped so the top is to the left of the base. This is extremely rare. NOTE WELL: Face names sometimes use the word \\"oblique\\" for italic faces."}]},{"namespace":"Rhino.DocObjects","name":"Font.FontType","dataType":"enum","summary":"An enum that reports if the font face is avaialable on the current device.","values":[{"signature":"Unset = 0","summary":"Not set."},{"signature":"ManagedFont = 1","summary":"In the managed font list."},{"signature":"InstalledFont = 2","summary":"In the installed font list."}]},{"namespace":"Rhino.DocObjects","name":"Font.FontWeight","dataType":"enum","summary":"Weight enum values Avoid casting these values to int. Use ON_Font::WindowsLogfontWeightFromWeight() or ON_Font::AppleWeightOfFontFromWeight() or add another converter.","values":[{"signature":"Unset = 0","summary":"Not set."},{"signature":"Thin = 1","summary":"IsLight = True"},{"signature":"Ultralight = 2","summary":"IsLight = True"},{"signature":"Light = 3","summary":"IsLight = True"},{"signature":"Normal = 4","summary":"Default font weight. IsNormalWeight = True  Also called Regular."},{"signature":"Medium = 5","summary":"IsNormalWeight = True"},{"signature":"Semibold = 6","summary":"IsBold = True"},{"signature":"Bold = 7","summary":"IsBold = True"},{"signature":"Ultrabold = 8","summary":"IsBold = True"},{"signature":"Heavy      = 9","summary":"IsBold = True Also called Black"}]},{"namespace":"Rhino.DocObjects","name":"FontQuartet","dataType":"class","constructors":[{"signature":"FontQuartet(string name, bool supportsRegular, bool supportsBold, bool supportsItalic, bool supportsBoldItalic)","since":"6.26"}],"properties":[{"signature":"bool HasBoldFont","since":"6.7","property":["get","set"]},{"signature":"bool HasBoldItalicFont","since":"6.7","property":["get","set"]},{"signature":"bool HasItalicFont","since":"6.7","property":["get","set"]},{"signature":"bool HasRegularFont","since":"6.7","property":["get","set"]},{"signature":"string QuartetName","since":"6.7","property":["get","set"]}],"methods":[{"signature":"string ToString()"}]},{"namespace":"Rhino.DocObjects","name":"GripObject","dataType":"class","baseclass":"Rhino.DocObjects.RhinoObject","properties":[{"signature":"Point3d CurrentLocation","since":"5.0","property":["get","set"]},{"signature":"int Index","since":"5.0","property":["get","set"]},{"signature":"bool Moved","summary":"True if the grip has moved from OriginalLocation.","since":"5.0","property":["get"]},{"signature":"Point3d OriginalLocation","since":"5.0","property":["get"]},{"signature":"Guid OwnerId","since":"5.0","property":["get"]},{"signature":"double Weight","summary":"The weight of a NURBS control point grip or RhinoMath.UnsetValue if the grip is not a NURBS control point grip.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"bool GetCageParameters(out double u, out double v, out double w)","summary":"Retrieves the 2d parameter space values of this GripObject from the cage it\'s associated with.","since":"6.0","returns":"True on success. Output is unreliable if return is false."},{"signature":"bool GetCurveParameters(out double t)","summary":"Retrieves the 2d parameter space values of this GripObject from the curve it\'s associated with.","since":"6.0","returns":"True on success. Output is unreliable if return is false."},{"signature":"bool GetGripDirections(out Vector3d u, out Vector3d v, out Vector3d normal)","summary":"Sometimes grips have directions.  These directions can have any length and do not have to be orthogonal.","since":"6.0","parameters":[{"name":"u","summary":"u direction"},{"name":"v","summary":"v direction"},{"name":"normal","summary":"normal direction"}],"returns":"True if the grip has directions."},{"signature":"bool GetSurfaceParameters(out double u, out double v)","summary":"Retrieves the 2d parameter space values of this GripObject from the surface it\'s associated with.","since":"6.0","returns":"True on success. Output is unreliable if return is false."},{"signature":"void Move(Point3d newLocation)","summary":"Moves the grip to a new location.","since":"5.0","parameters":[{"name":"newLocation","summary":"New location for grip."}]},{"signature":"void Move(Transform xform)","summary":"Moves the grip to a new location.","since":"5.0","parameters":[{"name":"xform","summary":"Transformation applied to the OriginalLocation point."}]},{"signature":"void Move(Vector3d delta)","summary":"Moves the grip to a new location.","since":"5.0","parameters":[{"name":"delta","summary":"Translation applied to the OriginalLocation point."}]},{"signature":"GripObject NeighborGrip(int directionR, int directionS, int directionT, bool wrap)","summary":"Used to get a grip\'s logical neighbors, like NURBS curve, surface, and cage control point grips.","since":"5.0","parameters":[{"name":"directionR","summary":"-1 to go back one grip, +1 to move forward one grip.  For curves, surfaces and cages, this is the first parameter direction."},{"name":"directionS","summary":"-1 to go back one grip, +1 to move forward one grip.  For surfaces and cages this is the second parameter direction."},{"name":"directionT","summary":"For cages this is the third parameter direction"},{"name":"wrap","summary":""}],"returns":"logical neighbor or None if the is no logical neighbor"},{"signature":"void UndoMove()","summary":"Undoes any grip moves made by calling Move.","since":"5.0"}]},{"namespace":"Rhino.DocObjects","name":"Group","dataType":"class","baseclass":"Rhino.DocObjects.ModelComponent","properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.Group.","since":"6.0","property":["get"]},{"signature":"int UserStringCount","summary":"Gets the amount of user strings.","since":"6.4","property":["get"]}],"methods":[{"signature":"string GetUserString(string key)","summary":"Gets user string from this geometry.","since":"6.4","parameters":[{"name":"key","summary":"id used to retrieve the string."}],"returns":"string associated with the key if successful. None if no key was found."},{"signature":"System.Collections.Specialized.NameValueCollection GetUserStrings()","summary":"Gets a copy of all (user key string, user value string) pairs attached to this geometry.","since":"6.4","returns":"A new collection."},{"signature":"bool SetUserString(string key, string value)","summary":"Attach a user string (key,value combination) to this geometry.","since":"6.4","parameters":[{"name":"key","summary":"id used to retrieve this string."},{"name":"value","summary":"string associated with key."}],"returns":"True on success."}]},{"namespace":"Rhino.DocObjects","name":"HatchObject","dataType":"class","baseclass":"Rhino.DocObjects.RhinoObject","properties":[{"signature":"Hatch HatchGeometry","since":"5.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"HatchPattern","dataType":"class","baseclass":"Rhino.DocObjects.ModelComponent","constructors":[{"signature":"HatchPattern()","since":"5.0"}],"properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.HatchPattern.","since":"6.0","property":["get"]},{"signature":"string Description","since":"5.0","property":["get","set"]},{"signature":"HatchPatternFillType FillType","since":"5.0","property":["get","set"]},{"signature":"int Index","summary":"Index in the hatch pattern table for this pattern. -1 if not in the table.","since":"5.0","property":["get","set"]},{"signature":"bool IsDeleted","summary":"Deleted hatch patterns are kept in the runtime hatch pattern table so that undo will work with hatch patterns.  Call IsDeleted to determine to determine if a hatch pattern is deleted.","since":"5.0","property":["get"]},{"signature":"bool IsReference","summary":"Rhino allows multiple files to be viewed simultaneously. Hatch patterns in the document are \\"normal\\" or \\"reference\\". Reference hatch patterns are not saved.","since":"5.0","property":["get"]}],"methods":[{"signature":"static HatchPattern[] ReadFromFile(string filename, bool quiet)","summary":"Reads hatch pattern definitions from a file.","since":"5.0","parameters":[{"name":"filename","summary":"Name of an existing file. If filename is None or empty, default hatch pattern filename is used."},{"name":"quiet","summary":"Ignored."}],"returns":"An array of hatch patterns. This can be null, but not empty."},{"signature":"Rhino.Geometry.Line[] CreatePreviewGeometry(int width, int height, double angle)","summary":"Creates preview line segments of the hatch pattern.","since":"6.8","parameters":[{"name":"width","summary":"The width of the preview."},{"name":"height","summary":"The height of the preview."},{"name":"angle","summary":"The rotation angle of the pattern display in radians."}],"returns":"The preview line segments if successful, an empty array on failure."}]},{"namespace":"Rhino.DocObjects","name":"HatchPattern.Defaults","dataType":"class","properties":[{"signature":"static HatchPattern Dash","since":"6.0","property":["get"]},{"signature":"static HatchPattern Grid","since":"6.0","property":["get"]},{"signature":"static HatchPattern Grid60","since":"6.0","property":["get"]},{"signature":"static HatchPattern Hatch1","since":"6.0","property":["get"]},{"signature":"static HatchPattern Hatch2","since":"6.0","property":["get"]},{"signature":"static HatchPattern Hatch3","since":"6.0","property":["get"]},{"signature":"static HatchPattern Plus","since":"6.0","property":["get"]},{"signature":"static HatchPattern Solid","since":"6.0","property":["get"]},{"signature":"static HatchPattern Squares","since":"6.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"HatchPatternFillType","dataType":"enum","since":"5.0","values":[{"signature":"Solid = 0"},{"signature":"Lines = 1"},{"signature":"Gradient = 2"}]},{"namespace":"Rhino.DocObjects","name":"HistoryRecord","dataType":"class","summary":"Provides a single bundling of information to be passed to Rhino when setting up history for an object.","remarks":"To use this object, just pass it to a RhinoDoc.Add() method along with the needed geometry. Do not reuse this class for more than one history addition.","interfaces":["IDisposable"],"constructors":[{"signature":"HistoryRecord(Command command, int version)","since":"5.0"}],"properties":[{"signature":"bool CopyOnReplaceObject","summary":"When an object is replaced and the old object has a history record with this field set, the history record is copied and attached to the new object. That allows a descendant object to continue the history linkage after it is edited.","since":"6.0","property":["get","set"]},{"signature":"IntPtr Handle","summary":"Wrapped native C++ pointer to CRhinoHistory instance","since":"5.0","property":["get"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"bool SetBool(int id, bool value)","since":"5.0"},{"signature":"bool SetBools(int id, IEnumerable<bool> values)","since":"5.0"},{"signature":"bool SetBrep(int id, Brep value)","since":"5.0"},{"signature":"bool SetColor(int id, Color value)","since":"5.0"},{"signature":"bool SetColors(int id, IEnumerable<Color> values)","since":"5.0"},{"signature":"bool SetCurve(int id, Curve value)","since":"5.0"},{"signature":"bool SetDouble(int id, double value)","since":"5.0"},{"signature":"bool SetDoubles(int id, IEnumerable<double> values)","since":"5.0"},{"signature":"bool SetGuid(int id, Guid value)","since":"5.0"},{"signature":"bool SetGuids(int id, IEnumerable<Guid> values)","since":"5.0"},{"signature":"bool SetHistoryVersion(int historyVersion)","summary":"Specifies a non-zero integer that identifies the version of this history record. The virtual ReplayHistory() functions can check this version to avoid replaying history using information created by earlier versions of the command.","since":"6.0","parameters":[{"name":"historyVersion","summary":"Any non-zero integer. It is strongly suggested that something like YYYYMMDD be used."}],"returns":"True if successful."},{"signature":"bool SetInt(int id, int value)","since":"5.0"},{"signature":"bool SetInts(int id, IEnumerable<int> values)","since":"5.0"},{"signature":"bool SetMesh(int id, Mesh value)","since":"5.0"},{"signature":"bool SetObjRef(int id, ObjRef value)","since":"5.0"},{"signature":"bool SetPoint3d(int id, Point3d value)","since":"5.0"},{"signature":"bool SetPoint3dOnObject(int id, ObjRef objref, Point3d value)","since":"5.0"},{"signature":"bool SetPoint3ds(int id, IEnumerable<Point3d> values)","since":"5.0"},{"signature":"bool SetString(int id, string value)","since":"5.0"},{"signature":"bool SetStrings(int id, IEnumerable<string> values)","since":"5.0"},{"signature":"bool SetSurface(int id, Surface value)","since":"5.0"},{"signature":"bool SetTransorm(int id, Transform value)","since":"5.0"},{"signature":"bool SetVector3d(int id, Vector3d value)","since":"5.0"},{"signature":"bool SetVector3ds(int id, IEnumerable<Vector3d> values)","since":"5.0"}]},{"namespace":"Rhino.DocObjects","name":"InstanceDefinition","dataType":"class","summary":"This is the same as InstanceDefinitionGeometry, but in a Rhino document.","baseclass":"Rhino.Geometry.InstanceDefinitionGeometry","properties":[{"signature":"InstanceDefinitionArchiveFileStatus ArchiveFileStatus","summary":"Returns the archive file status of a linked instance definition.","since":"5.2","property":["get"]},{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.InstanceDefinition.","since":"6.0","property":["get"]},{"signature":"int Index","summary":"Index of this instance definition in the index definition table.","since":"5.0","property":["get"]},{"signature":"bool IsDeleted","since":"5.0","property":["get"]},{"signature":"bool IsReference","summary":"An object from a work session reference model is reference a reference object and cannot be modified.  An object is a reference object if, and only if, it is on a reference layer.","since":"5.0","property":["get"]},{"signature":"bool IsTenuous","since":"5.0","property":["get"]},{"signature":"InstanceDefinitionLayerStyle LayerStyle","since":"5.0","property":["get"]},{"signature":"int ObjectCount","summary":"Number of objects this definition uses. This counts the objects that are used to define the geometry. This does NOT count the number of references to this instance definition.","since":"5.0","property":["get"]},{"signature":"bool SkipNestedLinkedDefinitions","summary":"Controls how much geometry is read when a linked InstanceDefinition is updated.","since":"5.0","property":["get"]},{"signature":"string SourceArchive","since":"5.0","property":["get"]},{"signature":"InstanceDefinitionUpdateType UpdateType","since":"5.0","property":["get"]}],"methods":[{"signature":"System.Drawing.Bitmap CreatePreviewBitmap(DefinedViewportProjection definedViewportProjection, DisplayMode displayMode, Size bitmapSize)","summary":"Creates a preview bitmap of the instance definition.","since":"5.0","parameters":[{"name":"definedViewportProjection","summary":"The view projection."},{"name":"displayMode","summary":"The display mode."},{"name":"bitmapSize","summary":"The bitmap size in pixels."}],"returns":"The preview bitmap if successful, None otherwise."},{"signature":"System.Drawing.Bitmap CreatePreviewBitmap(DefinedViewportProjection definedViewportProjection, DisplayMode displayMode, Size bitmapSize, bool applyDpiScaling)","summary":"Creates a preview bitmap of the instance definition.","since":"6.0","parameters":[{"name":"definedViewportProjection","summary":"The view projection."},{"name":"displayMode","summary":"The display mode."},{"name":"bitmapSize","summary":"The bitmap size in pixels."},{"name":"applyDpiScaling","summary":"Specify True to apply DPI scaling (Windows-only)."}],"returns":"The preview bitmap if successful, None otherwise."},{"signature":"System.Drawing.Bitmap CreatePreviewBitmap(DefinedViewportProjection definedViewportProjection, Size bitmapSize)","summary":"Creates a wireframe preview bitmap of the instance definition.","since":"5.0","parameters":[{"name":"definedViewportProjection","summary":"The view projection."},{"name":"bitmapSize","summary":"The bitmap size in pixels."}],"returns":"The preview bitmap if successful, None otherwise."},{"signature":"System.Drawing.Bitmap CreatePreviewBitmap(DefinedViewportProjection definedViewportProjection, Size bitmapSize, bool applyDpiScaling)","summary":"Creates a wireframe preview bitmap of the instance definition.","since":"6.0","parameters":[{"name":"definedViewportProjection","summary":"The view projection."},{"name":"bitmapSize","summary":"The bitmap size in pixels."},{"name":"applyDpiScaling","summary":"Specify True to apply DPI scaling (Windows-only)."}],"returns":"The preview bitmap if successful, None otherwise."},{"signature":"System.Drawing.Bitmap CreatePreviewBitmap(Guid definitionObjectId, DefinedViewportProjection definedViewportProjection, DisplayMode displayMode, Size bitmapSize, bool applyDpiScaling)","summary":"Creates a preview bitmap of the instance definition.","since":"6.21","parameters":[{"name":"definitionObjectId","summary":"Id of one of this definition\'s objects to draw selected."},{"name":"definedViewportProjection","summary":"The view projection."},{"name":"displayMode","summary":"The display mode."},{"name":"bitmapSize","summary":"The bitmap size in pixels."},{"name":"applyDpiScaling","summary":"Specify True to apply DPI scaling (Windows-only)."}],"returns":"The preview bitmap if successful, None otherwise."},{"signature":"bool Equals(object obj)","summary":"Equality is checked against InstanceDefinition.Id","returns":"True if obj.Id equals Id"},{"signature":"InstanceDefinition[] GetContainers()","summary":"Gets a list of all the InstanceDefinitions that contain a reference this InstanceDefinition.","since":"5.0","returns":"An array of instance definitions. The returned array can be empty, but not null."},{"signature":"int GetHashCode()","summary":"Use Id.GetHashCode()"},{"signature":"RhinoObject[] GetObjects()","summary":"Gets an array with the objects that belong to this instance definition.","since":"5.0","returns":"An array of Rhino objects. The returned array can be empty, but not null."},{"signature":"InstanceObject[] GetReferences(int wheretoLook)","summary":"Gets a list of the CRhinoInstanceObjects (inserts) that contains a reference this instance definition.","since":"5.0","parameters":[{"name":"wheretoLook","summary":"0 = get top level references in active document.  \\n1 = get top level and nested references in active document.  \\n2 = check for references from other instance definitions."}],"returns":"An array of instance objects. The returned array can be empty, but not null."},{"signature":"bool InUse(int wheretoLook)","summary":"Determines whether the instance definition is referenced.","since":"5.0","parameters":[{"name":"wheretoLook","summary":"0 = check for top level references in active document.  \\n1 = check for top level and nested references in active document.  \\n2 = check for references in other instance definitions."}],"returns":"True if the instance definition is used; otherwise false."},{"signature":"RhinoObject Object(int index)","summary":"returns an object used as part of this definition.","since":"5.0","parameters":[{"name":"index","summary":"0 <= index < ObjectCount."}],"returns":"Returns an object that is used to define the geometry. Does NOT return an object that references this definition.count the number of references to this instance."},{"signature":"int UsesDefinition(int otherIdefIndex)","summary":"Determines if this instance definition contains a reference to another instance definition.","since":"5.0","parameters":[{"name":"otherIdefIndex","summary":"index of another instance definition."}],"returns":"0      no 1      other_idef_index is the index of this instance definition >1      This InstanceDefinition uses the instance definition and the returned value is the nesting depth."}]},{"namespace":"Rhino.DocObjects","name":"InstanceDefinitionArchiveFileStatus","dataType":"enum","summary":"The archive file of a linked instance definition can have the following possible states. Use InstanceObject.ArchiveFileStatus to query a instance definition\'s archive file status.","since":"5.2","values":[{"signature":"NotALinkedInstanceDefinition = -3","summary":"The instance definition is not a linked instance definition."},{"signature":"LinkedFileNotReadable = -2","summary":"The instance definition\'s archive file is not readable."},{"signature":"LinkedFileNotFound = -1","summary":"The instance definition\'s archive file cannot be found."},{"signature":"LinkedFileIsUpToDate = 0","summary":"The instance definition\'s archive file is up-to-date."},{"signature":"LinkedFileIsNewer = 1","summary":"The instance definition\'s archive file is newer."},{"signature":"LinkedFileIsOlder = 2","summary":"The instance definition\'s archive file is older."},{"signature":"LinkedFileIsDifferent = 3","summary":"The instance definition\'s archive file is different."}]},{"namespace":"Rhino.DocObjects","name":"InstanceDefinitionLayerStyle","dataType":"enum","summary":"A InstanceDefinitionUpdateType.Static or InstanceDefinitionUpdateType.LinkedAndEmbedded instance definition must have LayerStyle = Unset, a InstanceDefinitionUpdateType.Linked InstanceDefnition must have LayerStyle = Active or Reference","since":"5.0","values":[{"signature":"None = 0"},{"signature":"Active = 1"},{"signature":"Reference = 2"}]},{"namespace":"Rhino.DocObjects","name":"InstanceDefinitionUpdateType","dataType":"enum","summary":"The possible relationships between the instance definition geometry and the archive containing the original definition.","since":"5.0","values":[{"signature":"Static = 0","summary":"The Rhino user interface uses the term \\"Embedded\\" for Static update types. This instance definition is never updated. If m_source_archive is set, it records the origin of the instance definition geometry, but m_source_archive is never used to update the instance definition."},{"signature":"    Embedded = 1","summary":"This instance definition geometry was imported from another archive (m_source_archive) and is embedded. If m_source_archive changes, the user is asked if they want to update the instance definition."},{"signature":"LinkedAndEmbedded = 2","summary":"This instance definition geometry was imported from another archive (m_source_archive) and is embedded. If m_source_archive changes, the instance definition is automatically updated. If m_source_archive is not available, the instance definition is still valid."},{"signature":"Linked = 3","summary":"This instance definition geometry was imported from another archive (m_source_archive) and is not embedded. If m_source_archive changes, the instance definition is automatically updated. If m_source_archive is not available, the instance definition is not valid. This does not save runtime memory.  It may save a little disk space, but it is a  foolish option requested by people who do not understand all the issues."}]},{"namespace":"Rhino.DocObjects","name":"InstanceObject","dataType":"class","baseclass":"Rhino.DocObjects.RhinoObject","properties":[{"signature":"Point3d InsertionPoint","summary":"Base point coordinates of a block.","since":"5.0","property":["get"]},{"signature":"InstanceDefinition InstanceDefinition","summary":"instance definition that this object uses.","since":"5.0","property":["get"]},{"signature":"Transform InstanceXform","summary":"transformation applied to an instance definition for this object.","since":"5.0","property":["get"]}],"methods":[{"signature":"void Explode(bool explodeNestedInstances, out RhinoObject[] pieces, out ObjectAttributes[] pieceAttributes, out Transform[] pieceTransforms)","summary":"Explodes the instance reference into pieces.","since":"5.0","parameters":[{"name":"explodeNestedInstances","summary":"If true, then nested instance references are recursively exploded into pieces until actual geometry is found. If false, an InstanceObject is added to the pieces out parameter when this InstanceObject has nested references."},{"name":"pieces","summary":"An array of Rhino objects will be assigned to this out parameter during this call."},{"name":"pieceAttributes","summary":"An array of object attributes will be assigned to this out parameter during this call."},{"name":"pieceTransforms","summary":"An array of the previously applied transform matrices will be assigned to this out parameter during this call."}]},{"signature":"bool UsesDefinition(int definitionIndex, out int nestingLevel)","summary":"Determine if this reference uses an instance definition","since":"5.2","parameters":[{"name":"definitionIndex","summary":""},{"name":"nestingLevel","summary":"If the instance definition is used, this is the definition\'s nesting depth"}],"returns":"True or False depending on if the definition is used"}]},{"namespace":"Rhino.DocObjects","name":"Layer","dataType":"class","baseclass":"Rhino.DocObjects.ModelComponent","interfaces":["IEquatable<Layer>"],"constructors":[{"signature":"Layer()","since":"5.0"}],"properties":[{"signature":"static string PathSeparator","summary":"The string \\"::\\" (colon,colon) is used to separate parent and child layer names.","since":"6.0","property":["get"]},{"signature":"Color Color","summary":"Gets or sets the display color for this layer.","since":"5.0","property":["get","set"]},{"signature":"ComponentStatus ComponentStatus","summary":"Gets or sets the status of the layer.","since":"6.0","property":["get","set"]},{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.Layer.","since":"6.0","property":["get"]},{"signature":"string FullPath","summary":"Gets the full path to this layer. The full path includes nesting information.","since":"5.0","property":["get"]},{"signature":"Guid Id","summary":"Gets or sets the ID of this layer object. You typically do not need to assign a custom ID.","since":"5.0","property":["get","set"]},{"signature":"int IgesLevel","summary":"Gets or sets the IGES level for this layer.","since":"5.0","property":["get","set"]},{"signature":"bool IsDeleted","summary":"Gets a value indicating whether this layer has been deleted and is currently in the Undo buffer.","since":"5.0","property":["get"]},{"signature":"bool IsExpanded","summary":"Gets or sets a value indicating whether this layer is expanded in the Rhino Layer dialog.","since":"5.0","property":["get","set"]},{"signature":"bool IsLocked","summary":"Gets or sets a value indicating the locked state of this layer.","since":"5.0","property":["get","set"]},{"signature":"bool IsReference","summary":"Gets a value indicting whether this layer is a referenced layer. Referenced layers are part of referenced documents.","since":"5.0","property":["get"]},{"signature":"bool IsVisible","summary":"Gets or sets the visibility of this layer.","since":"5.0","property":["get","set"]},{"signature":"int LayerIndex","summary":"Gets or sets the index of this layer.","since":"5.0","property":["get","set"]},{"signature":"int LinetypeIndex","summary":"Gets or sets the line-type index for this layer.","since":"5.0","property":["get","set"]},{"signature":"string Name","summary":"Gets or sets the name of this layer.","since":"5.0","property":["get","set"]},{"signature":"Guid ParentLayerId","summary":"Gets the ID of the parent layer. Layers can be organized in a hierarchical structure, in which case this returns the parent layer ID. If the layer has no parent, Guid.Empty will be returned.","since":"5.0","property":["get","set"]},{"signature":"Color PlotColor","summary":"Gets or sets the plot color for this layer.","since":"5.0","property":["get","set"]},{"signature":"double PlotWeight","summary":"Gets or sets the weight of the plotting pen in millimeters. A weight of 0.0 indicates the \\"default\\" pen weight should be used. A weight of -1.0 indicates the layer should not be printed.","since":"5.0","property":["get","set"]},{"signature":"RenderMaterial RenderMaterial","summary":"Gets or sets the Render.RenderMaterialfor objects on this layer that have MaterialSource() == MaterialFromLayer. A None result indicates that no Render.RenderMaterialhas been assigned  and the material created by the default Material constructor or the RenderMaterialIndexshould be used.","since":"5.7","property":["get","set"]},{"signature":"int RenderMaterialIndex","summary":"Gets or sets the index of render material for objects on this layer that have MaterialSource() == MaterialFromLayer. A material index of -1 indicates no material has been assigned and the material created by the default Material constructor should be used.","since":"5.0","property":["get","set"]},{"signature":"int SortIndex","summary":"Runtime index used to sort layers in layer dialog.","since":"5.0","property":["get"]},{"signature":"int UserStringCount","summary":"Gets the amount of user strings.","since":"5.0","property":["get"]}],"methods":[{"signature":"static Layer GetDefaultLayerProperties()","summary":"Constructs a layer with the current default properties. The default layer properties are:  \\ncolor = Rhino.ApplicationSettings.AppearanceSettings.DefaultLayerColor  \\nline style = Rhino.ApplicationSettings.AppearanceSettings.DefaultLayerLineStyle  \\nmaterial index = -1  \\nIGES level = -1  \\nmode = NormalLayer  \\nname = empty  \\nlayer index = 0 (ignored by AddLayer)","since":"5.0","returns":"A new layer instance."},{"signature":"static string GetLeafName(Layer layer)","summary":"Get a layer name\'s \\"leaf\\" level name","since":"6.0","returns":"leaf name or String.Empty if fullPath does not contain a leaf"},{"signature":"static string GetLeafName(string fullPath)","summary":"Get a layer name\'s \\"leaf\\" level name","since":"6.0","returns":"leaf name or String.Empty if fullPath does not contain a leaf"},{"signature":"static string GetParentName(Layer layer)","summary":"Get a layer\'s \\"parent\\" path name","since":"6.0","returns":"parent name or String.Empty"},{"signature":"static string GetParentName(string fullPath)","summary":"Get a layer\'s \\"parent\\" path name","since":"6.0","returns":"parent name or String.Empty"},{"signature":"static bool IsValidName(string name)","summary":"Determines if a given string is valid for a layer name.","since":"5.0","parameters":[{"name":"name","summary":"A name to be validated."}],"returns":"True if the name is valid for a layer name; otherwise, false."},{"signature":"bool CommitChanges()","since":"5.0","deprecated":"6.0"},{"signature":"void CopyAttributesFrom(Layer otherLayer)","summary":"Copy typical attributes from another layer","since":"6.0"},{"signature":"void Default()","summary":"Sets layer to default settings.","since":"5.0"},{"signature":"void DeletePerViewportColor(Guid viewportId)","summary":"Remove any per viewport layer color setting so the layer\'s overall setting will be used for all viewports.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the setting for this viewport will be deleted. If Guid.Empty, the all per viewport layer color settings will be removed."}]},{"signature":"void DeletePerViewportPlotColor(Guid viewportId)","summary":"Remove any per viewport layer plot color setting so the layer\'s overall setting will be used for all viewports.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the setting for this viewport will be deleted. If Guid.Empty, the all per viewport layer color settings will be removed."}]},{"signature":"void DeletePerViewportPlotWeight(Guid viewportId)","summary":"Remove any per viewport layer plot weight setting so the layer\'s overall setting will be used for all viewports.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the setting for this viewport will be deleted. If Guid.Empty, the all per viewport layer color settings will be removed."}]},{"signature":"void DeletePerViewportSettings(Guid viewportId)","summary":"Deletes per viewport layer settings.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the settings for that viewport are deleted. If Guid.Empty, then all per viewport settings are deleted."}]},{"signature":"void DeletePerViewportVisible(Guid viewportId)","summary":"Remove any per viewport visibility setting so the layer\'s overall setting will be used for all viewports.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the setting for this viewport will be deleted. If Guid.Empty, the all per viewport visibility settings will be removed."}]},{"signature":"bool Equals(Layer other)","since":"6.0"},{"signature":"bool Equals(object obj)"},{"signature":"Layer[] GetChildren()","summary":"Gets immediate children of this layer. Note that child layers may have their own children.","since":"5.0","returns":"Array of child layers. None if this layer does not have any children."},{"signature":"int GetHashCode()"},{"signature":"bool GetPersistentLocking()","summary":"The persistent locking setting is used for layers that can be locked by a \\"parent\\" object. A common case is when a layer is a child layer (Layer.ParentI is not nil). In this case, when a parent layer is locked, then child layers are also locked. The persistent locking setting determines what happens when the parent is unlocked again.","since":"5.5"},{"signature":"bool GetPersistentVisibility()","summary":"The persistent viability setting is used for layers whose visibility can be changed by a \\"parent\\" object. A common case is when a layer is a child layer (ParentId is not nil). In this case, when a parent layer is turned off, then child layers are also turned off. The persistent visibility setting determines what happens when the parent is turned on again.","since":"5.5"},{"signature":"string GetUserString(string key)","summary":"Gets user string from this geometry.","since":"5.0","parameters":[{"name":"key","summary":"id used to retrieve the string."}],"returns":"string associated with the key if successful. None if no key was found."},{"signature":"System.Collections.Specialized.NameValueCollection GetUserStrings()","summary":"Gets a copy of all (user key string, user value string) pairs attached to this geometry.","since":"5.0","returns":"A new collection."},{"signature":"bool HasPerViewportSettings(Guid viewportId)","summary":"Verifies that a layer has per viewport settings.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then checks for settings for that specific viewport. If Guid.Empty, then checks for any viewport settings."}],"returns":"True if the layer has per viewport settings, False otherwise."},{"signature":"bool IsChildOf(Guid otherlayerId)","since":"6.0"},{"signature":"bool IsChildOf(int layerIndex)","since":"5.0"},{"signature":"bool IsChildOf(Layer otherLayer)","since":"5.0"},{"signature":"bool IsParentOf(Guid otherLayer)","since":"6.0"},{"signature":"bool IsParentOf(int layerIndex)","since":"5.0"},{"signature":"bool IsParentOf(Layer otherLayer)","since":"5.0"},{"signature":"System.Drawing.Color PerViewportColor(Guid viewportId)","summary":"Gets the display color for this layer.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the setting applies only to the viewport with the specified id."}],"returns":"The display color."},{"signature":"bool PerViewportIsVisible(Guid viewportId)","summary":"Gets the per viewport visibility of this layer.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the visibility setting for that viewport is returned. If Guid.Empty, the IsVisible property is returned."}],"returns":"Returns True if objects on layer are visible."},{"signature":"bool PerViewportPersistentVisibility(Guid viewportId)","summary":"Gets the per layer persistent visibility. The persistent viability setting is used for layers whose visibility can be changed by a parent layer. In this case, when a parent layer is turned off, then child layers are also turned off. The persistent visibility setting determines what happens when the parent is turned on again.","since":"6.0","returns":"Return True if this layer\'s visibility in the specified viewport is controlled by a parent object and the parent is turned on (after being off), then this layer will also be turned on in the specified viewport. Returns False if this layer\'s visibility in the specified viewport is controlled by a parent object and the parent layer is turned on(after being off), then this layer will continue to be off in the specified viewport."},{"signature":"System.Drawing.Color PerViewportPlotColor(Guid viewportId)","summary":"Gets the plot color for this layer.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the setting applies only to the viewport with the specified id."}],"returns":"The plot color."},{"signature":"double PerViewportPlotWeight(Guid viewportId)","summary":"Gets the plot weight, in millimeters, for this layer.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the setting applies only to the viewport with the specified id."}],"returns":"The plot color."},{"signature":"void SetPersistentLocking(bool persistentLocking)","summary":"Set the persistent locking setting for this layer","since":"5.5"},{"signature":"void SetPersistentVisibility(bool persistentVisibility)","summary":"Set the persistent visibility setting for this layer","since":"5.5"},{"signature":"void SetPerViewportColor(Guid viewportId, Color color)","summary":"Sets the display color for this layer.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the setting applies only to the viewport with the specified id."},{"name":"color","summary":"The display color."}]},{"signature":"void SetPerViewportPersistentVisibility(Guid viewportId, bool persistentVisibility)","summary":"Sets the per layer persistent visibility. The persistent viability setting is used for layers whose visibility can be changed by a parent layer. In this case, when a parent layer is turned off, then child layers are also turned off. The persistent visibility setting determines what happens when the parent is turned on again.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the setting applies only to the viewport with the specified id. If Guid.Empty, then the setting applies to all viewports with per viewport layer settings."},{"name":"persistentVisibility","summary":"If true, this layer\'s visibility in the specified viewport is controlled by a parent object and the parent is turned on (after being off), then this layer will also be turned on in the specified viewport. If false, this layer\'s visibility in the specified viewport is controlled by a parent object and the parent layer is turned on (after being off), then this layer will continue to be off in the specified viewport."}]},{"signature":"void SetPerViewportPlotColor(Guid viewportId, Color color)","summary":"Sets the plot color for this layer.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the setting applies only to the viewport with the specified id."},{"name":"color","summary":"The plot color."}]},{"signature":"void SetPerViewportPlotWeight(Guid viewportId, double plotWeight)","summary":"Sets the plot weight, in millimeters, for this layer.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the setting applies only to the viewport with the specified id."},{"name":"plotWeight","summary":"The plot weight in millimeters. A weight of  0.0 indicates the \\"default\\" pen weight should be used. A weight of -1.0 indicates the layer should not be printed."}]},{"signature":"void SetPerViewportVisible(Guid viewportId, bool visible)","summary":"Controls layer visibility in specific viewports.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the setting applies only to the viewport with the specified id. If Guid.Empty, then the setting applies to all viewports with per viewport layer settings."},{"name":"visible","summary":"True to make layer visible, False to make layer invisible."}]},{"signature":"bool SetUserString(string key, string value)","summary":"Attach a user string (key,value combination) to this geometry.","since":"5.0","parameters":[{"name":"key","summary":"id used to retrieve this string."},{"name":"value","summary":"string associated with key."}],"returns":"True on success."},{"signature":"string ToString()"},{"signature":"void UnsetPersistentLocking()","summary":"Remove any explicitly persistent locking settings from this layer","since":"5.5"},{"signature":"void UnsetPersistentVisibility()","summary":"Remove any explicit persistent visibility setting from this layer","since":"5.5"},{"signature":"void UnsetPerViewportPersistentVisibility(Guid viewportId)","summary":"Remove any per viewport persistent visibility setting so the layer\'s overall setting will be used for all viewports.","since":"6.0","parameters":[{"name":"viewportId","summary":"If not Guid.Empty, then the setting for this viewport will be deleted. If Guid.Empty, the all per viewport visibility settings will be removed."}]}]},{"namespace":"Rhino.DocObjects","name":"LeaderObject","dataType":"class","summary":"Rhino Object that represents leader geometry and attributes","baseclass":"Rhino.DocObjects.AnnotationObjectBase","properties":[{"signature":"Leader LeaderGeometry","summary":"Get the leader geometry for this object.","since":"6.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"LightObject","dataType":"class","baseclass":"Rhino.DocObjects.RhinoObject","properties":[{"signature":"ModelComponentType ComponentType","since":"6.0","property":["get"]},{"signature":"Light LightGeometry","since":"5.0","property":["get"]}],"methods":[{"signature":"Light DuplicateLightGeometry()","since":"5.0"}]},{"namespace":"Rhino.DocObjects","name":"LinearDimensionObject","dataType":"class","summary":"Rhino Object that represents a linear dimension geometry and attributes","baseclass":"Rhino.DocObjects.DimensionObject","properties":[{"signature":"LinearDimension LinearDimensionGeometry","summary":"Get the dimension geometry for this object.","since":"6.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"Linetype","dataType":"class","baseclass":"Rhino.DocObjects.ModelComponent","constructors":[{"signature":"Linetype()","since":"5.0"}],"properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.LinePattern.","since":"6.0","property":["get"]},{"signature":"bool IsDeleted","summary":"Gets a value indicating whether this linetype has been deleted and is currently in the Undo buffer.","since":"5.0","property":["get"]},{"signature":"bool IsModified","summary":"True if this linetype has been modified by LinetypeTable.ModifyLinetype() and the modifications can be undone.","since":"5.0","property":["get"]},{"signature":"bool IsReference","summary":"Gets a value indicting whether this linetype is a referenced linetype. Referenced linetypes are part of referenced documents.","since":"5.0","property":["get"]},{"signature":"int LinetypeIndex","summary":"The index of this linetype.","since":"5.0","property":["get","set"]},{"signature":"string Name","summary":"The name of this linetype.","since":"5.0","property":["get","set"]},{"signature":"double PatternLength","summary":"Total length of one repeat of the pattern.","since":"5.0","property":["get"]},{"signature":"int SegmentCount","summary":"Number of segments in the pattern.","since":"5.0","property":["get"]}],"methods":[{"signature":"static Linetype[] ReadFromFile(string path)","summary":"Reads linetypes from either a Rhino .3dm file or an AutoCAD .lin file.","since":"6.6","parameters":[{"name":"path","summary":"The path to the file to read."}],"returns":"An array of linetypes if successful, otherwise an empty array."},{"signature":"int AppendSegment(double length, bool isSolid)","summary":"Adds a segment to the pattern.","since":"5.0","parameters":[{"name":"length","summary":"The length of the segment to be added."},{"name":"isSolid","summary":"If true, the length is interpreted as a line. If false, then the length is interpreted as a space."}],"returns":"Index of the added segment."},{"signature":"bool CommitChanges()","since":"5.0"},{"signature":"void Default()","summary":"Set linetype to default settings.","since":"5.0"},{"signature":"void GetSegment(int index, out double length, out bool isSolid)","summary":"Gets the segment information at a index.","since":"5.0","parameters":[{"name":"index","summary":"Zero based index of the segment."},{"name":"length","summary":"The length of the segment in millimeters."},{"name":"isSolid","summary":"If the length is interpreted as a line, True is assigned during the call to this out parameter.  \\nIf the length is interpreted as a space, then False is assigned during the call to this out parameter."}]},{"signature":"bool RemoveSegment(int index)","summary":"Removes a segment in the linetype.","since":"5.0","parameters":[{"name":"index","summary":"Zero based index of the segment to remove."}],"returns":"True if the segment index was removed."},{"signature":"bool SetSegment(int index, double length, bool isSolid)","summary":"Sets the length and type of the segment at index.","since":"5.0","parameters":[{"name":"index","summary":"Zero based index of the segment."},{"name":"length","summary":"The length of the segment to be added in millimeters."},{"name":"isSolid","summary":"If true, the length is interpreted as a line. If false, then the length is interpreted as a space."}],"returns":"True if the operation was successful; otherwise false."},{"signature":"bool SetSegments(IEnumerable<double> segments)","summary":"Set all segments.","since":"6.8","parameters":[{"name":"segments","summary":"An array of segments lengths. Lengths >= 0 are interpreted as a line. Lengths < 0 are interpreted as a space."}],"returns":"True if the segments were replaced"}]},{"namespace":"Rhino.DocObjects","name":"Material","dataType":"class","baseclass":"Rhino.DocObjects.ModelComponent","constructors":[{"signature":"Material()","since":"5.0"},{"signature":"Material(Material other)","since":"6.0"}],"properties":[{"signature":"static Material DefaultMaterial","since":"5.0","property":["get"]},{"signature":"static double MaxShine","since":"5.0","property":["get"]},{"signature":"bool AlphaTransparency","since":"6.0","property":["get","set"]},{"signature":"Color AmbientColor","since":"5.0","property":["get","set"]},{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.RenderMaterial.","since":"6.0","property":["get"]},{"signature":"Color DiffuseColor","since":"5.0","property":["get","set"]},{"signature":"bool DisableLighting","since":"6.0","property":["get","set"]},{"signature":"Color EmissionColor","since":"5.0","property":["get","set"]},{"signature":"double FresnelIndexOfRefraction","summary":"Gets or sets the Fresnel index of refraction of the material, default is 1.56","since":"6.0","property":["get","set"]},{"signature":"bool FresnelReflections","summary":"Gets or sets if Fresnel reflections are used.","since":"6.0","property":["get","set"]},{"signature":"double IndexOfRefraction","summary":"Gets or sets the index of refraction of the material, generally >= 1.0 (speed of light in vacuum)/(speed of light in material)","since":"5.1","property":["get","set"]},{"signature":"bool IsDefaultMaterial","summary":"By default Rhino layers and objects are assigned the default rendering material.","since":"5.0","property":["get"]},{"signature":"bool IsDeleted","summary":"Deleted materials are kept in the runtime material table so that undo will work with materials.  Call IsDeleted to determine to determine if a material is deleted.","since":"5.0","property":["get"]},{"signature":"bool IsDocumentControlled","summary":"If True this object may not be modified. Any properties or functions that attempt to modify this object when it is set to \\"IsReadOnly\\" will throw a NotSupportedException.","since":"5.6","property":["get"]},{"signature":"bool IsPhysicallyBased","since":"7.0","property":["get"]},{"signature":"bool IsReference","summary":"Rhino allows multiple files to be viewed simultaneously. Materials in the document are \\"normal\\" or \\"reference\\". Reference materials are not saved.","since":"5.0","property":["get"]},{"signature":"int MaterialIndex","since":"5.6","property":["get"]},{"signature":"string Name","since":"5.0","property":["get","set"]},{"signature":"PhysicallyBasedMaterial PhysicallyBased","since":"7.0","property":["get"]},{"signature":"Color PreviewColor","summary":"Very simple preview color function for GUIs.","since":"6.6","property":["get"]},{"signature":"Color ReflectionColor","since":"5.0","property":["get","set"]},{"signature":"double ReflectionGlossiness","summary":"Gets or sets the reflection glossiness.","since":"6.0","property":["get","set"]},{"signature":"double Reflectivity","summary":"Gets or sets how reflective a material is, 0f is no reflection 1f is 100% reflective.","since":"5.7","property":["get","set"]},{"signature":"double RefractionGlossiness","summary":"Gets or sets the refraction glossiness.","since":"6.0","property":["get","set"]},{"signature":"RenderMaterial RenderMaterial","summary":"Get the RenderMaterial related to this Material.  Will create a new RenderMaterial if none exists. This can happen for older documents.","since":"6.0","property":["get"]},{"signature":"Guid RenderMaterialInstanceId","since":"6.0","property":["get","set"]},{"signature":"Guid RenderPlugInId","summary":"The Id of the RenderPlugIn that is associated with this material.","since":"5.0","property":["get","set"]},{"signature":"double Shine","summary":"Gets or sets the shine factor of the material.","since":"5.0","property":["get","set"]},{"signature":"Color SpecularColor","since":"5.0","property":["get","set"]},{"signature":"double Transparency","summary":"Gets or sets the transparency of the material (0.0 = opaque to 1.0 = transparent)","since":"5.0","property":["get","set"]},{"signature":"Color TransparentColor","since":"5.0","property":["get","set"]},{"signature":"int UseCount","summary":"Number of objects and layers that use this material.","since":"5.0","property":["get"]},{"signature":"int UserStringCount","since":"5.0","property":["get"]}],"methods":[{"signature":"void ClearMaterialChannels()","summary":"Removes all material channels","since":"6.26"},{"signature":"bool CommitChanges()","since":"5.0"},{"signature":"void CopyFrom(Material other)","since":"6.0"},{"signature":"void Default()","summary":"Set material to default settings.","since":"5.0"},{"signature":"Texture GetBitmapTexture()","since":"5.0","deprecated":"7.0"},{"signature":"Texture GetBumpTexture()","summary":"Gets the bump texture of this material.","since":"5.0","deprecated":"7.0","returns":"A texture; or None if no bump texture has been added to this material."},{"signature":"Texture GetEnvironmentTexture()","since":"5.0","deprecated":"7.0"},{"signature":"Texture GetTexture(TextureType which)","summary":"Get the texture that corresponds with the specified texture type for this material.","since":"7.0"},{"signature":"Texture[] GetTextures()","summary":"Get array of textures that this material uses","since":"5.7"},{"signature":"Texture GetTransparencyTexture()","since":"5.0","deprecated":"7.0"},{"signature":"string GetUserString(string key)","summary":"Gets a user string.","since":"5.0","parameters":[{"name":"key","summary":"id used to retrieve the string."}],"returns":"string associated with the key if successful. None if no key was found."},{"signature":"System.Collections.Specialized.NameValueCollection GetUserStrings()","summary":"Gets an independent copy of the collection of (user text key, user text value) pairs attached to this object.","since":"5.0","returns":"A collection of key strings and values strings. This"},{"signature":"Guid MaterialChannelIdFromIndex(int material_channel_index)","summary":"Finds id of the material channel at given index.","since":"6.26","parameters":[{"name":"material_channel_index","summary":"Index"}],"returns":"Id of the material channel"},{"signature":"int MaterialChannelIndexFromId(Guid material_channel_id, bool bAddIdIfNotPresent)","summary":"Finds index of the material channel that refers to a material channel with the given id. Optionally adds channel if one is not found.","since":"6.26","parameters":[{"name":"material_channel_id","summary":"Id"},{"name":"bAddIdIfNotPresent","summary":"Controls whether to add channel if none exist"}],"returns":"Index of the material channel"},{"signature":"bool SetBitmapTexture(string filename)","since":"5.0","deprecated":"7.0"},{"signature":"bool SetBitmapTexture(Texture texture)","since":"5.0","deprecated":"7.0"},{"signature":"bool SetBumpTexture(string filename)","since":"5.0","deprecated":"7.0"},{"signature":"bool SetBumpTexture(Texture texture)","since":"5.0","deprecated":"7.0"},{"signature":"bool SetEnvironmentTexture(string filename)","since":"5.0","deprecated":"7.0"},{"signature":"bool SetEnvironmentTexture(Texture texture)","since":"5.0","deprecated":"7.0"},{"signature":"bool SetTexture(Texture texture, TextureType which)","summary":"Set the texture that corresponds with the specified texture type for this material.","since":"7.0","parameters":[{"name":"texture","summary":"An instance of Rhino.DocObjects.Texture"},{"name":"which","summary":"Use Rhino.DocObjects.TextureType"}]},{"signature":"bool SetTransparencyTexture(string filename)","since":"5.0","deprecated":"7.0"},{"signature":"bool SetTransparencyTexture(Texture texture)","since":"5.0","deprecated":"7.0"},{"signature":"bool SetUserString(string key, string value)","summary":"Attach a user string (key,value combination) to this geometry.","since":"5.0","parameters":[{"name":"key","summary":"id used to retrieve this string."},{"name":"value","summary":"string associated with key."}],"returns":"True on success."},{"signature":"void ToPhysicallyBased()","since":"7.0"}]},{"namespace":"Rhino.DocObjects","name":"MaterialRef","dataType":"class","interfaces":["IDisposable"],"properties":[{"signature":"Guid BackFaceMaterialId","summary":"The Id of the Material used to render the back of an object.","since":"5.10","property":["get"]},{"signature":"int BackFaceMaterialIndex","summary":"The index of the material used to render the back of an object","since":"5.10","property":["get"]},{"signature":"Guid FrontFaceMaterialId","summary":"The Id of the Material used to render the front of an object.","since":"5.10","property":["get"]},{"signature":"int FrontFaceMaterialIndex","summary":"The index of the material used to render the front of an object","since":"5.10","property":["get"]},{"signature":"ObjectMaterialSource MaterialSource","summary":"Determines if the simple material should come from the object or from it\'s layer.","since":"5.10","property":["get"]},{"signature":"Guid PlugInId","summary":"Identifies a rendering plug-in","since":"5.10","property":["get","set"]}],"methods":[{"signature":"void Dispose()","since":"5.10"}]},{"namespace":"Rhino.DocObjects","name":"MaterialRefCreateParams","dataType":"class","summary":"Options passed to MaterialRefs.Create","properties":[{"signature":"Guid BackFaceMaterialId","summary":"The Id of the Material used to render the back of an object.","since":"5.10","property":["get","set"]},{"signature":"int BackFaceMaterialIndex","summary":"The index of the material used to render the back of an object","since":"5.10","property":["get","set"]},{"signature":"Guid FrontFaceMaterialId","summary":"The Id of the Material used to render the front of an object.","since":"5.10","property":["get","set"]},{"signature":"int FrontFaceMaterialIndex","summary":"The index of the material used to render the front of an object","since":"5.10","property":["get","set"]},{"signature":"ObjectMaterialSource MaterialSource","summary":"Determines if the simple material should come from the object or from it\'s layer.","since":"5.10","property":["get","set"]},{"signature":"Guid PlugInId","summary":"Identifies a rendering plug-in","since":"5.10","property":["get","set"]}]},{"namespace":"Rhino.DocObjects","name":"MaterialRefs","dataType":"class","summary":"If you are developing a high quality plug-in renderer, and a user is assigning a custom render material to this object, then add rendering material information to the MaterialRefs dictionary.  Note to developers: As soon as the MaterialRefs dictionary contains items rendering material queries slow down.  Do not populate the MaterialRefs dictionary when setting the MaterialIndex will take care of your needs.","interfaces":["IDictionary<Guid, MaterialRef>"],"properties":[{"signature":"int Count","summary":"Gets the number of elements contained in this dictionary","since":"5.10","property":["get"]},{"signature":"bool IsReadOnly","summary":"IDictionary required property, always returns False for this dictionary.","since":"5.10","property":["get"]},{"signature":"ICollection<Guid> Keys","summary":"Gets an ICollection containing the plug-in Id\'s in this dictionary.","since":"5.10","property":["get"]},{"signature":"ICollection<MaterialRef> Values","summary":"Gets an ICollection containing the MaterialRef objects in this dictionary.","since":"5.10","property":["get"]}],"methods":[{"signature":"void Add(Guid key, MaterialRef value)","summary":"Add or replace an element with the provided key and value to this dictionary.","since":"5.10","parameters":[{"name":"key","summary":"The plug-in associated with this MaterialRef"},{"name":"value","summary":"MaterialRef to add to this dictionary"}]},{"signature":"void Add(KeyValuePair<Guid, MaterialRef> item)","summary":"Adds an item to this dictionary.","parameters":[{"name":"item","summary":"The object to add to this dictionary"}]},{"signature":"void Clear()","summary":"Removes all items from this dictionary.","since":"5.10"},{"signature":"bool Contains(KeyValuePair<Guid, MaterialRef> item)","summary":"Determines whether this dictionary contains a specific value.","parameters":[{"name":"item","summary":"The object to locate in this dictionary."}],"returns":"True if item is found in this dictionary; otherwise, false."},{"signature":"bool ContainsKey(Guid key)","summary":"Determines whether this dictionary contains an MaterialRef with the specified plug-in id.","since":"5.10","parameters":[{"name":"key","summary":"The plug-in Id used to locate a MaterialRef in this dictionary."}],"returns":"True if this dictionary contains an element with the specified plug-in Id; otherwise, false."},{"signature":"void CopyTo(KeyValuePair<Guid, MaterialRef>[] array, int arrayIndex)","summary":"Copies the elements of this dictionary to an System.Array, starting at a particular System.Array index.","parameters":[{"name":"array","summary":"The one-dimensional System.Array that is the destination of the elements copied from this dictionary. The System.Array must have zero-based indexing."},{"name":"arrayIndex","summary":"The zero-based index in array at which copying begins."}]},{"signature":"MaterialRef Create(MaterialRefCreateParams createParams)","summary":"Call this method to create a MaterialRef which can be used when calling one of the Add methods.","since":"5.10","parameters":[{"name":"createParams","summary":"Values used to initialize the MaterialRef"}],"returns":"A temporary MaterialRef object, the caller is responsible for disposing of this object."},{"signature":"IEnumerator<KeyValuePair<Guid, MaterialRef>> GetEnumerator()","summary":"Returns an enumerator that iterates through this dictionary.","since":"5.10","returns":"A IEnumerator that can be used to iterate this dictionary."},{"signature":"bool Remove(Guid key)","summary":"Removes the MaterialRef with the specified plug-in Id from this dictionary.","since":"5.10","parameters":[{"name":"key","summary":"The plug-in Id for the MaterialRef to remove."}],"returns":"True if the MaterialRef is successfully removed; otherwise, false. This method also returns False if key was not found in the original dictionary."},{"signature":"bool Remove(KeyValuePair<Guid, MaterialRef> item)","summary":"Removes the element with the specified plug-in id from the this dictionary.","parameters":[{"name":"item","summary":"The object to remove from this dictionary"}]},{"signature":"bool TryGetValue(Guid key, out MaterialRef value)","summary":"Gets the value associated with the specified key.","since":"5.10","parameters":[{"name":"key","summary":"The plug-in Id whose MaterialRef to get."},{"name":"value","summary":"When this method returns, the MaterialRef associated with the specified key, if the key is found; otherwise, null. This parameter is passed uninitialized."}],"returns":"True if this dictionary contains a MaterialRef with the specified key; otherwise, false."}]},{"namespace":"Rhino.DocObjects","name":"MeshObject","dataType":"class","baseclass":"Rhino.DocObjects.RhinoObject","properties":[{"signature":"bool IsCustomObject","since":"6.0","property":["get","set"]},{"signature":"Mesh MeshGeometry","since":"5.0","property":["get"]}],"methods":[{"signature":"static bool CheckMeshes(IEnumerable<MeshObject> meshObjects, TextLog textLog, ref MeshCheckParameters parameters)","summary":"Examines mesh objects and logs a description of what it finds right or wrong. The various properties the function checks for are described in MeshCheckParameters.","since":"7.0","parameters":[{"name":"meshObjects","summary":"A collection of mesh objects."},{"name":"textLog","summary":"The text log."},{"name":"parameters","summary":"The mesh checking parameter and results."}],"returns":"True if successful, False otherwise."},{"signature":"Mesh DuplicateMeshGeometry()","since":"5.0"}]},{"namespace":"Rhino.DocObjects","name":"ModelComponent","dataType":"class","summary":"Base class for all components in a model (document) and manages the index, id and other information common to this type of objects.  \\nThis class parallels the C++ ON_ModelComponent.","baseclass":"Rhino.Runtime.CommonObject","properties":[{"signature":"ComponentStatus ComponentStatus","summary":"Gets or sets the component status of the model component.","since":"6.0","property":["get","set"]},{"signature":"ModelComponentType ComponentType","summary":"Gets the ModelComponentTypefor this object. Useful in switch statements.","since":"6.0","property":["get"]},{"signature":"string DeletedName","summary":"Gets the name of a component that is deleted.","since":"6.2","property":["get"]},{"signature":"bool HasId","summary":"Returns a value indicating whether the component has an ID.","since":"6.0","property":["get"]},{"signature":"bool HasIndex","summary":"Returns a value indicating whether the component has an Index.","since":"6.0","property":["get"]},{"signature":"bool HasName","summary":"Returns a value indicating whether the component has a Name.","since":"6.0","property":["get"]},{"signature":"Guid Id","summary":"Gets or sets the ID of the current instance.","since":"6.0","property":["get","set"]},{"signature":"bool IdIsLocked","summary":"Returns a value indicating whether the component ID is already locked.","since":"6.0","property":["get"]},{"signature":"int Index","summary":"Gets or sets the model component index attribute.","since":"6.0","property":["get","set"]},{"signature":"bool IndexIsLocked","summary":"Returns a value indicating whether the component Index is already locked.","since":"6.0","property":["get"]},{"signature":"uint InstanceDefinitionModelSerialNumber","summary":"When a component is in a model as part of the information required for a linked instance definition, this value identifies the linked instance definition reference model.","since":"6.12","property":["get"]},{"signature":"bool IsComponentStatusLocked","summary":"The component status itself can be locked. This returns an indication.","since":"6.0","property":["get"]},{"signature":"bool IsSystemComponent","summary":"True if this model component is a system constant.  \\nAn incomplete list of system constant model components is below:  \\nON_ModelComponent::Unset ON_InstanceDefinition::Empty ON_Linetype::UnsetON_Linetype::ContinuousON_Linetype::ByLayerON_Linetype::ByParent ON_Layer::UnsetON_Layer::Default ON_TextStyle::UnsetON_TextStyle::DefaultON_TextStyle::ByLayerON_TextStyle::ByParent ON_DimStyle::UnsetON_DimStyle::DefaultON_DimStyle::DefaultInchDecimalON_DimStyle::DefaultInchFractionalON_DimStyle::DefaultFootInchArchitectureON_DimStyle::DefaultMillimeterSmallON_DimStyle::DefaultMillimeterLargeON_DimStyle::DefaultMillimeterArchitecture","since":"6.0","property":["get"]},{"signature":"uint ModelSerialNumber","summary":"A value identifying the model that manages this component.","since":"6.12","property":["get"]},{"signature":"string Name","summary":"Gets or sets the name","since":"6.0","property":["get","set"]},{"signature":"bool NameIsLocked","summary":"Returns a value indicating whether the component Name is already locked.","since":"6.0","property":["get"]},{"signature":"uint ReferenceModelSerialNumber","summary":"When a component is in a model for reference, this value identifies the reference model.","since":"6.12","property":["get"]}],"methods":[{"signature":"static bool IsValidComponentName(string name)","summary":"Tests for a valid model component name.","since":"6.15","parameters":[{"name":"name","summary":"The string to validate."}],"returns":"True if the string is a valid model component name, False otherwise."},{"signature":"static bool ModelComponentTypeIgnoresCase(ModelComponentType type)","summary":"Informs the developer if a particular model component type will require case-ignoring searching within a document. This is currently True with groups; False otherwise.","since":"6.0","parameters":[{"name":"type","summary":"True if the component ignores case."}]},{"signature":"static bool ModelComponentTypeIncludesParent(ModelComponentType type)","summary":"Informs the developer if a particular model component type will include the hash of the parent.","since":"6.0","parameters":[{"name":"type","summary":"True if the component includes parent hash."}]},{"signature":"static bool ModelComponentTypeRequiresUniqueName(ModelComponentType type)","summary":"Informs the developer if a particular model component type will require uniqueness within a document. This is currently True with render materials and model geometry; False otherwise.","since":"6.0","parameters":[{"name":"type","summary":"The type to check."}],"returns":"True with render materials and model geometry; False otherwise."},{"signature":"void ClearId()","summary":"Resets the HasId property of the model component to false, if possible.","since":"6.0"},{"signature":"void ClearIndex()","summary":"Resets the HasIndex property of the model component to false, if possible.","since":"6.0"},{"signature":"void ClearName()","summary":"Resets the HasName property of the model component to false, if possible.","since":"6.0"},{"signature":"uint DataCRC(uint currentRemainder)","summary":"Increments the Cyclic Redundancy Check value by this instance.","since":"6.0","parameters":[{"name":"currentRemainder","summary":"The current remainder value."}],"returns":"The updated remainder value."},{"signature":"void LockId()","summary":"Locks the component Id property.","since":"6.0"},{"signature":"void LockIndex()","summary":"Locks the component Index property.","since":"6.0"},{"signature":"void LockName()","summary":"Locks the component Name property.","since":"6.0"},{"signature":"string ToString()","summary":"Returns the name of the model component type, and then its name and index."}]},{"namespace":"Rhino.DocObjects","name":"ModelComponentType","dataType":"enum","summary":"The ON_ModelComponent::Type enum has a value for each explicit component type and two special values, Unset and Mixed. Use an ON_ModelComponentTypeIterator instance to iterate over the ON_ModelComponent::Type values.","values":[{"signature":"Unset = 0","summary":"No value set."},{"signature":"Image = 1","summary":"Embedded image (bitmap) components."},{"signature":"TextureMapping = 2","summary":"Texture mapping."},{"signature":"RenderMaterial = 3","summary":"Render material."},{"signature":"LinePattern = 4","summary":"Line pattern (linetype)."},{"signature":"Layer = 5","summary":"Layer."},{"signature":"Group = 6","summary":"Group."},{"signature":"TextStyle = 7","summary":"Text style."},{"signature":"DimStyle = 8","summary":"AnnotationDimension style."},{"signature":"RenderLight = 9","summary":"Render light."},{"signature":"HatchPattern = 10","summary":"Hatch pattern."},{"signature":"InstanceDefinition = 11","summary":"Instance definition."},{"signature":"ModelGeometry = 12","summary":"Model objects (points, curves, surfaces, ..., annotation, page details, ...), including objects referenced by instance definitions."},{"signature":"HistoryRecord = 13","summary":"History record."},{"signature":"Mixed = 0xFE","summary":"Multiple component types. Used when a component type filter must include all explicit component types."}]},{"namespace":"Rhino.DocObjects","name":"MorphControlObject","dataType":"class","summary":"Represents a Rhino.Geometry.MorphControlin a document.","baseclass":"Rhino.DocObjects.RhinoObject"},{"namespace":"Rhino.DocObjects","name":"ObjectAttributes","dataType":"class","summary":"Attributes (color, material, layer,...) associated with a rhino object","baseclass":"Rhino.Runtime.CommonObject","constructors":[{"signature":"ObjectAttributes()","since":"5.0"}],"properties":[{"signature":"bool CastsShadows","summary":"Gets or sets an object\'s casts shadows property, or whether or not an object casts shadows on other objects and a ground plane.","since":"6.0","property":["get","set"]},{"signature":"ObjectColorSource ColorSource","summary":"The color used to display an object is specified in one of three ways. If ColorSource is ON::color_from_layer, then the object\'s layer ON_Layer::Color() is used. If ColorSource is ON::color_from_object, then value of m_color is used. If ColorSource is ON::color_from_material, then the diffuse color of the object\'s render material is used.  See ON_3dmObjectAttributes::MaterialSource() to determine where to get the definition of the object\'s render material.","since":"5.0","property":["get","set"]},{"signature":"Decals Decals","summary":"Gets all object decals associated with this object.","since":"5.10","property":["get"]},{"signature":"int DisplayOrder","summary":"Display order used to force objects to be drawn on top or behind each other. Larger numbers draw on top of smaller numbers.  \\n0  = draw object in standard depth buffered order  \\n<0 = draw object behind \\"normal\\" draw order objects  \\n>0 = draw object on top of \\"normal\\" draw order objects","since":"5.10","property":["get","set"]},{"signature":"int GroupCount","summary":"number of groups object belongs to.","since":"5.0","property":["get"]},{"signature":"bool HasMapping","summary":"A mapping from any plug-in source is associated with these attributes Need to do this here to respond correctly to ModifyObjectAttributes event","since":"5.10","property":["get"]},{"signature":"bool IsDocumentControlled","since":"5.0","property":["get"]},{"signature":"bool IsInstanceDefinitionObject","summary":"Use this query to determine if an object is part of an instance definition.","since":"5.0","property":["get"]},{"signature":"int LayerIndex","summary":"Gets or sets an associated layer index.  \\nLayer definitions in an OpenNURBS model are stored in a layer table. The layer table is conceptually an array of ON_Layer classes.  Every OpenNURBS object in a model is on some layer.  The object\'s layer is specified by zero based indices into the ON_Layer array.","since":"5.0","property":["get","set"]},{"signature":"int LinetypeIndex","summary":"Gets or sets the linetype index.  \\nLinetype definitions in an OpenNURBS model are stored in a linetype table. The linetype table is conceptually an array of ON_Linetype classes. Every OpenNURBS object in a model references some linetype.  The object\'s linetype is specified by zero based indices into the ON_Linetype array.  \\nIndex 0 is reserved for continuous linetype (no pattern).","since":"5.0","property":["get","set"]},{"signature":"ObjectLinetypeSource LinetypeSource","summary":"The Linetype used to display an object is specified in one of two ways. If LinetypeSource is ON::linetype_from_layer, then the object\'s layer ON_Layer::Linetype() is used. If LinetypeSource is ON::linetype_from_object, then value of m_linetype is used.","since":"5.0","property":["get","set"]},{"signature":"int MaterialIndex","summary":"Gets or sets the material index.  \\nIf you want something simple and fast, set the index of the rendering material.","since":"5.0","property":["get","set"]},{"signature":"MaterialRefs MaterialRefs","summary":"If you are developing a high quality plug-in renderer, and a user is assigning a custom render material to this object, then add rendering material information to the MaterialRefs dictionary.  Note to developers: As soon as the MaterialRefs dictionary contains items rendering material queries slow down.  Do not populate the MaterialRefs dictionary when setting the MaterialIndex will take care of your needs.","since":"5.10","property":["get"]},{"signature":"ObjectMaterialSource MaterialSource","summary":"Determines if the simple material should come from the object or from it\'s layer. High quality rendering plug-ins should use m_rendering_attributes.","since":"5.0","property":["get","set"]},{"signature":"ObjectMode Mode","summary":"An object must be in one of three modes: normal, locked or hidden. If an object is in normal mode, then the object\'s layer controls visibility and selectability. If an object is locked, then the object\'s layer controls visibility by the object cannot be selected. If the object is hidden, it is not visible and it cannot be selected.","since":"5.0","property":["get","set"]},{"signature":"string Name","summary":"Gets or sets an object optional text name.  \\nMore than one object in a model can have the same name and some objects may have no name.","since":"5.0","property":["get","set"]},{"signature":"Color ObjectColor","summary":"If ON::color_from_object == ColorSource, then color is the object\'s display color.","since":"5.0","property":["get","set"]},{"signature":"ObjectDecoration ObjectDecoration","summary":"Used to indicate an object has a decoration (like an arrowhead on a curve)","since":"5.0","property":["get","set"]},{"signature":"Guid ObjectId","summary":"Every object has a Guid (globally unique identifier, also known as UUID, or universally unique identifier). The default value is Guid.Empty.  \\nWhen an object is added to a model, the value is checked.  If the value is Guid.Empty, a new Guid is created. If the value is not None but it is already used by another object in the model, a new Guid is created. If the value is not Guid.Empty and it is not used by another object in the model, then that value persists. When an object is updated, by a move for example, the value of ObjectId persists.  \\nThis value is the same as the one returned by object.Id.","since":"5.0","property":["get","set"]},{"signature":"Color PlotColor","summary":"If plot_color_from_object == PlotColorSource, then PlotColor is the object\'s plotting color.","since":"5.0","property":["get","set"]},{"signature":"ObjectPlotColorSource PlotColorSource","summary":"The color used to plot an object on paper is specified in one of three ways. If PlotColorSource is ON::plot_color_from_layer, then the object\'s layer ON_Layer::PlotColor() is used. If PlotColorSource is ON::plot_color_from_object, then value of PlotColor() is used.","since":"5.0","property":["get","set"]},{"signature":"double PlotWeight","summary":"Plot weight in millimeters. =0.0 means use the default width <0.0 means don\'t plot (visible for screen display, but does not show on plot)","since":"5.0","property":["get","set"]},{"signature":"ObjectPlotWeightSource PlotWeightSource","since":"5.0","property":["get","set"]},{"signature":"bool ReceivesShadows","summary":"Gets or sets an object\'s receives shadows property, or whether or not an object receives shadows from other objects.","since":"6.0","property":["get","set"]},{"signature":"ActiveSpace Space","summary":"Starting with V4, objects can be in either model space or page space. If an object is in page space, then ViewportId is not nil and identifies the page it is on.","since":"5.0","property":["get","set"]},{"signature":"string Url","summary":"Objects may have an URL. There are no restrictions on what value this URL may have. As an example, if the object came from a commercial part library, the URL might point to the definition of that part.","since":"6.8","property":["get","set"]},{"signature":"int UserStringCount","since":"5.0","property":["get"]},{"signature":"Guid ViewportId","summary":"If ViewportId is nil, the object is active in all viewports. If ViewportId is not nil, then this object is only active in a specific view. This field is primarily used to assign page space objects to a specific page, but it can also be used to restrict model space to a specific view.","since":"5.0","property":["get","set"]},{"signature":"bool Visible","summary":"Gets or sets an object\'s visibility.","since":"5.0","property":["get","set"]},{"signature":"int WireDensity","summary":"When a surface object is displayed in wireframe, this controls how many isoparametric wires are used. value    number of isoparametric wires -1       boundary wires (off) 0        boundary and knot wires 1        boundary and knot wires and, if there are no interior knots, a single interior wire. N>=2     boundary and knot wires and (N+1) interior wires.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"bool AddHideInDetailOverride(Guid detailId)","summary":"Make this object hidden in a given detail","since":"6.1"},{"signature":"void AddToGroup(int groupIndex)","summary":"Adds object to the group with specified index by appending index to group list.  \\nIf the object is already in group, nothing is changed.","since":"5.0","parameters":[{"name":"groupIndex","summary":"The index that will be added."}]},{"signature":"System.Drawing.Color ComputedPlotColor(RhinoDoc document)","since":"5.6"},{"signature":"System.Drawing.Color ComputedPlotColor(RhinoDoc document, Guid viewportId)","since":"5.6"},{"signature":"double ComputedPlotWeight(RhinoDoc document)","since":"5.6"},{"signature":"double ComputedPlotWeight(RhinoDoc document, Guid viewportId)","since":"5.6"},{"signature":"void DeleteAllUserStrings()","since":"6.0"},{"signature":"bool DeleteUserString(string key)","since":"6.0"},{"signature":"System.Drawing.Color DrawColor(RhinoDoc document)","since":"5.0"},{"signature":"System.Drawing.Color DrawColor(RhinoDoc document, Guid viewportId)","since":"5.0"},{"signature":"ObjectAttributes Duplicate()","summary":"Constructs a copy of this ObjectAttributesinstance.","since":"5.0","returns":"A new instance on success, or None on failure."},{"signature":"Guid GetDisplayModeOverride(Guid viewportId)","summary":"Returns the id of the display mode of an objects. Object display modes are view based. Thus, it is possible to have an object display different in different views.","since":"6.18","parameters":[{"name":"viewportId","summary":"Id of a Rhino Viewport."}],"returns":"A display node id if the object has a display mode override for the viewport; otherwise Guid.Empty is returned."},{"signature":"int[] GetGroupList()","summary":"Returns an array of GroupCount group indices.  If GroupCount is zero, then GetGroupList() returns null.","since":"5.0","returns":"An array of group indices. None might be returned in place of an empty array."},{"signature":"Guid[] GetHideInDetailOverrides()","summary":"Get list of details that this object is supposed to be hidden in","since":"6.1"},{"signature":"string GetUserString(string key)","summary":"Gets a user string.","since":"5.0","parameters":[{"name":"key","summary":"id used to retrieve the string."}],"returns":"string associated with the key if successful. None if no key was found."},{"signature":"System.Collections.Specialized.NameValueCollection GetUserStrings()","summary":"Gets an independent copy of the collection of (user text key, user text value) pairs attached to this object.","since":"5.0","returns":"A collection of key strings and values strings. This"},{"signature":"bool HasDisplayModeOverride(Guid viewportId)","summary":"Determines if an object has a display mode override for a given viewport.","since":"5.0","parameters":[{"name":"viewportId","summary":"Id of a Rhino Viewport."}],"returns":"True if the object has a display mode override for the viewport; otherwise, false."},{"signature":"bool HasHideInDetailOverrideSet(Guid detailId)","summary":"Is this object supposed to be hidden in a given detail","since":"6.1"},{"signature":"void RemoveDisplayModeOverride()","summary":"By default, objects are drawn using the display mode of the viewport that the object is being drawn in. Setting a specific display mode, instructs Rhino to always use that display mode, regardless of the viewport\'s mode. This function resets an object to use the viewport\'s display mode for all viewports.","since":"5.0"},{"signature":"void RemoveDisplayModeOverride(Guid rhinoViewportId)","summary":"By default, objects are drawn using the display mode of the viewport that the object is being drawn in. Setting a specific display mode, instructs Rhino to always use that display mode, regardless of the viewport\'s mode. This function resets an object to use the viewport\'s display mode.","since":"5.0","parameters":[{"name":"rhinoViewportId","summary":"viewport that display mode overrides should be cleared from."}]},{"signature":"void RemoveFromAllGroups()","summary":"Removes object from all groups.","since":"5.0"},{"signature":"void RemoveFromGroup(int groupIndex)","summary":"removes object from the group with specified index.  \\nIf the object is not in the group, nothing is changed.","since":"5.0","parameters":[{"name":"groupIndex","summary":"The index that will be removed."}]},{"signature":"bool RemoveHideInDetailOverride(Guid detailId)","summary":"Remove hidden in detail flag for a specific detail","since":"6.1"},{"signature":"bool SetDisplayModeOverride(DisplayModeDescription mode)","summary":"By default, objects are drawn using the display mode of the viewport that the object is being drawn in. Setting a specific display mode, instructs Rhino to always use that display mode, regardless of the viewport\'s mode. This version affects the object\'s display mode for all viewports.","since":"5.0","parameters":[{"name":"mode","summary":"The display mode."}],"returns":"True if setting was successful."},{"signature":"bool SetDisplayModeOverride(DisplayModeDescription mode, Guid rhinoViewportId)","summary":"By default, objects are drawn using the display mode of the viewport that the object is being drawn in. Setting a specific display mode, instructs Rhino to always use that display mode, regardless of the viewport\'s mode. This version sets a display mode for a specific viewport.","since":"5.0","parameters":[{"name":"mode","summary":"The display mode."},{"name":"rhinoViewportId","summary":"The Rhino viewport ID."}],"returns":"True on success."},{"signature":"bool SetUserString(string key, string value)","summary":"Attach a user string (key,value combination) to this geometry.","since":"5.0","parameters":[{"name":"key","summary":"id used to retrieve this string."},{"name":"value","summary":"string associated with key. If null, the key will be removed"}],"returns":"True on success."},{"signature":"bool Transform(Transform xform)","summary":"Apply a transformation.","since":"6.0","parameters":[{"name":"xform","summary":"The transformation."}],"returns":"True if successful, False otherwise."}]},{"namespace":"Rhino.DocObjects","name":"ObjectColorSource","dataType":"enum","summary":"Defines enumerated values for the source of display color of single objects.","since":"5.0","values":[{"signature":"ColorFromLayer = 0","summary":"use color assigned to layer."},{"signature":"ColorFromObject = 1","summary":"use color assigned to object."},{"signature":"ColorFromMaterial = 2","summary":"use diffuse render material color."},{"signature":"ColorFromParent = 3","summary":"for objects with parents (like objects in instance references, use parent linetype) if no parent, treat as color_from_layer."}]},{"namespace":"Rhino.DocObjects","name":"ObjectDecoration","dataType":"enum","summary":"Defines bit mask values to represent object decorations.","since":"5.0","values":[{"signature":"None = 0","summary":"There are no object decorations."},{"signature":"StartArrowhead = 0x08","summary":"Arrow head at start."},{"signature":"EndArrowhead = 0x10","summary":"Arrow head at end."},{"signature":"BothArrowhead = 0x18","summary":"Arrow head at start and end."}]},{"namespace":"Rhino.DocObjects","name":"ObjectEnumeratorSettings","dataType":"class","summary":"Settings used for getting an enumerator of objects in a document. See ObjectTable.FindByFilter(ObjectEnumeratorSettings),  ObjectTable.GetObjectsByType{T}(ObjectEnumeratorSettings), and ObjectTable.GetEnumerator(ObjectEnumeratorSettings).","constructors":[{"signature":"ObjectEnumeratorSettings()","summary":"Constructs object enumerator settings that will iterate the document looking for normal object and locked object that are active, or part of current model and saved in file.","since":"5.0"}],"properties":[{"signature":"bool ActiveObjects","summary":"When true, objects that are part of current model and saved in file are returned.","since":"5.0","property":["get","set"]},{"signature":"Type ClassTypeFilter","since":"5.0","property":["get","set"]},{"signature":"bool DeletedObjects","summary":"When true, deleted objects are returned.","since":"5.0","property":["get","set"]},{"signature":"bool HiddenObjects","summary":"When true, hidden objects or objects on hidden layers are returned.","since":"5.0","property":["get","set"]},{"signature":"bool IdefObjects","summary":"When true, objects in instance definitions (not the instance references) are returned.","since":"5.0","property":["get","set"]},{"signature":"bool IncludeGrips","summary":"The default object enumerator settings will not iterate through grip objects. If you want the iterator to include grips, then set this property to true.","since":"5.0","property":["get","set"]},{"signature":"bool IncludeLights","summary":"The default object enumerator settings will not iterate through render light objects. If you want the iterator to include lights, then set this property to true.","since":"5.0","property":["get","set"]},{"signature":"bool IncludePhantoms","summary":"The default object enumerator settings will not iterate through phantom objects. If you want the iterator to include phantom objects, then set this property to true.","since":"5.0","property":["get","set"]},{"signature":"int LayerIndexFilter","summary":"The layer filter property can be used to limit the iteration to objects on a specific layer. The default is to iterate through all layers.","since":"5.0","property":["get","set"]},{"signature":"bool LockedObjects","summary":"When true, locked objects or objects on locked layers are returned.","since":"5.0","property":["get","set"]},{"signature":"string NameFilter","summary":"The name filter property can be used to limit the iteration to objects with a specific name.","since":"5.0","property":["get","set"]},{"signature":"bool NormalObjects","summary":"When true, normal objects (e.g. not locked and not hidden) are returned.","since":"5.0","property":["get","set"]},{"signature":"ObjectType ObjectTypeFilter","summary":"The object type filter property can be used to limit the iteration to specific types of geometry. The default is to iterate all objects types.","since":"5.0","property":["get","set"]},{"signature":"bool ReferenceObjects","summary":"When true, objects that are for reference and not saved in file are returned.","since":"5.0","property":["get","set"]},{"signature":"bool SelectedObjectsFilter","summary":"The default object enumerator settings ignore the selected state of objects. If you want the iterator to limit itself to selected objects, then set this property to true.","since":"5.0","property":["get","set"]},{"signature":"RhinoViewport ViewportFilter","summary":"The viewport filter property can be used to limit the iteration to objects that are active in a specific viewport.","since":"5.6","property":["get","set"]},{"signature":"bool VisibleFilter","summary":"The default object enumerator settings ignore the visiblity state of objects. If you want the iterator to limit itself to visible objects, then set this property to true.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.DocObjects","name":"ObjectLinetypeSource","dataType":"enum","summary":"Defines enumerated values for the source of linetype of single objects.","since":"5.0","values":[{"signature":"LinetypeFromLayer = 0","summary":"use line style assigned to layer."},{"signature":"LinetypeFromObject = 1","summary":"use line style assigned to object."},{"signature":"LinetypeFromParent = 3","summary":"for objects with parents (like objects in instance references, use parent linetype) if not parent, treat as linetype_from_layer."}]},{"namespace":"Rhino.DocObjects","name":"ObjectMaterialSource","dataType":"enum","summary":"Defines enumerated values for the source of material of single objects.","since":"5.0","values":[{"signature":"MaterialFromLayer = 0","summary":"use material assigned to layer."},{"signature":"MaterialFromObject = 1","summary":"use material assigned to object."},{"signature":"MaterialFromParent = 3","summary":"for objects with parents, like definition geometry in instance references and faces in polysurfaces, this value indicates the material definition should come from the parent. If the object does not have an obvious \\"parent\\", then treat it the same as material_from_layer."}]},{"namespace":"Rhino.DocObjects","name":"ObjectMode","dataType":"enum","summary":"Defines enumerated values for the display and behavior of single objects.","since":"5.0","values":[{"signature":"Normal = 0","summary":"Object mode comes from layer."},{"signature":"Hidden = 1","summary":"Not visible, object cannot be selected or changed."},{"signature":"Locked = 2","summary":"Visible, object cannot be selected or changed."},{"signature":"InstanceDefinitionObject = 3","summary":"Object is part of an InstanceDefinition. The InstanceDefinition m_object_uuid[] array will contain this object attribute\'s id."}]},{"namespace":"Rhino.DocObjects","name":"ObjectPlotColorSource","dataType":"enum","summary":"Defines enumerated values for the source of plotting/printing color of single objects.","since":"5.0","values":[{"signature":"PlotColorFromLayer = 0","summary":"use plot color assigned to layer."},{"signature":"PlotColorFromObject = 1","summary":"use plot color assigned to object."},{"signature":"PlotColorFromDisplay = 2","summary":"use display color."},{"signature":"PlotColorFromParent = 3","summary":"for objects with parents (like objects in instance references, use parent plot color) if no parent, treat as plot_color_from_layer."}]},{"namespace":"Rhino.DocObjects","name":"ObjectPlotWeightSource","dataType":"enum","summary":"Defines enumerated values for the source of plotting/printing weight of single objects.","since":"5.0","values":[{"signature":"PlotWeightFromLayer = 0","summary":"use plot color assigned to layer."},{"signature":"PlotWeightFromObject = 1","summary":"use plot color assigned to object."},{"signature":"PlotWeightFromParent = 3","summary":"for objects with parents (like objects in instance references, use parent plot color) if no parent, treat as plot_color_from_layer."}]},{"namespace":"Rhino.DocObjects","name":"ObjectType","dataType":"enum","summary":"Defines binary mask values for each object type that can be found in a document.","since":"5.0","values":[{"signature":"None = 0","summary":"Nothing."},{"signature":"Point = 1","summary":"A point."},{"signature":"PointSet = 2","summary":"A point set or cloud."},{"signature":"Curve = 4","summary":"A curve."},{"signature":"Surface = 8","summary":"A surface."},{"signature":"Brep = 0x10","summary":"A brep."},{"signature":"Mesh = 0x20","summary":"A mesh."},{"signature":"Light = 0x100","summary":"A rendering light."},{"signature":"Annotation = 0x200","summary":"An annotation."},{"signature":"InstanceDefinition = 0x800","summary":"A block definition."},{"signature":"InstanceReference = 0x1000","summary":"A block reference."},{"signature":"TextDot = 0x2000","summary":"A text dot."},{"signature":"Grip = 0x4000","summary":"Selection filter value - not a real object type."},{"signature":"Detail = 0x8000","summary":"A detail."},{"signature":"Hatch = 0x10000","summary":"A hatch."},{"signature":"MorphControl = 0x20000","summary":"A morph control."},{"signature":"SubD = 0x40000","summary":"A SubD object."},{"signature":"BrepLoop = 0x80000","summary":"A brep loop."},{"signature":"BrepVertex = 0x100000","summary":"a brep vertex."},{"signature":"PolysrfFilter = 0x200000","summary":"Selection filter value - not a real object type."},{"signature":"EdgeFilter = 0x400000","summary":"Selection filter value - not a real object type."},{"signature":"PolyedgeFilter = 0x800000","summary":"Selection filter value - not a real object type."},{"signature":"MeshVertex = 0x01000000","summary":"A mesh vertex."},{"signature":"MeshEdge = 0x02000000","summary":"A mesh edge."},{"signature":"MeshFace = 0x04000000","summary":"A mesh face."},{"signature":"Cage = 0x08000000","summary":"A cage."},{"signature":"Phantom = 0x10000000","summary":"A phantom object."},{"signature":"ClipPlane = 0x20000000","summary":"A clipping plane."},{"signature":"Extrusion = 0x40000000","summary":"An extrusion."},{"signature":"AnyObject = 0xFFFFFFFF","summary":"All bits set."}]},{"namespace":"Rhino.DocObjects","name":"ObjRef","dataType":"class","summary":"Represents a reference to a Rhino object.","interfaces":["IDisposable"],"constructors":[{"signature":"ObjRef(Guid id)","summary":"Initializes a new object reference from a globally unique identifier ( Guid).","since":"5.0","parameters":[{"name":"id","summary":"The ID."}]},{"signature":"ObjRef(Guid id, ComponentIndex ci)","summary":"Initializes a new object reference from a guid and component index. The component index is used to specify a \\"piece\\" of the geometry","since":"7.0","parameters":[{"name":"id","summary":"The object\'s Id"},{"name":"ci","summary":"a portion of the object"}]},{"signature":"ObjRef(ObjRef other)","summary":"Copy constructor","since":"7.0"},{"signature":"ObjRef(RhinoObject rhinoObject)","summary":"Initializes a new object reference from a Rhino object.","since":"5.0","parameters":[{"name":"rhinoObject","summary":"The Rhino object."}]},{"signature":"ObjRef(RhinoObject rhinoObject, PickContext pickContext)","summary":"Initialized a new object reference from a Rhino object and pick context","since":"5.0"}],"properties":[{"signature":"ComponentIndex GeometryComponentIndex","summary":"Gets the component index of the referenced (sub) geometry. Some objects have sub-objects that are valid pieces of geometry. For example, breps have edges and faces that are valid curves and surfaces. Each sub-object has a component index that is > 0. The parent geometry has a component index = -1.","since":"5.0","property":["get"]},{"signature":"Guid ObjectId","summary":"Returns the id of the referenced Rhino object.","since":"5.0","property":["get"]},{"signature":"uint RuntimeSerialNumber","summary":"If > 0, then this is the value of a Rhino object\'s serial number field. The serial number is used instead of the pointer to prevent crashes in cases when the RhinoObject is deleted but an ObjRef continues to reference the Rhino object. The value of RuntimeSerialNumber is not saved in archives because it generally changes if you save and reload an archive.","since":"5.0","property":["get"]}],"methods":[{"signature":"Brep Brep()","summary":"Gets the brep if this reference geometry is one.","since":"5.0","returns":"A boundary representation; or None on error."},{"signature":"ClippingPlaneSurface ClippingPlaneSurface()","summary":"Gets the clipping plane surface if this reference targeted one.","since":"5.0","returns":"A clipping plane surface, or None if this reference targeted something else."},{"signature":"Curve Curve()","summary":"Gets the curve if this reference targeted one.","since":"5.0","returns":"A curve, or None if this reference targeted something else."},{"signature":"Curve CurveParameter(out double parameter)","summary":"If the reference geometry is a curve or edge with a selection point, then this gets the parameter of the selection point.","since":"5.0","parameters":[{"name":"parameter","summary":"The parameter of the selection point."}],"returns":"If the selection point was on a curve or edge, then the curve/edge is returned, otherwise null."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"BrepEdge Edge()","summary":"Gets the edge if this reference geometry is one.","since":"5.0","returns":"A boundary representation edge; or None on error."},{"signature":"BrepFace Face()","summary":"If the referenced geometry is a brep face, a brep with one face, or a surface, this returns the brep face.","since":"5.0","returns":"A boundary representation face; or None on error."},{"signature":"GeometryBase Geometry()","summary":"Gets the geometry linked to the object targeted by this reference.","since":"5.0","returns":"The geometry."},{"signature":"Hatch Hatch()","summary":"Gets the hatch if the referenced geometry is one.","since":"5.0","returns":"A hatch; or None if the referenced object is not a hatch"},{"signature":"RhinoObject InstanceDefinitionPart()","summary":"If sub-object selection is enabled and a piece of an instance reference is selected, this will return the selected piece.","since":"6.0"},{"signature":"Light Light()","summary":"Gets the light if the referenced geometry is one.","since":"5.0","returns":"A light; or None if the referenced object is not a light, or on error."},{"signature":"Mesh Mesh()","summary":"Gets the mesh if the referenced geometry is one.","since":"5.0","returns":"A mesh; or None if the referenced object is not a mesh, or on error."},{"signature":"RhinoObject Object()","summary":"Returns the referenced Rhino object.","since":"5.0"},{"signature":"Point Point()","summary":"Gets the point if the referenced geometry is one.","since":"5.0","returns":"A point; or None if the referenced object is not a point, or on error."},{"signature":"PointCloud PointCloud()","summary":"Gets the point cloud if the referenced geometry is one.","since":"5.0","returns":"A point cloud; or None if the referenced object is not a point cloud, or on error."},{"signature":"SelectionMethod SelectionMethod()","summary":"Gets the method used to select this object.","since":"5.0","returns":"The method used to select this object."},{"signature":"Point3d SelectionPoint()","summary":"If the object was selected by picking a point on it, then SelectionPoint() returns the point where the selection occurred, otherwise it returns Point3d.Unset.","since":"5.0","returns":"The point where the selection occurred or Point3d.Unset on failure."},{"signature":"RhinoView SelectionView()","summary":"If the object was interactively selected in a particular viewport, then SelectionView() returns the view where the object was selected.","since":"6.5"},{"signature":"uint SelectionViewDetailSerialNumber()","summary":"If the object was interactively selected in a page space detail view, then SelectionViewDetailSerialNumber() returns the CRhinoObject serial number of the detail view object.  Use SelectionView() to get the page view that contains the detail view object. If SelectionViewDetailSerialNumber() returns 0, then the selection did not happen in a detail view.","since":"6.5"},{"signature":"void SetSelectionComponent(ComponentIndex componentIndex)","summary":"When an object is selected by picking a sub-object, SetSelectionComponent may be used to identify the sub-object.","since":"5.0"},{"signature":"SubD SubD()","summary":"Gets the SubD if the referenced geometry is one.","since":"7.0","returns":"A SubD; or None if the referenced object is not a SubD, or on error."},{"signature":"SubDFace SubDFace()","summary":"Gets the SubDFace if the referenced geometry is one.","since":"7.0","returns":"A SubDFace; or None if the referenced object is not a SubDFace, or on error."},{"signature":"Surface Surface()","summary":"Gets the surface if the referenced geometry is one.","since":"5.0","returns":"A surface; or None if the referenced object is not a surface, or on error."},{"signature":"Surface SurfaceParameter(out double u, out double v)","summary":"If the reference geometry is a surface, brep with one face, or surface edge with a selection point, then this gets the surface parameters of the selection point.","since":"5.0","parameters":[{"name":"u","summary":"The U value is assigned to this out parameter during the call."},{"name":"v","summary":"The V value is assigned to this out parameter during the call."}],"returns":"If the selection point was on a surface, then the surface is returned."},{"signature":"TextDot TextDot()","summary":"Gets the text dot if the referenced geometry is one.","since":"5.0","returns":"A text dot; or None if the referenced object is not a text dot, or on error."},{"signature":"TextEntity TextEntity()","summary":"Gets the text entity if the referenced geometry is one.","since":"5.0","returns":"A text entity; or None if the referenced object is not a text entity, or on error."},{"signature":"BrepTrim Trim()","summary":"If the referenced geometry is an edge of a surface, this returns the associated brep trim.","since":"5.8","returns":"A boundary representation trim; or None on error"}]},{"namespace":"Rhino.DocObjects","name":"OrdinateDimensionObject","dataType":"class","summary":"Rhino Object that represents an ordinate dimension geometry and attributes","baseclass":"Rhino.DocObjects.DimensionObject","properties":[{"signature":"OrdinateDimension OrdinateDimensionGeometry","summary":"Get the dimension geometry for this object.","since":"6.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"PhysicallyBasedMaterial","dataType":"class","properties":[{"signature":"double Anisotropic","since":"7.0","property":["get","set"]},{"signature":"double AnisotropicRotation","since":"7.0","property":["get","set"]},{"signature":"Color4f BaseColor","since":"7.0","property":["get","set"]},{"signature":"BRDFs BRDF","since":"7.0","property":["get","set"]},{"signature":"double Clearcoat","since":"7.0","property":["get","set"]},{"signature":"double ClearcoatRoughness","since":"7.0","property":["get","set"]},{"signature":"Color4f Emission","since":"7.0","property":["get","set"]},{"signature":"Material Material","since":"7.0","property":["get"]},{"signature":"double Metallic","since":"7.0","property":["get","set"]},{"signature":"double Opacity","since":"7.0","property":["get","set"]},{"signature":"double OpacityIOR","since":"7.0","property":["get","set"]},{"signature":"double OpacityRoughness","since":"7.0","property":["get","set"]},{"signature":"double ReflectiveIOR","since":"7.0","property":["get","set"]},{"signature":"double Roughness","since":"7.0","property":["get","set"]},{"signature":"double Sheen","since":"7.0","property":["get","set"]},{"signature":"double SheenTint","since":"7.0","property":["get","set"]},{"signature":"double Specular","since":"7.0","property":["get","set"]},{"signature":"double SpecularTint","since":"7.0","property":["get","set"]},{"signature":"double Subsurface","since":"7.0","property":["get","set"]},{"signature":"Color4f SubsurfaceScatteringColor","since":"7.0","property":["get","set"]},{"signature":"double SubsurfaceScatteringRadius","since":"7.0","property":["get","set"]}],"methods":[{"signature":"DocObjects.Texture GetTexture(TextureType which)","summary":"Get the texture that corresponds with the specified texture type for this material.","since":"7.0"},{"signature":"DocObjects.Texture[] GetTextures()","summary":"Get array of textures that this material uses","since":"7.0"},{"signature":"bool SetTexture(Texture texture, TextureType which)","summary":"Set the texture that corresponds with the specified texture type for this material.","since":"7.0","parameters":[{"name":"texture","summary":"An instance of Rhino.DocObjects.Texture"},{"name":"which","summary":"Use Rhino.DocObjects.TextureType"}]},{"signature":"void SynchronizeLegacyMaterial()","since":"7.0"}]},{"namespace":"Rhino.DocObjects","name":"PhysicallyBasedMaterial.BRDFs","dataType":"enum","since":"7.0","values":[{"signature":"GGX = 0"},{"signature":"Ward = 1"}]},{"namespace":"Rhino.DocObjects","name":"PointCloudObject","dataType":"class","baseclass":"Rhino.DocObjects.RhinoObject","properties":[{"signature":"PointCloud PointCloudGeometry","since":"5.0","property":["get"]}],"methods":[{"signature":"PointCloud DuplicatePointCloudGeometry()","since":"5.0"}]},{"namespace":"Rhino.DocObjects","name":"PointObject","dataType":"class","baseclass":"Rhino.DocObjects.RhinoObject","properties":[{"signature":"Point PointGeometry","since":"5.0","property":["get"]}],"methods":[{"signature":"Point DuplicatePointGeometry()","since":"5.0"}]},{"namespace":"Rhino.DocObjects","name":"ProxyObject","dataType":"class","summary":"A proxy object (not saved in files)","baseclass":"Rhino.DocObjects.RhinoObject","methods":[{"signature":"int CreateMeshes(MeshType meshType, MeshingParameters parameters, bool ignoreCustomParameters)","since":"7.0"},{"signature":"Mesh[] GetMeshes(MeshType meshType)","since":"7.0"}]},{"namespace":"Rhino.DocObjects","name":"RadialDimensionObject","dataType":"class","summary":"Rhino Object that represents a radial dimension geometry and attributes","baseclass":"Rhino.DocObjects.DimensionObject","properties":[{"signature":"RadialDimension RadialDimensionGeometry","summary":"Get the dimension geometry for this object.","since":"6.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"ReplayHistoryData","dataType":"class","summary":"Provides history information to commands that will repeat history construction. Generally, a developer using this class will not construct a new instance, but receive one.","interfaces":["IDisposable"],"properties":[{"signature":"RhinoDoc Document","summary":"The document this record belongs to","since":"5.0","property":["get"]},{"signature":"int HistoryVersion","summary":"ReplayHistory overrides check the version number to ensure the information saved in the history record is compatible with the current implementation of ReplayHistory","since":"5.0","property":["get"]},{"signature":"Guid RecordId","summary":"Each history record has a unique id that Rhino assigns when it adds the history record to the history record table","since":"5.0","property":["get"]},{"signature":"ReplayHistoryResult[] Results","summary":"Provides access to BOTH inputs and outputs of the replay history operation.  \\nUse this property to then call an appropriate UpdateToX() method and make your custom history support work.","since":"5.0","property":["get"]}],"methods":[{"signature":"void Dispose()","since":"5.0"},{"signature":"Rhino.DocObjects.ObjRef GetRhinoObjRef(int id)","summary":"In ReplayHistory, use GetRhinoObjRef to convert the information in a history record into the ObjRef that has up to date RhinoObject pointers","since":"5.0","parameters":[{"name":"id","summary":"HistoryRecord value id"}],"returns":"ObjRef on success, None if not successful"},{"signature":"bool TryGetBool(int id, out bool value)","since":"5.0"},{"signature":"bool TryGetColor(int id, out Color value)","since":"5.0"},{"signature":"bool TryGetDouble(int id, out double value)","since":"5.0"},{"signature":"bool TryGetDoubles(int id, out double[] values)","since":"6.10"},{"signature":"bool TryGetGuid(int id, out Guid value)","since":"5.0"},{"signature":"bool TryGetInt(int id, out int value)","since":"5.0"},{"signature":"bool TryGetPoint3d(int id, out Point3d value)","since":"5.0"},{"signature":"bool TryGetPoint3dOnObject(int id, out Point3d value)","since":"6.0"},{"signature":"bool TryGetString(int id, out string value)","since":"5.0"},{"signature":"bool TryGetTransform(int id, out Transform value)","since":"5.0"},{"signature":"bool TryGetVector3d(int id, out Vector3d value)","since":"5.0"}]},{"namespace":"Rhino.DocObjects","name":"ReplayHistoryResult","dataType":"class","properties":[{"signature":"RhinoObject ExistingObject","summary":"The previously existing object.  \\nDo not attempt to edit this object. It might have been already deleted by, for example, dragging.","since":"5.0","property":["get"]}],"methods":[{"signature":"bool UpdateToAngularDimension(AngularDimension dimension, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToArc(Arc arc, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToBrep(Brep brep, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToCircle(Circle circle, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToClippingPlane(Plane plane, double uMagnitude, double vMagnitude, Guid clippedViewportId, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToClippingPlane(Plane plane, double uMagnitude, double vMagnitude, IEnumerable<Guid> clippedViewportIds, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToCurve(Curve curve, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToEllipse(Ellipse ellipse, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToExtrusion(Extrusion extrusion, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToHatch(Hatch hatch, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToLeader(Leader leader, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToLine(Point3d from, Point3d to, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToLinearDimension(LinearDimension dimension, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToMesh(Mesh mesh, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToPoint(Point3d point, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToPointCloud(IEnumerable<Point3d> points, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToPointCloud(PointCloud cloud, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToPolyline(IEnumerable<Point3d> points, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToRadialDimension(RadialDimension dimension, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToSphere(Sphere sphere, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToSurface(Surface surface, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToText(string text, Plane plane, double height, string fontName, bool bold, bool italic, TextJustification justification, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToText(TextEntity text, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool UpdateToTextDot(TextDot dot, ObjectAttributes attributes)","since":"5.0"}]},{"namespace":"Rhino.DocObjects","name":"RhinoDeselectAllObjectsEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"RhinoDoc Document","since":"5.0","property":["get"]},{"signature":"int ObjectCount","since":"5.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"RhinoModifyObjectAttributesEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"RhinoDoc Document","since":"5.0","property":["get"]},{"signature":"ObjectAttributes NewAttributes","since":"5.0","property":["get"]},{"signature":"ObjectAttributes OldAttributes","since":"5.0","property":["get"]},{"signature":"RhinoObject RhinoObject","since":"5.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"RhinoObject","dataType":"class","summary":"Represents an object in the document.  \\nRhinoObjects should only ever be creatable by the RhinoDoc.","baseclass":"Rhino.DocObjects.ModelComponent","properties":[{"signature":"static uint NextRuntimeSerialNumber","summary":"Gets the runtime serial number that will be assigned to the next Rhino Object that is created.","since":"5.0","property":["get"]},{"signature":"ObjectAttributes Attributes","summary":"Gets or sets the object attributes.","since":"5.0","property":["get","set"]},{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.ModelGeometry.","since":"6.0","property":["get"]},{"signature":"RhinoDoc Document","summary":"Gets the document that owns this object.","since":"5.0","property":["get"]},{"signature":"GeometryBase Geometry","summary":"Gets the underlying geometry for this object.  \\nAll rhino objects are composed of geometry and attributes.","since":"5.0","property":["get"]},{"signature":"bool GripsOn","summary":"Gets or sets the activation state of object default editing grips.","since":"5.0","property":["get","set"]},{"signature":"bool GripsSelected","summary":"True if grips are turned on and at least one is selected.","since":"5.0","property":["get"]},{"signature":"int GroupCount","summary":"Number of groups object belongs to.","since":"5.0","property":["get"]},{"signature":"bool HasDynamicTransform","summary":"True if the object has a dynamic transformation","since":"5.0","property":["get"]},{"signature":"bool HasSubobjectMaterials","summary":"Will be True if the object contains sub object meshes with materials that are different than the top level object.","since":"6.0","property":["get"]},{"signature":"Guid Id","summary":"Every object has a Guid (globally unique identifier, also known as UUID, or universally unique identifier). The default value is Guid.Empty.  \\nWhen an object is added to a model, the value is checked.  If the value is Guid.Empty, a new Guid is created. If the value is not None but it is already used by another object in the model, a new Guid is created. If the value is not Guid.Empty and it is not used by another object in the model, then that value persists. When an object is updated, by a move for example, the value of ObjectId persists.  \\nThis value is the same as the one returned by this.Attributes.ObjectId.","since":"5.0","property":["get","set"]},{"signature":"uint InstanceDefinitionModelSerialNumber","summary":"When a component is in a model as part of the information required for a linked instance definition, this value identifies the linked instance definition reference model.","since":"6.12","property":["get"]},{"signature":"bool IsDeletable","summary":"Some objects cannot be deleted, like grips on lights and annotation objects.","since":"5.0","property":["get","set"]},{"signature":"bool IsDeleted","summary":"True if the object is deleted. Deleted objects are kept by the document for undo purposes. Call RhinoDoc.UndeleteObject to undelete an object.","since":"5.0","property":["get"]},{"signature":"bool IsHidden","summary":"An object must be in one of three modes: normal, locked or hidden. If an object is in normal mode, then the object\'s layer controls visibility and selectability. If an object is locked, then the object\'s layer controls visibility by the object cannot be selected. If the object is hidden, it is not visible and it cannot be selected.","since":"5.0","property":["get"]},{"signature":"bool IsInstanceDefinitionGeometry","summary":"True if the object is used as part of an instance definition.","since":"5.0","property":["get"]},{"signature":"bool IsLocked","summary":"An object must be in one of three modes: normal, locked or hidden. If an object is in normal mode, then the object\'s layer controls visibility and selectability. If an object is locked, then the object\'s layer controls visibility by the object cannot be selected. If the object is hidden, it is not visible and it cannot be selected.","since":"5.0","property":["get"]},{"signature":"bool IsNormal","summary":"An object must be in one of three modes: normal, locked or hidden. If an object is in normal mode, then the object\'s layer controls visibility and selectability. If an object is locked, then the object\'s layer controls visibility by the object cannot be selected. If the object is hidden, it is not visible and it cannot be selected.","since":"5.0","property":["get"]},{"signature":"bool IsReference","summary":"Gets a value indicating if an object is a reference object. An object from a work session reference model is a reference object and cannot be modified. An object is a reference object if, and only if, it is on a reference layer.","since":"5.0","property":["get"]},{"signature":"string Name","summary":"Rhino objects have optional text names.  More than one object in a model can have the same name and some objects may have no name.","since":"5.0","property":["get","set"]},{"signature":"ObjectType ObjectType","summary":"Gets the Rhino-based object type.","since":"5.0","property":["get"]},{"signature":"uint ReferenceModelSerialNumber","summary":"When a component is in a model for reference, this value identifies the reference model.","since":"6.12","property":["get"]},{"signature":"RenderMaterial RenderMaterial","summary":"Gets the render material associated with this object or None if there is none.  This does not pay attention to the material source and will not check parent objects or layers for a RenderMaterial.","since":"5.7","property":["get","set"]},{"signature":"uint RuntimeSerialNumber","summary":"Gets the objects runtime serial number.","since":"5.0","property":["get"]},{"signature":"ComponentIndex[] SubobjectMaterialComponents","since":"6.0","property":["get"]},{"signature":"bool Visible","summary":"Gets the object visibility.","since":"5.0","property":["get"]},{"signature":"uint WorksessionReferenceSerialNumber","summary":"Obsolete - use ReferenceModelSerialNumber","since":"6.3","property":["get"]}],"methods":[{"signature":"static RhinoObject FromRuntimeSerialNumber(uint serialNumber)","summary":"Get a Rhino object for a unique runtime serial number","since":"6.0"},{"signature":"static Brep[] GetFillSurfaces(RhinoObject rhinoObject, ClippingPlaneObject clippingPlaneObject)","summary":"Return list of fill surfaces if any for object and clipping plane.","since":"6.7","parameters":[{"name":"rhinoObject","summary":"Object to clip"},{"name":"clippingPlaneObject","summary":"Clipping plane to use"}]},{"signature":"static Brep[] GetFillSurfaces(RhinoObject rhinoObject, IEnumerable<ClippingPlaneObject> clippingPlaneObjects)","summary":"Return list of fill surfaces if any for object and clipping plane. Fills are trimmed by clipping planes that did not generate them.","since":"6.7","parameters":[{"name":"rhinoObject","summary":"Object to clip"},{"name":"clippingPlaneObjects","summary":"Enumeration of clipping plane objects"}],"returns":"Array of Brep containing fully trimmed fills if there were any generated."},{"signature":"static Brep[] GetFillSurfaces(RhinoObject rhinoObject, IEnumerable<ClippingPlaneObject> clippingPlaneObjects, bool unclippedFills)","summary":"Return list of fill surfaces if any for object and clipping plane.","since":"6.7","parameters":[{"name":"rhinoObject","summary":"Object to clip"},{"name":"clippingPlaneObjects","summary":"Enumeration of clipping plane objects"},{"name":"unclippedFills","summary":"Use True to get fills that are not trimmed by all clipping planes"}],"returns":"Array of Brep containing fills if there were any generated, trimmed if unclippedFills was false"},{"signature":"static ObjRef[] GetRenderMeshes(IEnumerable<RhinoObject> rhinoObjects, bool okToCreate, bool returnAllObjects)","summary":"Gets the render meshes of some objects.","since":"5.0","parameters":[{"name":"rhinoObjects","summary":"An array, a list, or any enumerable set of Rhino objects."},{"name":"okToCreate","summary":"True if the method is allowed to instantiate new meshes if they do not exist."},{"name":"returnAllObjects","summary":"True if all objects should be returned."}],"returns":"An array of object references."},{"signature":"static bool GetTightBoundingBox(IEnumerable<RhinoObject> rhinoObjects, out BoundingBox boundingBox)","summary":"Gets a world XY-plane aligned tight bounding box from a collection of Rhino objects.","since":"7.0","parameters":[{"name":"rhinoObjects","summary":"A collection of Rhino objects."},{"name":"boundingBox","summary":"A tight bounding box."}]},{"signature":"static bool GetTightBoundingBox(IEnumerable<RhinoObject> rhinoObjects, Plane plane, out BoundingBox boundingBox)","summary":"Gets a plane aligned tight bounding box from a collection of Rhino objects.","since":"7.0","parameters":[{"name":"rhinoObjects","summary":"A collection of Rhino objects."},{"name":"plane","summary":"A valid alignment plane."},{"name":"boundingBox","summary":"A tight bounding box."}]},{"signature":"static Commands.Result MeshObjects(IEnumerable<RhinoObject> rhinoObjects, MeshingParameters parameters, out Mesh[] meshes, out ObjectAttributes[] attributes)","summary":"Meshes Rhino objects.","since":"5.9","parameters":[{"name":"rhinoObjects","summary":"The Rhino objects to mesh."},{"name":"parameters","summary":"The parameters used to create the meshes."},{"name":"meshes","summary":"The created meshes are appended to this array."},{"name":"attributes","summary":"The object attributes that coincide with each created mesh are appended to this array."}],"returns":"The results of the calculation."},{"signature":"static Commands.Result MeshObjects(IEnumerable<RhinoObject> rhinoObjects, ref MeshingParameters parameters, ref bool simpleDialog, out Mesh[] meshes, out ObjectAttributes[] attributes)","summary":"Meshes Rhino objects.","since":"5.9","parameters":[{"name":"rhinoObjects","summary":"The Rhino objects to mesh."},{"name":"parameters","summary":"The parameters used to create the meshes. The meshing parameters may change."},{"name":"simpleDialog","summary":"True to display the simple mesh parameters dialog, False to display the detailed mesh parameters dialog."},{"name":"meshes","summary":"The created meshes are appended to this array."},{"name":"attributes","summary":"The object attributes that coincide with each created mesh are appended to this array."}],"returns":"The results of the calculation."},{"signature":"static Commands.Result MeshObjects(IEnumerable<RhinoObject> rhinoObjects, ref MeshingParameters parameters, ref int uiStyle, Transform xform, out Mesh[] meshes, out ObjectAttributes[] attributes)","summary":"Meshes Rhino objects.","since":"6.0","parameters":[{"name":"rhinoObjects","summary":"The Rhino objects to mesh."},{"name":"parameters","summary":"The parameters used to create the meshes. The meshing parameters may change."},{"name":"uiStyle","summary":"The user interface style, where: -1 = no interface, 0 = simple dialog, 1 = details dialog, 2 = script or batch mode"},{"name":"xform","summary":"Transform to be used for export with origin, or Z to Y up, etc."},{"name":"meshes","summary":"The created meshes are appended to this array."},{"name":"attributes","summary":"The object attributes that coincide with each created mesh are appended to this array."}],"returns":"The results of the calculation."},{"signature":"bool CommitChanges()","summary":"Moves changes made to this RhinoObject into the RhinoDoc.","since":"5.0","returns":"True if changes were made."},{"signature":"int CreateMeshes(MeshType meshType, MeshingParameters parameters, bool ignoreCustomParameters)","summary":"Create meshes used to render and analyze surface and polysurface objects.","since":"5.0","parameters":[{"name":"meshType","summary":"type of meshes to create"},{"name":"parameters","summary":"in parameters that control the quality of the meshes that are created"},{"name":"ignoreCustomParameters","summary":"Default should be false. Should the object ignore any custom meshing parameters on the object\'s attributes"}],"returns":"number of meshes created"},{"signature":"void Description(TextLog textLog)","summary":"Get a brief description of a object, including it\'s attributes and geometry.","since":"6.0","parameters":[{"name":"textLog","summary":"A text log for collecting the description."}]},{"signature":"GeometryBase DuplicateGeometry()","summary":"Constructs a deep (full) copy of the geometry.","since":"5.0","returns":"A copy of the internal geometry."},{"signature":"bool EnableCustomGrips(CustomObjectGrips customGrips)","summary":"Turns on/off the object\'s editing grips.","since":"5.0","parameters":[{"name":"customGrips","summary":"The custom object grips."}],"returns":"True if the call succeeded.  If you attempt to add custom grips to an object that does not support custom grips, then False is returned."},{"signature":"bool EnableVisualAnalysisMode(VisualAnalysisMode mode, bool enable)","summary":"Used to turn analysis modes on and off.","since":"5.0","parameters":[{"name":"mode","summary":"A visual analysis mode."},{"name":"enable","summary":"True if the mode should be activated; False otherwise."}],"returns":"True if this object supports the analysis mode."},{"signature":"Display.VisualAnalysisMode[] GetActiveVisualAnalysisModes()","summary":"Gets a list of currently enabled analysis modes for this object.","since":"5.0","returns":"An array of visual analysis modes. The array can be empty, but not null."},{"signature":"IConvertible GetCustomRenderMeshParameter(Guid providerId, String parameterName)","summary":"Query the object for the value of a given named custom render mesh parameter.","since":"6.0","parameters":[{"name":"providerId","summary":"Id of the custom render mesh provider"},{"name":"parameterName","summary":"Name of the parameter"}],"returns":"IConvertible. Note that you can\'t directly cast from object, instead you have to use the Convert mechanism."},{"signature":"bool GetDynamicTransform(out Transform transform)","summary":"While an object is being dynamically transformed (dragged, rotated, ...), the current transformation can be retrieved and used for creating dynamic display.","since":"5.0","returns":"True if the object is being edited and its transformation is available.  False if the object is not being edited, in which case the identity transform is returned."},{"signature":"GripObject[] GetGrips()","summary":"Returns grips for this object If grips are enabled. If grips are not enabled, returns null.","since":"5.0","returns":"An array of grip objects; or None if there are no grips."},{"signature":"int[] GetGroupList()","summary":"Allocates an array of group indices of length GroupCount. If GroupCountis 0, then this method returns null.","since":"5.0","returns":"An array of group indices, or None if GroupCountis 0."},{"signature":"ComponentIndex[] GetHighlightedSubObjects()","summary":"Gets a list of all highlighted sub-objects.","since":"5.0","returns":"An array of all highlighted sub-objects; or None is there are none."},{"signature":"Material GetMaterial(bool frontMaterial)","summary":"Gets material that this object uses based on it\'s attributes and the document that the object is associated with.  In the rare case that a document is not associated with this object, None will be returned.","since":"5.0","parameters":[{"name":"frontMaterial","summary":"If true, gets the material used to render the object\'s front side"}]},{"signature":"Material GetMaterial(ComponentIndex componentIndex)","summary":"Get the Material associated with the sub object identified by componentIndex if the component index is set to ComponentIndex.Unset then the top level material is returned.","since":"6.0","parameters":[{"name":"componentIndex","summary":"Returns the material associated with the specified sub object or the objects top level material if it is set to ComponentIndex.Unset"}],"returns":"Returns the Material associated with the sub object identified by componentIndex if the component index is set to ComponentIndex.Unset then the top level material is returned."},{"signature":"Material GetMaterial(ComponentIndex componentIndex, Guid plugInId)","summary":"Get the Material associated with the sub object identified by componentIndex if the component index is set to ComponentIndex.Unset then the top level material is returned.","since":"6.0","parameters":[{"name":"componentIndex","summary":"Returns the material associated with the specified sub object or the objects top level material if it is set to ComponentIndex.Unset"},{"name":"plugInId","summary":"The plug-in specific material to look for."}],"returns":"Returns the Material associated with the sub object identified by componentIndex if the component index is set to ComponentIndex.Unset then the top level material is returned."},{"signature":"Material GetMaterial(ComponentIndex componentIndex, Guid plugInId, ObjectAttributes attributes)","summary":"Get the Material associated with the sub object identified by componentIndex if the component index is set to ComponentIndex.Unset then the top level material is returned.","since":"6.0","parameters":[{"name":"componentIndex","summary":"Returns the material associated with the specified sub object or the objects top level material if it is set to ComponentIndex.Unset"},{"name":"plugInId","summary":"The plug-in specific material to look for."},{"name":"attributes","summary":"Optional object attributes used to determine the material source, if None the objects attributes are used."}],"returns":"Returns the Material associated with the sub object identified by componentIndex if the component index is set to ComponentIndex.Unset then the top level material is returned."},{"signature":"Mesh[] GetMeshes(MeshType meshType)","summary":"Get existing meshes used to render and analyze surface and polysurface objects.","since":"5.0","returns":"An array of meshes."},{"signature":"RenderMaterial GetRenderMaterial(bool frontMaterial)","summary":"Gets the RenderMaterial that this object uses based on it\'s attributes and the document that the object is associated with. If there is no RenderMaterial associated with this object then None is returned.  If None is returned you should call GetMaterial to get the material used to render this object.","since":"5.10","parameters":[{"name":"frontMaterial","summary":"If true, gets the material used to render the object\'s front side otherwise; gets the material used to render the back side of the object."}],"returns":"If there is a RenderMaterial associated with this objects\' associated Material then it is returned otherwise; None is returned."},{"signature":"RenderMaterial GetRenderMaterial(ComponentIndex componentIndex)","summary":"Gets the RenderMaterial associated with this object if there is one. If there is no RenderMaterial associated with this object then None is returned.  If None is returned you should call GetMaterial to get the material used to render this object.","since":"6.0","parameters":[{"name":"componentIndex","summary":"Returns the RenderMaterial associated with the specified sub object or the objects top level material if it is set to ComponentIndex.Unset"}],"returns":"Returns the RenderMaterialassociated with the sub object identified by componentIndex if the component index is set to  ComponentIndex.Unsetthen the top level RenderMaterail is returned.  If this method returns None it means there is no RenderMaterial associated with the object or  sub object so you should may GetMaterial get the objects generic material."},{"signature":"RenderMaterial GetRenderMaterial(ComponentIndex componentIndex, Guid plugInId)","summary":"Gets the RenderMaterial associated with this object if there is one. If there is no RenderMaterial associated with this object then None is returned.  If None is returned you should call GetMaterial to get the material used to render this object.","since":"6.0","parameters":[{"name":"componentIndex","summary":"Returns the RenderMaterial associated with the specified sub object or the objects top level material if it is set to  Rhino.Geometry.ComponentIndex.Unset"},{"name":"plugInId","summary":"The plug-in specific material to look for."}],"returns":"Returns the RenderMaterialassociated with the sub object identified by componentIndex if the component index is set to  ComponentIndex.Unsetthen the top level RenderMaterail is returned.  If this method returns None it means there is no RenderMaterial associated with the object or sub object so you should may GetMaterial get the objects generic material."},{"signature":"RenderMaterial GetRenderMaterial(ComponentIndex componentIndex, Guid plugInId, ObjectAttributes attributes)","summary":"Gets the RenderMaterial associated with this object if there is one. If there is no RenderMaterial associated with this object then None is returned.  If None is returned you should call GetMaterial to get the material used to render this object.","since":"6.0","parameters":[{"name":"componentIndex","summary":"Returns the RenderMaterial associated with the specified sub object or the objects top level material if it is set to  Rhino.Geometry.ComponentIndex.Unset"},{"name":"plugInId","summary":"The plug-in specific material to look for."},{"name":"attributes","summary":"Optional object attributes used to determine the material source, if None the objects attributes are used."}],"returns":"Returns the RenderMaterialassociated with the sub object identified by componentIndex if the component index is set to  ComponentIndex.Unsetthen the top level RenderMaterail is returned.  If this method returns None it means there is no RenderMaterial associated with the object or  sub object so you should may GetMaterial get the objects generic material."},{"signature":"MeshingParameters GetRenderMeshParameters()","summary":"Meshing parameters that this object uses for generating render meshes. If the object\'s attributes do not have custom meshing parameters, then the document\'s meshing parameters are used.","since":"5.0"},{"signature":"RenderPrimitiveList GetRenderPrimitiveList(ViewportInfo viewport, bool preview)","summary":"Build custom render mesh(es) for this object.","since":"5.7","deprecated":"6.0","parameters":[{"name":"viewport","summary":"The viewport being rendered."},{"name":"preview","summary":"Type of mesh to build, if preview is True then a smaller mesh may be generated in less time, False is meant when actually rendering."}],"returns":"Returns a RenderPrimitiveList if successful otherwise returns null."},{"signature":"RenderPrimitiveList GetRenderPrimitiveList(ViewportInfo viewport, DisplayPipelineAttributes attrs)","summary":"Build custom render mesh(es) for this object.","since":"6.0","parameters":[{"name":"viewport","summary":"The viewport being rendered."},{"name":"attrs","summary":"Attributes for the view mode you are supplying meshes for.  Will be None if this is a modal rendering."}],"returns":"Returns a RenderPrimitiveList if successful otherwise returns null."},{"signature":"ComponentIndex[] GetSelectedSubObjects()","summary":"Get a list of all selected sub-objects.","since":"5.0","returns":"An array of sub-object indices, or None if there are none."},{"signature":"RhinoObject[] GetSubObjects()","summary":"Explodes the object into sub-objects. It is up to the caller to add the returned objects to the document.","since":"5.0","returns":"An array of Rhino objects, or None if this object cannot be exploded."},{"signature":"int[] GetTextureChannels()","summary":"Get a list of the texture mapping channel Id\'s associated with object.","since":"5.7","returns":"Returns an array of channel Id\'s or an empty list if there are not mappings."},{"signature":"TextureMapping GetTextureMapping(int channel)","since":"5.7"},{"signature":"TextureMapping GetTextureMapping(int channel, out Transform objectTransform)","summary":"Get objects texture mapping","since":"5.7"},{"signature":"bool HasTextureMapping()","summary":"Returns True if this object has a texture mapping form any source (pluginId)","since":"6.0"},{"signature":"bool Highlight(bool enable)","summary":"Modifies the highlighting of the object.","since":"5.0","parameters":[{"name":"enable","summary":"True if highlighting should be enabled."}],"returns":"True if the object is now highlighted."},{"signature":"bool HighlightSubObject(ComponentIndex componentIndex, bool highlight)","summary":"Highlights a sub-object.","since":"5.0","parameters":[{"name":"componentIndex","summary":"A sub-object component index."},{"name":"highlight","summary":"True if the sub-object should be highlighted."}],"returns":"True if the sub-object is now highlighted."},{"signature":"bool InVisualAnalysisMode()","summary":"Reports if any visual analysis mode is currently active for an object.","since":"5.0","returns":"True if an analysis mode is active; otherwise false."},{"signature":"bool InVisualAnalysisMode(VisualAnalysisMode mode)","summary":"Reports if a visual analysis mode is currently active for an object.","since":"5.0","parameters":[{"name":"mode","summary":"The mode to check for.  \\nUse None if you want to see if any mode is active."}],"returns":"True if the specified analysis mode is active; otherwise false."},{"signature":"bool IsActiveInViewport(RhinoViewport viewport)","summary":"Determine if this object is active in a particular viewport.","since":"5.0","returns":"True if the object is active in viewport"},{"signature":"int IsHighlighted(bool checkSubObjects)","summary":"Check highlight state.","since":"5.0","parameters":[{"name":"checkSubObjects","summary":"If True and the entire object is not highlighted, and some subset of the object is highlighted, like some edges of a surface, then 3 is returned. If False and the entire object is not highlighted, then zero is returned."}],"returns":"0: object is not highlighted.  \\n1: entire object is highlighted.  \\n3: one or more proper sub-objects are highlighted."},{"signature":"bool IsMeshable(MeshType meshType)","summary":"Returns True if the object is capable of having a mesh of the specified type","since":"5.0"},{"signature":"bool IsSelectable()","summary":"Reports if an object can be selected.","since":"5.0","returns":"True if object is capable of being selected."},{"signature":"bool IsSelectable(bool ignoreSelectionState, bool ignoreGripsState, bool ignoreLayerLocking, bool ignoreLayerVisibility)","summary":"Reports if an object can be selected.","since":"5.0","parameters":[{"name":"ignoreSelectionState","summary":"If true, then selected objects are selectable. If false, then selected objects are not selectable."},{"name":"ignoreGripsState","summary":"If true, then objects with grips on can be selected. If false, then the value returned by the object\'s IsSelectableWithGripsOn() function decides if the object can be selected."},{"name":"ignoreLayerLocking","summary":"If true, then objects on locked layers are selectable. If false, then objects on locked layers are not selectable."},{"name":"ignoreLayerVisibility","summary":"If true, then objects on hidden layers are selectable. If false, then objects on hidden layers are not selectable."}],"returns":"True if object is capable of being selected."},{"signature":"int IsSelected(bool checkSubObjects)","summary":"Check selection state.","since":"5.0","parameters":[{"name":"checkSubObjects","summary":"(False is good default) If True and the entire object is not selected, and some subset of the object is selected, like some edges of a surface, then 3 is returned. If False and the entire object is not selected, then zero is returned."}],"returns":"0 = object is not selected. 1 = object is selected. 2 = entire object is selected persistently. 3 = one or more proper sub-objects are selected."},{"signature":"bool IsSubObjectHighlighted(ComponentIndex componentIndex)","summary":"Determines if a sub-object is highlighted.","since":"5.0","parameters":[{"name":"componentIndex","summary":"A sub-object component index."}],"returns":"True if the sub-object is highlighted."},{"signature":"bool IsSubObjectSelectable(ComponentIndex componentIndex, bool ignoreSelectionState)","summary":"Reports if a sub-object can be selected.","since":"5.0","parameters":[{"name":"componentIndex","summary":"index of sub-object to check."},{"name":"ignoreSelectionState","summary":"If true, then selected objects are selectable. If false, then selected objects are not selectable."}],"returns":"True if the specified sub-object can be selected."},{"signature":"bool IsSubObjectSelected(ComponentIndex componentIndex)","summary":"Check sub-object selection state.","since":"5.0","parameters":[{"name":"componentIndex","summary":"Index of sub-object to check."}],"returns":"True if the sub-object is selected."},{"signature":"uint MemoryEstimate()","summary":"Computes an estimate of the number of bytes that this object is using in memory. Note that this is a runtime memory estimate and does not directly compare to the amount of space take up by the object when saved to a file.","since":"5.0","returns":"The estimated number of bytes this object occupies in memory."},{"signature":"int MeshCount(MeshType meshType, MeshingParameters parameters)","summary":"RhinoObjects can have several different types of meshes and different numbers of meshes.  A b-rep can have a render and an analysis mesh on each face.  A mesh object has a single render mesh and no analysis mesh. Curve, point, and annotation objects have no meshes.","since":"5.0","parameters":[{"name":"meshType","summary":"type of mesh to count"},{"name":"parameters","summary":"if not None and if the object can change its mesh (like a brep), then only meshes that were created with these mesh parameters are counted."}],"returns":"number of meshes"},{"signature":"int Select(bool on)","summary":"Selects an object.","since":"5.0","parameters":[{"name":"on","summary":"The new selection state; True activates selection."}],"returns":"0: object is not selected.  \\n1: object is selected.  \\n2: object is selected persistently."},{"signature":"int Select(bool on, bool syncHighlight)","summary":"Selects an object.","since":"5.0","parameters":[{"name":"on","summary":"The new selection state; True activates selection."},{"name":"syncHighlight","summary":"If true, then the object is highlighted if it is selected and not highlighted if is not selected.  \\nHighlighting can be and stay out of sync, as its specification is independent."}],"returns":"0: object is not selected.  \\n1: object is selected.  \\n2: object is selected persistently."},{"signature":"int Select(bool on, bool syncHighlight, bool persistentSelect, bool ignoreGripsState, bool ignoreLayerLocking, bool ignoreLayerVisibility)","summary":"Selects an object.","since":"5.0","parameters":[{"name":"on","summary":"The new selection state; True activates selection."},{"name":"syncHighlight","summary":"If true, then the object is highlighted if it is selected and unhighlighted if is not selected.  \\nHighlighting can be and stay out of sync, as its specification is independent."},{"name":"persistentSelect","summary":"Objects that are persistently selected stay selected when a command terminates."},{"name":"ignoreGripsState","summary":"If true, then objects with grips on can be selected. If false, then the value returned by the object\'s IsSelectableWithGripsOn() function decides if the object can be selected when it has grips turned on."},{"name":"ignoreLayerLocking","summary":"If true, then objects on locked layers can be selected. If false, then objects on locked layers cannot be selected."},{"name":"ignoreLayerVisibility","summary":"If true, then objects on hidden layers can be selectable. If false, then objects on hidden layers cannot be selected."}],"returns":"0: object is not selected.  \\n1: object is selected.  \\n2: object is selected persistently."},{"signature":"int SelectSubObject(ComponentIndex componentIndex, bool select, bool syncHighlight)","summary":"Reports if an object can be selected.","since":"5.0","parameters":[{"name":"componentIndex","summary":"Index of sub-object to check."},{"name":"select","summary":"The new selection state; True activates selection."},{"name":"syncHighlight","summary":"(default=true) If true, then the object is highlighted if it is selected and unhighlighted if is not selected."}],"returns":"0: object is not selected 1: object is selected 2: object is selected persistently."},{"signature":"int SelectSubObject(ComponentIndex componentIndex, bool select, bool syncHighlight, bool persistentSelect)","summary":"Reports if an object can be selected.","since":"6.0","parameters":[{"name":"componentIndex","summary":"Index of sub-object to check."},{"name":"select","summary":"The new selection state; True activates selection."},{"name":"syncHighlight","summary":"(default=true) If true, then the object is highlighted if it is selected and unhighlighted if is not selected."},{"name":"persistentSelect","summary":"When true, selection persists even after the current command terminates."}],"returns":"0: object is not selected  \\n1: object is selected  \\n2: object is selected persistently."},{"signature":"void SetCustomRenderMeshParameter(Guid providerId, String parameterName, object value)","summary":"Set the named custom render mesh parameter value for this object.","since":"6.0","parameters":[{"name":"providerId","summary":"Id of the custom render mesh provider"},{"name":"parameterName","summary":""},{"name":"value","summary":""}]},{"signature":"int SetTextureMapping(int channel, TextureMapping tm)","since":"6.0"},{"signature":"int SetTextureMapping(int channel, TextureMapping tm, Transform objectTransform)","summary":"Sets texture mapping and mapping object transform for a channel","since":"6.26","parameters":[{"name":"channel","summary":""},{"name":"tm","summary":""},{"name":"objectTransform","summary":"Mapping channel object transform"}]},{"signature":"string ShortDescription(bool plural)","summary":"Gets a localized short descriptive name of the object.","since":"5.0","parameters":[{"name":"plural","summary":"True if the descriptive name should in plural."}],"returns":"A string with the short localized descriptive name."},{"signature":"bool SupportsRenderPrimitiveList(ViewportInfo viewport, bool preview)","summary":"Determines if custom render meshes will be built for a particular object.","since":"5.7","deprecated":"6.0","parameters":[{"name":"viewport","summary":"The viewport being rendered."},{"name":"preview","summary":"Type of mesh to build. If attributes is non-None then a smaller mesh may be generated in less time, False is meant when actually rendering."}],"returns":"Returns True if custom render mesh(es) will get built for this object."},{"signature":"bool SupportsRenderPrimitiveList(ViewportInfo viewport, DisplayPipelineAttributes attrs)","summary":"Determines if custom render meshes will be built for a particular object.","since":"6.0","parameters":[{"name":"viewport","summary":"The viewport being rendered."},{"name":"attrs","summary":"Type of mesh to build. If attributes is non-None then a smaller mesh may be generated in less time, False is meant when actually rendering."}],"returns":"Returns True if custom render mesh(es) will get built for this object."},{"signature":"bool TryGetGumballFrame(out GumballFrame frame)","summary":"If a Rhino object has been manipulated by Rhino\'s gumball, and the gumball is not in its default position, then the object\'s repositioned gumball frame is returned.","since":"7.0","parameters":[{"name":"frame","summary":"The gumball frame."}],"returns":"True if the object has a gumball frame, otherwise false."},{"signature":"bool TryGetRenderPrimitiveBoundingBox(ViewportInfo viewport, bool preview, out BoundingBox boundingBox)","summary":"Get the bounding box for the custom render meshes associated with this object.","since":"5.7","deprecated":"6.0","parameters":[{"name":"viewport","summary":"The viewport being rendered."},{"name":"preview","summary":"Type of mesh to build, if preview is True then a smaller mesh may be generated in less time, False is meant when actually rendering."},{"name":"boundingBox","summary":"This will be set to BoundingBox.Unset on failure otherwise it will be the bounding box for the custom render meshes associated with this object."}],"returns":"Returns True if the bounding box was successfully calculated otherwise returns False on error."},{"signature":"bool TryGetRenderPrimitiveBoundingBox(ViewportInfo viewport, DisplayPipelineAttributes attrs, out BoundingBox boundingBox)","summary":"Get the bounding box for the custom render meshes associated with this object.","since":"6.0","parameters":[{"name":"viewport","summary":"The viewport being rendered."},{"name":"attrs","summary":"Attributes for the view mode you are supplying meshes for.  Will be None if this is a modal rendering."},{"name":"boundingBox","summary":"This will be set to BoundingBox.Unset on failure otherwise it will be the bounding box for the custom render meshes associated with this object."}],"returns":"Returns True if the bounding box was successfully calculated otherwise returns False on error."},{"signature":"int UnhighlightAllSubObjects()","summary":"Removes highlighting from all sub-objects.","since":"5.0","returns":"The number of changed sub-objects."},{"signature":"int UnselectAllSubObjects()","summary":"Removes selection from all sub-objects.","since":"5.0","returns":"The number of unselected sub-objects."}]},{"namespace":"Rhino.DocObjects","name":"RhinoObjectEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"Guid ObjectId","since":"5.0","property":["get"]},{"signature":"RhinoObject TheObject","since":"5.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"RhinoObjectSelectionEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"RhinoDoc Document","since":"5.0","property":["get"]},{"signature":"RhinoObject[] RhinoObjects","since":"5.0","property":["get"]},{"signature":"bool Selected","summary":"Returns True if objects are being selected. Returns False if objects are being deselected.","since":"5.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"RhinoReplaceObjectEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"RhinoDoc Document","since":"5.0","property":["get"]},{"signature":"RhinoObject NewRhinoObject","since":"5.0","property":["get"]},{"signature":"Guid ObjectId","since":"5.0","property":["get"]},{"signature":"RhinoObject OldRhinoObject","since":"5.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"RhinoTransformObjectsEventArgs","dataType":"class","summary":"EventArgs passed to RhinoDoc.BeforeTransform.","baseclass":"EventArgs","properties":[{"signature":"int GripCount","summary":"The number of Rhino object grips that will be transformed.","since":"7.0","property":["get"]},{"signature":"int GripOwnerCount","summary":"The number of Rhino object grip owners that will be changed when the grips are transformed.","since":"7.0","property":["get"]},{"signature":"RhinoObject[] GripOwners","summary":"An array of Rhino object grip owners that will be changed when the grips are transformed. WARNING: these objects may be deleted at anytime after the event handler has been notified. Do not save references to these objects. Use the object\'s runtime serial number to safely reference these objects at a later time.","since":"7.0","property":["get"]},{"signature":"GripObject[] Grips","summary":"An array of Rhino object grips that will be transformed. WARNING: these objects may be deleted at anytime after the event handler has been notified. Do not save references to these objects. Use the object\'s runtime serial number to safely reference these objects at a later time.","since":"7.0","property":["get"]},{"signature":"int ObjectCount","summary":"The number of Rhino objects that will be transformed.","since":"5.10","property":["get"]},{"signature":"RhinoObject[] Objects","summary":"An array of Rhino objects to be transformed. WARNING: these objects may be deleted at anytime after the event handler has been notified. Do not save references to these objects. Use the object\'s runtime serial number to safely reference these objects at a later time.","since":"5.10","property":["get"]},{"signature":"bool ObjectsWillBeCopied","summary":"True if the objects will be copied.","since":"5.10","property":["get"]},{"signature":"Transform Transform","summary":"The transformation to be applied.","since":"5.10","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"SelectionMethod","dataType":"enum","summary":"Defines enumerated values for several kinds of selection methods.","since":"5.0","values":[{"signature":"Other = 0","summary":"Selected by non-mouse method (SelAll, etc.)"},{"signature":"MousePick = 1","summary":"Selected by a mouse click on the object."},{"signature":"WindowBox = 2","summary":"Selected by a mouse selection window box. Window selection indicates the object is completely contained by the selection rectangle."},{"signature":"CrossingBox = 3","summary":"Selected by a mouse selection crossing box. A crossing selection indicates the object intersects with the selection rectangle."}]},{"namespace":"Rhino.DocObjects.SnapShots","name":"SnapShotsClient","dataType":"class","summary":"This is the abstract interface class for all Snapshot clients.","interfaces":["IDisposable"],"constructors":[{"signature":"SnapShotsClient()","summary":"SnapShotsClient constructor","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.0","property":["get"]},{"signature":"int SerialNumber","since":"6.0","property":["get","set"]}],"methods":[{"signature":"static string ApplicationCategory()","summary":"Predefined application category","since":"6.0"},{"signature":"static string DocumentCategory()","summary":"Predefined document category","since":"6.0"},{"signature":"static string LayersCategory()","summary":"Predefined layers category","since":"6.0"},{"signature":"static string LightsCategory()","summary":"Predefined lights category","since":"6.0"},{"signature":"static string ObjectsCategory()","summary":"Predefined objects category","since":"6.0"},{"signature":"static bool RegisterSnapShotClient(SnapShotsClient client)","summary":"Function used to register snapshots client","since":"6.0"},{"signature":"static string RenderingCategory()","summary":"Predefined rendering category","since":"6.0"},{"signature":"static string ViewsCategory()","summary":"Predefined views category","since":"6.0"},{"signature":"bool AnimateDocument(RhinoDoc doc, double dPos, BinaryArchiveReader archive_start, BinaryArchiveReader archive_stop)","summary":"Called for each frame. Starting at 0.0.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document."},{"name":"dPos","summary":"dPos is the current frame. Starting at 0.0."},{"name":"archive_start","summary":"archive_start is a archive to the data of the starting position."},{"name":"archive_stop","summary":"archive_stop is a archive to the data of the ending position."}],"returns":"True if successful, otherwise false."},{"signature":"bool AnimateObject(RhinoDoc doc, RhinoObject doc_object, ref Transform transform, double dPos, BinaryArchiveReader archive_start, BinaryArchiveReader archive_stop)","summary":"Called for each frame. Starting at 0.0.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document."},{"name":"doc_object","summary":"doc_obj is the current object."},{"name":"transform","summary":"transform is a transformation matrix. The matrix is set to identity the first time an object is associated with a snapshot. After that the matrix is updated when the object is transformed(scale, rotate etc.)."},{"name":"dPos","summary":"dPos is the current frame. Starting at 0.0."},{"name":"archive_start","summary":"archive_start is a archive to the data of the starting position."},{"name":"archive_stop","summary":"archive_stop is a archive to the data of the ending position."}]},{"signature":"void AnimationStart(RhinoDoc doc, int iFrames)","summary":"Called once at the start of an animation.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document."},{"name":"iFrames","summary":"iFrames is the number of frames to be animated."}]},{"signature":"bool AnimationStop(RhinoDoc doc)","summary":"Called once at the end of an animation.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document."}]},{"signature":"string Category()","summary":"The category of this client. Usually one of the above predefined categories like e.g object, rendering or application category","since":"6.0"},{"signature":"Guid ClientId()","summary":"The unique id of this client.","since":"6.0","returns":"The unique id of this client."},{"signature":"void Dispose()","summary":"SnapShotsClient Dispose","since":"6.0"},{"signature":"void ExtendBoundingBoxForDocumentAnimation(RhinoDoc doc, BinaryArchiveReader archive_start, BinaryArchiveReader archive_stop, ref BoundingBox bbox)","summary":"Called once at the start of an animation. This can be used to extend the scene bounding box to avoid clipping.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document."},{"name":"archive_start","summary":"archive_start is a archive to the data of the starting position."},{"name":"archive_stop","summary":"archive_stop is a archive to the data of the ending position."},{"name":"bbox","summary":"bbox is the current scene bounding box."}]},{"signature":"void ExtendBoundingBoxForObjectAnimation(RhinoDoc doc, RhinoObject doc_object, ref Transform transform, BinaryArchiveReader archive_start, BinaryArchiveReader archive_stop, ref BoundingBox bbox)","summary":"Called once at the start of an animation. This can be used to extend the scene bounding box to avoid clipping.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document."},{"name":"doc_object","summary":"doc_obj is the current object."},{"name":"transform","summary":"transform is a transformation matrix. The matrix is set to identity the first time an object is associated with a snapshot. After that the matrix is updated when the object is transformed(scale, rotate etc.)."},{"name":"archive_start","summary":"archive_start is a archive to the data of the starting position."},{"name":"archive_stop","summary":"archive_stop is a archive to the data of the ending position."},{"name":"bbox","summary":"bbox is the current scene bounding box."}]},{"signature":"bool IsCurrentModelStateInAnySnapshot(RhinoDoc doc, BinaryArchiveReader archive, SimpleArrayBinaryArchiveReader archive_array, TextLog text_log)","summary":"Called before restoring a snapshot. Warns the user if the current model state is not already saved.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document."},{"name":"archive","summary":"archive is the current state of the model."},{"name":"archive_array","summary":"archive_array is a list of client data."},{"name":"text_log","summary":"text_log is used to list the missing items that cannot be found in the current model."}],"returns":"return True if successful, otherwise false."},{"signature":"bool IsCurrentModelStateInAnySnapshot(RhinoDoc doc, RhinoObject doc_object, BinaryArchiveReader archive, SimpleArrayBinaryArchiveReader archive_array, TextLog text_log)","summary":"Called before restoring a snapshot. Warns the user if the current model state is not already saved.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document."},{"name":"doc_object","summary":"doc_object is the current object."},{"name":"archive","summary":"archive is the current state of the model."},{"name":"archive_array","summary":"archive_array is a list of client data."},{"name":"text_log","summary":"text_log is used to list the missing items that cannot be found in the current model."}],"returns":"return True if successful, otherwise false."},{"signature":"string Name()","summary":"The client\'s name.","since":"6.0","returns":"The client\'s name."},{"signature":"bool ObjectTransformNotification(RhinoDoc doc, RhinoObject doc_object, ref Transform transform, BinaryArchiveReader archive)","summary":"Called for every object that is associated with a snapshot and gets transformed in Rhino. This is getting called for each stored snapshot and gives the client the possibility to update the stored data.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document."},{"name":"doc_object","summary":"doc_obj is the current object."},{"name":"transform","summary":"transform is a transformation matrix. The matrix is set to identity the first time an object is associated with a snapshot. After that the matrix is updated when the object is transformed(scale, rotate etc.)."},{"name":"archive","summary":"archive is a archive which can be used to update the stored data."}],"returns":"True if successful, otherwise false."},{"signature":"Guid PlugInId()","summary":"The plug-in id that registers this client.","since":"6.0","returns":"The plug-in id that registers this client."},{"signature":"bool PrepareForDocumentAnimation(RhinoDoc doc, BinaryArchiveReader archive_start, BinaryArchiveReader archive_stop)","summary":"Called once at the start of an animation.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document."},{"name":"archive_start","summary":"archive_start is a archive to the data of the starting position."},{"name":"archive_stop","summary":"archive_stop is a archive to the data of the ending position."}],"returns":"True if successful, otherwise"},{"signature":"bool PrepareForObjectAnimation(RhinoDoc doc, RhinoObject doc_object, ref Transform transform, BinaryArchiveReader archive_start, BinaryArchiveReader archive_stop)","summary":"Called once at the start of an animation.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document."},{"name":"doc_object","summary":"doc_obj is the current object."},{"name":"transform","summary":"transform is a transformation matrix. The matrix is set to identity the first time an object is associated with a snapshot. After that the matrix is updated when the object is transformed(scale, rotate etc.)."},{"name":"archive_start","summary":"archive_start is a archive to the data of the starting position."},{"name":"archive_stop","summary":"archive_stop is a archive to the data of the ending position."}],"returns":"True if successful, otherwise false."},{"signature":"bool RestoreDocument(RhinoDoc doc, BinaryArchiveReader archive)","summary":"Called when the user restores a snapshot and SupportDocument() returns true.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document"},{"name":"archive","summary":"archive is the archive to read the data from"}],"returns":"True if successful, otherwise false"},{"signature":"bool RestoreObject(RhinoDoc doc, RhinoObject doc_object, ref Transform transform, BinaryArchiveReader archive)","summary":"Called when the user restores a snapshot and SupportsObjects() and SupportsObject(Rhino.DocObjects.RhinoObject doc_object) returns true.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document."},{"name":"doc_object","summary":"doc_obj is the current object."},{"name":"transform","summary":"transform is a transformation matrix. The matrix is set to identity the first time an object is associated with a snapshot. After that the matrix is updated when the object is transformed(scale, rotate etc.)."},{"name":"archive","summary":"archive is the archive to read the data from."}],"returns":"True if successful, otherwise false."},{"signature":"bool SaveDocument(RhinoDoc doc, BinaryArchiveWriter archive)","summary":"Called when the user saves a snapshot and SupportDocument() returns true.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document"},{"name":"archive","summary":"archive is the archive to write the data to"}],"returns":"True if successful, otherwise false"},{"signature":"bool SaveObject(RhinoDoc doc, RhinoObject doc_object, ref Transform transform, BinaryArchiveWriter archive)","summary":"Called when the user saves a snapshot and SupportsObjects() and SupportsObject(Rhino.DocObjects.RhinoObject doc_object) returns true.","since":"6.0","parameters":[{"name":"doc","summary":"doc is the current document."},{"name":"doc_object","summary":"doc_obj is the current object."},{"name":"transform","summary":"transform is a transformation matrix. The matrix is set to identity the first time an object is associated with a snapshot. After that the matrix is updated when the object is transformed(scale, rotate etc.)."},{"name":"archive","summary":"archive is the archive to write the data to."}],"returns":"True if successful, otherwise false."},{"signature":"void SnapshotRestored(RhinoDoc doc)","summary":"Called after all clients restored their data.","since":"6.0"},{"signature":"bool SupportsAnimation()","summary":"Returns True if the client allows animation.","since":"6.0","returns":"True if the client allows animation."},{"signature":"bool SupportsDocument()","summary":"Defines if the client supports document user data or not","since":"6.0","returns":"True if the client saves/restores document user data."},{"signature":"bool SupportsObject(RhinoObject doc_object)","summary":"Returns True if the client saves/restores object user data for the given object.","since":"6.0","parameters":[{"name":"doc_object","summary":"doc_object is the given object"}],"returns":"True if the client saves/restores object user data for the given object."},{"signature":"bool SupportsObjects()","summary":"Returns True if the client saves/restores object user data.","since":"6.0","returns":"True if the client saves/restores object user data."}]},{"namespace":"Rhino.DocObjects","name":"SubDObject","dataType":"class","summary":"Rhino object for SubD","baseclass":"Rhino.DocObjects.RhinoObject"},{"namespace":"Rhino.DocObjects","name":"SurfaceObject","dataType":"class","summary":"Represents a Rhino.Geometry.Surfacein a document.","baseclass":"Rhino.DocObjects.RhinoObject","properties":[{"signature":"Surface SurfaceGeometry","summary":"Gets the surface geometry linked with this object.","since":"5.0","property":["get"]}],"methods":[{"signature":"Surface DuplicateSurfaceGeometry()","summary":"Constructs a new deep copy of the surface geometry.","since":"5.0","returns":"The copy of the geometry."}]},{"namespace":"Rhino.DocObjects.Tables","name":"BitmapTable","dataType":"class","summary":"Stores the list of bitmaps in a Rhino document.","baseclass":"RhinoDocCommonTable<BitmapEntry>","interfaces":["ICollection<BitmapEntry>"],"properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.Image.","since":"6.0","property":["get"]}],"methods":[{"signature":"int AddBitmap(string bitmapFilename, bool replaceExisting)","summary":"Adds a new bitmap with specified name to the bitmap table.","since":"5.0","parameters":[{"name":"bitmapFilename","summary":"If NULL or empty, then a unique name of the form \\"Bitmap 01\\" will be automatically created."},{"name":"replaceExisting","summary":"If True and the there is already a bitmap using the specified name, then that bitmap is replaced. If False and there is already a bitmap using the specified name, then -1 is returned."}],"returns":"index of new bitmap in table on success. -1 on error."},{"signature":"bool Delete(BitmapEntry item)","summary":"Removes the bitmap from the table.","since":"6.0","parameters":[{"name":"item","summary":"The item to remove. Null will always return false."}],"returns":"True if the item could be deleted; otherwise, false."},{"signature":"bool DeleteBitmap(string bitmapFilename)","summary":"Deletes a bitmap.","since":"5.0","parameters":[{"name":"bitmapFilename","summary":"The bitmap file name."}],"returns":"True if successful. False if the bitmap cannot be deleted because it is the current bitmap or because it bitmap contains active geometry."},{"signature":"bool ExportToFile(int index, string path)","summary":"Writes a bitmap to a file.","since":"5.0","parameters":[{"name":"index","summary":"The index of the bitmap to be written."},{"name":"path","summary":"The full path, including file name and extension, name of the file to write."}],"returns":"True if successful."},{"signature":"int ExportToFiles(string directoryPath, int overwrite)","summary":"Exports all the bitmaps in the table to files.","since":"5.0","parameters":[{"name":"directoryPath","summary":"full path to the directory where the bitmaps should be saved. If NULL, a dialog is used to interactively get the directory name."},{"name":"overwrite","summary":"0 = no, 1 = yes, 2 = ask."}],"returns":"Number of bitmaps written."},{"signature":"BitmapEntry Find(string name, bool createFile, out string fileName)","summary":"This function first attempts to find the file with \\"name\\" on the disk. If it does find it, \\"fileName\\" is set to the full path of the file and the BitmapEntry returned will be null, even if there was a BitmapEntry with \\"name\\" in the bitmap table. If the function cannot find the file on the disk, it searches the bitmap table.  If it finds it, the returned BitmapEntry entry will be the entry in the table with that name. Additionally, if \\"createFile\\" is true, and an entry is found, the file will be written to the disk and it\'s full path will be contained in \\"fileName\\".","since":"5.1","parameters":[{"name":"name","summary":"Name of the file to search for including file extension."},{"name":"createFile","summary":"If this is true, and the file is not found on the disk but is found in the BitmapTable, then the BitmapEntry will get saved to the Rhino bitmap file cache and fileName will contain the full path to the cached file."},{"name":"fileName","summary":"The full path to the current location of this file or an empty string if the file was not found and/or not extracted successfully."}],"returns":"Returns None if \\"name\\" was found on the disk.  If name was not found on the disk, returns the BitmapEntry with the specified name if it is found in the bitmap table and None if it was not found in the bitmap table."},{"signature":"BitmapEntry FindIndex(int index)","summary":"Retrieves a BitmapEntry object based on Index. This search type of search is discouraged. We are moving towards using only IDs for all tables.","since":"6.0","parameters":[{"name":"index","summary":"The index to search for."}],"returns":"A BitmapEntry object, or None if none was found."}]},{"namespace":"Rhino.DocObjects.Tables","name":"DimStyleTable","dataType":"class","baseclass":"RhinoDocCommonTable<DimensionStyle>","interfaces":["ICollection<DimensionStyle>"],"properties":[{"signature":"DimensionStyle[] BuiltInStyles","summary":"Creates an array of default AnnotationStyle objects","since":"6.0","property":["get"]},{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.DimStyle.","since":"6.0","property":["get"]},{"signature":"DimensionStyle Current","summary":"Returns an instance of the current DimensionStyle.","since":"6.0","property":["get"]},{"signature":"DimensionStyle CurrentDimensionStyle","summary":"Do not use. Use the Currentproperty.","since":"5.0","property":["get"]},{"signature":"Guid CurrentId","since":"6.0","property":["get"]},{"signature":"int CurrentIndex","since":"6.0","property":["get"]}],"methods":[{"signature":"int Add(DimensionStyle dimstyle, bool reference)","summary":"Adds a new DimensionStyle to the document.","since":"6.0","parameters":[{"name":"dimstyle","summary":"The dimension style to add"},{"name":"reference","summary":"if True the dimstyle will not be saved in files."}],"returns":"index of new AnnotationStyle."},{"signature":"int Add(string name)","summary":"Adds a new AnnotationStyle to the document. The new AnnotationStyle will be initialized with the current default AnnotationStyle properties.","since":"5.0","parameters":[{"name":"name","summary":"Name of the new AnnotationStyle. If None or empty, Rhino automatically generates the name."}],"returns":"index of new AnnotationStyle."},{"signature":"int Add(string name, bool reference)","summary":"Adds a new AnnotationStyle to the document. The new AnnotationStyle will be initialized with the current default AnnotationStyle properties.","since":"5.0","parameters":[{"name":"name","summary":"Name of the new AnnotationStyle. If None or empty, Rhino automatically generates the name."},{"name":"reference","summary":"if True the dimstyle will not be saved in files."}],"returns":"index of new AnnotationStyle."},{"signature":"bool Delete(DimensionStyle item)","summary":"Removes an annotation style.","since":"6.0","parameters":[{"name":"item","summary":"The item to remove."}],"returns":"True if the item was removed; False otherwise."},{"signature":"bool Delete(int index, bool quiet)","since":"6.0"},{"signature":"DimensionStyle Find(Guid styleId, bool ignoreDeleted)","since":"6.0"},{"signature":"DimensionStyle Find(string name, bool ignoreDeleted)","since":"5.0","deprecated":"6.0"},{"signature":"DimensionStyle FindIndex(int index)","summary":"Retrieves a DimensionStyle object based on Index. This search type of search is discouraged. We are moving towards using only IDs for all tables.","since":"6.0","parameters":[{"name":"index","summary":"The index to search for."}],"returns":"A DimensionStyle object, or None if none was found."},{"signature":"DimensionStyle FindName(string name)","summary":"Finds the DimensionStyle with a given name and returns it. None is returned if no DimensionStyle is found.","since":"6.0","parameters":[{"name":"name","summary":"The string to search. Deleted styles are ignored."}],"returns":"The instance, or null."},{"signature":"DimensionStyle FindRoot(Guid styleId, bool ignoreDeleted)","since":"6.0"},{"signature":"IEnumerator<DimensionStyle> GetEnumerator()","since":"5.0"},{"signature":"string GetUnusedStyleName()","summary":"Get a unique name for a style that does not already exist in the DimStyle table","since":"6.0"},{"signature":"string GetUnusedStyleName(string rootName)","summary":"Get a unique name for a dimension style that does not already exist in the DimStyle table","since":"6.0","parameters":[{"name":"rootName","summary":"prefix in name; typically the parent style name"}]},{"signature":"ModifyType Modify(DimensionStyle dimstyle, AnnotationBase annotation)","since":"6.0"},{"signature":"bool Modify(DimensionStyle newSettings, Guid dimstyleId, bool quiet)","summary":"Modifies dimension style settings.","since":"6.0","parameters":[{"name":"newSettings","summary":"This information is copied."},{"name":"dimstyleId","summary":"Id of dimension style"},{"name":"quiet","summary":"if true, information message boxes pop up when illegal changes are attempted."}],"returns":"True if successful. False if Id is not already in table"},{"signature":"bool Modify(DimensionStyle newSettings, int dimstyleIndex, bool quiet)","summary":"Modifies dimension style settings.","since":"6.0","parameters":[{"name":"newSettings","summary":"This information is copied."},{"name":"dimstyleIndex","summary":"zero based index of dimension to set. Must be in the range 0 <= dimstyleIndex < DimStyleTable.Count."},{"name":"quiet","summary":"if true, information message boxes pop up when illegal changes are attempted."}],"returns":"True if successful. False if dimstyleIndex is out of range"},{"signature":"bool SetCurrent(int index, bool quiet)","summary":"Sets the Currentproperty.","since":"6.0","parameters":[{"name":"index","summary":"The index of the current DimStyle."},{"name":"quiet","summary":"True if error dialog boxes are disabled. False if they are enabled."}],"returns":"True if the method achieved its goal; otherwise false."},{"signature":"bool SetCurrentDimensionStyleIndex(int index, bool quiet)","summary":"Do not use. Use the SetCurrentmethod.","since":"5.0","deprecated":"6.0","parameters":[{"name":"index","summary":"Do not use."},{"name":"quiet","summary":"Do not use."}],"returns":"Do not use."}]},{"namespace":"Rhino.DocObjects.Tables","name":"DimStyleTableEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"RhinoDoc Document","since":"6.0","property":["get"]},{"signature":"DimStyleTableEventType EventType","since":"6.0","property":["get"]},{"signature":"int Index","since":"6.0","property":["get"]},{"signature":"DimensionStyle NewState","since":"6.0","property":["get"]},{"signature":"DimensionStyle OldState","since":"6.0","property":["get"]}]},{"namespace":"Rhino.DocObjects.Tables","name":"DimStyleTableEventType","dataType":"enum","since":"6.0","values":[{"signature":"Added"},{"signature":"Deleted"},{"signature":"Undeleted"},{"signature":"Modified","summary":"name, color, etc., change"},{"signature":"Sorted","summary":"doc.m_dimstyle_table.Sort() potentially changed sort order"},{"signature":"Current","summary":"current dim style change"}]},{"namespace":"Rhino.DocObjects.Tables","name":"FontTable","dataType":"class","summary":"Font tables store the list of fonts in a Rhino document. The FontTable is now just a wrapper around the DimStyles table.","remarks":"The FontTable is now just a wrapper around the DimStyles table.","interfaces":["IEnumerable<Font>","Collections.IRhinoTable<Font>"],"properties":[{"signature":"int Count","summary":"Number of fonts in the table.","since":"5.0","property":["get"]},{"signature":"int CurrentIndex","summary":"At all times, there is a \\"current\\" font.  Unless otherwise specified, new dimension objects are assigned to the current font. The current font is never deleted. Returns: Zero based font index of the current font.","since":"5.0","property":["get"]},{"signature":"RhinoDoc Document","summary":"Document that owns this table.","since":"5.0","property":["get"]}],"methods":[{"signature":"int FindOrCreate(string face, bool bold, bool italic)","summary":"Get a DimensionStyle with the specified characteristics the settings other than face, bold and italic are copied from the current style","since":"5.0"},{"signature":"int FindOrCreate(string face, bool bold, bool italic, DimensionStyle template_style)","summary":"Get a DimensionStyle with the specified characteristics","since":"6.0","parameters":[{"name":"face","summary":""},{"name":"bold","summary":""},{"name":"italic","summary":""},{"name":"template_style","summary":"the settings other than face, bold and italic are copied from the template_style"}]},{"signature":"IEnumerator<Font> GetEnumerator()","since":"5.0"}]},{"namespace":"Rhino.DocObjects.Tables","name":"GroupTable","dataType":"class","summary":"Group tables store the list of groups in a Rhino document.","baseclass":"RhinoDocCommonTable<Group>","interfaces":["ICollection<Group>"],"properties":[{"signature":"ModelComponentType ComponentType","since":"6.0","property":["get"]}],"methods":[{"signature":"int Add()","summary":"Adds a new empty group to the group table.","since":"5.0","returns":">=0 index of new group. -1 group not added because a group with that name already exists."},{"signature":"int Add(IEnumerable<Guid> objectIds)","summary":"Adds a new group to the group table with a set of objects.","since":"5.0","parameters":[{"name":"objectIds","summary":"An array, a list or any enumerable set of object IDs."}],"returns":">=0 index of new group.  \\n-1 group not added because a group with that name already exists."},{"signature":"int Add(string groupName)","summary":"Adds a new empty group to the group table.","since":"5.0","parameters":[{"name":"groupName","summary":"name of new group."}],"returns":">=0 index of new group. -1 group not added because a group with that name already exists."},{"signature":"int Add(string groupName, IEnumerable<Guid> objectIds)","summary":"Adds a new group to the group table with a set of objects.","since":"5.0","parameters":[{"name":"groupName","summary":"Name of new group."},{"name":"objectIds","summary":"An array, a list or any enumerable set of object IDs."}],"returns":">=0 index of new group.  \\n-1 group not added because a group with that name already exists."},{"signature":"bool AddToGroup(int groupIndex, Guid objectId)","summary":"Adds an object to an existing group.","since":"5.0","parameters":[{"name":"groupIndex","summary":"The group index value."},{"name":"objectId","summary":"An ID of an object."}],"returns":"True if the operation was successful."},{"signature":"bool AddToGroup(int groupIndex, IEnumerable<Guid> objectIds)","summary":"Adds a list of objects to an existing group.","since":"5.0","parameters":[{"name":"groupIndex","summary":"The group index value."},{"name":"objectIds","summary":"An array, a list or any enumerable set of IDs to objects."}],"returns":"True if at least an operation was successful."},{"signature":"bool ChangeGroupName(int groupIndex, string newName)","summary":"Changes the name of a group.","parameters":[{"name":"groupIndex","summary":"The index of the group."},{"name":"newName","summary":"The new group name."}],"returns":"True if successful, False otherwise."},{"signature":"bool Delete(Group item)","since":"6.0"},{"signature":"bool Delete(int groupIndex)","summary":"Deletes a group from this table.  \\nDeleted groups are kept in the runtime group table so that undo will work with groups. Call IsDeleted() to determine if a group is deleted.","since":"5.0","parameters":[{"name":"groupIndex","summary":"An group index to be deleted."}],"returns":"True if the operation was successful."},{"signature":"int Find(string groupName)","summary":"Finds a group with a given name.","since":"6.0","parameters":[{"name":"groupName","summary":"Name of group to search for. Ignores case."}],"returns":">=0 index of the group with the given name.  RhinoMath.UnsetIntIndexno group found with the given name."},{"signature":"int Find(string groupName, bool ignoreDeletedGroups)","summary":"Finds a group with a given name.","since":"5.0","deprecated":"6.0","parameters":[{"name":"groupName","summary":"Name of group to search for. Ignores case."},{"name":"ignoreDeletedGroups","summary":"This parameter is ignored. Deleted groups are never searched."}],"returns":">=0 index of the group with the given name. -1 no group found with the given name."},{"signature":"Group FindIndex(int index)","summary":"Retrieves a Group object based on Index. This search type of search is discouraged. We are moving towards using only IDs for all tables.","since":"6.0","parameters":[{"name":"index","summary":"The index to search for."}],"returns":"A Group object, or None if none was found."},{"signature":"Group FindName(string name)","summary":"Finds a group given its name. Returns the instance, rather than the index.","since":"6.0","parameters":[{"name":"name","summary":"The name of the group to be searched."}],"returns":"An group, or None on error."},{"signature":"Group FindNameHash(NameHash nameHash)","summary":"Finds a group given its name hash.","since":"6.0","parameters":[{"name":"nameHash","summary":"The name hash of the group to be searched."}],"returns":"An group, or None on error."},{"signature":"RhinoObject[] GroupMembers(int groupIndex)","summary":"Gets an array of all of the objects in a group.","since":"5.0","parameters":[{"name":"groupIndex","summary":"The index of the group in this table."}],"returns":"An array with all the objects in the specified group."},{"signature":"string GroupName(int groupIndex)","summary":"Returns the name of a group.","since":"5.0","parameters":[{"name":"groupIndex","summary":"The index of the group."}],"returns":"The group name."},{"signature":"string[] GroupNames(bool ignoreDeletedGroups)","summary":"Returns an array of all group names.","since":"5.0","parameters":[{"name":"ignoreDeletedGroups","summary":"Ignore any groups that were deleted."}],"returns":"An array if group names if succesful, None if there are no groups."},{"signature":"int GroupObjectCount(int groupIndex)","summary":"Returns the number of objects that are members of a group.","since":"5.0","parameters":[{"name":"groupIndex","summary":"The index of the group."}],"returns":"The nnumber of objects that are members of the group."},{"signature":"int Hide(int groupIndex)","summary":"Hides all objects that are members of a group.","since":"5.0","parameters":[{"name":"groupIndex","summary":"The index of the group."}],"returns":"The number of objects that were hidden."},{"signature":"bool IsDeleted(int groupIndex)","summary":"Verifies a group is deleted.","parameters":[{"name":"groupIndex","summary":"The index of the group."}],"returns":"True if the group is deleted, False otherwise."},{"signature":"int Lock(int groupIndex)","summary":"Locks all objects that are members of a group.","since":"5.0","parameters":[{"name":"groupIndex","summary":"The index of the group."}],"returns":"The number of objects that were locked."},{"signature":"int Show(int groupIndex)","summary":"Shows, or unhides, all objects that are members of a group.","since":"5.0","parameters":[{"name":"groupIndex","summary":"The index of the group."}],"returns":"The number of objects that were shown."},{"signature":"bool Undelete(int groupIndex)","summary":"Undeletes a previously deleted group.","since":"5.0","parameters":[{"name":"groupIndex","summary":"The index of the group."}],"returns":"True if successful, False otherwise."},{"signature":"int Unlock(int groupIndex)","summary":"Unlocks all objects that are members of a group.","since":"5.0","parameters":[{"name":"groupIndex","summary":"The index of the group."}],"returns":"The number of objects that were unlocked."}]},{"namespace":"Rhino.DocObjects.Tables","name":"GroupTableEventArgs","dataType":"class","summary":"Contains group table event data.","baseclass":"EventArgs","properties":[{"signature":"RhinoDoc Document","summary":"The document in which the event occurred.","since":"5.0","property":["get"]},{"signature":"GroupTableEventType EventType","summary":"The event type.","since":"5.0","property":["get"]},{"signature":"int GroupIndex","summary":"The index of the Group that has changed.","since":"6.10","property":["get"]},{"signature":"Group NewState","summary":"The Group that has changed.","since":"6.10","property":["get"]},{"signature":"Group OldState","summary":"If the event is GroupTableEventType.Modified, then the old Group.","since":"6.10","property":["get"]}]},{"namespace":"Rhino.DocObjects.Tables","name":"GroupTableEventType","dataType":"enum","summary":"Defines the types of group table events.","since":"5.0","values":[{"signature":"Added = 0","summary":"A group was added."},{"signature":"Deleted = 1","summary":"A group was deleted."},{"signature":"Undeleted = 2","summary":"A group was undeleted."},{"signature":"Modified = 3","summary":"A group was modified."},{"signature":"Sorted = 4","summary":"The group table was sorted."}]},{"namespace":"Rhino.DocObjects.Tables","name":"HatchPatternTable","dataType":"class","summary":"All of the hatch pattern definitions contained in a rhino document.","baseclass":"RhinoDocCommonTable<HatchPattern>","interfaces":["ICollection<HatchPattern>"],"properties":[{"signature":"ModelComponentType ComponentType","since":"6.0","property":["get"]},{"signature":"int CurrentHatchPatternIndex","summary":"At all times, there is a \\"current\\" hatch pattern.  Unless otherwise specified, new objects are assigned to the current hatch pattern. The current hatch pattern is never locked, hidden, or deleted.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"int Add(HatchPattern pattern)","summary":"Adds a new hatch pattern with specified definition to the table.","since":"5.0","parameters":[{"name":"pattern","summary":"definition of new hatch pattern. The information in pattern is copied. If patern.Name is empty the a unique name of the form \\"HatchPattern 01\\" will be automatically created."}],"returns":">=0 index of new hatch pattern -1  not added because a hatch pattern with that name already exists or some other problem occurred."},{"signature":"bool Delete(HatchPattern item)","since":"6.0"},{"signature":"bool Delete(HatchPattern item, bool quiet)","since":"6.0"},{"signature":"int Find(string name, bool ignoreDeleted)","summary":"Finds the hatch pattern with a given name. Search ignores case.","since":"5.0","deprecated":"6.0","parameters":[{"name":"name","summary":"The name of the hatch patter to be found."},{"name":"ignoreDeleted","summary":"True means don\'t search deleted hatch patterns."}],"returns":"Index of the hatch pattern with the given name. -1 if no hatch pattern found."},{"signature":"HatchPattern FindIndex(int index)","summary":"Retrieves a HatchPattern object based on Index. This search type of search is discouraged. We are moving towards using only IDs for all tables.","since":"6.0","parameters":[{"name":"index","summary":"The index to search for."}],"returns":"A HatchPattern object, or None if none was found."},{"signature":"HatchPattern FindName(string name)","summary":"Finds the hatch pattern with a given name. Search ignores case.","since":"6.0","parameters":[{"name":"name","summary":"The name of the hatch patter to be found."}],"returns":"Hatch pattern with the given name. Null if no hatch pattern found."},{"signature":"HatchPattern FindNameHash(NameHash nameHash)","summary":"Finds a HatchPattern given its name hash.","since":"6.0","parameters":[{"name":"nameHash","summary":"The name hash of the HatchPattern to be searched."}],"returns":"An Linetype, or None on error."}]},{"namespace":"Rhino.DocObjects.Tables","name":"InstanceDefinitionTable","dataType":"class","baseclass":"RhinoDocCommonTable<InstanceDefinition>","properties":[{"signature":"int ActiveCount","summary":"Number of items in the instance definitions table, excluding deleted definitions.","since":"5.0","property":["get"]},{"signature":"ModelComponentType ComponentType","since":"6.0","property":["get"]},{"signature":"int Count","summary":"Number of items in the instance definitions table.","since":"5.0","property":["get"]},{"signature":"RhinoDoc Document","summary":"Document that owns this table.","since":"5.0","property":["get"]}],"methods":[{"signature":"int Add(string name, string description, Point3d basePoint, GeometryBase geometry, ObjectAttributes attributes)","summary":"Adds an instance definition to the instance definition table.","since":"5.0","parameters":[{"name":"name","summary":"The definition name."},{"name":"description","summary":"The definition description."},{"name":"basePoint","summary":"A base point."},{"name":"geometry","summary":"An element."},{"name":"attributes","summary":"An attribute."}],"returns":">=0  index of instance definition in the instance definition table. -1 on failure."},{"signature":"int Add(string name, string description, Point3d basePoint, IEnumerable<GeometryBase> geometry)","summary":"Adds an instance definition to the instance definition table.","since":"5.0","parameters":[{"name":"name","summary":"The definition name."},{"name":"description","summary":"The definition description."},{"name":"basePoint","summary":"A base point."},{"name":"geometry","summary":"An array, a list or any enumerable set of geometry."}],"returns":">=0  index of instance definition in the instance definition table. -1 on failure."},{"signature":"int Add(string name, string description, Point3d basePoint, IEnumerable<GeometryBase> geometry, IEnumerable<ObjectAttributes> attributes)","summary":"Adds an instance definition to the instance definition table.","since":"5.0","parameters":[{"name":"name","summary":"The definition name."},{"name":"description","summary":"The definition description."},{"name":"basePoint","summary":"A base point."},{"name":"geometry","summary":"An array, a list or any enumerable set of geometry."},{"name":"attributes","summary":"An array, a list or any enumerable set of attributes."}],"returns":">=0  index of instance definition in the instance definition table. -1 on failure."},{"signature":"int Add(string name, string description, string url, string urlTag, Point3d basePoint, IEnumerable<GeometryBase> geometry, IEnumerable<ObjectAttributes> attributes)","summary":"Adds an instance definition to the instance definition table.","since":"7.0","parameters":[{"name":"name","summary":"The definition name."},{"name":"description","summary":"The definition description."},{"name":"url","summary":"A URL or hyperlink."},{"name":"urlTag","summary":"A description of the URL or hyperlink."},{"name":"basePoint","summary":"A base point."},{"name":"geometry","summary":"An array, a list or any enumerable set of geometry."},{"name":"attributes","summary":"An array, a list or any enumerable set of attributes."}],"returns":">=0  index of instance definition in the instance definition table. -1 on failure."},{"signature":"void Compact(bool ignoreUndoReferences)","summary":"Purge deleted instance definition information that is not in use. This function is time consuming and should be used in a thoughtful manner.","since":"5.9","parameters":[{"name":"ignoreUndoReferences","summary":"If false, then deleted instance definition information that could possibly be undeleted by the Undo command will not be deleted. If true, then all deleted instance definition information is deleted."}]},{"signature":"bool Delete(InstanceDefinition item)","summary":"Deletes the instance definition. This deletes all references too.","since":"6.0","parameters":[{"name":"item","summary":"The item to delete."}],"returns":"True on success."},{"signature":"bool Delete(int idefIndex, bool deleteReferences, bool quiet)","summary":"Deletes the instance definition.","since":"5.0","parameters":[{"name":"idefIndex","summary":"zero based index of instance definition to delete. This must be in the range 0 <= idefIndex < InstanceDefinitionTable.Count."},{"name":"deleteReferences","summary":"True to delete all references to this definition. False to delete definition only if there are no references."},{"name":"quiet","summary":"If true, no warning message box appears if an instance definition cannot be deleted because it is the current layer or it contains active geometry."}],"returns":"True if successful. False if the instance definition has active references and bDeleteReferences is false."},{"signature":"bool DestroySourceArchive(InstanceDefinition definition, bool quiet)","summary":"Destroys all source archive information. Specifically: * InstanceDefinition.SourceArchiveis set to the empty string. * SourceRelativePath is set to false * The alternative source archive path is set to the empty string. * Checksum.Zero() is used to private destroy all checksum information. * InstanceDefinition.UpdateTypeis set to InstanceDefinitionUpdateType.Static.","since":"6.0","parameters":[{"name":"definition","summary":"The instance definition to be modified."},{"name":"quiet","summary":"If true, then message boxes about erroneous parameters will not be shown."}],"returns":"Returns True if the definition was successfully modified otherwise returns false."},{"signature":"InstanceDefinition Find(Guid instanceId, bool ignoreDeletedInstanceDefinitions)","summary":"Finds the instance definition with a given id.","since":"5.0","parameters":[{"name":"instanceId","summary":"Unique id of the instance definition to search for."},{"name":"ignoreDeletedInstanceDefinitions","summary":"True means don\'t search deleted instance definitions."}],"returns":"The specified instance definition, or None if nothing matching was found."},{"signature":"InstanceDefinition Find(string instanceDefinitionName)","summary":"Finds the instance definition with a given name.","since":"6.0","parameters":[{"name":"instanceDefinitionName","summary":"name of instance definition to search for (ignores case)"}],"returns":"The specified instance definition, or None if nothing matching was found."},{"signature":"InstanceDefinition Find(string instanceDefinitionName, bool ignoreDeletedInstanceDefinitions)","summary":"Finds the instance definition with a given name.","since":"5.0","deprecated":"6.0","parameters":[{"name":"instanceDefinitionName","summary":"name of instance definition to search for (ignores case)"},{"name":"ignoreDeletedInstanceDefinitions","summary":"True means don\'t search deleted instance definitions."}],"returns":"The specified instance definition, or None if nothing matching was found."},{"signature":"IEnumerator<InstanceDefinition> GetEnumerator()","since":"5.0"},{"signature":"InstanceDefinition[] GetList(bool ignoreDeleted)","summary":"Gets an array of instance definitions.","since":"5.0","parameters":[{"name":"ignoreDeleted","summary":"If True then deleted instance definitions are filtered out."}],"returns":"An array of instance definitions. This can be empty, but not null."},{"signature":"string GetUnusedInstanceDefinitionName()","summary":"Gets unused instance definition name used as default when creating new instance definitions.","since":"5.0","returns":"An unused instance definition name string."},{"signature":"string GetUnusedInstanceDefinitionName(string root)","summary":"Gets unused instance definition name used as default when creating new instance definitions.","since":"5.0","parameters":[{"name":"root","summary":"The returned name is \'root nn\'  If root is empty, then \'Block\' (localized) is used."}],"returns":"An unused instance definition name string."},{"signature":"string GetUnusedInstanceDefinitionName(string root, uint defaultSuffix)","summary":"Gets unused instance definition name used as default when creating new instance definitions.","since":"5.0","deprecated":"6.0","parameters":[{"name":"root","summary":"The returned name is \'root nn\'  If root is empty, then \'Block\' (localized) is used."},{"name":"defaultSuffix","summary":"Unique names are created by appending a decimal number to the localized term for \\"Block\\" as in \\"Block 01\\", \\"Block 02\\", and so on.  When defaultSuffix is supplied, the search for an unused name begins at \\"Block suffix\\"."}],"returns":"An unused instance definition name string."},{"signature":"int InstanceDefinitionIndex(Guid instanceId, bool ignoreDeletedInstanceDefinitions)","summary":"Get the index of the instance definition with a given id.","since":"6.0","parameters":[{"name":"instanceId","summary":"Unique id of the instance definition to search for"},{"name":"ignoreDeletedInstanceDefinitions","summary":"True means don\'t search deleted instance definitions."}],"returns":"index > -1 if instance definition was found."},{"signature":"bool MakeSourcePathRelative(InstanceDefinition idef, bool relative, bool quiet)","summary":"Obsolete method that always returns false. Marks the source path for a linked instance definition as relative or absolute.","since":"5.0","deprecated":"6.0","parameters":[{"name":"idef","summary":"The instance definition to be marked."},{"name":"relative","summary":"If true, the path should be considered as relative.  \\nIf false, the path should be considered as absolute."},{"name":"quiet","summary":"If true, then message boxes about erroneous parameters will not be shown."}],"returns":"True if the instance definition could be modified."},{"signature":"bool Modify(InstanceDefinition idef, string newName, string newDescription, bool quiet)","summary":"Modifies the instance definition name and description. Does not change instance definition ID or geometry.","since":"5.0","parameters":[{"name":"idef","summary":"The instance definition to be modified."},{"name":"newName","summary":"The new name."},{"name":"newDescription","summary":"The new description string."},{"name":"quiet","summary":"If true, information message boxes pop up when illegal changes are attempted."}],"returns":"True if successful."},{"signature":"bool Modify(int idefIndex, string newName, string newDescription, bool quiet)","summary":"Modifies the instance definition name and description. Does not change instance definition ID or geometry.","since":"5.0","parameters":[{"name":"idefIndex","summary":"The index of the instance definition to be modified."},{"name":"newName","summary":"The new name."},{"name":"newDescription","summary":"The new description string."},{"name":"quiet","summary":"If true, information message boxes pop up when illegal changes are attempted."}],"returns":"True if successful."},{"signature":"bool ModifyGeometry(int idefIndex, GeometryBase newGeometry, ObjectAttributes newAttributes)","since":"5.0"},{"signature":"bool ModifyGeometry(int idefIndex, IEnumerable<GeometryBase> newGeometry)","since":"5.0"},{"signature":"bool ModifyGeometry(int idefIndex, IEnumerable<GeometryBase> newGeometry, IEnumerable<ObjectAttributes> newAttributes)","summary":"Modifies the instance definition geometry and replaces all references to the current definition with references to the new definition.","since":"5.0","parameters":[{"name":"idefIndex","summary":"The index of the instance definition to be modified."},{"name":"newGeometry","summary":"The new geometry."},{"name":"newAttributes","summary":"The new attributes."}],"returns":"True if operation succeeded."},{"signature":"bool ModifySourceArchive(int idefIndex, FileReference sourceArchive, InstanceDefinitionUpdateType updateType, bool quiet)","summary":"If the instance definition is linked or embedded, use SetSource to specify the source archive.","since":"6.0","parameters":[{"name":"idefIndex","summary":"The index of the instance definition to be modified."},{"name":"sourceArchive","summary":"The new source archive file name."},{"name":"updateType","summary":""},{"name":"quiet","summary":"If true, then message boxes about erroneous parameters will not be shown."}],"returns":"Returns True if the definition was successfully modified otherwise returns false."},{"signature":"bool ModifySourceArchive(int idefIndex, string sourceArchive, InstanceDefinitionUpdateType updateType, bool quiet)","summary":"If the instance definition is linked or embedded, use SetSource to specify the source archive.","since":"6.0","deprecated":"6.0","parameters":[{"name":"idefIndex","summary":"The index of the instance definition to be modified."},{"name":"sourceArchive","summary":"The new source archive file name."},{"name":"updateType","summary":""},{"name":"quiet","summary":"If true, then message boxes about erroneous parameters will not be shown."}],"returns":"Returns True if the definition was successfully modified otherwise returns false."},{"signature":"bool Purge(int idefIndex)","summary":"Purges an instance definition and its definition geometry.","since":"5.9","parameters":[{"name":"idefIndex","summary":"zero based index of instance definition to delete. This must be in the range 0 <= idefIndex < InstanceDefinitionTable.Count."}],"returns":"True if successful. False if the instance definition cannot be purged because it is in use by reference objects or undo information."},{"signature":"bool RefreshLinkedBlock(InstanceDefinition definition)","summary":"Reload linked block definitions and update the Rhino display.","since":"6.0","parameters":[{"name":"definition","summary":"Instance definition to reload."}],"returns":"Returns True if the linked file was successfully read and updated."},{"signature":"bool Undelete(int idefIndex)","summary":"Undeletes an instance definition that has been deleted by Delete()","since":"5.9","parameters":[{"name":"idefIndex","summary":"zero based index of instance definition to delete. This must be in the range 0 <= idefIndex < InstanceDefinitionTable.Count."}],"returns":"True if successful"},{"signature":"bool UndoModify(int idefIndex)","summary":"Restores the instance definition to its previous state, if the instance definition has been modified and the modification can be undone.","since":"5.0","parameters":[{"name":"idefIndex","summary":"The index of the instance definition to be restored."}],"returns":"True if operation succeeded."},{"signature":"bool UpdateLinkedInstanceDefinition(int idefIndex, string filename, bool updateNestedLinks, bool quiet)","summary":"Read the objects from a file and use them as the instance\'s definition geometry.","since":"5.9","parameters":[{"name":"idefIndex","summary":"zero based index of instance definition to delete. This must be in the range 0 <= idefIndex < InstanceDefinitionTable.Count."},{"name":"filename","summary":"name of file (can be any type of file that Rhino or a plug-in can read)"},{"name":"updateNestedLinks","summary":"If True and the instance definition references to a linked instance definition, that needs to be updated, then the nested definition is also updated. If false, nested updates are skipped."},{"name":"quiet","summary":""}]}]},{"namespace":"Rhino.DocObjects.Tables","name":"InstanceDefinitionTableEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"RhinoDoc Document","since":"5.3","property":["get"]},{"signature":"InstanceDefinitionTableEventType EventType","since":"5.3","property":["get"]},{"signature":"int InstanceDefinitionIndex","since":"5.3","property":["get"]},{"signature":"InstanceDefinition NewState","since":"5.3","property":["get"]},{"signature":"InstanceDefinitionGeometry OldState","since":"5.3","property":["get"]}]},{"namespace":"Rhino.DocObjects.Tables","name":"InstanceDefinitionTableEventType","dataType":"enum","since":"5.3","values":[{"signature":"Added = 0"},{"signature":"Deleted = 1"},{"signature":"Undeleted = 2"},{"signature":"Modified = 3"},{"signature":"Sorted = 4","summary":"InstanceDefinitionTable.Sort() potentially changed sort order."}]},{"namespace":"Rhino.DocObjects.Tables","name":"LayerTable","dataType":"class","baseclass":"RhinoDocCommonTable<Layer>","interfaces":["ICollection<Layer>"],"properties":[{"signature":"int ActiveCount","summary":"Returns number of layers in the layer table, excluding deleted layers.","since":"5.0","property":["get"]},{"signature":"ModelComponentType ComponentType","since":"6.0","property":["get"]},{"signature":"int Count","summary":"Returns number of layers in the layer table, including deleted layers.","since":"5.0","property":["get"]},{"signature":"Layer CurrentLayer","summary":"At all times, there is a \\"current\\" layer. Unless otherwise specified, new objects are assigned to the current layer. The current layer is never locked, hidden, or deleted.  Returns reference to the current layer. Note that this reference may become invalid after a call to AddLayer().","since":"5.0","property":["get"]},{"signature":"int CurrentLayerIndex","summary":"At all times, there is a \\"current\\" layer.  Unless otherwise specified, new objects are assigned to the current layer. The current layer is never locked, hidden, or deleted. Returns: Zero based layer table index of the current layer.","since":"5.0","property":["get"]},{"signature":"RhinoDoc Document","summary":"Document that owns this table.","since":"5.0","property":["get"]}],"methods":[{"signature":"int Add()","summary":"Adds a new layer with default definition to the layer table.","since":"5.0","returns":"index of new layer."},{"signature":"int Add(Layer layer)","summary":"Adds a new layer with specified definition to the layer table.","since":"5.0","parameters":[{"name":"layer","summary":"definition of new layer. The information in layer is copied. If layer.Name is empty the a unique name of the form \\"Layer 01\\" will be automatically created."}],"returns":">=0 index of new layer -1  layer not added because a layer with that name already exists."},{"signature":"int Add(string layerName, Color layerColor)","summary":"Adds a new layer with specified definition to the layer table.","since":"5.0","parameters":[{"name":"layerName","summary":"Name for new layer. Cannot be a None or zero-length string."},{"name":"layerColor","summary":"Color of new layer. Alpha components will be ignored."}],"returns":">=0 index of new layer -1  layer not added because a layer with that name already exists."},{"signature":"int AddReferenceLayer()","summary":"Adds a new reference layer with default definition to the layer table. Reference layers are not saved in files.","since":"5.0","returns":"index of new layer."},{"signature":"int AddReferenceLayer(Layer layer)","summary":"Adds a new reference layer with specified definition to the layer table Reference layers are not saved in files.","since":"5.0","parameters":[{"name":"layer","summary":"definition of new layer. The information in layer is copied. If layer.Name is empty the a unique name of the form \\"Layer 01\\" will be automatically created."}],"returns":">=0 index of new layer -1  layer not added because a layer with that name already exists."},{"signature":"bool Delete(Guid layerId, bool quiet)","summary":"Deletes layer.","since":"6.0","parameters":[{"name":"layerId","summary":"Id of the layer to be deleted."},{"name":"quiet","summary":"If true, no warning message box appears if a layer the layer cannot be deleted because it is the current layer or it contains active geometry."}],"returns":"True if successful. False if layerIndex is out of range or the layer cannot be deleted because it is the current layer or because it layer contains active geometry."},{"signature":"bool Delete(int layerIndex, bool quiet)","summary":"Deletes layer.","since":"5.0","parameters":[{"name":"layerIndex","summary":"zero based index of layer to delete. This must be in the range 0 <= layerIndex < LayerTable.Count."},{"name":"quiet","summary":"If true, no warning message box appears if a layer the layer cannot be deleted because it is the current layer or it contains active geometry."}],"returns":"True if successful. False if layerIndex is out of range or the layer cannot be deleted because it is the current layer or because it layer contains active geometry."},{"signature":"bool Delete(Layer layer)","summary":"Deletes layer.","since":"6.0","parameters":[{"name":"layer","summary":"Layer to be deleted."}],"returns":"True if successful. False if layerIndex is out of range or the layer cannot be deleted because it is the current layer or because it layer contains active geometry."},{"signature":"bool Delete(Layer layer, bool quiet)","summary":"Deletes layer.","since":"6.0","parameters":[{"name":"layer","summary":"Layer to be deleted."},{"name":"quiet","summary":"If true, no warning message box appears if a layer the layer cannot be deleted because it is the current layer or it contains active geometry."}],"returns":"True if successful. False if layerIndex is out of range or the layer cannot be deleted because it is the current layer or because it layer contains active geometry."},{"signature":"int[] Duplicate(IEnumerable<int> layerIndices, bool duplicateObjects, bool duplicateSublayers)","summary":"Duplicates, or copies, one or more layers. Duplicated layers are added to the document.","since":"6.18","parameters":[{"name":"layerIndices","summary":"The indices of layers to duplicate."},{"name":"duplicateObjects","summary":"If true, then layer objects will also be duplicated and added to the document."},{"name":"duplicateSublayers","summary":"If true, then all sub-layers of the layer will be duplicated."}],"returns":"The indices of the newly added layers if successful, an empty array on failure."},{"signature":"int[] Duplicate(int layerIndex, bool duplicateObjects, bool duplicateSublayers)","summary":"Duplicates, or copies, a layer. Duplicated layers are added to the document.","since":"6.18","parameters":[{"name":"layerIndex","summary":"The index of the layer to duplicate."},{"name":"duplicateObjects","summary":"If true, then layer objects will also be duplicated and added to the document."},{"name":"duplicateSublayers","summary":"If true, then all sub-layers of the layer will be duplicated."}],"returns":"The indices of the newly added layers if successful, an empty array on failure."},{"signature":"int Find(Guid layerId, bool ignoreDeletedLayers)","summary":"Finds a layer with a matching ID.","since":"5.0","deprecated":"6.0","parameters":[{"name":"layerId","summary":"A valid layer ID."},{"name":"ignoreDeletedLayers","summary":"If true, deleted layers are not checked."}],"returns":">=0 index of the layer with the given name -1  no layer has the given name."},{"signature":"int Find(Guid layerId, bool ignoreDeletedLayers, int notFoundReturnValue)","summary":"Finds a layer with a matching ID.","since":"6.0","parameters":[{"name":"layerId","summary":"A valid layer ID."},{"name":"ignoreDeletedLayers","summary":"If true, deleted layers are not checked."},{"name":"notFoundReturnValue","summary":"Should be -1 to get the index of the OpenNURBS default layer, or RhinoMath.UnsetIntIndexto get an always-out-of-bound value."}],"returns":"The index of the found layer, or notFoundReturnValue."},{"signature":"int Find(Guid parentId, string layerName, bool ignoreDeletedLayers)","summary":"Finds a layer with a given name and matching parent ID.","since":"6.0","deprecated":"6.0","parameters":[{"name":"parentId","summary":"A valid layer ID."},{"name":"layerName","summary":"name of layer to search for. The search ignores case."},{"name":"ignoreDeletedLayers","summary":"If true, deleted layers are not checked. NOT SUPPORTED FOR NAME SEARCH, only for Guids."}],"returns":">=0 index of the layer with the given name -1  no layer has the given name."},{"signature":"int Find(Guid parentId, string layerName, int notFoundReturnValue)","summary":"Finds a layer with a given name and matching parent ID.","since":"6.0","parameters":[{"name":"parentId","summary":"A valid layer ID."},{"name":"layerName","summary":"name of layer to search for. The search ignores case."},{"name":"notFoundReturnValue","summary":"Should be -1 to get the index of the OpenNURBS default layer, or RhinoMath.UnsetIntIndexto get an always-out-of-bound value."}],"returns":"The index of the found layer, or notFoundReturnValue."},{"signature":"int Find(string layerName, bool ignoreDeletedLayers)","summary":"Finds the layer with a given name. If multiple layers exist that have the same name, the first match layer index will be returned.  \\nDeleted layers have no name.","since":"5.0","deprecated":"6.0","parameters":[{"name":"layerName","summary":"name of layer to search for. The search ignores case."},{"name":"ignoreDeletedLayers","summary":"True means don\'t search deleted layers."}],"returns":"index of the layer with the given name. If no layer is found, the index of the default layer, -1, is returned."},{"signature":"int FindByFullPath(string layerPath, bool ignoreDeletedLayers)","since":"5.0","deprecated":"6.0"},{"signature":"int FindByFullPath(string layerPath, int notFoundReturnValue)","summary":"Searches for a layer using the fully qualified name, that includes ancestors.  \\nDeleted layers have no name.","since":"6.0","parameters":[{"name":"layerPath","summary":"The full layer name."},{"name":"notFoundReturnValue","summary":"Should be -1 to get the index of the OpenNURBS default layer, or RhinoMath.UnsetIntIndexto get an always-out-of-bound value."}],"returns":"The index of the found layer, or notFoundReturnValue."},{"signature":"Layer FindIndex(int index)","summary":"Retrieves a Layer object based on Index. This search type of search is discouraged. We are moving towards using only IDs for all tables.","since":"6.0","parameters":[{"name":"index","summary":"The index to search for."}],"returns":"A Layer object, or None if none was found."},{"signature":"Layer FindName(string layerName)","summary":"Finds the layer with a given name. If multiple layers exist that have the same name, the first match layer index will be returned.  \\nDeleted layers have no name.  \\nThe default layer is NOT included in the search. If required, use the overload with startIndex input.","since":"6.0","parameters":[{"name":"layerName","summary":"name of layer to search for. The search ignores case."}],"returns":"A layer, or null."},{"signature":"Layer FindName(string layerName, int startIndex)","summary":"Finds the next layer that has an index equal or higher than the searched value.  \\nSearch in case-insensitive.","since":"6.0","parameters":[{"name":"layerName","summary":"The layer to search for."},{"name":"startIndex","summary":"If you specify RhinoMath.UnsetIntIndex, then also default layers will be included. This is the first index that will be tested."}],"returns":"A layer, or null."},{"signature":"Layer FindNameHash(NameHash nameHash)","summary":"Finds a Layer given its name hash.","since":"6.0","parameters":[{"name":"nameHash","summary":"The name hash of the Layer to be searched."}],"returns":"An Layer, or None on error."},{"signature":"Layer FindNext(int index, string layerName)","summary":"Use FindName(name, index).","since":"6.0","parameters":[{"name":"index","summary":"Do not use."},{"name":"layerName","summary":"Do not use."}],"returns":"Do not use."},{"signature":"int FindNext(int index, string layerName, bool ignoreDeletedLayers)","since":"5.0","deprecated":"6.0"},{"signature":"bool ForceLayerVisible(Guid layerId)","summary":"Makes a layer and all of its parent layers visible.","since":"5.0","parameters":[{"name":"layerId","summary":"The layer ID to be made visible."}],"returns":"True if the operation succeeded."},{"signature":"bool ForceLayerVisible(int layerIndex)","summary":"Makes a layer and all of its parent layers visible.","since":"5.0","parameters":[{"name":"layerIndex","summary":"The layer index to be made visible."}],"returns":"True if the operation succeeded."},{"signature":"IEnumerator<Layer> GetEnumerator()","since":"5.0"},{"signature":"bool GetSelected(out List<int> layerIndices)","summary":"Returns the indices of layers that are selected on the Layer user interface.","parameters":[{"name":"layerIndices","summary":"The indices of selected layers."}],"returns":"True if the layer user interface is visible, False otherwise."},{"signature":"string GetUnusedLayerName()","summary":"Gets the next unused layer name used as default when creating new layers.","since":"6.0","returns":"An unused layer name string."},{"signature":"string GetUnusedLayerName(bool ignoreDeleted)","summary":"Gets the next unused layer name used as default when creating new layers.","since":"5.0","deprecated":"6.0","parameters":[{"name":"ignoreDeleted","summary":"If this is True then Rhino may use a name used by a deleted layer."}],"returns":"An unused layer name string."},{"signature":"bool Modify(Layer newSettings, Guid layerId, bool quiet)","summary":"Modifies layer settings.","since":"6.0","parameters":[{"name":"newSettings","summary":"This information is copied."},{"name":"layerId","summary":"Id of layer."},{"name":"quiet","summary":"if false, information message boxes pop up when illegal changes are attempted."}],"returns":"True if successful. False if layerIndex is out of range or the settings attempt to lock or hide the current layer."},{"signature":"bool Modify(Layer newSettings, int layerIndex, bool quiet)","summary":"Modifies layer settings.","since":"5.0","parameters":[{"name":"newSettings","summary":"This information is copied."},{"name":"layerIndex","summary":"zero based index of layer to set.  This must be in the range 0 <= layerIndex < LayerTable.Count."},{"name":"quiet","summary":"if false, information message boxes pop up when illegal changes are attempted."}],"returns":"True if successful. False if layerIndex is out of range or the settings attempt to lock or hide the current layer."},{"signature":"bool Purge(Guid layerId, bool quiet)","summary":"Deletes a layer and all geometry objects on a layer.","since":"6.0","parameters":[{"name":"layerId","summary":"Id of the layer to purge."},{"name":"quiet","summary":"If true, no warning message box appears if a layer the layer cannot be deleted because it is the current layer."}],"returns":"True if successful. False if layerIndex is out of range or the layer cannot be deleted because it is the current layer."},{"signature":"bool Purge(int layerIndex, bool quiet)","summary":"Deletes a layer and all geometry objects on a layer","since":"5.5","parameters":[{"name":"layerIndex","summary":"zero based index of layer to delete. This must be in the range 0 <= layerIndex < LayerTable.Count."},{"name":"quiet","summary":"If true, no warning message box appears if a layer the layer cannot be deleted because it is the current layer."}],"returns":"True if successful. False if layerIndex is out of range or the layer cannot be deleted because it is the current layer."},{"signature":"bool Select(IEnumerable<int> layerIndices, bool bDeselect)","summary":"Selects layers in the Layer user interface.","since":"6.0","parameters":[{"name":"layerIndices","summary":"The indices of layers to select."},{"name":"bDeselect","summary":"If true, then any previously selected layers will be unselected."}],"returns":"True if the layer user interface is visible, False otherwise."},{"signature":"bool SetCurrentLayerIndex(int layerIndex, bool quiet)","summary":"At all times, there is a \\"current\\" layer. Unless otherwise specified, new objects are assigned to the current layer. The current layer is never locked, hidden, or deleted.","since":"5.0","parameters":[{"name":"layerIndex","summary":"Value for new current layer. 0 <= layerIndex < LayerTable.Count. The layer\'s mode is automatically set to NormalMode."},{"name":"quiet","summary":"if true, then no warning message box pops up if the current layer request can\'t be satisfied."}],"returns":"True if current layer index successfully set."},{"signature":"bool Undelete(int layerIndex)","summary":"Undeletes a layer that has been deleted by DeleteLayer().","since":"5.0","parameters":[{"name":"layerIndex","summary":"zero based index of layer to undelete. This must be in the range 0 <= layerIndex < LayerTable.Count."}],"returns":"True if successful."},{"signature":"bool UndoModify(Guid layerId)","summary":"Restores the layer to its previous state, if the layer has been modified and the modification can be undone.","since":"6.0","parameters":[{"name":"layerId","summary":"The layer Id to be used."}],"returns":"True if this layer had been modified and the modifications were undone."},{"signature":"bool UndoModify(Guid layerId, uint undoRecordSerialNumber)","summary":"Restores the layer to its previous state, if the layer has been modified and the modification can be undone.","since":"6.0","parameters":[{"name":"layerId","summary":"The layer Id to be used."},{"name":"undoRecordSerialNumber","summary":"The undo record serial number. Pass 0 not to specify one."}],"returns":"True if this layer had been modified and the modifications were undone."},{"signature":"bool UndoModify(int layerIndex)","summary":"Restores the layer to its previous state, if the layer has been modified and the modification can be undone.","since":"5.0","parameters":[{"name":"layerIndex","summary":"The layer index to be used."}],"returns":"True if this layer had been modified and the modifications were undone."},{"signature":"bool UndoModify(int layerIndex, uint undoRecordSerialNumber)","summary":"Restores the layer to its previous state, if the layer has been modified and the modification can be undone.","since":"5.0","parameters":[{"name":"layerIndex","summary":"The layer index to be used."},{"name":"undoRecordSerialNumber","summary":"The undo record serial number. Pass 0 not to specify one."}],"returns":"True if this layer had been modified and the modifications were undone."}]},{"namespace":"Rhino.DocObjects.Tables","name":"LayerTableEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"RhinoDoc Document","since":"5.0","property":["get"]},{"signature":"LayerTableEventType EventType","since":"5.0","property":["get"]},{"signature":"int LayerIndex","since":"5.0","property":["get"]},{"signature":"Layer NewState","since":"5.0","property":["get"]},{"signature":"Layer OldState","since":"5.0","property":["get"]}]},{"namespace":"Rhino.DocObjects.Tables","name":"LayerTableEventType","dataType":"enum","since":"5.0","values":[{"signature":"Added = 0"},{"signature":"Deleted = 1"},{"signature":"Undeleted = 2"},{"signature":"Modified = 3"},{"signature":"Sorted = 4","summary":"LayerTable.Sort() potentially changed sort order."},{"signature":"Current = 5","summary":"Current layer change."}]},{"namespace":"Rhino.DocObjects.Tables","name":"LightTable","dataType":"class","baseclass":"RhinoDocCommonTable<LightObject>","properties":[{"signature":"ModelComponentType ComponentType","since":"6.0","property":["get"]},{"signature":"int Count","summary":"Number of lights in the light table.  Does not include Sun or Skylight.","since":"5.0","property":["get"]},{"signature":"RhinoDoc Document","summary":"Document that owns this light table.","since":"5.0","property":["get"]},{"signature":"Skylight Skylight","since":"6.0","property":["get"]},{"signature":"Sun Sun","summary":"Gets the Sun instance that is applied to the document.  \\nIf the RDK is loaded, an instance is always returned.","since":"5.0","property":["get"]}],"methods":[{"signature":"int Add(Light light)","since":"5.0"},{"signature":"int Add(Light light, ObjectAttributes attributes)","since":"5.0"},{"signature":"bool Delete(int index, bool quiet)","since":"6.0"},{"signature":"bool Delete(LightObject item)","since":"6.0"},{"signature":"int Find(Guid id, bool ignoreDeleted)","since":"5.0"},{"signature":"LightObject FindIndex(int index)","summary":"Retrieves a  object based on Index. This search type of search is discouraged. We are moving towards using only IDs for all tables.","since":"6.0","parameters":[{"name":"index","summary":"The index to search for."}],"returns":"A  object, or None if none was found."},{"signature":"LightObject FindName(string name)","summary":"Finds the LightObject with a given name.  \\nDeleted lights have no name.","since":"6.0","parameters":[{"name":"name","summary":"Name to search."}],"returns":"A layer. If no layer is found, None is returned."},{"signature":"LightObject FindNameHash(NameHash nameHash)","summary":"Finds a LightObject given its name hash.","since":"6.0","parameters":[{"name":"nameHash","summary":"The name hash of the LightObject to be searched."}],"returns":"A LightObject, or None on error."},{"signature":"IEnumerator<LightObject> GetEnumerator()","since":"5.0"},{"signature":"bool Modify(Guid id, Light light)","since":"5.0"},{"signature":"bool Modify(int index, Light light)","since":"5.0"}]},{"namespace":"Rhino.DocObjects.Tables","name":"LightTableEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"RhinoDoc Document","since":"5.3","property":["get"]},{"signature":"LightTableEventType EventType","since":"5.3","property":["get"]},{"signature":"int LightIndex","since":"5.3","property":["get"]},{"signature":"LightObject NewState","since":"5.3","property":["get"]},{"signature":"Light OldState","since":"5.3","property":["get"]}]},{"namespace":"Rhino.DocObjects.Tables","name":"LightTableEventType","dataType":"enum","since":"5.3","values":[{"signature":"Added = 0"},{"signature":"Deleted = 1"},{"signature":"Undeleted = 2"},{"signature":"Modified = 3"},{"signature":"Sorted = 4","summary":"LightTable.Sort() potentially changed sort order."}]},{"namespace":"Rhino.DocObjects.Tables","name":"LinetypeTable","dataType":"class","baseclass":"RhinoDocCommonTable<Linetype>","interfaces":["ICollection<Linetype>"],"properties":[{"signature":"int ActiveCount","summary":"Returns number of linetypes in the linetypes table, excluding deleted linetypes.","since":"5.0","property":["get"]},{"signature":"string ByLayerLinetypeName","summary":"Returns the text name of the by-layer linetype.","since":"5.0","property":["get"]},{"signature":"string ByParentLinetypeName","summary":"Returns the text name of the by-parent linetype.","since":"6.0","property":["get"]},{"signature":"ModelComponentType ComponentType","since":"6.0","property":["get"]},{"signature":"string ContinuousLinetypeName","summary":"Returns the text name of the continuous linetype.","since":"5.0","property":["get"]},{"signature":"int Count","summary":"Returns number of linetypes in the linetypes table, including deleted linetypes.","since":"5.0","property":["get"]},{"signature":"Linetype CurrentLinetype","summary":"Returns reference to the current linetype. Note that this reference may become invalid after a call to AddLinetype().","since":"5.0","property":["get"]},{"signature":"int CurrentLinetypeIndex","summary":"At all times, there is a \\"current\\" linetype.  Unless otherwise specified, new objects are assigned to the current linetype. If the current linetype source is LinetypeFromLayer the object\'s layer\'s linetype is used instead.","since":"5.0","property":["get"]},{"signature":"ObjectLinetypeSource CurrentLinetypeSource","summary":"Source used by an object to determine its current linetype to be used by new objects.","since":"5.0","property":["get","set"]},{"signature":"RhinoDoc Document","summary":"Document that owns this table.","since":"5.0","property":["get"]},{"signature":"double LinetypeScale","summary":"For display in Rhino viewports, the linetypes are scaled by a single scale factor for all viewports. This is not used for printing, where all linetype patterns are scaled to print in their defined size 1:1 on the paper.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"int Add(Linetype linetype)","summary":"Adds a new linetype with specified definition to the linetype table.","since":"5.0","parameters":[{"name":"linetype","summary":"Definition of new linetype.  The information in linetype is copied. If linetype.Name is empty then a unique name of the form \\"Linetype 01\\" will be automatically created."}],"returns":"Index of newline type or -1 on error."},{"signature":"int Add(string name, IEnumerable<double> segmentLengths)","summary":"Adds a new linetype with specified definition to the linetype table.","since":"5.0","parameters":[{"name":"name","summary":"A name for the new linetype."},{"name":"segmentLengths","summary":"Positive values are dashes, negative values are gaps."}],"returns":"Index of new linetype or -1 on error."},{"signature":"int AddReferenceLinetype(Linetype linetype)","summary":"Adds a reference linetypes that will not be saved in files.","since":"5.0","parameters":[{"name":"linetype","summary":"Definition of new linetype.  The information in linetype is copied. If linetype.Name is empty then a unique name of the form \\"Linetype 01\\" will be automatically created."}],"returns":"Index of new linetype or -1 on error."},{"signature":"bool Delete(IEnumerable<int> indices, bool quiet)","summary":"Deletes multiple linetypes.","since":"5.0","parameters":[{"name":"indices","summary":"An array, a list or any enumerable instance of linetype indices."},{"name":"quiet","summary":"If true, no warning message box appears if a linetype the linetype cannot be deleted because it is the current linetype or it contains active geometry."}],"returns":"True if operation succeeded."},{"signature":"bool Delete(int index, bool quiet)","summary":"Deletes linetype.","since":"5.0","parameters":[{"name":"index","summary":"zero based index of linetype to delete."},{"name":"quiet","summary":"If true, no warning message box appears if a linetype the linetype cannot be deleted because it is the current linetype or it contains active geometry."}],"returns":"True if successful. False if linetypeIndex is out of range or the linetype cannot be deleted because it is the current linetype or because it linetype is referenced by active geometry."},{"signature":"bool Delete(Linetype item)","since":"6.0"},{"signature":"int Find(Guid id, bool ignoreDeletedLinetypes)","summary":"Finds a linetype with a matching ID.","since":"5.0","parameters":[{"name":"id","summary":"The ID of the line type to be found."},{"name":"ignoreDeletedLinetypes","summary":"If true, deleted linetypes are not checked."}],"returns":"Zero or a positive value if the index of the linetype with the given ID is found.  \\n-1 if no linetype has the given ID."},{"signature":"int Find(string name)","summary":"Finds the linetype with a given name.","since":"6.0","parameters":[{"name":"name","summary":"search ignores case."}],"returns":">=0 index of the linetype with the given name -1  no linetype has the given name."},{"signature":"int Find(string name, bool ignoreDeletedLinetypes)","summary":"Obsolete. Use the other overload.","since":"5.0","deprecated":"6.0","parameters":[{"name":"name","summary":"search ignores case."},{"name":"ignoreDeletedLinetypes","summary":"If true, deleted linetypes are not checked."}],"returns":">=0 index of the linetype with the given name -1  no linetype has the given name."},{"signature":"Linetype FindIndex(int index)","summary":"Retrieves a Linetype object based on Index. This search type of search is discouraged. We are moving towards using only IDs for all tables.","since":"6.0","parameters":[{"name":"index","summary":"The index to search for."}],"returns":"A Linetype object, or None if none was found."},{"signature":"Linetype FindName(string name)","summary":"Finds the linetype with a given name.","since":"6.0","parameters":[{"name":"name","summary":"The name."}],"returns":"A linetype, or None if the name does not exist."},{"signature":"IEnumerator<Linetype> GetEnumerator()","since":"5.0"},{"signature":"string GetUnusedLinetypeName()","summary":"Gets unused linetype name used as default when creating new linetypes.","since":"6.0","returns":"The unused linetype name."},{"signature":"string GetUnusedLinetypeName(bool ignoreDeleted)","summary":"Obsolete. Use the other overload. Gets unused linetype name used as default when creating new linetypes.","since":"5.0","deprecated":"6.0","parameters":[{"name":"ignoreDeleted","summary":"If this is True then a name used by a deleted linetype is allowed."}],"returns":"The unused linetype name."},{"signature":"int LinetypeIndexForObject(RhinoObject rhinoObject)","summary":"Returns the effective linetype index to be used to find the linetype definition to draw an object. If an object\'s linetype source is LinetypeFromObject, the linetype index in the object\'s attributes is used. If an object\'s linetype source is LinetypeFromLayer the linetype index from the object\'s layer is used.","since":"5.0","parameters":[{"name":"rhinoObject","summary":"The Rhino object to use in the query."}],"returns":"The effective linetype index."},{"signature":"int LoadDefaultLinetypes()","summary":"Fills in the linetype table with any default linetypes not already included.","since":"6.0","returns":"The number of default linetypes added to the linetype table."},{"signature":"bool Modify(Linetype linetype, int index, bool quiet)","summary":"Modify linetype settings.","since":"5.0","parameters":[{"name":"linetype","summary":"New linetype settings. This information is copied."},{"name":"index","summary":"Zero based index of linetype to set."},{"name":"quiet","summary":"if true, information message boxes pop up when illegal changes are attempted."}],"returns":"True if successful. False if linetype_index is out of range or the settings attempt to lock or hide the current linetype."},{"signature":"bool SetCurrentLinetypeIndex(int linetypeIndex, bool quiet)","summary":"At all times, there is a \\"current\\" linetype. Unless otherwise specified, new objects are assigned to the current linetype. The current linetype is never deleted.","since":"5.0","parameters":[{"name":"linetypeIndex","summary":"Value for new current linetype. 0 <= linetypeIndex < LinetypeTable.Count."},{"name":"quiet","summary":"if true, then no warning message box pops up if the current linetype request can\'t be satisfied."}],"returns":"True if current linetype index successfully set."},{"signature":"bool Undelete(int index)","summary":"Restores a linetype that has been deleted.","since":"5.0","parameters":[{"name":"index","summary":"A linetype index to be undeleted."}],"returns":"True if successful."},{"signature":"bool UndoModify(int index)","summary":"If the linetype has been modified and the modification can be undone, then UndoModify() will restore the linetype to its previous state.","since":"5.0","parameters":[{"name":"index","summary":"Zero based index of linetype for which to undo changes."}],"returns":"True if this linetype had been modified and the modifications were undone."}]},{"namespace":"Rhino.DocObjects.Tables","name":"MaterialTable","dataType":"class","baseclass":"RhinoDocCommonTable<Material>","interfaces":["ICollection<Material>"],"properties":[{"signature":"ModelComponentType ComponentType","since":"6.0","property":["get"]},{"signature":"int CurrentMaterialIndex","summary":"At all times, there is a \\"current\\" material.  Unless otherwise specified, new objects are assigned to the current material. The current material is never locked, hidden, or deleted.","since":"5.0","property":["get","set"]},{"signature":"ObjectMaterialSource CurrentMaterialSource","summary":"Gets or sets the current material source.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"int Add()","summary":"Adds a new material to the table based on the default material.","since":"5.0","returns":"The position of the new material in the table."},{"signature":"int Add(Material material)","summary":"Adds a new material to the table based on a given material.","since":"5.0","parameters":[{"name":"material","summary":"A model of the material to be added."}],"returns":"The position of the new material in the table."},{"signature":"int Add(Material material, bool reference)","summary":"Adds a new material to the table based on a given material.","since":"5.0","parameters":[{"name":"material","summary":"A model of the material to be added."},{"name":"reference","summary":"True if this material is supposed to be a reference material. Reference materials are not saved in the file."}],"returns":"The position of the new material in the table."},{"signature":"bool Delete(Material item)","since":"6.0"},{"signature":"bool DeleteAt(int materialIndex)","summary":"Removes a material at a specific position from this material table.","since":"5.0","parameters":[{"name":"materialIndex","summary":"The position to be removed."}],"returns":"True if successful. False if materialIndex is out of range or the material cannot be deleted because it is the current material or because it material contains active geometry."},{"signature":"int Find(Guid materialId, bool ignoreDeletedMaterials)","summary":"Finds a material with a matching id.","since":"5.0","parameters":[{"name":"materialId","summary":"A material ID to be found."},{"name":"ignoreDeletedMaterials","summary":"If true, deleted materials are not checked."}],"returns":">=0 index of the material with the given name -1  no material has the given name."},{"signature":"int Find(string materialName, bool ignoreDeletedMaterials)","summary":"Finds a material with a given name.","since":"5.0","parameters":[{"name":"materialName","summary":"Name of the material to search for. The search ignores case."},{"name":"ignoreDeletedMaterials","summary":"True means don\'t search deleted materials."}],"returns":">=0 index of the material with the given name -1  no material has the given name."},{"signature":"Material FindIndex(int index)","summary":"Retrieves a Material object based on Index. This search type of search is discouraged. We are moving towards using only IDs for all tables.","since":"6.0","parameters":[{"name":"index","summary":"The index to search for."}],"returns":"A Material object, or None if none was found."},{"signature":"bool Modify(Material newSettings, int materialIndex, bool quiet)","summary":"Modify material settings.","since":"5.0","parameters":[{"name":"newSettings","summary":"This information is copied."},{"name":"materialIndex","summary":"zero based index of material to set.  This must be in the range 0 <= layerIndex < MaterialTable.Count."},{"name":"quiet","summary":"if true, information message boxes pop up when illegal changes are attempted."}],"returns":"True if successful. False if materialIndex is out of range or the settings attempt to lock or hide the current material."},{"signature":"bool ResetMaterial(int materialIndex)","since":"5.0"}]},{"namespace":"Rhino.DocObjects.Tables","name":"MaterialTableEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"RhinoDoc Document","since":"5.0","property":["get"]},{"signature":"MaterialTableEventType EventType","since":"5.0","property":["get"]},{"signature":"int Index","since":"5.0","property":["get"]},{"signature":"Material OldSettings","since":"5.0","property":["get"]}]},{"namespace":"Rhino.DocObjects.Tables","name":"MaterialTableEventType","dataType":"enum","since":"5.0","values":[{"signature":"Added = 0"},{"signature":"Deleted = 1"},{"signature":"Undeleted = 2"},{"signature":"Modified = 3"},{"signature":"Sorted = 4"},{"signature":"Current = 5"}]},{"namespace":"Rhino.DocObjects.Tables","name":"ModifyType","dataType":"enum","since":"6.0","values":[{"signature":"Modify"},{"signature":"Override"},{"signature":"NotSaved"}]},{"namespace":"Rhino.DocObjects.Tables","name":"NamedConstructionPlaneTable","dataType":"class","summary":"Contains all named construction planes in a rhino document.  \\nThis class cannot be inherited.","interfaces":["IEnumerable<ConstructionPlane>","Collections.IRhinoTable<ConstructionPlane>"],"properties":[{"signature":"int Count","summary":"Number of construction planes in the table.","since":"5.0","property":["get"]},{"signature":"RhinoDoc Document","summary":"Gets the document that owns this table.","since":"5.0","property":["get"]}],"methods":[{"signature":"int Add(string name, Plane plane)","summary":"Adds named construction plane to document.","since":"5.0","parameters":[{"name":"name","summary":"If name is empty, a unique name is automatically created. If there is already a named construction plane with the same name, that construction plane is replaced."},{"name":"plane","summary":"The plane value."}],"returns":"0 based index of named construction plane. -1 on failure."},{"signature":"bool Delete(int index)","summary":"Remove named construction plane from the document.","since":"5.0","parameters":[{"name":"index","summary":"zero based array index."}],"returns":"True if successful."},{"signature":"bool Delete(string name)","summary":"Remove named construction plane from the document.","since":"5.0","parameters":[{"name":"name","summary":"name of the construction plane."}],"returns":"True if successful."},{"signature":"int Find(string name)","summary":"Finds a named construction plane.","since":"5.0","parameters":[{"name":"name","summary":"Name of construction plane to search for."}],"returns":">=0 index of the construction plane with the given name. -1 no construction plane found with the given name."},{"signature":"IEnumerator<ConstructionPlane> GetEnumerator()","since":"5.0"}]},{"namespace":"Rhino.DocObjects.Tables","name":"NamedLayerStateTable","dataType":"class","summary":"All named layer states in a Rhino document.","properties":[{"signature":"int Count","summary":"Returns the number of named layers states in the document.","since":"6.14","property":["get"]},{"signature":"RhinoDoc Document","summary":"Document that owns this table.","since":"6.14","property":["get"]},{"signature":"string[] Names","summary":"Returns the names of named layer states in the document.","since":"6.14","property":["get"]}],"methods":[{"signature":"bool Delete(string name)","summary":"Deletes an existing named layer state.","since":"6.14","parameters":[{"name":"name","summary":"The name of the layer state."}],"returns":"True if successful, False otherwise."},{"signature":"int FindName(string name)","summary":"Returns the index of an existing named layer state.","since":"6.14","parameters":[{"name":"name","summary":"The name of the layer state."}],"returns":">0 if successful, -1 if not found."},{"signature":"int Import(string filename)","summary":"Imports named layer states from a 3dm file.","since":"6.15","parameters":[{"name":"filename","summary":"The name of the file to import."}],"returns":"The number of named layers states imported."},{"signature":"bool Rename(string oldName, string newName)","summary":"Renames an existing named layer state.","since":"6.14","parameters":[{"name":"oldName","summary":"The name of the layer state."},{"name":"newName","summary":"The new name"}],"returns":"True if successful, False otherwise."},{"signature":"bool Restore(string name, RestoreLayerProperties properties)","summary":"Restores a named layer state.","since":"6.14","parameters":[{"name":"name","summary":"The name of the layer state."},{"name":"properties","summary":"The layer properties to restore."}],"returns":"True if successful, False otherwise."},{"signature":"bool Restore(string name, RestoreLayerProperties properties, Guid viewportId)","summary":"Restores a named layer state.","since":"6.14","parameters":[{"name":"name","summary":"The name of the layer state."},{"name":"properties","summary":"The layer properties to restore."},{"name":"viewportId","summary":"The id of the layout or detail viewport to restore the per-viewport layer properties."}]},{"signature":"int Save(string name)","summary":"Saves or updates a named layer state.","since":"6.14","parameters":[{"name":"name","summary":"The name of the layer state. If the named layer state already exists, it will be updated."}],"returns":"The index of the newly added, or updated, layer state."},{"signature":"int Save(string name, Guid viewportId)","summary":"Saves or updates a named layer state.","since":"6.14","parameters":[{"name":"name","summary":"The name of the layer state. If the named layer state already exists, it will be updated."},{"name":"viewportId","summary":"The id of the layout or detail viewport, required to save per viewport layer state properties."}],"returns":"The index of the newly added, or updated, layer state."}]},{"namespace":"Rhino.DocObjects.Tables","name":"NamedPositionTable","dataType":"class","summary":"All named positions in a rhino document.","properties":[{"signature":"int Count","summary":"Number of Named Positions in the table.","since":"6.0","property":["get"]},{"signature":"RhinoDoc Document","summary":"Document that owns this table.","since":"6.0","property":["get"]},{"signature":"Guid[] Ids","summary":"Array of Named Position Guids.","since":"6.0","property":["get"]},{"signature":"string[] Names","summary":"Array of Named Position names.","since":"6.0","property":["get"]}],"methods":[{"signature":"bool Append(Guid id, IEnumerable<Guid> objectIds)","summary":"Append objects to a Named Position.","since":"6.0","parameters":[{"name":"id","summary":"Guid of the Named Position which you want to append to."},{"name":"objectIds","summary":"New object ids to be included in this Named Position."}],"returns":"True or False depending on whether the Append was successful."},{"signature":"bool Append(Guid id, IEnumerable<RhinoObject> objects)","summary":"Append objects to a Named Position.","since":"6.0","parameters":[{"name":"id","summary":"Guid of the Named Position which you want to append to."},{"name":"objects","summary":"Collection of Rhino Objects to be included in this Named Position."}],"returns":"True or False depending on whether the Append was successful."},{"signature":"bool Append(string name, IEnumerable<Guid> objectIds)","summary":"Append objects to a Named Position.","since":"6.0","parameters":[{"name":"name","summary":"Name of the Named Position which you want to append to."},{"name":"objectIds","summary":"New object Guids to be included in this Named Position."}],"returns":"True or False depending on whether the Append was successful."},{"signature":"bool Append(string name, IEnumerable<RhinoObject> objects)","summary":"Append objects to a Named Position.","since":"6.0","parameters":[{"name":"name","summary":"Name of the Named Position which you want to append to."},{"name":"objects","summary":"Collection of Rhino Objects to be included in this Named Position."}],"returns":"True or False depending on whether the Append was successful."},{"signature":"bool Delete(Guid id)","summary":"Delete a Named Position.","since":"6.0","parameters":[{"name":"id","summary":"Guid of the Named Position which you want to delete."}],"returns":"True or False depending on whether the Delete was successful, Null in case the id does not exist as a Named Position."},{"signature":"bool Delete(string name)","summary":"Delete a Named Position.","since":"6.0","parameters":[{"name":"name","summary":"Name of the Named Position which you want to delete."}],"returns":"True or False depending on whether the Delete was successful, Null in case the id does not exist as a Named Position."},{"signature":"Guid Id(string name)","summary":"Guid of a Named Position.","since":"6.0","parameters":[{"name":"name","summary":"Name of the Named Position for which you want to retrieve the Guid."}],"returns":"The Guid of the Named Position.  If not found, an empty Guid is returned."},{"signature":"string Name(Guid id)","summary":"Name of a Named Position.","since":"6.0","parameters":[{"name":"id","summary":"Guid of the Named Position for which you want to retrieve the name."}],"returns":"The name of the Named Position as a string."},{"signature":"Guid[] ObjectIds(Guid id)","summary":"Array of Rhino Object Guids related to a Named Position.","since":"6.0","parameters":[{"name":"id","summary":"The Guid of the named position from which you want to retrieve the objects."}],"returns":"Array of Guid which pertain to the objects tracked by the Named Position."},{"signature":"Guid[] ObjectIds(string name)","summary":"Array of Rhino Object Guids related to a Named Position.","since":"6.0","parameters":[{"name":"name","summary":"The name of the Named Position from which you want to retrieve the objects."}],"returns":"Array of Guid which pertain to the objects tracked by the Named Position, or None in case no such Named Position is found."},{"signature":"RhinoObject[] Objects(Guid id)","summary":"Array of Rhino Objects related to a Named Position.","since":"6.0","parameters":[{"name":"id","summary":"The Guid of the named position from which you want to retrieve the objects."}],"returns":"Array of Rhino Objects which are tracked by the Named Position."},{"signature":"RhinoObject[] Objects(string name)","summary":"Array of Rhino Objects related to a Named Position.","since":"6.0","parameters":[{"name":"name","summary":"The name of the Named Position from which you want to retrieve the objects."}],"returns":"Array of Rhino Objects which are tracked by the Named Position if successful, None if no such Named Position exists."},{"signature":"bool ObjectXform(Guid id, Guid objId, ref Transform xform)","summary":"Retrieve the Transform of a Rhino Object relate to a Named Position.","since":"6.0","parameters":[{"name":"id","summary":"The Guid of the Named Position"},{"name":"objId","summary":"The Guid of the Rhino Object from which to retrieve the Transform."},{"name":"xform","summary":"The Transform to retrieve."}],"returns":"Transform of the RhinoObject related to the Named Position."},{"signature":"bool ObjectXform(Guid id, RhinoObject obj, ref Transform xform)","summary":"Retrieve the Transform of a Rhino Object relate to a Named Position.","since":"6.0","parameters":[{"name":"id","summary":"The Guid of the Named Position"},{"name":"obj","summary":"The Rhino Object from which to retrieve the Transform."},{"name":"xform","summary":"The Transform to retrieve."}],"returns":"Transform of the RhinoObject related to the Named Position."},{"signature":"bool Rename(Guid id, string name)","summary":"Rename a Named Position.","since":"6.0","parameters":[{"name":"id","summary":"Guid of the Named Position which you want to rename."},{"name":"name","summary":"New name for the Named Position."}],"returns":"True or False depending on whether the Rename was successful.  For example, this method might return False if you attempt to rename the Named Position with the currently assigned name."},{"signature":"bool Rename(string oldName, string name)","summary":"Rename a Named Position.","since":"6.0","parameters":[{"name":"oldName","summary":"Current name of the Named Position which you want to rename."},{"name":"name","summary":"New name for the Named Position."}],"returns":"True or False depending on whether the Rename was successful.  For example, this method might return False if you attempt to rename the Named Position with the currently assigned name."},{"signature":"bool Restore(Guid id)","summary":"Restore a Named Position.","since":"6.0","parameters":[{"name":"id","summary":"Guid of the Named Position to restore."}],"returns":"True or False based on whether the Named Position was able to be restored."},{"signature":"bool Restore(string name)","summary":"Restore a Named Position.","since":"6.0","parameters":[{"name":"name","summary":"Name of the Named Position to restore."}],"returns":"True or False based on whether the Named Position was able to be restored."},{"signature":"Guid Save(string name, IEnumerable<Guid> objectIds)","summary":"Save a new Named Position.","since":"6.0","parameters":[{"name":"name","summary":"Name for this Named Position."},{"name":"objectIds","summary":"Array of Rhino Object Ids which should be included in this Named Position."}],"returns":"Guid of the newly saved Named Position."},{"signature":"Guid Save(string name, IEnumerable<RhinoObject> objects)","summary":"Save a new Named Position.","since":"6.0","parameters":[{"name":"name","summary":"Name for this Named Position."},{"name":"objects","summary":"Array of Rhino Objects which should be included in this Named Position."}],"returns":"Guid of the newly saved Named Position."},{"signature":"bool Update(Guid id)","summary":"Updates a Named Position, effectively storing the current positions of the objects which the Named Position is tracking.","since":"6.0","parameters":[{"name":"id","summary":"Guid of the Named Position which you want to update."}],"returns":"True or False depending on whether the Update was successful."},{"signature":"bool Update(string name)","summary":"Updates a Named Position, effectively storing the current positions of the objects which the Named Position is tracking.","since":"6.0","parameters":[{"name":"name","summary":"Name of the Named Position which you want to update."}],"returns":"True or False depending on whether the Update was successful."}]},{"namespace":"Rhino.DocObjects.Tables","name":"NamedViewTable","dataType":"class","summary":"All named views in a rhino document.","interfaces":["IEnumerable<ViewInfo>","Collections.IRhinoTable<ViewInfo>"],"properties":[{"signature":"int Count","summary":"Number of named views in the table.","since":"5.0","property":["get"]},{"signature":"RhinoDoc Document","summary":"Document that owns this table.","since":"5.0","property":["get"]}],"methods":[{"signature":"int Add(string name, Guid viewportId)","summary":"Adds named view to document which is based on an existing viewport.","since":"5.0","parameters":[{"name":"name","summary":"If name is empty, a unique name is automatically created. If there is already a named view with the same name, that view is replaced."},{"name":"viewportId","summary":"Id of an existing viewport in the document. View information is copied from this viewport."}],"returns":"0 based index of named view. -1 on failure."},{"signature":"int Add(ViewInfo view)","since":"5.0"},{"signature":"bool Delete(int index)","summary":"Remove named view from the document.","since":"5.0","parameters":[{"name":"index","summary":"index of the named view in the named view table."}],"returns":"True if successful."},{"signature":"bool Delete(string name)","summary":"Remove named view from the document.","since":"5.0","parameters":[{"name":"name","summary":"name of the view."}],"returns":"True if successful."},{"signature":"int FindByName(string name)","summary":"Finds a named view.","since":"5.0","parameters":[{"name":"name","summary":"name to search for."}],"returns":">=0 index of the found named view -1 no named view found."},{"signature":"IEnumerator<ViewInfo> GetEnumerator()","since":"5.0"},{"signature":"bool Rename(int index, string newName)","summary":"Renames a named view.","since":"7.0","parameters":[{"name":"index","summary":"Index of the named view in the named view table."},{"name":"newName","summary":"The new name."}],"returns":"True if successful, False otherwise."},{"signature":"bool Rename(string oldName, string newName)","summary":"Renames a named view.","since":"7.0","parameters":[{"name":"oldName","summary":"The name of a named view in the named view table."},{"name":"newName","summary":"The new name."}],"returns":"True if successful, False otherwise."},{"signature":"bool Restore(int index, RhinoView view, bool backgroundBitmap)","since":"5.0","deprecated":"6.0"},{"signature":"bool Restore(int index, RhinoViewport viewport)","summary":"Sets the MainViewport of a standard RhinoView to a named views settings","since":"6.0"},{"signature":"bool Restore(int index, RhinoViewport viewport, bool backgroundBitmap)","since":"5.9","deprecated":"6.0"},{"signature":"bool RestoreAnimated(int index, RhinoView view, bool backgroundBitmap)","since":"5.0","deprecated":"6.0"},{"signature":"bool RestoreAnimated(int index, RhinoView view, bool backgroundBitmap, int frames, int frameRate)","since":"5.0","deprecated":"6.0"},{"signature":"bool RestoreAnimated(int index, RhinoViewport viewport, bool backgroundBitmap)","since":"5.9","deprecated":"6.0"},{"signature":"bool RestoreAnimated(int index, RhinoViewport viewport, bool backgroundBitmap, int frames, int frameRate)","since":"5.9","deprecated":"6.0"},{"signature":"bool RestoreAnimatedConstantSpeed(int index, RhinoViewport viewport, double units_per_frame, int ms_delay)","since":"6.0"},{"signature":"bool RestoreAnimatedConstantTime(int index, RhinoViewport viewport, int frames, int ms_delay)","since":"6.0"},{"signature":"bool RestoreWithAspectRatio(int index, RhinoViewport viewport)","since":"6.0"}]},{"namespace":"Rhino.DocObjects.Tables","name":"ObjectTable","dataType":"class","baseclass":"RhinoDocCommonTable<RhinoObject>","interfaces":["ICollection<RhinoObject>"],"properties":[{"signature":"BoundingBox BoundingBox","summary":"Gets the bounding box for all objects (normal, locked and hidden) in this document that exist in \\"model\\" space. This bounding box does not include objects that exist in layout space.","since":"5.0","property":["get"]},{"signature":"BoundingBox BoundingBoxVisible","summary":"Gets the bounding box for all visible objects (normal and locked) in this document that exist in \\"model\\" space. This bounding box does not include hidden objects or any objects that exist in layout space.","since":"5.0","property":["get"]},{"signature":"ModelComponentType ComponentType","since":"6.0","property":["get"]},{"signature":"RhinoDoc Document","summary":"Gets the document that owns this object table.","since":"5.0","property":["get"]},{"signature":"int HistoryRecordCount","summary":"Returns the amount of history records in this document.","since":"6.0","property":["get"]}],"methods":[{"signature":"Guid Add(GeometryBase geometry)","summary":"Adds geometry that is not further specified.  \\nThis is meant, for example, to handle addition of sets of different geometrical entities.","since":"5.0","parameters":[{"name":"geometry","summary":"The base geometry. This cannot be null."}],"returns":"The new object ID on success."},{"signature":"Guid Add(GeometryBase geometry, ObjectAttributes attributes)","summary":"Adds geometry that is not further specified.  \\nThis is meant, for example, to handle addition of sets of different geometrical entities.","since":"5.0","parameters":[{"name":"geometry","summary":"The base geometry. This cannot be null."},{"name":"attributes","summary":"The object attributes. This can be null."}],"returns":"The new object ID on success."},{"signature":"Guid Add(GeometryBase geometry, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds geometry that is not further specified.  \\nThis is meant, for example, to handle addition of sets of different geometrical entities.","since":"6.0","parameters":[{"name":"geometry","summary":"The base geometry. This cannot be null."},{"name":"attributes","summary":"The object attributes. This can be null."},{"name":"history","summary":"The history information that will be saved."},{"name":"reference","summary":"If reference is true, object will not be saved in the 3dm file."}],"returns":"The new object ID on success."},{"signature":"Guid AddAngularDimension(AngularDimension dimension)","summary":"Adds a angular dimension object to the document.","since":"5.0","parameters":[{"name":"dimension","summary":"Dimension object to add."}],"returns":"The Id of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddAngularDimension(AngularDimension dimension, ObjectAttributes attributes)","summary":"Adds a angular dimension object to the document.","since":"5.0","parameters":[{"name":"dimension","summary":"Dimension object to add."},{"name":"attributes","summary":""}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddAngularDimension(AngularDimension dimension, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds an angular dimension object to the document.","since":"5.0","parameters":[{"name":"dimension","summary":"Dimension object to add."},{"name":"attributes","summary":"Attributes to apply to dimension."},{"name":"history","summary":"Object history to save."},{"name":"reference","summary":"If reference, then object will not be saved into the 3dm file."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddArc(Arc arc)","summary":"Adds a curve object to the document representing an arc.","since":"5.0","parameters":[{"name":"arc","summary":"An arc value."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddArc(Arc arc, ObjectAttributes attributes)","summary":"Adds a curve object to the document representing an arc.","since":"5.0","parameters":[{"name":"arc","summary":"An arc value."},{"name":"attributes","summary":"Attributes to apply to arc."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddArc(Arc arc, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddBox(Box box)","summary":"Adds a box to the object table.","since":"6.0","parameters":[{"name":"box","summary":"The box."}],"returns":"The ID."},{"signature":"Guid AddBox(Box box, ObjectAttributes attributes)","summary":"Adds a box to the object table.","since":"6.0","parameters":[{"name":"box","summary":"The box."},{"name":"attributes","summary":"Attributes that will be linked with the surface object."}],"returns":"The ID."},{"signature":"Guid AddBox(Box box, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds a box to the object table, as an extrusion.","since":"6.0","parameters":[{"name":"box","summary":"The box."},{"name":"attributes","summary":"Attributes that will be linked with the surface object."},{"name":"history","summary":"History data records."},{"name":"reference","summary":"If a reference, object will not be saved in the document."}],"returns":"The ID."},{"signature":"Guid AddBrep(Brep brep)","summary":"Adds a brep object to Rhino.","since":"5.0","parameters":[{"name":"brep","summary":"A duplicate of this brep is added to Rhino."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddBrep(Brep brep, ObjectAttributes attributes)","summary":"Adds a brep object to Rhino.","since":"5.0","parameters":[{"name":"brep","summary":"A duplicate of this brep is added to Rhino."},{"name":"attributes","summary":"attributes to apply to brep."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddBrep(Brep brep, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddBrep(Brep brep, ObjectAttributes attributes, HistoryRecord history, bool reference, bool splitKinkySurfaces)","since":"5.0"},{"signature":"Guid AddCentermark(Centermark centermark, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds an ordinate dimension object to the document.","since":"6.0","parameters":[{"name":"centermark","summary":"Dimension object to add."},{"name":"attributes","summary":"Attributes to apply to dimension."},{"name":"history","summary":"Object history to save."},{"name":"reference","summary":"If reference, then object will not be saved into the 3dm file."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddCircle(Circle circle)","summary":"Adds a curve object to the document representing a circle.","since":"5.0","parameters":[{"name":"circle","summary":"A circle value."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddCircle(Circle circle, ObjectAttributes attributes)","summary":"Adds a curve object to the document representing a circle.","since":"5.0","parameters":[{"name":"circle","summary":"A circle value."},{"name":"attributes","summary":"Attributes to apply to circle."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddCircle(Circle circle, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddClippingPlane(Plane plane, double uMagnitude, double vMagnitude, Guid clippedViewportId)","summary":"Adds a clipping plane object to Rhino.","since":"5.0","parameters":[{"name":"plane","summary":"The plane value."},{"name":"uMagnitude","summary":"The size in the U direction."},{"name":"vMagnitude","summary":"The size in the V direction."},{"name":"clippedViewportId","summary":"Viewport ID that the new clipping plane will clip."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddClippingPlane(Plane plane, double uMagnitude, double vMagnitude, Guid clippedViewportId, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddClippingPlane(Plane plane, double uMagnitude, double vMagnitude, IEnumerable<Guid> clippedViewportIds)","summary":"Adds a clipping plane object to Rhino.","since":"5.0","parameters":[{"name":"plane","summary":"The plane value."},{"name":"uMagnitude","summary":"The size in the U direction."},{"name":"vMagnitude","summary":"The size in the V direction."},{"name":"clippedViewportIds","summary":"A list, an array or any enumerable set of viewport IDs that the new clipping plane will clip."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddClippingPlane(Plane plane, double uMagnitude, double vMagnitude, IEnumerable<Guid> clippedViewportIds, ObjectAttributes attributes)","summary":"Adds a clipping plane object to Rhino.","since":"5.0","parameters":[{"name":"plane","summary":"The plane value."},{"name":"uMagnitude","summary":"The size in the U direction."},{"name":"vMagnitude","summary":"The size in the V direction."},{"name":"clippedViewportIds","summary":"A list, an array or any enumerable set of viewport IDs that the new clipping plane will clip."},{"name":"attributes","summary":"Document attributes for the plane."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddClippingPlane(Plane plane, double uMagnitude, double vMagnitude, IEnumerable<Guid> clippedViewportIds, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddCurve(Curve curve)","summary":"Adds a curve object to Rhino.","since":"5.0","parameters":[{"name":"curve","summary":"A curve. A duplicate of this curve is added to Rhino."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddCurve(Curve curve, ObjectAttributes attributes)","summary":"Adds a curve object to Rhino.","since":"5.0","parameters":[{"name":"curve","summary":"A curve. A duplicate of this curve is added to Rhino."},{"name":"attributes","summary":"Attributes to apply to curve."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddCurve(Curve curve, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddEllipse(Ellipse ellipse)","summary":"Adds a curve object to the document representing an ellipse.","since":"5.0","parameters":[{"name":"ellipse","summary":"An ellipse value."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddEllipse(Ellipse ellipse, ObjectAttributes attributes)","summary":"Adds a curve object to the document representing an ellipse.","since":"5.0","parameters":[{"name":"ellipse","summary":"An ellipse value."},{"name":"attributes","summary":"Attributes to apply to ellipse."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddEllipse(Ellipse ellipse, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid[] AddExplodedInstancePieces(InstanceObject instance, bool explodeNestedInstances, bool deleteInstance)","since":"5.11"},{"signature":"Guid AddExtrusion(Extrusion extrusion)","summary":"Adds an extrusion object to Rhino.","since":"5.0","parameters":[{"name":"extrusion","summary":"A duplicate of this extrusion is added to Rhino."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddExtrusion(Extrusion extrusion, ObjectAttributes attributes)","summary":"Adds an extrusion object to Rhino.","since":"5.0","parameters":[{"name":"extrusion","summary":"A duplicate of this extrusion is added to Rhino."},{"name":"attributes","summary":"Attributes that will be linked with the extrusion object."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddExtrusion(Extrusion extrusion, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddHatch(Hatch hatch)","since":"5.0"},{"signature":"Guid AddHatch(Hatch hatch, ObjectAttributes attributes)","since":"5.0"},{"signature":"Guid AddHatch(Hatch hatch, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddInstanceObject(int instanceDefinitionIndex, Transform instanceXform)","summary":"Adds an instance object to the document.","since":"5.0","parameters":[{"name":"instanceDefinitionIndex","summary":"The index of the instance definition."},{"name":"instanceXform","summary":"The instance transformation."}],"returns":"A unique identifier for the object if successful. Guid.Empty it not successful."},{"signature":"Guid AddInstanceObject(int instanceDefinitionIndex, Transform instanceXform, ObjectAttributes attributes)","summary":"Adds an instance object to the document.","since":"5.0","parameters":[{"name":"instanceDefinitionIndex","summary":"The index of the instance definition."},{"name":"instanceXform","summary":"The instance transformation."},{"name":"attributes","summary":"The attributes to apply to the instance object."}],"returns":"A unique identifier for the object if successful. Guid.Empty it not successful."},{"signature":"Guid AddInstanceObject(int instanceDefinitionIndex, Transform instanceXform, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds an instance object to the document.","since":"6.24","parameters":[{"name":"instanceDefinitionIndex","summary":"The index of the instance definition."},{"name":"instanceXform","summary":"The instance transformation."},{"name":"attributes","summary":"The attributes to apply to the instance object."},{"name":"history","summary":"The history record associated with this instance object."},{"name":"reference","summary":"True if the object is from a reference file. Reference objects do not persist in archives."}],"returns":"A unique identifier for the object if successful. Guid.Empty it not successful."},{"signature":"Guid AddLeader(IEnumerable<Point3d> points)","since":"5.0"},{"signature":"Guid AddLeader(Leader leader)","summary":"Adds a Leader object to the document.","since":"6.0","parameters":[{"name":"leader","summary":"The leader object."}],"returns":"The Id of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddLeader(Leader leader, ObjectAttributes attributes)","summary":"Adds Leader object to the document.","since":"6.0","parameters":[{"name":"leader","summary":"The leader object."},{"name":"attributes","summary":"Attributes to apply to rich text."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddLeader(Leader leader, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds a Leader object to the document.","since":"6.0","parameters":[{"name":"leader","summary":"The leader object."},{"name":"attributes","summary":"Attributes to apply to rich text."},{"name":"history","summary":"Object history to save."},{"name":"reference","summary":"If reference, then object will not be saved into the 3dm file."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddLeader(Plane plane, IEnumerable<Point2d> points)","since":"5.0"},{"signature":"Guid AddLeader(Plane plane, IEnumerable<Point2d> points, ObjectAttributes attributes)","since":"5.0"},{"signature":"Guid AddLeader(string text, IEnumerable<Point3d> points)","since":"5.0"},{"signature":"Guid AddLeader(string text, Plane plane, IEnumerable<Point2d> points)","since":"5.0"},{"signature":"Guid AddLeader(string text, Plane plane, IEnumerable<Point2d> points, ObjectAttributes attributes)","since":"5.0"},{"signature":"Guid AddLeader(string text, Plane plane, IEnumerable<Point2d> points, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddLine(Line line)","summary":"Adds a line object to Rhino.","since":"5.0","returns":"A unique identifier for the object."},{"signature":"Guid AddLine(Line line, ObjectAttributes attributes)","summary":"Adds a line object to Rhino.","since":"5.0","parameters":[{"name":"line","summary":"The line value."},{"name":"attributes","summary":"Attributes to apply to line."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddLine(Point3d from, Point3d to)","summary":"Adds a line object to Rhino.","since":"5.0","parameters":[{"name":"from","summary":"The line origin."},{"name":"to","summary":"The line end."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddLine(Point3d from, Point3d to, ObjectAttributes attributes)","summary":"Adds a line object to Rhino.","since":"5.0","parameters":[{"name":"from","summary":"The line origin."},{"name":"to","summary":"The line end."},{"name":"attributes","summary":"Attributes to apply to line."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddLine(Point3d from, Point3d to, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddLinearDimension(LinearDimension dimension)","summary":"Adds a linear dimension object to the document.","since":"5.0","parameters":[{"name":"dimension","summary":"Dimension object to add."}],"returns":"The Id of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddLinearDimension(LinearDimension dimension, ObjectAttributes attributes)","summary":"Adds a linear dimension object to the document.","since":"5.0","parameters":[{"name":"dimension","summary":"Dimension object to add."},{"name":"attributes","summary":""}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddLinearDimension(LinearDimension dimension, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds a linear dimension object to the document.","since":"5.0","parameters":[{"name":"dimension","summary":"Dimension object to add."},{"name":"attributes","summary":"Attributes to apply to dimension."},{"name":"history","summary":"Object history to save."},{"name":"reference","summary":"If reference, then object will not be saved into the 3dm file."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddMesh(Mesh mesh)","summary":"Adds a mesh object to Rhino.","since":"5.0","parameters":[{"name":"mesh","summary":"A duplicate of this mesh is added to Rhino."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddMesh(Mesh mesh, ObjectAttributes attributes)","summary":"Adds a mesh object to Rhino.","since":"5.0","parameters":[{"name":"mesh","summary":"A duplicate of this mesh is added to Rhino."},{"name":"attributes","summary":"Attributes that will be linked with the mesh object."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddMesh(Mesh mesh, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddMesh(Mesh mesh, ObjectAttributes attributes, HistoryRecord history, bool reference, bool requireValidMesh)","since":"6.0"},{"signature":"Guid AddMorphControl(MorphControl morphControl)","since":"5.0"},{"signature":"Guid AddMorphControl(MorphControl morphControl, ObjectAttributes attributes)","since":"5.0"},{"signature":"Guid AddMorphControl(MorphControl morphControl, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"6.0"},{"signature":"Guid AddOrdinateDimension(OrdinateDimension dimordinate, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds an ordinate dimension object to the document.","since":"6.0","parameters":[{"name":"dimordinate","summary":"Dimension object to add."},{"name":"attributes","summary":"Attributes to apply to dimension."},{"name":"history","summary":"Object history to save."},{"name":"reference","summary":"If reference, then object will not be saved into the 3dm file."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddPictureFrame(Plane plane, string texturePath, bool asMesh, double width, double height, bool selfIllumination, bool embedBitmap)","summary":"Creates a PictureFrame object from a plane and a path to an image file, Note, a PictureFrame object is just a Plane surface or mesh that has a material with a texture assigned to it that displays in all display modes.","since":"5.10","parameters":[{"name":"plane","summary":"Plane in which the PictureFrame will be created.  Bottom left corner of picture will be at plane\'s origin, width will be in the plane\'s x axis direction, height will be in the plane\'s y axis direction."},{"name":"texturePath","summary":"path to an image file"},{"name":"asMesh","summary":"If true, the function will make a MeshObject rather than a surface"},{"name":"width","summary":"Width of the resulting PictureFrame. If 0.0, the width of the picture frame is the width of the image if height is also 0.0 or calculated from the height and aspect ratio of the image if height is not 0.0."},{"name":"height","summary":"Height of the resulting PictureFrame. If 0.0, the height of the picture frame is the height of the image if width is also 0.0 or calculated from the width and aspect ratio of the image if width is not 0.0."},{"name":"selfIllumination","summary":"If true, the image mapped to the picture frame plane always displays at full intensity and is not affected by light or shadow."},{"name":"embedBitmap","summary":"If true, the function adds the image to the bitmap table of the document to which the PictureFrame will be added"}],"returns":"A unique identifier for the object"},{"signature":"Guid AddPoint(double x, double y, double z)","summary":"Adds a point object to the document.","since":"5.0","parameters":[{"name":"x","summary":"X component of point coordinate."},{"name":"y","summary":"Y component of point coordinate."},{"name":"z","summary":"Z component of point coordinate."}],"returns":"A unique identifier for the object.."},{"signature":"Guid AddPoint(Point point, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds a point object and its geometry-linked information to the document","since":"6.0","parameters":[{"name":"point","summary":"A point geometry class."},{"name":"attributes","summary":"attributes to apply to point. None is acceptable"},{"name":"history","summary":"history associated with this point. None is acceptable"},{"name":"reference","summary":"True if the object is from a reference file.  Reference objects do not persist in archives"}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPoint(Point3d point)","summary":"Adds a point object to the document.","since":"5.0","parameters":[{"name":"point","summary":"location of point."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPoint(Point3d point, ObjectAttributes attributes)","summary":"Adds a point object to the document.","since":"5.0","parameters":[{"name":"point","summary":"location of point."},{"name":"attributes","summary":"attributes to apply to point. None is acceptable"}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPoint(Point3d point, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds a point object to the document","since":"5.0","parameters":[{"name":"point","summary":"location of point"},{"name":"attributes","summary":"attributes to apply to point. None is acceptable"},{"name":"history","summary":"history associated with this point. None is acceptable"},{"name":"reference","summary":"True if the object is from a reference file.  Reference objects do not persist in archives"}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPoint(Point3f point)","summary":"Adds a point object to the document.","since":"5.0","parameters":[{"name":"point","summary":"location of point."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPoint(Point3f point, ObjectAttributes attributes)","summary":"Adds a point object to the document.","since":"5.0","parameters":[{"name":"point","summary":"location of point."},{"name":"attributes","summary":"attributes to apply to point."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPointCloud(IEnumerable<Point3d> points)","summary":"Adds a point cloud object to the document.","since":"5.0","parameters":[{"name":"points","summary":"A list, an array or any enumerable set of points."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPointCloud(IEnumerable<Point3d> points, ObjectAttributes attributes)","summary":"Adds a point cloud object to the document.","since":"5.0","parameters":[{"name":"points","summary":"A list, an array or any enumerable set of points."},{"name":"attributes","summary":"attributes to apply to point cloud."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPointCloud(IEnumerable<Point3d> points, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds a point cloud object to the document.","since":"5.0","parameters":[{"name":"points","summary":"A list, an array or any enumerable set of points"},{"name":"attributes","summary":"Attributes to apply to point cloud. None is acceptable"},{"name":"history","summary":"history associated with this point cloud. None is acceptable"},{"name":"reference","summary":"True if the object is from a reference file.  Reference objects do not persist in archives"}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPointCloud(PointCloud cloud)","summary":"Adds a point cloud object to the document.","since":"5.0","parameters":[{"name":"cloud","summary":"PointCloud to add."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPointCloud(PointCloud cloud, ObjectAttributes attributes)","summary":"Adds a point cloud object to the document.","since":"5.0","parameters":[{"name":"cloud","summary":"PointCloud to add."},{"name":"attributes","summary":"Attributes to apply to point cloud."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPointCloud(PointCloud cloud, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds a point cloud object to the document.","since":"5.0","parameters":[{"name":"cloud","summary":"PointCloud to add."},{"name":"attributes","summary":"Attributes to apply to point cloud. None is acceptable"},{"name":"history","summary":"history associated with this point cloud. None is acceptable"},{"name":"reference","summary":"True if the object is from a reference file.  Reference objects do not persist in archives"}],"returns":"A unique identifier for the object."},{"signature":"RhinoList<Guid> AddPoints(IEnumerable<Point3d> points)","summary":"Adds multiple points to the document.","since":"5.0","parameters":[{"name":"points","summary":"Points to add."}],"returns":"List of object ids."},{"signature":"RhinoList<Guid> AddPoints(IEnumerable<Point3d> points, ObjectAttributes attributes)","summary":"Adds multiple points to the document.","since":"5.0","parameters":[{"name":"points","summary":"Points to add."},{"name":"attributes","summary":"Attributes to apply to point objects."}],"returns":"List of object ids."},{"signature":"RhinoList<Guid> AddPoints(IEnumerable<Point3f> points)","summary":"Adds multiple points to the document.","since":"5.0","parameters":[{"name":"points","summary":"Points to add."}],"returns":"List of object ids."},{"signature":"RhinoList<Guid> AddPoints(IEnumerable<Point3f> points, ObjectAttributes attributes)","summary":"Adds multiple points to the document.","since":"5.0","parameters":[{"name":"points","summary":"Points to add."},{"name":"attributes","summary":"Attributes to apply to point objects."}],"returns":"List of object ids."},{"signature":"Guid AddPolyline(IEnumerable<Point3d> points)","summary":"Adds a polyline object to Rhino.","since":"5.0","parameters":[{"name":"points","summary":"A Polyline; a list, an array, or any enumerable set of Point3d."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPolyline(IEnumerable<Point3d> points, ObjectAttributes attributes)","summary":"Adds a polyline object to Rhino.","since":"5.0","parameters":[{"name":"points","summary":"A Polyline; a list, an array, or any enumerable set of Point3d."},{"name":"attributes","summary":"attributes to apply to line."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPolyline(IEnumerable<Point3d> points, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddRadialDimension(RadialDimension dimension)","since":"5.0"},{"signature":"Guid AddRadialDimension(RadialDimension dimension, ObjectAttributes attributes)","since":"5.0"},{"signature":"Guid AddRadialDimension(RadialDimension dimension, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds a radial dimension object to the document.","since":"5.0","parameters":[{"name":"dimension","summary":"Dimension object to add."},{"name":"attributes","summary":"Attributes to apply to dimension."},{"name":"history","summary":"Object history to save."},{"name":"reference","summary":"If reference, then object will not be saved into the 3dm file."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddRectangle(Rectangle3d rectangle)","summary":"Adds a rectangle to the object table.","since":"6.0","parameters":[{"name":"rectangle","summary":"The rectangle."}],"returns":"The ID."},{"signature":"Guid AddRectangle(Rectangle3d rectangle, ObjectAttributes attributes)","summary":"Adds a rectangle to the object table.","since":"6.0","parameters":[{"name":"rectangle","summary":"The rectangle."},{"name":"attributes","summary":"Attributes that will be linked with the surface object."}],"returns":"The ID."},{"signature":"Guid AddRectangle(Rectangle3d rectangle, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds a rectangle to the object table.","since":"6.0","parameters":[{"name":"rectangle","summary":"The rectangle."},{"name":"attributes","summary":"Attributes that will be linked with the surface object."},{"name":"history","summary":"History data records."},{"name":"reference","summary":"If a reference, object will not be saved in the document."}],"returns":"The ID."},{"signature":"void AddRhinoObject(BrepObject brepObject, Brep brep)","since":"5.0"},{"signature":"void AddRhinoObject(CurveObject curveObject, Curve curve)","since":"5.0"},{"signature":"void AddRhinoObject(CustomBrepObject brepObject)","since":"5.0"},{"signature":"void AddRhinoObject(CustomBrepObject brepObject, HistoryRecord history)","since":"6.1"},{"signature":"void AddRhinoObject(CustomCurveObject curveObject, HistoryRecord history)","since":"6.1"},{"signature":"void AddRhinoObject(CustomMeshObject meshObject)","since":"5.0"},{"signature":"void AddRhinoObject(CustomMeshObject meshObject, HistoryRecord history)","since":"6.1"},{"signature":"void AddRhinoObject(CustomPointObject pointObject)","since":"5.6"},{"signature":"void AddRhinoObject(CustomPointObject pointObject, HistoryRecord history)","since":"6.1"},{"signature":"void AddRhinoObject(MeshObject meshObject, Mesh mesh)","since":"5.0"},{"signature":"void AddRhinoObject(PointObject pointObject, Point point)","since":"5.6"},{"signature":"Guid AddSphere(Sphere sphere)","since":"5.0"},{"signature":"Guid AddSphere(Sphere sphere, ObjectAttributes attributes)","since":"5.0"},{"signature":"Guid AddSphere(Sphere sphere, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddSubD(SubD subD)","summary":"Adds a SubD object to Rhino.","since":"7.0","parameters":[{"name":"subD","summary":"A duplicate of this SubD is added to Rhino."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddSubD(SubD subD, ObjectAttributes attributes)","summary":"Adds a SubD object to Rhino.","since":"7.0","parameters":[{"name":"subD","summary":"A duplicate of this SubD is added to Rhino."},{"name":"attributes","summary":"Attributes that will be linked with the object."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddSubD(SubD subD, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds a SubD object to Rhino.","since":"7.0","parameters":[{"name":"subD","summary":"A duplicate of this SubD is added to Rhino."},{"name":"attributes","summary":"Attributes that will be linked with the object."},{"name":"history","summary":""},{"name":"reference","summary":""}],"returns":"A unique identifier for the object."},{"signature":"Guid AddSurface(Surface surface)","summary":"Adds a surface object to Rhino.","since":"5.0","parameters":[{"name":"surface","summary":"A duplicate of this surface is added to Rhino."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddSurface(Surface surface, ObjectAttributes attributes)","summary":"Adds a surface object to Rhino.","since":"5.0","parameters":[{"name":"surface","summary":"A duplicate of this surface is added to Rhino."},{"name":"attributes","summary":"Attributes that will be linked with the surface object."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddSurface(Surface surface, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddText(string text, Plane plane, double height, string fontName, bool bold, bool italic)","summary":"Adds an annotation text object to the document.","since":"5.0","parameters":[{"name":"text","summary":"Text string."},{"name":"plane","summary":"Plane of text."},{"name":"height","summary":"Height of text."},{"name":"fontName","summary":"Name of FontFace."},{"name":"bold","summary":"Bold flag."},{"name":"italic","summary":"Italic flag."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddText(string text, Plane plane, double height, string fontName, bool bold, bool italic, ObjectAttributes attributes)","summary":"Adds an annotation text object to the document.","since":"5.0","parameters":[{"name":"text","summary":"Text string."},{"name":"plane","summary":"Plane of text."},{"name":"height","summary":"Height of text."},{"name":"fontName","summary":"Name of FontFace."},{"name":"bold","summary":"Bold flag."},{"name":"italic","summary":"Italic flag."},{"name":"attributes","summary":"Attributes that will be linked with the object."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddText(string text, Plane plane, double height, string fontName, bool bold, bool italic, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddText(string text, Plane plane, double height, string fontName, bool bold, bool italic, TextJustification justification)","since":"5.0"},{"signature":"Guid AddText(string text, Plane plane, double height, string fontName, bool bold, bool italic, TextJustification justification, ObjectAttributes attributes)","since":"5.0"},{"signature":"Guid AddText(string text, Plane plane, double height, string fontName, bool bold, bool italic, TextJustification justification, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"Guid AddText(Text3d text3d)","summary":"Adds an annotation text object to the document.","since":"5.0","parameters":[{"name":"text3d","summary":"The text object to add."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddText(Text3d text3d, ObjectAttributes attributes)","summary":"Adds an annotation text object to the document.","since":"5.0","parameters":[{"name":"text3d","summary":"The text object to add."},{"name":"attributes","summary":"Object Attributes."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddText(TextEntity text)","summary":"Adds a v6_TextObject to the document.","since":"5.0","parameters":[{"name":"text","summary":"Text object to add."}],"returns":"The Id of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddText(TextEntity text, ObjectAttributes attributes)","summary":"Adds a text object to the document.","since":"5.0","parameters":[{"name":"text","summary":"Text object to add."},{"name":"attributes","summary":""}],"returns":"The Id of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddText(TextEntity text, ObjectAttributes attributes, HistoryRecord history, bool reference)","summary":"Adds a text object to the document.","since":"5.0","parameters":[{"name":"text","summary":"Text object to add."},{"name":"attributes","summary":""},{"name":"history","summary":"Object history to save."},{"name":"reference","summary":"If reference, then object will not be saved into the 3dm file."}],"returns":"The Id of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddTextDot(string text, Point3d location)","summary":"Adds a text dot object to Rhino.","since":"5.0","parameters":[{"name":"text","summary":"A text string."},{"name":"location","summary":"A point position."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddTextDot(string text, Point3d location, ObjectAttributes attributes)","summary":"Adds a text dot object to Rhino.","since":"5.0","parameters":[{"name":"text","summary":"A text string."},{"name":"location","summary":"A point position."},{"name":"attributes","summary":"Attributes to apply to curve."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddTextDot(TextDot dot)","summary":"Adds a text dot object to Rhino.","since":"5.0","parameters":[{"name":"dot","summary":"A text dot that will be copied."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddTextDot(TextDot dot, ObjectAttributes attributes)","summary":"Adds a text dot object to Rhino.","since":"5.0","parameters":[{"name":"dot","summary":"A text dot that will be copied."},{"name":"attributes","summary":"Attributes to apply to text dot."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddTextDot(TextDot dot, ObjectAttributes attributes, HistoryRecord history, bool reference)","since":"5.0"},{"signature":"RhinoObject[] AllObjectsSince(uint runtimeSerialNumber)","summary":"Gets all the objects that have been added to the document since a given runtime serial number.","since":"5.0","parameters":[{"name":"runtimeSerialNumber","summary":"Runtime serial number of the last object not to include in the list."}],"returns":"An array of objects or None if no objects were added since the given runtime serial number."},{"signature":"bool Delete(Guid objectId, bool quiet)","summary":"Deletes object from document. The deletion can be undone by calling UndeleteObject().","since":"5.0","parameters":[{"name":"objectId","summary":"Id of the object to delete."},{"name":"quiet","summary":"If false, a message box will appear when an object cannot be deleted."}],"returns":"True on success, False on failure."},{"signature":"int Delete(IEnumerable<Guid> objectIds, bool quiet)","summary":"Deletes a collection of objects from the document.","since":"5.0","parameters":[{"name":"objectIds","summary":"Ids of all objects to delete."},{"name":"quiet","summary":"If false, a message box will appear when an object cannot be deleted."}],"returns":"The number of successfully deleted objects."},{"signature":"bool Delete(ObjRef objref, bool quiet)","summary":"Deletes objref.Object(). The deletion can be undone by calling UndeleteObject().","since":"5.0","parameters":[{"name":"objref","summary":"objref.Object() will be deleted."},{"name":"quiet","summary":"If false, a message box will appear when an object cannot be deleted."}],"returns":"True on success, False on failure."},{"signature":"bool Delete(ObjRef objref, bool quiet, bool ignoreModes)","summary":"Deletes objref.Object(). The deletion can be undone by calling UndeleteObject().","since":"6.0","parameters":[{"name":"objref","summary":"objref.Object() will be deleted."},{"name":"quiet","summary":"If false, a message box will appear when an object cannot be deleted."},{"name":"ignoreModes","summary":"If true, locked and hidden objects are deleted.  If False objects that are locked, hidden, or on locked or hidden layers are not deleted."}],"returns":"True on success, False on failure."},{"signature":"bool Delete(RhinoObject item)","summary":"Deletes an object, taking into account modes and not showing error message boxes.","since":"6.0","parameters":[{"name":"item","summary":"The object to delete."}],"returns":"True on success."},{"signature":"bool Delete(RhinoObject obj, bool quiet)","summary":"Deletes object from document. The deletion can be undone by calling UndeleteObject().","since":"5.0","parameters":[{"name":"obj","summary":"The object to delete."},{"name":"quiet","summary":"If false, a message box will appear when an object cannot be deleted."}],"returns":"True on success, False on failure."},{"signature":"bool Delete(RhinoObject obj, bool quiet, bool ignoreModes)","summary":"Deletes object from document. The deletion can be undone by calling UndeleteObject().","since":"6.0","parameters":[{"name":"obj","summary":"The object to delete."},{"name":"quiet","summary":"If false, a message box will appear when an object cannot be deleted."},{"name":"ignoreModes","summary":"If true, locked and hidden objects are deleted.  If False objects that are locked, hidden, or on locked or hidden layers are not deleted."}],"returns":"True on success, False on failure."},{"signature":"bool DeleteGrip(GripObject grip)","summary":"Deletes a grip object.","since":"6.5","parameters":[{"name":"grip","summary":"The grip object to delete."}],"returns":"True on success."},{"signature":"bool DeleteGrip(Guid gripId)","summary":"Deletes a grip object.","since":"6.5","parameters":[{"name":"gripId","summary":"The id of the grip object to delete."}],"returns":"True on success."},{"signature":"bool DeleteGrip(ObjRef gripRef)","summary":"Deletes a grip object.","since":"6.5","parameters":[{"name":"gripRef","summary":"A reference to the grip object to delete."}],"returns":"True on success."},{"signature":"int DeleteGrips(IEnumerable<GripObject> grips)","summary":"Deletes one or more grip objects.","since":"6.5","parameters":[{"name":"grips","summary":"The grip objects to delete."}],"returns":"The number of successfully deleted grip objects."},{"signature":"int DeleteGrips(IEnumerable<Guid> gripIds)","summary":"Deletes one or more grip objects.","since":"6.5","parameters":[{"name":"gripIds","summary":"The ids of the grip objects to delete."}],"returns":"The number of successfully deleted grip objects."},{"signature":"int DeleteGrips(IEnumerable<ObjRef> gripRefs)","summary":"Deletes one or more grip objects.","since":"6.5","parameters":[{"name":"gripRefs","summary":"References to the grip objects to delete."}],"returns":"The number of successfully deleted grip objects."},{"signature":"int DeleteGrips(RhinoObject owner, IEnumerable<int> gripIndices)","summary":"Deletes one or more grip objects.","since":"6.5","parameters":[{"name":"owner","summary":"The owner of the grip objects."},{"name":"gripIndices","summary":"The indices of the grip objects to delete."}],"returns":"The number of successfully deleted grip objects."},{"signature":"Guid Duplicate(Guid objectId)","summary":"Same as TransformObject(objref, ON_Xform.Identity, false)","since":"5.0","parameters":[{"name":"objectId","summary":"An ID to an object in the document that needs to be duplicated."}],"returns":"The new object ID."},{"signature":"Guid Duplicate(ObjRef objref)","summary":"Duplicates the object that is referenced by objref.  \\nSame as Transform(objref, Transform.Identity, false)","since":"5.0","parameters":[{"name":"objref","summary":"A Rhino object reference to follow for object duplication."}],"returns":"The new object ID."},{"signature":"Guid Duplicate(RhinoObject obj)","summary":"Duplicates the object that is referenced by obj.  \\nSame as TransformObject(obj, Transform.Identityy, false)","since":"5.0","parameters":[{"name":"obj","summary":"A Rhino object to duplicate."}],"returns":"The new object ID."},{"signature":"RhinoObject Find(Guid objectId)","summary":"Please use FindId().","since":"5.0","parameters":[{"name":"objectId","summary":"Do not use this method."}],"returns":"Do not use this method."},{"signature":"RhinoObject Find(uint runtimeSerialNumber)","summary":"Use the object runtime serial number to find a rhino object in the document. This is the value stored on RhinoObject.RuntimeObjectSerialNumber. The RhinoObject constructor sets the runtime serial number and every instance of a RhinoObject class will have a unique serial number for the duration of the Rhino application. If an object is replaced with a new object, then the new object will have a different runtime serial number. Deleted objects stored in the undo list maintain their runtime serial numbers and this function will return pointers to these objects. Call RhinoObject.IsDeleted if you need to determine if the returned object is active or deleted.  The runtime serial number is not saved in files.","since":"5.0","parameters":[{"name":"runtimeSerialNumber","summary":"Runtime serial number to search for."}],"returns":"Reference to the rhino object with the objectId or None if no such object could be found."},{"signature":"RhinoObject[] FindByCrossingWindowRegion(RhinoViewport viewport, IEnumerable<Point3d> region, bool inside, ObjectType filter)","summary":"Finds objects bounded by a polyline region","since":"5.7","parameters":[{"name":"viewport","summary":"viewport to use for selection"},{"name":"region","summary":"list of points that define the"},{"name":"inside","summary":"should objects returned be the ones inside of this region (or outside)"},{"name":"filter","summary":"filter down list by object type"}],"returns":"An array of RhinoObjects that are inside of this region"},{"signature":"RhinoObject[] FindByCrossingWindowRegion(RhinoViewport viewport, Point2d screen1, Point2d screen2, bool inside, ObjectType filter)","summary":"Finds objects bounded by a region","since":"5.8","parameters":[{"name":"viewport","summary":"viewport to use for selection"},{"name":"screen1","summary":"first screen corner"},{"name":"screen2","summary":"second screen corner"},{"name":"inside","summary":"should objects returned be the ones inside of this region (or outside)"},{"name":"filter","summary":"filter down list by object type"}],"returns":"An array of RhinoObjects that are inside of this region"},{"signature":"RhinoObject[] FindByDrawColor(Color drawColor, bool includeLights)","summary":"Finds all objects whose draw color matches a given color.","since":"5.0","parameters":[{"name":"drawColor","summary":"The alpha value of this color is ignored."},{"name":"includeLights","summary":"True if lights should be included."}],"returns":"An array of Rhino document objects. This array can be empty."},{"signature":"RhinoObject[] FindByFilter(ObjectEnumeratorSettings filter)","summary":"Same as GetObjectList but converts the result to an array.","since":"5.0","parameters":[{"name":"filter","summary":"The Rhino.DocObjects.ObjectEnumeratorSettingsfilter to customize inclusion requirements."}],"returns":"A Rhino object array. This array can be empty but not null."},{"signature":"RhinoObject[] FindByGroup(int groupIndex)","summary":"Finds all RhinoObjects that are in a given group.","since":"5.0","parameters":[{"name":"groupIndex","summary":"Index of group to search for."}],"returns":"An array of objects that belong to the specified group or None if no objects could be found."},{"signature":"RhinoObject[] FindByLayer(Layer layer)","summary":"Finds all RhinoObjects that are in a given layer.","since":"5.0","parameters":[{"name":"layer","summary":"Layer to search."}],"returns":"Array of objects that belong to the specified group or None if no objects could be found."},{"signature":"RhinoObject[] FindByLayer(string layerName)","summary":"Finds all RhinoObjects that are in a given layer.","since":"5.0","parameters":[{"name":"layerName","summary":"Name of layer to search."}],"returns":"Array of objects that belong to the specified group or None if no objects could be found."},{"signature":"RhinoObject[] FindByObjectType(ObjectType typeFilter)","since":"5.0"},{"signature":"RhinoObject[] FindByUserString(string key, string value, bool caseSensitive)","summary":"Finds all objects whose UserString matches the search patterns.","since":"5.0","parameters":[{"name":"key","summary":"Search pattern for UserString keys (supported wildcards are: ? = any single character, * = any sequence of characters)."},{"name":"value","summary":"Search pattern for UserString values (supported wildcards are: ? = any single character, * = any sequence of characters)."},{"name":"caseSensitive","summary":"If true, string comparison will be case sensitive."}],"returns":"An array of all objects whose UserString matches with the search patterns or None when no such objects could be found."},{"signature":"RhinoObject[] FindByUserString(string key, string value, bool caseSensitive, bool searchGeometry, bool searchAttributes, ObjectEnumeratorSettings filter)","summary":"Finds all objects whose UserString matches the search patterns.","since":"5.0","parameters":[{"name":"key","summary":"Search pattern for UserString keys (supported wildcards are: ? = any single character, * = any sequence of characters)."},{"name":"value","summary":"Search pattern for UserString values (supported wildcards are: ? = any single character, * = any sequence of characters)."},{"name":"caseSensitive","summary":"If true, string comparison will be case sensitive."},{"name":"searchGeometry","summary":"If true, UserStrings attached to the geometry of an object will be searched."},{"name":"searchAttributes","summary":"If true, UserStrings attached to the attributes of an object will be searched."},{"name":"filter","summary":"Rhino.DocObjects.ObjectEnumeratorSettingsfilter used to restrict the number of objects searched."}],"returns":"An array of all objects whose UserString matches with the search patterns or None when no such objects could be found."},{"signature":"RhinoObject[] FindByUserString(string key, string value, bool caseSensitive, bool searchGeometry, bool searchAttributes, ObjectType filter)","summary":"Finds all objects whose UserString matches the search patterns.","since":"5.0","parameters":[{"name":"key","summary":"Search pattern for UserString keys (supported wildcards are: ? = any single character, * = any sequence of characters)."},{"name":"value","summary":"Search pattern for UserString values (supported wildcards are: ? = any single character, * = any sequence of characters)."},{"name":"caseSensitive","summary":"If true, string comparison will be case sensitive."},{"name":"searchGeometry","summary":"If true, UserStrings attached to the geometry of an object will be searched."},{"name":"searchAttributes","summary":"If true, UserStrings attached to the attributes of an object will be searched."},{"name":"filter","summary":"Object type filter."}],"returns":"An array of all objects whose UserString matches with the search patterns or None when no such objects could be found."},{"signature":"RhinoObject[] FindByWindowRegion(RhinoViewport viewport, IEnumerable<Point3d> region, bool inside, ObjectType filter)","summary":"Finds objects bounded by a polyline region","since":"5.7","parameters":[{"name":"viewport","summary":"viewport to use for selection"},{"name":"region","summary":"list of points that define the"},{"name":"inside","summary":"should objects returned be the ones inside of this region (or outside)"},{"name":"filter","summary":"filter down list by object type"}],"returns":"An array of RhinoObjects that are inside of this region"},{"signature":"RhinoObject[] FindByWindowRegion(RhinoViewport viewport, Point2d screen1, Point2d screen2, bool inside, ObjectType filter)","summary":"Finds objects bounded by a polyline region","since":"5.8","parameters":[{"name":"viewport","summary":"viewport to use for selection"},{"name":"screen1","summary":"first screen corner"},{"name":"screen2","summary":"second screen corner"},{"name":"inside","summary":"should objects returned be the ones inside of this region (or outside)"},{"name":"filter","summary":"filter down list by object type"}],"returns":"An array of RhinoObjects that are inside of this region"},{"signature":"ClippingPlaneObject[] FindClippingPlanesForViewport(RhinoViewport viewport)","summary":"Finds all of the clipping plane objects that actively clip a viewport.","since":"5.0","parameters":[{"name":"viewport","summary":"The viewport in which clipping planes are searched."}],"returns":"An array of clipping plane objects. The array can be empty but not null."},{"signature":"GeometryBase FindGeometry(Guid id)","summary":"Same as FindId, but returns the Geometry property directly, if it exists.","since":"6.0","parameters":[{"name":"id","summary":"ID of object to search for."}],"returns":"Reference to the geometry in the rhino object with the objectId or None if no such object could be found."},{"signature":"RhinoObject FindId(Guid id)","summary":"Uses the object guid to find a rhino object. Deleted objects cannot be found by id. The guid is the value that is stored on RhinoObject.Id In a single document, no two active objects have the same guid. If an object is replaced with a new object, then the guid  persists. For example, if the _Move command moves an object, then the moved object inherits it\'s guid from the starting object. If the Copy command copies an object, then the copy gets a new guid. This guid persists through file saving/opening operations. This function will not find grip objects.","since":"6.0","parameters":[{"name":"id","summary":"ID of object to search for."}],"returns":"Reference to the rhino object with the objectId or None if no such object could be found."},{"signature":"IEnumerator<RhinoObject> GetEnumerator()","since":"5.0"},{"signature":"IEnumerable<RhinoObject> GetObjectList(ObjectEnumeratorSettings settings)","summary":"Returns an enumerable based on a Rhino.DocObjects.ObjectEnumeratorSettingsfilter.","parameters":[{"name":"settings","summary":"The Rhino.DocObjects.ObjectEnumeratorSettingssettings."}],"returns":"The enumerable."},{"signature":"IEnumerable<RhinoObject> GetObjectList(ObjectType typeFilter)","since":"5.0"},{"signature":"IEnumerable<RhinoObject> GetObjectList(Type typeFilter)","since":"5.0"},{"signature":"IEnumerable<T> GetObjectsByType()","summary":"Returns Rhino object by type.","since":"6.0","returns":"The enumerable."},{"signature":"IEnumerable<T> GetObjectsByType(ObjectEnumeratorSettings settings)","summary":"Returns Rhino object by type.","since":"6.0","returns":"The enumerable."},{"signature":"IEnumerable<RhinoObject> GetSelectedObjects(bool includeLights, bool includeGrips)","since":"5.0"},{"signature":"ObjectType GetSelectedObjectTypes()","since":"6.0"},{"signature":"RhinoObject GripUpdate(RhinoObject obj, bool deleteOriginal)","summary":"Altered grip positions on a RhinoObject are used to calculate an updated object that is added to the document.","since":"5.0","parameters":[{"name":"obj","summary":"object with modified grips to update."},{"name":"deleteOriginal","summary":"if true, obj is deleted from the document."}],"returns":"new RhinoObject on success; otherwise null."},{"signature":"bool Hide(Guid objectId, bool ignoreLayerMode)","summary":"If Object().IsNormal() is true, then the object will be hidden.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to hide."},{"name":"ignoreLayerMode","summary":"if true, the object will be hidden even if it is on a layer that is locked or off."}],"returns":"True if the object was successfully hidden."},{"signature":"bool Hide(ObjRef objref, bool ignoreLayerMode)","summary":"If objref.Object().IsNormal() is true, then the object will be hidden.","since":"5.0","parameters":[{"name":"objref","summary":"reference to object to hide."},{"name":"ignoreLayerMode","summary":"if true, the object will be hidden even if it is on a layer that is locked or off."}],"returns":"True if the object was successfully hidden."},{"signature":"bool Hide(RhinoObject obj, bool ignoreLayerMode)","summary":"If obj.IsNormal() is true, then the object will be hidden.","since":"5.0","parameters":[{"name":"obj","summary":"object to hide."},{"name":"ignoreLayerMode","summary":"if true, the object will be hidden even if it is on a layer that is locked or off."}],"returns":"True if the object was successfully hidden."},{"signature":"bool Lock(Guid objectId, bool ignoreLayerMode)","summary":"If objref.Object().IsNormal() is true, then the object will be locked.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of normal object to lock."},{"name":"ignoreLayerMode","summary":"if true, the object will be locked even if it is on a layer that is locked or off."}],"returns":"True if the object was successfully locked."},{"signature":"bool Lock(ObjRef objref, bool ignoreLayerMode)","summary":"If objref.Object().IsNormal() is true, then the object will be locked.","since":"5.0","parameters":[{"name":"objref","summary":"reference to normal object to lock."},{"name":"ignoreLayerMode","summary":"if true, the object will be locked even if it is on a layer that is locked or off."}],"returns":"True if the object was successfully locked."},{"signature":"bool Lock(RhinoObject obj, bool ignoreLayerMode)","summary":"If obj.IsNormal() is true, then the object will be locked.","since":"5.0","parameters":[{"name":"obj","summary":"normal object to lock."},{"name":"ignoreLayerMode","summary":"if true, the object will be locked even if it is on a layer that is locked or off."}],"returns":"True if the object was successfully locked."},{"signature":"bool ModifyAttributes(Guid objectId, ObjectAttributes newAttributes, bool quiet)","summary":"Modifies an object\'s attributes.  Cannot be used to change object id.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to modify."},{"name":"newAttributes","summary":"new attributes."},{"name":"quiet","summary":"if true, then warning message boxes are disabled."}],"returns":"True if successful."},{"signature":"bool ModifyAttributes(ObjRef objref, ObjectAttributes newAttributes, bool quiet)","summary":"Modifies an object\'s attributes.  Cannot be used to change object id.","since":"5.0","parameters":[{"name":"objref","summary":"reference to object to modify."},{"name":"newAttributes","summary":"new attributes."},{"name":"quiet","summary":"if true, then warning message boxes are disabled."}],"returns":"True if successful."},{"signature":"bool ModifyAttributes(RhinoObject obj, ObjectAttributes newAttributes, bool quiet)","summary":"Modifies an object\'s attributes.  Cannot be used to change object id.","since":"5.0","parameters":[{"name":"obj","summary":"object to modify."},{"name":"newAttributes","summary":"new attributes."},{"name":"quiet","summary":"if true, then warning message boxes are disabled."}],"returns":"True if successful."},{"signature":"bool ModifyRenderMaterial(Guid objectId, RenderMaterial material)","summary":"Modifies an object\'s render material assignment, this will set the objects material source to ObjectMaterialSource.MaterialFromObject.","since":"5.7","parameters":[{"name":"objectId","summary":"Id of object to modify."},{"name":"material","summary":"Material to assign to this object."}],"returns":"Returns True on success otherwise returns false."},{"signature":"bool ModifyRenderMaterial(ObjRef objRef, RenderMaterial material)","summary":"Modifies an object\'s render material assignment, this will set the objects material source to ObjectMaterialSource.MaterialFromObject.","since":"5.7","parameters":[{"name":"objRef","summary":"Object to modify."},{"name":"material","summary":"Material to assign to this object."}],"returns":"Returns True on success otherwise returns false."},{"signature":"bool ModifyRenderMaterial(RhinoObject obj, RenderMaterial material)","summary":"Modifies an object\'s render material assignment, this will set the objects material source to ObjectMaterialSource.MaterialFromObject.","since":"5.7","parameters":[{"name":"obj","summary":"Object to modify."},{"name":"material","summary":"Material to assign to this object."}],"returns":"Returns True on success otherwise returns false."},{"signature":"bool ModifyTextureMapping(Guid objId, int channel, TextureMapping mapping)","since":"5.7"},{"signature":"bool ModifyTextureMapping(ObjRef objRef, int channel, TextureMapping mapping)","since":"5.7"},{"signature":"bool ModifyTextureMapping(RhinoObject obj, int channel, TextureMapping mapping)","since":"5.7"},{"signature":"RhinoObject MostRecentObject()","summary":"Gets the most recently added object that is still in the Document.","since":"5.0","returns":"The most recent (non-deleted) object in the document, or None if no such object exists."},{"signature":"int ObjectCount(ObjectEnumeratorSettings filter)","summary":"Returns the number objects that pass a filter.","parameters":[{"name":"filter","summary":"The Rhino.DocObjects.ObjectEnumeratorSettingsfilter."}],"returns":"The number of objects that pass the filter."},{"signature":"ObjRef[] PickObjects(PickContext pickContext)","summary":"Pick one or more objects based on a given pick context","since":"6.0","parameters":[{"name":"pickContext","summary":"settings used to define what is picked"}],"returns":"zero or more objects"},{"signature":"bool Purge(RhinoObject rhinoObject)","summary":"Removes object from document and deletes the pointer. Typically you will want to call Delete instead in order to keep the object on the undo list.","since":"5.0","parameters":[{"name":"rhinoObject","summary":"A Rhino object that will be deleted."}],"returns":"True if the object was purged; otherwise false."},{"signature":"bool Purge(uint runtimeSerialNumber)","summary":"Removes object from document and deletes the pointer. Typically you will want to call Delete instead in order to keep the object on the undo list.","since":"5.0","parameters":[{"name":"runtimeSerialNumber","summary":"A runtime serial number of the object that will be deleted."}],"returns":"True if the object was purged; otherwise false."},{"signature":"bool Replace(Guid objectId, Arc arc)","summary":"Replaces one object with new curve object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"arc","summary":"new arc to be added.  The arc is copied."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, Brep brep)","summary":"Replaces one object with new brep object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"brep","summary":"new surface to be added A duplicate of the brep is added to the Rhino model."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, Brep brep, bool splitKinkySurfaces)","since":"6.1"},{"signature":"bool Replace(Guid objectId, Circle circle)","summary":"Replaces one object with new curve object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"circle","summary":"new circle to be added.  The circle is copied."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, Curve curve)","summary":"Replaces one object with new curve object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"curve","summary":"New curve to be added. A duplicate of the curve is added to the Rhino model."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, Extrusion extrusion)","summary":"Replaces one object with new extrusion object.","since":"6.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"extrusion","summary":"New extrusion to be added. A duplicate of the extrusion is added to the Rhino model."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, Hatch hatch)","summary":"Replaces one object with new hatch object.","since":"6.1","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"hatch","summary":"new hatch to be added. The hatch is copied."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, Leader leader)","summary":"Replaces one object with new text object.","since":"6.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"leader","summary":"new leader to be added.  The leader is copied."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, Line line)","summary":"Replaces one object with new line curve object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"line","summary":"new line to be added.  The line is copied."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, Mesh mesh)","summary":"Replaces one object with new mesh object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"mesh","summary":"new mesh to be added A duplicate of the mesh is added to the Rhino model."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, Point point)","summary":"Replaces one object with new point object.","since":"6.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"point","summary":"new point to be added.  The point is copied."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, Point3d point)","summary":"Replaces one object with new point object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"point","summary":"new point to be added.  The point is copied."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, PointCloud pointcloud)","summary":"Replaces one object with new point cloud object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"pointcloud","summary":"new point cloud to be added A duplicate of the point cloud is added to the Rhino model."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, Polyline polyline)","summary":"Replaces one object with new curve object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"polyline","summary":"new polyline to be added.  The polyline is copied."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, SubD subD)","summary":"Replaces one object with new subd object.","since":"7.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"subD","summary":"new mesh to be added A duplicate of the mesh is added to the Rhino model."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, Surface surface)","summary":"Replaces one object with new surface object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"surface","summary":"new surface to be added A duplicate of the surface is added to the Rhino model."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, TextDot dot)","summary":"Replaces one object with new text dot object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"dot","summary":"new text dot to be added.  The text dot is copied."}],"returns":"True if successful."},{"signature":"bool Replace(Guid objectId, TextEntity text)","summary":"Replaces one object with new text object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to be replaced."},{"name":"text","summary":"new text to be added.  The text is copied."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, Arc arc)","summary":"Replaces one object with new curve object.","since":"5.0","parameters":[{"name":"objref","summary":"Reference to old object to be replaced. The object objref.Object() will be deleted."},{"name":"arc","summary":"new arc to be added.  The arc is copied."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, Brep brep)","summary":"Replaces one object with new brep object.","since":"5.0","parameters":[{"name":"objref","summary":"reference to old object to be replaced. The objref.Object() will be deleted."},{"name":"brep","summary":"new brep to be added A duplicate of the brep is added to the Rhino model."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, Brep brep, bool splitKinkySurfaces)","since":"6.1"},{"signature":"bool Replace(ObjRef objref, Circle circle)","summary":"Replaces one object with new curve object.","since":"5.0","parameters":[{"name":"objref","summary":"Reference to old object to be replaced. The object objref.Object() will be deleted."},{"name":"circle","summary":"new circle to be added.  The circle is copied."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, Curve curve)","summary":"Replaces one object with new curve object.","since":"5.0","parameters":[{"name":"objref","summary":"reference to old object to be replaced. The objref.Object() will be deleted."},{"name":"curve","summary":"New curve to be added. A duplicate of the curve is added to the Rhino model."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, Extrusion extrusion)","summary":"Replaces one object with new extrusion object.","since":"6.0","parameters":[{"name":"objref","summary":"reference to old object to be replaced. The objref.Object() will be deleted."},{"name":"extrusion","summary":"New extrusion to be added. A duplicate of the extrusion is added to the Rhino model."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, Hatch hatch)","summary":"Replaces one object with new hatch object.","since":"6.1","parameters":[{"name":"objref","summary":"Reference to old object to be replaced. The object objref.Object() will be deleted."},{"name":"hatch","summary":"new hatch to be added. The hatch is copied."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, Leader leader)","summary":"Replaces one object with new text object.","since":"6.0","parameters":[{"name":"objref","summary":"Reference to old object to be replaced. The object objref.Object() will be deleted."},{"name":"leader","summary":"new leader to be added.  The leader is copied."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, Line line)","summary":"Replaces one object with new line curve object.","since":"5.0","parameters":[{"name":"objref","summary":"Reference to old object to be replaced. The object objref.Object() will be deleted."},{"name":"line","summary":"new line to be added.  The line is copied."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, Mesh mesh)","summary":"Replaces one object with new mesh object.","since":"5.0","parameters":[{"name":"objref","summary":"reference to old object to be replaced. The objref.Object() will be deleted."},{"name":"mesh","summary":"new mesh to be added A duplicate of the mesh is added to the Rhino model."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, Point point)","summary":"Replaces one object with new point object.","since":"6.0","parameters":[{"name":"objref","summary":"Reference to old object to be replaced. The object objref.Object() will be deleted."},{"name":"point","summary":"new point to be added.  The point is copied."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, Point3d point)","summary":"Replaces one object with new point object.","since":"5.0","parameters":[{"name":"objref","summary":"Reference to old object to be replaced. The object objref.Object() will be deleted."},{"name":"point","summary":"new point to be added.  The point is copied."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, PointCloud pointcloud)","summary":"Replaces one object with new point cloud object.","since":"5.0","parameters":[{"name":"objref","summary":"reference to old object to be replaced. The objref.Object() will be deleted."},{"name":"pointcloud","summary":"new point cloud to be added A duplicate of the point cloud is added to the Rhino model."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, Polyline polyline)","summary":"Replaces one object with new curve object.","since":"5.0","parameters":[{"name":"objref","summary":"Reference to old object to be replaced. The object objref.Object() will be deleted."},{"name":"polyline","summary":"new polyline to be added.  The polyline is copied."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, RhinoObject newObject)","summary":"Replaces one object with another. Conceptually, this function is the same as calling Setting new_object attributes = old_object attributes DeleteObject(old_object); AddObject(old_object);","since":"5.0","parameters":[{"name":"objref","summary":"reference to old object to be replaced. The objref.Object() will be deleted."},{"name":"newObject","summary":"new replacement object - must not be in document."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, SubD subD)","summary":"Replaces one object with a new SubD object.","since":"7.0","parameters":[{"name":"objref","summary":"reference to old object to be replaced. The objref.Object() will be deleted."},{"name":"subD","summary":"new SubD to be added A duplicate of the SubD is added to the Rhino model."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, Surface surface)","summary":"Replaces one object with new surface object.","since":"5.0","parameters":[{"name":"objref","summary":"reference to old object to be replaced. The objref.Object() will be deleted."},{"name":"surface","summary":"new surface to be added A duplicate of the surface is added to the Rhino model."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, TextDot dot)","summary":"Replaces one object with new text dot object.","since":"5.0","parameters":[{"name":"objref","summary":"Reference to old object to be replaced. The object objref.Object() will be deleted."},{"name":"dot","summary":"new text dot to be added.  The text dot is copied."}],"returns":"True if successful."},{"signature":"bool Replace(ObjRef objref, TextEntity text)","summary":"Replaces one object with new text object.","since":"5.0","parameters":[{"name":"objref","summary":"Reference to old object to be replaced. The object objref.Object() will be deleted."},{"name":"text","summary":"new text to be added.  The text is copied."}],"returns":"True if successful."},{"signature":"bool ReplaceInstanceObject(Guid objectId, int instanceDefinitionIndex)","summary":"Replaces the underlying instance definition of an instance object.","since":"6.8","parameters":[{"name":"objectId","summary":"Id of the instance object to be replaced."},{"name":"instanceDefinitionIndex","summary":"The index of the new instance definition to use."}],"returns":"True if successful."},{"signature":"bool ReplaceInstanceObject(ObjRef objref, int instanceDefinitionIndex)","summary":"Replaces the underlying instance definition of an instance object.","since":"6.8","parameters":[{"name":"objref","summary":"Reference to the instance object to be replaced. The objref.Object() will be deleted."},{"name":"instanceDefinitionIndex","summary":"The index of the new instance definition to use."}],"returns":"True if successful."},{"signature":"bool Select(Guid objectId)","summary":"Select a single object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to select."}],"returns":"True on success, False on failure."},{"signature":"bool Select(Guid objectId, bool select)","summary":"Select or deselects a single object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to select."},{"name":"select","summary":"If true, the object will be selected, if false, it will be deselected."}],"returns":"True on success, False on failure."},{"signature":"bool Select(Guid objectId, bool select, bool syncHighlight)","summary":"Select or deselects a single object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to select."},{"name":"select","summary":"If true, the object will be selected, if false, it will be deselected."},{"name":"syncHighlight","summary":"If true, then the object is highlighted if it is selected and unhighlighted if is not selected."}],"returns":"True on success, False on failure."},{"signature":"bool Select(Guid objectId, bool select, bool syncHighlight, bool persistentSelect)","summary":"Select or deselects a single object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to select."},{"name":"select","summary":"If true, the object will be selected, if false, it will be deselected."},{"name":"syncHighlight","summary":"If true, then the object is highlighted if it is selected and unhighlighted if is not selected."},{"name":"persistentSelect","summary":"Objects that are persistently selected stay selected when a command terminates."}],"returns":"True on success, False on failure."},{"signature":"bool Select(Guid objectId, bool select, bool syncHighlight, bool persistentSelect, bool ignoreGripsState, bool ignoreLayerLocking, bool ignoreLayerVisibility)","summary":"Select or deselects a single object.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of object to select."},{"name":"select","summary":"If true, the object will be selected, if false, it will be deselected."},{"name":"syncHighlight","summary":"If true, then the object is highlighted if it is selected and unhighlighted if is not selected."},{"name":"persistentSelect","summary":"Objects that are persistently selected stay selected when a command terminates."},{"name":"ignoreGripsState","summary":"If true, then objects with grips on can be selected. If false, then the value returned by the object\'s IsSelectableWithGripsOn() function decides if the object can be selected when it has grips turned on."},{"name":"ignoreLayerLocking","summary":"If true, then objects on locked layers can be selected."},{"name":"ignoreLayerVisibility","summary":"If true, then objects on hidden layers can be selectable."}],"returns":"True on success, False on failure."},{"signature":"int Select(IEnumerable<Guid> objectIds)","summary":"Selects a collection of objects.","since":"5.0","parameters":[{"name":"objectIds","summary":"Ids of objects to select."}],"returns":"Number of objects successfully selected."},{"signature":"int Select(IEnumerable<Guid> objectIds, bool select)","summary":"Selects or deselects a collection of objects.","since":"5.0","parameters":[{"name":"objectIds","summary":"Ids of objects to select or deselect."},{"name":"select","summary":"If true, objects will be selected. If false, objects will be deselected."}],"returns":"Number of objects successfully selected or deselected."},{"signature":"int Select(IEnumerable<ObjRef> objRefs)","summary":"Selects a collection of objects.","since":"5.0","parameters":[{"name":"objRefs","summary":"References to objects to select."}],"returns":"Number of objects successfully selected."},{"signature":"int Select(IEnumerable<ObjRef> objRefs, bool select)","summary":"Selects or deselects a collection of objects.","since":"5.0","parameters":[{"name":"objRefs","summary":"References to objects to select or deselect."},{"name":"select","summary":"If true, objects will be selected. If false, objects will be deselected."}],"returns":"Number of objects successfully selected or deselected."},{"signature":"bool Select(ObjRef objref)","summary":"Select a single object.","since":"5.0","parameters":[{"name":"objref","summary":"Object represented by this ObjRef is selected."}],"returns":"True on success, False on failure."},{"signature":"bool Select(ObjRef objref, bool select)","summary":"Select or deselects a single object.","since":"5.0","parameters":[{"name":"objref","summary":"Object represented by this ObjRef is selected."},{"name":"select","summary":"If true, the object will be selected, if false, it will be deselected."}],"returns":"True on success, False on failure."},{"signature":"bool Select(ObjRef objref, bool select, bool syncHighlight)","summary":"Select or deselects a single object.","since":"5.0","parameters":[{"name":"objref","summary":"Object represented by this ObjRef is selected."},{"name":"select","summary":"If true, the object will be selected, if false, it will be deselected."},{"name":"syncHighlight","summary":"If true, then the object is highlighted if it is selected and unhighlighted if is not selected."}],"returns":"True on success, False on failure."},{"signature":"bool Select(ObjRef objref, bool select, bool syncHighlight, bool persistentSelect)","summary":"Select or deselects a single object.","since":"5.0","parameters":[{"name":"objref","summary":"Object represented by this ObjRef is selected."},{"name":"select","summary":"If true, the object will be selected, if false, it will be deselected."},{"name":"syncHighlight","summary":"If true, then the object is highlighted if it is selected and unhighlighted if is not selected."},{"name":"persistentSelect","summary":"Objects that are persistently selected stay selected when a command terminates."}],"returns":"True on success, False on failure."},{"signature":"bool Select(ObjRef objref, bool select, bool syncHighlight, bool persistentSelect, bool ignoreGripsState, bool ignoreLayerLocking, bool ignoreLayerVisibility)","summary":"Select or deselects a single object.","since":"5.0","parameters":[{"name":"objref","summary":"Object represented by this ObjRef is selected."},{"name":"select","summary":"If true, the object will be selected, if false, it will be deselected."},{"name":"syncHighlight","summary":"If true, then the object is highlighted if it is selected and unhighlighted if is not selected."},{"name":"persistentSelect","summary":"Objects that are persistently selected stay selected when a command terminates."},{"name":"ignoreGripsState","summary":"If true, then objects with grips on can be selected. If false, then the value returned by the object\'s IsSelectableWithGripsOn() function decides if the object can be selected when it has grips turned on."},{"name":"ignoreLayerLocking","summary":"If true, then objects on locked layers can be selected."},{"name":"ignoreLayerVisibility","summary":"If true, then objects on hidden layers can be selectable."}],"returns":"True on success, False on failure."},{"signature":"bool Show(Guid objectId, bool ignoreLayerMode)","summary":"If Object().IsHidden() is true, then the object will be returned to normal (visible and selectable) mode.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of the normal object to show."},{"name":"ignoreLayerMode","summary":"if true, the object will be shown even if it is on a layer that is locked or off."}],"returns":"True if the object was successfully shown."},{"signature":"bool Show(ObjRef objref, bool ignoreLayerMode)","summary":"If objref.Object().IsHidden() is true, then the object will be returned to normal (visible and selectable) mode.","since":"5.0","parameters":[{"name":"objref","summary":"reference to normal object to show."},{"name":"ignoreLayerMode","summary":"if true, the object will be shown even if it is on a layer that is locked or off."}],"returns":"True if the object was successfully shown."},{"signature":"bool Show(RhinoObject obj, bool ignoreLayerMode)","summary":"If obj.IsHidden() is true, then the object will be returned to normal (visible and selectable) mode.","since":"5.0","parameters":[{"name":"obj","summary":"the normal object to show."},{"name":"ignoreLayerMode","summary":"if true, the object will be shown even if it is on a layer that is locked or off."}],"returns":"True if the object was successfully shown."},{"signature":"Guid Transform(Guid objectId, Transform xform, bool deleteOriginal)","summary":"Constructs a new object that is the transformation of the existing object and deletes the existing object if deleteOriginal is true.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of rhino object to transform. This object will be deleted if deleteOriginal is true."},{"name":"xform","summary":"transformation to apply."},{"name":"deleteOriginal","summary":"if true, the original object is deleted if false, the original object is not deleted."}],"returns":"Id of the new object that is the transformation of the existing_object. The new object has identical attributes."},{"signature":"Guid Transform(ObjRef objref, Transform xform, bool deleteOriginal)","summary":"Constructs a new object that is the transformation of the existing object and deletes the existing object if deleteOriginal is true.","since":"5.0","parameters":[{"name":"objref","summary":"reference to object to transform. The objref.Object() will be deleted if deleteOriginal is true."},{"name":"xform","summary":"transformation to apply."},{"name":"deleteOriginal","summary":"if true, the original object is deleted if false, the original object is not deleted."}],"returns":"Id of the new object that is the transformation of the existing_object. The new object has identical attributes."},{"signature":"Guid Transform(RhinoObject obj, Transform xform, bool deleteOriginal)","summary":"Constructs a new object that is the transformation of the existing object and deletes the existing object if deleteOriginal is true.","since":"5.0","parameters":[{"name":"obj","summary":"Rhino object to transform. This object will be deleted if deleteOriginal is true."},{"name":"xform","summary":"transformation to apply."},{"name":"deleteOriginal","summary":"if true, the original object is deleted if false, the original object is not deleted."}],"returns":"Id of the new object that is the transformation of the existing_object. The new object has identical attributes."},{"signature":"Guid TransformWithHistory(Guid objectId, Transform xform)","summary":"Constructs a new object that is the transformation of the existing object and records history of the transformation if history recording is turned on. If history recording is not enabled, this function will act the same as Transform(objectId, xform, false)","since":"5.0","parameters":[{"name":"objectId","summary":"Id of rhino object to transform."},{"name":"xform","summary":"transformation to apply."}],"returns":"Id of the new object that is the transformation of the existing_object. The new object has identical attributes."},{"signature":"Guid TransformWithHistory(ObjRef objref, Transform xform)","summary":"Constructs a new object that is the transformation of the existing object and records history of the transformation if history recording is turned on. If history recording is not enabled, this function will act the same as Transform(objref, xform, false)","since":"5.0","parameters":[{"name":"objref","summary":"reference to object to transform."},{"name":"xform","summary":"transformation to apply."}],"returns":"Id of the new object that is the transformation of the existing_object. The new object has identical attributes."},{"signature":"Guid TransformWithHistory(RhinoObject obj, Transform xform)","summary":"Constructs a new object that is the transformation of the existing object and records history of the transformation if history recording is turned on. If history recording is not enabled, this function will act the same as Transform(obj, xform, false)","since":"5.0","parameters":[{"name":"obj","summary":"Rhino object to transform."},{"name":"xform","summary":"transformation to apply."}],"returns":"Id of the new object that is the transformation of the existing_object. The new object has identical attributes."},{"signature":"bool TryFindPoint(Guid id, out Point3d point)","summary":"Finds the location of a point, if a point exists in the document.","since":"6.0","parameters":[{"name":"id","summary":"ID of point object to search for."},{"name":"point","summary":"The point will be passed here."}],"returns":"True on success; False if point was not found, id represented another geometry type, or on error."},{"signature":"bool Undelete(RhinoObject rhinoObject)","since":"5.0"},{"signature":"bool Undelete(uint runtimeSerialNumber)","since":"5.0"},{"signature":"bool Unlock(Guid objectId, bool ignoreLayerMode)","summary":"If Object().IsLocked() is true, then the object will be returned to normal (visible and selectable) mode.","since":"5.0","parameters":[{"name":"objectId","summary":"Id of locked object to unlock."},{"name":"ignoreLayerMode","summary":"if true, the object will be unlocked even if it is on a layer that is locked or off."}],"returns":"True if the object was successfully unlocked."},{"signature":"bool Unlock(ObjRef objref, bool ignoreLayerMode)","summary":"If objref.Object().IsLocked() is true, then the object will be returned to normal (visible and selectable) mode.","since":"5.0","parameters":[{"name":"objref","summary":"reference to locked object to unlock."},{"name":"ignoreLayerMode","summary":"if true, the object will be unlocked even if it is on a layer that is locked or off."}],"returns":"True if the object was successfully unlocked."},{"signature":"bool Unlock(RhinoObject obj, bool ignoreLayerMode)","summary":"If obj.IsLocked() is true, then the object will be returned to normal (visible and selectable) mode.","since":"5.0","parameters":[{"name":"obj","summary":"locked object to unlock."},{"name":"ignoreLayerMode","summary":"if true, the object will be unlocked even if it is on a layer that is locked or off."}],"returns":"True if the object was successfully unlocked."},{"signature":"int UnselectAll()","summary":"Unselect objects.","since":"5.0","returns":"Number of object that were unselected."},{"signature":"int UnselectAll(bool ignorePersistentSelections)","summary":"Unselect objects.","since":"5.0","parameters":[{"name":"ignorePersistentSelections","summary":"if true, then objects that are persistently selected will not be unselected."}],"returns":"Number of object that were unselected."}]},{"namespace":"Rhino.DocObjects.Tables","name":"RestoreLayerProperties","dataType":"enum","since":"6.14","values":[{"signature":"None = 0x0","summary":"Restore nothing"},{"signature":"Current = 0x1","summary":"Restore current layer"},{"signature":"Visible = 0x2","summary":"Restore layer visibility"},{"signature":"Locked = 0x4","summary":"Restore layer locked status"},{"signature":"Color = 0x8","summary":"Restore layer color"},{"signature":"Linetype = 0x10","summary":"Restore layer linetype"},{"signature":"PrintColor = 0x20","summary":"Restore layer print color"},{"signature":"PrintWidth = 0x40","summary":"Restore layer print width"},{"signature":"ViewportVisible = 0x80","summary":"Restore per-viewport layer visibility"},{"signature":"ViewportColor = 0x100","summary":"Restore per-viewport layer color"},{"signature":"ViewportPrintColor = 0x200","summary":"Restore per-viewport layer print color"},{"signature":"ViewportPrintWidth = 0x400","summary":"Restore per-viewport layer print width"},{"signature":"RenderMaterial = 0x800","summary":"Restore render material"},{"signature":"Unused = 0x1000","summary":"Unused flag"},{"signature":"All = 0xFFFFFFFF","summary":"Restore all layer properties"}]},{"namespace":"Rhino.DocObjects.Tables","name":"RhinoDocCommonTable<T>","dataType":"class","baseclass":"Rhino.FileIO.CommonComponentTable<T>","properties":[{"signature":"RhinoDoc Document","summary":"Document that owns this table.","property":["get"]}]},{"namespace":"Rhino.DocObjects.Tables","name":"RuntimeDocumentDataTable","dataType":"class","summary":"Collection of document runtime data. This is a good place to put non-serialized, per document data.","baseclass":"Dictionary<object, object>","properties":[{"signature":"RhinoDoc Document","since":"6.3","property":["get"]}],"methods":[{"signature":"T GetValue(object key, Func<RhinoDoc, T> newT)","summary":"Checks the dictionary for the specified key, if found and the value is not None then the value is returned.  If the key is not found or its value is None then newT(Document) is called to create a new value instance which is put in the dictionary and returned.","parameters":[{"name":"key","summary":"Key to search for."},{"name":"newT","summary":"Function called to create new value"}],"returns":"Returns the document specific instance of type T using the specified dictionary key."},{"signature":"T TryGetValue(object key)","summary":"Check dictionary for value and return it properly cast if found.","since":"6.15","parameters":[{"name":"key","summary":"Key to search for."}],"returns":"Returns the document specific instance of type T using the specified dictionary key or None if not found."}]},{"namespace":"Rhino.DocObjects.Tables","name":"SnapshotTable","dataType":"class","summary":"All snapshots in a rhino document.","properties":[{"signature":"RhinoDoc Document","summary":"Document that owns this table.","since":"6.7","property":["get"]},{"signature":"string[] Names","summary":"Array of Snapshot names.","since":"6.7","property":["get"]}]},{"namespace":"Rhino.DocObjects.Tables","name":"StringTable","dataType":"class","summary":"Collection of document user data strings","properties":[{"signature":"int Count","summary":"The number of user data strings in the current document.","since":"5.0","property":["get"]},{"signature":"RhinoDoc Document","summary":"Document that owns this object table.","since":"5.0","property":["get"]},{"signature":"int DocumentDataCount","since":"6.0","property":["get"]},{"signature":"int DocumentUserTextCount","since":"6.0","property":["get"]}],"methods":[{"signature":"void Delete(string key)","since":"5.0"},{"signature":"void Delete(string section, string entry)","summary":"Removes user data strings from the document.","since":"5.0","parameters":[{"name":"section","summary":"name of section to delete. If null, all sections will be deleted."},{"name":"entry","summary":"name of entry to delete. If null, all entries will be deleted for a given section."}]},{"signature":"string[] GetEntryNames(string section)","summary":"Return list of all entry names for a given section of user data strings in the document.","since":"5.0","parameters":[{"name":"section","summary":"The section from which to retrieve section names."}],"returns":"An array of section names. This can be empty, but not null."},{"signature":"string GetKey(int i)","since":"5.0"},{"signature":"string[] GetSectionNames()","summary":"Returns a list of all the section names for user data strings in the document.  \\nBy default a section name is a key that is prefixed with a string separated by a backslash.","since":"5.0","returns":"An array of section names. This can be empty, but not null."},{"signature":"string GetValue(int i)","since":"5.0"},{"signature":"string GetValue(string key)","since":"5.0"},{"signature":"string GetValue(string section, string entry)","summary":"Gets a user data string from the document.","since":"5.0","parameters":[{"name":"section","summary":"The section at which to get the value."},{"name":"entry","summary":"The entry to search for."}],"returns":"The user data."},{"signature":"string SetString(string key, string value)","summary":"Adds or sets a user data string to the document.","since":"5.0","parameters":[{"name":"key","summary":"The key."},{"name":"value","summary":"The entry value."}],"returns":"The previous value if successful and a previous value existed."},{"signature":"string SetString(string section, string entry, string value)","summary":"Adds or sets a user data string to the document.","since":"5.0","parameters":[{"name":"section","summary":"The section."},{"name":"entry","summary":"The entry name."},{"name":"value","summary":"The entry value."}],"returns":"The previous value if successful and a previous value existed."}]},{"namespace":"Rhino.DocObjects.Tables","name":"ViewTable","dataType":"class","interfaces":["IEnumerable<RhinoView>"],"properties":[{"signature":"RhinoView ActiveView","summary":"Gets or Sets the active view.","since":"5.0","property":["get","set"]},{"signature":"RhinoDoc Document","summary":"Document that owns this object table.","since":"5.0","property":["get"]},{"signature":"bool ModelSpaceIsActive","since":"5.0","property":["get"]},{"signature":"bool RedrawEnabled","summary":"Returns or sets (enable or disables) screen redrawing.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"RhinoView Add(string title, DefinedViewportProjection projection, Rectangle position, bool floating)","summary":"Constructs a new Rhino view and, at the same time, adds it to the list.","since":"5.0","parameters":[{"name":"title","summary":"The title of the new Rhino view."},{"name":"projection","summary":"A basic projection type."},{"name":"position","summary":"A position."},{"name":"floating","summary":"True if the view floats; False if it is docked."}],"returns":"The newly constructed Rhino view; or None on error."},{"signature":"RhinoPageView AddPageView(string title)","summary":"Constructs a new page view with a given title and, at the same time, adds it to the list.","since":"5.0","parameters":[{"name":"title","summary":"If None or empty, a name will be generated as \\"Page #\\" where # is the largest page number."}],"returns":"The newly created page view on success; or None on error."},{"signature":"RhinoPageView AddPageView(string title, double pageWidth, double pageHeight)","summary":"Constructs a new page view with a given title and size and, at the same time, adds it to the list.","since":"5.0","parameters":[{"name":"title","summary":"If None or empty, a name will be generated as \\"Page #\\" where # is the largest page number."},{"name":"pageWidth","summary":"The page total width."},{"name":"pageHeight","summary":"The page total height."}],"returns":"The newly created page view on success; or None on error."},{"signature":"void DefaultViewLayout()","since":"5.0"},{"signature":"void EnableCameraIcon(RhinoView view)","summary":"Use to turn camera icon on and off","since":"6.0","parameters":[{"name":"view","summary":"If null, any camera icon is turned off. If not null, the camera icon for that view is turned on."}]},{"signature":"RhinoView Find(Guid mainViewportId)","summary":"Finds a view in this document with a given main viewport Id.","since":"5.0","parameters":[{"name":"mainViewportId","summary":"The ID of the main viewport looked for."}],"returns":"View on success. None if the view could not be found in this document."},{"signature":"RhinoView Find(string mainViewportName, bool compareCase)","summary":"Finds a view in this document with a main viewport that has a given name. Note that there may be multiple views in this document that have the same name. This function only returns the first view found. If you want to find all the views with a given name, use the GetViewList function and iterate through the views.","since":"5.0","parameters":[{"name":"mainViewportName","summary":"The name of the main viewport."},{"name":"compareCase","summary":"True if capitalization influences comparison; otherwise, false."}],"returns":"A Rhino view on success; None on error."},{"signature":"void FlashObjects(IEnumerable<RhinoObject> list, bool useSelectionColor)","summary":"Cause objects selection state to change momentarily so the object appears to flash on the screen.","since":"5.0","parameters":[{"name":"list","summary":"An array, a list or any enumerable set of Rhino objects."},{"name":"useSelectionColor","summary":"If true, flash between object color and selection color. If false, flash between visible and invisible."}]},{"signature":"void FourViewLayout(bool useMatchingViews)","since":"5.0"},{"signature":"IEnumerator<RhinoView> GetEnumerator()","since":"5.0"},{"signature":"RhinoPageView[] GetPageViews()","summary":"Gets all page views in the document.","since":"5.0","returns":"An array with all page views. The return value can be an empty array but not null."},{"signature":"RhinoView[] GetStandardRhinoViews()","since":"5.0"},{"signature":"RhinoView[] GetViewList(bool includeStandardViews, bool includePageViews)","summary":"Gets an array of all the views.","since":"5.0","parameters":[{"name":"includeStandardViews","summary":"True if \\"Right\\", \\"Perspective\\", etc., view should be included; False otherwise."},{"name":"includePageViews","summary":"True if page-related views should be included; False otherwise."}],"returns":"A array of Rhino views. This array can be empty, but not null."},{"signature":"bool IsCameraIconVisible(RhinoView view)","summary":"Determine if a camera icon is being shown","since":"6.0","parameters":[{"name":"view","summary":"if null, then all views are tested. If not null, then just view is tested."}]},{"signature":"void Redraw()","summary":"Redraws all views.","since":"5.0"},{"signature":"void ThreeViewLayout(bool useMatchingViews)","since":"5.0"}]},{"namespace":"Rhino.DocObjects","name":"TextDisplayAlignment","dataType":"enum","summary":"Defines enumerated values for the line alignment of text.","since":"5.0","values":[{"signature":"Normal = 0","summary":"Normal alignment."},{"signature":"Horizontal = 1","summary":"Horizontal alignment."},{"signature":"AboveLine = 2","summary":"Above line alignment."},{"signature":"InLine = 3","summary":"In line alignment."}]},{"namespace":"Rhino.DocObjects","name":"TextDotObject","dataType":"class","summary":"Represents a text dot that is a document.","baseclass":"Rhino.DocObjects.RhinoObject"},{"namespace":"Rhino.DocObjects","name":"TextHorizontalAlignment","dataType":"enum","summary":"Horizontal location of text attach point relative to text","values":[{"signature":"Left = 0","summary":"Attach at left of text lines (Independent of glyphs being displayed.)"},{"signature":"Center = 1","summary":"Attach point at center of text horizontal advance (not glyph bounding box)"},{"signature":"Right = 2","summary":"Attach point at right text horizontal advance (not glyph bounding box)"},{"signature":"Auto = 3","summary":"Used for Leaders only Attach point adjusts to Right or Left depending on leader tail direction in view If tail direction is to the Left, alignment is Right If tail direction is to the Right, alignment is Left"}]},{"namespace":"Rhino.DocObjects","name":"TextObject","dataType":"class","summary":"Rhino Object that represents text geometry and attributes","baseclass":"Rhino.DocObjects.AnnotationObjectBase","properties":[{"signature":"TextEntity TextGeometry","summary":"Get the text geometry for this object.","since":"5.0","property":["get"]}]},{"namespace":"Rhino.DocObjects","name":"TextOrientation","dataType":"enum","summary":"Method for getting rotation for drawing text","values":[{"signature":"InPlane = 0","summary":"Text has fixed rotation on a world coordinate plane"},{"signature":"InView = 1","summary":"Text is drawn on a plane perpendicular to view direction horizontal to the screen"}]},{"namespace":"Rhino.DocObjects","name":"Texture","dataType":"class","summary":"Represents a texture that is mapped on objects.","baseclass":"Rhino.Runtime.CommonObject","constructors":[{"signature":"Texture()","summary":"Initializes a new texture.","since":"5.0"}],"properties":[{"signature":"bool ApplyUvwTransform","summary":"If True then the UVW transform is applied to the texture otherwise the UVW transform is ignored.","since":"5.6","property":["get","set"]},{"signature":"bool Enabled","summary":"If the texture is enabled then it will be visible in the rendered display otherwise it will not.","since":"5.0","property":["get","set"]},{"signature":"string FileName","summary":"Gets or sets a file name that is used by this texture.  \\nNOTE: We are moving away from string-based FileName, and suggest the usage of the new FileReference class.  \\nAlso, this filename may well not be a path that makes sense on a user\'s computer because it was a path initially set on a different user\'s computer. If you want to get a workable path for this user, use the BitmapTable.Find function using this property.","since":"5.0","property":["get","set"]},{"signature":"FileReference FileReference","summary":"Gets or sets a copy of the file reference that is used by this texture. After the get or the set method complete, you own the copy you received or passed in, and can Dispose() of it.","since":"6.0","property":["get","set"]},{"signature":"Guid Id","summary":"Gets the globally unique identifier of this texture.","since":"5.0","property":["get"]},{"signature":"int MappingChannelId","since":"5.10","property":["get"]},{"signature":"TextureCombineMode TextureCombineMode","summary":"Determines how this texture is combined with others in a material\'s texture list.","since":"5.6","property":["get","set"]},{"signature":"TextureType TextureType","summary":"Controls how the pixels in the bitmap are interpreted","since":"5.6","property":["get","set"]},{"signature":"Transform UvwTransform","summary":"Transform to be applied to each instance of this texture if ApplyUvw is true","since":"5.6","property":["get","set"]},{"signature":"TextureUvwWrapping WrapU","summary":"Texture wrapping mode in the U direction","since":"5.6","property":["get","set"]},{"signature":"TextureUvwWrapping WrapV","summary":"Texture wrapping mode in the V direction","since":"5.6","property":["get","set"]},{"signature":"TextureUvwWrapping WrapW","summary":"Texture wrapping mode in the W direction","since":"5.6","property":["get","set"]}],"methods":[{"signature":"void GetAlphaBlendValues(out double constant, out double a0, out double a1, out double a2, out double a3)","summary":"If the TextureCombineMode is Blend, then the blending function for alpha is determined by  \\nnew alpha = constant + a0*(current alpha) + a1*(texture alpha) + a2*min(current alpha,texture alpha) + a3*max(current alpha,texture alpha)","since":"5.6"},{"signature":"void SetAlphaBlendValues(double constant, double a0, double a1, double a2, double a3)","summary":"If the TextureCombineMode is Blend, then the blending function for alpha is determined by  \\nnew alpha = constant + a0*(current alpha) + a1*(texture alpha) + a2*min(current alpha,texture alpha) + a3*max(current alpha,texture alpha)","since":"5.6"},{"signature":"void SetRGBBlendValues(Color color, double a0, double a1, double a2, double a3)","summary":"If the TextureCombineMode is Blend, then the blending function for RGB is determined by  \\nnew rgb = colorcolor + a0[0]*(current RGB) + a1[1]*(texture RGB) + a2[2]*min(current RGB,texture RGB) + a3[3]*max(current RGB,texture RGB)","since":"6.0"}]},{"namespace":"Rhino.DocObjects","name":"TextureCombineMode","dataType":"enum","summary":"Determines how this texture is combined with others in a material\'s texture list.","since":"5.6","values":[{"signature":"None = 0"},{"signature":"Modulate = 1","summary":"Modulate with material diffuse color"},{"signature":"Decal = 2","summary":"Decal"},{"signature":"Blend = 3","summary":"Blend texture with others in the material To \\"add\\" a texture, set BlendAmount = +1 To \\"subtract\\" a texture, set BlendAmount = -1"}]},{"namespace":"Rhino.DocObjects","name":"TextureType","dataType":"enum","summary":"The TextureType controls how the pixels in the bitmap are interpreted.","since":"5.6","values":[{"signature":"None = 0"},{"signature":"Bitmap = 1","summary":"Deprecated - this should be diffuse"},{"signature":"Diffuse = 1","summary":"The diffuse color of the material, ideally the albedo."},{"signature":"Bump = 2","summary":"bump map"},{"signature":"Transparency = 3","summary":"Deprecated - see Opacity.  This has always actually meant opacity in Rhino, so there is nothing to change."},{"signature":"Opacity = 3","summary":"value = alpha"},{"signature":"Emap = 4","summary":"Emap/Environment texture"},{"signature":"PBR_BaseColor = 1","summary":"Physically based materials only - base color.  Re-uses diffuse texture slot."},{"signature":"PBR_Subsurface = 10","summary":"Physically based materials only - subsurface (greyscale)"},{"signature":"PBR_SubsurfaceScattering = 11","summary":"Physically based materials only - subsurface scattering"},{"signature":"PBR_SubsurfaceScatteringRadius = 12","summary":"Physically based materials only - subsurface scattering radius (greyscale)"},{"signature":"PBR_Metallic = 13","summary":"Physically based materials only - metallic (greyscale)"},{"signature":"PBR_Specular = 14","summary":"Physically based materials only - specular (greyscale)"},{"signature":"PBR_SpecularTint = 15","summary":"Physically based materials only - specular tint (greyscale)"},{"signature":"PBR_Roughness = 16","summary":"Physically based materials only - roughness (greyscale)"},{"signature":"PBR_Anisotropic = 17","summary":"Physically based materials only - anisotropic (greyscale)"},{"signature":"PBR_Anisotropic_Rotation = 18","summary":"Physically based materials only - anisotropic rotation 0 = 0, 255 = 360"},{"signature":"PBR_Sheen = 19","summary":"Physically based materials only - sheen (greyscale)"},{"signature":"PBR_SheenTint = 20","summary":"Physically based materials only - sheen tint (greyscale)"},{"signature":"PBR_Clearcoat = 21","summary":"Physically based materials only - clearcoat (greyscale)"},{"signature":"PBR_ClearcoatRoughness = 22","summary":"Physically based materials only - clearcoat roughness (greyscale)"},{"signature":"PBR_OpacityIor = 23","summary":"Physically based materials only - ior (greyscale - remaps from 1.0 to 2.0)"},{"signature":"PBR_OpacityRoughness = 24","summary":"Physically based materials only - transparency roughness (greyscale)"},{"signature":"PBR_Emission = 25","summary":"Physically based materials only - emission (greyscale)"},{"signature":"PBR_AmbientOcclusion = 26","summary":"Physically based materials only - occlusion (greyscale)"},{"signature":"PBR_Displacement = 28","summary":"Physically based materials only - normal 8-bit RGB, alpha is ignored"},{"signature":"PBR_ClearcoatBump = 29","summary":"Physically based materials only - clearcoat normal  or bump (normal map, RGB)"}]},{"namespace":"Rhino.DocObjects","name":"TextureUvwWrapping","dataType":"enum","summary":"Defines Texture UVW wrapping modes","since":"5.6","values":[{"signature":"Repeat = 0","summary":"Repeat the texture"},{"signature":"Clamp = 1","summary":"Clamp the texture"}]},{"namespace":"Rhino.DocObjects","name":"TextVerticalAlignment","dataType":"enum","summary":"Vertical location of text attach point relative to text","values":[{"signature":"Top = 0","summary":"Attach to top of an \\"I\\" on the first line. (Independent of glyphs being displayed.)"},{"signature":"MiddleOfTop = 1","summary":"Attach to middle of an \\"I\\" on the first line. (Independent of glyphs being displayed.)"},{"signature":"BottomOfTop = 2","summary":"Attach to baseline of first line. (Independent of glyphs being displayed.)"},{"signature":"Middle = 3","summary":"Attach to middle of text vertical advance. (Independent of glyphs being displayed.)"},{"signature":"MiddleOfBottom = 4","summary":"Attach to middle of an \\"I\\" on the last line. (Independent of glyphs being displayed.)"},{"signature":"Bottom = 5","summary":"Attach to the basline of the last line. (Independent of glyphs being displayed.)"},{"signature":"BottomOfBoundingBox = 6","summary":"Attach to the bottom of the boudning box of the visible glyphs."}]},{"namespace":"Rhino.DocObjects","name":"ViewInfo","dataType":"class","summary":"Represents the name and orientation of a View (and named view).  \\nviews can be thought of as cameras.","interfaces":["IDisposable"],"constructors":[{"signature":"ViewInfo(RhinoViewport rhinoViewPort)","summary":"Access to the ViewInfo for given RhinoViewport","since":"6.0"},{"signature":"ViewInfo(uint docRuntimeSerialNumber)","summary":"Construct the ViewInfo for active viewport of given doc.","since":"6.0","parameters":[{"name":"docRuntimeSerialNumber","summary":"Runtime serial number of the document to query for the active viewport"}]}],"properties":[{"signature":"double FocalBlurAperture","summary":"Gets or sets the Focal blur aperture of the active viewport","since":"6.0","property":["get","set"]},{"signature":"double FocalBlurDistance","summary":"Gets or sets the Focal blur distance of the active viewport","since":"6.0","property":["get","set"]},{"signature":"double FocalBlurJitter","summary":"Gets or sets the Focal blur jitter of the active viewport","since":"6.0","property":["get","set"]},{"signature":"ViewInfoFocalBlurModes FocalBlurMode","summary":"Gets or sets the Focal blur mode of the active viewport","since":"6.0","property":["get","set"]},{"signature":"uint FocalBlurSampleCount","summary":"Gets or sets the Focal blur sample count of the active viewport","since":"6.0","property":["get","set"]},{"signature":"string Name","summary":"Gets or sets the name of the view.","since":"5.0","property":["get","set"]},{"signature":"bool ShowWallpaperInGrayScale","summary":"True if wallpaper (if any) is to be shown in gray scale in this view.","since":"6.0","property":["get"]},{"signature":"ViewportInfo Viewport","summary":"Gets the viewport, or viewing frustum, associated with this view.","since":"5.0","property":["get"]},{"signature":"string WallpaperFilename","summary":"Get filename for wallpaper set to this view, if any.","since":"6.0","property":["get"]},{"signature":"bool WallpaperHidden","summary":"True if wallpaper (if any) is to be hidden from this view.","since":"6.0","property":["get"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"}]},{"namespace":"Rhino.DocObjects","name":"ViewInfoFocalBlurModes","dataType":"enum","summary":"The different focal blur modes of the ViewInfo","since":"6.0","values":[{"signature":"None","summary":"No focal blur"},{"signature":"Automatic","summary":"Auto-focus on selected objects"},{"signature":"Manual","summary":"Fully manual focus"}]},{"namespace":"Rhino.DocObjects","name":"ViewportInfo","dataType":"class","summary":"Represents a viewing frustum.","baseclass":"Rhino.Runtime.CommonObject","constructors":[{"signature":"ViewportInfo()","summary":"Initializes a new instance.","since":"5.0"},{"signature":"ViewportInfo(RhinoViewport rhinoViewport)","summary":"Copies all of the ViewportInfo data from an existing RhinoViewport.","since":"5.0","parameters":[{"name":"rhinoViewport","summary":"A viewport to copy."}]},{"signature":"ViewportInfo(ViewportInfo other)","summary":"Initializes a new instance by copying values from another instance.","since":"5.0","parameters":[{"name":"other","summary":"The other viewport info."}]}],"properties":[{"signature":"static Vector3d DefaultCameraDirection","summary":"Default z=up perspective camera direction","since":"6.0","property":["get"]},{"signature":"double Camera35mmLensLength","summary":"This property assumes the camera is horizontal and crop the film rather than the image when the aspect of the frustum is not 36/24.  (35mm film is 36mm wide and 24mm high.) Setting preserves camera location, changes the frustum, but maintains the frustum\'s aspect.","since":"5.0","property":["get","set"]},{"signature":"double CameraAngle","summary":"Gets or sets the 1/2 smallest angle. See GetCameraAnglesfor more information.","since":"5.0","property":["get","set"]},{"signature":"Vector3d CameraDirection","summary":"Gets the direction that the camera faces.","since":"5.0","property":["get"]},{"signature":"Point3d CameraLocation","summary":"Gets the camera location (position) point.","since":"5.0","property":["get"]},{"signature":"Vector3d CameraUp","summary":"Gets the camera up vector.","since":"5.0","property":["get"]},{"signature":"Vector3d CameraX","summary":"Gets the unit \\"to the right\\" vector.","since":"5.0","property":["get"]},{"signature":"Vector3d CameraY","summary":"Gets the unit \\"up\\" vector.","since":"5.0","property":["get"]},{"signature":"Vector3d CameraZ","summary":"Gets the unit vector in -CameraDirection.","since":"5.0","property":["get"]},{"signature":"double FrustumAspect","summary":"Setting FrustumAspect changes the larger of the frustum\'s width/height so that the resulting value of width/height matches the requested aspect.  The camera angle is not changed.  If you change the shape of the view port with a call SetScreenPort(), then you generally want to call SetFrustumAspect() with the value returned by GetScreenPortAspect().","since":"5.0","property":["get","set"]},{"signature":"double FrustumBottom","summary":"Gets the frustum bottom value. This is -top if the frustum has a horizontal symmetry axis.  \\nThis number is usually negative.","since":"5.0","property":["get"]},{"signature":"Plane FrustumBottomPlane","summary":"Gets the frustum bottom plane that separates visible from off-screen.","since":"5.0","property":["get"]},{"signature":"Point3d FrustumCenter","summary":"Gets the frustum center point.","since":"5.0","property":["get"]},{"signature":"double FrustumFar","summary":"Gets the frustum far-cutting value.","since":"5.0","property":["get"]},{"signature":"Plane FrustumFarPlane","summary":"Gets far clipping plane if camera and frustum are valid.  The plane\'s frame is the same as the camera\'s frame.  The origin is located at the intersection of the camera direction ray and the far clipping plane. The plane\'s normal points into the frustum towards the camera location.","since":"5.0","property":["get"]},{"signature":"double FrustumHeight","summary":"Gets the frustum height. This is FrustumTop- FrustumBottom.","since":"5.0","property":["get"]},{"signature":"double FrustumLeft","summary":"Gets the frustum left value. This is -right if the frustum has a vertical symmetry axis.  \\nThis number is usually negative.","since":"5.0","property":["get"]},{"signature":"Plane FrustumLeftPlane","summary":"Gets the frustum left plane that separates visible from off-screen.","since":"5.0","property":["get"]},{"signature":"double FrustumMaximumDiameter","summary":"Gets the frustum maximum diameter, or the maximum between FrustumWidthand FrustumHeight.","since":"5.0","property":["get"]},{"signature":"double FrustumMinimumDiameter","summary":"Gets the frustum minimum diameter, or the minimum between FrustumWidthand FrustumHeight.","since":"5.0","property":["get"]},{"signature":"double FrustumNear","summary":"Gets the frustum near-cutting value.","since":"5.0","property":["get"]},{"signature":"Plane FrustumNearPlane","summary":"Gets near clipping plane if camera and frustum are valid.  The plane\'s frame is the same as the camera\'s frame.  The origin is located at the intersection of the camera direction ray and the near clipping plane. The plane\'s normal points out of the frustum towards the camera location.","since":"5.0","property":["get"]},{"signature":"double FrustumRight","summary":"Gets the frustum right value. This is -left if the frustum has a vertical symmetry axis.  \\nThis number is usually positive.","since":"5.0","property":["get"]},{"signature":"Plane FrustumRightPlane","summary":"Gets the frustum right plane that separates visible from off-screen.","since":"5.0","property":["get"]},{"signature":"double FrustumTop","summary":"Gets the frustum top value. This is -bottom if the frustum has a horizontal symmetry axis.  \\nThis number is usually positive.","since":"5.0","property":["get"]},{"signature":"Plane FrustumTopPlane","summary":"Gets the frustum top plane that separates visible from off-screen.","since":"5.0","property":["get"]},{"signature":"double FrustumWidth","summary":"Gets the frustum width. This is FrustumRight- FrustumLeft.","since":"5.0","property":["get"]},{"signature":"Guid Id","summary":"Sets the viewport\'s id to the value used to uniquely identify this viewport. There is no approved way to change the viewport id once it is set in order to maintain consistency across multiple viewports and those routines that manage them.","since":"5.0","property":["get"]},{"signature":"bool IsCameraDirectionLocked","summary":"Gets or sets a value that indicates whether the direction that the camera faces is unmodifiable.","since":"5.0","property":["get","set"]},{"signature":"bool IsCameraLocationLocked","summary":"Gets or sets a value that indicates whether the camera location is unmodifiable.","since":"5.0","property":["get","set"]},{"signature":"bool IsCameraUpLocked","summary":"Gets or sets a value that indicates whether the camera up vector is unmodifiable.","since":"5.0","property":["get","set"]},{"signature":"bool IsFrustumLeftRightSymmetric","summary":"Gets or sets a value that indicates whether the camera frustum has a vertical symmetry axis.","since":"5.0","property":["get","set"]},{"signature":"bool IsFrustumTopBottomSymmetric","summary":"Gets or sets a value that indicates whether the camera frustum has a horizontal symmetry axis.","since":"5.0","property":["get","set"]},{"signature":"bool IsParallelProjection","summary":"Get or set whether this projection is parallel.","since":"5.0","property":["get","set"]},{"signature":"bool IsPerspectiveProjection","summary":"Get or set whether this projection is perspective.","since":"5.0","property":["get","set"]},{"signature":"bool IsTwoPointPerspectiveProjection","summary":"Gets a value that indicates whether this projection is a two-point perspective.","since":"5.0","property":["get"]},{"signature":"bool IsValidCamera","summary":"Gets a value that indicates whether the camera is valid.","since":"5.0","property":["get"]},{"signature":"bool IsValidFrustum","summary":"Gets a value that indicates whether the frustum is valid.","since":"5.0","property":["get"]},{"signature":"double PerspectiveMinNearDist","summary":"Expert user function to control the minimum value of near when perspective projections are being used.","since":"7.0","property":["get","set"]},{"signature":"double PerspectiveMinNearOverFar","summary":"Expert user function to control the minimum ratio of near/far when perspective projections are begin used.","since":"7.0","property":["get","set"]},{"signature":"Rectangle ScreenPort","summary":"Get or set the screen port. SetScreenPort(System.Drawing.Rectangle)and GetScreenPort()","since":"6.0","property":["get","set"]},{"signature":"double ScreenPortAspect","summary":"Gets the screen aspect ratio.  \\nThis is width / height.","since":"5.0","property":["get"]},{"signature":"Point3d TargetPoint","summary":"The current value of the target point.  This point does not play a role in the view projection calculations.  It can be used as a fixed point when changing the camera so the visible regions of the before and after frustums both contain the region of interest. The default constructor sets this point on ON_3dPoint::UnsetPoint. You must explicitly call one SetTargetPoint() functions to set the target point.","since":"5.0","property":["get","set"]},{"signature":"SizeF ViewScale","summary":"Applies scaling factors to parallel projection clipping coordinates by setting the m_clip_mod transformation. If you want to compress the view projection across the viewing plane, then set x = 0.5, y = 1.0, and z = 1.0.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static double CalculateCameraRotationAngle(Vector3d direction, Vector3d up)","summary":"Calculates the camera rotation angle.","since":"6.8","parameters":[{"name":"direction","summary":"The camera direction."},{"name":"up","summary":"The camera up direction."}],"returns":"The camera rotation angle in radians."},{"signature":"static Vector3d CalculateCameraUpDirection(Point3d location, Vector3d direction, double angle)","summary":"Calculates the camera up direction.","since":"6.8","parameters":[{"name":"location","summary":"The camera location."},{"name":"direction","summary":"The camera direction."},{"name":"angle","summary":"The camera rotation angle in radians."}],"returns":"The camera up direction."},{"signature":"bool ChangeToParallelProjection(bool symmetricFrustum)","summary":"Use this function to change projections of valid viewports from parallel to perspective.  It will make common additional adjustments to the frustum and camera location so the resulting views are similar.  The camera direction and target point are not be changed. If the current projection is parallel and symmetricFrustum, FrustumIsLeftRightSymmetric() and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned.","since":"5.0","parameters":[{"name":"symmetricFrustum","summary":"True if you want the resulting frustum to be symmetric."}],"returns":"True if the operation succeeded; otherwise, false."},{"signature":"bool ChangeToPerspectiveProjection(double targetDistance, bool symmetricFrustum, double lensLength)","summary":"Use this function to change projections of valid viewports from parallel to perspective.  It will make common additional adjustments to the frustum and camera location so the resulting views are similar.  The camera direction and target point are not changed. If the current projection is perspective and symmetricFrustum, IsFrustumIsLeftRightSymmetric, and IsFrustumIsTopBottomSymmetric are all equal, then no changes are made and True is returned.","since":"5.0","parameters":[{"name":"targetDistance","summary":"If RhinoMath.UnsetValue this parameter is ignored. Otherwise it must be > 0 and indicates which plane in the current view frustum should be preserved."},{"name":"symmetricFrustum","summary":"True if you want the resulting frustum to be symmetric."},{"name":"lensLength","summary":"(pass 50.0 when in doubt) 35 mm lens length to use when changing from parallel to perspective projections. If the current projection is perspective or lens_length is <= 0.0, then this parameter is ignored."}],"returns":"True if the operation succeeded; otherwise, false."},{"signature":"bool ChangeToSymmetricFrustum(bool isLeftRightSymmetric, bool isTopBottomSymmetric, double targetDistance)","summary":"If needed, adjusts the current frustum so it has the specified symmetries and adjust the camera location so the target plane remains visible.","since":"5.0","parameters":[{"name":"isLeftRightSymmetric","summary":"If true, the frustum will be adjusted so left = -right."},{"name":"isTopBottomSymmetric","summary":"If true, the frustum will be adjusted so top = -bottom."},{"name":"targetDistance","summary":"If projection is not perspective or target_distance is RhinoMath.UnsetValue, then this parameter is ignored. If the projection is perspective and targetDistance is not RhinoMath.UnsetValue, then it must be > 0.0 and it is used to determine which plane in the old frustum will appear unchanged in the new frustum."}],"returns":"Returns True if the viewport has now a frustum with the specified symmetries."},{"signature":"bool ChangeToTwoPointPerspectiveProjection(double targetDistance, Vector3d up, double lensLength)","summary":"Changes projections of valid viewports to a two point perspective.  It will make common additional adjustments to the frustum and camera location and direction so the resulting views are similar. If the current projection is perspective and IsFrustumIsLeftRightSymmetric is True and IsFrustumIsTopBottomSymmetric is false, then no changes are made and True is returned.","since":"5.0","parameters":[{"name":"targetDistance","summary":"If RhinoMath.UnsetValue this parameter is ignored.  Otherwise it must be > 0 and indicates which plane in the current view frustum should be preserved."},{"name":"up","summary":"The locked up direction. Pass Vector3d.Zero if you want to use the world axis direction that is closest to the current up direction. Pass CameraY() if you want to preserve the current up direction."},{"name":"lensLength","summary":"(pass 50.0 when in doubt) 35 mm lens length to use when changing from parallel to perspective projections. If the current projection is perspective or lens_length is <= 0.0, then this parameter is ignored."}],"returns":"True if the operation succeeded; otherwise, false."},{"signature":"bool DollyCamera(Vector3d dollyVector)","summary":"DollyCamera() does not update the frustum\'s clipping planes. To update the frustum\'s clipping planes call DollyFrustum(d) with d = dollyVector o cameraFrameZ.  To convert screen locations into a dolly vector, use GetDollyCameraVector(). Does not update frustum.  To update frustum use DollyFrustum(d) with d = dollyVector o cameraFrameZ.","since":"5.0","parameters":[{"name":"dollyVector","summary":"dolly vector in world coordinates."}],"returns":"True if the operation succeeded; otherwise, false."},{"signature":"bool DollyExtents(BoundingBox cameraCoordinateBoundingBox, double border)","summary":"Dolly the camera location and so that the view frustum contains all of the document objects that can be seen in view. If the projection is perspective, the camera angle is not changed.","since":"5.6","parameters":[{"name":"cameraCoordinateBoundingBox","summary":""},{"name":"border","summary":"If border > 1.0, then the frustum in enlarged by this factor to provide a border around the view.  1.1 works well for parallel projections; 0.0 is suggested for perspective projections."}],"returns":"True if successful."},{"signature":"bool DollyExtents(IEnumerable<GeometryBase> geometry, double border)","summary":"Dolly the camera location and so that the view frustum contains all of the document objects that can be seen in view. If the projection is perspective, the camera angle is not changed.","since":"5.6","parameters":[{"name":"geometry","summary":""},{"name":"border","summary":"If border > 1.0, then the frustum in enlarged by this factor to provide a border around the view.  1.1 works well for parallel projections; 0.0 is suggested for perspective projections."}],"returns":"True if successful."},{"signature":"bool DollyFrustum(double dollyDistance)","summary":"Moves the frustum clipping planes.","since":"5.0","parameters":[{"name":"dollyDistance","summary":"Distance to move in camera direction."}],"returns":"True if the operation succeeded; otherwise, false."},{"signature":"bool Extents(double halfViewAngleRadians, BoundingBox bbox)","summary":"Extends this viewport view to include a bounding box.  \\nUse Extents() as a quick way to set a viewport to so that bounding volume is inside of a viewports frustum. The view angle is used to determine the position of the camera.","since":"5.0","parameters":[{"name":"halfViewAngleRadians","summary":"1/2 smallest subtended view angle in radians."},{"name":"bbox","summary":"A bounding box in 3d world coordinates."}],"returns":"True if the operation succeeded; otherwise, false."},{"signature":"bool Extents(double halfViewAngleRadians, Sphere sphere)","summary":"Extends this viewport view to include a sphere.  \\nUse Extents() as a quick way to set a viewport to so that bounding volume is inside of a viewports frustum. The view angle is used to determine the position of the camera.","since":"5.0","parameters":[{"name":"halfViewAngleRadians","summary":"1/2 smallest subtended view angle in radians."},{"name":"sphere","summary":"A sphere in 3d world coordinates."}],"returns":"True if the operation succeeded; otherwise, false."},{"signature":"Point3d FrustumCenterPoint(double targetDistance)","summary":"Return a point on the central axis of the view frustum. This point is a good choice for a general purpose target point.","since":"5.0","parameters":[{"name":"targetDistance","summary":"If targetDistance > 0.0, then the distance from the returned point to the camera plane will be targetDistance. Note that if the frustum is not symmetric, the distance from the returned point to the camera location will be larger than targetDistance. If targetDistance == ON_UNSET_VALUE and the frustum is valid with near > 0.0, then 0.5*(near + far) will be used as the targetDistance."}],"returns":"A point on the frustum\'s central axis.  If the viewport or input is not valid, then ON_3dPoint::UnsetPoint is returned."},{"signature":"bool GetBoundingBoxDepth(BoundingBox bbox, out double nearDistance, out double farDistance)","summary":"Gets near and far clipping distances of a bounding box. This function ignores the current value of the viewport\'s near and far settings. If the viewport is a perspective projection, the it intersects the semi infinite frustum volume with the bounding box and returns the near and far distances of the intersection.  If the viewport is a parallel projection, it intersects the infinite view region with the bounding box and returns the near and far distances of the projection.","since":"5.0","parameters":[{"name":"bbox","summary":"The bounding box to sample."},{"name":"nearDistance","summary":"Near distance of the box. This value can be zero or negative when the camera location is inside box."},{"name":"farDistance","summary":"Far distance of the box. This value can be equal to near_dist, zero or negative when the camera location is in front of the bounding box."}],"returns":"True if the bounding box intersects the view frustum and near_dist/far_dist were set. False if the bounding box does not intersect the view frustum."},{"signature":"bool GetCameraAngles(out double halfDiagonalAngleRadians, out double halfVerticalAngleRadians, out double halfHorizontalAngleRadians)","summary":"Gets the field of view angles.","since":"5.0","parameters":[{"name":"halfDiagonalAngleRadians","summary":"1/2 of diagonal subtended angle. This out parameter is assigned during this call."},{"name":"halfVerticalAngleRadians","summary":"1/2 of vertical subtended angle. This out parameter is assigned during this call."},{"name":"halfHorizontalAngleRadians","summary":"1/2 of horizontal subtended angle. This out parameter is assigned during this call."}],"returns":"True if the operation succeeded; otherwise, false."},{"signature":"bool GetCameraFrame(out Point3d location, out Vector3d cameraX, out Vector3d cameraY, out Vector3d cameraZ)","summary":"Gets location and vectors of this camera.","since":"5.0","parameters":[{"name":"location","summary":"An out parameter that will be filled with a point during the call."},{"name":"cameraX","summary":"An out parameter that will be filled with the X vector during the call."},{"name":"cameraY","summary":"An out parameter that will be filled with the Y vector during the call."},{"name":"cameraZ","summary":"An out parameter that will be filled with the Z vector during the call."}],"returns":"True if current camera orientation is valid; otherwise false."},{"signature":"Vector3d GetDollyCameraVector(int screenX0, int screenY0, int screenX1, int screenY1, double projectionPlaneDistance)","summary":"Gets a world coordinate dolly vector that can be passed to DollyCamera().","since":"5.0","parameters":[{"name":"screenX0","summary":"Screen coordinates of start point."},{"name":"screenY0","summary":"Screen coordinates of start point."},{"name":"screenX1","summary":"Screen coordinates of end point."},{"name":"screenY1","summary":"Screen coordinates of end point."},{"name":"projectionPlaneDistance","summary":"Distance of projection plane from camera. When in doubt, use 0.5*(frus_near+frus_far)."}],"returns":"The world coordinate dolly vector."},{"signature":"Vector3d GetDollyCameraVector(Point screen0, Point screen1, double projectionPlaneDistance)","summary":"Gets a world coordinate dolly vector that can be passed to DollyCamera().","since":"5.0","parameters":[{"name":"screen0","summary":"Start point."},{"name":"screen1","summary":"End point."},{"name":"projectionPlaneDistance","summary":"Distance of projection plane from camera. When in doubt, use 0.5*(frus_near+frus_far)."}],"returns":"The world coordinate dolly vector."},{"signature":"Point3d[] GetFarPlaneCorners()","summary":"Gets the corners of far clipping plane rectangle. 4 points are returned in the order of bottom left, bottom right, top left, top right.","since":"5.0","returns":"Four corner points on success. Empty array if viewport is not valid."},{"signature":"bool GetFrustum(out double left, out double right, out double bottom, out double top, out double nearDistance, out double farDistance)","summary":"Gets the view frustum.","since":"5.0","parameters":[{"name":"left","summary":"A left value that will be filled during the call."},{"name":"right","summary":"A right value that will be filled during the call."},{"name":"bottom","summary":"A bottom value that will be filled during the call."},{"name":"top","summary":"A top value that will be filled during the call."},{"name":"nearDistance","summary":"A near distance value that will be filled during the call."},{"name":"farDistance","summary":"A far distance value that will be filled during the call."}],"returns":"True if operation succeeded; otherwise, false."},{"signature":"Line GetFrustumLine(double screenX, double screenY)","summary":"Gets the world coordinate line in the view frustum that projects to a point on the screen.","since":"5.1","parameters":[{"name":"screenX","summary":"(screenx,screeny) = screen location."},{"name":"screenY","summary":"(screenx,screeny) = screen location."}],"returns":"3d world coordinate line segment starting on the near clipping plane and ending on the far clipping plane."},{"signature":"Line GetFrustumLine(Point screenPoint)","summary":"Gets the world coordinate line in the view frustum that projects to a point on the screen.","since":"5.1","parameters":[{"name":"screenPoint","summary":"screen location"}],"returns":"3d world coordinate line segment starting on the near clipping plane and ending on the far clipping plane."},{"signature":"Line GetFrustumLine(PointF screenPoint)","summary":"Gets the world coordinate line in the view frustum that projects to a point on the screen.","since":"5.1","parameters":[{"name":"screenPoint","summary":"screen location"}],"returns":"3d world coordinate line segment starting on the near clipping plane and ending on the far clipping plane."},{"signature":"Point3d[] GetNearPlaneCorners()","summary":"Gets the corners of near clipping plane rectangle. 4 points are returned in the order of bottom left, bottom right, top left, top right.","since":"5.0","returns":"Four corner points on success. Empty array if viewport is not valid."},{"signature":"bool GetPointDepth(Point3d point, out double distance)","summary":"Gets the clipping distance of a point. This function ignores the current value of the viewport\'s near and far settings. If the viewport is a perspective projection, then it intersects the semi infinite frustum volume with the bounding box and returns the near and far distances of the intersection. If the viewport is a parallel projection, it intersects the infinite view region with the bounding box and returns the near and far distances of the projection.","since":"5.0","parameters":[{"name":"point","summary":"A point to measure."},{"name":"distance","summary":"distance of the point (can be < 0)"}],"returns":"True if the bounding box intersects the view frustum and near_dist/far_dist were set. False if the bounding box does not intersect the view frustum."},{"signature":"System.Drawing.Rectangle GetScreenPort()","summary":"Gets the location of viewport in pixels. See documentation for SetScreenPort(int, int, int, int, int, int).","since":"5.0","returns":"The rectangle, or System.Drawing.Rectangle.Emptyrectangle on error."},{"signature":"System.Drawing.Rectangle GetScreenPort(out int near, out int far)","summary":"Gets the location of viewport in pixels.  \\nSee value meanings in SetScreenPort.","since":"5.0","parameters":[{"name":"near","summary":"The near value. This out parameter is assigned during the call."},{"name":"far","summary":"The far value. This out parameter is assigned during the call."}],"returns":"The rectangle, or System.Drawing.Rectangle.Emptyrectangle on error."},{"signature":"void GetScreenPortLocation(out int left, out int top, out int right, out int bottom)","summary":"Get the location of viewport in pixels (non System.Drawing version of GetScreenPort)","since":"6.0"},{"signature":"bool GetSphereDepth(Sphere sphere, out double nearDistance, out double farDistance)","summary":"Gets near and far clipping distances of a bounding sphere.","since":"5.0","parameters":[{"name":"sphere","summary":"The sphere to sample."},{"name":"nearDistance","summary":"Near distance of the sphere (can be < 0)"},{"name":"farDistance","summary":"Far distance of the sphere (can be equal to near_dist)"}],"returns":"True if the sphere intersects the view frustum and near_dist/far_dist were set. False if the sphere does not intersect the view frustum."},{"signature":"double GetWorldToScreenScale(Point3d pointInFrustum)","summary":"Gets the scale factor from point in frustum to screen scale.","since":"5.1","parameters":[{"name":"pointInFrustum","summary":"point in viewing frustum."}],"returns":"number of pixels per world unit at the 3d point."},{"signature":"Transform GetXform(CoordinateSystem sourceSystem, CoordinateSystem destinationSystem)","summary":"Computes a transform from a coordinate system to another.","since":"5.0","parameters":[{"name":"sourceSystem","summary":"The coordinate system to map from."},{"name":"destinationSystem","summary":"The coordinate system to map into."}],"returns":"The 4x4 transformation matrix (acts on the left)."},{"signature":"bool RotateCamera(double rotationAngleRadians, Vector3d rotationAxis, Point3d rotationCenter)","summary":"Rotates the view camera.","since":"7.0","parameters":[{"name":"rotationAngleRadians","summary":"The amount to rotate expressed in radians."},{"name":"rotationAxis","summary":"The axis to rotate around."},{"name":"rotationCenter","summary":"The point to rotate around."}],"returns":"True if rotation is successful, False otherwise."},{"signature":"bool SetCameraDirection(Vector3d direction)","summary":"Sets the direction that the camera faces.","since":"5.0","parameters":[{"name":"direction","summary":"A new direction."}],"returns":"True if the direction was set; otherwise false."},{"signature":"bool SetCameraLocation(Point3d location)","summary":"Sets the camera location (position) point.","since":"5.0","returns":"True if the operation succeeded; otherwise, false."},{"signature":"bool SetCameraUp(Vector3d up)","summary":"Sets the camera up vector.","since":"5.0","parameters":[{"name":"up","summary":"A new direction."}],"returns":"True if the direction was set; otherwise false."},{"signature":"bool SetFrustum(double left, double right, double bottom, double top, double nearDistance, double farDistance)","summary":"Sets the view frustum. If FrustumSymmetryIsLocked() is true and left != -right or bottom != -top, then they will be adjusted so the resulting frustum is symmetric.","since":"5.0","parameters":[{"name":"left","summary":"A new left value."},{"name":"right","summary":"A new right value."},{"name":"bottom","summary":"A new bottom value."},{"name":"top","summary":"A new top value."},{"name":"nearDistance","summary":"A new near distance value."},{"name":"farDistance","summary":"A new far distance value."}],"returns":"True if operation succeeded; otherwise, false."},{"signature":"bool SetFrustumNearFar(BoundingBox boundingBox)","summary":"Sets the frustum near and far using a bounding box.","since":"5.0","parameters":[{"name":"boundingBox","summary":"A bounding box to use."}],"returns":"True if operation succeeded; otherwise, false."},{"signature":"bool SetFrustumNearFar(double nearDistance, double farDistance)","summary":"Sets the frustum near and far distances using two values.","since":"5.0","parameters":[{"name":"nearDistance","summary":"The new near distance."},{"name":"farDistance","summary":"The new far distance."}],"returns":"True if operation succeeded; otherwise, false."},{"signature":"bool SetFrustumNearFar(double nearDistance, double farDistance, double minNearDistance, double minNearOverFar, double targetDistance)","summary":"Sets near and far clipping distance subject to constraints.","since":"5.0","parameters":[{"name":"nearDistance","summary":"(>0) desired near clipping distance."},{"name":"farDistance","summary":"(>near_dist) desired near clipping distance."},{"name":"minNearDistance","summary":"If min_near_dist <= 0.0, it is ignored. If min_near_dist > 0 and near_dist < min_near_dist, then the frustum\'s near_dist will be increased to min_near_dist."},{"name":"minNearOverFar","summary":"If min_near_over_far <= 0.0, it is ignored. If near_dist < far_dist*min_near_over_far, then near_dist is increased and/or far_dist is decreased so that near_dist = far_dist*min_near_over_far. If near_dist < target_dist < far_dist, then near_dist near_dist is increased and far_dist is decreased so that projection precision will be good at target_dist. Otherwise, near_dist is simply set to far_dist*min_near_over_far."},{"name":"targetDistance","summary":"If target_dist <= 0.0, it is ignored. If target_dist > 0, it is used as described in the description of the min_near_over_far parameter."}],"returns":"True if operation succeeded; otherwise, false."},{"signature":"bool SetFrustumNearFar(Point3d center, double radius)","summary":"Sets the frustum near and far using a center point and radius.","since":"5.0","parameters":[{"name":"center","summary":"A center point."},{"name":"radius","summary":"A radius value."}],"returns":"True if operation succeeded; otherwise, false."},{"signature":"bool SetScreenPort(int left, int right, int bottom, int top, int near, int far)","summary":"Location of viewport in pixels. These are provided so you can set the port you are using and get the appropriate transformations to and from screen space. // For a Windows window /      int width = width of window client area in pixels; /      int height = height of window client area in pixels; /      port_left = 0; /      port_right = width; /      port_top = 0; /      port_bottom = height; /      port_near = 0; /      port_far = 1; /      SetScreenPort( port_left, port_right, /                     port_bottom, port_top, /                     port_near, port_far );","since":"5.0","parameters":[{"name":"left","summary":"A left value."},{"name":"right","summary":"A left value. (port_left != port_right)"},{"name":"bottom","summary":"A bottom value."},{"name":"top","summary":"A top value. (port_top != port_bottom)"},{"name":"near","summary":"A near value."},{"name":"far","summary":"A far value."}],"returns":"True if input is valid."},{"signature":"bool SetScreenPort(Rectangle windowRectangle)","summary":"Gets the location of viewport in pixels.  \\nSee value meanings in SetScreenPort.","since":"5.0","parameters":[{"name":"windowRectangle","summary":"A new rectangle."}],"returns":"True if input is valid."},{"signature":"bool SetScreenPort(Rectangle windowRectangle, int near, int far)","summary":"Gets the location of viewport in pixels.  \\nSee value meanings in SetScreenPort.","since":"5.0","parameters":[{"name":"windowRectangle","summary":"A new rectangle."},{"name":"near","summary":"The near value."},{"name":"far","summary":"The far value."}],"returns":"True if input is valid."},{"signature":"double TargetDistance(bool useFrustumCenterFallback)","summary":"Gets the distance from the target point to the camera plane. Note that if the frustum is not symmetric, then this distance is shorter than the distance from the target to the camera location.","since":"5.0","parameters":[{"name":"useFrustumCenterFallback","summary":"If bUseFrustumCenterFallback is False and the target point is not valid, then ON_UNSET_VALUE is returned. If bUseFrustumCenterFallback is True and the frustum is valid and current target point is not valid or is behind the camera, then 0.5*(near + far) is returned."}],"returns":"Shortest signed distance from camera plane to target point. If the target point is on the visible side of the camera, a positive value is returned.  ON_UNSET_VALUE is returned when the input of view is not valid."},{"signature":"bool TransformCamera(Transform xform)","summary":"Transforms the view camera location, direction, and up.","since":"7.0","parameters":[{"name":"xform","summary":"Transformation to apply to camera."}],"returns":"True if a valid camera was transformed, False if invalid camera, frustum, or transformation."},{"signature":"void UnlockCamera()","summary":"Unlocks the camera vectors and location.","since":"5.0"},{"signature":"void UnlockFrustumSymmetry()","summary":"Unlocks frustum horizontal and vertical symmetries.","since":"5.0"},{"signature":"bool ZoomToScreenRect(int left, int top, int right, int bottom)","summary":"Zooms to a screen zone.  \\nView changing from screen input points. Handy for using a mouse to manipulate a view. ZoomToScreenRect() may change camera and frustum settings.","since":"5.0","parameters":[{"name":"left","summary":"Screen coordinate."},{"name":"top","summary":"Screen coordinate."},{"name":"right","summary":"Screen coordinate."},{"name":"bottom","summary":"Screen coordinate."}],"returns":"True if the operation succeeded; otherwise, false."},{"signature":"bool ZoomToScreenRect(Rectangle windowRectangle)","summary":"Zooms to a screen zone.  \\nView changing from screen input points. Handy for using a mouse to manipulate a view. ZoomToScreenRect() may change camera and frustum settings.","since":"5.0","parameters":[{"name":"windowRectangle","summary":"The new window rectangle in screen space."}],"returns":"True if the operation succeeded; otherwise, false."}]},{"namespace":"Rhino.DocObjects","name":"Worksession","dataType":"class","summary":"Manages a list of models that are being used as reference geometry.","properties":[{"signature":"RhinoDoc Document","summary":"Gets the document that owns this worksession.","since":"6.0","property":["get"]},{"signature":"string FileName","summary":"Returns the path to the open worksession, or .rws, file. If there is no worksession file open, or the active worksession has not yet been saved, then None is returned.","since":"6.0","property":["get"]},{"signature":"int ModelCount","summary":"Returns the number of models in the worksession. The active model will included in this count whether or not it has been saved.","since":"6.0","property":["get"]},{"signature":"string[] ModelPaths","summary":"Returns the paths to the models used by the worksession. If the active model has not been saved, then it will not be included in the output array.","since":"6.0","property":["get"]},{"signature":"uint RuntimeSerialNumber","summary":"Unique serial number for the worksession while the application is running. This is not a persistent value.","since":"6.3","property":["get"]}],"methods":[{"signature":"static string FileNameFromRuntimeSerialNumber(uint runtimeSerialNumber)","summary":"Returns the path to the open worksession, or .rws, file. If there is no worksession file open, or the active worksession has not yet been saved, then None is returned.","since":"6.3"},{"signature":"string ModelPathFromSerialNumber(uint modelSerialNumber)","summary":"Returns the path to a model, used by the worksession, given a reference model serial number","since":"6.12","parameters":[{"name":"modelSerialNumber","summary":"The reference model serial number."}],"returns":"The path to the model if successful, None otherwise."}]},{"namespace":"Rhino","name":"DocumentEventArgs","dataType":"class","summary":"Provides document information for RhinoDoc events.","baseclass":"EventArgs","properties":[{"signature":"RhinoDoc Document","summary":"Gets the document for this event. This field might be null.","since":"5.0","property":["get"]},{"signature":"int DocumentId","summary":"Gets the document Id of the document for this event.","since":"5.0","property":["get"]},{"signature":"uint DocumentSerialNumber","summary":"Gets the uniques document serial number for this event","since":"6.0","property":["get"]}]},{"namespace":"Rhino","name":"DocumentOpenEventArgs","dataType":"class","summary":"Provides document information for RhinoDoc events.","baseclass":"Rhino.DocumentEventArgs","properties":[{"signature":"string FileName","summary":"Name of file being opened.","since":"5.0","property":["get"]},{"signature":"bool Merge","summary":"True if file is being merged into the current document. This occurs during the \\"Import\\" command.","since":"5.0","property":["get"]},{"signature":"bool Reference","summary":"True if file is opened as a reference file.","since":"5.0","property":["get"]}]},{"namespace":"Rhino","name":"DocumentSaveEventArgs","dataType":"class","summary":"Provides document information for RhinoDoc events.","baseclass":"Rhino.DocumentEventArgs","properties":[{"signature":"bool ExportSelected","summary":"True if only selected objects are being written to a file.","since":"5.0","property":["get"]},{"signature":"string FileName","summary":"Name of file being written.","since":"5.0","property":["get"]}]},{"namespace":"Rhino.FileIO","name":"BinaryArchiveException","dataType":"class","summary":"Thrown by BinaryArchiveReader and BinaryArchiveWriter classes when an IO error has occurred.","baseclass":"System.IO.IOException","constructors":[{"signature":"BinaryArchiveException(string message)","summary":"Initializes a new instance of the BinaryArchiveExceptionclass.","since":"5.0","parameters":[{"name":"message","summary":"The inner message to show to users."}]}]},{"namespace":"Rhino.FileIO","name":"BinaryArchiveFile","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"BinaryArchiveFile(string filename, BinaryArchiveMode mode)","since":"5.1"}],"properties":[{"signature":"BinaryArchiveReader Reader","since":"5.1","property":["get"]},{"signature":"BinaryArchiveWriter Writer","since":"5.1","property":["get"]}],"methods":[{"signature":"void Close()","since":"5.1"},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.1"},{"signature":"bool Open()","since":"5.1"}]},{"namespace":"Rhino.FileIO","name":"BinaryArchiveMode","dataType":"enum","since":"5.1","values":[{"signature":"Unknown = 0"},{"signature":"Read = 1"},{"signature":"Write = 2"},{"signature":"ReadWrite = 3"},{"signature":"Read3dm = 5"},{"signature":"Write3dm = 6"}]},{"namespace":"Rhino.FileIO","name":"BinaryArchiveReader","dataType":"class","summary":"Represents an entity that is capable of reading a binary archive and instantiating strongly-typed objects.","properties":[{"signature":"int Archive3dmVersion","summary":"If a 3dm archive is being read or written, then this is the version of the 3dm archive format (1, 2, 3, 4 or 5). 0     a 3dm archive is not being read/written 1     a version 1 3dm archive is being read/written 2     a version 2 3dm archive is being read/written 3     a version 3 3dm archive is being read/written 4     a version 4 3dm archive is being read/written 5     an old version 5 3dm archive is being read 50    a version 5 3dm archive is being read/written.","since":"5.0","property":["get"]},{"signature":"ulong CurrentPosition","summary":"current offset (in bytes) into archive ( like ftell() )","since":"6.0","property":["get"]},{"signature":"bool ReadErrorOccured","summary":"Gets or sets whether en error occurred during reading.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"bool AtEnd()","summary":"True if at end of a file","since":"5.1"},{"signature":"bool BeginRead3dmChunk(out uint typeCode, out long value)","summary":"Begins reading a chunk that must be in the archive at this location."},{"signature":"bool BeginRead3dmChunk(uint expectedTypeCode, out int majorVersion, out int minorVersion)","summary":"Begins reading a chunk that must be in the archive at this location.","since":"6.0","returns":"True if beginning of the chunk was read.  In this case you must call EndRead3dmChunk(), even if something goes wrong while you attempt to read the interior of the chunk. False if the chunk did not exist at the current location in the file."},{"signature":"uint Dump3dmChunk(TextLog log)","summary":"Function for studying contents of a file.  The primary use is as an aid to help dig through files that have been damaged (bad disks, transmission errors, etc.) If an error is found, a line that begins with the word \\"ERROR\\" is printed.","since":"5.1","parameters":[{"name":"log","summary":"log where information is printed to"}],"returns":"0 if something went wrong, otherwise the typecode of the chunk that was just studied."},{"signature":"bool EnableCRCCalculation(bool enable)","summary":"Expert user function to control CRC calculation while reading and writing. Typically this is used when seeking around and reading/writing information in non-serial order.","since":"6.0","returns":"Current state of CRC calculation.  Use the returned value to restore the CRC calculation setting after you are finished doing your fancy pants expert IO."},{"signature":"bool EndRead3dmChunk(bool suppressPartiallyReadChunkWarning)","summary":"Calling this will skip rest of stuff in chunk if it was only partially read.","since":"6.0","parameters":[{"name":"suppressPartiallyReadChunkWarning","summary":"Generally, a call to ON_WARNING is made when a chunk is partially read. If suppressPartiallyReadChunkWarning is true, then no warning is issued for partially read chunks."}]},{"signature":"void Read3dmChunkVersion(out int major, out int minor)","summary":"A chunk version is a single byte that encodes a major.minor version number.  Useful when creating I/O code for 3dm chunks that may change in the future.  Increment the minor version number if new information is added to the end of the chunk. Increment the major version if the format of the chunk changes in some other way.","since":"5.0","parameters":[{"name":"major","summary":"0 to 15."},{"name":"minor","summary":"0 to 16."}],"returns":"True on successful read."},{"signature":"bool Read3dmStartSection(out int version, out string comment)","since":"5.1","parameters":[{"name":"version","summary":".3dm file version (2, 3, 4, 5 or 50)"},{"name":"comment","summary":"String with application name, et cetera.  This information is primarily used when debugging files that contain problems.  McNeel and Associates stores application name, application version, compile date, and the OS in use when file was written."}],"returns":"True on success"},{"signature":"bool ReadBool()","summary":"Reads a boolfrom the archive.","since":"5.0","returns":"The value that was read."},{"signature":"bool[] ReadBoolArray()","summary":"Reads an array of boolfrom the archive.  \\nAn array is returned even if the input was another enumerable type.","since":"5.0","returns":"The array that was read."},{"signature":"Geometry.BoundingBox ReadBoundingBox()","summary":"Reads a Rhino.Geometry.BoundingBoxfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"byte ReadByte()","summary":"Reads a bytefrom the archive.","since":"5.0","returns":"The value that was read."},{"signature":"byte[] ReadByteArray()","summary":"Reads an array of bytefrom the archive.  \\nAn array is returned even if the input was another enumerable type.","since":"5.0","returns":"The array that was read."},{"signature":"void ReadCheckSum()","summary":"Reads a legacy ON_CheckSum, only provided to read data chunks from old V5 files, the CheckSum read is discarded","since":"6.0","deprecated":"6.0"},{"signature":"System.Drawing.Color ReadColor()","summary":"Reads a System.Drawing.Colorfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"byte[] ReadCompressedBuffer()","summary":"Reads an array of compressed byteinformation from the archive and uncompresses it.  \\nAn array is returned even if the input was another enumerable type.","since":"5.9","returns":"The array that was read."},{"signature":"Rhino.Collections.ArchivableDictionary ReadDictionary()","summary":"Reads a complete Rhino.Collections.ArchivableDictionaryfrom the archive.","since":"5.0","returns":"The newly instantiated object."},{"signature":"double ReadDouble()","summary":"Reads a doublefrom the archive.","since":"5.0","returns":"The value that was read."},{"signature":"double[] ReadDoubleArray()","summary":"Reads an array of doublefrom the archive.  \\nAn array is returned even if the input was another enumerable type.","since":"5.0","returns":"The array that was read."},{"signature":"System.Drawing.Font ReadFont()","summary":"Reads a System.Drawing.Fontfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"Geometry.GeometryBase ReadGeometry()","summary":"Reads a Rhino.Geometry.GeometryBase-derived object from the archive.  \\nThe  class is abstract.","since":"5.0","returns":"The element that was read."},{"signature":"Geometry.GeometryBase[] ReadGeometryArray()","since":"7.0"},{"signature":"Guid ReadGuid()","summary":"Reads a Guidfrom the archive.","since":"5.0","returns":"The value that was read."},{"signature":"Guid[] ReadGuidArray()","summary":"Reads an array of Guidfrom the archive.  \\nAn array is returned even if the input was another enumerable type.","since":"5.0","returns":"The array that was read."},{"signature":"int ReadInt()","summary":"Reads a intfrom the archive.","since":"5.0","returns":"The value that was read."},{"signature":"Int64 ReadInt64()","summary":"Reads a longfrom the archive.","since":"5.0","returns":"The value that was read."},{"signature":"int[] ReadIntArray()","summary":"Reads an array of intfrom the archive.  \\nAn array is returned even if the input was another enumerable type.","since":"5.0","returns":"The array that was read."},{"signature":"Geometry.Interval ReadInterval()","summary":"Reads a Rhino.Geometry.Intervalfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"Geometry.Line ReadLine()","summary":"Reads a Rhino.Geometry.Linefrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"Geometry.MeshingParameters ReadMeshingParameters()","summary":"Reads a Rhino.Geometry.MeshingParametersfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"DocObjects.ObjRef ReadObjRef()","summary":"Reads a Rhino.DocObjects.ObjReffrom the archive","since":"5.8","returns":"the element that was read"},{"signature":"DocObjects.ObjRef[] ReadObjRefArray()","summary":"Reads an array of doublefrom the archive.  \\nAn array is returned even if the input was another enumerable type.","since":"5.8","returns":"The array that was read."},{"signature":"Geometry.Plane ReadPlane()","summary":"Reads a Rhino.Geometry.Planefrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"System.Drawing.Point ReadPoint()","summary":"Reads a System.Drawing.Pointfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"Geometry.Point2d ReadPoint2d()","summary":"Reads a Rhino.Geometry.Point2dfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"Geometry.Point3d ReadPoint3d()","summary":"Reads a Rhino.Geometry.Point3dfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"Geometry.Point3f ReadPoint3f()","summary":"Reads a Rhino.Geometry.Point3ffrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"Geometry.Point4d ReadPoint4d()","summary":"Reads a Rhino.Geometry.Point4dfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"System.Drawing.PointF ReadPointF()","summary":"Reads a System.Drawing.PointFfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"Geometry.Ray3d ReadRay3d()","summary":"Reads a Rhino.Geometry.Ray3dfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"System.Drawing.Rectangle ReadRectangle()","summary":"Reads a System.Drawing.Rectanglefrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"System.Drawing.RectangleF ReadRectangleF()","summary":"Reads a System.Drawing.RectangleFfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"RenderSettings ReadRenderSettings()","summary":"Reads a Rhino.Render.RenderSettings-derived object from the archive.","since":"6.0","returns":"The element that was read."},{"signature":"sbyte ReadSByte()","summary":"Reads a sbytefrom the archive.","since":"5.0","returns":"The value that was read."},{"signature":"sbyte[] ReadSByteArray()","summary":"Reads an array of sbytefrom the archive.  \\nAn array is returned even if the input was another enumerable type.","since":"5.0","returns":"The array that was read."},{"signature":"short ReadShort()","summary":"Reads a shortfrom the archive.","since":"5.0","returns":"The value that was read."},{"signature":"short[] ReadShortArray()","summary":"Reads an array of shortfrom the archive.  \\nAn array is returned even if the input was another enumerable type.","since":"5.0","returns":"The array that was read."},{"signature":"float ReadSingle()","summary":"Reads a floatfrom the archive.","since":"5.0","returns":"The value that was read."},{"signature":"float[] ReadSingleArray()","summary":"Reads an array of floatfrom the archive.  \\nAn array is returned even if the input was another enumerable type.","since":"5.0","returns":"The array that was read."},{"signature":"System.Drawing.Size ReadSize()","summary":"Reads a System.Drawing.Sizefrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"System.Drawing.SizeF ReadSizeF()","summary":"Reads a System.Drawing.SizeFfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"string ReadString()","summary":"Reads a stringfrom the archive.","since":"5.0","returns":"The value that was read."},{"signature":"string[] ReadStringArray()","summary":"Reads an array of stringfrom the archive.  \\nAn array is returned even if the input was another enumerable type.","since":"5.0","returns":"The array that was read."},{"signature":"Geometry.Transform ReadTransform()","summary":"Reads a Rhino.Geometry.Transformfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"uint ReadUInt()","summary":"Reads a uintfrom the archive.","since":"5.0","returns":"The value that was read."},{"signature":"ushort ReadUShort()","summary":"Reads a ushortfrom the archive.","since":"5.0","returns":"The value that was read."},{"signature":"string ReadUtf8String()","summary":"Reads a stringfrom the archive.","since":"6.0","returns":"The value that was read."},{"signature":"Geometry.Vector2d ReadVector2d()","summary":"Reads a Rhino.Geometry.Vector2dfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"Geometry.Vector3d ReadVector3d()","summary":"Reads a Rhino.Geometry.Vector3dfrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"Geometry.Vector3f ReadVector3f()","summary":"Reads a Rhino.Geometry.Vector3ffrom the archive.","since":"5.0","returns":"The element that was read."},{"signature":"bool SeekFromCurrentPosition(long byteOffset)","summary":"seek from current position ( like fseek( ,SEEK_CUR) )"},{"signature":"bool SeekFromCurrentPosition(ulong byteOffset, bool forward)","summary":"seek from current position ( like fseek( ,SEEK_CUR) )","parameters":[{"name":"byteOffset","summary":""},{"name":"forward","summary":"seek forward of backward in the archive"}]},{"signature":"bool SeekFromStart(ulong byteOffset)","summary":"seek from start position ( like fseek( ,SEEK_SET) )"}]},{"namespace":"Rhino.FileIO","name":"BinaryArchiveWriter","dataType":"class","summary":"Represents an entity that is able to write data to an archive.","properties":[{"signature":"int Archive3dmVersion","summary":"If a 3dm archive is being read or written, then this is the version of the 3dm archive format (1, 2, 3, 4 or 5). 0     a 3dm archive is not being read/written 1     a version 1 3dm archive is being read/written 2     a version 2 3dm archive is being read/written 3     a version 3 3dm archive is being read/written 4     a version 4 3dm archive is being read/written 5     an old version 5 3dm archive is being read 50    a version 5 3dm archive is being read/written.","since":"5.0","property":["get"]},{"signature":"bool WriteErrorOccured","summary":"Gets or sets whether an error occurred.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"bool BeginWrite3dmChunk(uint typecode, int majorVersion, int minorVersion)","summary":"Begins writing a chunk","since":"6.0","parameters":[{"name":"typecode","summary":"chunk\'s typecode"},{"name":"majorVersion","summary":""},{"name":"minorVersion","summary":""}],"returns":"True if input was valid and chunk was started.  In this case you must call EndWrite3dmChunk(), even if something goes wrong while you attempt to write the contents of the chunk. False if input was not valid or the write failed."},{"signature":"bool BeginWrite3dmChunk(uint typecode, long value)","summary":"Begins writing a chunk"},{"signature":"bool EnableCRCCalculation(bool enable)","summary":"Expert user function to control CRC calculation while reading and writing. Typically this is used when seeking around and reading/writing information in non-serial order.","since":"6.0","returns":"Current state of CRC calculation.  Use the returned value to restore the CRC calculation setting after you are finished doing your fancy pants expert IO."},{"signature":"bool EndWrite3dmChunk()","summary":"updates length in chunk header","since":"6.0"},{"signature":"void Write3dmChunkVersion(int major, int minor)","summary":"A chunk version is a single byte that encodes a major.minor version number.  Useful when creating I/O code for 3dm chunks that may change in the future.  Increment the minor version number if new information is added to the end of the chunk. Increment the major version if the format of the chunk changes in some other way.","since":"5.0","parameters":[{"name":"major","summary":"0 to 15."},{"name":"minor","summary":"0 to 16."}],"returns":"True on successful read."},{"signature":"void WriteBool(bool value)","summary":"Writes a boolvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteBoolArray(IEnumerable<bool> value)","summary":"Writes a list, an array, or any enumerable of boolto the archive.  \\nThe return will always be an array.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteBoundingBox(BoundingBox value)","summary":"Writes a Rhino.Geometry.BoundingBoxvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteByte(byte value)","summary":"Writes a bytevalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteByteArray(IEnumerable<byte> value)","summary":"Writes a list, an array, or any enumerable of byteto the archive.  \\nThe return will always be an array.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteColor(Color value)","summary":"Writes a System.Drawing.Colorvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteCompressedBuffer(IEnumerable<byte> value)","summary":"Writes a list, an array, or any enumerable of byteto the archive as a compressed buffer.  \\nThe return will always be an array.","since":"5.9","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteDictionary(ArchivableDictionary dictionary)","summary":"Delivers the complete content of a dictionary to the archive.","since":"5.0","parameters":[{"name":"dictionary","summary":"A dictionary to archive."}]},{"signature":"void WriteDouble(double value)","summary":"Writes a doublevalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteDoubleArray(IEnumerable<double> value)","summary":"Writes a list, an array, or any enumerable of doubleto the archive.  \\nThe return will always be an array.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteEmptyCheckSum()","summary":"Reads a legacy ON_CheckSum, only provided to read data chunks from old V5 files, the CheckSum read is discarded","since":"6.0","deprecated":"6.0"},{"signature":"void WriteFont(Font value)","summary":"Writes a System.Drawing.Fontvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteGeometry(GeometryBase value)","summary":"Writes a Rhino.Geometry.GeometryBasevalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteGeometryArray(IEnumerable<GeometryBase> geometry)","since":"7.0"},{"signature":"void WriteGuid(Guid value)","summary":"Writes a Guidvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteGuidArray(IEnumerable<Guid> value)","summary":"Writes a list, an array, or any enumerable of Guidto the archive.  \\nThe return will always be an array.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteInt(int value)","summary":"Writes a intvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteInt64(Int64 value)","summary":"Writes a Int64value to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteIntArray(IEnumerable<int> value)","summary":"Writes a list, an array, or any enumerable of intto the archive.  \\nThe return will always be an array.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteInterval(Interval value)","summary":"Writes a Rhino.Geometry.Intervalvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteLine(Line value)","summary":"Writes a Rhino.Geometry.Linevalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteMeshingParameters(MeshingParameters value)","summary":"Writes a Rhino.Geometry.MeshingParametersvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteObjRef(ObjRef objref)","summary":"Writes a Rhino.DocObjects.ObjRefto the archive","since":"5.8","returns":"the element that was read"},{"signature":"void WriteObjRefArray(IEnumerable<ObjRef> objrefs)","summary":"Writes a list, an array, or any enumerable of Rhino.DocObjects.ObjRefto the archive.  \\nThe return will always be an array.","since":"5.8","parameters":[{"name":"objrefs","summary":"A value to write."}]},{"signature":"void WritePlane(Plane value)","summary":"Writes a Rhino.Geometry.Planevalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WritePoint(Point value)","summary":"Writes a System.Drawing.Pointvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WritePoint2d(Point2d value)","summary":"Writes a Rhino.Geometry.Point2dvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WritePoint3d(Point3d value)","summary":"Writes a Rhino.Geometry.Point3dvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WritePoint3f(Point3f value)","summary":"Writes a Rhino.Geometry.Point3fvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WritePoint4d(Point4d value)","summary":"Writes a Rhino.Geometry.Point4dvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WritePointF(PointF value)","summary":"Writes a System.Drawing.PointFvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteRay3d(Ray3d value)","summary":"Writes a Rhino.Geometry.Ray3dvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteRectangle(Rectangle value)","summary":"Writes a System.Drawing.Rectanglevalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteRectangleF(RectangleF value)","summary":"Writes a System.Drawing.RectangleFvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteRenderSettings(RenderSettings value)","summary":"Writes a Rhino.Render.RenderSettingsvalue to the archive.","since":"6.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteSByte(sbyte value)","summary":"Writes a sbytevalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteSByteArray(IEnumerable<sbyte> value)","summary":"Writes a list, an array, or any enumerable of sbyteto the archive.  \\nThe return will always be an array.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteShort(short value)","summary":"Writes a shortvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteShortArray(IEnumerable<short> value)","summary":"Writes a list, an array, or any enumerable of shortto the archive.  \\nThe return will always be an array.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteSingle(float value)","summary":"Writes a floatvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteSingleArray(IEnumerable<float> value)","summary":"Writes a list, an array, or any enumerable of floatto the archive.  \\nThe return will always be an array.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteSize(Size value)","summary":"Writes a System.Drawing.Sizevalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteSizeF(SizeF value)","summary":"Writes a System.Drawing.SizeFvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteString(string value)","summary":"Writes a stringvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteStringArray(IEnumerable<string> value)","summary":"Writes a list, an array, or any enumerable of stringto the archive.  \\nThe return will always be an array.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteTransform(Transform value)","summary":"Writes a Rhino.Geometry.Transformvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteUInt(uint value)","summary":"Writes a uintvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteUShort(ushort value)","summary":"Writes a ushortvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteUtf8String(string value)","summary":"Writes a stringvalue to the archive.","since":"6.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteVector2d(Vector2d value)","summary":"Writes a Rhino.Geometry.Vector2dvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteVector3d(Vector3d value)","summary":"Writes a Rhino.Geometry.Vector3dvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]},{"signature":"void WriteVector3f(Vector3f value)","summary":"Writes a Rhino.Geometry.Vector3fvalue to the archive.","since":"5.0","parameters":[{"name":"value","summary":"A value to write."}]}]},{"namespace":"Rhino.FileIO","name":"CommonComponentTable<T>","dataType":"class","summary":"Provides a base table type that encompasses all document tables, both in RhinoDoc and File3dm.","interfaces":["ICommonComponentTable<T>","IList<T>","IReadOnlyList<T>"],"properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns the actual component type of a table.","property":["get"]},{"signature":"int Count","summary":"Returns the count of all items, including deleted ones.","property":["get"]}],"methods":[{"signature":"void Clear()","summary":"Marks all items as deleted."},{"signature":"bool Delete(T item)","summary":"Deletes an item. Items that are deleted are still keeping their space, but the \'IsDeleted\' flag is checked.","parameters":[{"name":"item","summary":"An item to delete."}],"returns":"True if an items could be deleted (e.g., it was not locked)."},{"signature":"T FindId(Guid id)","summary":"Uses the guid to find a model component. Deleted objects cannot be found by id. The guid is the value that is stored in the .Id property. In a single document, no two active objects have the same guid. If an object is replaced with a new object, then the guid  persists. For example, if the _Move command moves an object, then the moved object inherits its guid from the starting object. If the Copy command copies an object, then the copy gets a new guid. This guid persists through file saving/opening operations. This function will not find grip objects.","parameters":[{"name":"id","summary":"ID of model component to search for."}],"returns":"Reference to the rhino object with the objectId or None if no such object could be found."},{"signature":"IEnumerator<T> GetEnumerator()","summary":"Returns the enumerator that yields all items."}]},{"namespace":"Rhino.FileIO","name":"ContentHash","dataType":"class","summary":"Contains information that is useful to uniquely identify an object. This object is immutable.","remarks":"This object is immutable.","interfaces":["ICloneable","IEquatable<ContentHash>"],"properties":[{"signature":"ulong ByteCount","summary":"Gets the length of the content, in bytes.","since":"6.0","property":["get"]},{"signature":"DateTime HashTime","summary":"Gets the hash time, rounded to seconds.","since":"6.0","property":["get"]},{"signature":"byte[] Sha1ContentHash","summary":"Gets the 20-bytes long SHA1 hash of the content.","since":"6.0","property":["get"]},{"signature":"byte[] Sha1NameHash","summary":"Gets the 20-bytes long SHA1 hash of the name.","since":"6.0","property":["get"]}],"methods":[{"signature":"static ContentHash CreateFromFile(string path)","summary":"Creates a new ContentHash, representing the content of a file.","since":"6.0","parameters":[{"name":"path","summary":"A path. This can be None and can refer to a non-existing path."}]},{"signature":"ContentHash Clone()","summary":"Creates a copy of this content hash. Because content hash is immutable, this can be used as a deep copy.","since":"6.0","returns":"A different instance of the same content hash."},{"signature":"bool Equals(ContentHash other)","summary":"Determines if another content hash has the same value.","since":"6.0","parameters":[{"name":"other","summary":"The other content hash to compare."}],"returns":"True if the two hashes are equal."},{"signature":"bool Equals(object obj)","summary":"Determines if another object is a content hash with same value.","parameters":[{"name":"obj","summary":"The other content hash to compare."}],"returns":"True if the two hashes are equal."},{"signature":"int GetHashCode()","summary":"Gets an hash code for this content hash. Two equal content hashes have equal hash code. The other way around might not be true.","returns":"An hash code value."}]},{"namespace":"Rhino.FileIO","name":"DracoCompression","dataType":"class","summary":"Google Draco compression for mesh and point cloud data","interfaces":["IDisposable"],"methods":[{"signature":"static DracoCompression Compress(Mesh mesh)","summary":"Compress a mesh using default compression options.","since":"7.0","parameters":[{"name":"mesh","summary":"mesh to compress"}],"returns":"instance of class representing the compressed data"},{"signature":"static DracoCompression Compress(Mesh mesh, DracoCompressionOptions options)","summary":"Compress a mesh","since":"7.0","parameters":[{"name":"mesh","summary":"mesh to compress"},{"name":"options","summary":"options used to determine how the compression will occur"}],"returns":"instance of class representing the compressed data"},{"signature":"static Rhino.Geometry.GeometryBase DecompressBase64String(string encoded)","summary":"Decompress base64 encoded version of Draco data into either a mesh or point cloud","since":"7.0","parameters":[{"name":"encoded","summary":"compressed Draco data"}],"returns":"Mesh or point cloud on success. None on failure"},{"signature":"static Rhino.Geometry.GeometryBase DecompressByteArray(byte[] bytes)","summary":"Decompress data into either a mesh or point cloud.","since":"7.0","parameters":[{"name":"bytes","summary":"compressed Draco data"}],"returns":"Mesh or point cloud on success. None on failure"},{"signature":"static Rhino.Geometry.GeometryBase DecompressFile(string path)","summary":"Read compressed data from disk and decompress to RhinoCommon geometry","since":"7.0","parameters":[{"name":"path","summary":"path to read from"}],"returns":"Mesh or point cloud on success. None on failure"},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"7.0"},{"signature":"string ToBase64String()","summary":"Convert byte array of Draco compressed data into a base64 encoded string","since":"7.0"},{"signature":"bool Write(string path)","summary":"Write the compressed data to disk","since":"7.0","parameters":[{"name":"path","summary":"path to write to"}],"returns":"True on success"}]},{"namespace":"Rhino.FileIO","name":"DracoCompressionOptions","dataType":"class","summary":"Options for applying Draco compression","constructors":[{"signature":"DracoCompressionOptions()","summary":"Initializes to default options","since":"7.0"}],"properties":[{"signature":"int CompressionLevel","summary":"Compression level. 0 if fastest, but least compression. 10 is slowest, but best compression","since":"7.0","property":["get","set"]},{"signature":"int NormalQuantizationBits","summary":"Sets the quantization compression options for normal values. The values will be quantized in a box defined by the maximum extent of the values. I.e., the actual precision of this option depends on the scale of the attribute values.","since":"7.0","property":["get","set"]},{"signature":"int PositionQuantizationBits","summary":"Sets the quantization compression options for position values. The values will be quantized in a box defined by the maximum extent of the values. I.e., the actual precision of this option depends on the scale of the attribute values.","since":"7.0","property":["get","set"]},{"signature":"int TextureCoordintateQuantizationBits","summary":"Sets the quantization compression options for texture coordinate values. The values will be quantized in a box defined by the maximum extent of the values. I.e., the actual precision of this option depends on the scale of the attribute values.","since":"7.0","property":["get","set"]}]},{"namespace":"Rhino.FileIO","name":"File3dm","dataType":"class","summary":"Represents a 3dm file, which is stored using the OpenNURBS file standard.  \\nThe 3dm format is the main Rhinoceros storage format.  \\nVisit http://www.opennurbs.com/ for more details.","interfaces":["IDisposable"],"constructors":[{"signature":"File3dm()","summary":"Initializes a new instance of a 3dm file.","since":"5.0"}],"properties":[{"signature":"File3dmDimStyleTable AllDimStyles","summary":"Dimension Styles in this file.","since":"6.0","property":["get"]},{"signature":"File3dmGroupTable AllGroups","summary":"Groups in this file.","since":"6.5","property":["get"]},{"signature":"File3dmHatchPatternTable AllHatchPatterns","summary":"Hatch patterns in this file.","since":"6.0","property":["get"]},{"signature":"File3dmInstanceDefinitionTable AllInstanceDefinitions","summary":"Instance definitions in this file","since":"6.0","property":["get"]},{"signature":"File3dmLayerTable AllLayers","summary":"Layers in this file.","since":"6.0","property":["get"]},{"signature":"File3dmLinetypeTable AllLinetypes","summary":"Linetypes in this file.","since":"6.0","property":["get"]},{"signature":"File3dmMaterialTable AllMaterials","summary":"Materials in this file.","since":"6.0","property":["get"]},{"signature":"File3dmNamedConstructionPlanes AllNamedConstructionPlanes","summary":"Named construction planes in this file.","since":"6.0","property":["get"]},{"signature":"File3dmViewTable AllNamedViews","summary":"Named views in this file.","since":"6.0","property":["get"]},{"signature":"File3dmViewTable AllViews","summary":"Views that represent the RhinoViews which are displayed when Rhino loads this file.","since":"6.0","property":["get"]},{"signature":"string ApplicationDetails","summary":"Gets or sets details for the application that wrote this file.","since":"5.0","property":["get","set"]},{"signature":"string ApplicationName","summary":"Gets or sets the name of the application that wrote this file.","since":"5.0","property":["get","set"]},{"signature":"string ApplicationUrl","summary":"Gets or sets a URL for the application that wrote this file.","since":"5.0","property":["get","set"]},{"signature":"DateTime Created","summary":"Get the DateTime that this file was originally created. If the value is not set in the 3dm file, then DateTime.MinValue is returned","since":"5.6","property":["get"]},{"signature":"string CreatedBy","summary":"Gets a string that names the user who created the file.","since":"5.0","property":["get"]},{"signature":"IList<DimensionStyle> DimStyles","summary":"Dimension Styles in this file.","since":"5.0","property":["get"]},{"signature":"IList<HatchPattern> HatchPatterns","summary":"Hatch patterns in this file","since":"5.0","property":["get"]},{"signature":"IList<InstanceDefinitionGeometry> InstanceDefinitions","summary":"Instance definitions in this file.","since":"5.6","property":["get"]},{"signature":"DateTime LastEdited","summary":"Get the DateTime that this file was last edited. If the value is not set in the 3dm file, then DateTime.MinValue is returned","since":"5.6","property":["get"]},{"signature":"string LastEditedBy","summary":"Gets a string that names the user who last edited the file.","since":"5.0","property":["get"]},{"signature":"IList<Layer> Layers","summary":"Layers in this file.","since":"5.0","property":["get"]},{"signature":"IList<Linetype> Linetypes","summary":"Linetypes in this file.","since":"5.0","property":["get"]},{"signature":"ManifestTable Manifest","summary":"Retrieves the manifest with all object descriptions in this file.","since":"6.0","property":["get"]},{"signature":"IList<Material> Materials","summary":"Materials in this file.","since":"5.0","property":["get"]},{"signature":"IList<ConstructionPlane> NamedConstructionPlanes","summary":"Named construction planes in this file.","since":"6.0","property":["get"]},{"signature":"IList<ViewInfo> NamedViews","summary":"Named views in this file.","since":"5.0","property":["get"]},{"signature":"File3dmNotes Notes","summary":"Gets or sets the model notes.","since":"5.0","property":["get","set"]},{"signature":"File3dmObjectTable Objects","summary":"Gets access to the File3dmObjectTableclass associated with this file, which contains all objects.","since":"5.0","property":["get"]},{"signature":"File3dmPlugInDataTable PlugInData","summary":"Custom plug-in data in this file.  This data is not attached to any geometry or attributes","since":"5.0","property":["get"]},{"signature":"int Revision","summary":"Gets or sets the revision number.","since":"5.0","property":["get","set"]},{"signature":"File3dmSettings Settings","summary":"Settings include tolerance, and unit system, and defaults used for creating views and objects.","since":"5.0","property":["get"]},{"signature":"string StartSectionComments","summary":"Gets or sets the start section comments, which are the comments with which the 3dm file begins.","since":"5.0","property":["get","set"]},{"signature":"File3dmStringTable Strings","summary":"Document user strings in this file","since":"6.0","property":["get"]},{"signature":"IList<ViewInfo> Views","summary":"Views that represent the RhinoViews which are displayed when Rhino loads this file.","since":"5.0","property":["get"]}],"methods":[{"signature":"static File3dm FromByteArray(byte[] bytes)","summary":"Read a 3dm file from a byte array","since":"7.0","returns":"New File3dm on success, None on error."},{"signature":"static File3dm Read(string path)","summary":"Reads a 3dm file from a specified location.","since":"5.0","parameters":[{"name":"path","summary":"The file to read."}],"returns":"new File3dm on success, None on error."},{"signature":"static File3dm Read(string path, TableTypeFilter tableTypeFilterFilter, ObjectTypeFilter objectTypeFilter)","summary":"Reads a 3dm file from a specified location.","since":"5.9","parameters":[{"name":"path","summary":"The file to read."},{"name":"tableTypeFilterFilter","summary":"If tableTypeFilterFilter is None, then everything in the archive is read. Otherwise tableTypeFilterFilter identifies what tables should be read."},{"name":"objectTypeFilter","summary":"If objectTypeFilter is not None, then is a filter made by bitwise or-ing values to select which types of objects will be read from the model object table."}],"returns":"new File3dm on success, None on error."},{"signature":"static void ReadApplicationData(string path, out string applicationName, out string applicationUrl, out string applicationDetails)","summary":"Reads only the application information from an existing 3dm file.","since":"5.0","parameters":[{"name":"path","summary":"A location on disk or network."},{"name":"applicationName","summary":"The application name. This out parameter is assigned during this call."},{"name":"applicationUrl","summary":"The application URL. This out parameter is assigned during this call."},{"name":"applicationDetails","summary":"The application details. This out parameter is assigned during this call."}]},{"signature":"static int ReadArchiveVersion(string path)","summary":"Reads only the archive 3dm version from an existing 3dm file.","since":"5.10","parameters":[{"name":"path","summary":"The file from which to read the archive version."}],"returns":"The 3dm file archive version."},{"signature":"static DimensionStyle[] ReadDimensionStyles(string path)","summary":"Read the dimension styles table out of a 3dm file.","since":"6.0","parameters":[{"name":"path","summary":"The location of the file."}],"returns":"Array of dimension styles on success (empty array if file does not contain dimension styles) None on error"},{"signature":"static string ReadNotes(string path)","summary":"Reads only the notes from an existing 3dm file.","since":"5.0","parameters":[{"name":"path","summary":"The file from which to read the notes."}],"returns":"The 3dm file notes."},{"signature":"static System.Drawing.Bitmap ReadPreviewImage(string path)","summary":"Attempts to read the preview image out of a 3dm file.","since":"5.0","parameters":[{"name":"path","summary":"The location of the file."}],"returns":"A bitmap, or None on failure."},{"signature":"static bool ReadRevisionHistory(string path, out string createdBy, out string lastEditedBy, out int revision, out DateTime createdOn, out DateTime lastEditedOn)","summary":"Quickly check a file for it\'s revision information.  This function does not read the entire file, just what it needs to get revision information out","since":"5.6","parameters":[{"name":"path","summary":"path to the 3dm file"},{"name":"createdBy","summary":"original author of the file"},{"name":"lastEditedBy","summary":"last person to edit the file"},{"name":"revision","summary":"which revision this file is at"},{"name":"createdOn","summary":"date file was created (DateTime.MinValue if not set in file)"},{"name":"lastEditedOn","summary":"date file was last edited (DateTime.MinValue if not set in file)"}],"returns":"True on success"},{"signature":"static File3dm ReadWithLog(string path, out string errorLog)","summary":"Read a 3dm file from a specified location and log any archive reading errors.","since":"5.0","parameters":[{"name":"path","summary":"The file to read."},{"name":"errorLog","summary":"Any archive reading errors are logged here."}],"returns":"New File3dm on success, None on error."},{"signature":"static File3dm ReadWithLog(string path, TableTypeFilter tableTypeFilterFilter, ObjectTypeFilter objectTypeFilter, out string errorLog)","summary":"Reads a 3dm file from a specified location.","since":"5.9","parameters":[{"name":"path","summary":"The file to read."},{"name":"tableTypeFilterFilter","summary":"If tableTypeFilterFilter is None, then everything in the archive is read. Otherwise tableTypeFilterFilter identifies what tables should be read."},{"name":"objectTypeFilter","summary":"If objectTypeFilter is not None, then is a filter made by bitwise or-ing values to select which types of objects will be read from the model object table."},{"name":"errorLog","summary":"Any archive reading errors are logged here."}],"returns":"new File3dm on success, None on error."},{"signature":"int Audit(bool attemptRepair, out int repairCount, out string errors, out int[] warnings)","summary":"This function is only kept for forward assembly compatibility.","since":"5.0","deprecated":"6.0","parameters":[{"name":"attemptRepair","summary":"Ignored."},{"name":"repairCount","summary":"Is set to 0."},{"name":"errors","summary":"Contains no meaningful error."},{"name":"warnings","summary":"Is set to null."}],"returns":"Returns 0."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"string Dump()","summary":"Prepares a text dump of the entire model.","since":"5.0","returns":"The text dump."},{"signature":"string DumpSummary()","summary":"Prepares a text dump of model properties and settings.","since":"5.0","returns":"The text dump."},{"signature":"void DumpToTextLog(TextLog log)","summary":"Prepares a text dump of the entire model.","since":"5.1"},{"signature":"System.Drawing.Bitmap GetPreviewImage()","summary":"Preview image used for file explorer","since":"6.0"},{"signature":"bool IsValid(out string errors)","summary":"The File3dm object is kept consistent during its creation. Therefore, this function now returns only true.","since":"5.0","deprecated":"6.0","parameters":[{"name":"errors","summary":"No errors are found."}],"returns":"True in any case."},{"signature":"bool IsValid(TextLog errors)","summary":"The File3dm object is kept consistent during its creation. Therefore, this function now returns only true.","since":"5.1","deprecated":"6.0","parameters":[{"name":"errors","summary":"No errors are found."}],"returns":">True in any case."},{"signature":"void Polish()","summary":"This function is only kept for forward assembly compatibility.","since":"5.0","deprecated":"6.0"},{"signature":"void SetPreviewImage(Bitmap image)","summary":"Preview image used for file explorer","since":"6.0"},{"signature":"bool Write(string path, File3dmWriteOptions options)","summary":"Writes contents of this model to an openNURBS archive. If the model is not valid, then Write will refuse to write it.","since":"5.9","parameters":[{"name":"path","summary":"The file name to use for writing."},{"name":"options","summary":"An options instance, or None for default."}],"returns":"True if archive is written with no error. False if errors occur."},{"signature":"bool Write(string path, int version)","summary":"Writes contents of this model to an openNURBS archive. If the model is not valid, then Write will refuse to write it.","since":"5.0","parameters":[{"name":"path","summary":"The file name to use for writing."},{"name":"version","summary":"Version of the openNURBS archive to write.  Must be [2; current version]. Rhino can read its current version, plus earlier file versions except 1. Use latest version when possible.  \\nAlternatively, 0 is a placeholder for the last valid version."}],"returns":"True if archive is written with no error. False if errors occur."},{"signature":"bool WriteWithLog(string path, File3dmWriteOptions options, out string errorLog)","summary":"Writes contents of this model to an openNURBS archive. If the model is not valid, then Write will refuse to write it.","since":"6.0","parameters":[{"name":"path","summary":"The file name to use for writing."},{"name":"options","summary":"An options instance, or None for default."},{"name":"errorLog","summary":"This argument will be filled by out reference."}],"returns":"True if archive is written with no error. False if errors occur."},{"signature":"bool WriteWithLog(string path, int version, out string errorLog)","summary":"Writes contents of this model to an openNURBS archive. If the model is not valid, then Write will refuse to write it.","since":"5.0","parameters":[{"name":"path","summary":"The file name to use for writing."},{"name":"version","summary":"Version of the openNURBS archive to write.  Must be [2; current version]. Rhino can read its current version, plus earlier file versions except 1. Use latest version when possible.  \\nAlternatively, 0 is a placeholder for the last valid version."},{"name":"errorLog","summary":"This argument will be filled by out reference."}],"returns":"True if archive is written with no error. False if errors occur."}]},{"namespace":"Rhino.FileIO","name":"File3dm.ObjectTypeFilter","dataType":"enum","since":"5.9","values":[{"signature":"None = UnsafeNativeMethods.ObjectTypeFilter.None"},{"signature":"Point = UnsafeNativeMethods.ObjectTypeFilter.Point","summary":"some type of Point"},{"signature":"Pointset = UnsafeNativeMethods.ObjectTypeFilter.Pointset","summary":"some type of PointCloud, PointGrid, ..."},{"signature":"Curve = UnsafeNativeMethods.ObjectTypeFilter.Curve","summary":"some type of Curve like LineCurve, NurbsCurve, etc."},{"signature":"Surface = UnsafeNativeMethods.ObjectTypeFilter.Surface","summary":"some type of Surface like PlaneSurface, NurbsSurface, etc."},{"signature":"Brep = UnsafeNativeMethods.ObjectTypeFilter.Brep","summary":"some type of Brep"},{"signature":"Mesh = UnsafeNativeMethods.ObjectTypeFilter.Mesh","summary":"some type of Mesh"},{"signature":"Annotation = UnsafeNativeMethods.ObjectTypeFilter.Annotation","summary":"some type of Annotation"},{"signature":"InstanceDefinition = UnsafeNativeMethods.ObjectTypeFilter.InstanceDefinition","summary":"some type of InstanceDefinition"},{"signature":"InstanceReference = UnsafeNativeMethods.ObjectTypeFilter.InstanceReference","summary":"some type of InstanceReference"},{"signature":"TextDot = UnsafeNativeMethods.ObjectTypeFilter.TextDot","summary":"some type of TextDot"},{"signature":"DetailView = UnsafeNativeMethods.ObjectTypeFilter.Detail","summary":"some type of DetailView"},{"signature":"Hatch = UnsafeNativeMethods.ObjectTypeFilter.Hatch","summary":"some type of Hatch"},{"signature":"Extrusion = UnsafeNativeMethods.ObjectTypeFilter.Extrusion","summary":"some type of Extrusion"},{"signature":"Any = UnsafeNativeMethods.ObjectTypeFilter.Any"}]},{"namespace":"Rhino.FileIO","name":"File3dm.TableTypeFilter","dataType":"enum","since":"5.9","values":[{"signature":"None = UnsafeNativeMethods.ReadFileTableTypeFilter.None"},{"signature":"Properties = UnsafeNativeMethods.ReadFileTableTypeFilter.PropertiesTable"},{"signature":"Settings = UnsafeNativeMethods.ReadFileTableTypeFilter.SettingsTable"},{"signature":"Bitmap = UnsafeNativeMethods.ReadFileTableTypeFilter.BitmapTable"},{"signature":"TextureMapping = UnsafeNativeMethods.ReadFileTableTypeFilter.TextureMappingTable"},{"signature":"Material = UnsafeNativeMethods.ReadFileTableTypeFilter.MaterialTable"},{"signature":"Linetype = UnsafeNativeMethods.ReadFileTableTypeFilter.LinetypeTable"},{"signature":"Layer = UnsafeNativeMethods.ReadFileTableTypeFilter.LayerTable"},{"signature":"Group = UnsafeNativeMethods.ReadFileTableTypeFilter.GroupTable"},{"signature":"Font = UnsafeNativeMethods.ReadFileTableTypeFilter.FontTable"},{"signature":"FutureFont = UnsafeNativeMethods.ReadFileTableTypeFilter.FutureFontTable"},{"signature":"Dimstyle = UnsafeNativeMethods.ReadFileTableTypeFilter.DimstyleTable"},{"signature":"Light = UnsafeNativeMethods.ReadFileTableTypeFilter.LightTable"},{"signature":"Hatchpattern = UnsafeNativeMethods.ReadFileTableTypeFilter.HatchpatternTable"},{"signature":"InstanceDefinition = UnsafeNativeMethods.ReadFileTableTypeFilter.InstanceDefinitionTable"},{"signature":"ObjectTable = UnsafeNativeMethods.ReadFileTableTypeFilter.ObjectTable"},{"signature":"Historyrecord = UnsafeNativeMethods.ReadFileTableTypeFilter.HistoryrecordTable"},{"signature":"UserTable = UnsafeNativeMethods.ReadFileTableTypeFilter.UserTable"}]},{"namespace":"Rhino.FileIO","name":"File3dmCommonComponentTable<T>","dataType":"class","summary":"Provides a base table type that is shared among all File3dm tables.","baseclass":"Rhino.FileIO.CommonComponentTable<T>","interfaces":["ICollection<T>"],"methods":[{"signature":"void Add(T item)","summary":"Adds an item.","parameters":[{"name":"item","summary":"The item to add."}]},{"signature":"void Delete(int index)","summary":"Flags a component as deleted.","parameters":[{"name":"index","summary":"The index of the item to flag."}],"returns":"True on success."},{"signature":"bool Delete(T item)","summary":"Flags a component as deleted.","parameters":[{"name":"item","summary":"The item to flag."}],"returns":"True on success."},{"signature":"string Dump()","summary":"Prepares a text dump of object table.","returns":"A string containing the dump."}]},{"namespace":"Rhino.FileIO","name":"File3dmDimStyleTable","dataType":"class","summary":"Provides access to annotation styles in the 3dm file.","baseclass":"File3dmCommonComponentTable<DimensionStyle>","interfaces":["IList<DimensionStyle>"],"properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.DimStyle.","since":"6.0","property":["get"]}],"methods":[{"signature":"DimensionStyle FindIndex(int index)","summary":"Retrieves a DimensionStyle object based on Index. This search type of search is discouraged. We are moving towards using only IDs for all tables.","since":"6.0","parameters":[{"name":"index","summary":"The index to search for."}],"returns":"A DimensionStyle object, or None if none was found."},{"signature":"DimensionStyle FindName(string name)","summary":"Finds a DimensionStyle given its name.","since":"6.0","parameters":[{"name":"name","summary":"The name of the DimensionStyle to be searched."}],"returns":"An DimensionStyle, or None on error."},{"signature":"DimensionStyle FindNameHash(NameHash nameHash)","summary":"Finds a DimensionStyle given its name hash.","since":"6.0","parameters":[{"name":"nameHash","summary":"The name hash of the DimensionStyle to be searched."}],"returns":"An DimensionStyle, or None on error."}]},{"namespace":"Rhino.FileIO","name":"File3dmGroupTable","dataType":"class","summary":"Provides access to groups in the 3dm file.","baseclass":"File3dmCommonComponentTable<Group>","interfaces":["IList<Group>"],"properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.Group.","since":"6.5","property":["get"]}],"methods":[{"signature":"Group FindIndex(int groupIndex)","summary":"Retrieves a Group object based on an index. This search type of search is discouraged. We are moving towards using only IDs for all tables.","since":"6.5","parameters":[{"name":"groupIndex","summary":"The index to search for."}],"returns":"A Group object, or None if none was found."},{"signature":"Group FindName(string name)","summary":"Finds a Group given its name.","since":"6.5","parameters":[{"name":"name","summary":"The name of the Group to be searched."}],"returns":"A Group, or None on error."},{"signature":"Group FindNameHash(NameHash nameHash)","summary":"Finds a Group given its name hash.","since":"6.5","parameters":[{"name":"nameHash","summary":"The name hash of the Group to be searched."}],"returns":"A Group, or None on error."},{"signature":"File3dmObject[] GroupMembers(int groupIndex)","summary":"Gets an array of all of the objects in a group.","since":"6.20","parameters":[{"name":"groupIndex","summary":"The index of the group in this table."}],"returns":"Array of objects that belong to the specified group or empty array if no objects could be found."}]},{"namespace":"Rhino.FileIO","name":"File3dmHatchPatternTable","dataType":"class","summary":"Provides access to hatch pattern definitions in the 3dm file.","baseclass":"File3dmCommonComponentTable<HatchPattern>","interfaces":["IList<HatchPattern>"],"properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.HatchPattern.","since":"6.0","property":["get"]}],"methods":[{"signature":"HatchPattern FindIndex(int index)","summary":"Retrieves a HatchPattern object based on Index. This search type of search is discouraged. We are moving towards using only IDs for all tables.","since":"6.0","parameters":[{"name":"index","summary":"The index to search for."}],"returns":"A HatchPattern object, or None if none was found."},{"signature":"HatchPattern FindName(string name)","summary":"Finds a HatchPattern given its name.","since":"6.0","parameters":[{"name":"name","summary":"The name of the HatchPattern to be searched."}],"returns":"An HatchPattern, or None on error."},{"signature":"HatchPattern FindNameHash(NameHash nameHash)","summary":"Finds a HatchPattern given its name hash.","since":"6.0","parameters":[{"name":"nameHash","summary":"The name hash of the HatchPattern to be searched."}],"returns":"An HatchPattern, or None on error."}]},{"namespace":"Rhino.FileIO","name":"File3dmInstanceDefinitionTable","dataType":"class","summary":"Provides access to instance (block) definitions in the 3dm file.","baseclass":"File3dmCommonComponentTable<InstanceDefinitionGeometry>","interfaces":["IList<InstanceDefinitionGeometry>"],"properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.InstanceDefinition.","since":"6.0","property":["get"]}],"methods":[{"signature":"int Add(string name, string description, Point3d basePoint, GeometryBase geometry, ObjectAttributes attributes)","summary":"Adds an instance definition to the instance definition table.","since":"6.5","parameters":[{"name":"name","summary":"The definition name."},{"name":"description","summary":"The definition description."},{"name":"basePoint","summary":"A base point."},{"name":"geometry","summary":"An element."},{"name":"attributes","summary":"An attribute."}],"returns":">=0  index of instance definition in the instance definition table. -1 on failure."},{"signature":"int Add(string name, string description, Point3d basePoint, IEnumerable<GeometryBase> geometry)","summary":"Adds an instance definition to the instance definition table.","since":"6.5","parameters":[{"name":"name","summary":"The definition name."},{"name":"description","summary":"The definition description."},{"name":"basePoint","summary":"A base point."},{"name":"geometry","summary":"An array, a list or any enumerable set of geometry."}],"returns":">=0  index of instance definition in the instance definition table. -1 on failure."},{"signature":"int Add(string name, string description, Point3d basePoint, IEnumerable<GeometryBase> geometry, IEnumerable<ObjectAttributes> attributes)","summary":"Adds an instance definition to the instance definition table.","since":"6.5","parameters":[{"name":"name","summary":"The definition name."},{"name":"description","summary":"The definition description."},{"name":"basePoint","summary":"A base point."},{"name":"geometry","summary":"An array, a list or any enumerable set of geometry."},{"name":"attributes","summary":"An array, a list or any enumerable set of attributes."}],"returns":">=0  index of instance definition in the instance definition table. -1 on failure."},{"signature":"int Add(string name, string description, string url, string urlTag, Point3d basePoint, IEnumerable<GeometryBase> geometry, IEnumerable<ObjectAttributes> attributes)","summary":"Adds an instance definition to the instance definition table.","since":"7.0","parameters":[{"name":"name","summary":"The definition name."},{"name":"description","summary":"The definition description."},{"name":"url","summary":"A URL or hyperlink."},{"name":"urlTag","summary":"A description of the URL or hyperlink."},{"name":"basePoint","summary":"A base point."},{"name":"geometry","summary":"An array, a list or any enumerable set of geometry."},{"name":"attributes","summary":"An array, a list or any enumerable set of attributes."}],"returns":">=0  index of instance definition in the instance definition table. -1 on failure."},{"signature":"int AddLinked(string filename, string name, string description)","summary":"Adds a linked instance definition to the instance definition table.","since":"6.13","parameters":[{"name":"filename","summary":"Full path of the file to link."},{"name":"name","summary":"The definition name."},{"name":"description","summary":"The definition description."}]},{"signature":"InstanceDefinitionGeometry FindName(string name)","summary":"Finds an InstanceDefinitionGeometry given its name.","since":"6.0","parameters":[{"name":"name","summary":"The name of the InstanceDefinitionGeometry to be searched."}],"returns":"An InstanceDefinitionGeometry, or None on error."},{"signature":"InstanceDefinitionGeometry FindNameHash(NameHash nameHash)","summary":"Finds a InstanceDefinitionGeometry given its name hash.","since":"6.0","parameters":[{"name":"nameHash","summary":"The name hash of the InstanceDefinitionGeometry to be searched."}],"returns":"An InstanceDefinitionGeometry, or None on error."}]},{"namespace":"Rhino.FileIO","name":"File3dmLayerTable","dataType":"class","summary":"Provides access to layers in the 3dm file.","baseclass":"File3dmCommonComponentTable<Layer>","interfaces":["IList<Layer>"],"properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.Layer.","since":"6.0","property":["get"]}],"methods":[{"signature":"Layer FindIndex(int index)","summary":"Retrieves a Layer object based on Index. This search type of search is discouraged. We are moving towards using only IDs for all tables.","since":"6.0","parameters":[{"name":"index","summary":"The index to search for."}],"returns":"A Layer object, or None if none was found."},{"signature":"Layer FindName(string name, Guid parentId)","summary":"Finds a Layer given its name.","since":"6.0","parameters":[{"name":"name","summary":"The name of the Layer to be searched."},{"name":"parentId","summary":"The id of the parent Layer to be searched."}],"returns":"A Layer, or None on error."},{"signature":"Layer FindNameHash(NameHash nameHash)","summary":"Finds a Layer given its name hash.","since":"6.0","parameters":[{"name":"nameHash","summary":"The name hash of the Layer to be searched."}],"returns":"An Layer, or None on error."}]},{"namespace":"Rhino.FileIO","name":"File3dmLinetypeTable","dataType":"class","summary":"Provides access to Linetypes in the 3dm file.","baseclass":"File3dmCommonComponentTable<Linetype>","interfaces":["IList<DocObjects.Linetype>"],"properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.LinePattern.","since":"6.0","property":["get"]}],"methods":[{"signature":"Linetype FindIndex(int index)","summary":"Retrieves a Linetype object based on Index. This search type of search is discouraged. We are moving towards using only IDs for all tables.","since":"6.0","parameters":[{"name":"index","summary":"The index to search for."}],"returns":"A Linetype, or None if none was found."},{"signature":"Linetype FindName(string name)","summary":"Finds a Linetype given its name.","since":"6.0","parameters":[{"name":"name","summary":"The name of the Linetype to be searched."}],"returns":"A Linetype, or None on error."},{"signature":"Linetype FindNameHash(NameHash nameHash)","summary":"Finds a Linetype given its name hash.","since":"6.0","parameters":[{"name":"nameHash","summary":"The name hash of the Linetype to be searched."}],"returns":"An Linetype, or None on error."}]},{"namespace":"Rhino.FileIO","name":"File3dmMaterialTable","dataType":"class","summary":"Provides access to materials in the 3dm file.","baseclass":"File3dmCommonComponentTable<Material>","interfaces":["IList<DocObjects.Material>"],"properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.RenderMaterial.","since":"6.0","property":["get"]}],"methods":[{"signature":"DocObjects.Material FindIndex(int index)","summary":"Retrieves a material based on Index. This search type of search is discouraged. We are moving towards using only IDs for all tables.","since":"6.0","parameters":[{"name":"index","summary":"The index to search for."}],"returns":"A material, or None if none was found."}]},{"namespace":"Rhino.FileIO","name":"File3dmNamedConstructionPlanes","dataType":"class","summary":"Provides access to named construction planes in the 3dm file.","interfaces":["IList<ConstructionPlane>","Collections.IRhinoTable<ConstructionPlane>"],"properties":[{"signature":"int Count","summary":"Number of named construction planes in the table.","since":"6.0","property":["get"]}],"methods":[{"signature":"void Add(ConstructionPlane cplane)","summary":"Adds a named construction plane to the table.","since":"6.0","parameters":[{"name":"cplane","summary":"The construction plane to add."}]},{"signature":"int Add(string name, Plane plane)","summary":"Adds a named construction plane to the table.","since":"6.0","parameters":[{"name":"name","summary":"The name of the named construction plane."},{"name":"plane","summary":"The plane value."}],"returns":"0 based index of the named construction plane. -1 on failure."},{"signature":"void Clear()","summary":"Removes all named construction planes from the table.","since":"6.0"},{"signature":"bool Contains(ConstructionPlane cplane)","summary":"Returns an indication of the presence of a named construction plane in the table.","since":"6.0","parameters":[{"name":"cplane","summary":"The construction plane to check."}],"returns":"True if the named construction plane is in the table; False otherwise."},{"signature":"void CopyTo(ConstructionPlane[] array, int arrayIndex)","summary":"Copies the content of the table to an array.","since":"6.0"},{"signature":"bool Delete(ConstructionPlane cplane)","summary":"Deletes a named construction plane from the table.","since":"6.0","parameters":[{"name":"cplane","summary":"The construction plane to delete."}]},{"signature":"bool Delete(int index)","summary":"Remove a named construction plane from the table.","since":"6.0","parameters":[{"name":"index","summary":"Zero based array index."}],"returns":"True if successful."},{"signature":"ConstructionPlane FindName(string name)","summary":"Finds a named construction plane given its name.","since":"6.0","parameters":[{"name":"name","summary":"The name of the construction plane to be searched."}],"returns":"A ConstructionPlane, or None if not found."},{"signature":"IEnumerator<ConstructionPlane> GetEnumerator()","summary":"Gets an enumerator that yields all construction planes in this collection.","since":"6.0","returns":"The enumerator."},{"signature":"int IndexOf(ConstructionPlane cplane)","summary":"Returns the index of a named construction plane.","since":"6.0","parameters":[{"name":"cplane","summary":"The construction plane to be searched."}],"returns":"The index of the named construction plane, -1 if not found."}]},{"namespace":"Rhino.FileIO","name":"File3dmNotes","dataType":"class","summary":"Represents the notes information stored in a 3dm file.","constructors":[{"signature":"File3dmNotes()","summary":"Creates empty default notes","since":"5.0"}],"properties":[{"signature":"bool IsHtml","summary":"Gets or sets the text format. If the format is HTML, true; False otherwise.","since":"5.0","property":["get","set"]},{"signature":"bool IsVisible","summary":"Gets or sets the notes visibility. If the notes are visible, true; False otherwise.","since":"5.0","property":["get","set"]},{"signature":"string Notes","summary":"Gets or sets the text content of the notes.","since":"5.0","property":["get","set"]},{"signature":"Rectangle WindowRectangle","summary":"Gets or sets the position of the Notes when they were saved.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.FileIO","name":"File3dmObject","dataType":"class","summary":"Used to store geometry table object definition and attributes in a File3dm.","baseclass":"Rhino.DocObjects.ModelComponent","interfaces":["IEquatable<File3dmObject>"],"properties":[{"signature":"ObjectAttributes Attributes","summary":"Gets the attributes that are linked with this document object.","since":"5.0","property":["get"]},{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.ModelGeometry.","since":"6.0","property":["get"]},{"signature":"GeometryBase Geometry","summary":"Gets the geometry that is linked with this document object.","since":"5.0","property":["get"]},{"signature":"string Name","summary":"Gets or sets the Name of the object. Equivalent to this.Attributes.Name.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"bool Equals(File3dmObject other)","summary":"Verified that two File3dmObject items refer to the same object in a document.","since":"6.0","parameters":[{"name":"other","summary":"The other item to test."}],"returns":"True is the two objects coincide."},{"signature":"bool Equals(object obj)","summary":"Verified that two objects refer to the same object in a document.","parameters":[{"name":"obj","summary":"The other item to test."}],"returns":"True is the two objects coincide."},{"signature":"int GetHashCode()","summary":"Provides an hash code for this item.","returns":"The hash code."}]},{"namespace":"Rhino.FileIO","name":"File3dmObjectTable","dataType":"class","summary":"Represents a simple object table for a file that is open externally.  \\nThis class mimics Rhino.DocObjects.Tables.ObjectTable while providing external access to the file.","baseclass":"File3dmCommonComponentTable<File3dmObject>","interfaces":["IEnumerable<File3dmObject>"],"properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.ModelGeometry.","since":"6.0","property":["get"]},{"signature":"int Count","summary":"Returns the total amount of items in the object table, including lights.","since":"5.0","property":["get"]}],"methods":[{"signature":"void Add(File3dmObject item)","summary":"Duplicates the object, then adds a copy of the object to the document.","since":"6.0","parameters":[{"name":"item","summary":"The item to duplicate and add."}]},{"signature":"Guid AddAngularDimension(AngularDimension dimension)","summary":"Adds a angular dimension object to the 3dm file object table.","since":"6.5","parameters":[{"name":"dimension","summary":"Dimension object to add."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddAngularDimension(AngularDimension dimension, ObjectAttributes attributes)","summary":"Adds a angular dimension object to the 3dm file object table.","since":"6.5","parameters":[{"name":"dimension","summary":"Dimension object to add."},{"name":"attributes","summary":"Attributes to apply to dimension."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddArc(Arc arc)","summary":"Adds a curve object to the document representing an arc.","since":"5.0","parameters":[{"name":"arc","summary":"An arc."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddArc(Arc arc, ObjectAttributes attributes)","summary":"Adds a curve object to the document representing an arc.","since":"5.0","parameters":[{"name":"arc","summary":"An arc to add."},{"name":"attributes","summary":"attributes to apply to arc."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddBrep(Brep brep)","summary":"Adds a brep object to Rhino.","since":"5.0","parameters":[{"name":"brep","summary":"A duplicate of this brep is added to Rhino."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddBrep(Brep brep, ObjectAttributes attributes)","summary":"Adds a brep object to Rhino.","since":"5.0","parameters":[{"name":"brep","summary":"A duplicate of this brep is added to Rhino."},{"name":"attributes","summary":"Attributes to apply to brep."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddCircle(Circle circle)","summary":"Adds a curve object to the document representing a circle.","since":"5.0","parameters":[{"name":"circle","summary":"A circle to add."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddCircle(Circle circle, ObjectAttributes attributes)","summary":"Adds a curve object to the document representing a circle.","since":"5.0","parameters":[{"name":"circle","summary":"A circle to add."},{"name":"attributes","summary":"attributes to apply to circle."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddClippingPlane(Plane plane, double uMagnitude, double vMagnitude, Guid clippedViewportId)","summary":"Adds a clipping plane object to Rhino.","since":"5.0","parameters":[{"name":"plane","summary":"A plane."},{"name":"uMagnitude","summary":"The size in U direction."},{"name":"vMagnitude","summary":"The size in V direction."},{"name":"clippedViewportId","summary":"The viewport id that the new clipping plane will clip."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddClippingPlane(Plane plane, double uMagnitude, double vMagnitude, IEnumerable<Guid> clippedViewportIds)","summary":"Adds a clipping plane object to Rhino.","since":"5.0","parameters":[{"name":"plane","summary":"A plane."},{"name":"uMagnitude","summary":"The size in U direction."},{"name":"vMagnitude","summary":"The size in V direction."},{"name":"clippedViewportIds","summary":"A list, an array or any enumerable of viewport ids that the new clipping plane will clip."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddClippingPlane(Plane plane, double uMagnitude, double vMagnitude, IEnumerable<Guid> clippedViewportIds, ObjectAttributes attributes)","summary":"Adds a clipping plane object to Rhino.","since":"5.0","parameters":[{"name":"plane","summary":"A plane."},{"name":"uMagnitude","summary":"The size in U direction."},{"name":"vMagnitude","summary":"The size in V direction."},{"name":"clippedViewportIds","summary":"list of viewport ids that the new clipping plane will clip."},{"name":"attributes","summary":"Attributes to apply to point cloud."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddCurve(Curve curve)","summary":"Adds a curve object to the table.","since":"5.0","parameters":[{"name":"curve","summary":"A curve to add."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddCurve(Curve curve, ObjectAttributes attributes)","summary":"Adds a curve object to the table.","since":"5.0","parameters":[{"name":"curve","summary":"A duplicate of this curve is added to Rhino."},{"name":"attributes","summary":"Attributes to apply to curve."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddEllipse(Ellipse ellipse)","summary":"Adds a curve object to the document representing an ellipse.","since":"5.0","parameters":[{"name":"ellipse","summary":"An ellipse to add."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddEllipse(Ellipse ellipse, ObjectAttributes attributes)","summary":"Adds a curve object to the document representing an ellipse.","since":"5.0","parameters":[{"name":"ellipse","summary":"An ellipse to add."},{"name":"attributes","summary":"attributes to apply to ellipse."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddExtrusion(Extrusion extrusion)","summary":"Adds an extrusion object to Rhino.","since":"5.0","parameters":[{"name":"extrusion","summary":"A duplicate of this extrusion is added to Rhino."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddExtrusion(Extrusion extrusion, ObjectAttributes attributes)","summary":"Adds an extrusion object to Rhino.","since":"5.0","parameters":[{"name":"extrusion","summary":"A duplicate of this extrusion is added to Rhino."},{"name":"attributes","summary":"Attributes to link to the object."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddHatch(Hatch hatch)","summary":"Adds a hatch to the document.","since":"5.0","parameters":[{"name":"hatch","summary":"A hatch."}],"returns":"A unique identifier for the hatch, or Guid.Emptyon failure."},{"signature":"Guid AddHatch(Hatch hatch, ObjectAttributes attributes)","summary":"Adds a hatch to the document.","since":"5.0","parameters":[{"name":"hatch","summary":"A hatch."},{"name":"attributes","summary":"Attributes to apply to brep."}],"returns":"A unique identifier for the hatch, or Guid.Emptyon failure."},{"signature":"Guid AddInstanceObject(InstanceReferenceGeometry instanceReference)","summary":"Adds an instance reference geometry object to the table.","since":"6.5","parameters":[{"name":"instanceReference","summary":"The instance reference geometry object."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddInstanceObject(InstanceReferenceGeometry instanceReference, ObjectAttributes attributes)","summary":"Adds an instance reference geometry object to the table.","since":"6.5","parameters":[{"name":"instanceReference","summary":"The instance reference geometry object."},{"name":"attributes","summary":"The attributes to link with the object."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddInstanceObject(int instanceDefinitionIndex, Transform instanceXform)","summary":"Adds an instance reference geometry object to the table.","since":"6.5","parameters":[{"name":"instanceDefinitionIndex","summary":"The index of the instance definition geometry object."},{"name":"instanceXform","summary":"The transformation."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddInstanceObject(int instanceDefinitionIndex, Transform instanceXform, ObjectAttributes attributes)","summary":"Adds an instance reference geometry object to the table.","since":"6.5","parameters":[{"name":"instanceDefinitionIndex","summary":"The index of the instance definition geometry object."},{"name":"instanceXform","summary":"The transformation."},{"name":"attributes","summary":"The object attributes."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddLeader(IEnumerable<Point3d> points)","summary":"Adds an annotation leader to the document. This overload is only provided in the Rhino SDK.","since":"5.0","parameters":[{"name":"points","summary":"A list, an array or any enumerable set of 2d points."}],"returns":"A unique identifier for the object; or Guid.Emptyon failure."},{"signature":"Guid AddLeader(Plane plane, IEnumerable<Point2d> points)","summary":"Adds an annotation leader to the document.","since":"5.0","parameters":[{"name":"plane","summary":"A plane."},{"name":"points","summary":"A list, an array or any enumerable set of 2d points."}],"returns":"A unique identifier for the object; or Guid.Emptyon failure."},{"signature":"Guid AddLeader(Plane plane, IEnumerable<Point2d> points, ObjectAttributes attributes)","summary":"Adds an annotation leader to the document.","since":"5.0","parameters":[{"name":"plane","summary":"A plane."},{"name":"points","summary":"A list, an array or any enumerable set of 2d points."},{"name":"attributes","summary":"Attributes to apply to brep."}],"returns":"A unique identifier for the object; or Guid.Emptyon failure."},{"signature":"Guid AddLeader(string text, IEnumerable<Point3d> points)","summary":"Adds an annotation leader to the document. This overload is only provided in the Rhino SDK.","since":"5.0","parameters":[{"name":"text","summary":"The text."},{"name":"points","summary":"A list, an array or any enumerable set of 2d points."}],"returns":"A unique identifier for the object; or Guid.Emptyon failure."},{"signature":"Guid AddLeader(string text, Plane plane, IEnumerable<Point2d> points)","summary":"Adds an annotation leader to the document.","since":"5.0","parameters":[{"name":"text","summary":"The text."},{"name":"plane","summary":"A plane."},{"name":"points","summary":"A list, an array or any enumerable set of 2d points."}],"returns":"A unique identifier for the object; or Guid.Emptyon failure."},{"signature":"Guid AddLeader(string text, Plane plane, IEnumerable<Point2d> points, ObjectAttributes attributes)","summary":"Adds an annotation leader to the document.","since":"5.0","parameters":[{"name":"text","summary":"The text."},{"name":"plane","summary":"A plane."},{"name":"points","summary":"A list, an array or any enumerable set of 2d points."},{"name":"attributes","summary":"Attributes to apply to brep."}],"returns":"A unique identifier for the object; or Guid.Emptyon failure."},{"signature":"Guid AddLine(Line line)","summary":"Adds a line object to Rhino.","since":"5.0","returns":"A unique identifier for the object."},{"signature":"Guid AddLine(Line line, ObjectAttributes attributes)","summary":"Adds a line object to Rhino.","since":"5.0","parameters":[{"name":"line","summary":"A line."},{"name":"attributes","summary":"Attributes to apply to line."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddLine(Point3d from, Point3d to)","summary":"Adds a line object to Rhino.","since":"5.0","parameters":[{"name":"from","summary":"A line start point."},{"name":"to","summary":"A line end point."}],"returns":"A unique identifier of new rhino object."},{"signature":"Guid AddLine(Point3d from, Point3d to, ObjectAttributes attributes)","summary":"Adds a line object to Rhino.","since":"5.0","parameters":[{"name":"from","summary":"The start point of the line."},{"name":"to","summary":"The end point of the line."},{"name":"attributes","summary":"Attributes to apply to line."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddLinearDimension(LinearDimension dimension)","summary":"Adds a linear dimension to the 3dm file object table.","since":"5.0","parameters":[{"name":"dimension","summary":"A dimension."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddLinearDimension(LinearDimension dimension, ObjectAttributes attributes)","summary":"Adds a linear dimension to the 3dm file object table.","since":"5.0","parameters":[{"name":"dimension","summary":"A dimension."},{"name":"attributes","summary":"Attributes to apply to dimension."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddMesh(Mesh mesh)","summary":"Adds a mesh object to Rhino.","since":"5.0","parameters":[{"name":"mesh","summary":"A duplicate of this mesh is added to Rhino."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddMesh(Mesh mesh, ObjectAttributes attributes)","summary":"Adds a mesh object to Rhino.","since":"5.0","parameters":[{"name":"mesh","summary":"A duplicate of this mesh is added to Rhino."},{"name":"attributes","summary":"Attributes to link to the object."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPoint(double x, double y, double z)","summary":"Adds a point object to the table.","since":"5.0","parameters":[{"name":"x","summary":"X component of point coordinate."},{"name":"y","summary":"Y component of point coordinate."},{"name":"z","summary":"Z component of point coordinate."}],"returns":"id of new object."},{"signature":"Guid AddPoint(Point3d point)","summary":"Adds a point object to the table.","since":"5.0","parameters":[{"name":"point","summary":"A location for point."}],"returns":"Id of new object."},{"signature":"Guid AddPoint(Point3d point, ObjectAttributes attributes)","summary":"Adds a point object to the document.","since":"5.0","parameters":[{"name":"point","summary":"A location for point."},{"name":"attributes","summary":"attributes to apply to point."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPoint(Point3f point)","summary":"Adds a point object to the document.","since":"5.0","parameters":[{"name":"point","summary":"location of point."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPoint(Point3f point, ObjectAttributes attributes)","summary":"Adds a point object to the document.","since":"5.0","parameters":[{"name":"point","summary":"location of point."},{"name":"attributes","summary":"attributes to apply to point."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPointCloud(IEnumerable<Point3d> points)","summary":"Adds a point cloud object to the document.","since":"5.0","parameters":[{"name":"points","summary":"A list, an array or any enumerable set of Point3d."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPointCloud(IEnumerable<Point3d> points, ObjectAttributes attributes)","summary":"Adds a point cloud object to the document.","since":"5.0","parameters":[{"name":"points","summary":"A list, an array or any enumerable set of Point3d."},{"name":"attributes","summary":"Attributes to apply to point cloud."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPointCloud(PointCloud cloud)","summary":"Adds a point cloud object to the document.","since":"5.0","parameters":[{"name":"cloud","summary":"PointCloud to add."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPointCloud(PointCloud cloud, ObjectAttributes attributes)","summary":"Adds a point cloud object to the document.","since":"5.0","parameters":[{"name":"cloud","summary":"PointCloud to add."},{"name":"attributes","summary":"attributes to apply to point cloud."}],"returns":"A unique identifier for the object."},{"signature":"Guid[] AddPoints(IEnumerable<Point3d> points)","summary":"Adds multiple points to the document.","since":"5.0","parameters":[{"name":"points","summary":"Points to add."}],"returns":"List of object ids."},{"signature":"Guid[] AddPoints(IEnumerable<Point3d> points, ObjectAttributes attributes)","summary":"Adds multiple points to the document.","since":"5.0","parameters":[{"name":"points","summary":"Points to add."},{"name":"attributes","summary":"Attributes to apply to point objects."}],"returns":"An array of object unique identifiers."},{"signature":"Guid[] AddPoints(IEnumerable<Point3f> points)","summary":"Adds multiple points to the document.","since":"5.0","parameters":[{"name":"points","summary":"Points to add."}],"returns":"An array of object unique identifiers."},{"signature":"Guid[] AddPoints(IEnumerable<Point3f> points, ObjectAttributes attributes)","summary":"Adds multiple points to the document.","since":"5.0","parameters":[{"name":"points","summary":"Points to add."},{"name":"attributes","summary":"Attributes to apply to point objects."}],"returns":"An array of object unique identifiers."},{"signature":"Guid AddPolyline(IEnumerable<Point3d> points)","summary":"Adds a polyline object to Rhino.","since":"5.0","parameters":[{"name":"points","summary":"A list, an array or any enumerable set of Point3d."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddPolyline(IEnumerable<Point3d> points, ObjectAttributes attributes)","summary":"Adds a polyline object to Rhino.","since":"5.0","parameters":[{"name":"points","summary":"A list, an array or any enumerable set of Point3d."},{"name":"attributes","summary":"Attributes to apply to line."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddSphere(Sphere sphere)","summary":"Adds a surface object to the document representing a sphere.","since":"5.0","parameters":[{"name":"sphere","summary":"A sphere to add."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddSphere(Sphere sphere, ObjectAttributes attributes)","summary":"Adds a surface object to the document representing a sphere.","since":"5.0","parameters":[{"name":"sphere","summary":"A sphere to add."},{"name":"attributes","summary":"Attributes to link with the sphere."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddSurface(Surface surface)","summary":"Adds a surface object to Rhino.","since":"5.0","parameters":[{"name":"surface","summary":"A duplicate of this surface is added to Rhino."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddSurface(Surface surface, ObjectAttributes attributes)","summary":"Adds a surface object to Rhino.","since":"5.0","parameters":[{"name":"surface","summary":"A duplicate of this surface is added to Rhino."},{"name":"attributes","summary":"Attributes to link to the object."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddText(string text, Plane plane, double height, string fontName, bool bold, bool italic)","summary":"Adds an annotation text object to the document.","since":"5.0","parameters":[{"name":"text","summary":"Text string."},{"name":"plane","summary":"Plane of text."},{"name":"height","summary":"Height of text."},{"name":"fontName","summary":"Name of FontFace."},{"name":"bold","summary":"Bold flag."},{"name":"italic","summary":"Italic flag."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddText(string text, Plane plane, double height, string fontName, bool bold, bool italic, ObjectAttributes attributes)","summary":"Adds an annotation text object to the document.","since":"5.0","parameters":[{"name":"text","summary":"Text string."},{"name":"plane","summary":"Plane of text."},{"name":"height","summary":"Height of text."},{"name":"fontName","summary":"Name of FontFace."},{"name":"bold","summary":"Bold flag."},{"name":"italic","summary":"Italic flag."},{"name":"attributes","summary":"Object Attributes."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddText(string text, Plane plane, double height, string fontName, bool bold, bool italic, TextJustification justification)","summary":"Adds an annotation text object to the document.","since":"5.0","parameters":[{"name":"text","summary":"Text string."},{"name":"plane","summary":"Plane of text."},{"name":"height","summary":"Height of text."},{"name":"fontName","summary":"Name of FontFace."},{"name":"bold","summary":"Bold flag."},{"name":"italic","summary":"Italic flag."},{"name":"justification","summary":"The justification of the text."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddText(string text, Plane plane, double height, string fontName, bool bold, bool italic, TextJustification justification, ObjectAttributes attributes)","summary":"Adds an annotation text object to the document.","since":"5.0","parameters":[{"name":"text","summary":"Text string."},{"name":"plane","summary":"Plane of text."},{"name":"height","summary":"Height of text."},{"name":"fontName","summary":"Name of FontFace."},{"name":"bold","summary":"Bold flag."},{"name":"italic","summary":"Italic flag."},{"name":"justification","summary":"The justification of the text."},{"name":"attributes","summary":"Attributes to link to the object."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddText(Text3d text3d)","summary":"Adds an annotation text object to the document.","since":"5.0","parameters":[{"name":"text3d","summary":"The text object to add."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddText(Text3d text3d, ObjectAttributes attributes)","summary":"Adds an annotation text object to the document.","since":"5.0","parameters":[{"name":"text3d","summary":"The text object to add."},{"name":"attributes","summary":"Attributes to link to the object."}],"returns":"The Guid of the newly added object or Guid.Empty on failure."},{"signature":"Guid AddTextDot(string text, Point3d location)","summary":"Adds a text dot object to the table.","since":"5.0","parameters":[{"name":"text","summary":"The text."},{"name":"location","summary":"The location."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddTextDot(string text, Point3d location, ObjectAttributes attributes)","summary":"Adds a text dot object to the table.","since":"5.0","parameters":[{"name":"text","summary":"The text."},{"name":"location","summary":"The location."},{"name":"attributes","summary":"Attributes to link with curve."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddTextDot(TextDot dot)","summary":"Adds a text dot object to the table.","since":"5.0","parameters":[{"name":"dot","summary":"The text dot."}],"returns":"A unique identifier for the object."},{"signature":"Guid AddTextDot(TextDot dot, ObjectAttributes attributes)","summary":"Adds a text dot object to the table.","since":"5.0","parameters":[{"name":"dot","summary":"The text dot."},{"name":"attributes","summary":"Attributes to link with text dot."}],"returns":"A unique identifier for the object."},{"signature":"bool Delete(Guid objectId)","summary":"Deletes object from document.","since":"5.2","parameters":[{"name":"objectId","summary":"Id of the object to delete."}],"returns":"True on success, False on failure."},{"signature":"int Delete(IEnumerable<Guid> objectIds)","summary":"Deletes a collection of objects from the document.","since":"5.2","parameters":[{"name":"objectIds","summary":"Ids of all objects to delete."}],"returns":"The number of successfully deleted objects."},{"signature":"File3dmObject[] FindByGroup(Group group)","summary":"Finds all File3dmObject that are in a given group.","since":"6.20","parameters":[{"name":"group","summary":"A group instance."}],"returns":"Array of objects that belong to the specified group or empty array if no objects could be found."},{"signature":"File3dmObject[] FindByLayer(Layer layer)","summary":"Finds all File3dmObject that are in a given layer.","since":"6.0","parameters":[{"name":"layer","summary":"A layer instance."}],"returns":"Array of objects that belong to the specified layer or empty array if no objects could be found."},{"signature":"File3dmObject[] FindByLayer(string layer)","summary":"Finds all File3dmObject that are in a given layer.","since":"5.0","parameters":[{"name":"layer","summary":"Layer to search."}],"returns":"Array of objects that belong to the specified layer or empty array if no objects could be found."},{"signature":"Rhino.Geometry.BoundingBox GetBoundingBox()","summary":"Gets the bounding box containing every object in this table.","since":"5.0","returns":"The computed bounding box."},{"signature":"IEnumerator<File3dmObject> GetEnumerator()","summary":"Returns an enumerator that yields all objects in this document. Like in Rhino, this includes lights. Unlike in Rhino, however, all lights are returned in the end of the list.","since":"5.0","returns":"An enumerator that yields all objects in a document."}]},{"namespace":"Rhino.FileIO","name":"File3dmPlugInData","dataType":"class","summary":"Represents custom plug-in data in the 3dm file written by a plug-in.","interfaces":["IDisposable"],"properties":[{"signature":"Guid PlugInId","summary":"Returns the id of the plug-in that is associated with this custom data.","since":"5.0","property":["get"]}],"methods":[{"signature":"BinaryArchiveReader ArchiveReader()","summary":"Gets a binary archive reader that can be used to read custom data that was written to the 3dm file by a Rhino plug-in. This custom data must be read in exactly the same manner that owning plug-in reads the data.","since":"7.0","returns":"A binary archive reader if successful, None otherwise."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"7.0"}]},{"namespace":"Rhino.FileIO","name":"File3dmPlugInDataTable","dataType":"class","summary":"Table of custom data provided by plug-ins","interfaces":["IEnumerable<File3dmPlugInData>","Collections.IRhinoTable<File3dmPlugInData>"],"properties":[{"signature":"int Count","summary":"Gets the number of File3dmPlugInData in this table.","since":"5.0","property":["get"]}],"methods":[{"signature":"void Clear()","summary":"Remove all entries from this table","since":"5.0"},{"signature":"string Dump()","summary":"Prepares a text dump of table.","since":"5.0","returns":"A string containing the dump."},{"signature":"IEnumerator<File3dmPlugInData> GetEnumerator()","summary":"Gets the enumerator that visits any File3dmPlugInDatain this table.","since":"5.0","returns":"The enumerator."}]},{"namespace":"Rhino.FileIO","name":"File3dmSettings","dataType":"class","summary":"General settings in a 3dm file.","properties":[{"signature":"double ModelAbsoluteTolerance","summary":"Gets or sets the model space absolute tolerance.","since":"5.0","property":["get","set"]},{"signature":"double ModelAngleToleranceDegrees","summary":"Gets or sets the model space angle tolerance.","since":"5.0","property":["get","set"]},{"signature":"double ModelAngleToleranceRadians","summary":"Gets or sets the model space angle tolerance.","since":"5.0","property":["get","set"]},{"signature":"Point3d ModelBasepoint","summary":"Gets or sets the model base point that is used when the file is read as an instance definition.  \\nThis point is mapped to the origin in the instance definition.","since":"5.0","property":["get","set"]},{"signature":"double ModelRelativeTolerance","summary":"Gets or sets the model space relative tolerance.","since":"5.0","property":["get","set"]},{"signature":"UnitSystem ModelUnitSystem","summary":"Gets or sets the model unit system, using Rhino.UnitSystemenumeration.","since":"5.0","property":["get","set"]},{"signature":"string ModelUrl","summary":"Gets or sets a Uniform Resource Locator (URL) direction for the model.","since":"5.0","property":["get","set"]},{"signature":"double PageAbsoluteTolerance","summary":"Gets or sets the page space absolute tolerance.","since":"5.0","property":["get","set"]},{"signature":"double PageAngleToleranceDegrees","summary":"Gets or sets the page space angle tolerance.","since":"5.0","property":["get","set"]},{"signature":"double PageAngleToleranceRadians","summary":"Gets or sets the page space angle tolerance.","since":"5.0","property":["get","set"]},{"signature":"double PageRelativeTolerance","summary":"Gets or sets the page space relative tolerance.","since":"5.0","property":["get","set"]},{"signature":"UnitSystem PageUnitSystem","summary":"Gets or sets the page unit system, using Rhino.UnitSystemenumeration.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.FileIO","name":"File3dmStringTable","dataType":"class","summary":"Provides access to document strings in the 3dm file.","properties":[{"signature":"int Count","summary":"Returns the number of document strings in the 3dm file.","since":"6.0","property":["get"]},{"signature":"int DocumentUserTextCount","summary":"Returns the number of Section/Entry-style key values.","since":"6.0","property":["get"]}],"methods":[{"signature":"void Delete(string key)","summary":"Removes a document string from the 3dm file.","since":"6.0","parameters":[{"name":"key","summary":"The key to remove."}]},{"signature":"void Delete(string section, string entry)","summary":"Removes document strings from the 3dm file.","since":"6.0","parameters":[{"name":"section","summary":"name of section to delete. If null, all sections will be deleted."},{"name":"entry","summary":"name of entry to delete. If null, all entries will be deleted for a given section."}]},{"signature":"string[] GetEntryNames(string section)","summary":"Return list of all entry names for a given section of document strings in the 3dm file.","since":"6.0","parameters":[{"name":"section","summary":"The section from which to retrieve section names."}],"returns":"An array of section names. This can be empty, but not null."},{"signature":"string GetKey(int i)","summary":"Returns a key value at a given index.","since":"6.0","parameters":[{"name":"i","summary":"The index."}],"returns":"The key if successful."},{"signature":"string[] GetSectionNames()","summary":"Returns a list of all the section names for document strings in the 3dm file.  \\nBy default a section name is a key that is prefixed with a string separated by a backslash.","since":"6.0","returns":"An array of section names. This can be empty, but not null."},{"signature":"string GetValue(int i)","summary":"Returns a string value at a given index.","since":"6.0","parameters":[{"name":"i","summary":"The index at which to get the value."}],"returns":"The string value if successful."},{"signature":"string GetValue(string key)","summary":"Returns a string value at a key.","since":"6.0","parameters":[{"name":"key","summary":"The key at which to get the value."}],"returns":"The string value if successful."},{"signature":"string GetValue(string section, string entry)","summary":"Returns a string value given a section and entry.","since":"6.0","parameters":[{"name":"section","summary":"The section at which to get the value."},{"name":"entry","summary":"The entry to search for."}],"returns":"The string value if successful."},{"signature":"string SetString(string key, string value)","summary":"Adds or sets a a document string in the 3dm file.","since":"6.0","parameters":[{"name":"key","summary":"The key."},{"name":"value","summary":"The entry value."}],"returns":"The previous value if successful."},{"signature":"string SetString(string section, string entry, string value)","summary":"Adds or sets a document string in the 3dm file.","since":"6.0","parameters":[{"name":"section","summary":"The section."},{"name":"entry","summary":"The entry name."},{"name":"value","summary":"The entry value."}],"returns":"The previous value if successful."}]},{"namespace":"Rhino.FileIO","name":"File3dmTypeCodes","dataType":"class","summary":"Typecode format 4 bytes long  x xxxxxxxxxxxxxxx,x xxx xxxx xxxx x x xx | |               | |               | |  | |        |        |                 | |        |        |         |       +---  \\"stuff\\" bit |        |        |         | |        |        |         +-- specific codes |        |        | |        |        +-- RESERVED - DO NOT USE (should be 0) (will be used to control CRC on/off) |        | |        +-- category:_000 0000 0000 0001  Legacy geometry    TCODE_LEGACY_GEOMETRY |                     _000 0000 0000 0010  openNURBS object   TCODE_OPENNURBS_OBJECT |                     _000 0000 0000 0100  -- RESERVED - DO NOT USE (should be 0 in any typecode) -- |                     _000 0000 0000 1000  -- RESERVED - DO NOT USE (should be 0 in any typecode) -- |                     _000 0000 0001 0000  Geometry           TCODE_GEOMETRY |                     _000 0000 0010 0000  Annotation |                     _000 0000 0100 0000  Display Attributes TCODE_DISPLAY |                     _000 0000 1000 0000  Rendering          TCODE_RENDER |                     _000 0001 0000 0000 |                     _000 0010 0000 0000  Interface          TCODE_INTERFACE |                     _000 0100 0000 0000  -- RESERVED - DO NOT USE (should be 0 in any typecode) -- |                     _000 1000 0000 0000  Tolerances         TCODE_TOLERANCE |                     _001 0000 0000 0000  Tables             TCODE_TABLE |                     _010 0000 0000 0000  Table record       TCODE_TABLEREC |                     _100 0000 0000 0000  User information   TCODE_USER | +-- format: 0 - data size in header  - data block follows    TCODE_SHORT 1 - data in header - no data block follows"},{"namespace":"Rhino.FileIO","name":"File3dmViewTable","dataType":"class","summary":"Provides access to views in the 3dm file.","interfaces":["IList<ViewInfo>","Collections.IRhinoTable<DocObjects.ViewInfo>"],"properties":[{"signature":"int Count","summary":"Gets the amount of items in the table.","since":"6.0","property":["get"]}],"methods":[{"signature":"void Add(ViewInfo item)","summary":"Adds a","since":"6.0"},{"signature":"void Clear()","summary":"Removes all items from the table.","since":"6.0"},{"signature":"bool Contains(ViewInfo item)","summary":"Returns an indication of the presence of a view in the table.","since":"6.0","parameters":[{"name":"item","summary":"The view to check."}],"returns":"True if the item is in the table; False otherwise."},{"signature":"void CopyTo(ViewInfo[] array, int arrayIndex)","summary":"Copies the content of the table to an array.","since":"6.0"},{"signature":"bool Delete(int index)","summary":"Removes an item.","since":"6.0","parameters":[{"name":"index","summary":"The index of the item to remove."}],"returns":"True if the item was removed."},{"signature":"bool Delete(ViewInfo item)","summary":"Deletes an item.","since":"6.0"},{"signature":"ViewInfo FindName(string name)","summary":"Finds a ViewInfo given its name.","since":"6.0","parameters":[{"name":"name","summary":"The name of the ViewInfo to be searched."}],"returns":"An ViewInfo, or None on error."},{"signature":"IEnumerator<DocObjects.ViewInfo> GetEnumerator()","summary":"Returns an enumerator that yields all views in the table.","since":"6.0","returns":"An enumerator."},{"signature":"int IndexOf(ViewInfo item)","summary":"Returns the index of the current ViewInfo.","since":"6.0","parameters":[{"name":"item","summary":"The item to be searched."}],"returns":"The index of the ViewInfo."}]},{"namespace":"Rhino.FileIO","name":"File3dmWriteOptions","dataType":"class","summary":"Options used by File3dm.Write","constructors":[{"signature":"File3dmWriteOptions()","summary":"Initializes properties to defaults.","since":"5.9"}],"properties":[{"signature":"bool SaveAnalysisMeshes","summary":"Include analysis meshes in the file. Default is true","since":"5.9","property":["get","set"]},{"signature":"bool SaveRenderMeshes","summary":"Include Render meshes in the file. Default is true","since":"5.9","property":["get","set"]},{"signature":"bool SaveUserData","summary":"Include custom user data in the file. Default is true","since":"5.9","property":["get","set"]},{"signature":"int Version","summary":"File version. Default is major version number of this assembly version.  \\nMust be in range [2; current version].  \\nAlternatively, 0 is a placeholder for the last valid version.  \\nRhino can read its current version, plus earlier file versions except 1.  \\nUse latest version when possible.","since":"5.9","property":["get","set"]}],"methods":[{"signature":"void EnableAnalysisMeshes(ObjectType objectType, bool enable)","summary":"Activates saving of analysis meshes for specific types of objects. If you do not specify the state for an object type, its default is used. Currently SubD mesh saving is disabled by default, while Brep and Extrusion is enabled.","since":"6.0","parameters":[{"name":"objectType","summary":"The object type. Mostly mesh, brep, extrusion and SubD (or their flag combinations) make sense here.  \\nDO NOT specify a \'filter\' or sub-object type."},{"name":"enable","summary":"If false, disables saving for this object type."}]},{"signature":"void EnableRenderMeshes(ObjectType objectType, bool enable)","summary":"Activates saving of render meshes for specific types of objects. If you do not specify the state for an object type, its default is used. Specifically, currently SubD mesh saving is disabled by default, while Brep and Extrusion is on.","since":"6.0","parameters":[{"name":"objectType","summary":"The object type. Mostly brep, extrusion and SubD (or their flag combinations) make sense here.  \\nDO NOT specify a \'filter\' or sub-object type."},{"name":"enable","summary":"If false, disables saving for this object type."}]}]},{"namespace":"Rhino.FileIO","name":"FileFindPreference","dataType":"enum","summary":"Defines options for file search.","values":[{"signature":"None = 0","summary":"The choice is not defined."},{"signature":"FullPath = 1","summary":"File name exists in FullPath()."},{"signature":"RelativePath = 2","summary":"File name exists in base path + RelativePath()."},{"signature":"BasePath = 3","summary":"File name exists in base path directory."},{"signature":"ContentMatch = 4","summary":"File with mathing content exists."},{"signature":"MostRecent = 5","summary":"Most recently modifed file."}]},{"namespace":"Rhino.FileIO","name":"FileObj","dataType":"class","summary":"Support for obj file format","methods":[{"signature":"static bool Read(String filename, RhinoDoc doc, FileObjReadOptions options)","since":"6.0"},{"signature":"static WriteFileResult Write(StreamWriter stream, RhinoDoc doc, FileObjWriteOptions options)","summary":"Write an obj stream based on the contents of a RhinoDoc","since":"7.0"},{"signature":"static WriteFileResult Write(String filename, Mesh[] meshes, FileObjWriteOptions options)","summary":"Write an obj file with an array of meshes","since":"7.0","parameters":[{"name":"filename","summary":"path to write to"},{"name":"meshes","summary":"meshes to write as obj format"},{"name":"options","summary":""}]},{"signature":"static WriteFileResult Write(String filename, RhinoDoc doc, FileObjWriteOptions options)","summary":"Write an obj file based on the contents of a RhinoDoc","since":"6.0"}]},{"namespace":"Rhino.FileIO","name":"FileObjReadOptions","dataType":"class","summary":"Options used when reading an obj file.","constructors":[{"signature":"FileObjReadOptions(FileReadOptions readOptions)","since":"6.0"}],"properties":[{"signature":"bool DisplayColorFromObjMaterial","summary":"Determines whether textures are read from the .mtl file, if it exists.","since":"6.5","property":["get","set"]},{"signature":"bool IgnoreTextures","summary":"Determines whether textures are read from the .mtl file, if it exists.","since":"6.0","property":["get","set"]},{"signature":"bool MapYtoZ","summary":"Setting to transform OBJ\'s Y axis to Rhino\'s Z axis","since":"6.0","property":["get","set"]},{"signature":"bool MorphTargetOnly","summary":"TODO","since":"6.0","property":["get","set"]},{"signature":"bool ReverseGroupOrder","summary":"Determines how groups/layers are nested when reading an obj file. Left to Right (default = false) or Right to Left (true)","since":"6.0","property":["get","set"]},{"signature":"bool Split32BitTextures","since":"6.0","property":["get","set"]},{"signature":"UseObjGsAs UseObjGroupsAs","since":"6.0","property":["get","set"]},{"signature":"bool UseObjObjects","summary":"Determines whether or not \\"o\\"s in the obj file will be interpreted as objects in the Rhino model","since":"6.0","property":["get","set"]}],"methods":[{"signature":"Transform GetTransform()","summary":"Calculates the YToZ transform.","since":"6.0"}]},{"namespace":"Rhino.FileIO","name":"FileObjReadOptions.UseObjGsAs","dataType":"enum","summary":"Determines how \\"g\\"s in the obj file will be interpreted on import","since":"6.0","values":[{"signature":"IgnoreObjGroups = 0","summary":"OBJ \\"g\\"s in the file are ignored"},{"signature":"ObjGroupsAsLayers = 1","summary":"OBJ \\"g\\"s in the file will become Rhino layers"},{"signature":"ObjGroupsAsGroups = 2","summary":"OBJ \\"g\\"s in the file will become Rhino groups"},{"signature":"ObjGroupsAsObjects = 3","summary":"OBJ \\"g\\"s in the file will become Rhino objects"}]},{"namespace":"Rhino.FileIO","name":"FileObjWriteOptions","dataType":"class","constructors":[{"signature":"FileObjWriteOptions(FileWriteOptions writeOptions)","since":"6.0"}],"properties":[{"signature":"string ActualFilePathOnMac","since":"6.3","property":["get","set"]},{"signature":"bool CreateNgons","summary":"Setting to enable/disable the creation of ngons for the output","since":"6.0","property":["get","set"]},{"signature":"bool CullUnnecessaryVertexesInNgons","summary":"Setting to determine whether interior collinear vertexes are part of the ngon.","since":"6.0","property":["get","set"]},{"signature":"AsciiEol EolType","since":"6.0","property":["get","set"]},{"signature":"ObjGroupNames ExportGroupNameLayerNames","summary":"Setting to determine whether object, group or layer names will become \\"g\\"s in the OBJ output file","since":"6.0","property":["get","set"]},{"signature":"bool ExportMaterialDefinitions","summary":"Setting to write an .mtl file and \\"usemtl\\"s in the obj file","since":"6.0","property":["get","set"]},{"signature":"bool ExportNormals","summary":"Enable/disable export of vertex normals, if they exist.","since":"6.0","property":["get","set"]},{"signature":"ObjObjectNames ExportObjectNames","summary":"Setting to determine what object names in Rhino will become in the OBJ output file","since":"6.0","property":["get","set"]},{"signature":"bool ExportOpenMeshes","summary":"Enable/Disable bailing when an open mesh is encountered.","since":"6.0","property":["get","set"]},{"signature":"bool ExportTcs","summary":"Enable/disable export of texture coordinates, if they exist.","since":"6.0","property":["get","set"]},{"signature":"bool ExportVcs","summary":"Enable/disable export of vertex colors, if they exist.","since":"6.0","property":["get","set"]},{"signature":"bool IncludeUnweldedEdgesInNgons","summary":"Setting to determine whether unwelded edges are ignored in the creation of an ngon.","since":"6.0","property":["get","set"]},{"signature":"bool MapZtoY","summary":"Setting to transform Rhino\'s Z axis to OBJ\'s Y axis","since":"6.0","property":["get","set"]},{"signature":"bool MergeNestedGroupingNames","summary":"Setting to merge nested layer or group names into a single OBJ group name","since":"6.7","property":["get","set"]},{"signature":"MeshingParameters MeshParameters","summary":"Mesh parameters to use when meshing geometry that is not already a mesh.","since":"6.0","property":["get","set"]},{"signature":"VertexWelding MeshType","since":"6.0","property":["get","set"]},{"signature":"int MinNgonFaceCount","summary":"Minimum number of faces to consider creation of ngon","since":"6.0","property":["get","set"]},{"signature":"NGons NgonMode","since":"7.0","property":["get","set"]},{"signature":"GeometryType ObjectType","since":"6.0","property":["get","set"]},{"signature":"int SignificantDigits","summary":"Number of significant digits to write out for floating point numbers","since":"6.0","property":["get","set"]},{"signature":"bool SortObjGroups","summary":"Setting to enable/disable sorting of OBJ groups","since":"6.0","property":["get","set"]},{"signature":"SubDMeshing SubDMeshType","since":"7.0","property":["get","set"]},{"signature":"int SubDSurfaceMeshingDensity","summary":"Determines how coarse the mesh output will be when surface meshing subd objects  See comments for ON_SubDDisplayParameters in opennurbs_mesh.h for details regarding numbers used.","since":"7.0","property":["get","set"]},{"signature":"CurveType TrimCurveType","summary":"trimming curve option","since":"6.0","property":["get","set"]},{"signature":"bool UnderbarMaterialNames","summary":"Enable/disable replacing white space with under-bars in material names.","since":"6.0","property":["get","set"]},{"signature":"bool UseDisplayColorForMaterial","summary":"Setting to display color as material when material index for object is -1.","since":"7.0","property":["get","set"]},{"signature":"bool UseRelativeIndexing","summary":"Determines whether to use relative indexing.  TRUE = use relative (negative) indexing FALSE = use absolute (positive) indexing","since":"6.0","property":["get","set"]},{"signature":"bool UseRenderMeshes","summary":"Use existing or generate render meshes instead of calling RhinoObject.MeshObjects.","since":"7.0","property":["get","set"]},{"signature":"bool UseSimpleDialog","summary":"Determines whether to use the simple or detailed meshing dialog.","since":"6.0","property":["get","set"]},{"signature":"bool WrapLongLines","summary":"Setting to enable/disable line wrapping with \\"\\\\\\"s","since":"6.0","property":["get","set"]}],"methods":[{"signature":"Transform GetTransform()","summary":"Calculates the transform combination of ZToY and any the translation that might occur in a SavewithOrigin.","since":"6.0"}]},{"namespace":"Rhino.FileIO","name":"FileObjWriteOptions.AsciiEol","dataType":"enum","summary":"End of Line","since":"6.0","values":[{"signature":"Crlf = 0","summary":"MicroSoft"},{"signature":"Lf = 1","summary":"UNIX"},{"signature":"Cr = 2","summary":"Apple"}]},{"namespace":"Rhino.FileIO","name":"FileObjWriteOptions.CurveType","dataType":"enum","summary":"Type of curve used for trimmed surfaces","since":"6.0","values":[{"signature":"Polyline = 0","summary":"Polyline approximation, see comments for AngleTolRadians"},{"signature":"Nurbs = 1"}]},{"namespace":"Rhino.FileIO","name":"FileObjWriteOptions.GeometryType","dataType":"enum","summary":"(trimmed) NURBS surfaces may be exported as either NURBS or meshes","since":"6.0","values":[{"signature":"Nurbs = 0"},{"signature":"Mesh = 1"}]},{"namespace":"Rhino.FileIO","name":"FileObjWriteOptions.NGons","dataType":"enum","since":"7.0","values":[{"signature":"None = 0","summary":"Ngons will not be created, nor will they be exported if they already exist"},{"signature":"Preserve = 1","summary":"If ngons already exist, they will be used as is, no ngons will be created"},{"signature":"Create = 2","summary":"Ngons will be created, if possible, by calling Mesh.Ngons.AddPlanarNgons"}]},{"namespace":"Rhino.FileIO","name":"FileObjWriteOptions.ObjGroupNames","dataType":"enum","since":"6.0","values":[{"signature":"NoGroups = 0","summary":"Neither layer or group names are exported as OBJ groups"},{"signature":"LayerAsGroup = 1","summary":"Rhino layer names are exported as OBJ groups"},{"signature":"GroupAsGroup = 2","summary":"Rhino group names are exported as OBJ groups"}]},{"namespace":"Rhino.FileIO","name":"FileObjWriteOptions.ObjObjectNames","dataType":"enum","since":"6.0","values":[{"signature":"NoObjects = 0","summary":"Object names are not exported"},{"signature":"ObjectAsGroup = 1","summary":"Rhino Object names are exported as OBJ groups"},{"signature":"ObjectAsObject = 2","summary":"Rhino Object names are exported as OBJ objects"}]},{"namespace":"Rhino.FileIO","name":"FileObjWriteOptions.SubDMeshing","dataType":"enum","summary":"Determines whether the surface or control net of a SubD object is used to generate a mesh","since":"7.0","values":[{"signature":"Surface = 0","summary":"The SubD surface is used"},{"signature":"ControlNet = 1","summary":"The SubD control net is used"}]},{"namespace":"Rhino.FileIO","name":"FileObjWriteOptions.VertexWelding","dataType":"enum","summary":"Determines how/if vertexes of the mesh in Rhino will be modified in the output","remarks":"The actual values of any vertex, normal or texture coordinate are not modified, this setting determines whether they are duplicated or merged.","since":"6.0","values":[{"signature":"Normal = 0","summary":"Mesh is exported in existing state"},{"signature":"Welded = 1","summary":"Mesh topology vertex indexing is used for the v in the OBJ output file normals and texture coordinates, if they exist, come from the mesh"},{"signature":"Unwelded = 2","summary":"Each face gets it\'s own vertex, and normal and texture coordinates if they exist, in the output"}]},{"namespace":"Rhino.FileIO","name":"FileObjWriter.ObjGroupComparer","dataType":"class","interfaces":["IComparer<ObjRhinoObject>"]},{"namespace":"Rhino.FileIO","name":"FileObjWriter.ObjLayerComparer","dataType":"class","interfaces":["IComparer<ObjRhinoObject>"]},{"namespace":"Rhino.FileIO","name":"FileObjWriter.ObjRhinoObject","dataType":"class"},{"namespace":"Rhino.FileIO","name":"FileObjWriter.RhinoObjectMesh","dataType":"class"},{"namespace":"Rhino.FileIO","name":"FilePdf","dataType":"class","summary":"Support for PDF file format","properties":[{"signature":"bool LayersAsOptionalContentGroups","summary":"Add layers as \\"optional content groups\\" to the PDF. This is the visible layer tree available in PDF viewers","since":"7.0","property":["get","set"]}],"methods":[{"signature":"static FilePdf Create()","summary":"Create a new instance of a FilePdf class","since":"6.0"},{"signature":"int AddPage(int widthInDots, int heightInDots, int dotsPerInch)","summary":"Add a blank page to this document","since":"6.5","returns":"page number on success"},{"signature":"int AddPage(ViewCaptureSettings settings)","summary":"Add a new page to this document and draw a viewport into it based on provided ViewCaptureSettings","since":"6.0","returns":"page number on success"},{"signature":"void DrawBitmap(int pageNumber, Bitmap bitmap, float left, float top, float width, float height, float rotationInDegrees)","summary":"Draw a bitmap","since":"6.5"},{"signature":"void DrawLine(int pageNumber, PointF from, PointF to, Color strokeColor, float strokeWidth)","summary":"Draw a line","since":"6.5"},{"signature":"void DrawPolyline(int pageNumber, PointF[] polyline, Color fillColor, Color strokeColor, float strokeWidth)","summary":"Draw a polyline path","since":"6.5"},{"signature":"void DrawText(int pageNumber, string text, double x, double y, float heightPoints, Font onfont, Color fillColor, Color strokeColor, float strokeWidth, float angleDegrees, TextHorizontalAlignment horizontalAlignment, TextVerticalAlignment verticalAlignment)","summary":"Draw text on a page","since":"6.5"},{"signature":"object PdfDocumentImplementation()","summary":"Get actual implementation of PdfDocument class","since":"6.0"},{"signature":"void Write(Stream stream)","summary":"Write PDF to a stream","since":"6.0"},{"signature":"void Write(string filename)","summary":"Write PDF to a file","since":"6.0"}]},{"namespace":"Rhino.FileIO","name":"FilePdfEventArgs","dataType":"class","summary":"Used for events that are fired while constructing/saving a PDF","baseclass":"EventArgs","properties":[{"signature":"FilePdf Pdf","summary":"The document that is about to be written","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.FileIO","name":"FilePly","dataType":"class","summary":"Support for ply file format","methods":[{"signature":"static WriteFileResult Write(String filename, RhinoDoc doc, FilePlyWriteOptions options)","summary":"Write a ply file based on the contents of a RhinoDoc","since":"7.0"}]},{"namespace":"Rhino.FileIO","name":"FilePlyWriteOptions","dataType":"class","constructors":[{"signature":"FilePlyWriteOptions(FileWriteOptions writeOptions)","since":"7.0"}],"properties":[{"signature":"bool ExportASCII","summary":"Determines whether to export as Ascii.","since":"7.0","property":["get","set"]},{"signature":"bool ExportColors","summary":"Determines whether to export vertex colors.","since":"7.0","property":["get","set"]},{"signature":"bool ExportDoubles","summary":"Determines whether vertexes are exported as doubles or floats.","since":"7.0","property":["get","set"]},{"signature":"bool ExportMaterial","summary":"Determines whether to export a material.","since":"7.0","property":["get","set"]},{"signature":"bool ExportNormals","summary":"Determines whether to export vertex normals.","since":"7.0","property":["get","set"]},{"signature":"MeshingParameters MeshingParameters","since":"7.0","property":["get","set"]},{"signature":"bool UseSimpleDialog","summary":"Determines whether to use the simple or detailed meshing dialog.","since":"7.0","property":["get","set"]}]},{"namespace":"Rhino.FileIO","name":"FileReadOptions","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"FileReadOptions()","since":"5.0"}],"properties":[{"signature":"bool BatchMode","summary":"True means you cannot ask questions during reading. (no dialogs, no \\"getters\\", etc.)","since":"5.0","property":["get","set"]},{"signature":"bool ImportMode","summary":"True means we are merging whatever is being read into an existing document. This means you need to consider things like:  \\nIf the information being read is in a different unit system, it should be scaled if UseScaleGeometry is true.  \\nThere can be existing layers, fonts, materials, dimension styles, hatch patterns, and so on with the same name as items being read from the file.","since":"5.0","property":["get","set"]},{"signature":"bool ImportReferenceMode","summary":"True means we are reading information for a work session reference model or a linked instance definition.","since":"5.0","property":["get","set"]},{"signature":"bool InsertMode","summary":"True means we are reading information that will be used to create an instance definition or some other type of \\"inserting\\" that is supported by Rhino\'s \\"Insert\\" command.","since":"5.0","property":["get","set"]},{"signature":"bool NewMode","summary":"True means we are reading template information in something like a OnFileNew event.","since":"5.0","property":["get","set"]},{"signature":"bool OpenMode","summary":"True means we are reading the information into an empty document.  This means you need to consider things like: Setting the unit system (if the file has a unit system)Creating a default layer if one is not there.Setting up appropriate views when you\'re finished reading.","since":"5.0","property":["get","set"]},{"signature":"bool ScaleGeometry","summary":"true: If ImportMode is True and the geometry in the file being read has a unit system different from the model\'s unit system, then apply the unit conversion scale to the file\'s geometry before adding it to the model.  \\nfalse: Do not scale. Once case where this happens is when an instance definition is read from a file and the model space instance references have been scaled. In case the instance definition geometry cannot be scaled or the net result is that the size of the instance reference object is scaled by the square of the scale factor.","since":"5.0","property":["get","set"]},{"signature":"bool UseScaleGeometry","summary":"If this parameter is true, then no questions are asked when unit conversion scaling is optional and the setting specified by ScaleGeometry is used.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","since":"5.0"}]},{"namespace":"Rhino.FileIO","name":"FileReference","dataType":"class","summary":"Manages a reference to an existing or non-existing file, using either or both absolute or relative paths. Once constructed, this class is immutable.","interfaces":["IDisposable"],"constructors":[{"signature":"FileReference(string fullPath, string relativePath, ContentHash hash, FileReferenceStatus status)","summary":"Constructs a new instance of the FileReference class, given a fullPath, a relativePath a content hash and a status value.","since":"6.0"}],"properties":[{"signature":"ContentHash ContentHash","summary":"Gets the content hash.","since":"6.0","property":["get"]},{"signature":"string FullPath","summary":"Gets the absolute path of this file reference.","since":"6.0","property":["get"]},{"signature":"FileReferenceStatus FullPathStatus","summary":"Gets the file reference status.","since":"6.0","property":["get"]},{"signature":"bool IsSet","summary":"Returns an indication of the fact that the reference is actually set to a non-None value.","since":"6.0","property":["get"]},{"signature":"string RelativePath","summary":"Gets the relative path of this file reference.","since":"6.0","property":["get"]}],"methods":[{"signature":"static FileReference CreateFromFullAndRelativePaths(string fullPath, string relativePath)","summary":"Returns a new file reference. This returns a new instance even if the path does not exist.","since":"6.0","parameters":[{"name":"fullPath","summary":"A full path. This parameter cannot be null."},{"name":"relativePath","summary":"A relative path. This parameter can be null."}],"returns":"A file reference to the specified paths."},{"signature":"static FileReference CreateFromFullPath(string fullPath)","summary":"Returns a new file reference. This returns a new instance even if the path does not exist.","since":"6.0","parameters":[{"name":"fullPath","summary":"A full path."}],"returns":"A file reference to the specified path."},{"signature":"void Dispose()","summary":"Reclaims unmanaged resources used by this object.","since":"6.0"}]},{"namespace":"Rhino.FileIO","name":"FileReferenceStatus","dataType":"enum","summary":"Enumerates a list of file statuses.","values":[{"signature":"Unknown = 0","summary":"Status of a the full path is not known."},{"signature":"FullPathValid = 1","summary":"Full path is valid."},{"signature":"FileNotFound = 2","summary":"Unable to locate file."}]},{"namespace":"Rhino.FileIO","name":"FileSlc","dataType":"class","summary":"Support for writing slice (SLC) file format","methods":[{"signature":"static bool Write(string filename, RhinoDoc doc, FileSlcWriteOptions options)","summary":"Write a SLC file based on the contents of a RhinoDoc","since":"7.0","parameters":[{"name":"filename","summary":"path to write a file to"},{"name":"doc","summary":"document to get geometry from"},{"name":"options","summary":"options used for generating the SLC file"}],"returns":"True on success"}]},{"namespace":"Rhino.FileIO","name":"FileSlcWriteOptions","dataType":"class","summary":"Options used when writing a SLC file","properties":[{"signature":"double AngleBetweenSegmentsDegrees","summary":"The angle that determines how smooth the polylines of the slice curves will be. When the number is small you will get a smooth final output but it will take more time to export and a larger file.","since":"7.0","property":["get","set"]},{"signature":"Point3d EndPoint","summary":"End of the slicing normal","since":"7.0","property":["get","set"]},{"signature":"double SliceDistance","summary":"The distance between the slices or layers of curves that your final output will contain. The distance should be based on the slice thickness of your final output device","since":"7.0","property":["get","set"]},{"signature":"Point3d StartPoint","summary":"Start of the slicing normal","since":"7.0","property":["get","set"]},{"signature":"bool UseMeshes","summary":"Use meshes to generate slices. The curves for each slice are generated by intersecting the object mesh with a plane. the Angle between polyline segments data is not used when this value is true","since":"7.0","property":["get","set"]}]},{"namespace":"Rhino.FileIO","name":"FileStp","dataType":"class","summary":"Support for writing STEP (STP) file format","methods":[{"signature":"static bool Write(string filename, RhinoDoc doc, FileStpWriteOptions options)","summary":"Write a STP file based on the contents of a RhinoDoc","since":"7.0","parameters":[{"name":"filename","summary":"path to write a file to"},{"name":"doc","summary":"document to get geometry from"},{"name":"options","summary":"options used for generating the STP file"}],"returns":"True on success"}]},{"namespace":"Rhino.FileIO","name":"FileStpWriteOptions","dataType":"class","summary":"Options used when writing a STP file","properties":[{"signature":"bool Export2dCurves","summary":"Some (not most, and not Rhino) importing applications can make use of the 2-D trimming curves to get a more accurate and faster import. The size of the step file will be larger","since":"7.0","property":["get","set"]},{"signature":"bool ExportBlack","summary":"Let importing application set color for black objects. If a Rhino object has color black, no color is assigned to the object in the step file.This will cause the importing application to give the object its default color.This is desirable because black objects look like ink blots in some applications.This option is grayed out if the schema option is AP203ControConfigDesign since that schema does not include color entities.","since":"7.0","property":["get","set"]},{"signature":"bool SplitClosedSurfaces","summary":"Splits closed surfaces, for example, the interior surfaces of drilled holes.","since":"7.0","property":["get","set"]}]},{"namespace":"Rhino.FileIO","name":"FileType","dataType":"class","constructors":[{"signature":"FileType(string extension, string description)","since":"5.0"}],"properties":[{"signature":"string Description","since":"5.0","property":["get","set"]},{"signature":"string Extension","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.FileIO","name":"FileWriteOptions","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"FileWriteOptions()","since":"5.0"}],"properties":[{"signature":"string DestinationFileName","summary":"For use on Apple frameworks only. Retrns the final destination file name.","since":"6.3","property":["get"]},{"signature":"int FileVersion","since":"5.0","property":["get","set"]},{"signature":"bool IncludeBitmapTable","summary":"The file written should include the bitmap table if your File Writing Plug-in supports it.","since":"5.0","property":["get","set"]},{"signature":"bool IncludeHistory","summary":"The file written should include history information if your File Writing Plug-In supports it.","since":"5.0","property":["get","set"]},{"signature":"bool IncludePreviewImage","summary":"The file written should include a preview image if your File Writing Plug-in supports it.","since":"5.0","property":["get","set"]},{"signature":"bool IncludeRenderMeshes","summary":"The file written should include the render meshes if your File Writing Plug-in supports it.","since":"5.0","property":["get","set"]},{"signature":"bool SuppressAllInput","since":"7.0","property":["get","set"]},{"signature":"bool SuppressDialogBoxes","summary":"If true, it means the command has been run with a \'-\', meaning you should not ask questions during writing. (no dialogs, no \\"getters\\", etc.)","since":"5.0","property":["get","set"]},{"signature":"bool UpdateDocumentPath","summary":"If a complete, current version, 3dm file is successfully saved, then the name of the file will be used to update the document\'s default file path and title and document will be marked as not modified.","since":"6.7","property":["get","set"]},{"signature":"bool WriteAsTemplate","summary":"Write as template","since":"5.0","property":["get"]},{"signature":"bool WriteGeometryOnly","summary":"If true, the file written should include only geometry File Writing Plug-in supports it.","since":"5.0","property":["get","set"]},{"signature":"bool WriteSelectedObjectsOnly","summary":"If true, this command should export only the objects currently selected in the Rhino model.","since":"5.0","property":["get","set"]},{"signature":"bool WriteUserData","summary":"If true, the file written should include User Data if your File Writing Plug-in supports it.","since":"5.0","property":["get","set"]},{"signature":"Transform Xform","since":"5.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","since":"5.0"}]},{"namespace":"Rhino.FileIO","name":"ICommonComponentTable","dataType":"interface","summary":"Provides methods to use all File3dm and RhinoDoc tables under the same contract. Do not derive from this interface. This is to ensure all tables can be used with the same method list.","properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns the model component type the table handles.","property":["get"]}],"methods":[{"signature":"T FindId(Guid id)","summary":"Retrieves an object based on ID. You should prefer ID search over Index search.","parameters":[{"name":"id","summary":"The id to search for."}],"returns":"A model component, or None if none was found."},{"signature":"T FindNameHash(NameHash nameHash)","summary":"Retrieves an object based on Name.","parameters":[{"name":"nameHash","summary":"The name hash for which to search."}]}]},{"namespace":"Rhino.FileIO","name":"ImageFile","dataType":"class","summary":"Support functions for image files","methods":[{"signature":"static bool SupportsAlphaChannel(string filename)","summary":"Returns True if file at given path is an image file and that file format supports an alpha channel","since":"6.0"}]},{"namespace":"Rhino.FileIO","name":"ManifestTable","dataType":"class","summary":"Maintains an index to every model component that is in the 3dm file. This is the \\"more comprehensive\\" table that contains all objects in all other tables.","interfaces":["ICommonComponentTable<ModelComponent>"],"properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.Mixed.","since":"6.0","property":["get"]},{"signature":"int Count","summary":"Total number of items in the manifest, including deleted items.","since":"6.0","property":["get"]},{"signature":"long LongCount","summary":"Total number of items in the manifest, including deleted items.","since":"6.0","property":["get"]},{"signature":"object Parent","summary":"Returns the parent object. This is the RhinoDoc, or the File3md file.","since":"6.0","property":["get"]}],"methods":[{"signature":"static ModelComponentType GetModelComponentTypeFromGenericType()","summary":"Returns the result of the ComponentType property of a ModelComponent.","since":"6.0","returns":"A ModelComponentType."},{"signature":"int ActiveObjectCount(ModelComponentType type)","summary":"Total number of items in the manifest, including deleted items.","since":"6.0"},{"signature":"void Clear()","summary":"Marks all items as deleted.","since":"6.0"},{"signature":"bool Contains(ModelComponent item)","summary":"Determines if an items is contained in this table.","since":"6.0","parameters":[{"name":"item","summary":"An item, or null. Null is never contained."}],"returns":"True if the item is contained; otherwise, false."},{"signature":"void CopyTo(ModelComponent[] array, int arrayIndex)","summary":"Copies the content of this table to an array.","since":"6.0","parameters":[{"name":"array","summary":"The array to copy to."},{"name":"arrayIndex","summary":"The position in the array from which to start copying."}]},{"signature":"T FindId(Guid id)","summary":"Uses the guid to find a model component. Deleted objects cannot be found by id. The guid is the value that is stored in the .Id property. In a single document, no two active objects have the same guid. If an object is replaced with a new object, then the guid  persists. For example, if the _Move command moves an object, then the moved object inherits its guid from the starting object. If the Copy command copies an object, then the copy gets a new guid. This guid persists through file saving/opening operations. This function will not find grip objects.","since":"6.0","parameters":[{"name":"id","summary":"Index of model component to search for."}],"returns":"Reference to the rhino object or None if no such object could be found."},{"signature":"ModelComponent FindId(Guid id)","summary":"Uses the guid to find a model component. Deleted objects cannot be found by id. The guid is the value that is stored in the .Id property. In a single document, no two active objects have the same guid. If an object is replaced with a new object, then the guid  persists. For example, if the _Move command moves an object, then the moved object inherits its guid from the starting object. If the Copy command copies an object, then the copy gets a new guid. This guid persists through file saving/opening operations. This function will not find grip objects.","since":"6.0","parameters":[{"name":"id","summary":"ID of model component to search for."}],"returns":"Reference to the rhino object with the objectId or None if no such object could be found."},{"signature":"ModelComponent FindId(Guid id, ModelComponentType type)","summary":"Uses the guid to find a model component. Deleted objects cannot be found by id. The guid is the value that is stored in the .Id property. In a single document, no two active objects have the same guid. If an object is replaced with a new object, then the guid  persists. For example, if the _Move command moves an object, then the moved object inherits its guid from the starting object. If the Copy command copies an object, then the copy gets a new guid. This guid persists through file saving/opening operations. This function will not find grip objects.","since":"6.0","parameters":[{"name":"id","summary":"ID of model component to search for."},{"name":"type","summary":"The type to be searched. If this is ModelComponentType.Unset then all types are searched."}],"returns":"Reference to the rhino object with the objectId or None if no such object could be found."},{"signature":"T FindIndex(int index)","summary":"Uses the index to find a model component. The index is the value that is stored in the .Index property.","since":"6.0","parameters":[{"name":"index","summary":"Index of model component to search for."}],"returns":"Reference to the rhino object or None if no such object could be found."},{"signature":"ModelComponent FindIndex(int index, ModelComponentType type)","summary":"Uses the index to find a model component. The index is the value that is stored in the .Index property.","since":"6.0","parameters":[{"name":"index","summary":"Index of model component to search for."},{"name":"type","summary":"The type to be searched. Cannot be ModelComponentType.Unset."}],"returns":"Reference to the rhino object or None if no such object could be found."},{"signature":"T FindName(string name, Guid parent)","summary":"Uses the name to find a model component. The name is the value that is stored in the .Name property. Deleted objects have no name.","since":"6.0","parameters":[{"name":"name","summary":"Name of model component to search for."},{"name":"parent","summary":"Parent object id. This is only required for layers."}],"returns":"Reference to the rhino object or None if no such object could be found."},{"signature":"ModelComponent FindName(string name, ModelComponentType type, Guid parent)","summary":"Uses the name to find a model component. The name is the value that is stored in the .Name property. Deleted objects have no name.","since":"6.0","parameters":[{"name":"name","summary":"Name of model component to search for."},{"name":"type","summary":"The type to be searched. Cannot be ModelComponentType.Unset."},{"name":"parent","summary":"Parent object id. This is only required for layers."}],"returns":"Reference to the rhino object or None if no such object could be found."},{"signature":"T FindNameHash(NameHash nameHash)","summary":"Uses the hash of the name to find a model component. Deleted objects have no name.","since":"6.0","parameters":[{"name":"nameHash","summary":"Name hash of model component to search for."}]},{"signature":"ModelComponent FindNameHash(NameHash nameHash, ModelComponentType type)","summary":"Uses the hash of the name to find a model component. Deleted objects have no name.","since":"6.0","parameters":[{"name":"nameHash","summary":"NameHash of model component to search for."},{"name":"type","summary":"The type to be searched. Cannot be ModelComponentType.Unset."}],"returns":"Reference to the rhino object or None if no such object could be found."},{"signature":"IEnumerator<T> GetEnumerator()","summary":"Visits all model components in the document, including default ones.","since":"6.0","returns":"An enumerator."},{"signature":"IEnumerator<ModelComponent> GetEnumerator()","summary":"Visits all model components in the document, including default ones.","since":"6.0","returns":"An enumerator."},{"signature":"IEnumerator<ModelComponent> GetEnumerator(ModelComponentType type)","summary":"Returns an enumerators that yields all model components, including default ones, relating to a particular type.","since":"6.0","parameters":[{"name":"type","summary":"The model component type."}],"returns":"An enumerator."}]},{"namespace":"Rhino.FileIO","name":"NameHash","dataType":"class","summary":"Contains information that is useful to uniquely identify an object name. This object is immutable.","remarks":"This object is immutable.","interfaces":["ICloneable","IEquatable<NameHash>"],"constructors":[{"signature":"NameHash(string name)","summary":"Creates a new NameHash, representing a piece of text.","since":"6.0","parameters":[{"name":"name","summary":"A name. This can be None and can refer to a non-existing path."}]},{"signature":"NameHash(string name, Guid parentId)","summary":"Creates a new NameHash, representing a piece of text.","since":"6.0","parameters":[{"name":"name","summary":"A name. This can be None and can refer to a non-existing path."},{"name":"parentId","summary":"The id of the parent layer. This is only useful with layers."}]},{"signature":"NameHash(string name, Guid parentId, bool ignoreCase)","summary":"Creates a new NameHash, representing a piece of text.","since":"6.0","parameters":[{"name":"name","summary":"A name. This can be None and can refer to a non-existing path."},{"name":"parentId","summary":"The id of the parent layer. This is only useful with layers."},{"name":"ignoreCase","summary":"All manifest searches currently ignore case, except for groups."}]},{"signature":"NameHash(string name, Guid parentId, ModelComponentType type)","summary":"Creates a new NameHash, representing a piece of text.","since":"6.0","parameters":[{"name":"name","summary":"A name. This can be None and can refer to a non-existing path."},{"name":"parentId","summary":"The id of the parent layer. This is only useful with layers."},{"name":"type","summary":"Calls DocObjects.ModelComponent.ModelComponentTypeIgnoresCaseto determine if case should be used in search."}]}],"properties":[{"signature":"uint MappedCodePoints","summary":"Gets the NameHash flags. In some cases = number of mapped code points.","since":"6.0","property":["get"]},{"signature":"Guid ParentId","summary":"Only useful if this participates in a tree structure, as with layers.","since":"6.0","property":["get"]},{"signature":"byte[] Sha1Hash","summary":"Gets the 20-bytes long SHA-1 hash of ordinal minimum mapped Unicode (UTF-32) code points.","since":"6.0","property":["get"]}],"methods":[{"signature":"static NameHash CreateFilePathHash(string path)","summary":"Creates a new NameHash, representing the name of a file.","since":"6.0","parameters":[{"name":"path","summary":"A path. This can be None and can refer to a non-existing path."}]},{"signature":"NameHash Clone()","summary":"Creates a copy of this name hash. Because content hash is immutable, this can be used as a deep copy.","since":"6.0","returns":"A different instance of the same name hash."},{"signature":"bool Equals(NameHash other)","summary":"Determines if another name hash has the same value.","since":"6.0","parameters":[{"name":"other","summary":"The other name hash to compare."}],"returns":"True if the two hashes are equal."},{"signature":"bool Equals(object obj)","summary":"Determines if another object is a name hash with same value.","parameters":[{"name":"obj","summary":"The other content hash to compare."}],"returns":"True if the two hashes are equal."},{"signature":"int GetHashCode()","summary":"Gets an hash code for this name hash. Two equal content hashes have equal hash code. The other way around might not be true.","returns":"An hash code value."}]},{"namespace":"Rhino.FileIO","name":"SerializationOptions","dataType":"class","summary":"Contains options for serializing -or storing- data, such as Rhino version and user data.","constructors":[{"signature":"SerializationOptions()","summary":"Initializes a new instance of the SerializationOptionsclass.","since":"5.0"}],"properties":[{"signature":"int RhinoVersion","summary":"Gets or sets a value indicating the Rhino version.","since":"5.0","property":["get","set"]},{"signature":"bool WriteUserData","summary":"Gets or sets a value indicating whether to write user data.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.FileIO","name":"SHA1OpenNURBS","dataType":"class","summary":"Provides the OpenNURBS implementation of SHA1.  \\nThis class is provided only with the purpose of hashing. It is not meant to be used for any cryptographic purpose.","baseclass":"SHA1","constructors":[{"signature":"SHA1OpenNURBS()","summary":"Constructs a new instance of the SHA1 algorithm.","since":"6.0"}],"methods":[{"signature":"static byte[] FileSystemPathHash(string path, bool? ignoreCase)","summary":"Computes the SHA1 hash of a file system path, converted to UTF8.  \\nThese file system paths have identical values of FileSystemPathHash():  \\n/x/y/z/name.ext  \\n\\\\x\\\\y\\\\z\\\\name.ext  \\n/x//y//z/name.ext  \\n/x/y/a/b/c/../../../z/name.ext  \\n/X/Y/Z/NAME.EXT (When ignoreCase is true)","parameters":[{"name":"path","summary":"A non-None path string."},{"name":"ignoreCase","summary":"If case should be ignored. If this is None or unspecified, the operating system default is used."}],"returns":"A 20-byte long SHA1 hash."},{"signature":"static byte[] StringHash(string input)","summary":"Computes the SHA1 hash of a string, converted to UTF8.","since":"6.0","returns":"A 20-byte long SHA1 hash."},{"signature":"void Initialize()","summary":"Resets this instance of the algorithm, so that it can be used again. It is not required to call this method after creation.","since":"6.0"}]},{"namespace":"Rhino.FileIO","name":"TextLog","dataType":"class","summary":"Used for collecting text data","interfaces":["IDisposable"],"constructors":[{"signature":"TextLog()","summary":"Creates a text log that stores all text in memory.  Use ToString on this version of the TextLog to get the text that we written","since":"5.1"},{"signature":"TextLog(IntPtr ptr)","since":"6.0"},{"signature":"TextLog(string filename)","summary":"Creates a text log that writes all text to a file. If no filename is provided, then text is written to StdOut","since":"5.1","parameters":[{"name":"filename","summary":"Name of file to create and write to. If null, then text output is sent to StdOut"}]}],"properties":[{"signature":"int IndentSize","summary":"0: one tab per indent. >0: number of spaces per indent","since":"5.1","property":["get","set"]}],"methods":[{"signature":"static TextLog NewCommandLine()","summary":"Returns a reference to a TextLog that prints to the Rhino command line. Each new command line reference holds its own indents.","since":"7.0"},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.1"},{"signature":"void PopIndent()","summary":"Decrease the indentation level","since":"5.1"},{"signature":"void Print(string text)","summary":"Send text to the text log","since":"5.1"},{"signature":"void Print(string format, object arg0)","summary":"Send formatted text to the text log","since":"5.1"},{"signature":"void Print(string format, object arg0, object arg1)","summary":"Send formatted text to the text log","since":"5.1"},{"signature":"void PrintWrappedText(string text, int lineLength)","summary":"Send text wrapped at a set line length","since":"5.1"},{"signature":"void PushIndent()","summary":"Increase the indentation level","since":"5.1"},{"signature":"string ToString()","summary":"If the TextLog was constructed using the empty constructor, then the text information is stored in a runtime string.  The contents of this string is retrieved using ToString for this case"}]},{"namespace":"Rhino.Geometry","name":"AngularDimension","dataType":"class","summary":"Represents a dimension of an entity that can be measured with an angle.","baseclass":"Rhino.Geometry.Dimension","constructors":[{"signature":"AngularDimension()","since":"6.0"},{"signature":"AngularDimension(Arc arc, double offset)","summary":"Create an angular dimension from a given arc","since":"5.0","parameters":[{"name":"arc","summary":"The start and end points of the arc are the start and endpoints of the dimension"},{"name":"offset","summary":"How far to offset the dimension location from the arc"}]}],"properties":[{"signature":"AngleDisplayFormat AngleFormat","since":"6.0","property":["get","set"]},{"signature":"int AngleResolution","since":"6.0","property":["get","set"]},{"signature":"double AngleRoundoff","since":"6.0","property":["get","set"]},{"signature":"ZeroSuppression AngleZeroSuppression","since":"6.0","property":["get","set"]},{"signature":"Point2d ArrowPoint1","since":"6.0","property":["get"]},{"signature":"Point2d ArrowPoint2","since":"6.0","property":["get"]},{"signature":"Point2d CenterPoint","since":"6.0","property":["get","set"]},{"signature":"Point2d DefPoint1","since":"6.0","property":["get","set"]},{"signature":"Point2d DefPoint2","since":"6.0","property":["get","set"]},{"signature":"Point2d DimlinePoint","since":"6.0","property":["get","set"]}],"methods":[{"signature":"static AngularDimension Create(DimensionStyle dimStyle, Plane plane, Vector3d horizontal, Point3d centerpoint, Point3d defpoint1, Point3d defpoint2, Point3d dimlinepoint)","summary":"Initialize Dimension parameters","since":"6.0","parameters":[{"name":"dimStyle","summary":"Dimension\'s DimensionStyle"},{"name":"plane","summary":"Dimension\'s Plane"},{"name":"horizontal","summary":"Horizontal reference direction"},{"name":"centerpoint","summary":"Dimension center point"},{"name":"defpoint1","summary":"First definition point"},{"name":"defpoint2","summary":"Second definition point"},{"name":"dimlinepoint","summary":"Point on dimension line"}]},{"signature":"static AngularDimension Create(Guid styleId, Plane plane, Point3d extpoint1, Point3d extpoint2, Point3d dirpoint1, Point3d dirpoint2, Point3d dimlinepoint)","summary":"Initialize Dimension parameters","since":"6.0","parameters":[{"name":"styleId","summary":"Dimension\'s AnnotationStyle"},{"name":"plane","summary":"Dimension\'s plane"},{"name":"extpoint1","summary":"First dimension point"},{"name":"extpoint2","summary":"Second definition point"},{"name":"dirpoint1","summary":"First direction point"},{"name":"dirpoint2","summary":"Second direction point"},{"name":"dimlinepoint","summary":"Point on dimension line"}]},{"signature":"bool AdjustFromPoints(Plane plane, Point3d centerpoint, Point3d defpoint1, Point3d defpoint2, Point3d dimlinepoint)","summary":"Update Dimension geometry from point locations","since":"6.0","parameters":[{"name":"plane","summary":"Dimension\'s plane"},{"name":"centerpoint","summary":"Dimension\'s center point"},{"name":"defpoint1","summary":"First definition point"},{"name":"defpoint2","summary":"Second definition point"},{"name":"dimlinepoint","summary":"Point on dimension line"}]},{"signature":"bool AdjustFromPoints(Plane plane, Point3d extpoint1, Point3d extpoint2, Point3d dirpoint1, Point3d dirpoint2, Point3d dimlinepoint)","summary":"Update Dimension geometry from point locations","since":"6.0","parameters":[{"name":"plane","summary":"Dimension\'s plane"},{"name":"extpoint1","summary":"First dimension point"},{"name":"extpoint2","summary":"Second definition point"},{"name":"dirpoint1","summary":"First direction point"},{"name":"dirpoint2","summary":"Second direction point"},{"name":"dimlinepoint","summary":"Point on dimension line"}]},{"signature":"bool Get3dPoints(out Point3d centerpoint, out Point3d defpoint1, out Point3d defpoint2, out Point3d arrowpoint1, out Point3d arrowpoint2, out Point3d dimlinepoint, out Point3d textpoint)","summary":"Get locations of dimension\'s 3d points","since":"6.0","parameters":[{"name":"centerpoint","summary":"Dimension\'s center point"},{"name":"defpoint1","summary":"First definition point"},{"name":"defpoint2","summary":"Second definition point"},{"name":"arrowpoint1","summary":"First arrow point"},{"name":"arrowpoint2","summary":"Second arrow point"},{"name":"dimlinepoint","summary":"Point on dimension line"},{"name":"textpoint","summary":"Text location point"}]},{"signature":"string GetAngleDisplayText(DimensionStyle style)","since":"6.0"},{"signature":"bool GetDisplayLines(DimensionStyle style, double scale, out Line[] lines, out Arc[] arcs)","since":"6.0"},{"signature":"bool GetTextRectangle(out Point3d[] corners)","since":"6.0"}]},{"namespace":"Rhino.Geometry","name":"AnnotationBase","dataType":"class","summary":"Provides a common base class to all annotation geometry.  \\nThis class refers to the geometric element that is independent from the document.","baseclass":"Rhino.Geometry.GeometryBase","properties":[{"signature":"LengthDisplay AlternateDimensionLengthDisplay","summary":"Alternate length display units and format","since":"6.0","property":["get","set"]},{"signature":"AnnotationType AnnotationType","summary":"Type of annotation","since":"6.0","property":["get"]},{"signature":"char DecimalSeparator","summary":"Set or get the decimal separator c","since":"7.0","property":["get","set"]},{"signature":"LengthDisplay DimensionLengthDisplay","summary":"Length display units and format","since":"6.0","property":["get","set"]},{"signature":"double DimensionScale","summary":"Gets or sets the dimension scale","since":"6.0","property":["get","set"]},{"signature":"DimensionStyle DimensionStyle","summary":"If there are no overrides then the parent style is returned otherwise the dimension style saved with the annotation is returned.","since":"6.0","property":["get"]},{"signature":"Guid DimensionStyleId","summary":"Id of this annotation\'s parent dimstyle If this annotation has overrides to dimstyle properties, those overrides will be represented in the DimensionStyle returned by DimensionStyle(ParentStyle)","since":"6.0","property":["get","set"]},{"signature":"bool DrawForward","summary":"Gets or sets whether the text is oriented towards the reader when viewed from behind","since":"6.0","property":["get","set"]},{"signature":"bool DrawTextFrame","summary":"Gets or sets whether to draw a frame around a text mask","since":"7.0","property":["get","set"]},{"signature":"Font FirstCharFont","summary":"Returns the font used by the first run of text in an annotation","since":"6.5","property":["get"]},{"signature":"Font Font","summary":"The base Font for the text of the annotation.  The text string is rich text and therefore a different font that the base font can be associated with sub strings of the text","since":"6.0","property":["get","set"]},{"signature":"int FontIndex","summary":"Obsolete; use Font property instead","since":"6.1","property":["get","set"]},{"signature":"double FormatWidth","summary":"Text format width (Wrapping rectangle)","since":"6.0","property":["get","set"]},{"signature":"bool HasPropertyOverrides","since":"6.0","property":["get"]},{"signature":"Color MaskColor","summary":"Color to use for drawing a text mask when it is enabled. If the mask is enabled and MaskColor is System.Drawing.Color.Transparent, then the viewport\'s color will be used for the MaskColor","since":"6.0","property":["get","set"]},{"signature":"MaskType MaskColorSource","summary":"Gets or sets whether the mask background color is from the background or from a color","since":"6.0","property":["get","set"]},{"signature":"bool MaskEnabled","summary":"Determines whether or not to draw a Text Mask","since":"6.0","property":["get","set"]},{"signature":"MaskFrame MaskFrame","summary":"Gets or sets whether to draw a frame around a text mask","since":"7.0","property":["get","set"]},{"signature":"double MaskOffset","summary":"Offset for the border around text of the rectangle used to draw the mask.  This value multiplied by TextHeight is the offset on each side of the tight rectangle around the text characters to the mask rectangle. The default value is 0.1.","since":"6.0","property":["get","set"]},{"signature":"bool MaskUsesViewportColor","summary":"If true, the viewport\'s color is used for the mask color. If false, the color defined by MaskColor is used","since":"6.0","property":["get","set"]},{"signature":"DimensionStyle ParentDimensionStyle","summary":"The parent dimension style associated with this annotation","since":"6.0","property":["get","set"]},{"signature":"string PlainText","summary":"Text stripped of RTF formatting information","since":"6.0","property":["get","set"]},{"signature":"string PlainTextWithFields","summary":"Text stripped of RTF formatting information and with field expressions intact","since":"6.19","property":["get"]},{"signature":"Plane Plane","summary":"Plane that this annotation lies on","since":"5.0","property":["get","set"]},{"signature":"string RichText","summary":"Text including additional RTF formatting information","since":"6.0","property":["get","set"]},{"signature":"string Text","summary":"Text including additional RTF formatting information","since":"5.0","property":["get","set"]},{"signature":"string TextFormula","summary":"See RichText","since":"5.0","property":["get","set"]},{"signature":"bool TextHasRtfFormatting","since":"6.0","property":["get"]},{"signature":"double TextHeight","summary":"AnnotationBase.TextHeight Gets the parent dimstyle for the annotation and gets or sets the text height in the dimstyle","since":"5.0","property":["get","set"]},{"signature":"bool TextIsWrapped","summary":"Is text wrapping on","since":"6.0","property":["get","set"]},{"signature":"double TextModelWidth","summary":"Width of text in the model","since":"6.0","property":["get"]},{"signature":"double TextRotationDegrees","summary":"Rotation of text in degrees","since":"6.0","property":["get","set"]},{"signature":"double TextRotationRadians","summary":"Rotation of text in radians","since":"6.0","property":["get","set"]}],"methods":[{"signature":"static bool FirstCharProperties(string rtf_str, ref bool bold, ref bool italic, ref bool underline, ref string facename)","since":"6.0"},{"signature":"static string FormatRtfString(string rtf_in, bool clear_bold, bool set_bold, bool clear_italic, bool set_italic, bool clear_underline, bool set_underline, bool clear_facename, bool set_facename, string facename)","since":"6.0"},{"signature":"static double GetDimensionScale(RhinoDoc doc, DimensionStyle dimstyle, RhinoViewport vport)","summary":"Get view dependent dimension scale","since":"6.0"},{"signature":"static string PlainTextToRtf(string str)","since":"6.0"},{"signature":"bool ClearPropertyOverrides()","summary":"Clears all overridden properties for this annotation","since":"6.0"},{"signature":"BoundingBox GetBoundingBox(Transform xform)","summary":"Aligned bounding box solver. Gets the world axis aligned bounding box for the transformed geometry.","since":"6.10","parameters":[{"name":"xform","summary":"Transformation to apply to bounding box after calculation. The geometry is not modified."}],"returns":"The bounding box of the transformed geometry in world coordinates or BoundingBox.Empty if not bounding box could be found."},{"signature":"DimensionStyle GetDimensionStyle(DimensionStyle parentDimStyle)","summary":"Return the proper dimension style from which to get properties for this annotation object If this object has style overrides, those will be included in the returned dimension style and the style will be updated to include the current state of the parent style for non-overridden fields","since":"6.0"},{"signature":"string GetPlainTextWithRunMap(ref int[] map)","summary":"Return plain text string for this annotation with field expressions unevaluated.","since":"7.0","parameters":[{"name":"map","summary":"an array of int values in groups of 3: run index, character start position, and length."}],"returns":"A plain text string."},{"signature":"bool IsAllBold()","summary":"Returns True if all of the text in the annotation is Bold, otherwise returns false","since":"6.22"},{"signature":"bool IsAllItalic()","summary":"Returns True if all of the text in the annotation is Italic, otherwise returns false","since":"6.22"},{"signature":"bool IsAllUnderlined()","summary":"Returns True if all of the text in the annotation is Underlined, otherwise returns false","since":"6.22"},{"signature":"bool IsPropertyOverridden(Field field)","summary":"Returns True if a property is overridden","since":"6.0"},{"signature":"bool RunReplace(string replaceString, int startRunIndex, int startRunPosition, int endRunIndex, int endRunPosition)","summary":"Replace text within a formatted string","since":"7.0"},{"signature":"bool SetBold(bool set_on)","since":"6.0"},{"signature":"bool SetFacename(bool set_on, string facename)","since":"6.0"},{"signature":"bool SetItalic(bool set_on)","since":"6.0"},{"signature":"bool SetOverrideDimStyle(DimensionStyle OverrideStyle)","summary":"Set a style including overrides for this annotation object. The DimensionStyle OverrideStyle must have the override fields marked as overridden and must have it\'s Id set to nil. Use DimensinoStyle.SetFieldOverride(Field field) and related functions to manage override settings. To override a field, the field value must be set and the field must be marked as an override. The DimensionStyle passed in here must not be in the dimstyle table","since":"6.0"},{"signature":"void SetRichText(string rtfText, DimensionStyle dimstyle)","since":"6.0"},{"signature":"bool SetUnderline(bool set_on)","since":"6.0"},{"signature":"void WrapText()","summary":"Wrap text","since":"6.0"}]},{"namespace":"Rhino.Geometry","name":"AnnotationType","dataType":"enum","summary":"ON::AnnotationType identifies the type of an annotation object derived from ON_Annotation.","values":[{"signature":"Unset = 0","summary":"Not a valid annotation type."},{"signature":"Aligned = 1","summary":"Linear distance between two points with dimension line parallel to the dimensioned points."},{"signature":"Angular = 2","summary":"Angle bewteen two lines."},{"signature":"Diameter = 3","summary":"Arc or circle diameter dimension."},{"signature":"Radius = 4","summary":"Arc or circle radius dimension."},{"signature":"Rotated = 5","summary":"Linear distance between two points with dimension line horizontal, vertical or rotated by a specified amount."},{"signature":"Ordinate = 6","summary":"Ordinate dimension. Typically used to document an offset distance between the center of a circle and a reference point."},{"signature":"ArcLen = 7","summary":"Arc length of a curve."},{"signature":"CenterMark = 8","summary":"Center mark dimension. Typically used to document the center of an arc or circle."},{"signature":"Text = 9","summary":"Text. Stand alone text with a wide variety of uses."},{"signature":"Leader = 10","summary":"Leader. Text and a curve with an arrow head."},{"signature":"Angular3pt = 11","summary":"Angular3pt. Angle defined by 3 points."}]},{"namespace":"Rhino.Geometry","name":"Arc","dataType":"struct","summary":"Represents the value of a plane, two angles and a radius in a sub-curve of a three-dimensional circle.  \\nThe curve is parameterized by an angle expressed in radians. For an IsValid arc the total subtended angle AngleRadians() = Domain()(1) - Domain()(0) must satisfy 0 < AngleRadians() < 2*Pi  \\nThe parameterization of the Arc is inherited from the Circle it is derived from. In particular  \\nt -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis  \\nwhere xaxis and yaxis, (part of Circle.Plane) form an orthonormal frame of the plane containing the circle.","constructors":[{"signature":"Arc(Circle circle, double angleRadians)","summary":"Initializes a new instance of an arc from a base circle and an angle.","since":"5.0","parameters":[{"name":"circle","summary":"Circle to base arc upon."},{"name":"angleRadians","summary":"Sweep angle of arc (in radians)"}]},{"signature":"Arc(Circle circle, Interval angleIntervalRadians)","summary":"Initializes a new instance of an arc from a base circle and an interval of angles.","since":"5.0","parameters":[{"name":"circle","summary":"Circle to base arc upon."},{"name":"angleIntervalRadians","summary":"Increasing angle interval in radians with angleIntervalRadians.Length() <= 2.0*Math.PI."}]},{"signature":"Arc(Plane plane, double radius, double angleRadians)","summary":"Initializes a new arc from a base plane, a radius value and an angle.","since":"5.0","parameters":[{"name":"plane","summary":"The plane of the arc (arc center will be located at plane origin)"},{"name":"radius","summary":"Radius of arc."},{"name":"angleRadians","summary":"Sweep angle of arc (in radians)"}]},{"signature":"Arc(Plane plane, Point3d center, double radius, double angleRadians)","summary":"Initializes a new aligned arc at the given center point, with a custom radius and angle.","since":"5.0","parameters":[{"name":"plane","summary":"Alignment plane for arc. The arc will be parallel to this plane."},{"name":"center","summary":"Center point for arc."},{"name":"radius","summary":"Radius of arc."},{"name":"angleRadians","summary":"Sweep angle of arc (in radians)"}]},{"signature":"Arc(Point3d center, double radius, double angleRadians)","summary":"Initializes a new horizontal arc at the given center point, with a custom radius and angle.","since":"5.0","parameters":[{"name":"center","summary":"Center point of arc."},{"name":"radius","summary":"Radius of arc."},{"name":"angleRadians","summary":"Sweep angle of arc (in radians)"}]},{"signature":"Arc(Point3d startPoint, Point3d pointOnInterior, Point3d endPoint)","summary":"Initializes a new arc through three points. If the points are coincident or co-linear, this will result in an Invalid arc.","since":"5.0","parameters":[{"name":"startPoint","summary":"Start point of arc."},{"name":"pointOnInterior","summary":"Point on arc interior."},{"name":"endPoint","summary":"End point of arc."}]},{"signature":"Arc(Point3d pointA, Vector3d tangentA, Point3d pointB)","summary":"Initializes a new arc from end points and a tangent vector. If the tangent is parallel with the endpoints this will result in an Invalid arc.","since":"5.0","parameters":[{"name":"pointA","summary":"Start point of arc."},{"name":"tangentA","summary":"Tangent at start of arc."},{"name":"pointB","summary":"End point of arc."}]}],"properties":[{"signature":"static Arc Unset","summary":"Gets an Arc with Unset components.","since":"5.0","property":["get"]},{"signature":"double Angle","summary":"Gets or sets the sweep -or subtended- angle (in Radians) for this arc segment.","since":"5.0","property":["get","set"]},{"signature":"double AngleDegrees","summary":"Gets or sets the sweep -or subtended- angle (in Radians) for this arc segment.","since":"5.0","property":["get","set"]},{"signature":"Interval AngleDomain","summary":"Gets or sets the angle domain (in Radians) of this arc.","since":"5.0","property":["get","set"]},{"signature":"Point3d Center","summary":"Gets or sets the center point for this arc.","since":"5.0","property":["get","set"]},{"signature":"double Circumference","summary":"Gets the circumference of the circle that is coincident with this arc.","since":"5.0","property":["get"]},{"signature":"double Diameter","summary":"Gets or sets the Diameter of this arc.","since":"5.0","property":["get","set"]},{"signature":"double EndAngle","summary":"Gets or sets the end angle (in Radians) for this arc segment.","since":"5.0","property":["get","set"]},{"signature":"double EndAngleDegrees","summary":"Gets or sets the end angle (in Radians) for this arc segment.","since":"5.0","property":["get","set"]},{"signature":"Point3d EndPoint","summary":"Gets the end point of the arc.","since":"5.0","property":["get"]},{"signature":"bool IsCircle","summary":"Gets a value indicating whether or not this arc is a complete circle.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Gets a value indicating whether or not this arc is valid. Detail: Radius>0 and 0<AngleRadians()<=2*Math.Pi.","since":"5.0","property":["get"]},{"signature":"double Length","summary":"Gets the length of the arc. (Length = Radius * (subtended angle in radians)).","since":"5.0","property":["get"]},{"signature":"Point3d MidPoint","summary":"Gets the mid-point of the arc.","since":"5.0","property":["get"]},{"signature":"Plane Plane","summary":"Gets or sets the plane in which this arc lies.","since":"5.0","property":["get","set"]},{"signature":"double Radius","summary":"Gets or sets the radius of this arc.","since":"5.0","property":["get","set"]},{"signature":"double StartAngle","summary":"Gets or sets the start angle (in Radians) for this arc segment.","since":"5.0","property":["get","set"]},{"signature":"double StartAngleDegrees","summary":"Gets or sets the start angle (in Radians) for this arc segment.","since":"5.0","property":["get","set"]},{"signature":"Point3d StartPoint","summary":"Gets the start point of the arc.","since":"5.0","property":["get"]}],"methods":[{"signature":"BoundingBox BoundingBox()","summary":"Computes the 3D axis aligned bounding box for this arc.","since":"5.0","returns":"Bounding box of arc."},{"signature":"double ClosestParameter(Point3d testPoint)","summary":"Gets parameter on the arc closest to a test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to get close to."}],"returns":"Parameter (in radians) of the point on the arc that is closest to the test point. If testPoint is the center of the arc, then the starting point of the arc is (arc.Domain()[0]) returned. If no parameter could be found, RhinoMath.UnsetValue is returned."},{"signature":"Point3d ClosestPoint(Point3d testPoint)","summary":"Computes the point on an arc that is closest to a test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to get close to."}],"returns":"The point on the arc that is closest to testPoint. If testPoint is the center of the arc, then the starting point of the arc is returned. UnsetPoint on failure."},{"signature":"bool EpsilonEquals(Arc other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(Arc other)","summary":"Determines whether another arc has the same value as this arc.","since":"5.0","parameters":[{"name":"other","summary":"An arc."}],"returns":"True if obj is equal to this arc; otherwise false."},{"signature":"bool Equals(object obj)","summary":"Determines whether another object is an arc and has the same value as this arc.","parameters":[{"name":"obj","summary":"An object."}],"returns":"True if obj is an arc and is exactly equal to this arc; otherwise false."},{"signature":"int GetHashCode()","summary":"Computes a hash code for the present arc.","returns":"A non-unique integer that represents this arc."},{"signature":"Point3d PointAt(double t)","summary":"Gets the point at the given arc parameter.","since":"5.0","parameters":[{"name":"t","summary":"Arc parameter to evaluate."}],"returns":"The point at the given parameter."},{"signature":"void Reverse()","summary":"Reverses the orientation of the arc. Changes the domain from [a,b] to [-b,-a].","since":"5.0"},{"signature":"Vector3d TangentAt(double t)","summary":"Gets the tangent at the given parameter.","since":"5.0","parameters":[{"name":"t","summary":"Parameter of tangent to evaluate."}],"returns":"The tangent at the arc at the given parameter."},{"signature":"NurbsCurve ToNurbsCurve()","summary":"Initializes a nurbs curve representation of this arc. This amounts to the same as calling NurbsCurve.CreateFromArc().","since":"5.0","returns":"A nurbs curve representation of this arc or None if no such representation could be made."},{"signature":"NurbsCurve ToNurbsCurve(int degree, int cvCount)","summary":"Create a uniform non-rational cubic NURBS approximation of an arc.","since":"6.0","parameters":[{"name":"degree","summary":">=1"},{"name":"cvCount","summary":"cv count >=5"}],"returns":"NURBS curve approximation of an arc on success"},{"signature":"bool Transform(Transform xform)","summary":"Transforms the arc using a Transformation matrix.","since":"5.0","parameters":[{"name":"xform","summary":"Transformations to apply. Note that arcs cannot handle non-euclidean transformations."}],"returns":"True on success, False on failure."},{"signature":"bool Trim(Interval domain)","summary":"Sets arc\'s angle domain (in radians) as a sub-domain of the circle.","since":"5.0","parameters":[{"name":"domain","summary":"0 < domain[1] - domain[0] <= 2.0 * RhinoMath.Pi."}],"returns":"True on success, False on failure."}]},{"namespace":"Rhino.Geometry","name":"ArcCurve","dataType":"class","summary":"Represent arcs and circles.  \\nArcCurve.IsCircle returns True if the curve is a complete circle.","remarks":"Details:  \\nan ArcCurve is a sub-curve of a circle, with a constant speed parameterization. The parameterization is an affine linear reparameterization of the underlying arc m_arc onto the domain m_t.  \\nA valid ArcCurve has Radius()>0 and  0<AngleRadians()<=2*PI and a strictly increasing Domain.","baseclass":"Rhino.Geometry.Curve","constructors":[{"signature":"ArcCurve()","summary":"Initializes a new ArcCurveinstance.  \\nRadius is set to 1, position to Origin and Domain to full span (circle).","since":"5.0"},{"signature":"ArcCurve(Arc arc)","summary":"Initializes a new ArcCurveinstance, copying values from another Arc.","since":"5.0","parameters":[{"name":"arc","summary":"Another Arc."}]},{"signature":"ArcCurve(Arc arc, double t0, double t1)","summary":"Initializes a new ArcCurveinstance, copying values from another Arcand specifying the needed parametrization of the arc.  \\nArc will not be cut again at these parameterizations.","since":"5.0","parameters":[{"name":"arc","summary":"An original arc."},{"name":"t0","summary":"A new Domain.T0 value."},{"name":"t1","summary":"A new Domain.T1 value."}]},{"signature":"ArcCurve(ArcCurve other)","summary":"Initializes a new ArcCurveinstance, copying values from another ArcCurve.","since":"5.0","parameters":[{"name":"other","summary":"Another ArcCurve."}]},{"signature":"ArcCurve(Circle circle)","summary":"Initializes a new ArcCurveinstance, copying the shape of a Circle.  \\nParameterization will be [0;circle.Circumference]","since":"5.0","parameters":[{"name":"circle","summary":"The original circle."}]},{"signature":"ArcCurve(Circle circle, double t0, double t1)","summary":"Initializes a new ArcCurveinstance, copying values from a Circleand specifying the needed parametrization of the arc.  \\nCircle will not be newly cut at these parameterizations.","since":"5.0","parameters":[{"name":"circle","summary":"A circle."},{"name":"t0","summary":"A new Domain.T0 value."},{"name":"t1","summary":"A new Domain.T1 value."}]}],"properties":[{"signature":"double AngleDegrees","summary":"Gets the angles of this arc in degrees.","since":"5.0","property":["get"]},{"signature":"double AngleRadians","summary":"Gets the angles of this arc in radians.","since":"5.0","property":["get"]},{"signature":"Arc Arc","summary":"Gets the arc that is contained within this ArcCurve.","since":"5.0","property":["get"]},{"signature":"bool IsCompleteCircle","summary":"Gets a value indicating whether or not this curve can be represented by a complete circle.","since":"5.0","property":["get"]},{"signature":"double Radius","summary":"Gets the radius of this ArcCurve.","since":"5.0","property":["get"]}]},{"namespace":"Rhino.Geometry","name":"AreaMassProperties","dataType":"class","summary":"Contains static initialization methods and allows access to the computed metrics of area, area centroid and area moments in closed planar curves, in meshes, in surfaces, in hatches and in boundary representations.","interfaces":["IDisposable"],"properties":[{"signature":"double Area","summary":"Gets the area solution.","since":"5.0","property":["get"]},{"signature":"double AreaError","summary":"Gets the uncertainty in the area calculation.","since":"5.0","property":["get"]},{"signature":"Point3d Centroid","summary":"Gets the area centroid in the world coordinate system.","since":"5.0","property":["get"]},{"signature":"Vector3d CentroidCoordinatesMomentsOfInertia","summary":"Moments of inertia with respect to centroid coordinate system. X = integral of ((y-y0)^2 + (z-z0)^2) dm Y = integral of ((z-z0)^2 + (x-x0)^2) dm Z = integral of ((z-z0)^2 + (y-y0)^2) dm where (x0,y0,z0) = centroid.","since":"5.0","property":["get"]},{"signature":"Vector3d CentroidCoordinatesMomentsOfInertiaError","summary":"Uncertainty in centroid coordinates moments of inertia calculation.","since":"5.0","property":["get"]},{"signature":"Vector3d CentroidCoordinatesProductMoments","summary":"Product moments with respect to centroid coordinate system.","since":"6.26","property":["get"]},{"signature":"Vector3d CentroidCoordinatesProductMomentsError","summary":"Uncertainty in product moments with respect to centroid coordinate system.","since":"6.26","property":["get"]},{"signature":"Vector3d CentroidCoordinatesRadiiOfGyration","summary":"Radii of gyration with respect to centroid coordinate system. X = sqrt(integral of ((y-y0)^2 + (z-z0)^2) dm/M) Y = sqrt(integral of ((z-z0)^2 + (x-x0)^2) dm/M) Z = sqrt(integral of ((z-z0)^2 + (y-y0)^2) dm/M) where (x0,y0,z0) = centroid.","since":"5.0","property":["get"]},{"signature":"Vector3d CentroidCoordinatesSecondMoments","summary":"Second moments with respect to centroid coordinate system. X = integral of (x-x0)^2 dm Y = integral of (y-y0)^2 dm Z = integral of (z-z0)^2 dm where (x0,y0,z0) = centroid.","since":"5.0","property":["get"]},{"signature":"Vector3d CentroidCoordinatesSecondMomentsError","summary":"Uncertainty in centroid coordinates second moments calculation.","since":"5.0","property":["get"]},{"signature":"Vector3d CentroidError","summary":"Gets the uncertainty in the centroid calculation.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesFirstMoments","summary":"Returns the world coordinate first moments if they were able to be calculated. X is integral of \\"x dm\\" over the area Y is integral of \\"y dm\\" over the area Z is integral of \\"z dm\\" over the area.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesFirstMomentsError","summary":"Uncertainty in world coordinates first moments calculation.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesMomentsOfInertia","summary":"The moments of inertia about the world coordinate axes. X = integral of (y^2 + z^2) dm Y = integral of (z^2 + x^2) dm Z = integral of (z^2 + y^2) dm.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesMomentsOfInertiaError","summary":"Uncertainty in world coordinates moments of inertia calculation.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesProductMoments","summary":"Returns the world coordinate product moments if they were able to be calculated. X is integral of \\"xy dm\\" over the area Y is integral of \\"yz dm\\" over the area Z is integral of \\"zx dm\\" over the area.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesProductMomentsError","summary":"Uncertainty in world coordinates second moments calculation.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesRadiiOfGyration","summary":"Radii of gyration with respect to world coordinate system. X = sqrt(integral of (y^2 + z^2) dm/M) Y = sqrt(integral of (z^2 + x^2) dm/M) Z = sqrt(integral of (z^2 + y^2) dm/M)","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesSecondMoments","summary":"Returns the world coordinate first moments if they were able to be calculated. X is integral of \\"xx dm\\" over the area Y is integral of \\"yy dm\\" over the area Z is integral of \\"zz dm\\" over the area.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesSecondMomentsError","summary":"Uncertainty in world coordinates second moments calculation.","since":"5.0","property":["get"]}],"methods":[{"signature":"static AreaMassProperties Compute(Brep brep)","summary":"Computes an AreaMassProperties for a brep.","since":"5.0","parameters":[{"name":"brep","summary":"Brep to measure."}],"returns":"The AreaMassProperties for the given Brep or None on failure."},{"signature":"static AreaMassProperties Compute(Brep brep, bool area, bool firstMoments, bool secondMoments, bool productMoments)","summary":"Compute the AreaMassProperties for a single Brep.","since":"6.3","parameters":[{"name":"brep","summary":"Brep to measure."},{"name":"area","summary":"True to calculate area."},{"name":"firstMoments","summary":"True to calculate area first moments, area, and area centroid."},{"name":"secondMoments","summary":"True to calculate area second moments."},{"name":"productMoments","summary":"True to calculate area product moments."}],"returns":"The AreaMassProperties for the given Brep or None on failure."},{"signature":"static AreaMassProperties Compute(Curve closedPlanarCurve)","summary":"Computes an AreaMassProperties for a closed planar curve.","since":"5.0","parameters":[{"name":"closedPlanarCurve","summary":"Curve to measure."}],"returns":"The AreaMassProperties for the given curve or None on failure."},{"signature":"static AreaMassProperties Compute(Curve closedPlanarCurve, double planarTolerance)","summary":"Computes an AreaMassProperties for a closed planar curve.","since":"5.0","parameters":[{"name":"closedPlanarCurve","summary":"Curve to measure."},{"name":"planarTolerance","summary":"absolute tolerance used to insure the closed curve is planar"}],"returns":"The AreaMassProperties for the given curve or None on failure."},{"signature":"static AreaMassProperties Compute(Hatch hatch)","summary":"Computes an AreaMassProperties for a hatch.","since":"5.0","parameters":[{"name":"hatch","summary":"Hatch to measure."}],"returns":"The AreaMassProperties for the given hatch or None on failure."},{"signature":"static AreaMassProperties Compute(IEnumerable<GeometryBase> geometry)","summary":"Computes the Area properties for a collection of geometric objects. At present only Breps, Surfaces, Meshes and Planar Closed Curves are supported.","since":"5.1","parameters":[{"name":"geometry","summary":"Objects to include in the area computation."}],"returns":"The Area properties for the entire collection or None on failure."},{"signature":"static AreaMassProperties Compute(IEnumerable<GeometryBase> geometry, bool area, bool firstMoments, bool secondMoments, bool productMoments)","summary":"Computes the AreaMassProperties for a collection of geometric objects. At present only Breps, Surfaces, Meshes and Planar Closed Curves are supported.","since":"6.3","parameters":[{"name":"geometry","summary":"Objects to include in the area computation."},{"name":"area","summary":"True to calculate area."},{"name":"firstMoments","summary":"True to calculate area first moments, area, and area centroid."},{"name":"secondMoments","summary":"True to calculate area second moments."},{"name":"productMoments","summary":"True to calculate area product moments."}],"returns":"The AreaMassProperties for the entire collection or None on failure."},{"signature":"static AreaMassProperties Compute(Mesh mesh)","summary":"Computes an AreaMassProperties for a mesh.","since":"5.0","parameters":[{"name":"mesh","summary":"Mesh to measure."}],"returns":"The AreaMassProperties for the given Mesh or None on failure."},{"signature":"static AreaMassProperties Compute(Mesh mesh, bool area, bool firstMoments, bool secondMoments, bool productMoments)","summary":"Compute the AreaMassProperties for a single Mesh.","since":"6.3","parameters":[{"name":"mesh","summary":"Mesh to measure."},{"name":"area","summary":"True to calculate area."},{"name":"firstMoments","summary":"True to calculate area first moments, area, and area centroid."},{"name":"secondMoments","summary":"True to calculate area second moments."},{"name":"productMoments","summary":"True to calculate area product moments."}],"returns":"The AreaMassProperties for the given Mesh or None on failure."},{"signature":"static AreaMassProperties Compute(Surface surface)","summary":"Computes an AreaMassProperties for a surface.","since":"5.0","parameters":[{"name":"surface","summary":"Surface to measure."}],"returns":"The AreaMassProperties for the given Surface or None on failure."},{"signature":"static AreaMassProperties Compute(Surface surface, bool area, bool firstMoments, bool secondMoments, bool productMoments)","summary":"Compute the AreaMassProperties for a single Surface.","since":"6.3","parameters":[{"name":"surface","summary":"Surface to measure."},{"name":"area","summary":"True to calculate area."},{"name":"firstMoments","summary":"True to calculate area first moments, area, and area centroid."},{"name":"secondMoments","summary":"True to calculate area second moments."},{"name":"productMoments","summary":"True to calculate area product moments."}],"returns":"The AreaMassProperties for the given Surface or None on failure."},{"signature":"bool CentroidCoordinatesPrincipalMoments(out double x, out Vector3d xaxis, out double y, out Vector3d yaxis, out double z, out Vector3d zaxis)","summary":"Calculates the principal moments and principal axes with respect to centroid coordinates. These are simply the eigenvalues and eigenvectors of the centroid coordinate inertia matrix.","since":"6.9","parameters":[{"name":"x","summary":"Principal moment."},{"name":"xaxis","summary":"Principal axis for x."},{"name":"y","summary":"Principal moment."},{"name":"yaxis","summary":"Principal axis for y."},{"name":"z","summary":"Principal moment."},{"name":"zaxis","summary":"Principal axis for z."}],"returns":"True if successful."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"bool WorldCoordinatesPrincipalMoments(out double x, out Vector3d xaxis, out double y, out Vector3d yaxis, out double z, out Vector3d zaxis)","summary":"Calculates the principal moments and principal axes with respect to world coordinates. These are simply the eigenvalues and eigenvectors of the world coordinate inertia matrix.","since":"6.9","parameters":[{"name":"x","summary":"Principal moment."},{"name":"xaxis","summary":"Principal axis for x."},{"name":"y","summary":"Principal moment."},{"name":"yaxis","summary":"Principal axis for y."},{"name":"z","summary":"Principal moment."},{"name":"zaxis","summary":"Principal axis for z."}],"returns":"True if successful."}]},{"namespace":"Rhino.Geometry","name":"Arrowhead","dataType":"class","summary":"Arrowhead used by annotation","constructors":[{"signature":"Arrowhead()","summary":"Constructor","since":"6.0"},{"signature":"Arrowhead(ArrowType arrowType, Guid blockId)","summary":"Constructor","since":"6.0","parameters":[{"name":"arrowType","summary":"type of this arrowhead"},{"name":"blockId","summary":"Guid of the block used for user defined display"}]}],"properties":[{"signature":"ArrowType ArrowType","summary":"Type of arrowhead used by annotation","since":"6.0","property":["get"]},{"signature":"Guid BlockId","summary":"Id of block used for user-defined arrowhead","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Geometry","name":"BezierCurve","dataType":"class","summary":"Represents a Bezier curve.  \\nNote: as an exception, the bezier curve is not derived from .","interfaces":["IDisposable","ISerializable"],"constructors":[{"signature":"BezierCurve(IEnumerable<Point2d> controlPoints)","summary":"Create bezier curve with controls defined by a list of 2d points","since":"5.0"},{"signature":"BezierCurve(IEnumerable<Point3d> controlPoints)","summary":"Create bezier curve with controls defined by a list of 3d points","since":"5.0"},{"signature":"BezierCurve(IEnumerable<Point4d> controlPoints)","summary":"Create bezier curve with controls defined by a list of 4d points","since":"5.0"}],"properties":[{"signature":"int ControlVertexCount","summary":"Number of control vertices in this curve","since":"5.0","property":["get"]},{"signature":"int Dimension","summary":"Dimension of Bezier","since":"6.3","property":["get"]},{"signature":"bool IsRational","summary":"Gets a value indicating whether or not the curve is rational. Rational curves have control-points with custom weights.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Tests an object to see if it is valid.","since":"5.0","property":["get"]}],"methods":[{"signature":"static BezierCurve[] CreateBeziers(Curve sourceCurve)","summary":"Create an array of Bezier curves that fit to an existing curve. Please note, these Beziers can be of any order and may be rational.","since":"6.0","parameters":[{"name":"sourceCurve","summary":"The curve to fit Beziers to"}],"returns":"A new array of Bezier curves"},{"signature":"static BezierCurve[] CreateCubicBeziers(Curve sourceCurve, double distanceTolerance, double kinkTolerance)","summary":"Constructs an array of cubic, non-rational Beziers that fit a curve to a tolerance.","since":"5.0","parameters":[{"name":"sourceCurve","summary":"A curve to approximate."},{"name":"distanceTolerance","summary":"The max fitting error. Use RhinoMath.SqrtEpsilon as a minimum."},{"name":"kinkTolerance","summary":"If the input curve has a g1-discontinuity with angle radian measure greater than kinkTolerance at some point P, the list of beziers will also have a kink at P."}],"returns":"A new array of bezier curves. The array can be empty and might contain None items."},{"signature":"static BezierCurve CreateLoftedBezier(IEnumerable<Point2d> points)","summary":"Loft a bezier through a list of points","since":"5.0","parameters":[{"name":"points","summary":"2 or more points to interpolate"}],"returns":"new bezier curve if successful"},{"signature":"static BezierCurve CreateLoftedBezier(IEnumerable<Point3d> points)","summary":"Loft a bezier through a list of points","since":"5.0","parameters":[{"name":"points","summary":"2 or more points to interpolate"}],"returns":"new bezier curve if successful"},{"signature":"bool ChangeDimension(int desiredDimension)","summary":"Change dimension of bezier.","since":"5.0","returns":"True if successful.  False if desired_dimension < 1"},{"signature":"Vector3d CurvatureAt(double t)","summary":"Evaluate the curvature vector at a curve parameter.","since":"5.0","parameters":[{"name":"t","summary":"Evaluation parameter."}],"returns":"Curvature vector of the curve at the parameter t."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"BoundingBox GetBoundingBox(bool accurate)","summary":"Bounding box solver. Gets the world axis aligned bounding box for the curve.","since":"5.0","parameters":[{"name":"accurate","summary":"If true, a physically accurate bounding box will be computed. If not, a bounding box estimate will be computed. For some geometry types there is no difference between the estimate and the accurate bounding box. Estimated bounding boxes can be computed much (much) faster than accurate (or \\"tight\\") bounding boxes. Estimated bounding boxes are always similar to or larger than accurate bounding boxes."}],"returns":"The bounding box of the geometry in world coordinates or BoundingBox.Empty if not bounding box could be found."},{"signature":"Point2d GetControlVertex2d(int index)","summary":"Get location of a control vertex.","since":"5.0","parameters":[{"name":"index","summary":"Control vertex index (0 <= index < ControlVertexCount)"}],"returns":"If the bezier is rational, the euclidean location is returned."},{"signature":"Point3d GetControlVertex3d(int index)","summary":"Get location of a control vertex.","since":"5.0","parameters":[{"name":"index","summary":"Control vertex index (0 <= index < ControlVertexCount)"}],"returns":"If the bezier is rational, the euclidean location is returned."},{"signature":"Point4d GetControlVertex4d(int index)","summary":"Get location of a control vertex.","since":"5.0","parameters":[{"name":"index","summary":"Control vertex index (0 <= index < ControlVertexCount)"}],"returns":"Homogeneous value of control vertex. If the bezier is not rational, the weight is 1."},{"signature":"void GetObjectData(SerializationInfo info, StreamingContext context)","summary":"Populates a System.Runtime.Serialization.SerializationInfo with the data needed to serialize the target object.","since":"6.3","parameters":[{"name":"info","summary":"The System.Runtime.Serialization.SerializationInfo to populate with data."},{"name":"context","summary":"The destination (see System.Runtime.Serialization.StreamingContext) for this serialization."}]},{"signature":"bool IncreaseDegree(int desiredDegree)","summary":"Increase degree of bezier","since":"5.0","returns":"True if successful.  False if desiredDegree < current degree."},{"signature":"bool MakeNonRational()","summary":"Make bezier non-rational","since":"5.0","returns":"True if successful"},{"signature":"bool MakeRational()","summary":"Make bezier rational","since":"5.0","returns":"True if successful"},{"signature":"Point3d PointAt(double t)","summary":"Evaluates point at a curve parameter.","since":"5.0","parameters":[{"name":"t","summary":"Evaluation parameter."}],"returns":"Point (location of curve at the parameter t)."},{"signature":"bool Split(double t, out BezierCurve left, out BezierCurve right)","summary":"Divides the Bezier curve at the specified parameter.","since":"6.0","parameters":[{"name":"t","summary":"parameter must satisfy 0 < t < 1"},{"name":"left","summary":""},{"name":"right","summary":""}],"returns":"True on success"},{"signature":"Vector3d TangentAt(double t)","summary":"Evaluates the unit tangent vector at a curve parameter.","since":"5.0","parameters":[{"name":"t","summary":"Evaluation parameter."}],"returns":"Unit tangent vector of the curve at the parameter t."},{"signature":"NurbsCurve ToNurbsCurve()","summary":"Constructs a NURBS curve representation of this curve.","since":"5.0","returns":"NURBS representation of the curve on success, None on failure."}]},{"namespace":"Rhino.Geometry","name":"BlendContinuity","dataType":"enum","summary":"Used in curve and surface blending functions","since":"5.0","values":[{"signature":"Position = 0"},{"signature":"Tangency = 1"},{"signature":"Curvature = 2"}]},{"namespace":"Rhino.Geometry","name":"BlendType","dataType":"enum","summary":"Blend types used for creating filleted Brep edges","since":"6.0","values":[{"signature":"Chamfer = 0","summary":"Creates a ruled surface between brep edges with varying chamfer distances."},{"signature":"Fillet = 1","summary":"Creates a tangent surface between brep edges with varying radius values."},{"signature":"Blend = 2","summary":"Creates a curvature-continuous blend surface between brep edges with varying radius values."}]},{"namespace":"Rhino.Geometry","name":"BoundingBox","dataType":"struct","summary":"Represents the value of two points in a bounding box defined by the two extreme corner points.  \\nThis box is therefore aligned to the world X, Y and Z axes.","constructors":[{"signature":"BoundingBox(double minX, double minY, double minZ, double maxX, double maxY, double maxZ)","summary":"Constructs a bounding box from numeric extremes.","since":"5.0","parameters":[{"name":"minX","summary":"Lower extreme for box X size."},{"name":"minY","summary":"Lower extreme for box Y size."},{"name":"minZ","summary":"Lower extreme for box Z size."},{"name":"maxX","summary":"Upper extreme for box X size."},{"name":"maxY","summary":"Upper extreme for box Y size."},{"name":"maxZ","summary":"Upper extreme for box Z size."}]},{"signature":"BoundingBox(IEnumerable<Point3d> points)","summary":"Constructs a bounding box from a collection of points.","since":"5.0","parameters":[{"name":"points","summary":"Points to include in the bounding box."}]},{"signature":"BoundingBox(IEnumerable<Point3d> points, Transform xform)","summary":"Constructs a bounding box from a collection of points.","since":"6.0","parameters":[{"name":"points","summary":"Points to include in the bounding box."},{"name":"xform","summary":"Transformation."}]},{"signature":"BoundingBox(Point3d min, Point3d max)","summary":"Constructs a new bounding box from two corner points.","since":"5.0","parameters":[{"name":"min","summary":"Point containing all the minimum coordinates."},{"name":"max","summary":"Point containing all the maximum coordinates."}]}],"properties":[{"signature":"static BoundingBox Empty","summary":"Gets an [Empty] bounding box. An Empty box is an invalid structure that has negative width.","since":"5.0","property":["get"]},{"signature":"static BoundingBox Unset","summary":"Gets a bounding box that has Unset coordinates for Min and Max.","since":"5.0","property":["get"]},{"signature":"double Area","summary":"Gets the area of this BoundingBox.","since":"6.0","property":["get"]},{"signature":"Point3d Center","summary":"Gets the point in the center of the bounding box.","since":"5.0","property":["get"]},{"signature":"Vector3d Diagonal","summary":"Gets the diagonal vector of this BoundingBox. The diagonal connects the Min and Max points.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Gets a value that indicates whether or not this bounding box is valid. Empty boxes are not valid, and neither are boxes with unset points.","since":"5.0","property":["get"]},{"signature":"Point3d Max","summary":"Gets or sets the point in the maximal corner.","since":"5.0","property":["get","set"]},{"signature":"Point3d Min","summary":"Gets or sets the point in the minimal corner.","since":"5.0","property":["get","set"]},{"signature":"double Volume","summary":"Gets the volume of this BoundingBox.","since":"6.0","property":["get"]}],"methods":[{"signature":"static BoundingBox Intersection(BoundingBox a, BoundingBox b)","summary":"Computes the intersection of two bounding boxes.","since":"5.0","parameters":[{"name":"a","summary":"A first bounding box."},{"name":"b","summary":"A second bounding box."}],"returns":"The intersection bounding box."},{"signature":"static BoundingBox Union(BoundingBox a, BoundingBox b)","summary":"Returns a new BoundingBox that represents the union of boxes a and b.","since":"5.0","parameters":[{"name":"a","summary":"First box to include in union."},{"name":"b","summary":"Second box to include in union."}],"returns":"The BoundingBox that contains both a and b."},{"signature":"static BoundingBox Union(BoundingBox box, Point3d point)","summary":"Returns a new BoundingBox that represents the union of a bounding box and a point.","since":"5.0","parameters":[{"name":"box","summary":"Box to include in the union."},{"name":"point","summary":"Point to include in the union."}],"returns":"The BoundingBox that contains both the box and the point."},{"signature":"Point3d ClosestPoint(Point3d point)","summary":"Finds the closest point on or in the bounding box.","since":"5.0","parameters":[{"name":"point","summary":"Sample point."}],"returns":"The point on or in the box that is closest to the sample point."},{"signature":"Point3d ClosestPoint(Point3d point, bool includeInterior)","summary":"Finds the closest point on or in the bounding box.","since":"5.0","parameters":[{"name":"point","summary":"Sample point."},{"name":"includeInterior","summary":"If false, the point is projected onto the boundary faces only, otherwise the interior of the box is also taken into consideration."}],"returns":"The point on or in the box that is closest to the sample point."},{"signature":"bool Contains(BoundingBox box)","summary":"Determines whether this bounding box contains another bounding box.  \\nThis is the same as calling Contains(box,false).","since":"5.0","parameters":[{"name":"box","summary":"Box to test."}],"returns":"True if the box is on the inside of this bounding box, or is coincident with the surface of it."},{"signature":"bool Contains(BoundingBox box, bool strict)","summary":"Determines whether this bounding box contains another bounding box.  \\nThe user can choose how to treat bounding boxes with coincident surfaces.","since":"5.0","parameters":[{"name":"box","summary":"Box to test."},{"name":"strict","summary":"If true, the box needs to be fully on the inside of the bounding box. I.e. coincident boxes will be considered \'outside\'."}],"returns":"True if the box is (strictly) on the inside of this BoundingBox."},{"signature":"bool Contains(Point3d point)","summary":"Tests a point for bounding box inclusion. This is the same as calling Contains(point, false)","since":"5.0","parameters":[{"name":"point","summary":"Point to test."}],"returns":"True if the point is on the inside of or coincident with this bounding box; otherwise false."},{"signature":"bool Contains(Point3d point, bool strict)","summary":"Tests a point for BoundingBox inclusion.","since":"5.0","parameters":[{"name":"point","summary":"Point to test."},{"name":"strict","summary":"If true, the point needs to be fully on the inside of the BoundingBox. I.e. coincident points will be considered \'outside\'."}],"returns":"If \'strict\' is affirmative, True if the point is inside this bounding box; False if it is on the surface or outside.  \\nIf \'strict\' is negative, True if the point is on the surface or on the inside of the bounding box; otherwise false."},{"signature":"Point3d Corner(bool minX, bool minY, bool minZ)","summary":"Gets one of the eight corners of the box.","since":"5.0","parameters":[{"name":"minX","summary":"True for the minimum on the X axis; False for the maximum."},{"name":"minY","summary":"True for the minimum on the Y axis; False for the maximum."},{"name":"minZ","summary":"True for the minimum on the Z axis; False for the maximum."}],"returns":"The requested point."},{"signature":"Point3d FurthestPoint(Point3d point)","summary":"Finds the furthest point on the Box.","since":"5.0","parameters":[{"name":"point","summary":"Sample point."}],"returns":"The point on the box that is furthest from the sample point."},{"signature":"Point3d[] GetCorners()","summary":"Gets an array filled with the 8 corner points of this box.  \\nSee remarks for the return order.","since":"5.0","returns":"An array of 8 corners."},{"signature":"Line[] GetEdges()","summary":"Gets an array of the 12 edges of this box.","since":"5.0","returns":"If the bounding box IsValid, the 12 edges; otherwise, null."},{"signature":"void Inflate(double amount)","summary":"Inflates the box with equal amounts in all directions. Inflating with negative amounts may result in decreasing boxes.  \\nInvalid boxes can not be inflated.","since":"5.0","parameters":[{"name":"amount","summary":"Amount (in model units) to inflate this box in all directions."}]},{"signature":"void Inflate(double xAmount, double yAmount, double zAmount)","summary":"Inflate the box with custom amounts in all directions. Inflating with negative amounts may result in decreasing boxes.  \\nInValid boxes can not be inflated.","since":"5.0","parameters":[{"name":"xAmount","summary":"Amount (in model units) to inflate this box in the x direction."},{"name":"yAmount","summary":"Amount (in model units) to inflate this box in the y direction."},{"name":"zAmount","summary":"Amount (in model units) to inflate this box in the z direction."}]},{"signature":"int IsDegenerate(double tolerance)","summary":"Determines whether a bounding box is degenerate (flat) in one or more directions.","since":"5.0","parameters":[{"name":"tolerance","summary":"Distances <= tolerance will be considered to be zero.  If tolerance is negative (default), then a scale invariant tolerance is used."}],"returns":"0 = box is not degenerate 1 = box is a rectangle (degenerate in one direction). 2 = box is a line (degenerate in two directions). 3 = box is a point (degenerate in three directions) 4 = box is not valid."},{"signature":"bool MakeValid()","summary":"Ensures that the box is defined in an increasing fashion along X, Y and Z axes. If the Min or Max points are unset, this function will not change the box.","since":"5.0","returns":"True if the box was made valid, False if the box could not be made valid."},{"signature":"Point3d PointAt(double tx, double ty, double tz)","summary":"Evaluates the bounding box with normalized parameters.  \\nThe box has idealized side length of 1x1x1.","since":"5.0","parameters":[{"name":"tx","summary":"Normalized (between 0 and 1 is inside the box) parameter along the X direction."},{"name":"ty","summary":"Normalized (between 0 and 1 is inside the box) parameter along the Y direction."},{"name":"tz","summary":"Normalized (between 0 and 1 is inside the box) parameter along the Z direction."}],"returns":"The point at the {tx, ty, tz} parameters."},{"signature":"Brep ToBrep()","summary":"Constructs a Breprepresentation of this bounding box.","since":"5.0","returns":"If this operation is successful, a Brep representation of this box; otherwise null."},{"signature":"string ToString()","summary":"Constructs the string representation of this aligned bounding box.","returns":"Text."},{"signature":"bool Transform(Transform xform)","summary":"Updates this bounding box to be the smallest axis aligned bounding box that contains the transformed result of its 8 original corner points.","since":"5.0","parameters":[{"name":"xform","summary":"A transform."}],"returns":"True if this operation is successful; otherwise false."},{"signature":"void Union(BoundingBox other)","summary":"Updates this BoundingBox to represent the union of itself and another box.","since":"5.0","parameters":[{"name":"other","summary":"Box to include in this union."}]},{"signature":"void Union(Point3d point)","summary":"Updates this BoundingBox to represent the union of itself and a point.","since":"5.0","parameters":[{"name":"point","summary":"Point to include in the union."}]}]},{"namespace":"Rhino.Geometry","name":"Box","dataType":"struct","summary":"Represents the value of a plane and three intervals in an orthogonal, oriented box that is not necessarily parallel to the world Y, X, Z axes.","constructors":[{"signature":"Box(BoundingBox bbox)","summary":"Initializes a new Box that mimics a BoundingBox struct.  \\nThe orientation plane of the Box is coincident with the World XY plane.","since":"5.0","parameters":[{"name":"bbox","summary":"BoundingBox to mimic."}]},{"signature":"Box(Plane basePlane, BoundingBox boundingbox)","summary":"Initializes a world aligned box from a base plane and a bounding box.","since":"5.0","parameters":[{"name":"basePlane","summary":"Base plane of bounding box."},{"name":"boundingbox","summary":"Bounding Box in plane coordinates."}]},{"signature":"Box(Plane basePlane, GeometryBase geometry)","summary":"Initializes a box that contains a generic piece of geometry. This box will be aligned with an arbitrary plane.","since":"5.0","parameters":[{"name":"basePlane","summary":"Base plane for aligned bounding box."},{"name":"geometry","summary":"Geometry to box."}]},{"signature":"Box(Plane basePlane, IEnumerable<Point3d> points)","summary":"Initializes the smallest box that contains a set of points.","since":"5.0","parameters":[{"name":"basePlane","summary":"Orientation of the box."},{"name":"points","summary":"Points to include, Invalid points will be ignored."}]},{"signature":"Box(Plane basePlane, Interval xSize, Interval ySize, Interval zSize)","summary":"Initializes a new box from a base Plane and three Intervals.","since":"5.0","parameters":[{"name":"basePlane","summary":"Orientation plane of the box."},{"name":"xSize","summary":"Dimensions along the base plane X-Axis."},{"name":"ySize","summary":"Dimensions along the base plane Y-Axis."},{"name":"zSize","summary":"Dimensions along the base plane Z-Axis."}]}],"properties":[{"signature":"static Box Empty","summary":"Empty Box. Empty boxes are considered to be invalid.","since":"5.0","property":["get"]},{"signature":"static Box Unset","summary":"Gets a Box whose base plane and axis dimensions are all Unset.","since":"5.0","property":["get"]},{"signature":"double Area","summary":"Gets the total surface area of this box.","since":"5.0","property":["get"]},{"signature":"BoundingBox BoundingBox","summary":"Gets the world axis aligned Bounding box for this oriented box.","since":"5.0","property":["get"]},{"signature":"Point3d Center","summary":"Gets the point that is in the center of the box.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Gets the validity of this Box. Boxes are invalid when the base plane or any of the dimension intervals are invalid or decreasing.","since":"5.0","property":["get"]},{"signature":"Plane Plane","summary":"Gets or sets the orientation plane for this Box.","since":"5.0","property":["get","set"]},{"signature":"double Volume","summary":"Gets the total volume of this box.","since":"5.0","property":["get"]},{"signature":"Interval X","summary":"Gets or sets the Interval that describes the dimension of the Box along the orientation plane X-Axis. Otherwise known as the Width of the Box.","since":"5.0","property":["get","set"]},{"signature":"Interval Y","summary":"Gets or sets the Interval that describes the dimension of the Box along the orientation plane Y-Axis. Otherwise known as the Depth of the Box.","since":"5.0","property":["get","set"]},{"signature":"Interval Z","summary":"Gets or sets the Interval that describes the dimension of the Box along the orientation plane Z-Axis. Otherwise known as the Height of the Box.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"Point3d ClosestPoint(Point3d point)","summary":"Finds the closest point on or in the Box. The box should be Valid for this to work.","since":"5.0","parameters":[{"name":"point","summary":"Sample point."}],"returns":"The point on or in the box that is closest to the sample point."},{"signature":"bool Contains(BoundingBox box)","summary":"Test a bounding box for Box inclusion. This is the same as calling Contains(box,false)","since":"5.0","parameters":[{"name":"box","summary":"Box to test."}],"returns":"True if the box is on the inside of or coincident with this Box."},{"signature":"bool Contains(BoundingBox box, bool strict)","summary":"Test a bounding box for Box inclusion.","since":"5.0","parameters":[{"name":"box","summary":"Box to test."},{"name":"strict","summary":"If true, the bounding box needs to be fully on the inside of this Box. I.e. coincident boxes will be considered \'outside\'."}],"returns":"True if the box is (strictly) on the inside of this Box."},{"signature":"bool Contains(Box box)","summary":"Test a box for Box inclusion. This is the same as calling Contains(box,false)","since":"5.0","parameters":[{"name":"box","summary":"Box to test."}],"returns":"True if the box is on the inside of or coincident with this Box."},{"signature":"bool Contains(Box box, bool strict)","summary":"Test a box for Box inclusion.","since":"5.0","parameters":[{"name":"box","summary":"Box to test."},{"name":"strict","summary":"If true, the box needs to be fully on the inside of this Box. I.e. coincident boxes will be considered \'outside\'."}],"returns":"True if the box is (strictly) on the inside of this Box."},{"signature":"bool Contains(Point3d point)","summary":"Determines whether a point is included in this box. This is the same as calling Contains(point,false)","since":"5.0","parameters":[{"name":"point","summary":"Point to test."}],"returns":"True if the point is on the inside of or coincident with this Box."},{"signature":"bool Contains(Point3d point, bool strict)","summary":"Determines whether a point is included in this box.","since":"5.0","parameters":[{"name":"point","summary":"Point to test."},{"name":"strict","summary":"If true, the point needs to be fully on the inside of the Box. I.e. coincident points will be considered \'outside\'."}],"returns":"True if the point is (strictly) on the inside of this Box."},{"signature":"bool EpsilonEquals(Box other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"Point3d FurthestPoint(Point3d point)","summary":"Finds the furthest point on the Box. The Box should be Valid for this to work properly.","since":"5.0","parameters":[{"name":"point","summary":"Sample point."}],"returns":"The point on the box that is furthest from the sample point."},{"signature":"Point3d[] GetCorners()","summary":"Gets an array of the 8 corner points of this box.","since":"5.0","returns":"An array of 8 corners."},{"signature":"void Inflate(double amount)","summary":"Inflates the box by a given offset in each direction. Inflating with negative amounts may result in decreasing boxes. InValid boxes cannot be inflated.","since":"5.0","parameters":[{"name":"amount","summary":"Amount (in model units) to inflate this box in all directions."}]},{"signature":"void Inflate(double xAmount, double yAmount, double zAmount)","summary":"Inflates the box by a given offset in each direction. Inflating with negative amounts may result in decreasing boxes. InValid boxes cannot be inflated.","since":"5.0","parameters":[{"name":"xAmount","summary":"Amount (in model units) to inflate this box in the x direction."},{"name":"yAmount","summary":"Amount (in model units) to inflate this box in the y direction."},{"name":"zAmount","summary":"Amount (in model units) to inflate this box in the z direction."}]},{"signature":"bool MakeValid()","summary":"Attempts to make the Box valid. This is not always possible.","since":"5.0","returns":"True if the box was made valid, or if it was valid to begin with. False if the box remains unchanged."},{"signature":"Point3d PointAt(double x, double y, double z)","summary":"Evaluates the box volume at the given unitized parameters.  \\nThe box has idealized side length of 1x1x1.","since":"5.0","parameters":[{"name":"x","summary":"Unitized parameter (between 0 and 1 is inside the box) along box X direction."},{"name":"y","summary":"Unitized parameter (between 0 and 1 is inside the box) along box Y direction."},{"name":"z","summary":"Unitized parameter (between 0 and 1 is inside the box) along box Z direction."}],"returns":"The point at (x,y,z)."},{"signature":"void RepositionBasePlane(Point3d origin)","summary":"Repositions the origin of the Base plane for this box without affecting the physical dimensions.","since":"5.0","parameters":[{"name":"origin","summary":"The new base plane origin."}]},{"signature":"Brep ToBrep()","summary":"Constructs a brep representation of this box.","since":"5.0","returns":"A Brep representation of this box or null."},{"signature":"Extrusion ToExtrusion()","summary":"Constructs an extrusion representation of this box.","since":"6.0","returns":"An Extrusion representation of this box or null."},{"signature":"bool Transform(Transform xform)","summary":"Transforms this Box using a Transformation matrix. If the Transform does not preserve Similarity, the dimensions of the resulting box cannot be trusted.","since":"5.0","parameters":[{"name":"xform","summary":"Transformation matrix to apply to this Box."}],"returns":"True if the Box was successfully transformed, False if otherwise."},{"signature":"void Union(Point3d point)","summary":"Constructs a union between this Box and the given point. This grows the box in directions so it contains the point.","since":"5.0","parameters":[{"name":"point","summary":"Point to include."}]}]},{"namespace":"Rhino.Geometry","name":"Brep","dataType":"class","summary":"Boundary Representation. A surface or polysurface along with trim curve information.","baseclass":"Rhino.Geometry.GeometryBase","constructors":[{"signature":"Brep()","summary":"Initializes a new empty brep","since":"5.4"}],"properties":[{"signature":"BrepCurveList Curves2D","summary":"Parameter space trimming curves (used by trims)","since":"5.6","property":["get"]},{"signature":"BrepCurveList Curves3D","summary":"Pointers to 3d curves (used by edges)","since":"5.6","property":["get"]},{"signature":"BrepEdgeList Edges","summary":"Gets the brep edges list accessor.","since":"5.0","property":["get"]},{"signature":"BrepFaceList Faces","summary":"Gets the brep faces list accessor.","since":"5.0","property":["get"]},{"signature":"bool IsManifold","summary":"Gets a value indicating whether or not the Brep is manifold. Non-Manifold breps have at least one edge that is shared among three or more faces.","since":"5.0","property":["get"]},{"signature":"bool IsSolid","summary":"Determines whether this brep is a solid, or a closed oriented manifold.","since":"5.0","property":["get"]},{"signature":"bool IsSurface","summary":"Returns True if the Brep has a single face and that face is geometrically the same as the underlying surface.  I.e., the face has trivial trimming.  \\nIn this case, the surface is the first face surface. The flag Brep.Faces[0].OrientationIsReversed records the correspondence between the surface\'s natural parametric orientation and the orientation of the Brep.  \\ntrivial trimming here means that there is only one loop curve in the brep and that loop curve is the same as the underlying surface boundary.","since":"5.0","property":["get"]},{"signature":"BrepLoopList Loops","summary":"Gets the brep loop list accessor.","since":"5.0","property":["get"]},{"signature":"BrepSolidOrientation SolidOrientation","summary":"Gets the solid orientation state of this Brep.","since":"5.0","property":["get"]},{"signature":"BrepSurfaceList Surfaces","summary":"Parametric surfaces used by faces","since":"5.4","property":["get"]},{"signature":"BrepTrimList Trims","summary":"Gets the brep trims list accessor.","since":"5.1","property":["get"]},{"signature":"BrepVertexList Vertices","summary":"Gets the brep vertices list accessor.","since":"5.5","property":["get"]}],"methods":[{"signature":"static Brep ChangeSeam(BrepFace face, int direction, double parameter, double tolerance)","summary":"Change the seam of a closed trimmed surface.","since":"6.4","parameters":[{"name":"face","summary":"A Brep face with a closed underlying surface."},{"name":"direction","summary":"The parameter direction (0 = U, 1 = V). The face\'s underlying surface must be closed in this direction."},{"name":"parameter","summary":"The parameter at which to place the seam."},{"name":"tolerance","summary":"Tolerance used to cut up surface."}],"returns":"A new Brep that has the same geometry as the face with a relocated seam if successful, or None on failure."},{"signature":"static Brep CopyTrimCurves(BrepFace trimSource, Surface surfaceSource, double tolerance)","summary":"Copy all trims from a Brep face onto a surface.","since":"5.0","parameters":[{"name":"trimSource","summary":"Brep face which defines the trimming curves."},{"name":"surfaceSource","summary":"The surface to trim."},{"name":"tolerance","summary":"Tolerance to use for rebuilding 3D trim curves."}],"returns":"A brep with the shape of surfaceSource and the trims of trimSource or None on failure."},{"signature":"static Brep CreateBaseballSphere(Point3d center, double radius, double tolerance)","summary":"Creates a brep representation of the sphere with two similar trimmed NURBS surfaces, and no singularities.","since":"6.0","parameters":[{"name":"center","summary":"The center of the sphere."},{"name":"radius","summary":"The radius of the sphere."},{"name":"tolerance","summary":"Used in computing 2d trimming curves. If >= 0.0, then the max of ON_0.0001 * radius and RhinoMath.ZeroTolerance will be used."}],"returns":"A new brep, or None on error."},{"signature":"static Curve CreateBlendShape(BrepFace face0, BrepEdge edge0, double t0, bool rev0, BlendContinuity continuity0, BrepFace face1, BrepEdge edge1, double t1, bool rev1, BlendContinuity continuity1)","summary":"Makes a curve blend between points on two surface edges. The blend will be tangent to the surfaces and perpendicular to the edges.","since":"6.0","parameters":[{"name":"face0","summary":"First face to blend from."},{"name":"edge0","summary":"First edge to blend from."},{"name":"t0","summary":"Location on first edge for first end of blend curve."},{"name":"rev0","summary":"If false, edge0 will be used in its natural direction. If true, edge0 will be used in the reversed direction."},{"name":"continuity0","summary":"Continuity for the blend at the start."},{"name":"face1","summary":"Second face to blend from."},{"name":"edge1","summary":"Second edge to blend from."},{"name":"t1","summary":"Location on second edge for second end of blend curve."},{"name":"rev1","summary":"If false, edge1 will be used in its natural direction. If true, edge1 will be used in the reversed direction."},{"name":"continuity1","summary":">Continuity for the blend at the end."}],"returns":"The blend curve on success. None on failure"},{"signature":"static Brep[] CreateBlendSurface(BrepFace face0, BrepEdge edge0, Interval domain0, bool rev0, BlendContinuity continuity0, BrepFace face1, BrepEdge edge1, Interval domain1, bool rev1, BlendContinuity continuity1)","summary":"Makes a surface blend between two surface edges.","since":"6.0","parameters":[{"name":"face0","summary":"First face to blend from."},{"name":"edge0","summary":"First edge to blend from."},{"name":"domain0","summary":"The domain of edge0 to use."},{"name":"rev0","summary":"If false, edge0 will be used in its natural direction. If true, edge0 will be used in the reversed direction."},{"name":"continuity0","summary":"Continuity for the blend at the start."},{"name":"face1","summary":"Second face to blend from."},{"name":"edge1","summary":"Second edge to blend from."},{"name":"domain1","summary":"The domain of edge1 to use."},{"name":"rev1","summary":"If false, edge1 will be used in its natural direction. If true, edge1 will be used in the reversed direction."},{"name":"continuity1","summary":"Continuity for the blend at the end."}],"returns":"Array of Breps if successful."},{"signature":"static Brep[] CreateBooleanDifference(Brep firstBrep, Brep secondBrep, double tolerance)","summary":"Compute the Solid Difference of two Breps.","since":"5.0","parameters":[{"name":"firstBrep","summary":"First Brep for boolean difference."},{"name":"secondBrep","summary":"Second Brep for boolean difference."},{"name":"tolerance","summary":"Tolerance to use for difference operation."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep[] CreateBooleanDifference(Brep firstBrep, Brep secondBrep, double tolerance, bool manifoldOnly)","summary":"Compute the Solid Difference of two Breps.","since":"6.0","parameters":[{"name":"firstBrep","summary":"First Brep for boolean difference."},{"name":"secondBrep","summary":"Second Brep for boolean difference."},{"name":"tolerance","summary":"Tolerance to use for difference operation."},{"name":"manifoldOnly","summary":"If true, non-manifold input breps are ignored."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep[] CreateBooleanDifference(IEnumerable<Brep> firstSet, IEnumerable<Brep> secondSet, double tolerance)","summary":"Compute the Solid Difference of two sets of Breps.","since":"5.0","parameters":[{"name":"firstSet","summary":"First set of Breps (the set to subtract from)."},{"name":"secondSet","summary":"Second set of Breps (the set to subtract)."},{"name":"tolerance","summary":"Tolerance to use for difference operation."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep[] CreateBooleanDifference(IEnumerable<Brep> firstSet, IEnumerable<Brep> secondSet, double tolerance, bool manifoldOnly)","summary":"Compute the Solid Difference of two sets of Breps.","since":"6.0","parameters":[{"name":"firstSet","summary":"First set of Breps (the set to subtract from)."},{"name":"secondSet","summary":"Second set of Breps (the set to subtract)."},{"name":"tolerance","summary":"Tolerance to use for difference operation."},{"name":"manifoldOnly","summary":"If true, non-manifold input breps are ignored."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep[] CreateBooleanIntersection(Brep firstBrep, Brep secondBrep, double tolerance)","summary":"Compute the Solid Intersection of two Breps.","since":"5.0","parameters":[{"name":"firstBrep","summary":"First Brep for boolean intersection."},{"name":"secondBrep","summary":"Second Brep for boolean intersection."},{"name":"tolerance","summary":"Tolerance to use for intersection operation."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep[] CreateBooleanIntersection(Brep firstBrep, Brep secondBrep, double tolerance, bool manifoldOnly)","summary":"Compute the Solid Intersection of two Breps.","since":"6.0","parameters":[{"name":"firstBrep","summary":"First Brep for boolean intersection."},{"name":"secondBrep","summary":"Second Brep for boolean intersection."},{"name":"tolerance","summary":"Tolerance to use for intersection operation."},{"name":"manifoldOnly","summary":"If true, non-manifold input breps are ignored."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep[] CreateBooleanIntersection(IEnumerable<Brep> firstSet, IEnumerable<Brep> secondSet, double tolerance)","summary":"Compute the Solid Intersection of two sets of Breps.","since":"5.0","parameters":[{"name":"firstSet","summary":"First set of Breps."},{"name":"secondSet","summary":"Second set of Breps."},{"name":"tolerance","summary":"Tolerance to use for intersection operation."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep[] CreateBooleanIntersection(IEnumerable<Brep> firstSet, IEnumerable<Brep> secondSet, double tolerance, bool manifoldOnly)","summary":"Compute the Solid Intersection of two sets of Breps.","since":"6.0","parameters":[{"name":"firstSet","summary":"First set of Breps."},{"name":"secondSet","summary":"Second set of Breps."},{"name":"tolerance","summary":"Tolerance to use for intersection operation."},{"name":"manifoldOnly","summary":"If true, non-manifold input breps are ignored."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep[] CreateBooleanSplit(Brep firstBrep, Brep secondBrep, double tolerance)","summary":"Splits shared areas of Breps and creates separate Breps from the shared and unshared parts.","since":"6.16","parameters":[{"name":"firstBrep","summary":"The Brep to split."},{"name":"secondBrep","summary":"The cutting Brep."},{"name":"tolerance","summary":"Tolerance to use for splitting operation. When in doubt, use the document\'s model absolute tolerance."}],"returns":"An array of Brep if successful, an empty array on failure."},{"signature":"static Brep[] CreateBooleanSplit(IEnumerable<Brep> firstSet, IEnumerable<Brep> secondSet, double tolerance)","summary":"Splits shared areas of Breps and creates separate Breps from the shared and unshared parts.","since":"6.16","parameters":[{"name":"firstSet","summary":"The Breps to split."},{"name":"secondSet","summary":"The cutting Breps."},{"name":"tolerance","summary":"Tolerance to use for splitting operation. When in doubt, use the document\'s model absolute tolerance."}],"returns":"An array of Brep if successful, an empty array on failure."},{"signature":"static Brep[] CreateBooleanUnion(IEnumerable<Brep> breps, double tolerance)","summary":"Compute the Boolean Union of a set of Breps.","since":"5.0","parameters":[{"name":"breps","summary":"Breps to union."},{"name":"tolerance","summary":"Tolerance to use for union operation."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep[] CreateBooleanUnion(IEnumerable<Brep> breps, double tolerance, bool manifoldOnly)","summary":"Compute the Boolean Union of a set of Breps.","since":"6.0","parameters":[{"name":"breps","summary":"Breps to union."},{"name":"tolerance","summary":"Tolerance to use for union operation."},{"name":"manifoldOnly","summary":"If true, non-manifold input breps are ignored."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep[] CreateChamferSurface(BrepFace face0, Point2d uv0, double radius0, BrepFace face1, Point2d uv1, double radius1, bool trim, bool extend, double tolerance, out Brep[] outBreps0, out Brep[] outBreps1)","summary":"Creates a ruled surface as a bevel between two input surface edges.","since":"6.0","parameters":[{"name":"face0","summary":"First face to chamfer from."},{"name":"uv0","summary":"A parameter face0 at the side you want to keep after chamfering."},{"name":"radius0","summary":"The distance from the intersection of face0 to the edge of the chamfer."},{"name":"face1","summary":"Second face to chamfer from."},{"name":"uv1","summary":"A parameter face1 at the side you want to keep after chamfering."},{"name":"radius1","summary":"The distance from the intersection of face1 to the edge of the chamfer."},{"name":"trim","summary":"If true, the input faces will be trimmed, if false, the input faces will be split."},{"name":"extend","summary":"If true, then when one input surface is longer than the other, the chamfer surface is extended to the input surface edges."},{"name":"tolerance","summary":"The tolerance. When in doubt, use the document\'s model absolute tolerance."},{"name":"outBreps0","summary":"The trim or split results of the Brep owned by face0."},{"name":"outBreps1","summary":"The trim or split results of the Brep owned by face1."}],"returns":"Array of Breps if successful."},{"signature":"static Brep[] CreateChamferSurface(BrepFace face0, Point2d uv0, double radius0, BrepFace face1, Point2d uv1, double radius1, bool extend, double tolerance)","summary":"Creates a ruled surface as a bevel between two input surface edges.","since":"6.0","parameters":[{"name":"face0","summary":"First face to chamfer from."},{"name":"uv0","summary":"A parameter face0 at the side you want to keep after chamfering."},{"name":"radius0","summary":"The distance from the intersection of face0 to the edge of the chamfer."},{"name":"face1","summary":"Second face to chamfer from."},{"name":"uv1","summary":"A parameter face1 at the side you want to keep after chamfering."},{"name":"radius1","summary":"The distance from the intersection of face1 to the edge of the chamfer."},{"name":"extend","summary":"If true, then when one input surface is longer than the other, the chamfer surface is extended to the input surface edges."},{"name":"tolerance","summary":"The tolerance. When in doubt, use the document\'s model absolute tolerance."}],"returns":"Array of Breps if successful."},{"signature":"static Curve[] CreateContourCurves(Brep brepToContour, Plane sectionPlane)","summary":"Constructs the contour curves for a brep, using a slicing plane.","since":"5.0","parameters":[{"name":"brepToContour","summary":"A brep or polysurface."},{"name":"sectionPlane","summary":"A plane."}],"returns":"An array with intersected curves. This array can be empty."},{"signature":"static Curve[] CreateContourCurves(Brep brepToContour, Point3d contourStart, Point3d contourEnd, double interval)","summary":"Constructs the contour curves for a brep at a specified interval.","since":"5.0","parameters":[{"name":"brepToContour","summary":"A brep or polysurface."},{"name":"contourStart","summary":"A point to start."},{"name":"contourEnd","summary":"A point to use as the end."},{"name":"interval","summary":"The interaxial offset in world units."}],"returns":"An array with intersected curves. This array can be empty."},{"signature":"static Mesh[] CreateCurvatureAnalysisMesh(Brep brep, CurvatureAnalysisSettingsState state)","summary":"Create an array of analysis meshes for the brep using the specified settings. Meshes aren\'t set on the brep.","since":"6.0","parameters":[{"name":"brep","summary":""},{"name":"state","summary":"CurvatureAnalysisSettingsState"}],"returns":"True if meshes were created"},{"signature":"static Brep[] CreateDevelopableLoft(Curve crv0, Curve crv1, bool reverse0, bool reverse1, int density)","summary":"Creates a single developable surface between two curves.","since":"6.10","parameters":[{"name":"crv0","summary":"The first rail curve."},{"name":"crv1","summary":"The second rail curve."},{"name":"reverse0","summary":"Reverse the first rail curve."},{"name":"reverse1","summary":"Reverse the second rail curve"},{"name":"density","summary":"The number of rulings across the surface."}],"returns":"The output Breps if successful, otherwise an empty array."},{"signature":"static Brep[] CreateDevelopableLoft(NurbsCurve rail0, NurbsCurve rail1, IEnumerable<Point2d> fixedRulings)","summary":"Creates a single developable surface between two curves.","since":"6.10","parameters":[{"name":"rail0","summary":"The first rail curve."},{"name":"rail1","summary":"The second rail curve."},{"name":"fixedRulings","summary":"Rulings define lines across the surface that define the straight sections on the developable surface, where rulings[i].X = parameter on first rail curve, and rulings[i].Y = parameter on second rail curve. Note, rulings will be automatically adjusted to minimum twist."}],"returns":"The output Breps if successful, otherwise an empty array."},{"signature":"static Brep CreateEdgeSurface(IEnumerable<Curve> curves)","summary":"Constructs a coons patch from 2, 3, or 4 curves.","since":"5.0","parameters":[{"name":"curves","summary":"A list, an array or any enumerable set of curves."}],"returns":"resulting brep or None on failure."},{"signature":"static Brep[] CreateFilletEdges(Brep brep, IEnumerable<int> edgeIndices, IEnumerable<double> startRadii, IEnumerable<double> endRadii, BlendType blendType, RailType railType, double tolerance)","summary":"Fillets, chamfers, or blends the edges of a brep.","since":"6.0","parameters":[{"name":"brep","summary":"The brep to fillet, chamfer, or blend edges."},{"name":"edgeIndices","summary":"An array of one or more edge indices where the fillet, chamfer, or blend will occur."},{"name":"startRadii","summary":"An array of starting fillet, chamfer, or blend radaii, one for each edge index."},{"name":"endRadii","summary":"An array of ending fillet, chamfer, or blend radaii, one for each edge index."},{"name":"blendType","summary":"The blend type."},{"name":"railType","summary":"The rail type."},{"name":"tolerance","summary":"The tolerance to be used to perform calculations."}],"returns":"Array of Breps if successful."},{"signature":"static Brep[] CreateFilletSurface(BrepFace face0, Point2d uv0, BrepFace face1, Point2d uv1, double radius, bool trim, bool extend, double tolerance, out Brep[] outBreps0, out Brep[] outBreps1)","summary":"Creates a constant-radius round surface between two surfaces.","since":"6.0","parameters":[{"name":"face0","summary":"First face to fillet from."},{"name":"uv0","summary":"A parameter face0 at the side you want to keep after filleting."},{"name":"face1","summary":"Second face to fillet from."},{"name":"uv1","summary":"A parameter face1 at the side you want to keep after filleting."},{"name":"radius","summary":"The fillet radius."},{"name":"trim","summary":"If true, the input faces will be trimmed, if false, the input faces will be split."},{"name":"extend","summary":"If true, then when one input surface is longer than the other, the fillet surface is extended to the input surface edges."},{"name":"tolerance","summary":"The tolerance. When in doubt, use the document\'s model absolute tolerance."},{"name":"outBreps0","summary":"The trim or split results of the Brep owned by face0."},{"name":"outBreps1","summary":"The trim or split results of the Brep owned by face1."}],"returns":"Array of Breps if successful."},{"signature":"static Brep[] CreateFilletSurface(BrepFace face0, Point2d uv0, BrepFace face1, Point2d uv1, double radius, bool extend, double tolerance)","summary":"Creates a constant-radius round surface between two surfaces.","since":"6.0","parameters":[{"name":"face0","summary":"First face to fillet from."},{"name":"uv0","summary":"A parameter face0 at the side you want to keep after filleting."},{"name":"face1","summary":"Second face to fillet from."},{"name":"uv1","summary":"A parameter face1 at the side you want to keep after filleting."},{"name":"radius","summary":"The fillet radius."},{"name":"extend","summary":"If true, then when one input surface is longer than the other, the fillet surface is extended to the input surface edges."},{"name":"tolerance","summary":"The tolerance. When in doubt, use the document\'s model absolute tolerance."}],"returns":"Array of Breps if successful."},{"signature":"static Brep CreateFromBox(BoundingBox box)","summary":"Constructs new brep that matches a bounding box.","since":"5.0","parameters":[{"name":"box","summary":"A box to use for creation."}],"returns":"A new brep; or None on failure."},{"signature":"static Brep CreateFromBox(Box box)","summary":"Constructs new brep that matches an aligned box.","since":"5.0","parameters":[{"name":"box","summary":"Box to match."}],"returns":"A Brep with 6 faces that is similar to the Box."},{"signature":"static Brep CreateFromBox(IEnumerable<Point3d> corners)","summary":"Constructs new brep from 8 corner points.","since":"5.0","parameters":[{"name":"corners","summary":"8 points defining the box corners arranged as the vN labels indicate. v7_______e6____v6|\\\\             |\\\\| e7           | e5|  \\\\ ______e4_____\\\\e11 v4         |   v5|   |        e10   ||   |          |   |v3--|---e2----v2   e9 \\\\  e8          \\\\  | e3 |            e1|   \\\\|             \\\\|    v0_____e0______v1"}],"returns":"A new brep, or None on error."},{"signature":"static Brep CreateFromCone(Cone cone, bool capBottom)","summary":"Constructs a Brep representation of the cone with a single face for the cone, an edge along the cone seam, and vertices at the base and apex ends of this seam edge. The optional cap is a single face with one circular edge starting and ending at the base vertex.","since":"5.0","parameters":[{"name":"cone","summary":"A cone value."},{"name":"capBottom","summary":"if True the base of the cone should be capped."}],"returns":"A Brep if successful, None on error."},{"signature":"static Brep CreateFromCornerPoints(Point3d corner1, Point3d corner2, Point3d corner3, double tolerance)","summary":"Makes a Brep with one face from three corner points.","since":"5.0","parameters":[{"name":"corner1","summary":"A first corner."},{"name":"corner2","summary":"A second corner."},{"name":"corner3","summary":"A third corner."},{"name":"tolerance","summary":"Minimum edge length allowed before collapsing the side into a singularity."}],"returns":"A boundary representation, or None on error."},{"signature":"static Brep CreateFromCornerPoints(Point3d corner1, Point3d corner2, Point3d corner3, Point3d corner4, double tolerance)","summary":"Makes a Brep with one face from four corner points.","since":"5.0","parameters":[{"name":"corner1","summary":"A first corner."},{"name":"corner2","summary":"A second corner."},{"name":"corner3","summary":"A third corner."},{"name":"corner4","summary":"A fourth corner."},{"name":"tolerance","summary":"Minimum edge length allowed before collapsing the side into a singularity."}],"returns":"A boundary representation, or None on error."},{"signature":"static Brep CreateFromCylinder(Cylinder cylinder, bool capBottom, bool capTop)","summary":"Constructs a Brep definition of a cylinder.","since":"5.0","parameters":[{"name":"cylinder","summary":"cylinder.IsFinite() must be true."},{"name":"capBottom","summary":"if True end at cylinder.m_height[0] should be capped."},{"name":"capTop","summary":"if True end at cylinder.m_height[1] should be capped."}],"returns":"A Brep representation of the cylinder with a single face for the cylinder, an edge along the cylinder seam, and vertices at the bottom and top ends of this seam edge. The optional bottom/top caps are single faces with one circular edge starting and ending at the bottom/top vertex."},{"signature":"static Brep CreateFromJoinedEdges(Brep brep0, int edgeIndex0, Brep brep1, int edgeIndex1, double joinTolerance)","summary":"Joins two naked edges, or edges that are coincident or close together, from two Breps.","since":"6.0","parameters":[{"name":"brep0","summary":"The first Brep."},{"name":"edgeIndex0","summary":"The edge index on the first Brep."},{"name":"brep1","summary":"The second Brep."},{"name":"edgeIndex1","summary":"The edge index on the second Brep."},{"name":"joinTolerance","summary":"The join tolerance."}],"returns":"The resulting Brep if successful, None on failure."},{"signature":"static Brep[] CreateFromLoft(IEnumerable<Curve> curves, Point3d start, Point3d end, bool StartTangent, bool EndTangent, BrepTrim StartTrim, BrepTrim EndTrim, LoftType loftType, bool closed)","summary":"Constructs one or more Breps by lofting through a set of curves, optionally matching start and end tangents of surfaces when first and/or last loft curves are surface edges","since":"7.0","parameters":[{"name":"curves","summary":"The curves to loft through. This function will not perform any curve sorting. You must pass in curves in the order you want them lofted. This function will not adjust the directions of open curves. Use Curve.DoDirectionsMatch and Curve.Reverse to adjust the directions of open curves. This function will not adjust the seams of closed curves. Use Curve.ChangeClosedCurveSeam to adjust the seam of closed curves."},{"name":"start","summary":"Optional starting point of loft. Use Point3d.Unset if you do not want to include a start point. \\"start\\" and \\"StartTangent\\" cannot both be true."},{"name":"end","summary":"Optional ending point of loft. Use Point3d.Unset if you do not want to include an end point. \\"end and \\"EndTangent\\" cannot both be true."},{"name":"StartTangent","summary":"If StartTangent is True and the first loft curve is a surface edge, the loft will match the tangent of the surface behind that edge."},{"name":"EndTangent","summary":"If EndTangent is True and the first loft curve is a surface edge, the loft will match the tangent of the surface behind that edge."},{"name":"StartTrim","summary":"BrepTrim from the surface edge where start tangent is to be matched"},{"name":"EndTrim","summary":"BrepTrim from the surface edge where end tangent is to be matched"},{"name":"loftType","summary":"type of loft to perform."},{"name":"closed","summary":"True if the last curve in this loft should be connected back to the first one."}],"returns":"Constructs a closed surface, continuing the surface past the last curve around to the first curve. Available when you have selected three shape curves."},{"signature":"static Brep[] CreateFromLoft(IEnumerable<Curve> curves, Point3d start, Point3d end, LoftType loftType, bool closed)","summary":"Constructs one or more Breps by lofting through a set of curves.","since":"5.0","parameters":[{"name":"curves","summary":"The curves to loft through. This function will not perform any curve sorting. You must pass in curves in the order you want them lofted. This function will not adjust the directions of open curves. Use Curve.DoDirectionsMatch and Curve.Reverse to adjust the directions of open curves. This function will not adjust the seams of closed curves. Use Curve.ChangeClosedCurveSeam to adjust the seam of closed curves."},{"name":"start","summary":"Optional starting point of loft. Use Point3d.Unset if you do not want to include a start point."},{"name":"end","summary":"Optional ending point of loft. Use Point3d.Unset if you do not want to include an end point."},{"name":"loftType","summary":"type of loft to perform."},{"name":"closed","summary":"True if the last curve in this loft should be connected back to the first one."}],"returns":"Constructs a closed surface, continuing the surface past the last curve around to the first curve. Available when you have selected three shape curves."},{"signature":"static Brep[] CreateFromLoftRebuild(IEnumerable<Curve> curves, Point3d start, Point3d end, LoftType loftType, bool closed, int rebuildPointCount)","summary":"Constructs one or more Breps by lofting through a set of curves. Input for the loft is simplified by rebuilding to a specified number of control points.","since":"5.0","parameters":[{"name":"curves","summary":"The curves to loft through. This function will not perform any curve sorting. You must pass in curves in the order you want them lofted. This function will not adjust the directions of open curves. Use Curve.DoDirectionsMatch and Curve.Reverse to adjust the directions of open curves. This function will not adjust the seams of closed curves. Use Curve.ChangeClosedCurveSeam to adjust the seam of closed curves."},{"name":"start","summary":"Optional starting point of loft. Use Point3d.Unset if you do not want to include a start point."},{"name":"end","summary":"Optional ending point of lost. Use Point3d.Unset if you do not want to include an end point."},{"name":"loftType","summary":"type of loft to perform."},{"name":"closed","summary":"True if the last curve in this loft should be connected back to the first one."},{"name":"rebuildPointCount","summary":"A number of points to use while rebuilding the curves. 0 leaves turns this parameter off."}],"returns":"Constructs a closed surface, continuing the surface past the last curve around to the first curve. Available when you have selected three shape curves."},{"signature":"static Brep[] CreateFromLoftRefit(IEnumerable<Curve> curves, Point3d start, Point3d end, LoftType loftType, bool closed, double refitTolerance)","summary":"Constructs one or more Breps by lofting through a set of curves. Input for the loft is simplified by refitting to a specified tolerance.","since":"5.0","parameters":[{"name":"curves","summary":"The curves to loft through. This function will not perform any curve sorting. You must pass in curves in the order you want them lofted. This function will not adjust the directions of open curves. Use Curve.DoDirectionsMatch and Curve.Reverse to adjust the directions of open curves. This function will not adjust the seams of closed curves. Use Curve.ChangeClosedCurveSeam to adjust the seam of closed curves."},{"name":"start","summary":"Optional starting point of loft. Use Point3d.Unset if you do not want to include a start point."},{"name":"end","summary":"Optional ending point of lost. Use Point3d.Unset if you do not want to include an end point."},{"name":"loftType","summary":"type of loft to perform."},{"name":"closed","summary":"True if the last curve in this loft should be connected back to the first one."},{"name":"refitTolerance","summary":"A distance to use in refitting, or 0 if you want to turn this parameter off."}],"returns":"Constructs a closed surface, continuing the surface past the last curve around to the first curve. Available when you have selected three shape curves."},{"signature":"static Brep CreateFromMesh(Mesh mesh, bool trimmedTriangles)","summary":"Create a brep representation of a mesh","since":"5.1","parameters":[{"name":"mesh","summary":""},{"name":"trimmedTriangles","summary":"if true, triangles in the mesh will be represented by trimmed planes in the brep. If false, triangles in the mesh will be represented by untrimmed singular bilinear NURBS surfaces in the brep."}]},{"signature":"static Brep CreateFromOffsetFace(BrepFace face, double offsetDistance, double offsetTolerance, bool bothSides, bool createSolid)","summary":"Offsets a face including trim information to create a new brep.","since":"5.0","parameters":[{"name":"face","summary":"the face to offset."},{"name":"offsetDistance","summary":"An offset distance."},{"name":"offsetTolerance","summary":"Use 0.0 to make a loose offset. Otherwise, the document\'s absolute tolerance is usually sufficient."},{"name":"bothSides","summary":"When true, offset to both sides of the input face."},{"name":"createSolid","summary":"When true, make a solid object."}],"returns":"A new brep if successful. The brep can be disjoint if bothSides is True and createSolid is false, or if createSolid is True and connecting the offsets with side surfaces fails. None if unsuccessful."},{"signature":"static Brep CreateFromRevSurface(RevSurface surface, bool capStart, bool capEnd)","summary":"Constructs a brep form of a surface of revolution.","since":"5.0","parameters":[{"name":"surface","summary":"The surface of revolution."},{"name":"capStart","summary":"if true, the start of the revolute is not on the axis of revolution, and the surface of revolution is closed, then a circular cap will be added to close of the hole at the start of the revolute."},{"name":"capEnd","summary":"if true, the end of the revolute is not on the axis of revolution, and the surface of revolution is closed, then a circular cap will be added to close of the hole at the end of the revolute."}],"returns":"A Brep if successful, None on error."},{"signature":"static Brep CreateFromSphere(Sphere sphere)","summary":"Constructs a Brep definition of a sphere.","since":"5.0","parameters":[{"name":"sphere","summary":"The input sphere provides the orienting plane and radius."}],"returns":"A Brep if successful, None on error."},{"signature":"static Brep CreateFromSurface(Surface surface)","summary":"Constructs a Brep from a surface. The resulting Brep has an outer boundary made from four trims. The trims are ordered so that they run along the south, east, north, and then west side of the surface\'s parameter space.","since":"5.0","parameters":[{"name":"surface","summary":"A surface to convert."}],"returns":"Resulting brep or None on failure."},{"signature":"static Brep[] CreateFromSweep(Curve rail, Curve shape, bool closed, double tolerance)","summary":"Sweep1 function that fits a surface through a profile curve that define the surface cross-sections and one curve that defines a surface edge.","since":"5.0","parameters":[{"name":"rail","summary":"Rail to sweep shapes along"},{"name":"shape","summary":"Shape curve"},{"name":"closed","summary":"Only matters if shape is closed"},{"name":"tolerance","summary":"Tolerance for fitting surface and rails"}],"returns":"Array of Brep sweep results"},{"signature":"static Brep[] CreateFromSweep(Curve rail1, Curve rail2, Curve shape, bool closed, double tolerance)","summary":"General 2 rail sweep. If you are not producing the sweep results that you are after, then use the SweepTwoRail class with options to generate the swept geometry.","since":"5.0","parameters":[{"name":"rail1","summary":"Rail to sweep shapes along"},{"name":"rail2","summary":"Rail to sweep shapes along"},{"name":"shape","summary":"Shape curve"},{"name":"closed","summary":"Only matters if shape is closed"},{"name":"tolerance","summary":"Tolerance for fitting surface and rails"}],"returns":"Array of Brep sweep results"},{"signature":"static Brep[] CreateFromSweep(Curve rail1, Curve rail2, IEnumerable<Curve> shapes, bool closed, double tolerance)","summary":"General 2 rail sweep. If you are not producing the sweep results that you are after, then use the SweepTwoRail class with options to generate the swept geometry.","since":"5.0","parameters":[{"name":"rail1","summary":"Rail to sweep shapes along"},{"name":"rail2","summary":"Rail to sweep shapes along"},{"name":"shapes","summary":"Shape curves"},{"name":"closed","summary":"Only matters if shapes are closed"},{"name":"tolerance","summary":"Tolerance for fitting surface and rails"}],"returns":"Array of Brep sweep results"},{"signature":"static Brep[] CreateFromSweep(Curve rail1, Curve rail2, IEnumerable<Curve> shapes, Point3d start, Point3d end, bool closed, double tolerance, SweepRebuild rebuild, int rebuildPointCount, double refitTolerance, bool preserveHeight)","summary":"Sweep2 function that fits a surface through profile curves that define the surface cross-sections and two curves that defines the surface edges.","since":"6.16","parameters":[{"name":"rail1","summary":"Rail to sweep shapes along"},{"name":"rail2","summary":"Rail to sweep shapes along"},{"name":"shapes","summary":"Shape curves"},{"name":"start","summary":"Optional starting point of sweep. Use Point3d.Unset if you do not want to include a start point."},{"name":"end","summary":"Optional ending point of sweep. Use Point3d.Unset if you do not want to include an end point."},{"name":"closed","summary":"Only matters if shapes are closed."},{"name":"tolerance","summary":"Tolerance for fitting surface and rails."},{"name":"rebuild","summary":"The rebuild style."},{"name":"rebuildPointCount","summary":"If rebuild == SweepRebuild.Rebuild, the number of points. Otherwise specify 0."},{"name":"refitTolerance","summary":"If rebuild == SweepRebuild.Refit, the refit tolerance. Otherwise, specify 0.0"},{"name":"preserveHeight","summary":"Removes the association between the height scaling from the width scaling"}],"returns":"Array of Brep sweep results"},{"signature":"static Brep[] CreateFromSweep(Curve rail, IEnumerable<Curve> shapes, bool closed, double tolerance)","summary":"Sweep1 function that fits a surface through profile curves that define the surface cross-sections and one curve that defines a surface edge.","since":"5.0","parameters":[{"name":"rail","summary":"Rail to sweep shapes along"},{"name":"shapes","summary":"Shape curves"},{"name":"closed","summary":"Only matters if shapes are closed"},{"name":"tolerance","summary":"Tolerance for fitting surface and rails"}],"returns":"Array of Brep sweep results"},{"signature":"static Brep[] CreateFromSweep(Curve rail, IEnumerable<Curve> shapes, Point3d startPoint, Point3d endPoint, SweepFrame frameType, Vector3d roadlikeNormal, bool closed, SweepBlend blendType, SweepMiter miterType, double tolerance, SweepRebuild rebuildType, int rebuildPointCount, double refitTolerance)","summary":"Sweep1 function that fits a surface through a series of profile curves that define the surface cross-sections and one curve that defines a surface edge.","since":"7.0","parameters":[{"name":"rail","summary":"Rail to sweep shapes along."},{"name":"shapes","summary":"Shape curves."},{"name":"startPoint","summary":"Optional starting point of sweep. Use Point3d.Unset if you do not want to include a start point."},{"name":"endPoint","summary":"Optional ending point of sweep. Use Point3d.Unset if you do not want to include an end point."},{"name":"frameType","summary":"The frame type."},{"name":"roadlikeNormal","summary":"The roadlike normal directoion. Use Vector3d.Unset if the frame type is not set to roadlike."},{"name":"closed","summary":"Only matters if shapes are closed."},{"name":"blendType","summary":"The shape blending type."},{"name":"miterType","summary":"The mitering type."},{"name":"tolerance","summary":""},{"name":"rebuildType","summary":"The rebuild style."},{"name":"rebuildPointCount","summary":"If rebuild == SweepRebuild.Rebuild, the number of points. Otherwise specify 0."},{"name":"refitTolerance","summary":"If rebuild == SweepRebuild.Refit, the refit tolerance. Otherwise, specify 0.0"}],"returns":"Array of Brep sweep results."},{"signature":"static Brep[] CreateFromSweepInParts(Curve rail1, Curve rail2, IEnumerable<Curve> shapes, IEnumerable<Point2d> rail_params, bool closed, double tolerance)","summary":"Makes a 2 rail sweep. Like CreateFromSweep but the result is split where parameterization along a rail changes abruptly.","since":"6.0","parameters":[{"name":"rail1","summary":"Rail to sweep shapes along"},{"name":"rail2","summary":"Rail to sweep shapes along"},{"name":"shapes","summary":"Shape curves"},{"name":"rail_params","summary":"Shape parameters"},{"name":"closed","summary":"Only matters if shapes are closed"},{"name":"tolerance","summary":"Tolerance for fitting surface and rails"}],"returns":"Array of Brep sweep results"},{"signature":"static Brep[] CreateFromSweepSegmented(Curve rail, Curve shape, bool closed, double tolerance)","summary":"Sweep1 function that fits a surface through a profile curve that define the surface cross-sections and one curve that defines a surface edge. The Segmented version breaks the rail at curvature kinks and sweeps each piece separately, then put the results together into a Brep.","since":"6.14","parameters":[{"name":"rail","summary":"Rail to sweep shapes along"},{"name":"shape","summary":"Shape curve"},{"name":"closed","summary":"Only matters if shape is closed"},{"name":"tolerance","summary":"Tolerance for fitting surface and rails"}],"returns":"Array of Brep sweep results"},{"signature":"static Brep[] CreateFromSweepSegmented(Curve rail, IEnumerable<Curve> shapes, bool closed, double tolerance)","summary":"Sweep1 function that fits a surface through a series of profile curves that define the surface cross-sections and one curve that defines a surface edge. The Segmented version breaks the rail at curvature kinks and sweeps each piece separately, then put the results together into a Brep.","since":"6.14","parameters":[{"name":"rail","summary":"Rail to sweep shapes along."},{"name":"shapes","summary":"Shape curves."},{"name":"closed","summary":"Only matters if shapes are closed."},{"name":"tolerance","summary":"Tolerance for fitting surface and rails."}],"returns":"Array of Brep sweep results."},{"signature":"static Brep[] CreateFromSweepSegmented(Curve rail, IEnumerable<Curve> shapes, Point3d startPoint, Point3d endPoint, SweepFrame frameType, Vector3d roadlikeNormal, bool closed, SweepBlend blendType, SweepMiter miterType, double tolerance, SweepRebuild rebuildType, int rebuildPointCount, double refitTolerance)","summary":"Sweep1 function that fits a surface through a series of profile curves that define the surface cross-sections and one curve that defines a surface edge. The Segmented version breaks the rail at curvature kinks and sweeps each piece separately, then put the results together into a Brep.","since":"7.0","parameters":[{"name":"rail","summary":"Rail to sweep shapes along."},{"name":"shapes","summary":"Shape curves."},{"name":"startPoint","summary":"Optional starting point of sweep. Use Point3d.Unset if you do not want to include a start point."},{"name":"endPoint","summary":"Optional ending point of sweep. Use Point3d.Unset if you do not want to include an end point."},{"name":"frameType","summary":"The frame type."},{"name":"roadlikeNormal","summary":"The roadlike normal directoion. Use Vector3d.Unset if the frame type is not set to roadlike."},{"name":"closed","summary":"Only matters if shapes are closed."},{"name":"blendType","summary":"The shape blending type."},{"name":"miterType","summary":"The mitering type."},{"name":"tolerance","summary":""},{"name":"rebuildType","summary":"The rebuild style."},{"name":"rebuildPointCount","summary":"If rebuild == SweepRebuild.Rebuild, the number of points. Otherwise specify 0."},{"name":"refitTolerance","summary":"If rebuild == SweepRebuild.Refit, the refit tolerance. Otherwise, specify 0.0"}],"returns":"Array of Brep sweep results."},{"signature":"static Brep[] CreateFromTaperedExtrude(Curve curveToExtrude, double distance, Vector3d direction, Point3d basePoint, double draftAngleRadians, ExtrudeCornerType cornerType)","summary":"Extrude a curve to a taper making a brep (potentially more than 1)","since":"5.1","deprecated":"6.0","parameters":[{"name":"curveToExtrude","summary":"the curve to extrude"},{"name":"distance","summary":"the distance to extrude"},{"name":"direction","summary":"the direction of the extrusion"},{"name":"basePoint","summary":"the base point of the extrusion"},{"name":"draftAngleRadians","summary":"angle of the extrusion"},{"name":"cornerType","summary":""}],"returns":"array of breps on success"},{"signature":"static Brep[] CreateFromTaperedExtrude(Curve curveToExtrude, double distance, Vector3d direction, Point3d basePoint, double draftAngleRadians, ExtrudeCornerType cornerType, double tolerance, double angleToleranceRadians)","summary":"Extrude a curve to a taper making a brep (potentially more than 1)","since":"6.0","parameters":[{"name":"curveToExtrude","summary":"the curve to extrude"},{"name":"distance","summary":"the distance to extrude"},{"name":"direction","summary":"the direction of the extrusion"},{"name":"basePoint","summary":"the base point of the extrusion"},{"name":"draftAngleRadians","summary":"angle of the extrusion"},{"name":"cornerType","summary":""},{"name":"tolerance","summary":"tolerance to use for the extrusion"},{"name":"angleToleranceRadians","summary":"angle tolerance to use for the extrusion"}],"returns":"array of breps on success"},{"signature":"static Brep[] CreateFromTaperedExtrudeWithRef(Curve curve, Vector3d direction, double distance, double draftAngle, Plane plane, double tolerance)","summary":"Creates one or more Breps by extruding a curve a distance along an axis with draft angle.","since":"6.14","parameters":[{"name":"curve","summary":"The curve to extrude."},{"name":"direction","summary":"The extrusion direction."},{"name":"distance","summary":"The extrusion distance."},{"name":"draftAngle","summary":"The extrusion draft angle in radians."},{"name":"plane","summary":"The end of the extrusion will be parallel to this plane, and \\"distance\\" from the plane\'s origin. The plane\'s origin is generally be a point on the curve. For planar curves, a natural choice for the plane\'s normal direction will be the normal direction of the curve\'s plane. In any case, plane.Normal = direction may make sense."},{"name":"tolerance","summary":"The intersecting and trimming tolerance."}],"returns":"An array of Breps if successful."},{"signature":"static Brep[] CreateOffsetBrep(Brep brep, double distance, bool solid, bool extend, double tolerance, out Brep[] outBlends, out Brep[] outWalls)","summary":"Offsets a Brep.","since":"6.0","parameters":[{"name":"brep","summary":"The Brep to offset."},{"name":"distance","summary":"The distance to offset. This is a signed distance value with respect to face normals and flipped faces."},{"name":"solid","summary":"If true, then the function makes a closed solid from the input and offset surfaces by lofting a ruled surface between all of the matching edges."},{"name":"extend","summary":"If true, then the function maintains the sharp corners when the original surfaces have sharps corner. If False, then the function creates fillets at sharp corners in the original surfaces."},{"name":"tolerance","summary":"The offset tolerance."},{"name":"outBlends","summary":"The results of the calculation."},{"name":"outWalls","summary":"The results of the calculation."}],"returns":"Array of Breps if successful. If the function succeeds in offsetting, a single Brep will be returned. Otherwise, the array will contain the offset surfaces, outBlends will contain the set of blends used to fill in gaps (if extend is false), and outWalls will contain the set of wall surfaces that was supposed to join the offset to the original (if solid is true)."},{"signature":"static Brep CreatePatch(IEnumerable<GeometryBase> geometry, int uSpans, int vSpans, double tolerance)","summary":"Constructs a brep patch.  \\nThis is the simple version of fit that uses a plane with u x v spans. It makes a plane by fitting to the points from the input geometry to use as the starting surface. The surface has the specified u and v span count.","since":"5.0","parameters":[{"name":"geometry","summary":"A combination of Curve, brep trims,  Point, PointCloudor Mesh. Curves and trims are sampled to get points. Trims are sampled for points and normals."},{"name":"uSpans","summary":"The number of spans in the U direction."},{"name":"vSpans","summary":"The number of spans in the V direction."},{"name":"tolerance","summary":"Tolerance used by input analysis functions for loop finding, trimming, etc."}],"returns":"A brep fit through input on success, or None on error."},{"signature":"static Brep CreatePatch(IEnumerable<GeometryBase> geometry, Surface startingSurface, double tolerance)","summary":"Constructs a brep patch.  \\nThis is the simple version of fit that uses a specified starting surface.","since":"5.0","parameters":[{"name":"geometry","summary":"Combination of Curves, BrepTrims, Points, PointClouds or Meshes. Curves and trims are sampled to get points. Trims are sampled for points and normals."},{"name":"startingSurface","summary":"A starting surface (can be null)."},{"name":"tolerance","summary":"Tolerance used by input analysis functions for loop finding, trimming, etc."}],"returns":"Brep fit through input on success, or None on error."},{"signature":"static Brep CreatePatch(IEnumerable<GeometryBase> geometry, Surface startingSurface, int uSpans, int vSpans, bool trim, bool tangency, double pointSpacing, double flexibility, double surfacePull, bool[] fixEdges, double tolerance)","summary":"Constructs a brep patch using all controls","since":"5.0","parameters":[{"name":"geometry","summary":"A combination of Curve, brep trims,  Point, PointCloudor Mesh. Curves and trims are sampled to get points. Trims are sampled for points and normals."},{"name":"startingSurface","summary":"A starting surface (can be null)."},{"name":"uSpans","summary":"Number of surface spans used when a plane is fit through points to start in the U direction."},{"name":"vSpans","summary":"Number of surface spans used when a plane is fit through points to start in the U direction."},{"name":"trim","summary":"If true, try to find an outer loop from among the input curves and trim the result to that loop"},{"name":"tangency","summary":"If true, try to find brep trims in the outer loop of curves and try to fit to the normal direction of the trim\'s surface at those locations."},{"name":"pointSpacing","summary":"Basic distance between points sampled from input curves."},{"name":"flexibility","summary":"Determines the behavior of the surface in areas where its not otherwise controlled by the input.  Lower numbers make the surface behave more like a stiff material; higher, less like a stiff material.  That is, each span is made to more closely match the spans adjacent to it if there is no input geometry mapping to that area of the surface when the flexibility value is low.  The scale is logarithmic. Numbers around 0.001 or 0.1 make the patch pretty stiff and numbers around 10 or 100 make the surface flexible."},{"name":"surfacePull","summary":"Tends to keep the result surface where it was before the fit in areas where there is on influence from the input geometry"},{"name":"fixEdges","summary":"Array of four elements. Flags to keep the edges of a starting (untrimmed) surface in place while fitting the interior of the surface.  Order of flags is left, bottom, right, top"},{"name":"tolerance","summary":"Tolerance used by input analysis functions for loop finding, trimming, etc."}],"returns":"A brep fit through input on success, or None on error."},{"signature":"static Brep[] CreatePipe(Curve rail, double radius, bool localBlending, PipeCapMode cap, bool fitRail, double absoluteTolerance, double angleToleranceRadians)","summary":"Creates a single walled pipe.","since":"5.0","parameters":[{"name":"rail","summary":"The rail, or path, curve."},{"name":"radius","summary":"The radius of the pipe."},{"name":"localBlending","summary":"The shape blending. If True, Local (pipe radius stays constant at the ends and changes more rapidly in the middle) is applied. If False, Global (radius is linearly blended from one end to the other, creating pipes that taper from one radius to the other) is applied."},{"name":"cap","summary":"The end cap mode."},{"name":"fitRail","summary":"If the curve is a polycurve of lines and arcs, the curve is fit and a single surface is created; otherwise the result is a Brep with joined surfaces created from the polycurve segments."},{"name":"absoluteTolerance","summary":"The sweeping and fitting tolerance. When in doubt, use the document\'s absolute tolerance."},{"name":"angleToleranceRadians","summary":"The angle tolerance. When in doubt, use the document\'s angle tolerance in radians."}],"returns":"Array of Breps success."},{"signature":"static Brep[] CreatePipe(Curve rail, IEnumerable<double> railRadiiParameters, IEnumerable<double> radii, bool localBlending, PipeCapMode cap, bool fitRail, double absoluteTolerance, double angleToleranceRadians)","summary":"Creates a single walled pipe.","since":"5.0","parameters":[{"name":"rail","summary":"The rail, or path, curve."},{"name":"railRadiiParameters","summary":"One or more normalized curve parameters where changes in radius occur. Important: curve parameters must be normalized - ranging between 0.0 and 1.0. Use Interval.NormalizedParameterAt to calculate these."},{"name":"radii","summary":"One or more radii - one at each normalized curve parameter in railRadiiParameters."},{"name":"localBlending","summary":"The shape blending. If True, Local (pipe radius stays constant at the ends and changes more rapidly in the middle) is applied. If False, Global (radius is linearly blended from one end to the other, creating pipes that taper from one radius to the other) is applied."},{"name":"cap","summary":"The end cap mode."},{"name":"fitRail","summary":"If the curve is a polycurve of lines and arcs, the curve is fit and a single surface is created; otherwise the result is a Brep with joined surfaces created from the polycurve segments."},{"name":"absoluteTolerance","summary":"The sweeping and fitting tolerance. When in doubt, use the document\'s absolute tolerance."},{"name":"angleToleranceRadians","summary":"The angle tolerance. When in doubt, use the document\'s angle tolerance in radians."}],"returns":"Array of Breps success."},{"signature":"static Brep[] CreatePlanarBreps(Curve inputLoop)","summary":"Constructs a set of planar breps as outlines by the loops.","since":"5.0","deprecated":"6.0","parameters":[{"name":"inputLoop","summary":"A curve that should form the boundaries of the surfaces or polysurfaces."}],"returns":"An array of Planar Breps."},{"signature":"static Brep[] CreatePlanarBreps(Curve inputLoop, double tolerance)","summary":"Constructs a set of planar breps as outlines by the loops.","since":"6.0","parameters":[{"name":"inputLoop","summary":"A curve that should form the boundaries of the surfaces or polysurfaces."},{"name":"tolerance","summary":""}],"returns":"An array of Planar Breps."},{"signature":"static Brep[] CreatePlanarBreps(CurveList inputLoops)","summary":"Constructs a set of planar Breps as outlines by the loops.","since":"5.0","deprecated":"6.0","parameters":[{"name":"inputLoops","summary":"Curve loops that delineate the planar boundaries."}],"returns":"An array of Planar Breps or None on error."},{"signature":"static Brep[] CreatePlanarBreps(CurveList inputLoops, double tolerance)","summary":"Constructs a set of planar Breps as outlines by the loops.","since":"6.0","parameters":[{"name":"inputLoops","summary":"Curve loops that delineate the planar boundaries."},{"name":"tolerance","summary":""}],"returns":"An array of Planar Breps."},{"signature":"static Brep[] CreatePlanarBreps(IEnumerable<Curve> inputLoops)","summary":"Constructs a set of planar breps as outlines by the loops.","since":"5.0","deprecated":"6.0","parameters":[{"name":"inputLoops","summary":"Curve loops that delineate the planar boundaries."}],"returns":"An array of Planar Breps."},{"signature":"static Brep[] CreatePlanarBreps(IEnumerable<Curve> inputLoops, double tolerance)","summary":"Constructs a set of planar breps as outlines by the loops.","since":"6.0","parameters":[{"name":"inputLoops","summary":"Curve loops that delineate the planar boundaries."},{"name":"tolerance","summary":""}],"returns":"An array of Planar Breps."},{"signature":"static Brep[] CreatePlanarDifference(Brep b0, Brep b1, Plane plane, double tolerance)","summary":"CreatePlanarDifference","since":"7.0","parameters":[{"name":"b0","summary":"The first brep to intersect."},{"name":"b1","summary":"The first brep to intersect."},{"name":"plane","summary":"The plane in which all the input breps lie"},{"name":"tolerance","summary":"Tolerance to use for Difference operation."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep[] CreatePlanarIntersection(Brep b0, Brep b1, Plane plane, double tolerance)","summary":"CreatePlanarIntersection","since":"7.0","parameters":[{"name":"b0","summary":"The first brep to intersect."},{"name":"b1","summary":"The first brep to intersect."},{"name":"plane","summary":"The plane in which all the input breps lie"},{"name":"tolerance","summary":"Tolerance to use for intersection operation."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep[] CreatePlanarUnion(Brep b0, Brep b1, Plane plane, double tolerance)","summary":"CreatePlanarUnion","since":"7.0","parameters":[{"name":"b0","summary":"The first brep to union."},{"name":"b1","summary":"The first brep to union."},{"name":"plane","summary":"The plane in which all the input breps lie"},{"name":"tolerance","summary":"Tolerance to use for union operation."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep[] CreatePlanarUnion(IEnumerable<Brep> breps, Plane plane, double tolerance)","summary":"CreatePlanarUnion","since":"7.0","parameters":[{"name":"breps","summary":"The planar regions on which to preform the union operation."},{"name":"plane","summary":"The plane in which all the input breps lie"},{"name":"tolerance","summary":"Tolerance to use for union operation."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep CreateQuadSphere(Sphere sphere)","summary":"Constructs a Brep definition of a quad sphere.","since":"6.0","parameters":[{"name":"sphere","summary":"The input sphere provides the orienting plane and radius."}],"returns":"A Brep if successful, None on error."},{"signature":"static Brep[] CreateShell(Brep brep, IEnumerable<int> facesToRemove, double distance, double tolerance)","summary":"Creates a hollowed out shell from a solid Brep. Function only operates on simple, solid, manifold Breps.","since":"5.4","parameters":[{"name":"brep","summary":"The solid Brep to shell."},{"name":"facesToRemove","summary":"The indices of the Brep faces to remove. These surfaces are removed and the remainder is offset inward, using the outer parts of the removed surfaces to join the inner and outer parts."},{"name":"distance","summary":"The distance, or thickness, for the shell. This is a signed distance value with respect to face normals and flipped faces."},{"name":"tolerance","summary":"The offset tolerance. When in doubt, use the document\'s absolute tolerance."}],"returns":"An array of Brep results or None on failure."},{"signature":"static Brep[] CreateSolid(IEnumerable<Brep> breps, double tolerance)","summary":"Constructs closed polysurfaces from surfaces and polysurfaces that bound a region in space.","since":"5.0","parameters":[{"name":"breps","summary":"The intersecting surfaces and polysurfaces to automatically trim and join into closed polysurfaces."},{"name":"tolerance","summary":"The trim and join tolerance. If set to RhinoMath.UnsetValue, Rhino\'s global absolute tolerance is used."}],"returns":"The resulting polysurfaces on success or None on failure."},{"signature":"static Brep[] CreateThickPipe(Curve rail, double radius0, double radius1, bool localBlending, PipeCapMode cap, bool fitRail, double absoluteTolerance, double angleToleranceRadians)","summary":"Creates a double-walled pipe.","since":"7.0","parameters":[{"name":"rail","summary":"The rail, or path, curve."},{"name":"radius0","summary":"The first radius of the pipe."},{"name":"radius1","summary":"The second radius of the pipe."},{"name":"localBlending","summary":"The shape blending. If True, Local (pipe radius stays constant at the ends and changes more rapidly in the middle) is applied. If False, Global (radius is linearly blended from one end to the other, creating pipes that taper from one radius to the other) is applied."},{"name":"cap","summary":"The end cap mode."},{"name":"fitRail","summary":"If the curve is a polycurve of lines and arcs, the curve is fit and a single surface is created; otherwise the result is a Brep with joined surfaces created from the polycurve segments."},{"name":"absoluteTolerance","summary":"The sweeping and fitting tolerance. When in doubt, use the document\'s absolute tolerance."},{"name":"angleToleranceRadians","summary":"The angle tolerance. When in doubt, use the document\'s angle tolerance in radians."}],"returns":"Array of Breps success."},{"signature":"static Brep[] CreateThickPipe(Curve rail, IEnumerable<double> railRadiiParameters, IEnumerable<double> radii0, IEnumerable<double> radii1, bool localBlending, PipeCapMode cap, bool fitRail, double absoluteTolerance, double angleToleranceRadians)","summary":"Creates a double-walled pipe.","since":"7.0","parameters":[{"name":"rail","summary":"The rail, or path, curve."},{"name":"railRadiiParameters","summary":"One or more normalized curve parameters where changes in radius occur. Important: curve parameters must be normalized - ranging between 0.0 and 1.0. Use Interval.NormalizedParameterAt to calculate these."},{"name":"radii0","summary":"One or more radii for the first wall - one at each normalized curve parameter in railRadiiParameters."},{"name":"radii1","summary":"One or more radii for the second wall - one at each normalized curve parameter in railRadiiParameters."},{"name":"localBlending","summary":"The shape blending. If True, Local (pipe radius stays constant at the ends and changes more rapidly in the middle) is applied. If False, Global (radius is linearly blended from one end to the other, creating pipes that taper from one radius to the other) is applied."},{"name":"cap","summary":"The end cap mode."},{"name":"fitRail","summary":"If the curve is a polycurve of lines and arcs, the curve is fit and a single surface is created; otherwise the result is a Brep with joined surfaces created from the polycurve segments."},{"name":"absoluteTolerance","summary":"The sweeping and fitting tolerance. When in doubt, use the document\'s absolute tolerance."},{"name":"angleToleranceRadians","summary":"The angle tolerance. When in doubt, use the document\'s angle tolerance in radians."}],"returns":"Array of Breps success."},{"signature":"static Brep CreateTrimmedPlane(Plane plane, Curve curve)","summary":"Create a Brep trimmed plane.","since":"6.0","parameters":[{"name":"plane","summary":"Plane that will be trimmed."},{"name":"curve","summary":"A simple (no self intersections) closed curve that defines the outer boundary of the trimmed plane."}],"returns":"Resulting brep or None on failure."},{"signature":"static Brep CreateTrimmedPlane(Plane plane, IEnumerable<Curve> curves)","summary":"Create a Brep trimmed plane.","since":"6.0","parameters":[{"name":"plane","summary":"Plane that will be trimmed."},{"name":"curves","summary":"A list of curves that form a simple (no self intersections) closed curve that defines the outer boundary of the trimmed plane."}],"returns":"Resulting brep or None on failure."},{"signature":"static Brep CreateTrimmedSurface(BrepFace trimSource, Surface surfaceSource)","summary":"Constructs a Brep using the trimming information of a brep face and a surface. Surface must be roughly the same shape and in the same location as the trimming brep face.","since":"5.0","deprecated":"6.0","parameters":[{"name":"trimSource","summary":"BrepFace which contains trimmingSource brep."},{"name":"surfaceSource","summary":"Surface that trims of BrepFace will be applied to."}],"returns":"A brep with the shape of surfaceSource and the trims of trimSource or None on failure."},{"signature":"static Brep CreateTrimmedSurface(BrepFace trimSource, Surface surfaceSource, double tolerance)","summary":"Constructs a Brep using the trimming information of a brep face and a surface. Surface must be roughly the same shape and in the same location as the trimming brep face.","since":"6.0","parameters":[{"name":"trimSource","summary":"BrepFace which contains trimmingSource brep."},{"name":"surfaceSource","summary":"Surface that trims of BrepFace will be applied to."},{"name":"tolerance","summary":""}],"returns":"A brep with the shape of surfaceSource and the trims of trimSource or None on failure."},{"signature":"static Brep[] JoinBreps(IEnumerable<Brep> brepsToJoin, double tolerance)","summary":"Joins the breps in the input array at any overlapping edges to form as few as possible resulting breps. There may be more than one brep in the result array.","since":"5.0","parameters":[{"name":"brepsToJoin","summary":"A list, an array or any enumerable set of breps to join."},{"name":"tolerance","summary":"3d distance tolerance for detecting overlapping edges."}],"returns":"new joined breps on success, None on failure."},{"signature":"static Brep MergeBreps(IEnumerable<Brep> brepsToMerge, double tolerance)","summary":"Combines two or more breps into one. A merge is like a boolean union that keeps the inside pieces. This function creates non-manifold Breps which in general are unusual in Rhino. You may want to consider using JoinBreps or CreateBooleanUnion functions instead.","since":"5.0","parameters":[{"name":"brepsToMerge","summary":"must contain more than one Brep."},{"name":"tolerance","summary":"the tolerance to use when merging."}],"returns":"Single merged Brep on success. Null on error."},{"signature":"static Brep MergeSurfaces(Brep brep0, Brep brep1, double tolerance, double angleToleranceRadians)","summary":"Merges two surfaces into one surface at untrimmed edges. Both surfaces must be untrimmed and share an edge.","since":"6.0","parameters":[{"name":"brep0","summary":"The first single-face Brep to merge."},{"name":"brep1","summary":"The second single-face Brep to merge."},{"name":"tolerance","summary":"Surface edges must be within this tolerance for the two surfaces to merge."},{"name":"angleToleranceRadians","summary":"Edge must be within this angle tolerance in order for contiguous edges to be combined into a single edge."}],"returns":"The merged Brep if successful, None if not successful."},{"signature":"static Brep MergeSurfaces(Brep brep0, Brep brep1, double tolerance, double angleToleranceRadians, Point2d point0, Point2d point1, double roundness, bool smooth)","summary":"Merges two surfaces into one surface at untrimmed edges. Both surfaces must be untrimmed and share an edge.","since":"6.0","parameters":[{"name":"brep0","summary":"The first single-face Brep to merge."},{"name":"brep1","summary":"The second single-face Brep to merge."},{"name":"tolerance","summary":"Surface edges must be within this tolerance for the two surfaces to merge."},{"name":"angleToleranceRadians","summary":"Edge must be within this angle tolerance in order for contiguous edges to be combined into a single edge."},{"name":"point0","summary":"2D pick point on the first single-face Brep. The value can be unset."},{"name":"point1","summary":"2D pick point on the second single-face Brep. The value can be unset."},{"name":"roundness","summary":"Defines the roundness of the merge. Acceptable values are between 0.0 (sharp) and 1.0 (smooth)."},{"name":"smooth","summary":"The surface will be smooth. This makes the surface behave better for control point editing, but may alter the shape of both surfaces."}],"returns":"The merged Brep if successful, None if not successful."},{"signature":"static Brep MergeSurfaces(Surface surface0, Surface surface1, double tolerance, double angleToleranceRadians)","summary":"Merges two surfaces into one surface at untrimmed edges.","since":"6.0","parameters":[{"name":"surface0","summary":"The first surface to merge."},{"name":"surface1","summary":"The second surface to merge."},{"name":"tolerance","summary":"Surface edges must be within this tolerance for the two surfaces to merge."},{"name":"angleToleranceRadians","summary":"Edge must be within this angle tolerance in order for contiguous edges to be combined into a single edge."}],"returns":"The merged surfaces as a Brep if successful, None if not successful."},{"signature":"static Brep TryConvertBrep(GeometryBase geometry)","summary":"Attempts to convert a generic Geometry object into a Brep.","since":"5.0","parameters":[{"name":"geometry","summary":"Geometry to convert, not all types of GeometryBase can be represented by BReps."}],"returns":"Brep if a brep form could be created or None if this is not possible. If geometry was of type Brep to begin with, the same object is returned, i.e. it is not duplicated."},{"signature":"int AddEdgeCurve(Curve curve)","summary":"Add a 3d curve used by the brep edges","since":"5.4","returns":"Index used to reference this geometry in the edge curve list"},{"signature":"int AddSurface(Surface surface)","summary":"Adds a 3D surface used by BrepFace.","since":"5.0","parameters":[{"name":"surface","summary":"A copy of the surface is added to this brep."}],"returns":"Index that should be used to reference the geometry.  \\n-1 is returned if the input is not acceptable."},{"signature":"int AddTrimCurve(Curve curve)","summary":"Add a 2d curve used by the brep trims","since":"5.4","returns":"Index used to reference this geometry in the trimming curve list"},{"signature":"void Append(Brep other)","summary":"Appends a copy of another brep to this and updates indices of appended brep parts.  Duplicates are not removed","since":"5.4"},{"signature":"Brep CapPlanarHoles(double tolerance)","summary":"Returns a new Brep that is equivalent to this Brep with all planar holes capped.","since":"5.0","parameters":[{"name":"tolerance","summary":"Tolerance to use for capping."}],"returns":"New brep on success. None on error."},{"signature":"Point3d ClosestPoint(Point3d testPoint)","summary":"Finds a point on the brep that is closest to testPoint.","since":"5.0","parameters":[{"name":"testPoint","summary":"Base point to project to brep."}],"returns":"The point on the Brep closest to testPoint or Point3d.Unset if the operation failed."},{"signature":"bool ClosestPoint(Point3d testPoint, out Point3d closestPoint, out ComponentIndex ci, out double s, out double t, double maximumDistance, out Vector3d normal)","summary":"Finds a point on a Brep that is closest to testPoint. The method searches all Brep faces looking for the one closest to testPoint. When found, if the closest point falls on the inactive region of the face, then the method finds the face\'s edge that is closest to testPoint.","since":"5.0","parameters":[{"name":"testPoint","summary":"base point to project to surface."},{"name":"closestPoint","summary":"location of the closest brep point."},{"name":"ci","summary":"Component index of the brep component that contains the closest point. Possible types are brep_face, brep_edge or brep_vertex."},{"name":"s","summary":"If the ci type is brep_edge, then s is the parameter of the closest edge point."},{"name":"t","summary":"If the ci type is brep_face, then (s,t) is the parameter of the closest edge point."},{"name":"maximumDistance","summary":"If maximumDistance > 0, then only points whose distance is <= maximumDistance will be returned. Using a positive value of maximumDistance can substantially speed up the search."},{"name":"normal","summary":"The normal to the face if ci is a brep_face and the tangent to the edge if ci is brep_edge."}],"returns":"True if the operation succeeded; otherwise, false."},{"signature":"void Compact()","summary":"Deletes any unreferenced objects from arrays, re-indexes as needed, and shrinks arrays to minimum required size. Uses CUllUnused* members to delete any unreferenced objects from arrays.","since":"5.0"},{"signature":"bool CullUnused2dCurves()","summary":"Culls 3d curves not referenced by an edge.","since":"5.0","returns":"True if operation succeeded; False otherwise."},{"signature":"bool CullUnused3dCurves()","summary":"Culls 2d curves not referenced by a trim.","since":"5.0","returns":"True if operation succeeded; False otherwise."},{"signature":"bool CullUnusedEdges()","summary":"Culls edges with m_edge_index == -1.","since":"5.0","returns":"True if operation succeeded; False otherwise."},{"signature":"bool CullUnusedFaces()","summary":"Culls faces with m_face_index == -1.","since":"5.0","returns":"True if operation succeeded; False otherwise."},{"signature":"bool CullUnusedLoops()","summary":"Culls loops with m_loop_index == -1.","since":"5.0","returns":"True if operation succeeded; False otherwise."},{"signature":"bool CullUnusedSurfaces()","summary":"Culls surfaces not referenced by a face.","since":"5.0","returns":"True if operation succeeded; False otherwise."},{"signature":"bool CullUnusedTrims()","summary":"Culls trims with m_trim_index == -1.","since":"5.0","returns":"True if operation succeeded; False otherwise."},{"signature":"bool CullUnusedVertices()","summary":"Culls vertices with m_vertex_index == -1.","since":"5.0","returns":"True if operation succeeded; False otherwise."},{"signature":"GeometryBase Duplicate()","summary":"Copies this brep.","since":"5.0","returns":"A brep."},{"signature":"Brep DuplicateBrep()","summary":"Same as Duplicate(), but already performs a cast to a brep.  \\nThis cast always succeeds.","since":"5.0","returns":"A brep."},{"signature":"Curve[] DuplicateEdgeCurves()","summary":"Duplicate all the edges of this Brep.","since":"5.0","returns":"An array of edge curves."},{"signature":"Curve[] DuplicateEdgeCurves(bool nakedOnly)","summary":"Duplicate edges of this Brep.","since":"5.0","parameters":[{"name":"nakedOnly","summary":"If true, then only the \\"naked\\" edges are duplicated. If false, then all edges are duplicated."}],"returns":"Array of edge curves on success."},{"signature":"Curve[] DuplicateNakedEdgeCurves(bool outer, bool inner)","summary":"Duplicate naked edges of this Brep","since":"5.7"},{"signature":"Brep DuplicateSubBrep(IEnumerable<int> faceIndices)","summary":"Copy a subset of this Brep into another Brep.","since":"5.0","parameters":[{"name":"faceIndices","summary":"array of face indices in this brep to copy. (If any values in faceIndices are out of range or if faceIndices contains duplicates, this function will return null.)"}],"returns":"A brep, or None on error."},{"signature":"Point3d[] DuplicateVertices()","summary":"Duplicate all the corner vertices of this Brep.","since":"5.0","returns":"An array or corner vertices."},{"signature":"void FindCoincidentBrepComponents(Point3d point, double tolerance, out int[] faces, out int[] edges, out int[] vertices)","summary":"Find the indices of all brep faces, edges and vertices that are within tolerance of a test-point.","since":"6.2","parameters":[{"name":"point","summary":"Test point."},{"name":"tolerance","summary":"Coincidence tolerance."},{"name":"faces","summary":"Array of BrepFace indices."},{"name":"edges","summary":"Array of BrepEdge indices."},{"name":"vertices","summary":"Array of BrepVertex indices."}]},{"signature":"void Flip()","summary":"Reverses entire brep orientation of all faces.","since":"5.0"},{"signature":"double GetArea()","summary":"Compute the Area of the Brep. If you want proper Area data with moments and error information, use the AreaMassProperties class.","since":"5.0","returns":"The area of the Brep."},{"signature":"double GetArea(double relativeTolerance, double absoluteTolerance)","summary":"Compute the Area of the Brep. If you want proper Area data with moments and error information, use the AreaMassProperties class.","since":"5.0","parameters":[{"name":"relativeTolerance","summary":"Relative tolerance to use for area calculation."},{"name":"absoluteTolerance","summary":"Absolute tolerance to use for area calculation."}],"returns":"The area of the Brep."},{"signature":"bool GetPointInside(double tolerance, out Point3d point)","summary":"Finds a point inside of a solid Brep.","since":"6.19","parameters":[{"name":"tolerance","summary":"Used for intersecting rays and is not necessarily related to the distance from the brep to the found point. When in doubt, use the document\'s model absolute tolerance."},{"name":"point","summary":"A point inside the solid Brep."}],"returns":"Returns False if the input is not solid and manifold, if the Brep\'s bounding box is less than 2.0 * tolerance wide, or if no point could be found due to ray shooting or other errors. Otherwise, True is returned."},{"signature":"BrepRegion[] GetRegions()","summary":"Gets an array containing all regions in this brep.","since":"5.0","returns":"An array of regions in this brep. This array can be empty, but not null."},{"signature":"double GetVolume()","summary":"Compute the Volume of the Brep. If you want proper Volume data with moments and error information, use the VolumeMassProperties class.","since":"5.0","returns":"The volume of the Brep."},{"signature":"double GetVolume(double relativeTolerance, double absoluteTolerance)","summary":"Compute the Volume of the Brep. If you want proper Volume data with moments and error information, use the VolumeMassProperties class.","since":"5.0","parameters":[{"name":"relativeTolerance","summary":"Relative tolerance to use for area calculation."},{"name":"absoluteTolerance","summary":"Absolute tolerance to use for area calculation."}],"returns":"The volume of the Brep."},{"signature":"Curve[] GetWireframe(int density)","summary":"Constructs all the Wireframe curves for this Brep.","since":"5.0","parameters":[{"name":"density","summary":"Wireframe density. Valid values range between -1 and 99."}],"returns":"An array of Wireframe curves or None on failure."},{"signature":"bool IsDuplicate(Brep other, double tolerance)","summary":"See if this and other are same brep geometry.","since":"5.0","parameters":[{"name":"other","summary":"other brep."},{"name":"tolerance","summary":"tolerance to use when comparing control points."}],"returns":"True if breps are the same."},{"signature":"bool IsPointInside(Point3d point, double tolerance, bool strictlyIn)","summary":"Determines if point is inside a Brep.  This question only makes sense when the brep is a closed and manifold.  This function does not check for closed or manifold, so result is not valid in those cases.  Intersects a line through point with brep, finds the intersection point Q closest to point, and looks at face normal at Q.  If the point Q is on an edge or the intersection is not transverse at Q, then another line is used.","since":"5.0","parameters":[{"name":"point","summary":"3d point to test."},{"name":"tolerance","summary":"3d distance tolerance used for intersection and determining strict inclusion. A good default is RhinoMath.SqrtEpsilon."},{"name":"strictlyIn","summary":"if true, point is in if inside brep by at least tolerance. if false, point is in if truly in or within tolerance of boundary."}],"returns":"True if point is in, False if not."},{"signature":"bool IsValidGeometry(out string log)","summary":"Expert user function that tests the brep to see if its geometry information is valid. The value of brep.IsValidTopology() must be True before brep.IsValidGeometry() can be safely called.","since":"5.0","parameters":[{"name":"log","summary":"If the brep geometry is not valid, then a brief description of the problem in English is assigned to this out parameter. The information is suitable for low-level debugging purposes by programmers and is not intended to be useful as a high level user interface tool. Otherwise, string.Empty."}],"returns":"A value that indicates whether the geometry is valid."},{"signature":"bool IsValidTolerancesAndFlags(out string log)","summary":"Expert user function that tests the brep to see if its tolerances and flags are valid.  The values of brep.IsValidTopology() and brep.IsValidGeometry() must be True before brep.IsValidTolerancesAndFlags() can be safely called.","since":"5.0","parameters":[{"name":"log","summary":"If the brep tolerance or flags are not valid, then a brief description of the problem in English is assigned to this out parameter. The information is suitable for low-level debugging purposes by programmers and is not intended to be useful as a high level user interface tool. Otherwise, string.Empty."}],"returns":"A value that indicates"},{"signature":"bool IsValidTopology(out string log)","summary":"Tests the brep to see if its topology information is valid.","since":"5.0","parameters":[{"name":"log","summary":"If the brep topology is not valid, then a brief English description of the problem is appended to the log.  The information appended to log is suitable for low-level debugging purposes by programmers and is not intended to be useful as a high level user interface tool."}],"returns":"True if the topology is valid; False otherwise."},{"signature":"bool Join(Brep otherBrep, double tolerance, bool compact)","summary":"If any edges of this brep overlap edges of otherBrep, merge a copy of otherBrep into this brep joining all edges that overlap within tolerance.","since":"5.0","parameters":[{"name":"otherBrep","summary":"Brep to be added to this brep."},{"name":"tolerance","summary":"3d distance tolerance for detecting overlapping edges."},{"name":"compact","summary":"if true, set brep flags and tolerances, remove unused faces and edges."}],"returns":"True if any edges were joined."},{"signature":"bool JoinEdges(int edgeIndex0, int edgeIndex1, double joinTolerance, bool compact)","summary":"Joins two naked edges, or edges that are coincident or close together.","since":"6.0","parameters":[{"name":"edgeIndex0","summary":"The first edge index."},{"name":"edgeIndex1","summary":"The second edge index."},{"name":"joinTolerance","summary":"The join tolerance."},{"name":"compact","summary":"If joining more than one edge pair and want the edge indices of subsequent pairs to remain valid, set to false. But then call Brep.Compact() on the final result."}],"returns":"True if successful, False otherwise."},{"signature":"int JoinNakedEdges(double tolerance)","summary":"Joins naked edge pairs within the same brep that overlap within tolerance.","since":"5.0","parameters":[{"name":"tolerance","summary":"The tolerance value."}],"returns":"number of joins made."},{"signature":"bool MakeValidForV2()","summary":"No support is available for this function.  \\nExpert user function that converts all geometry in Brep to NURB form.","since":"6.0"},{"signature":"bool MergeCoplanarFaces(double tolerance)","summary":"Merges adjacent coplanar faces into single faces.","since":"5.0","parameters":[{"name":"tolerance","summary":"Tolerance for determining when edges are adjacent. When in doubt, use the document\'s ModelAbsoluteTolerance property."}],"returns":"True if faces were merged, False if no faces were merged."},{"signature":"bool MergeCoplanarFaces(double tolerance, double angleTolerance)","summary":"Merges adjacent coplanar faces into single faces.","since":"6.10","parameters":[{"name":"tolerance","summary":"Tolerance for determining when edges are adjacent. When in doubt, use the document\'s ModelAbsoluteTolerance property."},{"name":"angleTolerance","summary":"Angle tolerance, in radians, for determining when faces are parallel. When in doubt, use the document\'s ModelAngleToleranceRadians property."}],"returns":"True if faces were merged, False if no faces were merged."},{"signature":"void RebuildTrimsForV2(BrepFace face, NurbsSurface nurbsSurface)","summary":"No support is available for this function.  \\nExpert user function used by MakeValidForV2 to convert trim curves from one surface to its NURBS form. After calling this function, you need to change the surface of the face to a NurbsSurface.","since":"5.0","parameters":[{"name":"face","summary":"Face whose underlying surface has a parameterization that is different from its NURBS form."},{"name":"nurbsSurface","summary":"NURBS form of the face\'s underlying surface."}]},{"signature":"bool RemoveFins()","summary":"Recursively removes any Brep face with a naked edge. This function is only useful for non-manifold Breps.","since":"7.0","returns":"True if successful, False if everything is removed or if the result has any Brep edges with more than two Brep trims."},{"signature":"Brep RemoveHoles(double tolerance)","summary":"Remove all inner loops, or holes, in a Brep.","since":"6.0","parameters":[{"name":"tolerance","summary":"The tolerance. When in doubt, use the document\'s model absolute tolerance."}],"returns":"The Brep without holes if successful, None otherwise."},{"signature":"Brep RemoveHoles(IEnumerable<ComponentIndex> loops, double tolerance)","summary":"Removes inner loops, or holes, in a Brep.","since":"6.8","parameters":[{"name":"loops","summary":"A list of BrepLoop component indexes, where BrepLoop.LoopType == Rhino.Geometry.BrepLoopType.Inner."},{"name":"tolerance","summary":"The tolerance. When in doubt, use the document\'s model absolute tolerance."}],"returns":"The Brep without holes if successful, None otherwise."},{"signature":"bool Repair(double tolerance)","summary":"Fills in missing or fixes incorrect component information from a Brep. Useful when reading Brep information from other file formats that do not provide as complete of a Brep definition as required by Rhino.","since":"6.0","parameters":[{"name":"tolerance","summary":"The repair tolerance. When in doubt, use the document\'s model absolute tolerance."}],"returns":"True on success."},{"signature":"void SetTolerancesBoxesAndFlags()","summary":"Set tolerances and flags in a Brep.","since":"6.0"},{"signature":"void SetTolerancesBoxesAndFlags(bool bLazy, bool bSetVertexTolerances, bool bSetEdgeTolerances, bool bSetTrimTolerances, bool bSetTrimIsoFlags, bool bSetTrimTypeFlags, bool bSetLoopTypeFlags, bool bSetTrimBoxes)","summary":"Set tolerances and flags in a Brep.","since":"6.0","parameters":[{"name":"bLazy","summary":"If true, only flags and tolerances that are not set will be calculated."},{"name":"bSetVertexTolerances","summary":"Set True to compute BrepVertex tolerances."},{"name":"bSetEdgeTolerances","summary":"Set True to compute BrepEdge tolerances."},{"name":"bSetTrimTolerances","summary":"Set True to compute BrepTrim tolerances."},{"name":"bSetTrimIsoFlags","summary":"Set True to compute BrepTrim.IsoStatus values."},{"name":"bSetTrimTypeFlags","summary":"Set True to compute BrepTrim.TrimType values."},{"name":"bSetLoopTypeFlags","summary":"Set True to compute BrepLoop.BrepLoopType values."},{"name":"bSetTrimBoxes","summary":"Set True to compute BrepTrim bounding boxes."}]},{"signature":"void SetTrimIsoFlags()","summary":"This function can be used to set the BrepTrim::m_iso flag. It is intended to be used when creating a Brep from a definition that does not include compatible parameter space type information.","since":"5.4"},{"signature":"void SetVertices()","summary":"This function can be used to compute vertex information for a b-rep when everything but the Vertices array is properly filled in. It is intended to be used when creating a Brep from a definition that does not include explicit vertex information.","since":"5.4"},{"signature":"Brep[] Split(Brep cutter, double intersectionTolerance)","summary":"Splits a Brep into pieces using a Brep as a cutter.","since":"5.0","parameters":[{"name":"cutter","summary":"The Brep to use as a cutter."},{"name":"intersectionTolerance","summary":"The tolerance with which to compute intersections."}],"returns":"A new array of Breps. This array can be empty."},{"signature":"Brep[] Split(Brep cutter, double intersectionTolerance, out bool toleranceWasRaised)","summary":"Splits a Brep into pieces using a Brep as a cutter.","since":"5.0","parameters":[{"name":"cutter","summary":"The Brep to use as a cutter."},{"name":"intersectionTolerance","summary":"The tolerance with which to compute intersections."},{"name":"toleranceWasRaised","summary":"Set to True if the split failed at intersectionTolerance but succeeded when the tolerance was increased to twice intersectionTolerance."}],"returns":"A new array of Breps. This array can be empty."},{"signature":"Brep[] Split(IEnumerable<Brep> cutters, double intersectionTolerance)","summary":"Splits a Brep into pieces using Breps as cutters.","since":"6.13","parameters":[{"name":"cutters","summary":"One or more Breps to use as cutters."},{"name":"intersectionTolerance","summary":"The tolerance with which to compute intersections."}],"returns":"A new array of Breps. This array can be empty."},{"signature":"Brep[] Split(IEnumerable<Curve> cutters, double intersectionTolerance)","summary":"Splits a Brep into pieces using curves, at least partially on the Brep, as cutters.","since":"6.13","parameters":[{"name":"cutters","summary":"The splitting curves. Only the portion of the curve on the Brep surface will be used for cutting."},{"name":"intersectionTolerance","summary":"The tolerance with which to compute intersections."}],"returns":"A new array of Breps. This array can be empty."},{"signature":"Brep[] Split(IEnumerable<GeometryBase> cutters, Vector3d normal, bool planView, double intersectionTolerance)","summary":"Splits a Brep into pieces using a combination of curves, to be extruded, and Breps as cutters.","since":"6.13","parameters":[{"name":"cutters","summary":"The curves, surfaces, faces and Breps to be used as cutters. Any other geometry is ignored."},{"name":"normal","summary":"A construction plane normal, used in deciding how to extrude a curve into a cutter."},{"name":"planView","summary":"Set True if the assume view is a plan, or parallel projection, view."},{"name":"intersectionTolerance","summary":"The tolerance with which to compute intersections."}],"returns":"A new array of Breps. This array can be empty."},{"signature":"void Standardize()","summary":"Standardizes all trims, edges, and faces in the brep. After standardizing, there may be unused curves and surfaces in the brep.  Call Brep.Compact to remove these unused curves and surfaces.","since":"5.0"},{"signature":"bool TransformComponent(IEnumerable<ComponentIndex> components, Transform xform, double tolerance, double timeLimit, bool useMultipleThreads)","summary":"Transform an array of Brep components, bend neighbors to match, and leave the rest fixed.","since":"6.0","parameters":[{"name":"components","summary":"The Brep components to transform."},{"name":"xform","summary":"The transformation to apply."},{"name":"tolerance","summary":"The desired fitting tolerance to use when bending faces that share edges with both fixed and transformed components."},{"name":"timeLimit","summary":"If the deformation is extreme, it can take a long time to calculate the result. If time_limit > 0, then the value specifies the maximum amount of time in seconds you want to spend before giving up."},{"name":"useMultipleThreads","summary":"True if multiple threads can be used."}],"returns":"True if successful, False otherwise."},{"signature":"Brep[] Trim(Brep cutter, double intersectionTolerance)","summary":"Trims a brep with an oriented cutter. The parts of the brep that lie inside (opposite the normal) of the cutter are retained while the parts to the outside (in the direction of the normal) are discarded.  If the Cutter is closed, then a connected component of the Brep that does not intersect the cutter is kept if and only if it is contained in the inside of cutter. That is the region bounded by cutter opposite from the normal of cutter, If cutter is not closed all these components are kept.","since":"5.0","parameters":[{"name":"cutter","summary":"A cutting brep."},{"name":"intersectionTolerance","summary":"A tolerance value with which to compute intersections."}],"returns":"This Brep is not modified, the trim results are returned in an array."},{"signature":"Brep[] Trim(Plane cutter, double intersectionTolerance)","summary":"Trims a Brep with an oriented cutter.  The parts of Brep that lie inside (opposite the normal) of the cutter are retained while the parts to the outside ( in the direction of the normal ) are discarded. A connected component of Brep that does not intersect the cutter is kept if and only if it is contained in the inside of Cutter.  That is the region bounded by cutter opposite from the normal of cutter, or in the case of a Plane cutter the half space opposite from the plane normal.","since":"5.0","parameters":[{"name":"cutter","summary":"A cutting plane."},{"name":"intersectionTolerance","summary":"A tolerance value with which to compute intersections."}],"returns":"This Brep is not modified, the trim results are returned in an array."},{"signature":"Brep[] UnjoinEdges(IEnumerable<int> edgesToUnjoin)","summary":"Un-joins, or separates, edges within the Brep. Note, seams in closed surfaces will not separate.","since":"6.0","parameters":[{"name":"edgesToUnjoin","summary":"The indices of the Brep edges to un-join."}],"returns":"This Brep is not modified, the trim results are returned in an array."}]},{"namespace":"Rhino.Geometry","name":"BrepEdge","dataType":"class","summary":"Represents a single edge curve in a Brep object.","baseclass":"Rhino.Geometry.CurveProxy","properties":[{"signature":"Brep Brep","summary":"Gets the Brep that owns this edge.","since":"5.0","property":["get"]},{"signature":"Curve EdgeCurve","summary":"Get the brep.Curves3D[] 3d curve geometry used by this edge or null.","since":"6.0","property":["get"]},{"signature":"int EdgeCurveIndex","summary":"Get the brep.Curves3D[] index of the 3d curve geometry used by this edge or -1.","since":"6.0","property":["get"]},{"signature":"int EdgeIndex","summary":"Gets the index of this edge in the Brep.Edges collection.","since":"5.0","property":["get"]},{"signature":"BrepVertex EndVertex","summary":"BrepVertex at end of edge","since":"5.10","property":["get"]},{"signature":"BrepVertex StartVertex","summary":"BrepVertex at start of edge","since":"5.10","property":["get"]},{"signature":"double Tolerance","summary":"Gets or sets the accuracy of the edge curve (>=0.0 or RhinoMath.UnsetValue) A value of UnsetValue indicates that the tolerance should be computed.  The maximum distance from the edge\'s 3d curve to any surface of a face that has this edge as a portion of its boundary must be <= this tolerance.","since":"5.0","property":["get","set"]},{"signature":"int TrimCount","summary":"Gets the number of trim-curves that use this edge.","since":"5.0","property":["get"]},{"signature":"EdgeAdjacency Valence","summary":"Gets the topological valency of this edge. The topological valency is defined by how many adjacent faces share this edge.","since":"5.0","property":["get"]}],"methods":[{"signature":"int[] AdjacentFaces()","summary":"Gets the indices of all the BrepFaces that use this edge.","since":"5.0"},{"signature":"Concavity ConcavityAt(double t, double tolerance)","summary":"Determine the concavity of this edge at a specific parameter.","since":"6.2","parameters":[{"name":"t","summary":"Edge curve parameter."},{"name":"tolerance","summary":"Angle tolerance for tangent faces."}],"returns":"Concavity measure at parameter."},{"signature":"bool GetEdgeParameter(int trimIndex, double trimParameter, out double edgeParameter)","summary":"Get corresponding edge parameter for given trim at given trim parameter.","since":"5.12","returns":"True on success"},{"signature":"bool IsSmoothManifoldEdge(double angleToleranceRadians)","summary":"For a manifold, non-boundary edge, decides whether or not the two surfaces on either side meet smoothly.","since":"5.0","parameters":[{"name":"angleToleranceRadians","summary":"used to decide if surface normals on either side are parallel."}],"returns":"True if edge is manifold, has exactly 2 trims, and surface normals on either side agree to within angle_tolerance."},{"signature":"bool SetEdgeCurve(int curve3dIndex)","summary":"Set 3d curve geometry used by a b-rep edge.","since":"5.4","parameters":[{"name":"curve3dIndex","summary":"index of 3d curve in m_C3[] array"}],"returns":"True if successful"},{"signature":"bool SetEdgeCurve(int curve3dIndex, Interval subDomain)","summary":"Set 3d curve geometry used by a b-rep edge.","since":"5.4","parameters":[{"name":"curve3dIndex","summary":"index of 3d curve in m_C3[] array"},{"name":"subDomain","summary":""}],"returns":"True if successful"},{"signature":"int[] TrimIndices()","summary":"Gets the indices of all trims associated with this edge.","since":"5.12","returns":"Empty array on failure."}]},{"namespace":"Rhino.Geometry","name":"BrepFace","dataType":"class","summary":"Provides strongly-typed access to brep faces.  \\nA Brep face is composed of one surface and trimming curves.","baseclass":"Rhino.Geometry.SurfaceProxy","properties":[{"signature":"Brep Brep","summary":"Gets the Brep that owns this face.","since":"6.9","property":["get"]},{"signature":"int FaceIndex","summary":"Index of face in Brep.Faces array.","since":"5.0","property":["get"]},{"signature":"bool IsSurface","summary":"Gets a value indicating whether the face is synonymous with the underlying surface. If a Face has no trimming curves then it is considered a Surface.","since":"5.0","property":["get"]},{"signature":"BrepLoopList Loops","summary":"Loops in this face.","since":"5.0","property":["get"]},{"signature":"int MaterialChannelIndex","summary":"This face\'s rendering material channel index.","since":"6.26","property":["get","set"]},{"signature":"bool OrientationIsReversed","summary":"True if face orientation is opposite of natural surface orientation.","since":"5.0","property":["get","set"]},{"signature":"BrepLoop OuterLoop","summary":"Every face has a single outer loop.","since":"5.0","property":["get"]},{"signature":"Color PerFaceColor","summary":"If per-face color is \\"Empty\\", then this face does not have a custom color","since":"7.0","property":["get","set"]},{"signature":"int SurfaceIndex","summary":"Surface index of the 3d surface geometry used by this face or -1","since":"5.6","property":["get"]}],"methods":[{"signature":"int[] AdjacentEdges()","summary":"Gets the indices of all the BrepEdges that delineate this Face.","since":"5.0"},{"signature":"int[] AdjacentFaces()","summary":"Gets the indices of all the BrepFaces that surround (are adjacent to) this face.","since":"5.0"},{"signature":"bool ChangeSurface(int surfaceIndex)","summary":"Expert user tool that replaces the 3d surface geometry use by the face.","since":"5.0","parameters":[{"name":"surfaceIndex","summary":"brep surface index of new surface."}],"returns":"True if successful."},{"signature":"void ClearMaterialChannelIndex()","summary":"Clear this face\'s rendering material channel index.","since":"6.26"},{"signature":"Brep CreateExtrusion(Curve pathCurve, bool cap)","summary":"Extrude a face in a Brep.","since":"5.3","parameters":[{"name":"pathCurve","summary":"The path to extrude along. Note, the direction of the extrusion will follow the direction of the curve."},{"name":"cap","summary":"If true, the extrusion is capped with a translation of the face being extruded"}],"returns":"A Brep on success or None on failure."},{"signature":"bool DraftAnglePoint(Point2d testPoint, double testAngle, Vector3d pullDirection, bool edge, out Point3d draftPoint, out double draftAngle)","summary":"Returns the surface draft angle and point at a parameter.","since":"6.0","parameters":[{"name":"testPoint","summary":"The u,v parameter on the face to evaluate."},{"name":"testAngle","summary":"The angle in radians to test."},{"name":"pullDirection","summary":"The pull direction."},{"name":"edge","summary":"Restricts the point placement to an edge."},{"name":"draftPoint","summary":"The draft angle point."},{"name":"draftAngle","summary":"The draft angle in radians."}],"returns":"True if successful, False otherwise."},{"signature":"Brep DuplicateFace(bool duplicateMeshes)","summary":"Duplicate a face from the brep to create new single face brep.","since":"5.0","parameters":[{"name":"duplicateMeshes","summary":"If true, shading meshes will be copied as well."}],"returns":"A new single-face brep synonymous with the current Face."},{"signature":"Surface DuplicateSurface()","summary":"Gets a copy to the untrimmed surface that this face is based on.","since":"5.0","returns":"A copy of this face\'s underlying surface."},{"signature":"Mesh GetMesh(MeshType meshType)","summary":"Obtains a reference to a specified type of mesh for this brep face.","since":"5.0","parameters":[{"name":"meshType","summary":"The mesh type."}],"returns":"A mesh."},{"signature":"PointFaceRelation IsPointOnFace(double u, double v)","summary":"Tests if a parameter space point is in the active region of a face.","since":"5.0","parameters":[{"name":"u","summary":"Parameter space point U value."},{"name":"v","summary":"Parameter space point V value."}],"returns":"A value describing the relationship between the point and the face."},{"signature":"PointFaceRelation IsPointOnFace(double u, double v, double tolerance)","summary":"Tests if a parameter space point is in the active region of a face.","since":"7.0","parameters":[{"name":"u","summary":"Parameter space point U value."},{"name":"v","summary":"Parameter space point V value."},{"name":"tolerance","summary":"3D tolerance used when checking to see if the point is on a face or inside of a loop."}],"returns":"A value describing the relationship between the point and the face."},{"signature":"Point3d[] PullPointsToFace(IEnumerable<Point3d> points, double tolerance)","summary":"Pulls one or more points to a brep face.","since":"5.0","parameters":[{"name":"points","summary":"Points to pull."},{"name":"tolerance","summary":"Tolerance for pulling operation. Only points that are closer than tolerance will be pulled to the face."}],"returns":"An array of pulled points."},{"signature":"bool RebuildEdges(double tolerance, bool rebuildSharedEdges, bool rebuildVertices)","summary":"Rebuild the edges used by a face so they lie on the surface.","since":"5.0","parameters":[{"name":"tolerance","summary":"tolerance for fitting 3d edge curves."},{"name":"rebuildSharedEdges","summary":"if False and edge is used by this face and a neighbor, then the edge will be skipped."},{"name":"rebuildVertices","summary":"if true, vertex locations are updated to lie on the surface."}],"returns":"True on success."},{"signature":"Surface[] RefitTrim(BrepEdge edge, IEnumerable<double> knots, double tolerance, bool bSections, ref double fitQuality)","since":"7.0"},{"signature":"Brep RemoveHoles(double tolerance)","summary":"Remove all inner loops, or holes, from a Brep face.","since":"6.0"},{"signature":"bool SetDomain(int direction, Interval domain)","summary":"Sets the surface domain of this face.","since":"5.0","parameters":[{"name":"direction","summary":"Direction of face to set (0 = U, 1 = V)."},{"name":"domain","summary":"Domain to apply."}],"returns":"True on success, False on failure."},{"signature":"bool SetMesh(MeshType meshType, Mesh mesh)","summary":"Sets a reference to a specified type of mesh for this brep face.","since":"5.0","parameters":[{"name":"meshType","summary":"The mesh type."},{"name":"mesh","summary":"The new mesh."}],"returns":"True if the operation succeeded; otherwise false."},{"signature":"bool ShrinkFace(ShrinkDisableSide disableSide)","summary":"Shrinks the underlying untrimmed surface of this Brep face close to trimming boundaries. Shrinking a surface is like extending smoothly, only backwards. knot of full multiplicity are added where you want the surface to be cut off. Then the remaining control points are thrown away.","since":"6.0","parameters":[{"name":"disableSide","summary":"The side(s) of the surface to not shrink."}],"returns":"True on success, False on failure."},{"signature":"bool ShrinkSurfaceToEdge()","summary":"Shrinks the underlying untrimmed surface of this Brep face right to the trimming boundaries. Note, shrinking the trimmed surface can sometimes cause problems later since having the edges so close to the trimming boundaries can cause commands that use the surface edges as input to fail.","since":"6.16","returns":"True on success, False on failure."},{"signature":"Brep Split(IEnumerable<Curve> curves, double tolerance)","summary":"Split this face using 3D trimming curves.","since":"5.0","parameters":[{"name":"curves","summary":"Curves to split with."},{"name":"tolerance","summary":"Tolerance for splitting, when in doubt use the Document Absolute Tolerance."}],"returns":"A brep consisting of all the split fragments, or None on failure."},{"signature":"Curve[] TrimAwareIsoCurve(int direction, double constantParameter)","summary":"Similar to IsoCurve function, except this function pays attention to trims on faces and may return multiple curves.","since":"5.0","parameters":[{"name":"direction","summary":"Direction of isocurve.  \\n0 = Isocurve connects all points with a constant U value.  \\n1 = Isocurve connects all points with a constant V value."},{"name":"constantParameter","summary":"Surface parameter that remains identical along the isocurves."}],"returns":"Isoparametric curves connecting all points with the constantParameter value."},{"signature":"Interval[] TrimAwareIsoIntervals(int direction, double constantParameter)","summary":"Gets intervals where the iso curve exists on a BrepFace (trimmed surface)","since":"5.0","parameters":[{"name":"direction","summary":"Direction of isocurve.  \\n0 = Isocurve connects all points with a constant U value.  \\n1 = Isocurve connects all points with a constant V value."},{"name":"constantParameter","summary":"Surface parameter that remains identical along the isocurves."}],"returns":"If direction = 0, the parameter space iso interval connects the 2d points (intervals[i][0],iso_constant) and (intervals[i][1],iso_constant). If direction = 1, the parameter space iso interval connects the 2d points (iso_constant,intervals[i][0]) and (iso_constant,intervals[i][1])."},{"signature":"Surface UnderlyingSurface()","summary":"Gets the untrimmed surface that is the base of this face.","since":"5.0","returns":"A surface, or None on error."}]},{"namespace":"Rhino.Geometry","name":"BrepFace.ShrinkDisableSide","dataType":"enum","summary":"Defines bitwise mask flags indicating what side of a surface to not shrink.","since":"6.0","values":[{"signature":"ShrinkAllSides = 0x0000","summary":"Shrink on all four sides."},{"signature":"DoNotShrinkWestSide = 0x0001","summary":"Do not shrink on the west side of domain."},{"signature":"DoNotShrinkSouthSide = 0x0002","summary":"Do not shrink on the south side of domain."},{"signature":"DoNotShrinkEastSide = 0x0004","summary":"Do not shrink on the east side of domain."},{"signature":"DoNotShrinkNorthSide = 0x0008","summary":"Do not shrink on the north side of domain."}]},{"namespace":"Rhino.Geometry","name":"BrepLoop","dataType":"class","summary":"Represent a single loop in a Brep object. A loop is composed of a list of trim curves.","baseclass":"Rhino.Geometry.GeometryBase","properties":[{"signature":"Brep Brep","summary":"Gets the Brep that owns this loop.","since":"5.0","property":["get"]},{"signature":"BrepFace Face","summary":"BrepFace this loop belongs to.","since":"5.0","property":["get"]},{"signature":"int LoopIndex","summary":"Gets the index of this loop in the Brep.Loops collection.","since":"5.0","property":["get"]},{"signature":"BrepLoopType LoopType","summary":"type of loop.","since":"5.0","property":["get"]},{"signature":"BrepTrimList Trims","summary":"List of trims for this loop","since":"5.1","property":["get"]}],"methods":[{"signature":"Curve To2dCurve()","summary":"Create a 2d curve that traces the entire loop","since":"5.1"},{"signature":"Curve To3dCurve()","summary":"Create a 3D curve that approximates the loop geometry.","since":"5.0","returns":"A 3D curve that approximates the loop or None on failure."}]},{"namespace":"Rhino.Geometry","name":"BrepLoopType","dataType":"enum","summary":"Each brep loop has a defined type, e.g. outer, inner or point on surface.","since":"5.0","values":[{"signature":"Unknown = 0","summary":"Unknown loop type."},{"signature":"Outer = 1","summary":"2d loop curves form a simple closed curve with a counterclockwise orientation."},{"signature":"Inner = 2","summary":"2d loop curves form a simple closed curve with a clockwise orientation."},{"signature":"Slit = 3","summary":"Always closed - used internally during splitting operations."},{"signature":"CurveOnSurface = 4","summary":"\\"loop\\" is a curve-on-surface made from a single (open or closed) trim that has type TrimType.CurveOnSurface."},{"signature":"PointOnSurface = 5","summary":"\\"loop\\" is a PointOnSurface made from a single trim that has type TrimType.PointOnSurface."}]},{"namespace":"Rhino.Geometry","name":"BrepRegion","dataType":"class","summary":"Represents a brep topological region that has sides.","baseclass":"Rhino.Runtime.CommonObject","properties":[{"signature":"BoundingBox BoundingBox","summary":"Gets the region bounding box.","since":"5.0","property":["get"]},{"signature":"Brep Brep","summary":"Gets a reference to the Brep this region belongs to.","since":"5.0","property":["get"]},{"signature":"int Index","summary":"Gets the index of region in the RegionTopology array.","since":"5.0","property":["get"]},{"signature":"bool IsFinite","summary":"Gets a value indicating whether this region is finite.","since":"5.0","property":["get"]}],"methods":[{"signature":"Brep BoundaryBrep()","summary":"Gets the boundary of a region as a brep object. If the region is finite, the boundary will be a closed  manifold brep. The boundary may have more than one connected component.","since":"5.0","returns":"A brep or None on error."},{"signature":"BrepRegionFaceSide[] GetFaceSides()","summary":"Gets an array of BrepRegionFaceSideentities delimiting this region.","since":"5.0","returns":"An array of region face sides. This array might be empty on failure."}]},{"namespace":"Rhino.Geometry","name":"BrepRegionFaceSide","dataType":"class","summary":"Represents a side of a BrepRegionentity.","baseclass":"Rhino.Runtime.CommonObject","properties":[{"signature":"Brep Brep","summary":"The brep this side belongs to.","since":"5.0","property":["get"]},{"signature":"BrepFace Face","summary":"Gets the face this side belongs to.","since":"5.0","property":["get"]},{"signature":"BrepRegion Region","summary":"The region this side belongs to.","since":"5.0","property":["get"]},{"signature":"bool SurfaceNormalPointsIntoRegion","summary":"Gets True if BrepFace\'s surface normal points into region; False otherwise.","since":"5.0","property":["get"]}]},{"namespace":"Rhino.Geometry","name":"BrepSolidOrientation","dataType":"enum","summary":"Enumerates all possible Solid Orientations for a Brep.","since":"5.0","values":[{"signature":"None = 0","summary":"Brep is not a Solid."},{"signature":"Inward = -1","summary":"Brep is a Solid with inward facing normals."},{"signature":"Outward = 1","summary":"Brep is a Solid with outward facing normals."},{"signature":"Unknown = 2","summary":"Breps is a Solid but no orientation could be computed."}]},{"namespace":"Rhino.Geometry","name":"BrepTrim","dataType":"class","summary":"Brep trim information is stored in BrepTrim classes. Brep.Trims is an array of all the trims in the brep. A BrepTrim is derived from CurveProxy so the trim can supply easy to use evaluation tools via the Curve virtual member functions. Note well that the domains and orientations of the curve m_C2[trim.m_c2i] and the trim as a curve may not agree.","baseclass":"Rhino.Geometry.CurveProxy","properties":[{"signature":"Brep Brep","summary":"Gets the Brep that owns this trim.","since":"5.1","property":["get"]},{"signature":"BrepEdge Edge","summary":"Brep edge this trim belongs to. This will be None for singular trims","since":"5.1","property":["get"]},{"signature":"BrepVertex EndVertex","summary":"BrepVertex at end of trim","since":"6.0","property":["get"]},{"signature":"BrepFace Face","summary":"Brep face this trim belongs to","since":"5.1","property":["get"]},{"signature":"IsoStatus IsoStatus","since":"5.6","property":["get","set"]},{"signature":"BrepLoop Loop","summary":"Loop that this trim belongs to","since":"5.1","property":["get"]},{"signature":"BrepVertex StartVertex","summary":"BrepVertex at start of trim","since":"6.0","property":["get"]},{"signature":"Curve TrimCurve","summary":"Gets the Brep.Curves2D 2d curve geometry used by this trim, or null.","since":"6.0","property":["get"]},{"signature":"int TrimCurveIndex","summary":"Gets the Brep.Curves2D 2d curve index of the 2d curve geometry used by this trim, or -1.","since":"6.0","property":["get"]},{"signature":"int TrimIndex","summary":"Gets the index of this trim in the Brep.Trims collection.","since":"5.1","property":["get"]},{"signature":"BrepTrimType TrimType","summary":"Type of trim","since":"5.1","property":["get","set"]}],"methods":[{"signature":"void GetTolerances(out double toleranceU, out double toleranceV)","summary":"The values in tolerance[] record the accuracy of the parameter space trimming curves.","since":"5.6"},{"signature":"bool GetTrimParameter(double edgeParameter, out double trimParameter)","summary":"Get corresponding trim parameter at given edge parameter.","since":"5.12","returns":"True on success"},{"signature":"bool IsReversed()","summary":"Get orientation of trim with respect to it\'s corresponding edge.","since":"5.12","returns":"True if the 2d trim and 3d edge have opposite orientations"},{"signature":"void SetTolerances(double toleranceU, double toleranceV)","summary":"The values in tolerance[] record the accuracy of the parameter space trimming curves.","since":"5.6"},{"signature":"bool SetTrimCurve(int curve2dIndex)","summary":"Set 2d curve geometry used by a b-rep trim.","since":"5.4","parameters":[{"name":"curve2dIndex","summary":"index of 2d curve in m_C2[] array"}],"returns":"True if successful"},{"signature":"bool SetTrimCurve(int curve2dIndex, Interval subDomain)","summary":"Set 2d curve geometry used by a b-rep trim.","since":"5.4","parameters":[{"name":"curve2dIndex","summary":"index of 2d curve in m_C2[] array"},{"name":"subDomain","summary":""}],"returns":"True if successful"}]},{"namespace":"Rhino.Geometry","name":"BrepTrimType","dataType":"enum","summary":"Each brep trim has a defined type.","since":"5.1","values":[{"signature":"Unknown = 0","summary":"Unknown type"},{"signature":"Boundary = 1","summary":"Trim is connected to an edge, is part of an outer, inner or slit loop, and is the only trim connected to the edge."},{"signature":"Mated = 2","summary":"Trim is connected to an edge, is part of an outer, inner or slit loop, no other trim from the same loop is connected to the edge, and at least one trim from a different loop is connected to the edge."},{"signature":"Seam = 3","summary":"trim is connected to an edge, is part of an outer, inner or slit loop, and one other trim from the same loop is connected to the edge. (There can be other mated trims that are also connected to the edge. For example, the non-manifold edge that results when a surface edge lies in the middle of another surface.)  Non-manifold \\"cuts\\" have seam trims too."},{"signature":"Singular = 4","summary":"Trim is part of an outer loop, the trim\'s 2d curve runs along the singular side of a surface, and the trim is NOT connected to an edge. (There is no 3d edge because the surface side is singular.)"},{"signature":"CurveOnSurface = 5","summary":"Trim is connected to an edge, is the only trim in a curve-on-surface loop, and is the only trim connected to the edge."},{"signature":"PointOnSurface = 6","summary":"Trim is a point on a surface, trim.m_pbox is records surface parameters, and is the only trim in a point-on-surface loop.  This trim is not connected to an edge and has no 2d curve."},{"signature":"Slit = 7"}]},{"namespace":"Rhino.Geometry","name":"BrepVertex","dataType":"class","summary":"Brep vertex information","baseclass":"Rhino.Geometry.Point","properties":[{"signature":"Brep Brep","summary":"Gets the Brep that owns this vertex.","since":"5.4","property":["get"]},{"signature":"int VertexIndex","summary":"Gets the index of this vertex in the Brep.Vertices collection.","since":"5.4","property":["get"]}],"methods":[{"signature":"int[] EdgeIndices()","summary":"Gets the indices of all edges associated with this vertex.","since":"5.12","returns":"Empty array on failure."}]},{"namespace":"Rhino.Geometry","name":"Centermark","dataType":"class","summary":"Represents a center mark","baseclass":"Rhino.Geometry.Dimension","constructors":[{"signature":"Centermark()","since":"6.0"}],"methods":[{"signature":"static Centermark Create(DimensionStyle dimStyle, Plane plane, Point3d centerpoint, double radius)","summary":"Create a new center mark","since":"6.0","parameters":[{"name":"dimStyle","summary":"Dimension\'s AnnotationStyle"},{"name":"plane","summary":"Dimension\'s plane"},{"name":"centerpoint","summary":"Dimension\'s center point"},{"name":"radius","summary":"Center mark\'s radius"}]}]},{"namespace":"Rhino.Geometry","name":"Circle","dataType":"struct","summary":"Represents a circle in 3D.  \\nThe values used are a radius and an orthonormal frame of the plane containing the circle, with origin at the center.  \\nThe circle is parameterized by radians from 0 to 2 Pi given by  \\nt -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis  \\nwhere center, xaxis and yaxis define the orthonormal frame of the circle plane.","remarks":">An IsValid circle has positive radius and an IsValid plane defining the frame.","constructors":[{"signature":"Circle(Arc arc)","summary":"Initializes a circle from an arc.","since":"5.0","parameters":[{"name":"arc","summary":"Arc that defines the plane and radius."}]},{"signature":"Circle(double radius)","summary":"Initializes a circle with center (0,0,0) in the world XY plane.","since":"5.0","parameters":[{"name":"radius","summary":"Radius of circle, should be a positive number."}]},{"signature":"Circle(Plane plane, double radius)","summary":"Initializes a circle on a plane with a given radius.","since":"5.0","parameters":[{"name":"plane","summary":"Plane of circle. Plane origin defines the center of the circle."},{"name":"radius","summary":"Radius of circle (should be a positive value)."}]},{"signature":"Circle(Plane plane, Point3d center, double radius)","summary":"Initializes a circle parallel to a given plane with given center and radius.","since":"5.0","parameters":[{"name":"plane","summary":"Plane for circle."},{"name":"center","summary":"Center point override."},{"name":"radius","summary":"Radius of circle (should be a positive value)."}]},{"signature":"Circle(Point3d center, double radius)","summary":"Initializes a circle parallel to the world XY plane with given center and radius.","since":"5.0","parameters":[{"name":"center","summary":"Center of circle."},{"name":"radius","summary":"Radius of circle (should be a positive value)."}]},{"signature":"Circle(Point3d point1, Point3d point2, Point3d point3)","summary":"Initializes a circle through three 3d points.","since":"5.0","parameters":[{"name":"point1","summary":"The start/end of the circle is at point1."},{"name":"point2","summary":"Second point on the circle."},{"name":"point3","summary":"Third point on the circle."}]},{"signature":"Circle(Point3d startPoint, Vector3d tangentAtP, Point3d pointOnCircle)","summary":"Initializes a circle from two 3d points and a tangent at the first point. The start/end of the circle is at point \\"startPoint\\".","since":"5.0","parameters":[{"name":"startPoint","summary":"Start point of circle."},{"name":"tangentAtP","summary":"Tangent vector at start."},{"name":"pointOnCircle","summary":"Point coincident with desired circle."}]}],"properties":[{"signature":"static Circle Unset","summary":"Gets a circle with Unset components.","since":"5.0","property":["get"]},{"signature":"BoundingBox BoundingBox","summary":"Gets the circle\'s 3d axis aligned bounding box.","since":"5.0","property":["get"]},{"signature":"Point3d Center","summary":"Gets or sets the center point of this circle.","since":"5.0","property":["get","set"]},{"signature":"double Circumference","summary":"Gets or sets the circumference of this circle.","since":"5.0","property":["get","set"]},{"signature":"double Diameter","summary":"Gets or sets the diameter (radius * 2.0) of this circle. Diameters should be positive values.","since":"5.0","property":["get","set"]},{"signature":"bool IsValid","summary":"A valid circle has radius larger than 0.0 and a base plane which is must also be valid.","since":"5.0","property":["get"]},{"signature":"Vector3d Normal","summary":"Gets the normal vector for this circle.","since":"5.0","property":["get"]},{"signature":"Plane Plane","summary":"Gets or sets the plane of the circle.","since":"5.0","property":["get","set"]},{"signature":"double Radius","summary":"Gets or sets the radius of this circle. Radii should be positive values.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static bool TryFitCircleToPoints(IEnumerable<Point3d> points, out Circle circle)","summary":"Attempt to fit a circle through a set of points.","since":"6.2","parameters":[{"name":"points","summary":"The points through which to fit."},{"name":"circle","summary":"The resulting circle on success."}],"returns":"True on success, False on failure."},{"signature":"static Circle TryFitCircleTT(Curve c1, Curve c2, double t1, double t2)","summary":"Try to fit a circle to two curves using tangent relationships.","since":"5.0","parameters":[{"name":"c1","summary":"First curve to touch."},{"name":"c2","summary":"Second curve to touch."},{"name":"t1","summary":"Parameter on first curve close to desired solution."},{"name":"t2","summary":"Parameter on second curve closet to desired solution."}],"returns":"Valid circle on success, Circle.Unset on failure."},{"signature":"static Circle TryFitCircleTTT(Curve c1, Curve c2, Curve c3, double t1, double t2, double t3)","summary":"Try to fit a circle to three curves using tangent relationships.","since":"5.0","parameters":[{"name":"c1","summary":"First curve to touch."},{"name":"c2","summary":"Second curve to touch."},{"name":"c3","summary":"Third curve to touch."},{"name":"t1","summary":"Parameter on first curve close to desired solution."},{"name":"t2","summary":"Parameter on second curve closet to desired solution."},{"name":"t3","summary":"Parameter on third curve close to desired solution."}],"returns":"Valid circle on success, Circle.Unset on failure."},{"signature":"bool ClosestParameter(Point3d testPoint, out double t)","summary":"Gets the parameter on the circle which is closest to a test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to project onto the circle."},{"name":"t","summary":"Parameter on circle closes to testPoint."}],"returns":"True on success, False on failure."},{"signature":"Point3d ClosestPoint(Point3d testPoint)","summary":"Gets the point on the circle which is closest to a test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to project onto the circle."}],"returns":"The point on the circle that is closest to testPoint or Point3d.Unset on failure."},{"signature":"Vector3d DerivativeAt(int derivative, double t)","summary":"Determines the value of the Nth derivative at a parameter.","since":"5.0","parameters":[{"name":"derivative","summary":"Which order of derivative is wanted."},{"name":"t","summary":"Parameter to evaluate derivative. Valid values are 0, 1, 2 and 3."}],"returns":"The derivative of the circle at the given parameter."},{"signature":"bool EpsilonEquals(Circle other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool IsInPlane(Plane plane, double tolerance)","summary":"Evaluates whether or not this circle is co-planar with a given plane.","since":"5.0","parameters":[{"name":"plane","summary":"Plane."},{"name":"tolerance","summary":"Tolerance to use."}],"returns":"True if the circle plane is co-planar with the given plane within tolerance."},{"signature":"Point3d PointAt(double t)","summary":"Circles use trigonometric parameterization: t -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis.","since":"5.0","parameters":[{"name":"t","summary":"Parameter of point to evaluate."}],"returns":"The point on the circle at the given parameter."},{"signature":"void Reverse()","summary":"Reverse the orientation of the circle. Changes the domain from [a,b] to [-b,-a].","since":"5.0"},{"signature":"bool Rotate(double sinAngle, double cosAngle, Vector3d axis)","summary":"Rotates the circle around an axis that starts at the base plane origin.","since":"5.0","parameters":[{"name":"sinAngle","summary":"The value returned by Math.Sin(angle) to compose the rotation."},{"name":"cosAngle","summary":"The value returned by Math.Cos(angle) to compose the rotation."},{"name":"axis","summary":"A rotation axis."}],"returns":"True on success, False on failure."},{"signature":"bool Rotate(double sinAngle, double cosAngle, Vector3d axis, Point3d point)","summary":"Rotates the circle around an axis that starts at the provided point.","since":"5.0","parameters":[{"name":"sinAngle","summary":"The value returned by Math.Sin(angle) to compose the rotation."},{"name":"cosAngle","summary":"The value returned by Math.Cos(angle) to compose the rotation."},{"name":"axis","summary":"A rotation direction."},{"name":"point","summary":"A rotation base point."}],"returns":"True on success, False on failure."},{"signature":"bool Rotate(double angle, Vector3d axis)","summary":"Rotates the circle through a given angle.","since":"5.0","parameters":[{"name":"angle","summary":"Angle (in radians) of the rotation."},{"name":"axis","summary":"Rotation axis."}],"returns":"True on success, False on failure."},{"signature":"bool Rotate(double angle, Vector3d axis, Point3d point)","summary":"Rotates the circle through a given angle.","since":"5.0","parameters":[{"name":"angle","summary":"Angle (in radians) of the rotation."},{"name":"axis","summary":"Rotation axis."},{"name":"point","summary":"Rotation anchor point."}],"returns":"True on success, False on failure."},{"signature":"Vector3d TangentAt(double t)","summary":"Circles use trigonometric parameterization: t -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis.","since":"5.0","parameters":[{"name":"t","summary":"Parameter of tangent to evaluate."}],"returns":"The tangent at the circle at the given parameter."},{"signature":"NurbsCurve ToNurbsCurve()","summary":"Constructs a nurbs curve representation of this circle. This amounts to the same as calling NurbsCurve.CreateFromCircle().","since":"5.0","returns":"A nurbs curve representation of this circle or None if no such representation could be made."},{"signature":"NurbsCurve ToNurbsCurve(int degree, int cvCount)","summary":"Create a uniform non-rational cubic NURBS approximation of a circle.","since":"6.0","parameters":[{"name":"degree","summary":">=1"},{"name":"cvCount","summary":"cv count >=5"}],"returns":"NURBS curve approximation of a circle on success"},{"signature":"bool Transform(Transform xform)","summary":"Transforms this circle using an transformation matrix.","since":"5.0","parameters":[{"name":"xform","summary":"Transformation to apply."}],"returns":"True on success, False on failure."},{"signature":"bool Translate(Vector3d delta)","summary":"Moves the circle.","since":"5.0","parameters":[{"name":"delta","summary":"Translation vector."}],"returns":"True on success, False on failure."}]},{"namespace":"Rhino.Geometry","name":"ClippingPlaneSurface","dataType":"class","summary":"Represents a planar surface that is used as clipping plane in viewports. A clipping plane object maintains a list of viewports that it clips against.","baseclass":"Rhino.Geometry.PlaneSurface","properties":[{"signature":"Plane Plane","summary":"Gets or sets the clipping plane.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"bool AddClipViewportId(Guid viewportId)","summary":"Adds a viewport id to the list of viewports that this clipping plane clips.","since":"6.1","parameters":[{"name":"viewportId","summary":"The id of the RhinoViewport to add."}],"returns":"True if the viewport was added, False if the viewport is already in the list."},{"signature":"bool RemoveClipViewportId(Guid viewportId)","summary":"Removes a viewport id that this being clipped by this clipping plane.","since":"6.1","parameters":[{"name":"viewportId","summary":"The id of the RhinoViewport to remove."}],"returns":"True if the viewport was removed, False if the viewport was not in the list."},{"signature":"Guid[] ViewportIds()","summary":"Returns the ids of RhinoViewport objects that are clipped by this clipping plane.","since":"5.0","returns":"The ids of RhinoViewport objects."}]},{"namespace":"Rhino.Geometry.Collections","name":"BrepCurveList","dataType":"class","summary":"Provides access to all the underlying curves in a Brep object.","interfaces":["IEnumerable<Curve>","Rhino.Collections.IRhinoTable<Curve>"],"properties":[{"signature":"int Count","summary":"Gets the number of curves in this list.","since":"5.6","property":["get"]}],"methods":[{"signature":"int Add(Curve curve)","summary":"Adds a curve","since":"5.6","parameters":[{"name":"curve","summary":"A copy of the curve is added to this brep"}],"returns":"Index that should be used to reference the geometry.  \\n-1 is returned if the input is not acceptable."},{"signature":"IEnumerator<Curve> GetEnumerator()","summary":"Get an enumerator that visits all curves.","since":"5.6","returns":"The enumerator."}]},{"namespace":"Rhino.Geometry.Collections","name":"BrepEdgeList","dataType":"class","summary":"Provides access to all the Edges in a Brep object.","interfaces":["IEnumerable<BrepEdge>","Rhino.Collections.IRhinoTable<BrepEdge>"],"properties":[{"signature":"int Count","summary":"Gets the number of brep edges.","since":"5.0","property":["get"]}],"methods":[{"signature":"BrepEdge Add(BrepVertex startVertex, BrepVertex endVertex, int curve3dIndex, double edgeTolerance)","summary":"Create and add a new edge to this list","since":"5.4"},{"signature":"BrepEdge Add(BrepVertex startVertex, BrepVertex endVertex, int curve3dIndex, Interval subDomain, double edgeTolerance)","summary":"Create and add a new edge to this list","since":"5.4"},{"signature":"BrepEdge Add(int curve3dIndex)","summary":"Create and add a new edge to this list","since":"5.4"},{"signature":"BrepEdge Add(int startVertexIndex, int endVertexIndex, int curve3dIndex, double edgeTolerance)","summary":"Create and add a new edge to this list","since":"5.6"},{"signature":"BrepEdge Add(int startVertexIndex, int endVertexIndex, int curve3dIndex, Interval subDomain, double edgeTolerance)","summary":"Create and add a new edge to this list","since":"5.6"},{"signature":"IEnumerator<BrepEdge> GetEnumerator()","summary":"Gets an enumerator that visits all edges.","since":"5.0","returns":"The enumerator."},{"signature":"int MergeAllEdges(double angleTolerance)","summary":"Merges all possible Brep edges. Edges across kinks cannot be merged. A pair of adjacent edges in a Brep  are mergeable if the angle between them is less than tolerance and the valence of the shared vertex is 2.","since":"6.23","parameters":[{"name":"angleTolerance","summary":"The maximum allowable difference of angle in radian between adjacent edges that can be merged."}],"returns":"The number of edges merged."},{"signature":"int MergeEdge(int edgeIndex, double angleTolerance)","summary":"Merge adjacent edges to a specified edge recursively. A pair of adjacent edges in a Brep  are mergeable if the angle between them is less than tolerance and the valence of the shared vertex is 2.","since":"6.23","parameters":[{"name":"edgeIndex","summary":">Index of edge to merge."},{"name":"angleTolerance","summary":"The maximum allowable difference of angle in radian between adjacent edges that can be merged."}],"returns":"The number of edges merged."},{"signature":"int SplitEdgeAtParameters(int edgeIndex, IEnumerable<double> edgeParameters)","summary":"Splits an edge at the specified parameters.","since":"5.0","parameters":[{"name":"edgeIndex","summary":"The index of the edge to be addressed."},{"name":"edgeParameters","summary":"The parameter along that edge."}],"returns":"Number of splits applied to the edge."},{"signature":"bool SplitKinkyEdge(int edgeIndex, double kinkToleranceRadians)","summary":"Splits the edge into G1 pieces.","since":"5.0","parameters":[{"name":"edgeIndex","summary":"Index of edge to test and split."},{"name":"kinkToleranceRadians","summary":"The split tolerance in radians."}],"returns":"True if successful."}]},{"namespace":"Rhino.Geometry.Collections","name":"BrepFaceList","dataType":"class","summary":"Provides access to all the Faces in a Brep object.","interfaces":["IEnumerable<BrepFace>","Rhino.Collections.IRhinoTable<BrepFace>"],"properties":[{"signature":"int Count","summary":"Gets the number of brep faces.","since":"5.0","property":["get"]}],"methods":[{"signature":"BrepFace Add(int surfaceIndex)","summary":"Create and add a new face to this list. An incomplete face is added. The caller must create and fill in the loops used by the face.","since":"5.4","parameters":[{"name":"surfaceIndex","summary":"index of surface in brep\'s Surfaces list"}]},{"signature":"BrepFace Add(Surface surface)","summary":"Add a new face to a brep.  This creates a complete face with new vertices at the surface corners, new edges along the surface boundary, etc.  The loop of the returned face has four trims that correspond to the south, east, north, and west side of the surface in that order.  If you use this version of Add to add an exiting brep, then you are responsible for using a tool like JoinEdges() to hook the new face to its neighbors.","since":"5.4","parameters":[{"name":"surface","summary":"surface is copied"}]},{"signature":"BrepFace AddConeFace(BrepVertex vertex, BrepEdge edge, bool revEdge)","summary":"Add a new face to the brep whose surface geometry is a ruled cone with the edge as the base and the vertex as the apex point.","since":"5.4","parameters":[{"name":"vertex","summary":"The apex of the cone will be at this vertex. The north side of the surface\'s parameter space will be a singular point at the vertex."},{"name":"edge","summary":"The south side of the face\'s surface will run along this edge."},{"name":"revEdge","summary":"True if the new face\'s outer boundary orientation along the edge is opposite the orientation of edge."}]},{"signature":"BrepFace AddRuledFace(BrepEdge edgeA, bool revEdgeA, BrepEdge edgeB, bool revEdgeB)","summary":"Add a new face to the brep whose surface geometry is a ruled surface between two edges.","since":"5.4","parameters":[{"name":"edgeA","summary":"The south side of the face\'s surface will run along edgeA."},{"name":"revEdgeA","summary":"True if the new face\'s outer boundary orientation along edgeA is opposite the orientation of edgeA."},{"name":"edgeB","summary":"The north side of the face\'s surface will run along edgeA"},{"name":"revEdgeB","summary":"True if the new face\'s outer boundary orientation along edgeB is opposite the orientation of edgeB"}]},{"signature":"Brep ExtractFace(int faceIndex)","summary":"Extracts a face from a Brep.","since":"5.0","parameters":[{"name":"faceIndex","summary":"A face index"}],"returns":"A brep. This can be null."},{"signature":"void Flip(bool onlyReversedFaces)","summary":"Flips the orientation of faces.","since":"5.0","parameters":[{"name":"onlyReversedFaces","summary":"If true, clears all BrepFace.OrientationIsReversed flags by calling BrepFace.Transpose() on each face with a True OrientationIsReversed setting. If false, all of the faces are flipped regardless of their orientation."}]},{"signature":"IEnumerator<BrepFace> GetEnumerator()","summary":"Gets an enumerators that yields BrepFaceobjects.","since":"5.0","returns":"The enumerator."},{"signature":"void RemoveAt(int faceIndex)","summary":"Deletes a face at a specified index.","since":"5.0","parameters":[{"name":"faceIndex","summary":"The index of the mesh face."}]},{"signature":"bool RemoveSlits()","summary":"Remove slit trims and slit boundaries from each face.","since":"5.10","returns":"True if any slits were removed"},{"signature":"bool ShrinkFaces()","summary":"Shrinks all the underlying surfaces in this Brep. Sometimes the surfaces extend far beyond the trimming boundaries of the Brep Face. This function will remove those portions of the surfaces that are not used.","since":"5.0","returns":"True on success, False on failure."},{"signature":"bool SplitBipolarFaces()","summary":"Splits surfaces with two singularities, like spheres, so the results have at most one singularity.","since":"5.0","returns":"True if successful."},{"signature":"bool SplitClosedFaces(int minimumDegree)","summary":"Splits closed surfaces so they are not closed.","since":"5.0","parameters":[{"name":"minimumDegree","summary":"If the degree of the surface < min_degree, the surface is not split. In some cases, minimumDegree = 2 is useful to preserve piecewise linear surfaces."}],"returns":"True if successful."},{"signature":"bool SplitFaceAtTangents(int faceIndex)","summary":"Splits the face of a Brep at tangent locations.","since":"6.0","parameters":[{"name":"faceIndex","summary":"The index of the face to split."}],"returns":"True if successful, False otherwise."},{"signature":"bool SplitFacesAtTangents()","summary":"Splits all of the faces of a Brep at tangent locations.","since":"6.0","returns":"True if successful, False otherwise."},{"signature":"bool SplitKinkyFace(int faceIndex, double kinkTolerance)","summary":"Splits a single face into G1 pieces.","since":"5.0","parameters":[{"name":"faceIndex","summary":"The index of the face to split."},{"name":"kinkTolerance","summary":"Tolerance (in radians) to use for crease detection."}],"returns":"True on success, False on failure."},{"signature":"bool SplitKinkyFaces()","summary":"Splits any faces with creases into G1 pieces.","since":"5.0","returns":"True on success, False on failure."},{"signature":"bool SplitKinkyFaces(double kinkTolerance)","summary":"Splits any faces with creases into G1 pieces.","since":"5.0","parameters":[{"name":"kinkTolerance","summary":"Tolerance (in radians) to use for crease detection."}],"returns":"True on success, False on failure."},{"signature":"bool SplitKinkyFaces(double kinkTolerance, bool compact)","summary":"Splits any faces with creases into G1 pieces.","since":"5.0","parameters":[{"name":"kinkTolerance","summary":"Tolerance (in radians) to use for crease detection."},{"name":"compact","summary":"If true, the Brep will be compacted if possible."}],"returns":"True on success, False on failure."},{"signature":"bool StandardizeFaceSurface(int faceIndex)","summary":"Standardizes the relationship between a BrepFace and the 3d surface it uses.  When done, the face will be the only face that references its 3d surface, and the orientations of the face and 3d surface will be the same.","since":"5.0","parameters":[{"name":"faceIndex","summary":"The index of the face."}],"returns":"True if successful."},{"signature":"void StandardizeFaceSurfaces()","summary":"Standardize all faces in the brep.","since":"5.0"}]},{"namespace":"Rhino.Geometry.Collections","name":"BrepLoopList","dataType":"class","summary":"Provides access to all the Loops in a Brep object.","interfaces":["IEnumerable<BrepLoop>","Rhino.Collections.IRhinoTable<BrepLoop>"],"properties":[{"signature":"int Count","summary":"Gets the number of brep loops.","since":"5.0","property":["get"]}],"methods":[{"signature":"BrepLoop Add(BrepLoopType loopType)","summary":"Create a new empty boundary loop. The new loop will not be part of a face and will not include any trim curves.","since":"5.4"},{"signature":"BrepLoop Add(BrepLoopType loopType, BrepFace face)","summary":"Create a new boundary loop on a face.  After you get this BrepLoop, you still need to create the vertices, edges, and trims that define the loop.","since":"5.4","returns":"New loop that needs to be filled in"},{"signature":"BrepLoop AddOuterLoop(int faceIndex)","summary":"Create a new outer boundary loop that runs along the sides of the face\'s surface.  All the necessary trims, edges, and vertices are created and added to the brep.","since":"5.4","parameters":[{"name":"faceIndex","summary":"index of face that needs an outer boundary that runs along the sides of its surface."}],"returns":"New outer boundary loop that is complete."},{"signature":"BrepLoop AddPlanarFaceLoop(int faceIndex, BrepLoopType loopType, IEnumerable<Curve> boundaryCurves)","summary":"Add a planar trimming loop to a planar face","since":"5.4","parameters":[{"name":"faceIndex","summary":"index of planar face.  The underlying surface must be a PlaneSurface"},{"name":"loopType","summary":"type of loop to add.  If loopType is Unknown, then the loop direction is tested and the new loops type will be set to Outer or Inner. If the loopType is Outer, then the direction of the new loop is tested and flipped if it is clockwise. If the loopType is Inner, then the direction of the new loop is tested and flipped if it is counter-clockwise."},{"name":"boundaryCurves","summary":"list of 3d curves that form a simple (no self intersections) closed curve.  These curves define the 3d edge geometry and should be near the planar surface."}],"returns":"new loop if successful"},{"signature":"IEnumerator<BrepLoop> GetEnumerator()","summary":"Gets an enumerator that visits all edges.","since":"5.0","returns":"The enumerator."}]},{"namespace":"Rhino.Geometry.Collections","name":"BrepSurfaceList","dataType":"class","summary":"Provides access to all the underlying surfaces in a Brep object.","interfaces":["IEnumerable<Surface>","Rhino.Collections.IRhinoTable<Surface>"],"properties":[{"signature":"int Count","summary":"Gets the number of surfaces in a brep.","since":"5.4","property":["get"]}],"methods":[{"signature":"IEnumerator<Surface> GetEnumerator()","summary":"Gets an enumerator that visits all surfaces.","since":"5.4","returns":"The enumerator."}]},{"namespace":"Rhino.Geometry.Collections","name":"BrepTrimList","dataType":"class","summary":"Provides access to all the Trims in a Brep object","interfaces":["IEnumerable<BrepTrim>","Rhino.Collections.IRhinoTable<BrepTrim>"],"properties":[{"signature":"int Count","summary":"Gets the number of brep trims.","since":"5.1","property":["get"]}],"methods":[{"signature":"BrepTrim Add(bool rev3d, BrepEdge edge, int curve2dIndex)","summary":"Add a new trim that will be part of an inner, outer, or slit loop to the brep","since":"5.4","parameters":[{"name":"rev3d","summary":"True if the edge and trim have opposite directions"},{"name":"edge","summary":"3d edge associated with this trim"},{"name":"curve2dIndex","summary":"index of 2d trimming curve"}],"returns":"new trim"},{"signature":"BrepTrim Add(bool rev3d, BrepLoop loop, int curve2dIndex)","summary":"Add a new trim that will be part of an inner, outer, or slit loop to the brep","since":"5.4","parameters":[{"name":"rev3d","summary":"True if the edge and trim have opposite directions"},{"name":"loop","summary":"trim is appended to this loop"},{"name":"curve2dIndex","summary":"index of 2d trimming curve"}],"returns":"new trim"},{"signature":"BrepTrim Add(BrepEdge edge, bool rev3d, BrepLoop loop, int curve2dIndex)","summary":"Add a new trim that will be part of an inner, outer, or slit loop to the brep.","since":"5.4","parameters":[{"name":"edge","summary":"3d edge associated with this trim"},{"name":"rev3d","summary":"True if the edge and trim have opposite directions"},{"name":"loop","summary":"trim is appended to this loop"},{"name":"curve2dIndex","summary":"index of 2d trimming curve"}],"returns":"new trim"},{"signature":"BrepTrim Add(int curve2dIndex)","summary":"Add a new trim that will be part of an inner, outer, or slit loop to the brep.","since":"5.4","parameters":[{"name":"curve2dIndex","summary":"index of 2d trimming curve"}],"returns":"New Trim"},{"signature":"BrepTrim AddCurveOnFace(BrepFace face, BrepEdge edge, bool rev3d, int curve2dIndex)","summary":"Add a new curve on face to the brep","since":"5.4","parameters":[{"name":"face","summary":"face that curve lies on"},{"name":"edge","summary":"3d edge associated with this curve on surface"},{"name":"rev3d","summary":"True if the 3d edge and the 2d parameter space curve have opposite directions."},{"name":"curve2dIndex","summary":"index of 2d curve in face\'s parameter space"}],"returns":"new trim that represents the curve on surface"},{"signature":"BrepTrim AddSingularTrim(BrepVertex vertex, BrepLoop loop, IsoStatus iso, int curve2dIndex)","summary":"Add a new singular trim to the brep.","since":"5.4","parameters":[{"name":"vertex","summary":"vertex along collapsed surface edge"},{"name":"loop","summary":"trim is appended to this loop"},{"name":"iso","summary":""},{"name":"curve2dIndex","summary":"index of 2d trimming curve"}],"returns":"new trim"},{"signature":"IEnumerator<BrepTrim> GetEnumerator()","summary":"Gets an enumerator that visits all edges.","since":"5.1","returns":"The enumerator."},{"signature":"bool MatchEnds()","summary":"Matches the endpoints of all trims in the Brep.","since":"6.19","returns":"True if any trim\'s 2d curve is changed, False otherwise."},{"signature":"bool MatchEnds(BrepLoop loop)","summary":"Match the endpoints of all trims in a loop.","since":"6.19","parameters":[{"name":"loop","summary":"The Brep loop."}],"returns":"True if any trim\'s 2d curve is changed, False otherwise."},{"signature":"bool MatchEnds(BrepTrim trim0, BrepTrim trim1)","summary":"Match the end of a trim to the start of the next trim.","since":"6.19","parameters":[{"name":"trim0","summary":"The Brep trim."},{"name":"trim1","summary":"Brep trim that comes immediately after trim0 in the same loop."}],"returns":"True if either trim\'s 2d curve is changed, False otherwise."},{"signature":"bool MatchEnds(int trimIndex)","summary":"Match the endpoints of a trim to the next and previous trim.","since":"6.19","returns":"True if any trim\'s 2d curve is changed, False otherwise."}]},{"namespace":"Rhino.Geometry.Collections","name":"BrepVertexList","dataType":"class","summary":"Provides access to all the Vertices in a Brep object","interfaces":["IEnumerable<BrepVertex>","Rhino.Collections.IRhinoTable<BrepVertex>"],"properties":[{"signature":"int Count","summary":"Gets the number of brep vertices.","since":"5.4","property":["get"]}],"methods":[{"signature":"BrepVertex Add()","summary":"Create and add a new vertex to this list","since":"5.4"},{"signature":"BrepVertex Add(Point3d point, double vertexTolerance)","summary":"Create and add a new vertex to this list","since":"5.4","parameters":[{"name":"point","summary":""},{"name":"vertexTolerance","summary":"Use RhinoMath.UnsetTolerance if you are unsure"}]},{"signature":"BrepVertex AddPointOnFace(BrepFace face, double s, double t)","summary":"Adds a new point on face to the brep","since":"5.4","parameters":[{"name":"face","summary":"face that vertex lies on"},{"name":"s","summary":"surface parameters"},{"name":"t","summary":"surface parameters"}],"returns":"new vertex that represents the point on face"},{"signature":"IEnumerator<BrepVertex> GetEnumerator()","summary":"Gets an enumerator that visits all surfaces.","since":"5.4","returns":"The enumerator."}]},{"namespace":"Rhino.Geometry.Collections","name":"MeshFaceList","dataType":"class","summary":"Provides access to the faces and Face related functionality of a Mesh.","interfaces":["IResizableList<MeshFace>","IList","IReadOnlyList<MeshFace>"],"properties":[{"signature":"int Capacity","summary":"Gets or sets the total number of mesh triangles and quads the internal data structure can hold without resizing.","since":"6.0","property":["get","set"]},{"signature":"int Count","summary":"Gets or sets the number of mesh faces. When getting this can includes invalid faces.","since":"5.0","property":["get","set"]},{"signature":"int QuadCount","summary":"Gets the number of faces that are valid quads (4 corners).","since":"5.0","property":["get"]},{"signature":"int TriangleCount","summary":"Gets the number of faces that are valid triangles (3 corners).","since":"5.0","property":["get"]}],"methods":[{"signature":"int AddFace(int vertex1, int vertex2, int vertex3)","summary":"Appends a new triangular face to the end of the mesh face list.","since":"5.0","parameters":[{"name":"vertex1","summary":"Index of first face corner."},{"name":"vertex2","summary":"Index of second face corner."},{"name":"vertex3","summary":"Index of third face corner."}],"returns":"The index of the newly added triangle."},{"signature":"int AddFace(int vertex1, int vertex2, int vertex3, int vertex4)","summary":"Appends a new quadrangular face to the end of the mesh face list.","since":"5.0","parameters":[{"name":"vertex1","summary":"Index of first face corner."},{"name":"vertex2","summary":"Index of second face corner."},{"name":"vertex3","summary":"Index of third face corner."},{"name":"vertex4","summary":"Index of fourth face corner."}],"returns":"The index of the newly added quad."},{"signature":"int AddFace(MeshFace face)","summary":"Appends a new mesh face to the end of the mesh face list.","since":"5.0","parameters":[{"name":"face","summary":"Face to add."}],"returns":"The index of the newly added face."},{"signature":"int[] AddFaces(IEnumerable<MeshFace> faces)","summary":"Appends a list of faces to the end of the mesh face list.","since":"5.0","parameters":[{"name":"faces","summary":"Faces to add."}],"returns":"Indices of the newly created faces"},{"signature":"int[] AdjacentFaces(int faceIndex)","summary":"Gets all faces that share a topological edge with a given face.","since":"5.0","parameters":[{"name":"faceIndex","summary":"A face index."}],"returns":"All indices that share an edge."},{"signature":"void Clear()","summary":"Clears the Face list on the mesh.","since":"5.0"},{"signature":"int ConvertNonPlanarQuadsToTriangles(double planarTolerance, double angleToleranceRadians, int splitMethod)","summary":"Splits non-planar quads into two triangles based on given parameters.","since":"6.0","parameters":[{"name":"planarTolerance","summary":"If planarTolerance >= 0, then a quad is split if its vertices are not coplanar. If both planarTolerance = Rhino.RhinoMath.UnsetValue and angleToleranceRadians >= 0.0, then the planarity test is skipped."},{"name":"angleToleranceRadians","summary":"If angleToleranceRadians >= 0.0, then a quad is split if the angle between opposite corner normals is > angleToleranceRadians. The corner normal is the normal to the triangle formed by two adjacent edges and the diagonal connecting their endpoints. A quad has four corner normals. If both angleToleranceRadians = Rhino.RhinoMath.UnsetValue and planarTolerance >= 0.0, then the corner normal angle test is skipped."},{"name":"splitMethod","summary":"0 default Currently divides along the short diagonal. This may be changed as better methods are found or preferences change. By passing zero, you let the developers of this code decide what\'s best for you over time. 1 divide along the short diagonal 2 divide along the long diagonal 3 minimize resulting area 4 maximize resulting area 5 minimize angle between triangle normals 6 maximize angle between triangle normals"}],"returns":"Number of quads that were converted to triangles."},{"signature":"bool ConvertQuadsToTriangles()","summary":"Splits all quads along the short diagonal.","since":"5.0","returns":"True on success, False on failure."},{"signature":"bool ConvertTrianglesToQuads(double angleToleranceRadians, double minimumDiagonalLengthRatio)","summary":"Joins adjacent triangles into quads if the resulting quad is \'nice\'.","since":"5.0","parameters":[{"name":"angleToleranceRadians","summary":"Used to compare adjacent triangles\' face normals. For two triangles to be considered, the angle between their face normals has to be <= angleToleranceRadians. When in doubt use RhinoMath.PI/90.0 (2 degrees)."},{"name":"minimumDiagonalLengthRatio","summary":"( <= 1.0) For two triangles to be considered the ratio of the resulting quad\'s diagonals (length of the shortest diagonal)/(length of longest diagonal). has to be >= minimumDiagonalLengthRatio. When in doubt us .875."}],"returns":"True on success, False on failure."},{"signature":"int CullDegenerateFaces()","summary":"Attempts to removes degenerate faces from the mesh.  \\nDegenerate faces are faces that contains such a combination of indices, that their final shape collapsed in a line or point.  \\nBefore returning, this method also attempts to repair faces by juggling vertex indices.","since":"5.0","returns":"The number of degenerate faces that were removed."},{"signature":"int DeleteFaces(IEnumerable<int> faceIndexes)","summary":"Removes a collection of faces from the mesh without affecting the remaining geometry.","since":"5.0","parameters":[{"name":"faceIndexes","summary":"An array containing all the face indices to be removed."}],"returns":"The number of faces deleted on success."},{"signature":"int DeleteFaces(IEnumerable<int> faceIndexes, bool compact)","summary":"Removes a collection of faces from the mesh without affecting the remaining geometry.","since":"6.6","parameters":[{"name":"faceIndexes","summary":"An array containing all the face indices to be removed."},{"name":"compact","summary":"If true, removes vertices that are no longer referenced."}],"returns":"The number of faces deleted on success."},{"signature":"void Destroy()","summary":"Releases all memory allocated to store faces. The list capacity will be 0 after this call.  \\nSubsequent calls can add new items.","since":"6.0"},{"signature":"Mesh ExtractDuplicateFaces()","summary":"Extracts, or removes, duplicate faces.","since":"6.0","returns":"A mesh containing the extracted duplicate faces if successful, None otherwise."},{"signature":"Mesh ExtractFaces(IEnumerable<int> faceIndices)","summary":"Extracts, or removes, faces.","since":"6.0","parameters":[{"name":"faceIndices","summary":"The face indices to be extracted."}],"returns":"A mesh containing the extracted faces if successful, None otherwise."},{"signature":"IndexPair[] GetClashingFacePairs(int maxPairCount)","summary":"Gets an array of pairs of mesh faces that clash.","since":"6.0","parameters":[{"name":"maxPairCount","summary":"If >0, then at most this many pairs will be added to the output array. If <=0, then all clashing pairs will be added to the output array."}],"returns":"Array of pairs of mesh face indices."},{"signature":"int[] GetConnectedFaces(int faceIndex, double angleRadians, bool greaterThanAngle)","summary":"Find all connected face indices where adjacent face normals meet the criteria of angleRadians and greaterThanAngle","since":"5.6","parameters":[{"name":"faceIndex","summary":"face index to start from"},{"name":"angleRadians","summary":"angle to use for comparison of what is connected"},{"name":"greaterThanAngle","summary":"If True angles greater than or equal to are considered connected. If false, angles less than or equal to are considered connected."}],"returns":"list of connected face indices"},{"signature":"int[] GetConnectedFacesToEdges(int startFaceIndex, bool treatNonmanifoldLikeUnwelded)","summary":"Uses startFaceIndex and finds all connected face indexes up to unwelded or naked edges. If treatNonmanifoldLikeUnwelded is True then non-manifold edges will be considered as unwelded or naked","since":"5.6","parameters":[{"name":"startFaceIndex","summary":"Initial face index"},{"name":"treatNonmanifoldLikeUnwelded","summary":"True means non-manifold edges will be handled like unwelded edges, False means they aren\'t considered"}],"returns":"Array of connected face indexes"},{"signature":"int[] GetDuplicateFaces()","summary":"Finds all of the duplicate faces.","since":"6.0","returns":"The indexes that are duplicates of other indexes if successful. If there are no duplicate, then an empty array is returned."},{"signature":"IEnumerator<MeshFace> GetEnumerator()","summary":"Gets an enumerator that yields all faces in this collection.","since":"5.0","returns":"The enumerator."},{"signature":"MeshFace GetFace(int index)","summary":"Returns the mesh face at the given index.","since":"5.0","parameters":[{"name":"index","summary":"Index of face to get. Must be larger than or equal to zero and smaller than the Face Count of the mesh."}],"returns":"The mesh face at the given index on success or MeshFace.Unset if the index is out of range."},{"signature":"double GetFaceAspectRatio(int index)","summary":"Returns the mesh face at the given index.","since":"6.0","parameters":[{"name":"index","summary":"Index of face to get. Must be larger than or equal to zero and smaller than the Face Count of the mesh."}],"returns":"The mesh face at the given index on success or MeshFace.Unset if the index is out of range."},{"signature":"BoundingBox GetFaceBoundingBox(int faceIndex)","summary":"Gets the bounding box of a face.","since":"5.0","parameters":[{"name":"faceIndex","summary":"A face index."}],"returns":"A new bounding box, or BoundingBox.Emptyon error."},{"signature":"Point3d GetFaceCenter(int faceIndex)","summary":"Gets the center point of a face.  \\nFor a triangular face, this is the centroid or barycenter.  \\nFor a quad, this is the average of four comer points.","since":"5.0","parameters":[{"name":"faceIndex","summary":"A face index."}],"returns":"The center point."},{"signature":"bool GetFaceVertices(int faceIndex, out Point3f a, out Point3f b, out Point3f c, out Point3f d)","summary":"Gets the 3D location of the vertices forming a face.","since":"5.0","parameters":[{"name":"faceIndex","summary":"A face index."},{"name":"a","summary":"A first point. This out argument is assigned during the call."},{"name":"b","summary":"A second point. This out argument is assigned during the call."},{"name":"c","summary":"A third point. This out argument is assigned during the call."},{"name":"d","summary":"A fourth point. This out argument is assigned during the call."}],"returns":"True if the operation succeeded, otherwise false."},{"signature":"int[] GetTopologicalVertices(int faceIndex)","summary":"Gets the topology vertex indices of a face.","since":"5.0","parameters":[{"name":"faceIndex","summary":"A face index."}],"returns":"An array of integers."},{"signature":"bool GetZeroAreaFaces(out int[] whollyDegenerateFaces, out int[] partiallyDegenerateFaces)","summary":"Examines and adds face indexes to whollyDegenerateFaces if the face is a triangle with zero area or a quad both triangles have zero area. Face indexes are added to partiallyDegenerateFaces when a quad has one triangle with zero area.","since":"6.0","parameters":[{"name":"whollyDegenerateFaces","summary":"Array of indexes for faces, both triangles and quads, that have zero area."},{"name":"partiallyDegenerateFaces","summary":"Array of indexes for quad faces, that have one triangle with zero area."}],"returns":"Returns True if the mesh has wholly or partially degenerate faces, False otherwise."},{"signature":"bool HasNakedEdges(int faceIndex)","summary":"Returns True if at least one of the face edges are not topologically connected to any other faces.","since":"5.0","parameters":[{"name":"faceIndex","summary":"A face index."}],"returns":"True if that face makes the mesh open, otherwise false."},{"signature":"void Insert(int index, MeshFace face)","summary":"Inserts a mesh face at a defined index in this list.","since":"5.0","parameters":[{"name":"index","summary":"An index."},{"name":"face","summary":"A face."}]},{"signature":"bool IsHidden(int faceIndex)","summary":"Gets a value indicating whether a face is hidden.  \\nA face is hidden if, and only if, at least one of its vertices is hidden.","since":"5.0","parameters":[{"name":"faceIndex","summary":"A face index."}],"returns":"True if hidden, False if fully visible."},{"signature":"void RemoveAt(int index)","summary":"Removes a face from the mesh.","since":"5.0","parameters":[{"name":"index","summary":"The index of the face that will be removed."}]},{"signature":"void RemoveAt(int index, bool compact)","summary":"Removes a face from the mesh.","since":"6.6","parameters":[{"name":"index","summary":"The index of the face that will be removed."},{"name":"compact","summary":"If true, removes vertices that are no longer referenced."}]},{"signature":"int RemoveZeroAreaFaces(ref int fixedFaceCount)","summary":"Deletes or fixes mesh faces that have zero area.","since":"6.0","parameters":[{"name":"fixedFaceCount","summary":"Number of fixed partially degenerate faces."}],"returns":"Number of removed wholly degenerate faces."},{"signature":"bool SetFace(int index, int vertex1, int vertex2, int vertex3)","summary":"Sets a triangular face at a specific index of the mesh.","since":"5.0","parameters":[{"name":"index","summary":"A position in the list."},{"name":"vertex1","summary":"The first vertex index."},{"name":"vertex2","summary":"The second vertex index."},{"name":"vertex3","summary":"The third vertex index."}],"returns":"True if the operation succeeded, otherwise false."},{"signature":"bool SetFace(int index, int vertex1, int vertex2, int vertex3, int vertex4)","summary":"Sets a quadrangular face at a specific index of the mesh.","since":"5.0","parameters":[{"name":"index","summary":"A position in the list."},{"name":"vertex1","summary":"The first vertex index."},{"name":"vertex2","summary":"The second vertex index."},{"name":"vertex3","summary":"The third vertex index."},{"name":"vertex4","summary":"The fourth vertex index."}],"returns":"True if the operation succeeded, otherwise false."},{"signature":"bool SetFace(int index, MeshFace face)","summary":"Sets a face at a specific index of the mesh.","since":"5.0","parameters":[{"name":"index","summary":"A position in the list."},{"name":"face","summary":"A face."}],"returns":"True if the operation succeeded, otherwise false."},{"signature":"int[] ToIntArray(bool asTriangles)","summary":"Copies all of the face indices to a linear array of indices per face.  Note that this includes indices from invalid faces too.","since":"5.9","parameters":[{"name":"asTriangles","summary":"If set totrueas triangles."}],"returns":"The int array. This method never returns null."},{"signature":"int[] ToIntArray(bool asTriangles, ref List<int> replacedIndices)","summary":"Copies all of the faces to a linear array of indices.  Clean-up of vertex indices if replacedIndices is a valid List<int>","parameters":[{"name":"asTriangles","summary":"If set totrueas triangles."},{"name":"replacedIndices","summary":"List is populated with vertex indices that were replaced with 0. If replacedIndices is None there will be no cleanup"}],"returns":"The int array. This method never returns null."}]},{"namespace":"Rhino.Geometry.Collections","name":"MeshFaceNormalList","dataType":"class","summary":"Provides access to the Face normals of a Mesh.","interfaces":["IResizableList<Vector3f>","IList","IReadOnlyList<Vector3f>"],"properties":[{"signature":"int Capacity","summary":"Gets or sets the total number of face normals the internal data structure can hold without resizing.","since":"6.0","property":["get","set"]},{"signature":"int Count","summary":"Gets or sets the number of mesh face normals.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"int AddFaceNormal(double x, double y, double z)","summary":"Appends a face normal to the list of mesh face normals.","since":"5.0","parameters":[{"name":"x","summary":"X component of face normal."},{"name":"y","summary":"Y component of face normal."},{"name":"z","summary":"Z component of face normal."}],"returns":"The index of the newly added face normal."},{"signature":"int AddFaceNormal(float x, float y, float z)","summary":"Appends a face normal to the list of mesh face normals.","since":"5.0","parameters":[{"name":"x","summary":"X component of face normal."},{"name":"y","summary":"Y component of face normal."},{"name":"z","summary":"Z component of face normal."}],"returns":"The index of the newly added face normal."},{"signature":"int AddFaceNormal(Vector3d normal)","summary":"Appends a face normal to the list of mesh face normals.","since":"5.0","parameters":[{"name":"normal","summary":"New face normal."}],"returns":"The index of the newly added face normal."},{"signature":"int AddFaceNormal(Vector3f normal)","summary":"Appends a face normal to the list of mesh face normals.","since":"5.0","parameters":[{"name":"normal","summary":"New face normal."}],"returns":"The index of the newly added face normal."},{"signature":"void Clear()","summary":"Clears the Face Normal list on the mesh.","since":"5.0"},{"signature":"bool ComputeFaceNormals()","summary":"Computes all the face normals for this mesh based on the physical shape of the mesh.","since":"5.0","returns":"True on success, False on failure."},{"signature":"void Destroy()","summary":"Releases all memory allocated to store face normals. The list capacity will be 0 after this call.  \\nSubsequent calls can add new items.","since":"6.0"},{"signature":"IEnumerator<Vector3f> GetEnumerator()","summary":"Gets an enumerator that yields all normals (vectors) in this collection.","since":"5.0","returns":"The enumerator."},{"signature":"bool SetFaceNormal(int index, double x, double y, double z)","summary":"Sets a face normal vector at an index using three double-precision numbers.","since":"5.0","parameters":[{"name":"index","summary":"An index."},{"name":"x","summary":"A x component."},{"name":"y","summary":"A y component."},{"name":"z","summary":"A z component."}],"returns":"True on success; False on error."},{"signature":"bool SetFaceNormal(int index, float x, float y, float z)","summary":"Sets a face normal vector at an index using three single-precision numbers.","since":"5.0","parameters":[{"name":"index","summary":"An index."},{"name":"x","summary":"A x component."},{"name":"y","summary":"A y component."},{"name":"z","summary":"A z component."}],"returns":"True on success; False on error."},{"signature":"bool SetFaceNormal(int index, Vector3d normal)","summary":"Sets a face normal vector at an index using a single-precision vector.","since":"5.0","parameters":[{"name":"index","summary":"An index."},{"name":"normal","summary":"A normal vector."}],"returns":"True on success; False on error."},{"signature":"bool SetFaceNormal(int index, Vector3f normal)","summary":"Sets a face normal vector at an index using a single-precision vector.","since":"5.0","parameters":[{"name":"index","summary":"An index."},{"name":"normal","summary":"A normal vector."}],"returns":"True on success; False on error."},{"signature":"bool UnitizeFaceNormals()","summary":"Unitizes all the existing face normals.","since":"5.0","returns":"True on success, False on failure."}]},{"namespace":"Rhino.Geometry.Collections","name":"MeshNgonList","dataType":"class","summary":"Provides access to the ngons and ngon-related functionality of a Mesh. See also the Rhino.Geometry.Mesh.Ngonsproperty for Ngon functionality details.","interfaces":["IResizableList<MeshNgon>","IList","IReadOnlyList<MeshNgon>"],"properties":[{"signature":"int Count","summary":"Gets or sets the number of mesh ngons.","since":"6.0","property":["get","set"]},{"signature":"uint UnsignedCount","summary":"Gets or sets the number of mesh ngons.","since":"6.0","property":["get","set"]}],"methods":[{"signature":"int AddNgon(MeshNgon ngon)","summary":"Appends a new ngon to the end of the mesh ngon list.","since":"6.0","parameters":[{"name":"ngon","summary":"Ngon to add."}],"returns":"The index of the newly added ngon."},{"signature":"int[] AddNgons(IEnumerable<MeshNgon> ngons)","summary":"Appends a list of ngons to the end of the mesh ngon list.","since":"6.0","parameters":[{"name":"ngons","summary":"Ngons to add."}],"returns":"Indices of the newly created ngons"},{"signature":"int AddPlanarNgons(double planarTolerance)","summary":"Add an ngon for each group of connected coplanar faces.","since":"6.0","parameters":[{"name":"planarTolerance","summary":"3d distance tolerance for coplanar test."}],"returns":"Number of ngons added to the mesh."},{"signature":"int AddPlanarNgons(double planarTolerance, int minimumNgonVertexCount, int minimumNgonFaceCount, bool allowHoles)","summary":"Add an ngon for each group of connected coplanar faces.","since":"6.0","parameters":[{"name":"planarTolerance","summary":"3d distance tolerance for coplanar test."},{"name":"minimumNgonVertexCount","summary":"Minimum number of vertices for an ngon."},{"name":"minimumNgonFaceCount","summary":"Minimum number of faces for an ngon."},{"name":"allowHoles","summary":"Determines whether the ngon can have inner boundaries."}],"returns":"Number of ngons added to the mesh."},{"signature":"void Clear()","summary":"Clears the Ngon list on the mesh.","since":"6.0"},{"signature":"IEnumerator<MeshNgon> GetEnumerator()","summary":"Gets an enumerator that yields all ngons in this collection.","since":"6.0","returns":"The enumerator."},{"signature":"MeshNgon GetNgon(int index)","summary":"Returns the mesh ngon at the given index.","since":"6.0","parameters":[{"name":"index","summary":"Index of ngon to get. Must be larger than or equal to zero and smaller than the Ngon Count of the mesh."}],"returns":"The mesh ngon at the given index.  This ngon can be MeshNgon.Empty."},{"signature":"int[] GetNgonBoundary(IEnumerable<int> ngonFaceIndexList)","summary":"Get a list of vertices that form the boundary of a face set. This is often use to get ngon boundaries.","since":"6.0","parameters":[{"name":"ngonFaceIndexList","summary":"List of mesh face indices."}],"returns":"List of mesh vertex indices that form the boundary of the face set."},{"signature":"BoundingBox GetNgonBoundingBox(int index)","summary":"Gets the bounding box of an ngon.","since":"6.0","parameters":[{"name":"index","summary":"A ngon index."}],"returns":"A new bounding box, or BoundingBox.Emptyon error."},{"signature":"BoundingBox GetNgonBoundingBox(MeshNgon ngon)","summary":"Gets the bounding box of an ngon.","since":"6.0","parameters":[{"name":"ngon","summary":"An ngon."}],"returns":"A new bounding box, or BoundingBox.Emptyon error."},{"signature":"Point3d GetNgonCenter(int index)","summary":"Gets the center point of an ngon.  \\nThis the average of the corner points.","since":"6.0","parameters":[{"name":"index","summary":"A ngon index."}],"returns":"The center point."},{"signature":"Point3d GetNgonCenter(MeshNgon ngon)","summary":"Gets the center point of an ngon.  \\nThis the average of the corner points.","since":"6.0","parameters":[{"name":"ngon","summary":"An ngon."}],"returns":"The center point."},{"signature":"int GetNgonEdgeCount(int index)","summary":"Gets the complete edge count of an ngon.","since":"6.0","parameters":[{"name":"index","summary":"Ngon index."}],"returns":"Complete edge count or zero on error."},{"signature":"int GetNgonOuterEdgeCount(int index)","summary":"Gets the outer edge count of an ngon.","since":"6.0","parameters":[{"name":"index","summary":"Ngon index."}],"returns":"Outer edge count or zero on error."},{"signature":"void Insert(int index, MeshNgon ngon)","summary":"Inserts a mesh ngon at a defined index in this list.","since":"6.0","parameters":[{"name":"index","summary":"An ngon index."},{"name":"ngon","summary":"An ngon."}]},{"signature":"uint IsValid(int index)","summary":"Tests an ngon to see if the vertex and face references are valid and pass partial boundary validity checks.","since":"6.0","parameters":[{"name":"index","summary":"The index of the ngon to test."}],"returns":"0 if the ngon is not valid, otherwise the number of boundary edges."},{"signature":"uint IsValid(int index, TextLog textLog)","summary":"Tests an ngon to see if the vertex and face references are valid and pass partial boundary validity checks.","since":"6.0","parameters":[{"name":"index","summary":"The index of the ngon to test."},{"name":"textLog","summary":"A text log for collecting information about problems."}],"returns":"0 if the ngon is not valid, otherwise the number of boundary edges."},{"signature":"Point3d[] NgonBoundaryVertexList(MeshNgon ngon, bool bAppendStartPoint)","summary":"Get an ngon\'s boundary points.","since":"6.0","parameters":[{"name":"ngon","summary":"ngon."},{"name":"bAppendStartPoint","summary":"If true, the first point in the list is also appended to the end of the list to create a closed polyline."}],"returns":"A list of ngon boundary points."},{"signature":"bool NgonHasHoles(int index)","summary":"Determines whether a ngon has holes.","since":"6.0","parameters":[{"name":"index","summary":"Ngon index."}],"returns":"True for holes (or malformed ngon, see remarks), False for no holes."},{"signature":"int NgonIndexFromFaceIndex(int meshFaceIndex)","summary":"Returns the index of a mesh ngon the face belongs to.","since":"6.0","parameters":[{"name":"meshFaceIndex","summary":"Index of a mesh face."}],"returns":"The index of the mesh ngon the face belongs to or -1 if the face does not belong to an ngon."},{"signature":"int Orientation(int index, bool permitHoles)","summary":"Determine if the ngon\'s boundary orientation matches that of the set of faces it is made from.","since":"7.0","parameters":[{"name":"index","summary":"Ngon index."},{"name":"permitHoles","summary":"True if the ngon is permitted to have interior holes, False otherwise."}],"returns":"1: The ngon does not have holes, the ngon\'s faces are compatibly oriented, and the ngon\'s outer boundary orientation matches the faces\' orientation. -1: The ngon does not have holes, the ngon\'s faces are compatibly oriented, and the ngon\'s outer boundary orientation is opposite the faces\' orientation. 0: Otherwise.The ngon may be invalid, have holes, the ngon\'s faces may not be compatibly oriented, the ngons edges may not have a consistent orientation with respect to the faces, or some other issue."},{"signature":"void RemoveAt(int index)","summary":"Removes an ngon from the mesh.","since":"6.0","parameters":[{"name":"index","summary":"The index of the ngon."}]},{"signature":"int RemoveNgons(IEnumerable<int> indices)","summary":"Remove one or more ngons from the mesh.","since":"6.0","parameters":[{"name":"indices","summary":"An array of ngon indices."}],"returns":"The number of deleted ngons."},{"signature":"void ReverseOuterBoundary(int index)","summary":"Reverse the order of the m_vi[] array for an ngon","since":"7.0"},{"signature":"void SetNgon(int index, MeshNgon ngon)","summary":"Set an ngon in this list.","since":"6.0","parameters":[{"name":"index","summary":"An ngon index."},{"name":"ngon","summary":"An ngon."}]}]},{"namespace":"Rhino.Geometry.Collections","name":"MeshTextureCoordinateList","dataType":"class","summary":"Provides access to the Vertex Texture coordinates of a Mesh.","interfaces":["IResizableList<Point2f>","IList","IReadOnlyList<Point2f>"],"properties":[{"signature":"int Capacity","summary":"Gets or sets the total number of texture coordinates the internal data structure can hold without resizing.","since":"6.0","property":["get","set"]},{"signature":"int Count","summary":"Gets or sets the number of texture coordinates.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"int Add(double s, double t)","summary":"Adds a new texture coordinate to the end of the Texture list.","since":"5.0","parameters":[{"name":"s","summary":"S component of new texture coordinate."},{"name":"t","summary":"T component of new texture coordinate."}],"returns":"The index of the newly added texture coordinate."},{"signature":"int Add(float s, float t)","summary":"Adds a new texture coordinate to the end of the Texture list.","since":"5.0","parameters":[{"name":"s","summary":"S component of new texture coordinate."},{"name":"t","summary":"T component of new texture coordinate."}],"returns":"The index of the newly added texture coordinate."},{"signature":"int Add(Point2f tc)","summary":"Adds a new texture coordinate to the end of the Texture list.","since":"5.0","parameters":[{"name":"tc","summary":"Texture coordinate to add."}],"returns":"The index of the newly added texture coordinate."},{"signature":"int Add(Point3d tc)","summary":"Adds a new texture coordinate to the end of the Texture list.","since":"5.0","parameters":[{"name":"tc","summary":"Texture coordinate to add."}],"returns":"The index of the newly added texture coordinate."},{"signature":"bool AddRange(Point2f[] textureCoordinates)","summary":"Appends an array of texture coordinates.","since":"5.0","parameters":[{"name":"textureCoordinates","summary":"Texture coordinates to append."}],"returns":"True on success, False on failure."},{"signature":"void Clear()","summary":"Clears the Texture Coordinate list on the mesh.","since":"5.0"},{"signature":"void Destroy()","summary":"Releases all memory allocated to store texture coordinates. The list capacity will be 0 after this call.  \\nSubsequent calls can add new items.","since":"6.0"},{"signature":"IEnumerator<Point2f> GetEnumerator()","summary":"Gets an enumerator that yields all texture coordinates in this collection.","since":"5.0","returns":"The enumerator."},{"signature":"bool NormalizeTextureCoordinates()","summary":"Scales the texture coordinates so the texture domains are [0,1] and eliminate any texture rotations.","since":"5.0","returns":"True on success, False on failure."},{"signature":"bool ReverseTextureCoordinates(int direction)","summary":"Reverses one coordinate direction of the texture coordinates.  \\nThe region of the bitmap the texture uses does not change. Either Us or Vs direction is flipped.","since":"5.0","parameters":[{"name":"direction","summary":"0 = first texture coordinate is reversed.  \\n1 = second texture coordinate is reversed."}],"returns":"True if operation succeeded; otherwise, false."},{"signature":"bool SetTextureCoordinate(int index, double s, double t)","summary":"Sets or adds a texture coordinate to the Texture Coordinate List.  \\nIf [index] is less than [Count], the existing coordinate at [index] will be modified.  \\nIf [index] equals [Count], a new coordinate is appended to the end of the coordinate list.  \\nIf [index] is larger than [Count], the function will return false.","since":"5.0","parameters":[{"name":"index","summary":"Index of texture coordinate to set."},{"name":"s","summary":"S component of texture coordinate."},{"name":"t","summary":"T component of texture coordinate."}],"returns":"True on success, False on failure."},{"signature":"bool SetTextureCoordinate(int index, float s, float t)","summary":"Sets or adds a texture coordinate to the Texture Coordinate List.  \\nIf [index] is less than [Count], the existing coordinate at [index] will be modified.  \\nIf [index] equals [Count], a new coordinate is appended to the end of the coordinate list.  \\nIf [index] is larger than [Count], the function will return false.","since":"5.0","parameters":[{"name":"index","summary":"Index of texture coordinate to set."},{"name":"s","summary":"S component of texture coordinate."},{"name":"t","summary":"T component of texture coordinate."}],"returns":"True on success, False on failure."},{"signature":"bool SetTextureCoordinate(int index, Point2f tc)","summary":"Sets or adds a texture coordinate to the Texture Coordinate List.  \\nIf [index] is less than [Count], the existing coordinate at [index] will be modified.  \\nIf [index] equals [Count], a new coordinate is appended to the end of the coordinate list.  \\nIf [index] is larger than [Count], the function will return false.","since":"5.0","parameters":[{"name":"index","summary":"Index of texture coordinate to set."},{"name":"tc","summary":"Texture coordinate point."}],"returns":"True on success, False on failure."},{"signature":"bool SetTextureCoordinate(int index, Point3f tc)","summary":"Sets or adds a texture coordinate to the Texture Coordinate List.  \\nIf [index] is less than [Count], the existing coordinate at [index] will be modified.  \\nIf [index] equals [Count], a new coordinate is appended to the end of the coordinate list.  \\nIf [index] is larger than [Count], the function will return false.","since":"5.0","parameters":[{"name":"index","summary":"Index of texture coordinate to set."},{"name":"tc","summary":"Texture coordinate point."}],"returns":"True on success, False on failure."},{"signature":"bool SetTextureCoordinates(Point2f[] textureCoordinates)","summary":"Sets all texture coordinates in one go.","since":"5.0","parameters":[{"name":"textureCoordinates","summary":"Texture coordinates to assign to the mesh."}],"returns":"True on success, False on failure."},{"signature":"bool SetTextureCoordinates(TextureMapping mapping)","summary":"Set all texture coordinates based on a texture mapping function","since":"5.0","parameters":[{"name":"mapping","summary":"The new mapping type."}],"returns":"True on success, False on failure."},{"signature":"float[] ToFloatArray()","summary":"Copies all vertices to a linear array of float in u,v order","since":"6.0","returns":"The float array."},{"signature":"bool TransposeTextureCoordinates()","summary":"Transposes texture coordinates.  \\nThe region of the bitmap the texture uses does not change. All texture coordinates rows (Us) become columns (Vs), and vice versa.","since":"5.0","returns":"True on success, False on failure."}]},{"namespace":"Rhino.Geometry.Collections","name":"MeshTopologyEdgeList","dataType":"class","summary":"Represents an entry point to the list of edges in a mesh topology.","properties":[{"signature":"int Count","summary":"Gets the amount of edges in this list.","since":"5.0","property":["get"]}],"methods":[{"signature":"bool CollapseEdge(int topologyEdgeIndex)","summary":"Replaces a mesh edge with a vertex at its center and update adjacent faces as needed.","since":"5.0","parameters":[{"name":"topologyEdgeIndex","summary":"An index of a topology edge in Mesh.TopologyEdges."}],"returns":"True if successful."},{"signature":"Line EdgeLine(int topologyEdgeIndex)","summary":"Gets the 3d line along an edge.","since":"5.0","parameters":[{"name":"topologyEdgeIndex","summary":"The topology edge index."}],"returns":"Line along edge. If input is not valid, an Invalid Line is returned."},{"signature":"int[] GetConnectedFaces(int topologyEdgeIndex)","summary":"Gets indices of faces connected to an edge.","since":"5.0","parameters":[{"name":"topologyEdgeIndex","summary":"An index of a topology edge that is queried."}],"returns":"An array of face indices the edge borders. This might be empty on error."},{"signature":"int[] GetConnectedFaces(int topologyEdgeIndex, out bool[] faceOrientationMatchesEdgeDirection)","summary":"Gets indices of faces connected to an edge.","since":"5.0","parameters":[{"name":"topologyEdgeIndex","summary":"An index of a topology edge that is queried."},{"name":"faceOrientationMatchesEdgeDirection","summary":"An array of Boolean values that explains whether each face direction matches the direction of the specified edge."}],"returns":"An array of face indices the edge borders. This might be empty on error."},{"signature":"int GetEdgeIndex(int topologyVertex1, int topologyVertex2)","summary":"Returns index of edge that connects topological vertices. returns -1 if no edge is found.","since":"5.0","parameters":[{"name":"topologyVertex1","summary":"The first topology vertex index."},{"name":"topologyVertex2","summary":"The second topology vertex index."}],"returns":"The edge index."},{"signature":"int[] GetEdgesForFace(int faceIndex)","summary":"Gets indices of edges that surround a given face.","since":"5.0","parameters":[{"name":"faceIndex","summary":"A face index."}],"returns":"A new array of indices to the topological edges that are connected with the specified face."},{"signature":"int[] GetEdgesForFace(int faceIndex, out bool[] sameOrientation)","summary":"Gets indices of edges that surround a given face.","since":"5.0","parameters":[{"name":"faceIndex","summary":"A face index."},{"name":"sameOrientation","summary":"Same length as returned edge index array. For each edge, the sameOrientation value tells you if the edge orientation matches the face orientation (true), or is reversed (false) compared to it."}],"returns":"A new array of indices to the topological edges that are connected with the specified face."},{"signature":"IndexPair GetTopologyVertices(int topologyEdgeIndex)","summary":"Gets the two topology vertices for a given topology edge.","since":"5.0","parameters":[{"name":"topologyEdgeIndex","summary":"An index of a topology edge."}],"returns":"The pair of vertex indices the edge connects."},{"signature":"bool IsEdgeUnwelded(int topologyEdgeIndex)","summary":"Determines if the mesh edge is unwelded, or if the mesh faces that share the edge have unique vertex indices.","since":"6.13","parameters":[{"name":"topologyEdgeIndex","summary":"An index of a topology edge in Mesh.TopologyEdges."}],"returns":"True if the edge is unwelded, False if the edge is welded."},{"signature":"bool IsHidden(int topologyEdgeIndex)","summary":"Returns True if the topological edge is hidden. The mesh topology edge is hidden only if either of its mesh topology vertices is hidden.","since":"5.0","parameters":[{"name":"topologyEdgeIndex","summary":"An index of a topology edge in Mesh.TopologyEdges."}],"returns":"True if mesh topology edge is hidden."},{"signature":"bool IsNgonInterior(int topologyEdgeIndex)","summary":"Returns True if the topological edge is an interior ngon edge","since":"6.0","parameters":[{"name":"topologyEdgeIndex","summary":"An index of a topology edge in Mesh.TopologyEdges."}],"returns":"True if mesh topology edge is an interior ngon edge."},{"signature":"bool IsSwappableEdge(int topologyEdgeIndex)","summary":"Determines if a mesh edge index is valid input for SwapEdge.","since":"5.0","parameters":[{"name":"topologyEdgeIndex","summary":"An index of a topology edge in Mesh.TopologyEdges."}],"returns":"True if edge can be swapped."},{"signature":"bool SplitEdge(int topologyEdgeIndex, double t)","summary":"Divides a mesh edge to create two or more triangles","since":"5.0","parameters":[{"name":"topologyEdgeIndex","summary":"Edge to divide"},{"name":"t","summary":"Parameter along edge. This is the same as getting an EdgeLine and calling PointAt(t) on that line"}],"returns":"True if successful"},{"signature":"bool SplitEdge(int topologyEdgeIndex, Point3d point)","summary":"Divides a mesh edge to create two or more triangles","since":"5.0","parameters":[{"name":"topologyEdgeIndex","summary":"Edge to divide"},{"name":"point","summary":"Location to perform the split"}],"returns":"True if successful"},{"signature":"bool SwapEdge(int topologyEdgeIndex)","summary":"If the edge is shared by two triangular face, then the edge is swapped.","since":"5.0","parameters":[{"name":"topologyEdgeIndex","summary":"An index of a topology edge in Mesh.TopologyEdges."}],"returns":"True if successful."}]},{"namespace":"Rhino.Geometry.Collections","name":"MeshTopologyVertexList","dataType":"class","summary":"Provides access to the mesh topology vertices of a mesh. Topology vertices are sets of vertices in the MeshVertexList that can topologically be considered the same vertex.","interfaces":["IEnumerable<Point3f>","IList<Point3f>","IList","IReadOnlyList<Point3f>"],"properties":[{"signature":"int Count","summary":"Gets or sets the number of mesh topology vertices.","since":"5.0","property":["get"]}],"methods":[{"signature":"int ConnectedEdge(int topologyVertexIndex, int edgeAtVertexIndex)","summary":"Gets a particular edge that is connected to a topological vertex.  \\nCall TopologyVertices.SortVertices before this if you are interested in ordered edges.","since":"6.0","parameters":[{"name":"topologyVertexIndex","summary":"Index of a topology vertex in Mesh.TopologyVertices."},{"name":"edgeAtVertexIndex","summary":"Index of the edge at the vertex."}],"returns":"The index of the connected edge."},{"signature":"int[] ConnectedEdges(int topologyVertexIndex)","summary":"Gets all edges that are connected to a given vertex.  \\nCall TopologyVertices.SortVertices before this if you are interested in ordered edges.","since":"6.0","parameters":[{"name":"topologyVertexIndex","summary":"Index of a topology vertex in Mesh.TopologyVertices."}],"returns":"Indices of all edges around vertex that are connected to this topological vertex. None if no faces are connected to this vertex."},{"signature":"int ConnectedEdgesCount(int topologyVertexIndex)","summary":"Gets the count of edges that are connected to a given vertex.","since":"6.0","parameters":[{"name":"topologyVertexIndex","summary":"Index of a topology vertex in Mesh.TopologyVertices."}],"returns":"The amount of edges at this vertex. This can be 0."},{"signature":"int[] ConnectedFaces(int topologyVertexIndex)","summary":"Gets all faces that are connected to a given vertex.","since":"5.0","parameters":[{"name":"topologyVertexIndex","summary":"Index of a topology vertex in Mesh.TopologyVertices."}],"returns":"Indices of all faces in Mesh.Faces that are connected to this topological vertex. None if no faces are connected to this vertex."},{"signature":"int[] ConnectedTopologyVertices(int topologyVertexIndex)","summary":"Gets all topological vertices that are connected to a given vertex.","since":"5.0","parameters":[{"name":"topologyVertexIndex","summary":"index of a topology vertex in Mesh.TopologyVertices."}],"returns":"Indices of all topological vertices that are connected to this topological vertex. None if no vertices are connected to this vertex."},{"signature":"int[] ConnectedTopologyVertices(int topologyVertexIndex, bool sorted)","summary":"Gets all topological vertices that are connected to a given vertex.","since":"5.0","parameters":[{"name":"topologyVertexIndex","summary":"index of a topology vertex in Mesh.TopologyVertices."},{"name":"sorted","summary":"if true, the vertices are returned in a radially sorted order."}],"returns":"Indices of all topological vertices that are connected to this topological vertex. None if no vertices are connected to this vertex."},{"signature":"IEnumerator<Point3f> GetEnumerator()","summary":"Gets an enumerator that yields all topology vertices in this collection.","since":"5.0","returns":"The enumerator."},{"signature":"int[] IndicesFromFace(int faceIndex)","summary":"Returns TopologyVertexIndices for a given mesh face index.","since":"5.0","parameters":[{"name":"faceIndex","summary":"The index of a face to query."}],"returns":"An array of vertex indices."},{"signature":"bool IsHidden(int topologyVertexIndex)","summary":"Returns True if the topological vertex is hidden. The mesh topology vertex is hidden if and only if all the ON_Mesh vertices it represents is hidden.","since":"5.0","parameters":[{"name":"topologyVertexIndex","summary":"index of a topology vertex in Mesh.TopologyVertices."}],"returns":"True if mesh topology vertex is hidden."},{"signature":"int[] MeshVertexIndices(int topologyVertexIndex)","summary":"Gets all indices of the mesh vertices that a given topology vertex represents.","since":"5.0","parameters":[{"name":"topologyVertexIndex","summary":"Index of a topology vertex in Mesh.TopologyVertices to query."}],"returns":"Indices of all vertices that in Mesh.Vertices that a topology vertex represents."},{"signature":"bool SortEdges()","summary":"Sorts the edge list for the mesh topology vertex list so that the edges are in radial order when you call ConnectedTopologyVertices. A non-manifold edge is treated as a boundary edge with respect to sorting.  If any boundary or non-manifold edges end at the vertex, then the first edge will be a boundary or non-manifold edge.","since":"5.0","returns":"True on success."},{"signature":"bool SortEdges(int topologyVertexIndex)","summary":"Sorts the edge list for as single mesh topology vertex so that the edges are in radial order when you call ConnectedTopologyVertices. A non-manifold edge is treated as a boundary edge with respect to sorting.  If any boundary or non-manifold edges end at the vertex, then the first edge will be a boundary or non-manifold edge.","since":"5.0","parameters":[{"name":"topologyVertexIndex","summary":"index of a topology vertex in Mesh.TopologyVertices>"}],"returns":"True on success."},{"signature":"int TopologyVertexIndex(int vertexIndex)","summary":"Gets the topology vertex index for an existing mesh vertex in the mesh\'s VertexList.","since":"5.0","parameters":[{"name":"vertexIndex","summary":"Index of a vertex in the Mesh.Vertices."}],"returns":"Index of a topology vertex in the Mesh.TopologyVertices."}]},{"namespace":"Rhino.Geometry.Collections","name":"MeshVertexColorList","dataType":"class","summary":"Provides access to the vertex colors of a mesh object.","interfaces":["IResizableList<Color>","IList","IReadOnlyList<Color>"],"properties":[{"signature":"int Capacity","summary":"Gets or sets the total number of vertex colors the internal data structure can hold without resizing.","since":"6.0","property":["get","set"]},{"signature":"int Count","summary":"Gets or sets the number of mesh colors.","since":"5.0","property":["get","set"]},{"signature":"MappingTag Tag","summary":"Gets or sets a mapping information for the mesh associated with these vertex colors.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"int Add(Color color)","summary":"Adds a new vertex color to the end of the color list.","since":"5.0","parameters":[{"name":"color","summary":"Color to append, Alpha channels will be ignored."}],"returns":"The index of the newly added color."},{"signature":"int Add(int red, int green, int blue)","summary":"Adds a new vertex color to the end of the color list.","since":"5.0","parameters":[{"name":"red","summary":"Red component of color, must be in the 0~255 range."},{"name":"green","summary":"Green component of color, must be in the 0~255 range."},{"name":"blue","summary":"Blue component of color, must be in the 0~255 range."}],"returns":"The index of the newly added color."},{"signature":"bool AppendColors(Color[] colors)","summary":"Appends a collection of colors to the vertex color list. For the Mesh to be valid, the number of colors must match the number of vertices.","since":"5.0","parameters":[{"name":"colors","summary":"Colors to append."}],"returns":"True on success, False on failure."},{"signature":"void Clear()","summary":"Clears the vertex color list on the mesh.","since":"5.0"},{"signature":"bool CreateMonotoneMesh(Color baseColor)","summary":"Constructs a valid vertex color list consisting of a single color.","since":"5.0","parameters":[{"name":"baseColor","summary":"Color to apply to every vertex."}],"returns":"True on success, False on failure."},{"signature":"void Destroy()","summary":"Releases all memory allocated to store vertex colors. The list capacity will be 0 after this call.  \\nSubsequent calls can add new items.","since":"6.0"},{"signature":"IEnumerator<Color> GetEnumerator()","summary":"Gets an enumerator that yields all colors in this collection.","since":"5.0","returns":"The enumerator."},{"signature":"bool SetColor(int index, Color color)","summary":"Sets or adds a vertex to the Vertex List.  \\nIf [index] is less than [Count], the existing vertex at [index] will be modified.  \\nIf [index] equals [Count], a new vertex is appended to the end of the vertex list.  \\nIf [index] is larger than [Count], the function will return false.","since":"5.0","parameters":[{"name":"index","summary":"Index of vertex color to set. If index equals Count, then the color will be appended."},{"name":"color","summary":"Color to set, Alpha channels will be ignored."}],"returns":"True on success, False on failure."},{"signature":"bool SetColor(int index, int red, int green, int blue)","summary":"Sets or adds a vertex color to the color List.  \\nIf [index] is less than [Count], the existing vertex at [index] will be modified.  \\nIf [index] equals [Count], a new vertex is appended to the end of the vertex list.  \\nIf [index] is larger than [Count], the function will return false.","since":"5.0","parameters":[{"name":"index","summary":"Index of vertex color to set. If index equals Count, then the color will be appended."},{"name":"red","summary":"Red component of vertex color. Value must be in the 0~255 range."},{"name":"green","summary":"Green component of vertex color. Value must be in the 0~255 range."},{"name":"blue","summary":"Blue component of vertex color. Value must be in the 0~255 range."}],"returns":"True on success, False on failure."},{"signature":"bool SetColor(MeshFace face, Color color)","summary":"Sets a color at the three or four vertex indices of a specified face.","since":"5.0","parameters":[{"name":"face","summary":"A face to use to retrieve indices."},{"name":"color","summary":"A color."}],"returns":"True on success; False on error."},{"signature":"bool SetColors(Color[] colors)","summary":"Sets all the vertex colors in one go. For the Mesh to be valid, the number of colors must match the number of vertices.","since":"5.0","parameters":[{"name":"colors","summary":"Colors to set."}],"returns":"True on success, False on failure."},{"signature":"int[] ToARGBArray()","summary":"Return colors as an array of integers with packed ARGB values","since":"7.0"}]},{"namespace":"Rhino.Geometry.Collections","name":"MeshVertexList","dataType":"class","summary":"Provides access to the vertices and vertex-related functionality of a mesh.","interfaces":["IResizableList<Point3f>","IReadOnlyList<Point3f>","IList"],"properties":[{"signature":"int Capacity","summary":"Gets or sets the total number of vertices the internal data structure can hold without resizing.","since":"6.0","property":["get","set"]},{"signature":"int Count","summary":"Gets or sets the number of mesh vertices.","since":"5.0","property":["get","set"]},{"signature":"bool UseDoublePrecisionVertices","summary":"Set to True if the vertices should be stored in double precision","since":"6.4","property":["get","set"]}],"methods":[{"signature":"static int Align(IEnumerable<Mesh> meshes, double distance, IEnumerable<IEnumerable<bool>> whichVertices)","summary":"Moves mesh vertices that belong to naked edges to neighboring vertices, within the specified distance.  \\nThis forces unaligned mesh vertices to the same location and is helpful to clean meshes for 3D printing.  \\nSee the _AlignMeshVertices Rhino command for more information.","parameters":[{"name":"meshes","summary":"The enumerable of meshes that need to have vertices adjusted."},{"name":"distance","summary":"Distance that should not be exceed when modifying the mesh."},{"name":"whichVertices","summary":"If not null, defines which vertices should be considered for adjustment.  \\nIf this parameter is non-null, then all items within it have to be non-None as well, defining for each mesh, which vertices to adjust."}],"returns":"If the operation succeeded, the number of moved vertices, or -1 on error."},{"signature":"int Add(double x, double y, double z)","summary":"Adds a new vertex to the end of the Vertex list.","since":"5.0","parameters":[{"name":"x","summary":"X component of new vertex coordinate."},{"name":"y","summary":"Y component of new vertex coordinate."},{"name":"z","summary":"Z component of new vertex coordinate."}],"returns":"The index of the newly added vertex."},{"signature":"int Add(float x, float y, float z)","summary":"Adds a new vertex to the end of the Vertex list.","since":"5.0","parameters":[{"name":"x","summary":"X component of new vertex coordinate."},{"name":"y","summary":"Y component of new vertex coordinate."},{"name":"z","summary":"Z component of new vertex coordinate."}],"returns":"The index of the newly added vertex."},{"signature":"int Add(Point3d vertex)","summary":"Adds a new vertex to the end of the Vertex list.","since":"5.0","parameters":[{"name":"vertex","summary":"Location of new vertex."}],"returns":"The index of the newly added vertex."},{"signature":"int Add(Point3f vertex)","summary":"Adds a new vertex to the end of the Vertex list.","since":"5.0","parameters":[{"name":"vertex","summary":"Location of new vertex."}],"returns":"The index of the newly added vertex."},{"signature":"void AddVertices(IEnumerable<Point3d> vertices)","summary":"Adds a series of new vertices to the end of the vertex list.  \\nThis overload accepts double-precision points.","since":"5.0","parameters":[{"name":"vertices","summary":"A list, an array or any enumerable set of Point3d."}]},{"signature":"void AddVertices(IEnumerable<Point3f> vertices)","summary":"Adds a series of new vertices to the end of the vertex list.  \\nThis overload accepts single-precision points.","since":"5.0","parameters":[{"name":"vertices","summary":"A list, an array or any enumerable set of Point3f."}]},{"signature":"int Align(double distance, IEnumerable<bool> whichVertices)","summary":"Moves mesh vertices that belong to naked edges to neighboring vertices, within the specified distance.  \\nThis forces unaligned mesh vertices to the same location and is helpful to clean meshes for 3D printing.  \\nSee the _AlignMeshVertices Rhino command for more information.","since":"6.0","parameters":[{"name":"distance","summary":"Distance that should not be exceed when modifying the mesh."},{"name":"whichVertices","summary":"If not null, defines which vertices should be considered for adjustment."}],"returns":"If the operation succeeded, the number of moved vertices, or -1 on error."},{"signature":"void Clear()","summary":"Clears the Vertex list on the mesh.","since":"5.0"},{"signature":"bool CombineIdentical(bool ignoreNormals, bool ignoreAdditional)","summary":"Merges identical vertices.","since":"5.0","parameters":[{"name":"ignoreNormals","summary":"If true, vertex normals will not be taken into consideration when comparing vertices."},{"name":"ignoreAdditional","summary":"If true, texture coordinates, colors, and principal curvatures will not be taken into consideration when comparing vertices."}],"returns":"True if the mesh is changed, in which case the mesh will have fewer vertices than before."},{"signature":"int CullUnused()","summary":"Removes all vertices that are currently not used by the Face list.","since":"5.0","returns":"The number of unused vertices that were removed."},{"signature":"void Destroy()","summary":"Releases all memory allocated to store faces. The list capacity will be 0 after this call.  \\nSubsequent calls can add new items.","since":"6.0"},{"signature":"int[] GetConnectedVertices(int vertexIndex)","summary":"Gets indices of all vertices that form \\"edges\\" with a given vertex index.","since":"5.0","parameters":[{"name":"vertexIndex","summary":"The index of a vertex to query."}],"returns":"An array of vertex indices that are connected with the specified vertex."},{"signature":"IEnumerator<Point3f> GetEnumerator()","summary":"Gets an enumerator that yields all mesh vertices (points) in this collection.","since":"5.0","returns":"The enumerator."},{"signature":"int[] GetTopologicalIndenticalVertices(int vertexIndex)","summary":"Gets a list of other vertices which are \\"topologically\\" identical to this vertex.","since":"5.0","parameters":[{"name":"vertexIndex","summary":"A vertex index in the mesh."}],"returns":"Array of indices of vertices that are topologically the same as this vertex. The array includes vertexIndex. Returns None on failure."},{"signature":"int[] GetVertexFaces(int vertexIndex)","summary":"Gets a list of all of the faces that share a given vertex.","since":"5.0","parameters":[{"name":"vertexIndex","summary":"The index of a vertex in the mesh."}],"returns":"An array of indices of faces on success, None on failure."},{"signature":"void Hide(int vertexIndex)","summary":"Hides the vertex at the given index.","since":"5.0","parameters":[{"name":"vertexIndex","summary":"Index of vertex to hide."}]},{"signature":"void HideAll()","summary":"Hides all vertices in the mesh.","since":"5.0"},{"signature":"bool IsHidden(int vertexIndex)","summary":"Gets a value indicating whether or not a vertex is hidden.","since":"5.0","parameters":[{"name":"vertexIndex","summary":"Index of vertex to query."}],"returns":"True if the vertex is hidden, False if it is not."},{"signature":"Point3d Point3dAt(int index)","summary":"Get double precision location at a given index","since":"6.4"},{"signature":"bool Remove(IEnumerable<int> indices, bool shrinkFaces)","summary":"Removes the vertices at the given indices and all faces that reference those vertices.","since":"5.0","parameters":[{"name":"indices","summary":"Vertex indices to remove."},{"name":"shrinkFaces","summary":"If true, quads that reference the deleted vertex will be converted to triangles."}],"returns":"True on success, False on failure."},{"signature":"bool Remove(int index, bool shrinkFaces)","summary":"Removes the vertex at the given index and all faces that reference that index.","since":"5.0","parameters":[{"name":"index","summary":"Index of vertex to remove."},{"name":"shrinkFaces","summary":"If true, quads that reference the deleted vertex will be converted to triangles."}],"returns":"True on success, False on failure."},{"signature":"bool SetVertex(int index, double x, double y, double z)","summary":"Sets or adds a vertex to the Vertex List.  \\nIf [index] is less than [Count], the existing vertex at [index] will be modified.  \\nIf [index] equals [Count], a new vertex is appended to the end of the vertex list.  \\nIf [index] is larger than [Count], the function will return false.","since":"5.0","parameters":[{"name":"index","summary":"Index of vertex to set."},{"name":"x","summary":"X component of vertex location."},{"name":"y","summary":"Y component of vertex location."},{"name":"z","summary":"Z component of vertex location."}],"returns":"True on success, False on failure."},{"signature":"bool SetVertex(int index, double x, double y, double z, bool updateNormals)","summary":"Sets or adds a vertex to the Vertex List.  \\nIf [index] is less than [Count], the existing vertex at [index] will be modified.  \\nIf [index] equals [Count], a new vertex is appended to the end of the vertex list.  \\nIf [index] is larger than [Count], the function will return false.","since":"6.6","parameters":[{"name":"index","summary":"Index of vertex to set."},{"name":"x","summary":"X component of vertex location."},{"name":"y","summary":"Y component of vertex location."},{"name":"z","summary":"Z component of vertex location."},{"name":"updateNormals","summary":"Set to True if you\'d like the vertex and face normals impacted by the change updated."}],"returns":"True on success, False on failure."},{"signature":"bool SetVertex(int index, float x, float y, float z)","summary":"Sets or adds a vertex to the Vertex List.  \\nIf [index] is less than [Count], the existing vertex at [index] will be modified.  \\nIf [index] equals [Count], a new vertex is appended to the end of the vertex list.  \\nIf [index] is larger than [Count], the function will return false.","since":"5.0","parameters":[{"name":"index","summary":"Index of vertex to set."},{"name":"x","summary":"X component of vertex location."},{"name":"y","summary":"Y component of vertex location."},{"name":"z","summary":"Z component of vertex location."}],"returns":"True on success, False on failure."},{"signature":"bool SetVertex(int index, Point3d vertex)","summary":"Sets or adds a vertex to the Vertex List.  \\nIf [index] is less than [Count], the existing vertex at [index] will be modified.  \\nIf [index] equals [Count], a new vertex is appended to the end of the vertex list.  \\nIf [index] is larger than [Count], the function will return false.","since":"5.0","parameters":[{"name":"index","summary":"Index of vertex to set."},{"name":"vertex","summary":"Vertex location."}],"returns":"True on success, False on failure."},{"signature":"bool SetVertex(int index, Point3f vertex)","summary":"Sets or adds a vertex to the Vertex List.  \\nIf [index] is less than [Count], the existing vertex at [index] will be modified.  \\nIf [index] equals [Count], a new vertex is appended to the end of the vertex list.  \\nIf [index] is larger than [Count], the function will return false.","since":"5.0","parameters":[{"name":"index","summary":"Index of vertex to set."},{"name":"vertex","summary":"Vertex location."}],"returns":"True on success, False on failure."},{"signature":"void Show(int vertexIndex)","summary":"Shows the vertex at the given index.","since":"5.0","parameters":[{"name":"vertexIndex","summary":"Index of vertex to show."}]},{"signature":"void ShowAll()","summary":"Shows all vertices in the mesh.","since":"5.0"},{"signature":"float[] ToFloatArray()","summary":"Copies all vertices to a linear array of float in x,y,z order","since":"5.9","returns":"The float array."},{"signature":"Point3d[] ToPoint3dArray()","summary":"Copies all vertices to a new array of Point3d.","since":"5.0","returns":"A new array."},{"signature":"Point3f[] ToPoint3fArray()","summary":"Copies all vertices to a new array of Point3f.","since":"5.0","returns":"A new array."}]},{"namespace":"Rhino.Geometry.Collections","name":"MeshVertexNormalList","dataType":"class","summary":"Provides access to the Vertex Normals of a Mesh.","interfaces":["IResizableList<Vector3f>","IList","IReadOnlyList<Vector3f>"],"properties":[{"signature":"int Capacity","summary":"Gets or sets the amount of vertex normals that the list can hold without resizing.","since":"6.0","property":["get","set"]},{"signature":"int Count","summary":"Gets or sets the number of mesh vertex normals.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"int Add(double x, double y, double z)","summary":"Adds a new vertex normal at the end of the list.","since":"5.0","parameters":[{"name":"x","summary":"X component of new vertex normal."},{"name":"y","summary":"Y component of new vertex normal."},{"name":"z","summary":"Z component of new vertex normal."}],"returns":"The index of the newly added vertex normal."},{"signature":"int Add(float x, float y, float z)","summary":"Adds a new vertex normal at the end of the list.","since":"5.0","parameters":[{"name":"x","summary":"X component of new vertex normal."},{"name":"y","summary":"Y component of new vertex normal."},{"name":"z","summary":"Z component of new vertex normal."}],"returns":"The index of the newly added vertex normal."},{"signature":"int Add(Vector3d normal)","summary":"Adds a new vertex normal at the end of the list.","since":"5.0","parameters":[{"name":"normal","summary":"new vertex normal."}],"returns":"The index of the newly added vertex normal."},{"signature":"int Add(Vector3f normal)","summary":"Adds a new vertex normal at the end of the list.","since":"5.0","parameters":[{"name":"normal","summary":"new vertex normal."}],"returns":"The index of the newly added vertex normal."},{"signature":"bool AddRange(Vector3f[] normals)","summary":"Appends a collection of normal vectors.","since":"5.0","parameters":[{"name":"normals","summary":"Normals to append."}],"returns":"True on success, False on failure."},{"signature":"void Clear()","summary":"Clears the vertex normal collection on the mesh.","since":"5.0"},{"signature":"bool ComputeNormals()","summary":"Computes the vertex normals based on the physical shape of the mesh.","since":"5.0","returns":"True on success, False on failure."},{"signature":"void Destroy()","summary":"Releases all memory allocated to store vertex normals. The list capacity will be 0 after this call.  \\nSubsequent calls can add new items.","since":"6.0"},{"signature":"void Flip()","summary":"Reverses direction of all vertex normals  \\nThis is the same as Mesh.Flip(true, false, false)","since":"5.0"},{"signature":"IEnumerator<Vector3f> GetEnumerator()","summary":"Gets an enumerator that yields all normals (vectors) in this collection.","since":"5.0","returns":"The enumerator."},{"signature":"bool SetNormal(int index, double x, double y, double z)","summary":"Sets or adds a vertex normal to the list.  \\nIf [index] is less than [Count], the existing vertex normal at [index] will be modified.  \\nIf [index] equals [Count], a new vertex normal is appended to the end of the list.  \\nIf [index] is larger than [Count], the function will return false.","since":"5.0","parameters":[{"name":"index","summary":"Index of vertex normal to set."},{"name":"x","summary":"X component of vertex normal."},{"name":"y","summary":"Y component of vertex normal."},{"name":"z","summary":"Z component of vertex normal."}],"returns":"True on success, False on failure."},{"signature":"bool SetNormal(int index, float x, float y, float z)","summary":"Sets or adds a normal to the list.  \\nIf [index] is less than [Count], the existing vertex normal at [index] will be modified.  \\nIf [index] equals [Count], a new vertex normal is appended to the end of the list.  \\nIf [index] is larger than [Count], the function will return false.","since":"5.0","parameters":[{"name":"index","summary":"Index of vertex normal to set."},{"name":"x","summary":"X component of vertex normal."},{"name":"y","summary":"Y component of vertex normal."},{"name":"z","summary":"Z component of vertex normal."}],"returns":"True on success, False on failure."},{"signature":"bool SetNormal(int index, Vector3d normal)","summary":"Sets or adds a vertex normal to the list.  \\nIf [index] is less than [Count], the existing vertex normal at [index] will be modified.  \\nIf [index] equals [Count], a new vertex normal is appended to the end of the list.  \\nIf [index] is larger than [Count], the function will return false.","since":"5.0","parameters":[{"name":"index","summary":"Index of vertex normal to set."},{"name":"normal","summary":"The new normal at the index."}],"returns":"True on success, False on failure."},{"signature":"bool SetNormal(int index, Vector3f normal)","summary":"Sets or adds a vertex normal to the list.  \\nIf [index] is less than [Count], the existing vertex normal at [index] will be modified.  \\nIf [index] equals [Count], a new vertex normal is appended to the end of the vertex list.  \\nIf [index] is larger than [Count], the function will return false.","since":"5.0","parameters":[{"name":"index","summary":"Index of vertex normal to set."},{"name":"normal","summary":"The new normal at the index."}],"returns":"True on success, False on failure."},{"signature":"bool SetNormals(Vector3f[] normals)","summary":"Sets all normal vectors in one go. This method destroys the current normal array if it exists.","since":"5.0","parameters":[{"name":"normals","summary":"Normals for the entire mesh."}],"returns":"True on success, False on failure."},{"signature":"float[] ToFloatArray()","summary":"Copies all vertex normals to a linear array of float in x,y,z order","since":"6.0","returns":"The float array."},{"signature":"bool UnitizeNormals()","summary":"Unitizes all vertex normals.","since":"5.0","returns":"True on success, False on failure."}]},{"namespace":"Rhino.Geometry.Collections","name":"MeshVertexStatusList","dataType":"class","summary":"Provides access to status information relative to components of a mesh.","interfaces":["IResizableList<bool>","IList","IReadOnlyList<bool>"],"properties":[{"signature":"int Capacity","summary":"Gets or sets the total number of hidden vertex information the internal data structure can hold without resizing.","since":"6.0","property":["get","set"]},{"signature":"int Count","summary":"Gets or sets the number of hidden vertices. For this to be a valid part of a mesh, this count should be the same as the one of mesh vertices.","since":"6.0","property":["get","set"]},{"signature":"int HiddenCount","summary":"Gets a value indicating how many vertices have been set to hidden.","since":"6.0","property":["get"]}],"methods":[{"signature":"void Add(bool hidden)","summary":"Adds a new flag at the end of the list.","since":"6.0","parameters":[{"name":"hidden","summary":"True if vertex is hidden."}],"returns":"The index of the newly added hidden vertex."},{"signature":"void AddRange(IEnumerable<bool> values)","summary":"Appends an array, a list or any enumerable of flags to the end of the list.","since":"6.0","parameters":[{"name":"values","summary":"Hidden values to append."}],"returns":"True on success, False on failure."},{"signature":"void Clear()","summary":"Clears the hidden vertex list on the mesh. This results in a fully visible mesh.","since":"6.0"},{"signature":"bool Contains(bool hidden)","summary":"Determines if some vertices are hidden or some are shown.","since":"6.0","parameters":[{"name":"hidden","summary":"The value to be checked. True means some vertex is hidden."}],"returns":"True if the array contains the specified value."},{"signature":"void CopyTo(bool[] array, int arrayIndex)","summary":"Copies to an array, starting at an index.","since":"6.0","parameters":[{"name":"array","summary":"The array to be copied into."},{"name":"arrayIndex","summary":"The starting index in the array."}]},{"signature":"void Destroy()","summary":"Releases all memory allocated to store hidden vertices. The list capacity will be 0 after this call.  \\nVertices will be immediately considered visible.  \\nSubsequent calls can add new items.","since":"6.0"},{"signature":"IEnumerator<bool> GetEnumerator()","summary":"Gets an enumerator that yields all flags in this collection.","since":"6.0","returns":"The enumerator."}]},{"namespace":"Rhino.Geometry.Collections","name":"NurbsCurveKnotList","dataType":"class","summary":"Provides access to the knot vector of a NURBS curve.","interfaces":["IEnumerable<double>","IRhinoTable<double>","IEpsilonComparable<NurbsCurveKnotList>","IList<double>"],"properties":[{"signature":"int Count","summary":"Total number of knots in this curve.","since":"5.0","property":["get"]},{"signature":"bool IsClampedEnd","summary":"Gets a value indicating whether or not the knot vector is clamped at the end of the curve. Clamped curves are coincident with the first and last control-point. This requires fully multiple knots.","since":"5.0","property":["get"]},{"signature":"bool IsClampedStart","summary":"Gets a value indicating whether or not the knot vector is clamped at the start of the curve. Clamped curves start at the first control-point. This requires fully multiple knots.","since":"5.0","property":["get"]}],"methods":[{"signature":"bool ClampEnd(CurveEnd end)","summary":"Clamp end knots. Does not modify control point locations.","since":"5.0","parameters":[{"name":"end","summary":"Curve end to clamp."}],"returns":"True on success, False on failure."},{"signature":"bool Contains(double item)","summary":"Returns an indication of the presence of a value in the knot list.","since":"6.0","parameters":[{"name":"item","summary":"The item."}],"returns":"True if present, False otherwise."},{"signature":"void CopyTo(double[] array, int arrayIndex)","summary":"Copies the list to an array.","since":"6.0","parameters":[{"name":"array","summary":"The array to copy to."},{"name":"arrayIndex","summary":"The index into copy will begin."}]},{"signature":"bool CreatePeriodicKnots(double knotSpacing)","summary":"Compute a clamped, uniform, periodic knot vector based on the current degree and control point count. Does not change values of control vertices.","since":"5.0","parameters":[{"name":"knotSpacing","summary":"Spacing of subsequent knots."}],"returns":"True on success, False on failure."},{"signature":"bool CreateUniformKnots(double knotSpacing)","summary":"Compute a clamped, uniform knot vector based on the current degree and control point count. Does not change values of control vertices.","since":"5.0","parameters":[{"name":"knotSpacing","summary":"Spacing of subsequent knots."}],"returns":"True on success, False on failure."},{"signature":"void EnsurePrivateCopy()","summary":"If you want to keep a copy of this class around by holding onto it in a variable after a command completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can call this function as many times as you want.","since":"5.0"},{"signature":"bool EpsilonEquals(NurbsCurveKnotList other, double epsilon)","summary":"Checks that all values in the other list are sequentially equal within epsilon to the values in this list.","since":"5.4","parameters":[{"name":"other","summary":"The other list."},{"name":"epsilon","summary":"The epsilon value."}],"returns":"True if values are, orderly, equal within epsilon. False otherwise."},{"signature":"int IndexOf(double item)","summary":"Returns the first item in the list.","since":"6.0","parameters":[{"name":"item","summary":"The value."}],"returns":"The index, or -1 if no index is found."},{"signature":"bool InsertKnot(double value)","summary":"Inserts a knot and update control point locations. Does not change parameterization or locus of curve.","since":"5.0","parameters":[{"name":"value","summary":"Knot value to insert."}],"returns":"True on success, False on failure."},{"signature":"bool InsertKnot(double value, int multiplicity)","summary":"Inserts a knot and update control point locations. Does not change parameterization or locus of curve.","since":"5.0","parameters":[{"name":"value","summary":"Knot value to insert."},{"name":"multiplicity","summary":"Multiplicity of knot to insert."}],"returns":"True on success, False on failure."},{"signature":"int KnotMultiplicity(int index)","summary":"Get knot multiplicity.","since":"5.0","parameters":[{"name":"index","summary":"Index of knot to query."}],"returns":"The multiplicity (valence) of the knot."},{"signature":"KnotStyle KnotStyle()","summary":"Used to determine properties of the knot vector.","since":"7.0","returns":"The knot style."},{"signature":"bool RemoveKnotAt(double t)","summary":"Remove a knot from a curve and adjusts the remaining control points to maintain curve position as closely as possible.","since":"6.0","parameters":[{"name":"t","summary":"The parameter on the curve that is closest to the knot to be removed."}],"returns":"True if successful, False on failure."},{"signature":"bool RemoveKnots(int index0, int index1)","summary":"Remove knots from a curve and adjusts the remaining control points to maintain curve position as closely as possible. The knots from Knots[index0] through Knots[index1 - 1] will be removed.","since":"6.0","parameters":[{"name":"index0","summary":"The starting knot index, where Degree-1 < index0 < index1 <= Points.Count-1."},{"name":"index1","summary":"The ending knot index, where Degree-1 < index0 < index1 <= Points.Count-1."}],"returns":"True if successful, False on failure."},{"signature":"int RemoveMultipleKnots(int minimumMultiplicity, int maximumMultiplicity, double tolerance)","summary":"Remove multiple knots from this curve.","since":"6.0","parameters":[{"name":"minimumMultiplicity","summary":"Remove knots with multiplicity > minimumKnotMultiplicity."},{"name":"maximumMultiplicity","summary":"Remove knots with multiplicity < maximumKnotMultiplicity."},{"name":"tolerance","summary":"When you remove knots, the shape of the curve is changed. If tolerance is RhinoMath.UnsetValue, any amount of change is permitted. If tolerance is >=0, the maximum distance between the input and output curve is restricted to be <= tolerance."}],"returns":"number of knots removed on success. 0 if no knots were removed"},{"signature":"double SuperfluousKnot(bool start)","summary":"Computes the knots that are superfluous because they are not used in NURBs evaluation. These make it appear so that the first and last curve spans are different from interior spans.  \\nhttp://wiki.mcneel.com/developer/onsuperfluousknot","since":"5.0","parameters":[{"name":"start","summary":"True if the query targets the first knot. Otherwise, the last knot."}],"returns":"A component."}]},{"namespace":"Rhino.Geometry.Collections","name":"NurbsCurvePointList","dataType":"class","summary":"Provides access to the control points of a NURBS curve.","interfaces":["IEnumerable<ControlPoint>","IRhinoTable<ControlPoint>","IEpsilonComparable<NurbsCurvePointList>","IList<ControlPoint>"],"properties":[{"signature":"double ControlPolygonLength","summary":"Gets the length of the polyline connecting all control points.","since":"5.0","property":["get"]},{"signature":"int Count","summary":"Gets the number of control points in this curve.","since":"5.0","property":["get"]},{"signature":"int PointSize","summary":"Returns the control point size, or the number of doubles per control point. For rational curves, PointSize = Curve.Dimension + 1. For non-rational curves, PointSize = Curve.Dimension.","since":"6.9","property":["get"]}],"methods":[{"signature":"bool ChangeEndWeights(double w0, double w1)","summary":"Use a combination of scaling and reparameterization to change the end weights to the specified values.","since":"5.0","parameters":[{"name":"w0","summary":"Weight for first control point."},{"name":"w1","summary":"Weight for last control point."}],"returns":"True on success, False on failure."},{"signature":"bool Contains(ControlPoint item)","summary":"Determines if this list contains an item.","since":"6.0","parameters":[{"name":"item","summary":"The exact item to search for."}],"returns":"A boolean value."},{"signature":"Polyline ControlPolygon()","summary":"Constructs a polyline through all the control points. Note that periodic curves generate a closed polyline withfewer points than control-points.","since":"5.0","returns":"A polyline connecting all control points."},{"signature":"void CopyTo(ControlPoint[] array, int arrayIndex)","summary":"Copied the list to an array.","since":"6.0","parameters":[{"name":"array","summary":"The array to copy to."},{"name":"arrayIndex","summary":"The index in which the copy will begin."}]},{"signature":"void EnsurePrivateCopy()","summary":"If you want to keep a copy of this class around by holding onto it in a variable after a command completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can call this function as many times as you want.","since":"5.0"},{"signature":"bool EpsilonEquals(NurbsCurvePointList other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool GetPoint(int index, out Point3d point)","summary":"Gets a world 3-D, or Euclidean, control point at the given index. The 4-D representation is (x, y, z, 1.0).","since":"6.0","parameters":[{"name":"index","summary":"Index of control point to get."},{"name":"point","summary":"Coordinate of control point."}],"returns":"True on success, False on failure."},{"signature":"bool GetPoint(int index, out Point4d point)","summary":"Gets a homogeneous control point at the given index, where the 4-D representation is (x, y, z, w). The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).","since":"6.0","parameters":[{"name":"index","summary":"Index of control point to get."},{"name":"point","summary":"Coordinate and weight of control point."}],"returns":"True on success, False on failure."},{"signature":"double GetWeight(int index)","summary":"Gets the weight of a control point at the given index. Note, if the curve is non-rational, the weight will be 1.0.","since":"6.0","parameters":[{"name":"index","summary":"Index of control point to get."}],"returns":"The control point weight if successful, Rhino.Math.UnsetValue otherwise."},{"signature":"int IndexOf(ControlPoint item)","summary":"Gets the index of a control point, or -1.","since":"6.0","parameters":[{"name":"item","summary":"The exact item to search for."}],"returns":"The index."},{"signature":"bool MakeNonRational()","summary":"Converts the curve to a Non-rational NURBS curve. Non-rational curves have unweighted control points.","since":"5.0","returns":"True on success, False on failure."},{"signature":"bool MakeRational()","summary":"Converts the curve to a Rational NURBS curve. Rational NURBS curves have weighted control points.","since":"5.0","returns":"True on success, False on failure."},{"signature":"bool SetPoint(int index, double x, double y, double z)","summary":"Sets a world 3-D, or Euclidean, control point at the given index. The 4-D representation is (x, y, z, 1.0).","since":"6.0","parameters":[{"name":"index","summary":"Index of control point to set."},{"name":"x","summary":"X coordinate of control point."},{"name":"y","summary":"Y coordinate of control point."},{"name":"z","summary":"Z coordinate of control point."}],"returns":"True on success, False on failure."},{"signature":"bool SetPoint(int index, double x, double y, double z, double weight)","summary":"Sets a homogeneous control point at the given index, where the 4-D representation is (x, y, z, w). The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).","since":"5.0","parameters":[{"name":"index","summary":"Index of control point to set."},{"name":"x","summary":"X coordinate of control point."},{"name":"y","summary":"Y coordinate of control point."},{"name":"z","summary":"Z coordinate of control point."},{"name":"weight","summary":"Weight of control point."}],"returns":"True on success, False on failure."},{"signature":"bool SetPoint(int index, Point3d point)","summary":"Sets a world 3-D, or Euclidean, control point at the given index. The 4-D representation is (x, y, z, 1.0).","since":"5.0","parameters":[{"name":"index","summary":"Index of control point to set."},{"name":"point","summary":"Coordinate of control point."}],"returns":"True on success, False on failure."},{"signature":"bool SetPoint(int index, Point3d point, double weight)","summary":"Sets a world 3-D, or Euclidean, control point and weight at a given index. The 4-D representation is (x*w, y*w, z*w, w).","since":"6.0","parameters":[{"name":"index","summary":"Index of control point to set."},{"name":"point","summary":"Coordinates of the control point."},{"name":"weight","summary":"Weight of control point."}],"returns":"True on success, False on failure."},{"signature":"bool SetPoint(int index, Point4d point)","summary":"Sets a homogeneous control point at the given index, where the 4-D representation is (x, y, z, w). The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).","since":"5.0","parameters":[{"name":"index","summary":"Index of control point to set."},{"name":"point","summary":"Coordinate and weight of control point."}],"returns":"True on success, False on failure."},{"signature":"bool SetWeight(int index, double weight)","summary":"Sets the weight of a control point at the given index Note, if the curve is non-rational, it will be converted to rational.","since":"6.0","parameters":[{"name":"index","summary":"Index of control point to set."},{"name":"weight","summary":"The control point weight."}],"returns":"True if successful, False otherwise."},{"signature":"bool UVNDirectionsAt(int index, out Vector3d uDir, out Vector3d vDir, out Vector3d nDir)","summary":"Calculates the U, V, and N directions of a NURBS curve control point similar to the method used by Rhino\'s MoveUVN command.","since":"7.0","parameters":[{"name":"index","summary":"Index of control point."},{"name":"uDir","summary":"The U direction."},{"name":"vDir","summary":"The V direction."},{"name":"nDir","summary":"The N direction."}],"returns":"True if successful, False otherwise."},{"signature":"bool ValidateSpacing(double closeTolerance, double stackTolerance, out int[] closeIndices, out int[] stackedIndices)","summary":"Simple check of distance between adjacent control points","since":"6.0","parameters":[{"name":"closeTolerance","summary":"tolerance to use for determining if control points are \'close\'"},{"name":"stackTolerance","summary":"tolerance to use for determining if control points are \'stacked\'"},{"name":"closeIndices","summary":"indices of \'close\' points are returned in this array"},{"name":"stackedIndices","summary":"indices of \'stacked\' points are returned in this array"}],"returns":"True if close or stacked indices are found"}]},{"namespace":"Rhino.Geometry.Collections","name":"NurbsSurfaceKnotList","dataType":"class","summary":"Provides access to the knot vector of a NURBS surface.","interfaces":["IEnumerable<double>","Rhino.Collections.IRhinoTable<double>","IEpsilonComparable<NurbsSurfaceKnotList>"],"properties":[{"signature":"bool ClampedAtEnd","summary":"Determines if a knot vector is clamped.","since":"5.0","property":["get"]},{"signature":"bool ClampedAtStart","summary":"Determines if a knot vector is clamped.","since":"5.0","property":["get"]},{"signature":"int Count","summary":"Gets the total number of knots in this curve.","since":"5.0","property":["get"]}],"methods":[{"signature":"bool CreatePeriodicKnots(double knotSpacing)","summary":"Compute a clamped, uniform, periodic knot vector based on the current degree and control point count. Does not change values of control vertices.","since":"5.0","parameters":[{"name":"knotSpacing","summary":"Spacing of subsequent knots."}],"returns":"True on success, False on failure."},{"signature":"bool CreateUniformKnots(double knotSpacing)","summary":"Compute a clamped, uniform knot vector based on the current degree and control point count. Does not change values of control vertices.","since":"5.0","parameters":[{"name":"knotSpacing","summary":"Spacing of subsequent knots."}],"returns":"True on success, False on failure."},{"signature":"void EnsurePrivateCopy()","summary":"If you want to keep a copy of this class around by holding onto it in a variable after a command completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can call this function as many times as you want.","since":"5.0"},{"signature":"bool EpsilonEquals(NurbsSurfaceKnotList other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool InsertKnot(double value)","summary":"Inserts a knot and update control point locations. Does not change parameterization or locus of curve.","since":"5.0","parameters":[{"name":"value","summary":"Knot value to insert."}],"returns":"True on success, False on failure."},{"signature":"bool InsertKnot(double value, int multiplicity)","summary":"Inserts a knot and update control point locations. Does not change parameterization or locus of curve.","since":"5.0","parameters":[{"name":"value","summary":"Knot value to insert."},{"name":"multiplicity","summary":"Multiplicity of knot to insert."}],"returns":"True on success, False on failure."},{"signature":"int KnotMultiplicity(int index)","summary":"Get knot multiplicity.","since":"5.0","parameters":[{"name":"index","summary":"Index of knot to query."}],"returns":"The multiplicity (valence) of the knot."},{"signature":"KnotStyle KnotStyle()","summary":"Used to determine properties of the knot vector.","since":"7.0","returns":"The knot style."},{"signature":"bool RemoveKnots(int index0, int index1)","summary":"Remove knots from the knot vector and adjusts the remaining control points to maintain surface position as closely as possible. The knots from Knots[index0] through Knots[index1 - 1] will be removed.","since":"6.0","parameters":[{"name":"index0","summary":"The starting knot index, where Degree-1 < index0 < index1 <= Points.Count-1."},{"name":"index1","summary":"The ending knot index, where Degree-1 < index0 < index1 <= Points.Count-1."}],"returns":"True if successful, False on failure."},{"signature":"bool RemoveKnotsAt(double u, double v)","summary":"Remove knots from the surface and adjusts the remaining control points to maintain surface position as closely as possible.","since":"6.0","parameters":[{"name":"u","summary":"The u parameter on the surface that is closest to the knot to be removed."},{"name":"v","summary":"The v parameter on the surface that is closest to the knot to be removed."}],"returns":"True if successful, False on failure."},{"signature":"int RemoveMultipleKnots(int minimumMultiplicity, int maximumMultiplicity, double tolerance)","summary":"Remove multiple knots from this surface","since":"6.0","parameters":[{"name":"minimumMultiplicity","summary":"Remove knots with multiplicity > minimumKnotMultiplicity"},{"name":"maximumMultiplicity","summary":"Remove knots with multiplicity < maximumKnotMultiplicity"},{"name":"tolerance","summary":"When you remove knots, the shape of the surface is changed. If tolerance is RhinoMath.UnsetValue, any amount of change is permitted. If tolerance is >=0, the maximum distance between the input and output surface is restricted to be <= tolerance."}],"returns":"number of knots removed on success. 0 if no knots were removed"},{"signature":"double SuperfluousKnot(bool start)","summary":"Computes the knots that are superfluous because they are not used in NURBs evaluation. These make it appear so that the first and last surface spans are different from interior spans.  \\nhttp://wiki.mcneel.com/developer/onsuperfluousknot","since":"5.0","parameters":[{"name":"start","summary":"True if the query targets the first knot. Otherwise, the last knot."}],"returns":"A component."}]},{"namespace":"Rhino.Geometry.Collections","name":"NurbsSurfacePointList","dataType":"class","summary":"Provides access to the control points of a NURBS surface.","interfaces":["IEnumerable<ControlPoint>","IEpsilonComparable<NurbsSurfacePointList>"],"properties":[{"signature":"int CountU","summary":"Gets the number of control points in the U direction of this surface.","since":"5.0","property":["get"]},{"signature":"int CountV","summary":"Gets the number of control points in the V direction of this surface.","since":"5.0","property":["get"]},{"signature":"int PointSize","summary":"Returns the control point size, or the number of doubles per control point. For rational curves, PointSize = Surface.Dimension + 1. For non-rational curves, PointSize = Surface.Dimension.","since":"6.9","property":["get"]}],"methods":[{"signature":"void EnsurePrivateCopy()","summary":"If you want to keep a copy of this class around by holding onto it in a variable after a command completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can call this function as many times as you want.","since":"5.0"},{"signature":"bool EpsilonEquals(NurbsSurfacePointList other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"ControlPoint GetControlPoint(int u, int v)","summary":"Gets the control point at the given (u, v) index.","since":"5.0","parameters":[{"name":"u","summary":"Index of control point in the surface U direction."},{"name":"v","summary":"Index of control point in the surface V direction."}],"returns":"The control point at the given (u, v) index."},{"signature":"Point2d GetGrevillePoint(int u, int v)","summary":"Gets the 2-D Greville point associated with the control point at the given (u, v) index.","since":"5.0","parameters":[{"name":"u","summary":"Index of control point in the surface U direction."},{"name":"v","summary":"Index of control point in the surface V direction."}],"returns":"A Surface UV coordinate on success, Point2d.Unset on failure."},{"signature":"bool GetPoint(int u, int v, out Point3d point)","summary":"Gets a world 3-D, or Euclidean, control point at the given (u, v) index. The 4-D representation is (x, y, z, 1.0).","since":"6.0","parameters":[{"name":"u","summary":"Index of control point in the surface U direction."},{"name":"v","summary":"Index of control point in the surface V direction."},{"name":"point","summary":"Coordinate of control point."}],"returns":"True on success, False on failure."},{"signature":"bool GetPoint(int u, int v, out Point4d point)","summary":"Gets a homogeneous control point at the given (u, v) index, where the 4-D representation is (x, y, z, w). The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).","since":"6.0","parameters":[{"name":"u","summary":"Index of control point in the surface U direction."},{"name":"v","summary":"Index of control point in the surface V direction."},{"name":"point","summary":"Coordinate and weight of control point."}],"returns":"True on success, False on failure."},{"signature":"double GetWeight(int u, int v)","summary":"Gets the weight of a control point at the given (u, v) index. Note, if the surface is non-rational, the weight will be 1.0.","since":"6.0","parameters":[{"name":"u","summary":"Index of control-point along surface U direction."},{"name":"v","summary":"Index of control-point along surface V direction."}],"returns":"The control point weight if successful, Rhino.Math.UnsetValue otherwise."},{"signature":"bool SetControlPoint(int u, int v, ControlPoint cp)","summary":"Sets the control point at the given (u, v) index.","since":"5.0","parameters":[{"name":"u","summary":"Index of control point in the surface U direction."},{"name":"v","summary":"Index of control point in the surface V direction."},{"name":"cp","summary":"The control point to set."}],"returns":"True on success, False on failure."},{"signature":"bool SetControlPoint(int u, int v, Point3d cp)","summary":"Sets the control point at the given (u, v) index.","since":"5.0","deprecated":"6.0","parameters":[{"name":"u","summary":"Index of control point in the surface U direction."},{"name":"v","summary":"Index of control point in the surface V direction."},{"name":"cp","summary":"The control point location to set (weight is assumed to be 1.0)."}],"returns":"True on success, False on failure."},{"signature":"bool SetPoint(int u, int v, double x, double y, double z)","summary":"Sets a world 3-D, or Euclidean, control point at the given (u, v) index. The 4-D representation is (x, y, z, 1.0).","since":"6.0","parameters":[{"name":"u","summary":"Index of control point in the surface U direction."},{"name":"v","summary":"Index of control point in the surface V direction."},{"name":"x","summary":"X coordinate of control point."},{"name":"y","summary":"Y coordinate of control point."},{"name":"z","summary":"Z coordinate of control point."}],"returns":"True on success, False on failure."},{"signature":"bool SetPoint(int u, int v, double x, double y, double z, double weight)","summary":"Sets a homogeneous control point at the given (u, v) index, where the 4-D representation is (x, y, z, w). The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).","since":"6.0","parameters":[{"name":"u","summary":"Index of control point in the surface U direction."},{"name":"v","summary":"Index of control point in the surface V direction."},{"name":"x","summary":"X coordinate of control point."},{"name":"y","summary":"Y coordinate of control point."},{"name":"z","summary":"Z coordinate of control point."},{"name":"weight","summary":"Weight of control point."}],"returns":"True on success, False on failure."},{"signature":"bool SetPoint(int u, int v, Point3d point)","summary":"Sets a world 3-D, or Euclidean, control point at the given (u, v) index. The 4-D representation is (x, y, z, 1.0).","since":"6.0","parameters":[{"name":"u","summary":"Index of control point in the surface U direction."},{"name":"v","summary":"Index of control point in the surface V direction."},{"name":"point","summary":"Coordinate of control point."}],"returns":"True on success, False on failure."},{"signature":"bool SetPoint(int u, int v, Point3d point, double weight)","summary":"Sets a world 3-D, or Euclidean, control point and weight at a given index. The 4-D representation is (x*w, y*w, z*w, w).","since":"6.0","parameters":[{"name":"u","summary":"Index of control point in the surface U direction."},{"name":"v","summary":"Index of control point in the surface V direction."},{"name":"point","summary":"Coordinates of the control point."},{"name":"weight","summary":"Weight of control point."}],"returns":"True on success, False on failure."},{"signature":"bool SetPoint(int u, int v, Point4d point)","summary":"Sets a homogeneous control point at the given (u, v) index, where the 4-D representation is (x, y, z, w). The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).","since":"6.0","parameters":[{"name":"u","summary":"Index of control point in the surface U direction."},{"name":"v","summary":"Index of control point in the surface V direction."},{"name":"point","summary":"Coordinate and weight of control point."}],"returns":"True on success, False on failure."},{"signature":"bool SetWeight(int u, int v, double weight)","summary":"Sets the weight of a control point at the given (u, v) index. Note, if the surface is non-rational, it will be converted to rational.","since":"6.0","parameters":[{"name":"u","summary":"Index of control-point along surface U direction."},{"name":"v","summary":"Index of control-point along surface V direction."},{"name":"weight","summary":"The control point weight."}],"returns":"True if successful, False otherwise."},{"signature":"bool UVNDirectionsAt(int u, int v, out Vector3d uDir, out Vector3d vDir, out Vector3d nDir)","summary":"Calculates the U, V, and N directions of a NURBS surface control point similar to the method used by Rhino\'s MoveUVN command.","since":"7.0","parameters":[{"name":"u","summary":"Index of control-point along surface U direction."},{"name":"v","summary":"Index of control-point along surface V direction."},{"name":"uDir","summary":"The U direction."},{"name":"vDir","summary":"The V direction."},{"name":"nDir","summary":"The N direction."}],"returns":"True if successful, False otherwise."},{"signature":"bool ValidateSpacing(double closeTolerance, double stackTolerance, out IndexPair[] closeIndices, out IndexPair[] stackedIndices)","summary":"Simple check of distance between adjacent control points","since":"6.0"}]},{"namespace":"Rhino.Geometry.Collections","name":"SubDEdgeList","dataType":"class","summary":"All edges in a SubD","interfaces":["IEnumerable<SubDEdge>"],"properties":[{"signature":"int Count","summary":"Gets the number of SubD edges.","since":"7.0","property":["get"]}],"methods":[{"signature":"SubDEdge Add(SubDEdgeTag tag, SubDVertex v0, SubDVertex v1)","summary":"Add a new edge to the list.","since":"7.0","parameters":[{"name":"tag","summary":"The type of edge tag, such as smooth or corner."},{"name":"v0","summary":"First vertex."},{"name":"v1","summary":"Second vertex."}]},{"signature":"SubDEdge Find(int id)","summary":"Find an edge in this SubD with a given id","since":"7.0"},{"signature":"SubDEdge Find(uint id)","summary":"Find an edge in this SubD with a given id","since":"7.0"},{"signature":"IEnumerator<SubDEdge> GetEnumerator()","summary":"Implementation of IEnumerable","since":"7.0"}]},{"namespace":"Rhino.Geometry.Collections","name":"SubDFaceList","dataType":"class","summary":"All faces in a SubD","interfaces":["IEnumerable<SubDFace>"],"properties":[{"signature":"int Count","summary":"Gets the number of SubD faces.","since":"7.0","property":["get"]}],"methods":[{"signature":"SubDFace Find(int id)","summary":"Find a face in this SubD with a given id","since":"7.0"},{"signature":"SubDFace Find(uint id)","summary":"Find a face in this SubD with a given id","since":"7.0"},{"signature":"IEnumerator<SubDFace> GetEnumerator()","summary":"Implementation of IEnumerable","since":"7.0"}]},{"namespace":"Rhino.Geometry.Collections","name":"SubDVertexList","dataType":"class","summary":"Provides access to the vertices and vertex-related functionality of a SubD","properties":[{"signature":"int Count","summary":"Gets the number of SubD vertices.","since":"7.0","property":["get"]},{"signature":"SubDVertex First","summary":"First vertex in this linked list of vertices","since":"7.0","property":["get"]}],"methods":[{"signature":"SubDVertex Add(SubDVertexTag tag, Point3d vertex)","summary":"Add a new vertex to the end of the Vertex list.","since":"7.0","parameters":[{"name":"tag","summary":"The type of vertex tag, such as smooth or corner."},{"name":"vertex","summary":"Location of new vertex."}],"returns":"The newly added vertex."},{"signature":"SubDVertex Find(int id)","summary":"Find a vertex in this SubD with a given id","since":"7.0"},{"signature":"SubDVertex Find(uint id)","summary":"Find a vertex in this SubD with a given id","since":"7.0"}]},{"namespace":"Rhino.Geometry","name":"ComponentIndex","dataType":"struct","summary":"Represents an index of an element contained in another object.","constructors":[{"signature":"ComponentIndex(ComponentIndexType type, int index)","summary":"Construct component index with a specific type/index combination","since":"5.0"}],"properties":[{"signature":"static ComponentIndex Unset","summary":"The unset value of component index.","since":"5.0","property":["get"]},{"signature":"ComponentIndexType ComponentIndexType","summary":"The interpretation of Index depends on the Type value. Type             m_index interpretation (0 based indices) no_type            used when context makes it clear what array is being index brep_vertex        Brep.m_V[] array index brep_edge          Brep.m_E[] array index brep_face          Brep.m_F[] array index brep_trim          Brep.m_T[] array index brep_loop          Brep.m_L[] array index mesh_vertex        Mesh.m_V[] array index meshtop_vertex     MeshTopology.m_topv[] array index meshtop_edge       MeshTopology.m_tope[] array index mesh_face          Mesh.m_F[] array index idef_part          InstanceDefinition.m_object_uuid[] array index polycurve_segment  PolyCurve::m_segment[] array index dim_linear_point   LinearDimension2::POINT_INDEX dim_radial_point   RadialDimension2::POINT_INDEX dim_angular_point  AngularDimension2::POINT_INDEX dim_ordinate_point OrdinateDimension2::POINT_INDEX dim_text_point     TextEntity2 origin point.","since":"5.0","property":["get"]},{"signature":"int Index","summary":"The interpretation of m_index depends on the m_type value. m_type             m_index interpretation (0 based indices) no_type            used when context makes it clear what array is being index brep_vertex        Brep.m_V[] array index brep_edge          Brep.m_E[] array index brep_face          Brep.m_F[] array index brep_trim          Brep.m_T[] array index brep_loop          Brep.m_L[] array index mesh_vertex        Mesh.m_V[] array index meshtop_vertex     MeshTopology.m_topv[] array index meshtop_edge       MeshTopology.m_tope[] array index mesh_face          Mesh.m_F[] array index idef_part          InstanceDefinition.m_object_uuid[] array index polycurve_segment  PolyCurve::m_segment[] array index dim_linear_point   LinearDimension2::POINT_INDEX dim_radial_point   RadialDimension2::POINT_INDEX dim_angular_point  AngularDimension2::POINT_INDEX dim_ordinate_point OrdinateDimension2::POINT_INDEX dim_text_point     TextEntity2 origin point.","since":"5.0","property":["get"]}],"methods":[{"signature":"bool IsUnset()","summary":"Return True is this component index is the same as the Unset component index","since":"7.0"}]},{"namespace":"Rhino.Geometry","name":"ComponentIndexType","dataType":"enum","summary":"Defines enumerated values to represent component index types.","since":"5.0","values":[{"signature":"InvalidType = 0","summary":"Not used. This is the default value of the enumeration type."},{"signature":"BrepVertex = 1","summary":"Targets a brep vertex index."},{"signature":"BrepEdge = 2","summary":"Targets a brep edge index."},{"signature":"BrepFace = 3","summary":"Targets a brep face index."},{"signature":"BrepTrim = 4","summary":"Targets a brep trim index."},{"signature":"BrepLoop = 5","summary":"Targets a brep loop index."},{"signature":"MeshVertex = 11","summary":"Targets a mesh vertex index."},{"signature":"MeshTopologyVertex = 12","summary":"Targets a mesh topology vertex index."},{"signature":"MeshTopologyEdge = 13","summary":"Targets a mesh topology edge index."},{"signature":"MeshFace = 14","summary":"Targets a mesh face index."},{"signature":"MeshNgon = 15","summary":"Targets a mesh n-gon index."},{"signature":"InstanceDefinitionPart = 21","summary":"Targets an instance definition part index."},{"signature":"PolycurveSegment = 31","summary":"Targets a polycurve segment index."},{"signature":"PointCloudPoint = 41","summary":"Targets a point cloud point index."},{"signature":"GroupMember = 51","summary":"Targets a group member index."},{"signature":"ExtrusionBottomProfile = 61","summary":"3d bottom profile curves. Index identifies profile component"},{"signature":"ExtrusionTopProfile = 62","summary":"3d top profile curves. Index identifies profile component"},{"signature":"ExtrusionWallEdge = 63","summary":"3d wall edge curve. Index/2: identifies profile component Index%2: 0=start, 1=end"},{"signature":"ExtrusionWallSurface = 64","summary":"Side wall surfaces. Index identifies profile component"},{"signature":"ExtrusionCapSurface = 65","summary":"Bottom and top cap surfaces. Index 0=bottom, 1=top"},{"signature":"ExtrusionPath = 66","summary":"Extrusion path (axis line). Index -1=entire path, 0=start point, 1=endpoint"},{"signature":"SubdVertex = 71","summary":"Targets a SubD vertex pointer Id. Ids are not guaranteed to be sequential."},{"signature":"SubdEdge = 72","summary":"Targets a SubD edge pointer Id. Ids are not guaranteed to be sequential."},{"signature":"SubdFace = 73","summary":"Targets a SubD face pointer Id. Ids are not guaranteed to be sequential."},{"signature":"DimLinearPoint = 100","summary":"Targets a linear dimension point index."},{"signature":"DimRadialPoint = 101","summary":"Targets a radial dimension point index."},{"signature":"DimAngularPoint = 102","summary":"Targets an angular dimension point index."},{"signature":"DimOrdinatePoint = 103","summary":"Targets an ordinate dimension point index."},{"signature":"DimTextPoint = 104","summary":"Targets a text point index."},{"signature":"NoType = 0x0FFFFFFF","summary":"Targets no specific type."}]},{"namespace":"Rhino.Geometry","name":"ComponentStatus","dataType":"struct","summary":"Provides information about selection, highlighting, visibility, editability and integrity states of a component.  \\nThis structure is immutable.","properties":[{"signature":"static ComponentStatus AllSet","summary":"All flags are checked.","since":"6.0","property":["get"]},{"signature":"static ComponentStatus Clear","summary":"This is the default value and equal to undefined.","since":"6.0","property":["get"]},{"signature":"static ComponentStatus Damaged","summary":"The damaged flag is checked.","since":"6.0","property":["get"]},{"signature":"static ComponentStatus Hidden","summary":"The hidden flag is checked.","since":"6.0","property":["get"]},{"signature":"static ComponentStatus Highlighted","summary":"The highlight selection flag is checked.","since":"6.0","property":["get"]},{"signature":"static ComponentStatus Locked","summary":"The locked flag is checked.","since":"6.0","property":["get"]},{"signature":"static ComponentStatus Selected","summary":"The selection flag is checked.","since":"6.0","property":["get"]},{"signature":"static ComponentStatus SelectedPersistent","summary":"The persistent selection flag is checked.","since":"6.0","property":["get"]},{"signature":"bool IsClear","summary":"True if every setting is 0 or false.","since":"6.0","property":["get"]},{"signature":"bool IsDamaged","summary":"Returns False if component is not damaged. True otherwise.","since":"6.0","property":["get"]},{"signature":"bool IsHidden","summary":"Returns True if hidden. False otherwise.","since":"6.0","property":["get"]},{"signature":"bool IsHighlighted","summary":"Returns True if highlighted. False otherwise.","since":"6.0","property":["get"]},{"signature":"bool IsLocked","summary":"Returns True if locked. False otherwise.","since":"6.0","property":["get"]},{"signature":"bool IsSelected","summary":"Returns True if selected or selected persistent. False otherwise.","since":"6.0","property":["get"]},{"signature":"bool IsSelectedPersistent","summary":"Returns True if selected persistent. False otherwise.","since":"6.0","property":["get"]}],"methods":[{"signature":"bool Equals(ComponentStatus other)","summary":"Determines if another ComponentStatus and this are equal.","since":"6.0","parameters":[{"name":"other","summary":"A ComponentStatus."}],"returns":"True if equal in value. False otherwise"},{"signature":"bool Equals(object obj)","summary":"Determines if an object and this are equal.","parameters":[{"name":"obj","summary":"An object."}],"returns":"True if equal in value. False otherwise"},{"signature":"int GetHashCode()","summary":"Serves as a special hash function. The inner value is used for the purpose.","returns":"An integer deriving from a bit mask."},{"signature":"bool HasAllEqualStates(ComponentStatus statesFilter, ComponentStatus comparand)","summary":"For the purposes of this test, Selected and SelectedPersistent are considered equal.","since":"6.0","parameters":[{"name":"statesFilter","summary":"If no states are specified, then False is returned."},{"name":"comparand","summary":"If a state is set in states_filter, the corresponding state in \\"this\\" and comparand will be tested."}],"returns":"True if at all tested states in \\"this\\" and comparand are identical."},{"signature":"bool HasNoEqualStates(ComponentStatus statesFilter, ComponentStatus comparand)","summary":"For the purposes of this test, Selected and SelectedPersistent are considered equal.","since":"6.0","parameters":[{"name":"statesFilter","summary":"If no states are specified, then False is returned."},{"name":"comparand","summary":"If a state is set in states_filter, the corresponding state in \\"this\\" and comparand will be tested."}],"returns":"True if at all tested states in \\"this\\" and comparand are identical."},{"signature":"bool HasSomeEqualStates(ComponentStatus statesFilter, ComponentStatus comparand)","summary":"For the purposes of this test, Selected and SelectedPersistent are considered equal.","since":"6.0","parameters":[{"name":"statesFilter","summary":"If no states are specified, then False is returned."},{"name":"comparand","summary":"If a state is set in states_filter, the corresponding state in \\"this\\" and comparand will be tested."}],"returns":"True if at least one tested state in \\"this\\" and comparand are identical."},{"signature":"string ToString()","summary":"Provides a string representation of this ComponentStatus.","returns":"The representation in English."},{"signature":"ComponentStatus WithStates(ComponentStatus additionalStatus)","summary":"Activates any information flag described in any of the two input component statuses and returns a new ComponentStatus with those flags checked.","since":"6.0","parameters":[{"name":"additionalStatus","summary":"To be used for adding status values."}]}]},{"namespace":"Rhino.Geometry","name":"Concavity","dataType":"enum","summary":"Enumerates the possible types of edge concavity types.","since":"6.2","values":[{"signature":"None = -1","summary":"Concavity is not relevant, for example naked and non-manifold edges cannot have a concavity measure."},{"signature":"Tangent = 0","summary":"Faces on either side of the edge are tangent within tolerance."},{"signature":"Convex = 1","summary":"Faces on either side of the edge are convex."},{"signature":"Concave = 2","summary":"Faces on either side of the edge are concave."}]},{"namespace":"Rhino.Geometry","name":"Cone","dataType":"struct","summary":"Represents the center plane, radius and height values in a right circular cone.","constructors":[{"signature":"Cone(Plane plane, double height, double radius)","summary":"Initializes a new cone with a specified base plane, height and radius.","since":"5.0","parameters":[{"name":"plane","summary":"Base plane of cone.  The apex of the cone is at the plane\'s origin."},{"name":"height","summary":"Height of cone."},{"name":"radius","summary":"Radius of cone."}]}],"properties":[{"signature":"static Cone Unset","summary":"Gets an invalid Cone.","since":"5.0","property":["get"]},{"signature":"Point3d ApexPoint","summary":"Point at tip of the cone.","since":"5.0","property":["get"]},{"signature":"Vector3d Axis","summary":"Unit vector axis of cone.","since":"5.0","property":["get"]},{"signature":"Point3d BasePoint","summary":"Center of base circle.","since":"5.0","property":["get"]},{"signature":"double Height","summary":"Gets or sets the height of the circular right cone.","since":"5.0","property":["get","set"]},{"signature":"bool IsValid","summary":"True if plane is valid, height is not zero and radius is not zero.","since":"5.0","property":["get"]},{"signature":"Plane Plane","summary":"Gets or sets the base plane of the cone.  The apex of the cone is at the plane\'s origin.","since":"5.0","property":["get","set"]},{"signature":"double Radius","summary":"Gets or sets the radius of the cone.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"double AngleInDegrees()","summary":"Computes the angle (in degrees) between the axis and the side of the cone. The angle and the height have the same sign.","since":"5.0","returns":"An angle in degrees."},{"signature":"double AngleInRadians()","summary":"Computes the angle (in radians) between the axis and the side of the cone. The angle and the height have the same sign.","since":"5.0","returns":"Math.Atan(Radius / Height) if the height is not 0; 0 if the radius is 0; Math.PI otherwise."},{"signature":"bool EpsilonEquals(Cone other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"Brep ToBrep(bool capBottom)","summary":"Gets a Brep representation of the cone with a single face for the cone, an edge along the cone seam, and vertices at the base and apex ends of this seam edge. The optional cap is a single face with one circular edge starting and ending at the base vertex.","since":"5.0","parameters":[{"name":"capBottom","summary":"True if the bottom should be filled with a surface. False otherwise."}],"returns":"A brep (polysurface) representation of this cone values."},{"signature":"NurbsSurface ToNurbsSurface()","summary":"Constructs a Nurbs surface representation of this Cone. This is synonymous with calling NurbsSurface.CreateFromCone().","since":"5.0","returns":"A Nurbs surface representation of the cone or null."},{"signature":"RevSurface ToRevSurface()","summary":"Constructs a RevSurface representation of this Cone. This is synonymous with calling RevSurface.CreateFromCone().","since":"5.0","returns":"A RevSurface representation of the cone or null."}]},{"namespace":"Rhino.Geometry","name":"ConicSectionType","dataType":"enum","summary":"Defines enumerated values for types of conic sections.","since":"6.0","values":[{"signature":"Unknown = 0","summary":"The curve shape is unknown."},{"signature":"Circle = 1","summary":"The curve has the shape of a circle."},{"signature":"Ellipse = 2","summary":"The curve has the shape of an ellipse."},{"signature":"Hyperbola = 3","summary":"The curve has the shape of a hyperbola."},{"signature":"Parabola = 4","summary":"The curve has the shape of a parabola."}]},{"namespace":"Rhino.Geometry","name":"Continuity","dataType":"enum","summary":"Provides enumerated values for continuity along geometry, such as continuous first derivative or continuous unit tangent and curvature.","since":"5.0","values":[{"signature":"None = 0","summary":"There is no continuity."},{"signature":"C0_continuous = 1","summary":"Continuous Function : Test for parametric continuity. In particular, all types of curves are considered infinitely continuous at the start/end of the evaluation domain."},{"signature":"C1_continuous = 2","summary":"Continuous first derivative : Test for parametric continuity. In particular, all types of curves are considered infinitely continuous at the start/end of the evaluation domain."},{"signature":"C2_continuous = 3","summary":"Continuous first derivative and second derivative : Test for parametric continuity. In particular, all types of curves are considered infinitely continuous at the start/end of the evaluation domain."},{"signature":"G1_continuous = 4","summary":"Continuous unit tangent : Test for parametric continuity. In particular, all types of curves are considered infinitely continuous at the start/end of the evaluation domain."},{"signature":"G2_continuous = 5","summary":"Continuous unit tangent and curvature : Test for parametric continuity. In particular, all types of curves are considered infinitely continuous at the start/end of the evaluation domain."},{"signature":"C0_locus_continuous = 6","summary":"Locus continuous function : Continuity tests using the following enum values are identical to tests using the preceding enum values on the INTERIOR of a curve\'s domain. At the END of a curve a \\"locus\\" test is performed in place of a parametric test. In particular, at the END of a domain, all open curves are locus discontinuous. At the END of a domain, all closed curves are at least C0_locus_continuous. By convention all Curves are considered locus continuous at the START of the evaluation domain. This convention is not strictly correct, but it was adopted to make iterative kink finding tools easier to use and so that locus discontinuities are reported once at the end parameter of a curve rather than twice."},{"signature":"C1_locus_continuous = 7","summary":"Locus continuous first derivative : Continuity tests using the following enum values are identical to tests using the preceding enum values on the INTERIOR of a curve\'s domain. At the END of a curve a \\"locus\\" test is performed in place of a parametric test. In particular, at the END of a domain, all open curves are locus discontinuous. At the END of a domain, all closed curves are at least C0_locus_continuous. By convention all Curves are considered locus continuous at the START of the evaluation domain. This convention is not strictly correct, but it was adopted to make iterative kink finding tools easier to use and so that locus discontinuities are reported once at the end parameter of a curve rather than twice."},{"signature":"C2_locus_continuous = 8","summary":"Locus continuous first and second derivative : Continuity tests using the following enum values are identical to tests using the preceding enum values on the INTERIOR of a curve\'s domain. At the END of a curve a \\"locus\\" test is performed in place of a parametric test. In particular, at the END of a domain, all open curves are locus discontinuous. At the END of a domain, all closed curves are at least C0_locus_continuous. By convention all Curves are considered locus continuous at the START of the evaluation domain. This convention is not strictly correct, but it was adopted to make iterative kink finding tools easier to use and so that locus discontinuities are reported once at the end parameter of a curve rather than twice."},{"signature":"G1_locus_continuous = 9","summary":"Locus continuous unit tangent : Continuity tests using the following enum values are identical to tests using the preceding enum values on the INTERIOR of a curve\'s domain. At the END of a curve a \\"locus\\" test is performed in place of a parametric test. In particular, at the END of a domain, all open curves are locus discontinuous. At the END of a domain, all closed curves are at least C0_locus_continuous. By convention all Curves are considered locus continuous at the START of the evaluation domain. This convention is not strictly correct, but it was adopted to make iterative kink finding tools easier to use and so that locus discontinuities are reported once at the end parameter of a curve rather than twice."},{"signature":"G2_locus_continuous = 10","summary":"Locus continuous unit tangent and curvature : Continuity tests using the following enum values are identical to tests using the preceding enum values on the INTERIOR of a curve\'s domain. At the END of a curve a \\"locus\\" test is performed in place of a parametric test. In particular, at the END of a domain, all open curves are locus discontinuous. At the END of a domain, all closed curves are at least C0_locus_continuous. By convention all Curves are considered locus continuous at the START of the evaluation domain. This convention is not strictly correct, but it was adopted to make iterative kink finding tools easier to use and so that locus discontinuities are reported once at the end parameter of a curve rather than twice."},{"signature":"Cinfinity_continuous = 11","summary":"Analytic discontinuity. Cinfinity_continuous is a euphemism for \\"at a knot\\"."},{"signature":"Gsmooth_continuous = 12","summary":"Aesthetic discontinuity"}]},{"namespace":"Rhino.Geometry","name":"ControlPoint","dataType":"struct","summary":"Represents control point geometry with three-dimensional position and weight.","constructors":[{"signature":"ControlPoint(double x, double y, double z)","summary":"Constructs a new world 3-D, or Euclidean, control point. The 4-D representation is (x, y, z, 1.0).","since":"5.0","parameters":[{"name":"x","summary":"X coordinate of the control point."},{"name":"y","summary":"Y coordinate of the control point."},{"name":"z","summary":"Z coordinate of the control point."}]},{"signature":"ControlPoint(double x, double y, double z, double weight)","summary":"Constructs a new homogeneous control point, where the 4-D representation is (x, y, z, w). The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).","since":"5.0","parameters":[{"name":"x","summary":"X coordinate of the control point."},{"name":"y","summary":"Y coordinate of the control point."},{"name":"z","summary":"Z coordinate of the control point."},{"name":"weight","summary":"Weight factor of the control point. You should not use weights less than or equal to zero."}]},{"signature":"ControlPoint(Point3d pt)","summary":"Constructs a new world 3-D, or Euclidean, control point. The 4-D representation of this is (x, y, z, 1.0).","since":"5.0","parameters":[{"name":"pt","summary":"Coordinates of the control point."}]},{"signature":"ControlPoint(Point3d euclideanPt, double weight)","summary":"Constructs a control point from a world 3-D, or Euclidean, location and a weight. The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).","since":"5.0","parameters":[{"name":"euclideanPt","summary":"Coordinates of the control point."},{"name":"weight","summary":"Weight factor of the control point. You should not use weights less than or equal to zero."}]},{"signature":"ControlPoint(Point4d pt)","summary":"Constructs a new homogeneous control point, where the 4-D representation is (x, y, z, w). The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).","since":"5.0","parameters":[{"name":"pt","summary":"Coordinates of the control point."}]}],"properties":[{"signature":"static ControlPoint Unset","summary":"Gets the predefined, unset control point.","since":"5.0","property":["get"]},{"signature":"Point3d Location","summary":"Gets or sets world 3-D, or Euclidean location of the control point.","since":"5.0","property":["get","set"]},{"signature":"double Weight","summary":"Gets or sets the weight of this control point.","since":"5.0","property":["get","set"]},{"signature":"double X","summary":"Gets or sets the X coordinate of the control point.","since":"6.0","property":["get","set"]},{"signature":"double Y","summary":"Gets or sets the Y coordinate of the control point.","since":"6.0","property":["get","set"]},{"signature":"double Z","summary":"Gets or sets the Z coordinate of the control point.","since":"6.0","property":["get","set"]}],"methods":[{"signature":"bool EpsilonEquals(ControlPoint other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(ControlPoint other)","summary":"Determines if two points exactly match.","since":"6.0","parameters":[{"name":"other","summary":"The other point."}],"returns":"True if the other control point exactly matches this one."}]},{"namespace":"Rhino.Geometry","name":"Curve","dataType":"class","summary":"Represents a base class that is common to most RhinoCommon curve types.  \\nA curve represents an entity that can be all visited by providing a single parameter, usually called t.","baseclass":"Rhino.Geometry.GeometryBase","properties":[{"signature":"int Degree","summary":"Gets the maximum algebraic degree of any span or a good estimate if curve spans are not algebraic.","since":"5.0","property":["get"]},{"signature":"int Dimension","summary":"Gets the dimension of the object.  \\nThe dimension is typically three. For parameter space trimming curves the dimension is two. In rare cases the dimension can be one or greater than three.","since":"5.0","property":["get"]},{"signature":"Interval Domain","summary":"Gets or sets the domain of the curve.","since":"5.0","property":["get","set"]},{"signature":"bool IsClosed","summary":"Gets a value indicating whether or not this curve is a closed curve.","since":"5.0","property":["get"]},{"signature":"bool IsPeriodic","summary":"Gets a value indicating whether or not this curve is considered to be Periodic.","since":"5.0","property":["get"]},{"signature":"Point3d PointAtEnd","summary":"Evaluates point at the end of the curve.","since":"5.0","property":["get"]},{"signature":"Point3d PointAtStart","summary":"Evaluates point at the start of the curve.","since":"5.0","property":["get"]},{"signature":"int SpanCount","summary":"Gets the number of non-empty smooth (c-infinity) spans in the curve.","since":"5.0","property":["get"]},{"signature":"Vector3d TangentAtEnd","summary":"Evaluate unit tangent vector at the end of the curve.","since":"5.0","property":["get"]},{"signature":"Vector3d TangentAtStart","summary":"Evaluates the unit tangent vector at the start of the curve.","since":"5.0","property":["get"]}],"methods":[{"signature":"static Curve CreateArcBlend(Point3d startPt, Vector3d startDir, Point3d endPt, Vector3d endDir, double controlPointLengthRatio)","summary":"Creates a polycurve consisting of two tangent arc segments that connect two points and two directions.","since":"6.1","parameters":[{"name":"startPt","summary":"Start of the arc blend curve."},{"name":"startDir","summary":"Start direction of the arc blend curve."},{"name":"endPt","summary":"End of the arc blend curve."},{"name":"endDir","summary":"End direction of the arc blend curve."},{"name":"controlPointLengthRatio","summary":"The ratio of the control polygon lengths of the two arcs. Note, a value of 1.0 means the control polygon lengths for both arcs will be the same."}],"returns":"The arc blend curve, or None on error."},{"signature":"static Curve CreateBlendCurve(Curve curveA, Curve curveB, BlendContinuity continuity)","summary":"Create a Blend curve between two existing curves.","since":"5.0","parameters":[{"name":"curveA","summary":"Curve to blend from (blending will occur at curve end point)."},{"name":"curveB","summary":"Curve to blend to (blending will occur at curve start point)."},{"name":"continuity","summary":"Continuity of blend."}],"returns":"A curve representing the blend between A and B or None on failure."},{"signature":"static Curve CreateBlendCurve(Curve curveA, Curve curveB, BlendContinuity continuity, double bulgeA, double bulgeB)","summary":"Create a Blend curve between two existing curves.","since":"5.0","parameters":[{"name":"curveA","summary":"Curve to blend from (blending will occur at curve end point)."},{"name":"curveB","summary":"Curve to blend to (blending will occur at curve start point)."},{"name":"continuity","summary":"Continuity of blend."},{"name":"bulgeA","summary":"Bulge factor at curveA end of blend. Values near 1.0 work best."},{"name":"bulgeB","summary":"Bulge factor at curveB end of blend. Values near 1.0 work best."}],"returns":"A curve representing the blend between A and B or None on failure."},{"signature":"static Curve CreateBlendCurve(Curve curve0, double t0, bool reverse0, BlendContinuity continuity0, Curve curve1, double t1, bool reverse1, BlendContinuity continuity1)","summary":"Makes a curve blend between 2 curves at the parameters specified with the directions and continuities specified","since":"5.0","parameters":[{"name":"curve0","summary":"First curve to blend from"},{"name":"t0","summary":"Parameter on first curve for blend endpoint"},{"name":"reverse0","summary":"If false, the blend will go in the natural direction of the curve. If true, the blend will go in the opposite direction to the curve"},{"name":"continuity0","summary":"Continuity for the blend at the start"},{"name":"curve1","summary":"Second curve to blend from"},{"name":"t1","summary":"Parameter on second curve for blend endpoint"},{"name":"reverse1","summary":"If false, the blend will go in the natural direction of the curve. If true, the blend will go in the opposite direction to the curve"},{"name":"continuity1","summary":"Continuity for the blend at the end"}],"returns":"The blend curve on success. None on failure"},{"signature":"static Curve[] CreateBooleanDifference(Curve curveA, Curve curveB)","summary":"Calculates the boolean difference between two closed, planar curves. Note, curves must be co-planar.","since":"5.0","deprecated":"6.0","parameters":[{"name":"curveA","summary":"The first closed, planar curve."},{"name":"curveB","summary":"The second closed, planar curve."}],"returns":"Result curves on success, empty array if no difference could be calculated."},{"signature":"static Curve[] CreateBooleanDifference(Curve curveA, Curve curveB, double tolerance)","summary":"Calculates the boolean difference between two closed, planar curves. Note, curves must be co-planar.","since":"6.0","parameters":[{"name":"curveA","summary":"The first closed, planar curve."},{"name":"curveB","summary":"The second closed, planar curve."},{"name":"tolerance","summary":""}],"returns":"Result curves on success, empty array if no difference could be calculated."},{"signature":"static Curve[] CreateBooleanDifference(Curve curveA, IEnumerable<Curve> subtractors)","summary":"Calculates the boolean difference between a closed planar curve, and a list of closed planar curves. Note, curves must be co-planar.","since":"5.0","deprecated":"6.0","parameters":[{"name":"curveA","summary":"The first closed, planar curve."},{"name":"subtractors","summary":"curves to subtract from the first closed curve."}],"returns":"Result curves on success, empty array if no difference could be calculated."},{"signature":"static Curve[] CreateBooleanDifference(Curve curveA, IEnumerable<Curve> subtractors, double tolerance)","summary":"Calculates the boolean difference between a closed planar curve, and a list of closed planar curves. Note, curves must be co-planar.","since":"6.0","parameters":[{"name":"curveA","summary":"The first closed, planar curve."},{"name":"subtractors","summary":"curves to subtract from the first closed curve."},{"name":"tolerance","summary":""}],"returns":"Result curves on success, empty array if no difference could be calculated."},{"signature":"static Curve[] CreateBooleanIntersection(Curve curveA, Curve curveB)","summary":"Calculates the boolean intersection of two closed, planar curves. Note, curves must be co-planar.","since":"5.0","deprecated":"6.0","parameters":[{"name":"curveA","summary":"The first closed, planar curve."},{"name":"curveB","summary":"The second closed, planar curve."}],"returns":"Result curves on success, empty array if no intersection could be calculated."},{"signature":"static Curve[] CreateBooleanIntersection(Curve curveA, Curve curveB, double tolerance)","summary":"Calculates the boolean intersection of two closed, planar curves. Note, curves must be co-planar.","since":"6.0","parameters":[{"name":"curveA","summary":"The first closed, planar curve."},{"name":"curveB","summary":"The second closed, planar curve."},{"name":"tolerance","summary":""}],"returns":"Result curves on success, empty array if no intersection could be calculated."},{"signature":"static CurveBooleanRegions CreateBooleanRegions(IEnumerable<Curve> curves, Plane plane, bool combineRegions, double tolerance)","summary":"Calculates curve Boolean regions, which trims and splits curves based on their overlapping regions.","since":"7.0","parameters":[{"name":"curves","summary":"The input curves."},{"name":"plane","summary":"Regions will be found in the projection of the curves to this plane."},{"name":"combineRegions","summary":"If true, then adjacent regions will be combined."},{"name":"tolerance","summary":"Function tolerance. When in doubt, use the document\'s model absolute tolerance."}],"returns":"The curve Boolean regions if successful, None of no successful."},{"signature":"static CurveBooleanRegions CreateBooleanRegions(IEnumerable<Curve> curves, Plane plane, IEnumerable<Point3d> points, bool combineRegions, double tolerance)","summary":"Curve Boolean method, which trims and splits curves based on their overlapping regions.","since":"7.0","parameters":[{"name":"curves","summary":"The input curves."},{"name":"plane","summary":"Regions will be found in the projection of the curves to this plane."},{"name":"points","summary":"These points will be projected to plane. All regions that contain at least one of these points will be found."},{"name":"combineRegions","summary":"If true, then adjacent regions will be combined."},{"name":"tolerance","summary":"Function tolerance. When in doubt, use the document\'s model absolute tolerance."}],"returns":"The curve Boolean regions if successful, None of no successful."},{"signature":"static Curve[] CreateBooleanUnion(IEnumerable<Curve> curves)","summary":"Calculates the boolean union of two or more closed, planar curves. Note, curves must be co-planar.","since":"5.0","deprecated":"6.0","parameters":[{"name":"curves","summary":"The co-planar curves to union."}],"returns":"Result curves on success, empty array if no union could be calculated."},{"signature":"static Curve[] CreateBooleanUnion(IEnumerable<Curve> curves, double tolerance)","summary":"Calculates the boolean union of two or more closed, planar curves. Note, curves must be co-planar.","since":"6.0","parameters":[{"name":"curves","summary":"The co-planar curves to union."},{"name":"tolerance","summary":""}],"returns":"Result curves on success, empty array if no union could be calculated."},{"signature":"static Curve CreateControlPointCurve(IEnumerable<Point3d> points)","summary":"Constructs a control-point of degree=3 (or less).","since":"5.0","parameters":[{"name":"points","summary":"Control points of curve."}]},{"signature":"static Curve CreateControlPointCurve(IEnumerable<Point3d> points, int degree)","summary":"Constructs a curve from a set of control-point locations.","since":"5.0","parameters":[{"name":"points","summary":"Control points."},{"name":"degree","summary":"Degree of curve. The number of control points must be at least degree+1."}]},{"signature":"static Curve[] CreateCurve2View(Curve curveA, Curve curveB, Vector3d vectorA, Vector3d vectorB, double tolerance, double angleTolerance)","summary":"Creates a third curve from two curves that are planar in different construction planes. The new curve looks the same as each of the original curves when viewed in each plane.","since":"6.0","parameters":[{"name":"curveA","summary":"The first curve."},{"name":"curveB","summary":"The second curve."},{"name":"vectorA","summary":"A vector defining the normal direction of the plane which the first curve is drawn upon."},{"name":"vectorB","summary":"A vector defining the normal direction of the plane which the second curve is drawn upon."},{"name":"tolerance","summary":"The tolerance for the operation."},{"name":"angleTolerance","summary":"The angle tolerance for the operation."}],"returns":"An array containing one or more curves if successful."},{"signature":"static Arc CreateFillet(Curve curve0, Curve curve1, double radius, double t0Base, double t1Base)","summary":"Computes the fillet arc for a curve filleting operation.","since":"5.0","parameters":[{"name":"curve0","summary":"First curve to fillet."},{"name":"curve1","summary":"Second curve to fillet."},{"name":"radius","summary":"Fillet radius."},{"name":"t0Base","summary":"Parameter on curve0 where the fillet ought to start (approximately)."},{"name":"t1Base","summary":"Parameter on curve1 where the fillet ought to end (approximately)."}],"returns":"The fillet arc on success, or Arc.Unset on failure."},{"signature":"static Curve CreateFilletCornersCurve(Curve curve, double radius, double tolerance, double angleTolerance)","summary":"Rounds the corners of a kinked curve with arcs of a single, specified radius.","since":"6.0","parameters":[{"name":"curve","summary":"The curve to fillet."},{"name":"radius","summary":"The fillet radius."},{"name":"tolerance","summary":"The tolerance. When in doubt, use the document\'s model space absolute tolerance."},{"name":"angleTolerance","summary":"The angle tolerance in radians. When in doubt, use the document\'s model space angle tolerance."}],"returns":"The filleted curve if successful. None on failure."},{"signature":"static Curve[] CreateFilletCurves(Curve curve0, Point3d point0, Curve curve1, Point3d point1, double radius, bool join, bool trim, bool arcExtension, double tolerance, double angleTolerance)","summary":"Creates a tangent arc between two curves and trims or extends the curves to the arc.","since":"5.10","parameters":[{"name":"curve0","summary":"The first curve to fillet."},{"name":"point0","summary":"A point on the first curve that is near the end where the fillet will be created."},{"name":"curve1","summary":"The second curve to fillet."},{"name":"point1","summary":"A point on the second curve that is near the end where the fillet will be created."},{"name":"radius","summary":"The radius of the fillet."},{"name":"join","summary":"Join the output curves."},{"name":"trim","summary":"Trim copies of the input curves to the output fillet curve."},{"name":"arcExtension","summary":"Applies when arcs are filleted but need to be extended to meet the fillet curve or chamfer line. If true, then the arc is extended maintaining its validity. If false, then the arc is extended with a line segment, which is joined to the arc converting it to a polycurve."},{"name":"tolerance","summary":"The tolerance, generally the document\'s absolute tolerance."},{"name":"angleTolerance","summary":""}],"returns":"The results of the fillet operation. The number of output curves depends on the input curves and the values of the parameters that were used during the fillet operation. In most cases, the output array will contain either one or three curves, although two curves can be returned if the radius is zero and join = false. For example, if both join and trim = true, then the output curve will be a polycurve containing the fillet curve joined with trimmed copies of the input curves. If join = False and trim = true, then three curves, the fillet curve and trimmed copies of the input curves, will be returned. If both join and trim = false, then just the fillet curve is returned."},{"signature":"static Curve CreateInterpolatedCurve(IEnumerable<Point3d> points, int degree)","summary":"Interpolates a sequence of points. Used by InterpCurve Command This routine works best when degree=3.","since":"5.0","parameters":[{"name":"points","summary":"Points to interpolate (Count must be >= 2)"},{"name":"degree","summary":"The degree of the curve >=1.  Degree must be odd."}],"returns":"interpolated curve on success. None on failure."},{"signature":"static Curve CreateInterpolatedCurve(IEnumerable<Point3d> points, int degree, CurveKnotStyle knots)","summary":"Interpolates a sequence of points. Used by InterpCurve Command This routine works best when degree=3.","since":"5.0","parameters":[{"name":"points","summary":"Points to interpolate. For periodic curves if the final point is a duplicate of the initial point it is  ignored. (Count must be >=2)"},{"name":"degree","summary":"The degree of the curve >=1.  Degree must be odd."},{"name":"knots","summary":"Knot-style to use  and specifies if the curve should be periodic."}],"returns":"interpolated curve on success. None on failure."},{"signature":"static Curve CreateInterpolatedCurve(IEnumerable<Point3d> points, int degree, CurveKnotStyle knots, Vector3d startTangent, Vector3d endTangent)","summary":"Interpolates a sequence of points. Used by InterpCurve Command This routine works best when degree=3.","since":"5.0","parameters":[{"name":"points","summary":"Points to interpolate. For periodic curves if the final point is a duplicate of the initial point it is  ignored. (Count must be >=2)"},{"name":"degree","summary":"The degree of the curve >=1.  Degree must be odd."},{"name":"knots","summary":"Knot-style to use  and specifies if the curve should be periodic."},{"name":"startTangent","summary":"A starting tangent."},{"name":"endTangent","summary":"An ending tangent."}],"returns":"interpolated curve on success. None on failure."},{"signature":"static Curve CreateMeanCurve(Curve curveA, Curve curveB)","summary":"Constructs a mean, or average, curve from two curves.","since":"5.0","parameters":[{"name":"curveA","summary":"A first curve."},{"name":"curveB","summary":"A second curve."}],"returns":"The average curve, or None on error."},{"signature":"static Curve CreateMeanCurve(Curve curveA, Curve curveB, double angleToleranceRadians)","summary":"Constructs a mean, or average, curve from two curves.","since":"5.0","parameters":[{"name":"curveA","summary":"A first curve."},{"name":"curveB","summary":"A second curve."},{"name":"angleToleranceRadians","summary":"The angle tolerance, in radians, used to match kinks between curves. If you are unsure how to set this parameter, then either use the document\'s angle tolerance RhinoDoc.AngleToleranceRadians, or the default value (RhinoMath.UnsetValue)"}],"returns":"The average curve, or None on error."},{"signature":"static Curve CreatePeriodicCurve(Curve curve)","summary":"Removes kinks from a curve. Periodic curves deform smoothly without kinks.","since":"6.0","parameters":[{"name":"curve","summary":"The curve to make periodic. Curve must have degree >= 2."}],"returns":"The resulting curve if successful, None otherwise."},{"signature":"static Curve CreatePeriodicCurve(Curve curve, bool smooth)","summary":"Removes kinks from a curve. Periodic curves deform smoothly without kinks.","since":"6.0","parameters":[{"name":"curve","summary":"The curve to make periodic. Curve must have degree >= 2."},{"name":"smooth","summary":"If true, smooths any kinks in the curve and moves control points to make a smooth curve. If false, control point locations are not changed or changed minimally (only one point may move) and only the knot vector is altered."}],"returns":"The resulting curve if successful, None otherwise."},{"signature":"static Curve CreateSoftEditCurve(Curve curve, double t, Vector3d delta, double length, bool fixEnds)","summary":"Creates a soft edited curve from an existing curve using a smooth field of influence.","since":"6.0","parameters":[{"name":"curve","summary":"The curve to soft edit."},{"name":"t","summary":"A parameter on the curve to move from. This location on the curve is moved, and the move is smoothly tapered off with increasing distance along the curve from this parameter."},{"name":"delta","summary":"The direction and magnitude, or maximum distance, of the move."},{"name":"length","summary":"The distance along the curve from the editing point over which the strength of the editing falls off smoothly."},{"name":"fixEnds","summary":""}],"returns":"The soft edited curve if successful. None on failure."},{"signature":"static Curve[] CreateTextOutlines(string text, string font, double textHeight, int textStyle, bool closeLoops, Plane plane, double smallCapsScale, double tolerance)","summary":"Creates outline curves created from a text string. The functionality is similar to what you find in Rhino\'s TextObject command or TextEntity.Explode() in RhinoCommon.","since":"6.0","parameters":[{"name":"text","summary":"The text from which to create outline curves."},{"name":"font","summary":"The text font."},{"name":"textHeight","summary":"The text height."},{"name":"textStyle","summary":"The font style. The font style can be any number of the following: 0 - Normal, 1 - Bold, 2 - Italic"},{"name":"closeLoops","summary":"Set this value to True when dealing with normal fonts and when you expect closed loops. You may want to set this to False when specifying a single-stroke font where you don\'t want closed loops."},{"name":"plane","summary":"The plane on which the outline curves will lie."},{"name":"smallCapsScale","summary":"Displays lower-case letters as small caps. Set the relative text size to a percentage of the normal text."},{"name":"tolerance","summary":"The tolerance for the operation."}],"returns":"An array containing one or more curves if successful."},{"signature":"static Curve[] CreateTweenCurves(Curve curve0, Curve curve1, int numCurves)","summary":"Creates curves between two open or closed input curves. Uses the control points of the curves for finding tween curves. That means the first control point of first curve is matched to first control point of the second curve and so on. There is no matching of curves direction. Caller must match input curves direction before calling the function.","since":"5.2","deprecated":"6.0","parameters":[{"name":"curve0","summary":"The first, or starting, curve."},{"name":"curve1","summary":"The second, or ending, curve."},{"name":"numCurves","summary":"Number of tween curves to create."}],"returns":"An array of joint curves. This array can be empty."},{"signature":"static Curve[] CreateTweenCurves(Curve curve0, Curve curve1, int numCurves, double tolerance)","summary":"Creates curves between two open or closed input curves. Uses the control points of the curves for finding tween curves. That means the first control point of first curve is matched to first control point of the second curve and so on. There is no matching of curves direction. Caller must match input curves direction before calling the function.","since":"6.0","parameters":[{"name":"curve0","summary":"The first, or starting, curve."},{"name":"curve1","summary":"The second, or ending, curve."},{"name":"numCurves","summary":"Number of tween curves to create."},{"name":"tolerance","summary":""}],"returns":"An array of joint curves. This array can be empty."},{"signature":"static Curve[] CreateTweenCurvesWithMatching(Curve curve0, Curve curve1, int numCurves)","summary":"Creates curves between two open or closed input curves. Make the structure of input curves compatible if needed. Refits the input curves to have the same structure. The resulting curves are usually more complex than input unless input curves are compatible and no refit is needed. There is no matching of curves direction. Caller must match input curves direction before calling the function.","since":"5.2","deprecated":"6.0","parameters":[{"name":"curve0","summary":"The first, or starting, curve."},{"name":"curve1","summary":"The second, or ending, curve."},{"name":"numCurves","summary":"Number of tween curves to create."}],"returns":"An array of joint curves. This array can be empty."},{"signature":"static Curve[] CreateTweenCurvesWithMatching(Curve curve0, Curve curve1, int numCurves, double tolerance)","summary":"Creates curves between two open or closed input curves. Make the structure of input curves compatible if needed. Refits the input curves to have the same structure. The resulting curves are usually more complex than input unless input curves are compatible and no refit is needed. There is no matching of curves direction. Caller must match input curves direction before calling the function.","since":"6.0","parameters":[{"name":"curve0","summary":"The first, or starting, curve."},{"name":"curve1","summary":"The second, or ending, curve."},{"name":"numCurves","summary":"Number of tween curves to create."},{"name":"tolerance","summary":""}],"returns":"An array of joint curves. This array can be empty."},{"signature":"static Curve[] CreateTweenCurvesWithSampling(Curve curve0, Curve curve1, int numCurves, int numSamples)","summary":"Creates curves between two open or closed input curves. Use sample points method to make curves compatible. This is how the algorithm works: Divides the two curves into an equal number of points, finds the midpoint between the corresponding points on the curves and interpolates the tween curve through those points. There is no matching of curves direction. Caller must match input curves direction before calling the function.","since":"5.2","deprecated":"6.0","parameters":[{"name":"curve0","summary":"The first, or starting, curve."},{"name":"curve1","summary":"The second, or ending, curve."},{"name":"numCurves","summary":"Number of tween curves to create."},{"name":"numSamples","summary":"Number of sample points along input curves."}],"returns":">An array of joint curves. This array can be empty."},{"signature":"static Curve[] CreateTweenCurvesWithSampling(Curve curve0, Curve curve1, int numCurves, int numSamples, double tolerance)","summary":"Creates curves between two open or closed input curves. Use sample points method to make curves compatible. This is how the algorithm works: Divides the two curves into an equal number of points, finds the midpoint between the corresponding points on the curves and interpolates the tween curve through those points. There is no matching of curves direction. Caller must match input curves direction before calling the function.","since":"6.0","parameters":[{"name":"curve0","summary":"The first, or starting, curve."},{"name":"curve1","summary":"The second, or ending, curve."},{"name":"numCurves","summary":"Number of tween curves to create."},{"name":"numSamples","summary":"Number of sample points along input curves."},{"name":"tolerance","summary":""}],"returns":">An array of joint curves. This array can be empty."},{"signature":"static bool DoDirectionsMatch(Curve curveA, Curve curveB)","summary":"Determines whether two curves travel more or less in the same direction.","since":"5.0","parameters":[{"name":"curveA","summary":"First curve to test."},{"name":"curveB","summary":"Second curve to test."}],"returns":"True if both curves more or less point in the same direction, False if they point in the opposite directions."},{"signature":"static bool GetDistancesBetweenCurves(Curve curveA, Curve curveB, double tolerance, out double maxDistance, out double maxDistanceParameterA, out double maxDistanceParameterB, out double minDistance, out double minDistanceParameterA, out double minDistanceParameterB)","summary":"Computes the distances between two arbitrary curves that overlap.","since":"5.0","parameters":[{"name":"curveA","summary":"A curve."},{"name":"curveB","summary":"Another curve."},{"name":"tolerance","summary":"A tolerance value."},{"name":"maxDistance","summary":"The maximum distance value. This is an out reference argument."},{"name":"maxDistanceParameterA","summary":"The maximum distance parameter on curve A. This is an out reference argument."},{"name":"maxDistanceParameterB","summary":"The maximum distance parameter on curve B. This is an out reference argument."},{"name":"minDistance","summary":"The minimum distance value. This is an out reference argument."},{"name":"minDistanceParameterA","summary":"The minimum distance parameter on curve A. This is an out reference argument."},{"name":"minDistanceParameterB","summary":"The minimum distance parameter on curve B. This is an out reference argument."}],"returns":"True if the operation succeeded; otherwise false."},{"signature":"static bool GetFilletPoints(Curve curve0, Curve curve1, double radius, double t0Base, double t1Base, out double t0, out double t1, out Plane filletPlane)","summary":"Finds points at which to cut a pair of curves so that a fillet of given radius can be inserted.","since":"5.0","parameters":[{"name":"curve0","summary":"First curve to fillet."},{"name":"curve1","summary":"Second curve to fillet."},{"name":"radius","summary":"Fillet radius."},{"name":"t0Base","summary":"Parameter value for base point on curve0."},{"name":"t1Base","summary":"Parameter value for base point on curve1."},{"name":"t0","summary":"Parameter value of fillet point on curve 0."},{"name":"t1","summary":"Parameter value of fillet point on curve 1."},{"name":"filletPlane","summary":"The fillet is contained in this plane with the fillet center at the plane origin."}],"returns":"True on success, False on failure."},{"signature":"static Curve[] JoinCurves(IEnumerable<Curve> inputCurves)","summary":"Joins a collection of curve segments together.","since":"5.0","parameters":[{"name":"inputCurves","summary":"Curve segments to join."}],"returns":"An array of curves which contains."},{"signature":"static Curve[] JoinCurves(IEnumerable<Curve> inputCurves, double joinTolerance)","summary":"Joins a collection of curve segments together.","since":"5.0","parameters":[{"name":"inputCurves","summary":"An array, a list or any enumerable set of curve segments to join."},{"name":"joinTolerance","summary":"Joining tolerance, i.e. the distance between segment end-points that is allowed."}],"returns":"An array of joint curves. This array can be empty."},{"signature":"static Curve[] JoinCurves(IEnumerable<Curve> inputCurves, double joinTolerance, bool preserveDirection)","summary":"Joins a collection of curve segments together.","since":"5.0","parameters":[{"name":"inputCurves","summary":"An array, a list or any enumerable set of curve segments to join."},{"name":"joinTolerance","summary":"Joining tolerance, i.e. the distance between segment end-points that is allowed."},{"name":"preserveDirection","summary":"If true, curve endpoints will be compared to curve start points.  \\nIf false, all start and endpoints will be compared and copies of input curves may be reversed in output."}],"returns":"An array of joint curves. This array can be empty."},{"signature":"static bool MakeEndsMeet(Curve curveA, bool adjustStartCurveA, Curve curveB, bool adjustStartCurveB)","summary":"Makes adjustments to the ends of one or both input curves so that they meet at a point.","since":"5.0","parameters":[{"name":"curveA","summary":"1st curve to adjust."},{"name":"adjustStartCurveA","summary":"Which end of the 1st curve to adjust: True is start, False is end."},{"name":"curveB","summary":"2nd curve to adjust."},{"name":"adjustStartCurveB","summary":"which end of the 2nd curve to adjust true==start, false==end."}],"returns":"True on success."},{"signature":"static RegionContainment PlanarClosedCurveRelationship(Curve curveA, Curve curveB, Plane testPlane, double tolerance)","summary":"Determines whether two coplanar simple closed curves are disjoint or intersect; otherwise, if the regions have a containment relationship, discovers which curve encloses the other.","since":"5.0","parameters":[{"name":"curveA","summary":"A first curve."},{"name":"curveB","summary":"A second curve."},{"name":"testPlane","summary":"A plane."},{"name":"tolerance","summary":"A tolerance value."}],"returns":"A value indicating the relationship between the first and the second curve."},{"signature":"static bool PlanarCurveCollision(Curve curveA, Curve curveB, Plane testPlane, double tolerance)","summary":"Determines if two coplanar curves collide (intersect).","since":"5.0","parameters":[{"name":"curveA","summary":"A curve."},{"name":"curveB","summary":"Another curve."},{"name":"testPlane","summary":"A valid plane containing the curves."},{"name":"tolerance","summary":"A tolerance value for intersection."}],"returns":"True if the curves intersect, otherwise false"},{"signature":"static Curve[] ProjectToBrep(Curve curve, Brep brep, Vector3d direction, double tolerance)","summary":"Projects a Curve onto a Brep along a given direction.","since":"5.0","parameters":[{"name":"curve","summary":"Curve to project."},{"name":"brep","summary":"Brep to project onto."},{"name":"direction","summary":"Direction of projection."},{"name":"tolerance","summary":"Tolerance to use for projection."}],"returns":"An array of projected curves or empty array if the projection set is empty."},{"signature":"static Curve[] ProjectToBrep(Curve curve, IEnumerable<Brep> breps, Vector3d direction, double tolerance)","summary":"Projects a Curve onto a collection of Breps along a given direction.","since":"5.0","parameters":[{"name":"curve","summary":"Curve to project."},{"name":"breps","summary":"Breps to project onto."},{"name":"direction","summary":"Direction of projection."},{"name":"tolerance","summary":"Tolerance to use for projection."}],"returns":"An array of projected curves or empty array if the projection set is empty."},{"signature":"static Curve[] ProjectToBrep(Curve curve, IEnumerable<Brep> breps, Vector3d direction, double tolerance, out int[] brepIndices)","summary":"Projects a Curve onto a collection of Breps along a given direction.","since":"5.0","parameters":[{"name":"curve","summary":"Curve to project."},{"name":"breps","summary":"Breps to project onto."},{"name":"direction","summary":"Direction of projection."},{"name":"tolerance","summary":"Tolerance to use for projection."},{"name":"brepIndices","summary":"(out) Integers that identify for each resulting curve which Brep it was projected onto."}],"returns":"An array of projected curves or None if the projection set is empty."},{"signature":"static Curve[] ProjectToBrep(IEnumerable<Curve> curves, IEnumerable<Brep> breps, Vector3d direction, double tolerance)","summary":"Projects a collection of Curves onto a collection of Breps along a given direction.","since":"5.0","parameters":[{"name":"curves","summary":"Curves to project."},{"name":"breps","summary":"Breps to project onto."},{"name":"direction","summary":"Direction of projection."},{"name":"tolerance","summary":"Tolerance to use for projection."}],"returns":"An array of projected curves or empty array if the projection set is empty."},{"signature":"static Curve[] ProjectToBrep(IEnumerable<Curve> curves, IEnumerable<Brep> breps, Vector3d direction, double tolerance, out int[] curveIndices, out int[] brepIndices)","summary":"Projects a collection of Curves onto a collection of Breps along a given direction.","since":"5.0","parameters":[{"name":"curves","summary":"Curves to project."},{"name":"breps","summary":"Breps to project onto."},{"name":"direction","summary":"Direction of projection."},{"name":"tolerance","summary":"Tolerance to use for projection."},{"name":"curveIndices","summary":"Index of which curve in the input list was the source for a curve in the return array."},{"name":"brepIndices","summary":"Index of which brep was used to generate a curve in the return array."}],"returns":"An array of projected curves. Array is empty if the projection set is empty."},{"signature":"static Curve[] ProjectToMesh(Curve curve, IEnumerable<Mesh> meshes, Vector3d direction, double tolerance)","summary":"Projects a curve to a set of meshes using a direction and tolerance.","since":"5.0","parameters":[{"name":"curve","summary":"A curve."},{"name":"meshes","summary":"A list, an array or any enumerable of meshes."},{"name":"direction","summary":"A direction vector."},{"name":"tolerance","summary":"A tolerance value."}],"returns":"A curve array."},{"signature":"static Curve[] ProjectToMesh(Curve curve, Mesh mesh, Vector3d direction, double tolerance)","summary":"Projects a curve to a mesh using a direction and tolerance.","since":"5.0","parameters":[{"name":"curve","summary":"A curve."},{"name":"mesh","summary":"A mesh."},{"name":"direction","summary":"A direction vector."},{"name":"tolerance","summary":"A tolerance value."}],"returns":"A curve array."},{"signature":"static Curve[] ProjectToMesh(IEnumerable<Curve> curves, IEnumerable<Mesh> meshes, Vector3d direction, double tolerance)","summary":"Projects a curve to a set of meshes using a direction and tolerance.","since":"5.0","parameters":[{"name":"curves","summary":"A list, an array or any enumerable of curves."},{"name":"meshes","summary":"A list, an array or any enumerable of meshes."},{"name":"direction","summary":"A direction vector."},{"name":"tolerance","summary":"A tolerance value."}],"returns":"A curve array."},{"signature":"static Curve ProjectToPlane(Curve curve, Plane plane)","summary":"Constructs a curve by projecting an existing curve to a plane.","since":"5.0","parameters":[{"name":"curve","summary":"A curve."},{"name":"plane","summary":"A plane."}],"returns":"The projected curve on success; None on failure."},{"signature":"static Curve[] PullToBrepFace(Curve curve, BrepFace face, double tolerance)","summary":"Pull a curve to a BrepFace using closest point projection.","since":"5.0","parameters":[{"name":"curve","summary":"Curve to pull."},{"name":"face","summary":"Brep face that pulls."},{"name":"tolerance","summary":"Tolerance to use for pulling."}],"returns":"An array of pulled curves, or an empty array on failure."},{"signature":"bool ChangeClosedCurveSeam(double t)","summary":"If this curve is closed, then modify it so that the start/end point is at curve parameter t.","since":"5.0","parameters":[{"name":"t","summary":"Curve parameter of new start/end point. The returned curves domain will start at t."}],"returns":"True on success, False on failure."},{"signature":"bool ChangeDimension(int desiredDimension)","summary":"Changes the dimension of a curve.","since":"5.0","parameters":[{"name":"desiredDimension","summary":"The desired dimension."}],"returns":"True if the curve\'s dimension was already desiredDimension or if the curve\'s dimension was successfully changed to desiredDimension; otherwise false."},{"signature":"CurveOrientation ClosedCurveOrientation()","summary":"Determines the orientation (counterclockwise or clockwise) of a closed, planar curve in the world XY plane. Only works with simple (no self intersections) closed, planar curves.","since":"6.0","returns":"The orientation of this curve with respect to world XY plane."},{"signature":"CurveOrientation ClosedCurveOrientation(Plane plane)","summary":"Determines the orientation (counterclockwise or clockwise) of a closed, planar curve in a given plane. Only works with simple (no self intersections) closed, planar curves.","since":"5.0","parameters":[{"name":"plane","summary":"The plane in which to solve the orientation."}],"returns":"The orientation of this curve in the given plane."},{"signature":"CurveOrientation ClosedCurveOrientation(Transform xform)","summary":"Determines the orientation (counterclockwise or clockwise) of a closed, planar curve. Only works with simple (no self intersections) closed, planar curves.","since":"5.0","parameters":[{"name":"xform","summary":"Transformation to map the curve to the world XY plane."}],"returns":"The orientation of this curve in the world XY-plane."},{"signature":"CurveOrientation ClosedCurveOrientation(Vector3d upDirection)","summary":"Determines the orientation (counterclockwise or clockwise) of a closed, planar curve in a given plane. Only works with simple (no self intersections) closed, planar curves.","since":"5.0","parameters":[{"name":"upDirection","summary":"A vector that is considered \\"up\\"."}],"returns":"The orientation of this curve with respect to a defined up direction."},{"signature":"bool ClosestPoint(Point3d testPoint, out double t)","summary":"Finds parameter of the point on a curve that is closest to testPoint. If the maximumDistance parameter is > 0, then only points whose distance to the given point is <= maximumDistance will be returned.  Using a positive value of maximumDistance can substantially speed up the search.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to search from."},{"name":"t","summary":"Parameter of local closest point."}],"returns":"True on success, False on failure."},{"signature":"bool ClosestPoint(Point3d testPoint, out double t, double maximumDistance)","summary":"Finds the parameter of the point on a curve that is closest to testPoint. If the maximumDistance parameter is > 0, then only points whose distance to the given point is <= maximumDistance will be returned.  Using a positive value of maximumDistance can substantially speed up the search.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to project."},{"name":"t","summary":"parameter of local closest point returned here."},{"name":"maximumDistance","summary":"The maximum allowed distance.  \\nPast this distance, the search is given up and False is returned.  \\nUse 0 to turn off this parameter."}],"returns":"True on success, False on failure."},{"signature":"bool ClosestPoints(Curve otherCurve, out Point3d pointOnThisCurve, out Point3d pointOnOtherCurve)","summary":"Gets closest points between this and another curves.","since":"5.0","parameters":[{"name":"otherCurve","summary":"The other curve."},{"name":"pointOnThisCurve","summary":"The point on this curve. This out parameter is assigned during this call."},{"name":"pointOnOtherCurve","summary":"The point on other curve. This out parameter is assigned during this call."}],"returns":"True on success; False on error."},{"signature":"bool ClosestPoints(IEnumerable<GeometryBase> geometry, out Point3d pointOnCurve, out Point3d pointOnObject, out int whichGeometry)","summary":"Finds the object (and the closest point in that object) that is closest to this curve.  \\nBreps, surfaces, curves and point clouds are examples of objects that can be passed to this function.","since":"5.0","parameters":[{"name":"geometry","summary":"A list, an array or any enumerable set of geometry to search."},{"name":"pointOnCurve","summary":"The point on curve. This out parameter is assigned during this call."},{"name":"pointOnObject","summary":"The point on geometry. This out parameter is assigned during this call."},{"name":"whichGeometry","summary":"The index of the geometry. This out parameter is assigned during this call."}],"returns":"True on success; False if no object was found or selected."},{"signature":"bool ClosestPoints(IEnumerable<GeometryBase> geometry, out Point3d pointOnCurve, out Point3d pointOnObject, out int whichGeometry, double maximumDistance)","summary":"Finds the object (and the closest point in that object) that is closest to this curve.  \\nBreps, surfaces, curves and point clouds are examples of objects that can be passed to this function.","since":"5.0","parameters":[{"name":"geometry","summary":"A list, an array or any enumerable set of geometry to search."},{"name":"pointOnCurve","summary":"The point on curve. This out parameter is assigned during this call."},{"name":"pointOnObject","summary":"The point on geometry. This out parameter is assigned during this call."},{"name":"whichGeometry","summary":"The index of the geometry. This out parameter is assigned during this call."},{"name":"maximumDistance","summary":"Maximum allowable distance. Past this distance, the research is given up and False is returned."}],"returns":"True on success; False if no object was found or selected."},{"signature":"PointContainment Contains(Point3d testPoint)","summary":"Computes the relationship between a point and a closed curve region. This curve must be closed or the return value will be Unset. Both curve and point are projected to the World XY plane.","since":"5.0","deprecated":"6.0","parameters":[{"name":"testPoint","summary":"Point to test."}],"returns":"Relationship between point and curve region."},{"signature":"PointContainment Contains(Point3d testPoint, Plane plane)","summary":"Computes the relationship between a point and a closed curve region. This curve must be closed or the return value will be Unset.","since":"5.0","deprecated":"6.0","parameters":[{"name":"testPoint","summary":"Point to test."},{"name":"plane","summary":"Plane in which to compare point and region."}],"returns":"Relationship between point and curve region."},{"signature":"PointContainment Contains(Point3d testPoint, Plane plane, double tolerance)","summary":"Computes the relationship between a point and a closed curve region. This curve must be closed or the return value will be Unset.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to test."},{"name":"plane","summary":"Plane in which to compare point and region."},{"name":"tolerance","summary":"Tolerance to use during comparison."}],"returns":"Relationship between point and curve region."},{"signature":"Vector3d CurvatureAt(double t)","summary":"Evaluate the curvature vector at a curve parameter.","since":"5.0","parameters":[{"name":"t","summary":"Evaluation parameter."}],"returns":"Curvature vector of the curve at the parameter t."},{"signature":"Vector3d[] DerivativeAt(double t, int derivativeCount)","summary":"Evaluate the derivatives at the specified curve parameter.","since":"5.0","parameters":[{"name":"t","summary":"Curve parameter to evaluate."},{"name":"derivativeCount","summary":"Number of derivatives to evaluate, must be at least 0."}],"returns":"An array of vectors that represents all the derivatives starting at zero."},{"signature":"Vector3d[] DerivativeAt(double t, int derivativeCount, CurveEvaluationSide side)","summary":"Evaluate the derivatives at the specified curve parameter.","since":"5.0","parameters":[{"name":"t","summary":"Curve parameter to evaluate."},{"name":"derivativeCount","summary":"Number of derivatives to evaluate, must be at least 0."},{"name":"side","summary":"Side of parameter to evaluate. If the parameter is at a kink, it makes a big difference whether the evaluation is from below or above."}],"returns":"An array of vectors that represents all the derivatives starting at zero."},{"signature":"Point3d[] DivideAsContour(Point3d contourStart, Point3d contourEnd, double interval)","summary":"Divides this curve at fixed steps along a defined contour line.","since":"5.0","parameters":[{"name":"contourStart","summary":"The start of the contouring line."},{"name":"contourEnd","summary":"The end of the contouring line."},{"name":"interval","summary":"A distance to measure on the contouring axis."}],"returns":"An array of points; or None on error."},{"signature":"double[] DivideByCount(int segmentCount, bool includeEnds)","summary":"Divide the curve into a number of equal-length segments.","since":"5.0","parameters":[{"name":"segmentCount","summary":"Segment count. Note that the number of division points may differ from the segment count."},{"name":"includeEnds","summary":"If true, then the point at the start of the first division segment is returned."}],"returns":"List of curve parameters at the division points on success, None on failure."},{"signature":"double[] DivideByCount(int segmentCount, bool includeEnds, out Point3d[] points)","summary":"Divide the curve into a number of equal-length segments.","since":"5.0","parameters":[{"name":"segmentCount","summary":"Segment count. Note that the number of division points may differ from the segment count."},{"name":"includeEnds","summary":"If true, then the point at the start of the first division segment is returned."},{"name":"points","summary":"A list of division points. If the function returns successfully, this point-array will be filled in."}],"returns":"Array containing division curve parameters on success, None on failure."},{"signature":"double[] DivideByLength(double segmentLength, bool includeEnds)","summary":"Divide the curve into specific length segments.","since":"5.0","parameters":[{"name":"segmentLength","summary":"The length of each and every segment (except potentially the last one)."},{"name":"includeEnds","summary":"If true, then the point at the start of the first division segment is returned."}],"returns":"Array containing division curve parameters if successful, None on failure."},{"signature":"double[] DivideByLength(double segmentLength, bool includeEnds, bool reverse)","summary":"Divide the curve into specific length segments.","since":"6.0","parameters":[{"name":"segmentLength","summary":"The length of each and every segment (except potentially the last one)."},{"name":"includeEnds","summary":"If true, then the point at the start of the first division segment is returned."},{"name":"reverse","summary":"If true, then the divisions start from the end of the curve."}],"returns":"Array containing division curve parameters if successful, None on failure."},{"signature":"double[] DivideByLength(double segmentLength, bool includeEnds, bool reverse, out Point3d[] points)","summary":"Divide the curve into specific length segments.","since":"6.0","parameters":[{"name":"segmentLength","summary":"The length of each and every segment (except potentially the last one)."},{"name":"includeEnds","summary":"If true, then the point at the start of the first division segment is returned."},{"name":"reverse","summary":"If true, then the divisions start from the end of the curve."},{"name":"points","summary":"If function is successful, points at each parameter value are returned in points."}],"returns":"Array containing division curve parameters if successful, None on failure."},{"signature":"double[] DivideByLength(double segmentLength, bool includeEnds, out Point3d[] points)","summary":"Divide the curve into specific length segments.","since":"5.0","parameters":[{"name":"segmentLength","summary":"The length of each and every segment (except potentially the last one)."},{"name":"includeEnds","summary":"If true, then the point at the start of the first division segment is returned."},{"name":"points","summary":"If function is successful, points at each parameter value are returned in points."}],"returns":"Array containing division curve parameters if successful, None on failure."},{"signature":"Point3d[] DivideEquidistant(double distance)","summary":"Calculates 3d points on a curve where the linear distance between the points is equal.","since":"5.0","parameters":[{"name":"distance","summary":"The distance between division points."}],"returns":"An array of equidistant points, or None on error."},{"signature":"GeometryBase Duplicate()","summary":"Constructs an exact duplicate of this Curve.","since":"5.0"},{"signature":"Curve DuplicateCurve()","summary":"Constructs an exact duplicate of this curve.","since":"5.0","returns":"An exact copy of this curve."},{"signature":"Curve[] DuplicateSegments()","summary":"Polylines will be exploded into line segments. ExplodeCurves will return the curves in topological order.","since":"5.0","returns":"An array of all the segments that make up this curve."},{"signature":"Curve Extend(CurveEnd side, CurveExtensionStyle style, IEnumerable<GeometryBase> geometry)","summary":"Extends a curve until it intersects a collection of objects.","since":"5.0","parameters":[{"name":"side","summary":"The end of the curve to extend."},{"name":"style","summary":"The style or type of extension to use."},{"name":"geometry","summary":"A collection of objects. Allowable object types are Curve, Surface, Brep."}],"returns":"New extended curve result on success, None on failure."},{"signature":"Curve Extend(CurveEnd side, CurveExtensionStyle style, Point3d endPoint)","summary":"Extends a curve to a point.","since":"5.0","parameters":[{"name":"side","summary":"The end of the curve to extend."},{"name":"style","summary":"The style or type of extension to use."},{"name":"endPoint","summary":"A new end point."}],"returns":"New extended curve result on success, None on failure."},{"signature":"Curve Extend(CurveEnd side, double length, CurveExtensionStyle style)","summary":"Extends a curve by a specific length.","since":"5.0","parameters":[{"name":"side","summary":"Curve end to extend."},{"name":"length","summary":"Length to add to the curve end."},{"name":"style","summary":"Extension style."}],"returns":"A curve with extended ends or None on failure."},{"signature":"Curve Extend(double t0, double t1)","summary":"Where possible, analytically extends curve to include the given domain. This will not work on closed curves. The original curve will be identical to the restriction of the resulting curve to the original curve domain.","since":"5.0","parameters":[{"name":"t0","summary":"Start of extension domain, if the start is not inside the Domain of this curve, an attempt will be made to extend the curve."},{"name":"t1","summary":"End of extension domain, if the end is not inside the Domain of this curve, an attempt will be made to extend the curve."}],"returns":"Extended curve on success, None on failure."},{"signature":"Curve Extend(Interval domain)","summary":"Where possible, analytically extends curve to include the given domain. This will not work on closed curves. The original curve will be identical to the restriction of the resulting curve to the original curve domain.","since":"5.0","parameters":[{"name":"domain","summary":"Extension domain."}],"returns":"Extended curve on success, None on failure."},{"signature":"Curve ExtendByArc(CurveEnd side, IEnumerable<GeometryBase> geometry)","summary":"Extends a curve by an Arc until it intersects a collection of objects.","since":"5.0","parameters":[{"name":"side","summary":"The end of the curve to extend."},{"name":"geometry","summary":"A collection of objects. Allowable object types are Curve, Surface, Brep."}],"returns":"New extended curve result on success, None on failure."},{"signature":"Curve ExtendByLine(CurveEnd side, IEnumerable<GeometryBase> geometry)","summary":"Extends a curve by a line until it intersects a collection of objects.","since":"5.0","parameters":[{"name":"side","summary":"The end of the curve to extend."},{"name":"geometry","summary":"A collection of objects. Allowable object types are Curve, Surface, Brep."}],"returns":"New extended curve result on success, None on failure."},{"signature":"Curve ExtendOnSurface(CurveEnd side, BrepFace face)","summary":"Extends a curve on a surface.","since":"5.0","parameters":[{"name":"side","summary":"The end of the curve to extend."},{"name":"face","summary":"BrepFace that contains the curve."}],"returns":"New extended curve result on success, None on failure."},{"signature":"Curve ExtendOnSurface(CurveEnd side, Surface surface)","summary":"Extends a curve on a surface.","since":"5.0","parameters":[{"name":"side","summary":"The end of the curve to extend."},{"name":"surface","summary":"Surface that contains the curve."}],"returns":"New extended curve result on success, None on failure."},{"signature":"double[] ExtremeParameters(Vector3d direction)","summary":"Returns the parameter values of all local extrema. Parameter values are in increasing order so consecutive extrema define an interval on which each component of the curve is monotone. Note, non-periodic curves always return the end points.","since":"6.0","parameters":[{"name":"direction","summary":"The direction in which to perform the calculation."}],"returns":"The parameter values of all local extrema."},{"signature":"Curve Fair(double distanceTolerance, double angleTolerance, int clampStart, int clampEnd, int iterations)","summary":"Fairs a curve object. Fair works best on degree 3 (cubic) curves. Attempts to remove large curvature variations while limiting the geometry changes to be no more than the specified tolerance.","since":"5.0","parameters":[{"name":"distanceTolerance","summary":"Maximum allowed distance the faired curve is allowed to deviate from the input."},{"name":"angleTolerance","summary":"(in radians) kinks with angles <= angleTolerance are smoothed out 0.05 is a good default."},{"name":"clampStart","summary":"The number of (control vertices-1) to preserve at start.  \\n0 = preserve start point  \\n1 = preserve start point and 1st derivative  \\n2 = preserve start point, 1st and 2nd derivative"},{"name":"clampEnd","summary":"Same as clampStart."},{"name":"iterations","summary":"The number of iterations to use in adjusting the curve."}],"returns":"Returns new faired Curve on success, None on failure."},{"signature":"Curve Fit(int degree, double fitTolerance, double angleTolerance)","summary":"Fits a new curve through an existing curve.","since":"5.0","parameters":[{"name":"degree","summary":"The degree of the returned Curve. Must be bigger than 1."},{"name":"fitTolerance","summary":"The fitting tolerance. If fitTolerance is RhinoMath.UnsetValue or <=0.0, the document absolute tolerance is used."},{"name":"angleTolerance","summary":"The kink smoothing tolerance in radians.  \\nIf angleTolerance is 0.0, all kinks are smoothed  \\nIf angleTolerance is >0.0, kinks smaller than angleTolerance are smoothed  \\nIf angleTolerance is RhinoMath.UnsetValue or <0.0, the document angle tolerance is used for the kink smoothing"}],"returns":"Returns a new fitted Curve if successful, None on failure."},{"signature":"bool FrameAt(double t, out Plane plane)","summary":"Returns a 3d frame at a parameter.","since":"5.0","parameters":[{"name":"t","summary":"Evaluation parameter."},{"name":"plane","summary":"The frame is returned here."}],"returns":"True on success, False on failure."},{"signature":"ConicSectionType GetConicSectionType()","summary":"Returns the type of conic section based on the curve\'s shape.","since":"6.0"},{"signature":"ConicSectionType GetConicSectionType(out Point3d focus1, out Point3d focus2, out Point3d center)","summary":"Returns the type of conic section based on the curve\'s shape.","since":"6.0","parameters":[{"name":"focus1","summary":"The first focus point, if applicable."},{"name":"focus2","summary":"The second focus point, if applicable."},{"name":"center","summary":"The center point, if applicable."}]},{"signature":"bool GetCurveParameterFromNurbsFormParameter(double nurbsParameter, out double curveParameter)","summary":"Convert a NURBS curve parameter to a curve parameter.","since":"5.0","parameters":[{"name":"nurbsParameter","summary":"NURBS form parameter."},{"name":"curveParameter","summary":"Curve parameter."}],"returns":"True on success, False on failure."},{"signature":"double GetLength()","summary":"Gets the length of the curve with a fractional tolerance of 1.0e-8.","since":"5.0","returns":"The length of the curve on success, or zero on failure."},{"signature":"double GetLength(double fractionalTolerance)","summary":"Get the length of the curve.","since":"5.0","parameters":[{"name":"fractionalTolerance","summary":"Desired fractional precision. fabs((\\"exact\\" length from start to t) - arc_length)/arc_length <= fractionalTolerance."}],"returns":"The length of the curve on success, or zero on failure."},{"signature":"double GetLength(double fractionalTolerance, Interval subdomain)","summary":"Get the length of a sub-section of the curve.","since":"5.0","parameters":[{"name":"fractionalTolerance","summary":"Desired fractional precision. fabs((\\"exact\\" length from start to t) - arc_length)/arc_length <= fractionalTolerance."},{"name":"subdomain","summary":"The calculation is performed on the specified sub-domain of the curve (must be non-decreasing)."}],"returns":"The length of the sub-curve on success, or zero on failure."},{"signature":"double GetLength(Interval subdomain)","summary":"Get the length of a sub-section of the curve with a fractional tolerance of 1e-8.","since":"5.0","parameters":[{"name":"subdomain","summary":"The calculation is performed on the specified sub-domain of the curve (must be non-decreasing)."}],"returns":"The length of the sub-curve on success, or zero on failure."},{"signature":"bool GetLocalPerpPoint(Point3d testPoint, double seedParmameter, Interval subDomain, out double curveParameter)","summary":"Search for a location on the curve, near seedParmameter, that is perpendicular to a test point.","since":"6.0","parameters":[{"name":"testPoint","summary":"The test point."},{"name":"seedParmameter","summary":"A \\"seed\\" parameter on the curve."},{"name":"subDomain","summary":"The sub-domain of the curve to search."},{"name":"curveParameter","summary":"The parameter value at the perpendicular point"}],"returns":"True if a solution is found, False otherwise."},{"signature":"bool GetLocalPerpPoint(Point3d testPoint, double seedParmameter, out double curveParameter)","summary":"Search for a location on the curve, near seedParmameter, that is perpendicular to a test point.","since":"6.0","parameters":[{"name":"testPoint","summary":"The test point."},{"name":"seedParmameter","summary":"A \\"seed\\" parameter on the curve."},{"name":"curveParameter","summary":"The parameter value at the perpendicular point"}],"returns":"True if a solution is found, False otherwise."},{"signature":"bool GetLocalTangentPoint(Point3d testPoint, double seedParmameter, Interval subDomain, out double curveParameter)","summary":"Search for a location on the curve, near seedParmameter, that is tangent to a test point.","since":"6.0","parameters":[{"name":"testPoint","summary":"The test point."},{"name":"seedParmameter","summary":"A \\"seed\\" parameter on the curve."},{"name":"subDomain","summary":"The sub-domain of the curve to search."},{"name":"curveParameter","summary":"The parameter value at the tangent point"}],"returns":"True if a solution is found, False otherwise."},{"signature":"bool GetLocalTangentPoint(Point3d testPoint, double seedParmameter, out double curveParameter)","summary":"Search for a location on the curve, near seedParmameter, that is tangent to a test point.","since":"6.0","parameters":[{"name":"testPoint","summary":"The test point."},{"name":"seedParmameter","summary":"A \\"seed\\" parameter on the curve."},{"name":"curveParameter","summary":"The parameter value at the tangent point"}],"returns":"True if a solution is found, False otherwise."},{"signature":"bool GetNextDiscontinuity(Continuity continuityType, double t0, double t1, out double t)","summary":"Searches for a derivative, tangent, or curvature discontinuity.","since":"5.0","parameters":[{"name":"continuityType","summary":"Type of continuity to search for."},{"name":"t0","summary":"Search begins at t0. If there is a discontinuity at t0, it will be ignored. This makes it possible to repeatedly call GetNextDiscontinuity() and step through the discontinuities."},{"name":"t1","summary":"(t0 != t1)  If there is a discontinuity at t1 it will be ignored unless continuityType is a locus discontinuity type and t1 is at the start or end of the curve."},{"name":"t","summary":"If a discontinuity is found, then t reports the parameter at the discontinuity."}],"returns":"Parametric continuity tests c = (C0_continuous, ..., G2_continuous): True if a parametric discontinuity was found strictly between t0 and t1. Note well that all curves are parametrically continuous at the ends of their domains.  Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous): True if a locus discontinuity was found strictly between t0 and t1 or at t1 is the at the end of a curve. Note well that all open curves (IsClosed()=false) are locus discontinuous at the ends of their domains.  All closed curves (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains."},{"signature":"bool GetNurbsFormParameterFromCurveParameter(double curveParameter, out double nurbsParameter)","summary":"Convert a curve parameter to a NURBS curve parameter.","since":"5.0","parameters":[{"name":"curveParameter","summary":"Curve parameter."},{"name":"nurbsParameter","summary":"NURBS form parameter."}],"returns":"True on success, False on failure."},{"signature":"Plane[] GetPerpendicularFrames(IEnumerable<double> parameters)","summary":"Gets a collection of perpendicular frames along the curve. Perpendicular frames are also known as \'Zero-twisting frames\' and they minimize rotation from one frame to the next.","since":"5.0","parameters":[{"name":"parameters","summary":"A collection ofstrictly increasingcurve parameters to place perpendicular frames on."}],"returns":"An array of perpendicular frames on success or None on failure."},{"signature":"int HasNurbsForm()","summary":"Does a NURBS curve representation of this curve exist?","since":"5.0","returns":"0   unable to create NURBS representation with desired accuracy. 1   success - NURBS parameterization matches the curve\'s to the desired accuracy 2   success - NURBS point locus matches the curve\'s and the domain of the NURBS curve is correct. However, This curve\'s parameterization and the NURBS curve parameterization may not match. This situation happens when getting NURBS representations of curves that have a transcendental parameterization like circles."},{"signature":"Point3d[] InflectionPoints()","summary":"Returns a curve\'s inflection points. An inflection point is a location on a curve at which the sign of the curvature (i.e., the concavity) changes. The curvature at these locations is always 0.","since":"7.0","returns":"An array of points if successful, None if not successful or on error."},{"signature":"bool IsArc()","summary":"Test a curve to see if it can be represented by an arc or circle within RhinoMath.ZeroTolerance.","since":"5.0","returns":"True if the curve can be represented by an arc or a circle within tolerance."},{"signature":"bool IsArc(double tolerance)","summary":"Test a curve to see if it can be represented by an arc or circle within the given tolerance.","since":"5.0","parameters":[{"name":"tolerance","summary":"Tolerance to use when checking."}],"returns":"True if the curve can be represented by an arc or a circle within tolerance."},{"signature":"bool IsCircle()","summary":"Test a curve to see if it can be represented by a circle within RhinoMath.ZeroTolerance.","since":"5.0","returns":"True if the Curve can be represented by a circle within tolerance."},{"signature":"bool IsCircle(double tolerance)","summary":"Test a curve to see if it can be represented by a circle within the given tolerance.","since":"5.0","parameters":[{"name":"tolerance","summary":"Tolerance to use when checking."}],"returns":"True if the curve can be represented by a circle to within tolerance."},{"signature":"bool IsClosable(double tolerance)","summary":"Decide if it makes sense to close off this curve by moving the endpoint to the start based on start-end gap size and length of curve as approximated by chord defined by 6 points.","since":"5.0","parameters":[{"name":"tolerance","summary":"Maximum allowable distance between start and end. If start - end gap is greater than tolerance, this function will return false."}],"returns":"True if start and end points are close enough based on above conditions."},{"signature":"bool IsClosable(double tolerance, double minimumAbsoluteSize, double minimumRelativeSize)","summary":"Decide if it makes sense to close off this curve by moving the endpoint to the start based on start-end gap size and length of curve as approximated by chord defined by 6 points.","since":"5.0","parameters":[{"name":"tolerance","summary":"Maximum allowable distance between start and end. If start - end gap is greater than tolerance, this function will return false."},{"name":"minimumAbsoluteSize","summary":"If greater than 0.0 and none of the interior sampled points are at least minimumAbsoluteSize from start, this function will return false."},{"name":"minimumRelativeSize","summary":"If greater than 1.0 and chord length is less than minimumRelativeSize*gap, this function will return false."}],"returns":"True if start and end points are close enough based on above conditions."},{"signature":"bool IsContinuous(Continuity continuityType, double t)","summary":"Test continuity at a curve parameter value.","since":"5.0","parameters":[{"name":"continuityType","summary":"Type of continuity to test for."},{"name":"t","summary":"Parameter to test."}],"returns":"True if the curve has at least the c type continuity at the parameter t."},{"signature":"bool IsEllipse()","summary":"Test a curve to see if it can be represented by an ellipse within RhinoMath.ZeroTolerance.","since":"5.0","returns":"True if the Curve can be represented by an ellipse within tolerance."},{"signature":"bool IsEllipse(double tolerance)","summary":"Test a curve to see if it can be represented by an ellipse within a given tolerance.","since":"5.0","parameters":[{"name":"tolerance","summary":"Tolerance to use for checking."}],"returns":"True if the Curve can be represented by an ellipse within tolerance."},{"signature":"bool IsInPlane(Plane testPlane)","summary":"Test a curve to see if it lies in a specific plane.","since":"5.0","parameters":[{"name":"testPlane","summary":"Plane to test for."}],"returns":"True if the maximum distance from the curve to the testPlane is <= RhinoMath.ZeroTolerance."},{"signature":"bool IsInPlane(Plane testPlane, double tolerance)","summary":"Test a curve to see if it lies in a specific plane.","since":"5.0","parameters":[{"name":"testPlane","summary":"Plane to test for."},{"name":"tolerance","summary":"Tolerance to use when checking."}],"returns":"True if the maximum distance from the curve to the testPlane is <= tolerance."},{"signature":"bool IsLinear()","summary":"Test a curve to see if it is linear to within RhinoMath.ZeroTolerance units (1e-12).","since":"5.0","returns":"True if the curve is linear."},{"signature":"bool IsLinear(double tolerance)","summary":"Test a curve to see if it is linear to within the custom tolerance.","since":"5.0","parameters":[{"name":"tolerance","summary":"Tolerance to use when checking linearity."}],"returns":"True if the ends of the curve are farther than tolerance apart and the maximum distance from any point on the curve to the line segment connecting the curve ends is <= tolerance."},{"signature":"bool IsPlanar()","summary":"Test a curve for planarity.","since":"5.0","returns":"True if the curve is planar (flat) to within RhinoMath.ZeroTolerance units (1e-12)."},{"signature":"bool IsPlanar(double tolerance)","summary":"Test a curve for planarity.","since":"5.0","parameters":[{"name":"tolerance","summary":"Tolerance to use when checking."}],"returns":"True if there is a plane such that the maximum distance from the curve to the plane is <= tolerance."},{"signature":"bool IsPolyline()","summary":"Several types of Curve can have the form of a polyline including a degree 1 NurbsCurve, a PolylineCurve, and a PolyCurve all of whose segments are some form of polyline. IsPolyline tests a curve to see if it can be represented as a polyline.","since":"5.0","returns":"True if this curve can be represented as a polyline; otherwise, false."},{"signature":"bool IsShort(double tolerance)","summary":"Used to quickly find short curves.","since":"5.0","parameters":[{"name":"tolerance","summary":"Length threshold value for \\"shortness\\"."}],"returns":"True if the length of the curve is <= tolerance."},{"signature":"bool IsShort(double tolerance, Interval subdomain)","summary":"Used to quickly find short curves.","since":"5.0","parameters":[{"name":"tolerance","summary":"Length threshold value for \\"shortness\\"."},{"name":"subdomain","summary":"The test is performed on the interval that is the intersection of sub-domain with Domain()"}],"returns":"True if the length of the curve is <= tolerance."},{"signature":"bool LcoalClosestPoint(Point3d testPoint, double seed, out double t)","summary":"Find parameter of the point on a curve that is locally closest to the testPoint.  The search for a local close point starts at a seed parameter.","since":"6.3","deprecated":"6.18","parameters":[{"name":"testPoint","summary":"A point to test against."},{"name":"seed","summary":"The seed parameter."},{"name":"t","summary":">Parameter of the curve that is closest to testPoint."}],"returns":"True if the search is successful, False if the search fails."},{"signature":"bool LengthParameter(double segmentLength, out double t)","summary":"Gets the parameter along the curve which coincides with a given length along the curve. A fractional tolerance of 1e-8 is used in this version of the function.","since":"5.0","parameters":[{"name":"segmentLength","summary":"Length of segment to measure. Must be less than or equal to the length of the curve."},{"name":"t","summary":"Parameter such that the length of the curve from the curve start point to t equals length."}],"returns":"True on success, False on failure."},{"signature":"bool LengthParameter(double segmentLength, out double t, double fractionalTolerance)","summary":"Gets the parameter along the curve which coincides with a given length along the curve.","since":"5.0","parameters":[{"name":"segmentLength","summary":"Length of segment to measure. Must be less than or equal to the length of the curve."},{"name":"t","summary":"Parameter such that the length of the curve from the curve start point to t equals s."},{"name":"fractionalTolerance","summary":"Desired fractional precision. fabs((\\"exact\\" length from start to t) - arc_length)/arc_length <= fractionalTolerance."}],"returns":"True on success, False on failure."},{"signature":"bool LengthParameter(double segmentLength, out double t, double fractionalTolerance, Interval subdomain)","summary":"Gets the parameter along the curve which coincides with a given length along the curve.","since":"5.0","parameters":[{"name":"segmentLength","summary":"Length of segment to measure. Must be less than or equal to the length of the sub-domain."},{"name":"t","summary":"Parameter such that the length of the curve from the start of the sub-domain to t is s."},{"name":"fractionalTolerance","summary":"Desired fractional precision. fabs((\\"exact\\" length from start to t) - arc_length)/arc_length <= fractionalTolerance."},{"name":"subdomain","summary":"The calculation is performed on the specified sub-domain of the curve rather than the whole curve."}],"returns":"True on success, False on failure."},{"signature":"bool LengthParameter(double segmentLength, out double t, Interval subdomain)","summary":"Gets the parameter along the curve which coincides with a given length along the curve. A fractional tolerance of 1e-8 is used in this version of the function.","since":"5.0","parameters":[{"name":"segmentLength","summary":"Length of segment to measure. Must be less than or equal to the length of the sub-domain."},{"name":"t","summary":"Parameter such that the length of the curve from the start of the sub-domain to t is s."},{"name":"subdomain","summary":"The calculation is performed on the specified sub-domain of the curve rather than the whole curve."}],"returns":"True on success, False on failure."},{"signature":"bool LocalClosestPoint(Point3d testPoint, double seed, out double t)","summary":"Find parameter of the point on a curve that is locally closest to the testPoint.  The search for a local close point starts at a seed parameter.","since":"6.18","parameters":[{"name":"testPoint","summary":"A point to test against."},{"name":"seed","summary":"The seed parameter."},{"name":"t","summary":">Parameter of the curve that is closest to testPoint."}],"returns":"True if the search is successful, False if the search fails."},{"signature":"bool MakeClosed(double tolerance)","summary":"If IsClosed, just return true. Otherwise, decide if curve can be closed as follows: Linear curves polylinear curves with 2 segments, NURBS with 3 or less control points cannot be made closed. Also, if tolerance > 0 and the gap between start and end is larger than tolerance, curve cannot be made closed. Adjust the curve\'s endpoint to match its start point.","since":"5.0","parameters":[{"name":"tolerance","summary":"If nonzero, and the gap is more than tolerance, curve cannot be made closed."}],"returns":"True on success, False on failure."},{"signature":"Point3d[] MaxCurvaturePoints()","summary":"Returns a curve\'s maximum curvature points. The maximum curvature points identify where the curvature starts to decrease in both directions from the points.","since":"7.0","returns":"An array of points if successful, None if not successful or on error."},{"signature":"bool NormalizedLengthParameter(double s, out double t)","summary":"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve. A fractional tolerance of 1e-8 is used in this version of the function.","since":"5.0","parameters":[{"name":"s","summary":"Normalized arc length parameter. E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve."},{"name":"t","summary":"Parameter such that the length of the curve from its start to t is arc_length."}],"returns":"True on success, False on failure."},{"signature":"bool NormalizedLengthParameter(double s, out double t, double fractionalTolerance)","summary":"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.","since":"5.0","parameters":[{"name":"s","summary":"Normalized arc length parameter. E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve."},{"name":"t","summary":"Parameter such that the length of the curve from its start to t is arc_length."},{"name":"fractionalTolerance","summary":"Desired fractional precision. fabs((\\"exact\\" length from start to t) - arc_length)/arc_length <= fractionalTolerance."}],"returns":"True on success, False on failure."},{"signature":"bool NormalizedLengthParameter(double s, out double t, double fractionalTolerance, Interval subdomain)","summary":"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.","since":"5.0","parameters":[{"name":"s","summary":"Normalized arc length parameter. E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve."},{"name":"t","summary":"Parameter such that the length of the curve from its start to t is arc_length."},{"name":"fractionalTolerance","summary":"Desired fractional precision. fabs((\\"exact\\" length from start to t) - arc_length)/arc_length <= fractionalTolerance."},{"name":"subdomain","summary":"The calculation is performed on the specified sub-domain of the curve."}],"returns":"True on success, False on failure."},{"signature":"bool NormalizedLengthParameter(double s, out double t, Interval subdomain)","summary":"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve. A fractional tolerance of 1e-8 is used in this version of the function.","since":"5.0","parameters":[{"name":"s","summary":"Normalized arc length parameter. E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve."},{"name":"t","summary":"Parameter such that the length of the curve from its start to t is arc_length."},{"name":"subdomain","summary":"The calculation is performed on the specified sub-domain of the curve."}],"returns":"True on success, False on failure."},{"signature":"double[] NormalizedLengthParameters(double[] s, double absoluteTolerance)","summary":"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve. A fractional tolerance of 1e-8 is used in this version of the function.","since":"5.0","parameters":[{"name":"s","summary":"Array of normalized arc length parameters. E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve."},{"name":"absoluteTolerance","summary":"If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance."}],"returns":"If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length. Null on failure."},{"signature":"double[] NormalizedLengthParameters(double[] s, double absoluteTolerance, double fractionalTolerance)","summary":"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.","since":"5.0","parameters":[{"name":"s","summary":"Array of normalized arc length parameters. E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve."},{"name":"absoluteTolerance","summary":"If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance."},{"name":"fractionalTolerance","summary":"Desired fractional precision for each segment. fabs(\\"true\\" length - actual length)/(actual length) <= fractionalTolerance."}],"returns":"If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length. Null on failure."},{"signature":"double[] NormalizedLengthParameters(double[] s, double absoluteTolerance, double fractionalTolerance, Interval subdomain)","summary":"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.","since":"5.0","parameters":[{"name":"s","summary":"Array of normalized arc length parameters. E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve."},{"name":"absoluteTolerance","summary":"If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance."},{"name":"fractionalTolerance","summary":"Desired fractional precision for each segment. fabs(\\"true\\" length - actual length)/(actual length) <= fractionalTolerance."},{"name":"subdomain","summary":"The calculation is performed on the specified sub-domain of the curve. A 0.0 s value corresponds to sub-domain->Min() and a 1.0 s value corresponds to sub-domain->Max()."}],"returns":"If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length. Null on failure."},{"signature":"double[] NormalizedLengthParameters(double[] s, double absoluteTolerance, Interval subdomain)","summary":"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve. A fractional tolerance of 1e-8 is used in this version of the function.","since":"5.0","parameters":[{"name":"s","summary":"Array of normalized arc length parameters. E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve."},{"name":"absoluteTolerance","summary":"If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance."},{"name":"subdomain","summary":"The calculation is performed on the specified sub-domain of the curve. A 0.0 s value corresponds to sub-domain->Min() and a 1.0 s value corresponds to sub-domain->Max()."}],"returns":"If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length. Null on failure."},{"signature":"Curve[] Offset(Plane plane, double distance, double tolerance, CurveOffsetCornerStyle cornerStyle)","summary":"Offsets this curve. If you have a nice offset, then there will be one entry in the array. If the original curve had kinks or the offset curve had self intersections, you will get multiple segments in the output array.","since":"5.0","parameters":[{"name":"plane","summary":"Offset solution plane."},{"name":"distance","summary":"The positive or negative distance to offset."},{"name":"tolerance","summary":"The offset or fitting tolerance."},{"name":"cornerStyle","summary":"Corner style for offset kinks."}],"returns":"Offset curves on success, None on failure."},{"signature":"Curve[] Offset(Point3d directionPoint, Vector3d normal, double distance, double tolerance, CurveOffsetCornerStyle cornerStyle)","summary":"Offsets this curve. If you have a nice offset, then there will be one entry in the array. If the original curve had kinks or the offset curve had self intersections, you will get multiple segments in the output array.","since":"5.0","parameters":[{"name":"directionPoint","summary":"A point that indicates the direction of the offset."},{"name":"normal","summary":"The normal to the offset plane."},{"name":"distance","summary":"The positive or negative distance to offset."},{"name":"tolerance","summary":"The offset or fitting tolerance."},{"name":"cornerStyle","summary":"Corner style for offset kinks."}],"returns":"Offset curves on success, None on failure."},{"signature":"Curve[] Offset(Point3d directionPoint, Vector3d normal, double distance, double tolerance, double angleTolerance, bool loose, CurveOffsetCornerStyle cornerStyle, CurveOffsetEndStyle endStyle)","summary":"Offsets this curve. If you have a nice offset, then there will be one entry in the array. If the original curve had kinks or the offset curve had self intersections, you will get multiple segments in the output array.","since":"7.0","parameters":[{"name":"directionPoint","summary":"A point that indicates the direction of the offset."},{"name":"normal","summary":"The normal to the offset plane."},{"name":"distance","summary":"The positive or negative distance to offset."},{"name":"tolerance","summary":"The offset or fitting tolerance."},{"name":"angleTolerance","summary":"The angle tolerance, in radians, used to decide whether to split at kinks."},{"name":"loose","summary":"If false, offset within tolerance. If true, offset by moving edit points."},{"name":"cornerStyle","summary":"Corner style for offset kinks."},{"name":"endStyle","summary":"End style for non-loose, non-closed curve offsets."}],"returns":"Offset curves on success, None on failure."},{"signature":"Curve OffsetNormalToSurface(Surface surface, double height)","summary":"Finds a curve by offsetting an existing curve normal to a surface. The caller is responsible for ensuring that the curve lies on the input surface.","since":"5.0","parameters":[{"name":"surface","summary":"Surface from which normals are calculated."},{"name":"height","summary":"offset distance (distance from surface to result curve)"}],"returns":"Offset curve at distance height from the surface.  The offset curve is interpolated through a small number of points so if the surface is irregular or complicated, the result will not be a very accurate offset."},{"signature":"Curve[] OffsetOnSurface(BrepFace face, double distance, double fittingTolerance)","summary":"Offset this curve on a brep face surface. This curve must lie on the surface.","since":"5.0","parameters":[{"name":"face","summary":"The brep face on which to offset."},{"name":"distance","summary":"A distance to offset (+)left, (-)right."},{"name":"fittingTolerance","summary":"A fitting tolerance."}],"returns":"Offset curves on success, or None on failure."},{"signature":"Curve[] OffsetOnSurface(BrepFace face, double[] curveParameters, double[] offsetDistances, double fittingTolerance)","summary":"Offset a curve on a brep face surface. This curve must lie on the surface.  \\nThis overload allows to specify different offsets for different curve parameters.","since":"5.0","parameters":[{"name":"face","summary":"The brep face on which to offset."},{"name":"curveParameters","summary":"Curve parameters corresponding to the offset distances."},{"name":"offsetDistances","summary":"distances to offset (+)left, (-)right."},{"name":"fittingTolerance","summary":"A fitting tolerance."}],"returns":"Offset curves on success, or None on failure."},{"signature":"Curve[] OffsetOnSurface(BrepFace face, Point2d throughPoint, double fittingTolerance)","summary":"Offset a curve on a brep face surface. This curve must lie on the surface.  \\nThis overload allows to specify a surface point at which the offset will pass.","since":"5.0","parameters":[{"name":"face","summary":"The brep face on which to offset."},{"name":"throughPoint","summary":"2d point on the brep face to offset through."},{"name":"fittingTolerance","summary":"A fitting tolerance."}],"returns":"Offset curves on success, or None on failure."},{"signature":"Curve[] OffsetOnSurface(Surface surface, double distance, double fittingTolerance)","summary":"Offset a curve on a surface. This curve must lie on the surface.","since":"5.0","parameters":[{"name":"surface","summary":"A surface on which to offset."},{"name":"distance","summary":"A distance to offset (+)left, (-)right."},{"name":"fittingTolerance","summary":"A fitting tolerance."}],"returns":"Offset curves on success, or None on failure."},{"signature":"Curve[] OffsetOnSurface(Surface surface, double[] curveParameters, double[] offsetDistances, double fittingTolerance)","summary":"Offset this curve on a surface. This curve must lie on the surface.  \\nThis overload allows to specify different offsets for different curve parameters.","since":"5.0","parameters":[{"name":"surface","summary":"A surface on which to offset."},{"name":"curveParameters","summary":"Curve parameters corresponding to the offset distances."},{"name":"offsetDistances","summary":"Distances to offset (+)left, (-)right."},{"name":"fittingTolerance","summary":"A fitting tolerance."}],"returns":"Offset curves on success, or None on failure."},{"signature":"Curve[] OffsetOnSurface(Surface surface, Point2d throughPoint, double fittingTolerance)","summary":"Offset a curve on a surface. This curve must lie on the surface.  \\nThis overload allows to specify a surface point at which the offset will pass.","since":"5.0","parameters":[{"name":"surface","summary":"A surface on which to offset."},{"name":"throughPoint","summary":"2d point on the brep face to offset through."},{"name":"fittingTolerance","summary":"A fitting tolerance."}],"returns":"Offset curves on success, or None on failure."},{"signature":"bool PerpendicularFrameAt(double t, out Plane plane)","summary":"Return a 3d frame at a parameter. This is slightly different than FrameAt in that the frame is computed in a way so there is minimal rotation from one frame to the next.","since":"5.0","parameters":[{"name":"t","summary":"Evaluation parameter."},{"name":"plane","summary":"The frame is returned here."}],"returns":"True on success, False on failure."},{"signature":"Point3d PointAt(double t)","summary":"Evaluates point at a curve parameter.","since":"5.0","parameters":[{"name":"t","summary":"Evaluation parameter."}],"returns":"Point (location of curve at the parameter t)."},{"signature":"Point3d PointAtLength(double length)","summary":"Gets a point at a certain length along the curve. The length must be non-negative and less than or equal to the length of the curve. Lengths will not be wrapped when the curve is closed or periodic.","since":"5.0","parameters":[{"name":"length","summary":"Length along the curve between the start point and the returned point."}],"returns":"Point on the curve at the specified length from the start point or Poin3d.Unset on failure."},{"signature":"Point3d PointAtNormalizedLength(double length)","summary":"Gets a point at a certain normalized length along the curve. The length must be between or including 0.0 and 1.0, where 0.0 equals the start of the curve and 1.0 equals the end of the curve.","since":"5.0","parameters":[{"name":"length","summary":"Normalized length along the curve between the start point and the returned point."}],"returns":"Point on the curve at the specified normalized length from the start point or Poin3d.Unset on failure."},{"signature":"Curve[] PullToBrepFace(BrepFace face, double tolerance)","summary":"Pulls this curve to a brep face and returns the result of that operation.","since":"5.0","parameters":[{"name":"face","summary":"A brep face."},{"name":"tolerance","summary":"A tolerance value."}],"returns":"An array containing the resulting curves after pulling. This array could be empty."},{"signature":"PolylineCurve PullToMesh(Mesh mesh, double tolerance)","summary":"Makes a polyline approximation of the curve and gets the closest point on the mesh for each point on the curve. Then it \\"connects the points\\" so that you have a polyline on the mesh.","since":"5.0","parameters":[{"name":"mesh","summary":"Mesh to project onto."},{"name":"tolerance","summary":"Input tolerance (RhinoDoc.ModelAbsoluteTolerance is a good default)"}],"returns":"A polyline curve on success, None on failure."},{"signature":"NurbsCurve Rebuild(int pointCount, int degree, bool preserveTangents)","summary":"Rebuild a curve with a specific point count.","since":"5.0","parameters":[{"name":"pointCount","summary":"Number of control points in the rebuild curve."},{"name":"degree","summary":"Degree of curve. Valid values are between and including 1 and 11."},{"name":"preserveTangents","summary":"If true, the end tangents of the input curve will be preserved."}],"returns":"A NURBS curve on success or None on failure."},{"signature":"bool RemoveShortSegments(double tolerance)","summary":"Looks for segments that are shorter than tolerance that can be removed. Does not change the domain, but it will change the relative parameterization.","since":"5.0","parameters":[{"name":"tolerance","summary":"Tolerance which defines \\"short\\" segments."}],"returns":"True if removable short segments were found. False if no removable short segments were found."},{"signature":"bool Reverse()","summary":"Reverses the direction of the curve.","since":"5.0","returns":"True on success, False on failure."},{"signature":"Curve RibbonOffset(double distance, double blendRadius, Point3d directionPoint, Vector3d normal, double tolerance)","summary":"Offsets a closed curve in the following way: pProject the curve to a plane with given normal. Then, loose Offset the projection by distance + blend_radius and trim off self-intersection. THen, Offset the remaining curve back in the opposite direction by blend_radius, filling gaps with blends. Finally, use the elevations of the input curve to get the correct elevations of the result.","since":"7.0","parameters":[{"name":"distance","summary":"The positive distance to offset the curve."},{"name":"blendRadius","summary":"Positive, typically the same as distance. When the offset results in a self-intersection that gets trimmed off at a kink, the kink will be blended out using this radius."},{"name":"directionPoint","summary":"A point that indicates the direction of the offset. If the offset is inward, the point\'s projection to the plane should be well within the curve. It will be used to decide which part of the offset to keep if there are self-intersections."},{"name":"normal","summary":"A vector that indicates the normal of the plane in which the offset will occur."},{"name":"tolerance","summary":"Used to determine self-intersections, not offset error."}],"returns":"The offset curve if successful."},{"signature":"Curve RibbonOffset(double distance, double blendRadius, Point3d directionPoint, Vector3d normal, double tolerance, out Curve[] crossSections, out Surface[] ruledSurfaces)","summary":"Offsets a closed curve in the following way: pProject the curve to a plane with given normal. Then, loose Offset the projection by distance + blend_radius and trim off self-intersection. THen, Offset the remaining curve back in the opposite direction by blend_radius, filling gaps with blends. Finally, use the elevations of the input curve to get the correct elevations of the result.","since":"7.0","parameters":[{"name":"distance","summary":"The positive distance to offset the curve."},{"name":"blendRadius","summary":"Positive, typically the same as distance. When the offset results in a self-intersection that gets trimmed off at a kink, the kink will be blended out using this radius."},{"name":"directionPoint","summary":"A point that indicates the direction of the offset. If the offset is inward, the point\'s projection to the plane should be well within the curve. It will be used to decide which part of the offset to keep if there are self-intersections."},{"name":"normal","summary":"A vector that indicates the normal of the plane in which the offset will occur."},{"name":"tolerance","summary":"Used to determine self-intersections, not offset error."},{"name":"crossSections","summary":"Contains lines between input and the offset that might be useful as input to Brep.CreateFromSweep or some other surface creation tool."},{"name":"ruledSurfaces","summary":"Contain ruled surfaces between the input and the parts of the offset that correspond exactly. Note, there will be gaps between these at blends."}],"returns":"The offset curve if successful."},{"signature":"Curve RibbonOffset(double distance, double blendRadius, Point3d directionPoint, Vector3d normal, double tolerance, out double[] outputParameters, out double[] curveParameters)","summary":"Offsets a closed curve in the following way: pProject the curve to a plane with given normal. Then, loose Offset the projection by distance + blend_radius and trim off self-intersection. THen, Offset the remaining curve back in the opposite direction by blend_radius, filling gaps with blends. Finally, use the elevations of the input curve to get the correct elevations of the result.","since":"7.0","parameters":[{"name":"distance","summary":"The positive distance to offset the curve."},{"name":"blendRadius","summary":"Positive, typically the same as distance. When the offset results in a self-intersection that gets trimmed off at a kink, the kink will be blended out using this radius."},{"name":"directionPoint","summary":"A point that indicates the direction of the offset. If the offset is inward, the point\'s projection to the plane should be well within the curve. It will be used to decide which part of the offset to keep if there are self-intersections."},{"name":"normal","summary":"A vector that indicates the normal of the plane in which the offset will occur."},{"name":"tolerance","summary":"Used to determine self-intersections, not offset error."},{"name":"outputParameters","summary":"A list of parameter, paired with curveParameters, from the output curve for creating cross sections."},{"name":"curveParameters","summary":"A list of parameter, paired with outputParameters, from the input curve for creating cross sections."}],"returns":"The offset curve if successful."},{"signature":"bool SetEndPoint(Point3d point)","summary":"Forces the curve to end at a specified point. Not all curve types support this operation.","since":"5.0","parameters":[{"name":"point","summary":"New end point of curve."}],"returns":"True on success, False on failure."},{"signature":"bool SetStartPoint(Point3d point)","summary":"Forces the curve to start at a specified point. Not all curve types support this operation.","since":"5.0","parameters":[{"name":"point","summary":"New start point of curve."}],"returns":"True on success, False on failure."},{"signature":"Curve Simplify(CurveSimplifyOptions options, double distanceTolerance, double angleToleranceRadians)","summary":"Returns a geometrically equivalent PolyCurve.  \\nThe PolyCurve has the following properties  \\n1. All the PolyCurve segments are LineCurve, PolylineCurve, ArcCurve, or NurbsCurve.  \\n2. The NURBS Curves segments do not have fully multiple interior knots.  \\n3. Rational NURBS curves do not have constant weights.  \\n4. Any segment for which IsLinear() or IsArc() is True is a Line, Polyline segment, or an Arc.  \\n5. Adjacent co-linear or co-circular segments are combined.  \\n6. Segments that meet with G1-continuity have there ends tuned up so that they meet with G1-continuity to within machine precision.","since":"5.0","parameters":[{"name":"options","summary":"Simplification options."},{"name":"distanceTolerance","summary":"A distance tolerance for the simplification."},{"name":"angleToleranceRadians","summary":"An angle tolerance for the simplification."}],"returns":"New simplified curve on success, None on failure."},{"signature":"Curve SimplifyEnd(CurveEnd end, CurveSimplifyOptions options, double distanceTolerance, double angleToleranceRadians)","summary":"Same as SimplifyCurve, but simplifies only the last two segments at \\"side\\" end.","since":"5.0","parameters":[{"name":"end","summary":"If CurveEnd.Start the function simplifies the last two start side segments, otherwise if CurveEnd.End the last two end side segments are simplified."},{"name":"options","summary":"Simplification options."},{"name":"distanceTolerance","summary":"A distance tolerance for the simplification."},{"name":"angleToleranceRadians","summary":"An angle tolerance for the simplification."}],"returns":"New simplified curve on success, None on failure."},{"signature":"Curve Smooth(double smoothFactor, bool bXSmooth, bool bYSmooth, bool bZSmooth, bool bFixBoundaries, SmoothingCoordinateSystem coordinateSystem)","summary":"Smooths a curve by averaging the positions of control points in a specified region.","since":"6.0","parameters":[{"name":"smoothFactor","summary":"The smoothing factor, which controls how much control points move towards the average of the neighboring control points."},{"name":"bXSmooth","summary":"When True control points move in X axis direction."},{"name":"bYSmooth","summary":"When True control points move in Y axis direction."},{"name":"bZSmooth","summary":"When True control points move in Z axis direction."},{"name":"bFixBoundaries","summary":"When True the curve ends don\'t move."},{"name":"coordinateSystem","summary":"The coordinates to determine the direction of the smoothing."}],"returns":"The smoothed curve if successful, None otherwise."},{"signature":"Curve Smooth(double smoothFactor, bool bXSmooth, bool bYSmooth, bool bZSmooth, bool bFixBoundaries, SmoothingCoordinateSystem coordinateSystem, Plane plane)","summary":"Smooths a curve by averaging the positions of control points in a specified region.","since":"6.0","parameters":[{"name":"smoothFactor","summary":"The smoothing factor, which controls how much control points move towards the average of the neighboring control points."},{"name":"bXSmooth","summary":"When True control points move in X axis direction."},{"name":"bYSmooth","summary":"When True control points move in Y axis direction."},{"name":"bZSmooth","summary":"When True control points move in Z axis direction."},{"name":"bFixBoundaries","summary":"When True the curve ends don\'t move."},{"name":"coordinateSystem","summary":"The coordinates to determine the direction of the smoothing."},{"name":"plane","summary":"If SmoothingCoordinateSystem.CPlane specified, then the construction plane."}],"returns":"The smoothed curve if successful, None otherwise."},{"signature":"Interval SpanDomain(int spanIndex)","summary":"Get the domain of the curve span with the given index. Use the SpanCount property to test how many spans there are.","since":"5.0","parameters":[{"name":"spanIndex","summary":"Index of span."}],"returns":"Interval of the span with the given index."},{"signature":"Curve[] Split(Brep cutter, double tolerance)","summary":"Splits a curve into pieces using a polysurface.","since":"5.0","deprecated":"6.0","parameters":[{"name":"cutter","summary":"A cutting surface or polysurface."},{"name":"tolerance","summary":"A tolerance for computing intersections."}],"returns":"An array of curves. This array can be empty."},{"signature":"Curve[] Split(Brep cutter, double tolerance, double angleToleranceRadians)","summary":"Splits a curve into pieces using a polysurface.","since":"6.0","parameters":[{"name":"cutter","summary":"A cutting surface or polysurface."},{"name":"tolerance","summary":"A tolerance for computing intersections."},{"name":"angleToleranceRadians","summary":""}],"returns":"An array of curves. This array can be empty."},{"signature":"Curve[] Split(double t)","summary":"Splits (divides) the curve at the specified parameter. The parameter must be in the interior of the curve\'s domain.","since":"5.0","parameters":[{"name":"t","summary":"Parameter to split the curve at in the interval returned by Domain()."}],"returns":"Two curves on success, None on failure."},{"signature":"Curve[] Split(IEnumerable<double> t)","summary":"Splits (divides) the curve at a series of specified parameters. The parameter must be in the interior of the curve domain.","since":"5.0","parameters":[{"name":"t","summary":"Parameters to split the curve at in the interval returned by Domain()."}],"returns":"Multiple curves on success, None on failure."},{"signature":"Curve[] Split(Surface cutter, double tolerance)","summary":"Splits a curve into pieces using a surface.","since":"5.0","deprecated":"6.0","parameters":[{"name":"cutter","summary":"A cutting surface or polysurface."},{"name":"tolerance","summary":"A tolerance for computing intersections."}],"returns":"An array of curves. This array can be empty."},{"signature":"Curve[] Split(Surface cutter, double tolerance, double angleToleranceRadians)","summary":"Splits a curve into pieces using a surface.","since":"6.0","parameters":[{"name":"cutter","summary":"A cutting surface or polysurface."},{"name":"tolerance","summary":"A tolerance for computing intersections."},{"name":"angleToleranceRadians","summary":""}],"returns":"An array of curves. This array can be empty."},{"signature":"Vector3d TangentAt(double t)","summary":"Evaluates the unit tangent vector at a curve parameter.","since":"5.0","parameters":[{"name":"t","summary":"Evaluation parameter."}],"returns":"Unit tangent vector of the curve at the parameter t."},{"signature":"PolyCurve ToArcsAndLines(double tolerance, double angleTolerance, double minimumLength, double maximumLength)","summary":"Converts a curve into polycurve consisting of arc segments. Sections of the input curves that are nearly straight are converted to straight-line segments.","since":"6.0","parameters":[{"name":"tolerance","summary":"The tolerance. This is the maximum deviation from arc midpoints to the curve. When in doubt, use the document\'s model space absolute tolerance."},{"name":"angleTolerance","summary":"The angle tolerance in radians. This is the maximum deviation of the arc end directions from the curve direction. When in doubt, use the document\'s model space angle tolerance."},{"name":"minimumLength","summary":"The minimum segment length."},{"name":"maximumLength","summary":"The maximum segment length."}],"returns":"PolyCurve on success, None on error."},{"signature":"NurbsCurve ToNurbsCurve()","summary":"Constructs a NURBS curve representation of this curve.","since":"5.0","returns":"NURBS representation of the curve on success, None on failure."},{"signature":"NurbsCurve ToNurbsCurve(Interval subdomain)","summary":"Constructs a NURBS curve representation of this curve.","since":"5.0","parameters":[{"name":"subdomain","summary":"The NURBS representation for this portion of the curve is returned."}],"returns":"NURBS representation of the curve on success, None on failure."},{"signature":"PolylineCurve ToPolyline(double tolerance, double angleTolerance, double minimumLength, double maximumLength)","summary":"Gets a polyline approximation of a curve.","since":"6.0","parameters":[{"name":"tolerance","summary":"The tolerance. This is the maximum deviation from line midpoints to the curve. When in doubt, use the document\'s model space absolute tolerance."},{"name":"angleTolerance","summary":"The angle tolerance in radians. This is the maximum deviation of the line directions. When in doubt, use the document\'s model space angle tolerance."},{"name":"minimumLength","summary":"The minimum segment length."},{"name":"maximumLength","summary":"The maximum segment length."}],"returns":"PolyCurve on success, None on error."},{"signature":"PolylineCurve ToPolyline(int mainSegmentCount, int subSegmentCount, double maxAngleRadians, double maxChordLengthRatio, double maxAspectRatio, double tolerance, double minEdgeLength, double maxEdgeLength, bool keepStartPoint)","summary":"Gets a polyline approximation of a curve.","since":"5.0","parameters":[{"name":"mainSegmentCount","summary":"If mainSegmentCount <= 0, then both subSegmentCount and mainSegmentCount are ignored. If mainSegmentCount > 0, then subSegmentCount must be >= 1. In this case the NURBS will be broken into mainSegmentCount equally spaced chords. If needed, each of these chords can be split into as many subSegmentCount sub-parts if the subdivision is necessary for the mesh to meet the other meshing constraints. In particular, if subSegmentCount = 0, then the curve is broken into mainSegmentCount pieces and no further testing is performed."},{"name":"subSegmentCount","summary":"An amount of subsegments."},{"name":"maxAngleRadians","summary":"( 0 to pi ) Maximum angle (in radians) between unit tangents at adjacent vertices."},{"name":"maxChordLengthRatio","summary":"Maximum permitted value of (distance chord midpoint to curve) / (length of chord)."},{"name":"maxAspectRatio","summary":"If maxAspectRatio < 1.0, the parameter is ignored. If 1 <= maxAspectRatio < sqrt(2), it is treated as if maxAspectRatio = sqrt(2). This parameter controls the maximum permitted value of (length of longest chord) / (length of shortest chord)."},{"name":"tolerance","summary":"If tolerance = 0, the parameter is ignored. This parameter controls the maximum permitted value of the distance from the curve to the polyline."},{"name":"minEdgeLength","summary":"The minimum permitted edge length."},{"name":"maxEdgeLength","summary":"If maxEdgeLength = 0, the parameter is ignored. This parameter controls the maximum permitted edge length."},{"name":"keepStartPoint","summary":"If True the starting point of the curve is added to the polyline. If False the starting point of the curve is not added to the polyline."}],"returns":"PolylineCurve on success, None on error."},{"signature":"PolylineCurve ToPolyline(int mainSegmentCount, int subSegmentCount, double maxAngleRadians, double maxChordLengthRatio, double maxAspectRatio, double tolerance, double minEdgeLength, double maxEdgeLength, bool keepStartPoint, Interval curveDomain)","summary":"Gets a polyline approximation of a curve.","since":"5.0","parameters":[{"name":"mainSegmentCount","summary":"If mainSegmentCount <= 0, then both subSegmentCount and mainSegmentCount are ignored. If mainSegmentCount > 0, then subSegmentCount must be >= 1. In this case the NURBS will be broken into mainSegmentCount equally spaced chords. If needed, each of these chords can be split into as many subSegmentCount sub-parts if the subdivision is necessary for the mesh to meet the other meshing constraints. In particular, if subSegmentCount = 0, then the curve is broken into mainSegmentCount pieces and no further testing is performed."},{"name":"subSegmentCount","summary":"An amount of subsegments."},{"name":"maxAngleRadians","summary":"( 0 to pi ) Maximum angle (in radians) between unit tangents at adjacent vertices."},{"name":"maxChordLengthRatio","summary":"Maximum permitted value of (distance chord midpoint to curve) / (length of chord)."},{"name":"maxAspectRatio","summary":"If maxAspectRatio < 1.0, the parameter is ignored. If 1 <= maxAspectRatio < sqrt(2), it is treated as if maxAspectRatio = sqrt(2). This parameter controls the maximum permitted value of (length of longest chord) / (length of shortest chord)."},{"name":"tolerance","summary":"If tolerance = 0, the parameter is ignored. This parameter controls the maximum permitted value of the distance from the curve to the polyline."},{"name":"minEdgeLength","summary":"The minimum permitted edge length."},{"name":"maxEdgeLength","summary":"If maxEdgeLength = 0, the parameter is ignored. This parameter controls the maximum permitted edge length."},{"name":"keepStartPoint","summary":"If True the starting point of the curve is added to the polyline. If False the starting point of the curve is not added to the polyline."},{"name":"curveDomain","summary":"This sub-domain of the NURBS curve is approximated."}],"returns":"PolylineCurve on success, None on error."},{"signature":"Curve Trim(CurveEnd side, double length)","summary":"Shortens a curve by a given length","since":"5.1","returns":"Trimmed curve if successful, None on failure."},{"signature":"Curve Trim(double t0, double t1)","summary":"Removes portions of the curve outside the specified interval.","since":"5.0","parameters":[{"name":"t0","summary":"Start of the trimming interval. Portions of the curve before curve(t0) are removed."},{"name":"t1","summary":"End of the trimming interval. Portions of the curve after curve(t1) are removed."}],"returns":"Trimmed portion of this curve is successful, None on failure."},{"signature":"Curve Trim(Interval domain)","summary":"Removes portions of the curve outside the specified interval.","since":"5.0","parameters":[{"name":"domain","summary":"Trimming interval. Portions of the curve before curve(domain[0]) and after curve(domain[1]) are removed."}],"returns":"Trimmed curve if successful, None on failure."},{"signature":"bool TryGetArc(out Arc arc)","summary":"Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.","since":"5.0","parameters":[{"name":"arc","summary":"On success, the Arc will be filled in."}],"returns":"True if the curve could be converted into an arc."},{"signature":"bool TryGetArc(out Arc arc, double tolerance)","summary":"Try to convert this curve into an Arc using a custom tolerance.","since":"5.0","parameters":[{"name":"arc","summary":"On success, the Arc will be filled in."},{"name":"tolerance","summary":"Tolerance to use when checking."}],"returns":"True if the curve could be converted into an arc."},{"signature":"bool TryGetArc(Plane plane, out Arc arc)","summary":"Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.","since":"5.0","parameters":[{"name":"plane","summary":"Plane in which the comparison is performed."},{"name":"arc","summary":"On success, the Arc will be filled in."}],"returns":"True if the curve could be converted into an arc within the given plane."},{"signature":"bool TryGetArc(Plane plane, out Arc arc, double tolerance)","summary":"Try to convert this curve into an Arc using a custom tolerance.","since":"5.0","parameters":[{"name":"plane","summary":"Plane in which the comparison is performed."},{"name":"arc","summary":"On success, the Arc will be filled in."},{"name":"tolerance","summary":"Tolerance to use when checking."}],"returns":"True if the curve could be converted into an arc within the given plane."},{"signature":"bool TryGetCircle(out Circle circle)","summary":"Try to convert this curve into a circle using RhinoMath.ZeroTolerance.","since":"5.0","parameters":[{"name":"circle","summary":"On success, the Circle will be filled in."}],"returns":"True if the curve could be converted into a Circle."},{"signature":"bool TryGetCircle(out Circle circle, double tolerance)","summary":"Try to convert this curve into a Circle using a custom tolerance.","since":"5.0","parameters":[{"name":"circle","summary":"On success, the Circle will be filled in."},{"name":"tolerance","summary":"Tolerance to use when checking."}],"returns":"True if the curve could be converted into a Circle within tolerance."},{"signature":"bool TryGetEllipse(out Ellipse ellipse)","summary":"Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.","since":"5.0","parameters":[{"name":"ellipse","summary":"On success, the Ellipse will be filled in."}],"returns":"True if the curve could be converted into an Ellipse."},{"signature":"bool TryGetEllipse(out Ellipse ellipse, double tolerance)","summary":"Try to convert this curve into an Ellipse using a custom tolerance.","since":"5.0","parameters":[{"name":"ellipse","summary":"On success, the Ellipse will be filled in."},{"name":"tolerance","summary":"Tolerance to use when checking."}],"returns":"True if the curve could be converted into an Ellipse."},{"signature":"bool TryGetEllipse(Plane plane, out Ellipse ellipse)","summary":"Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.","since":"5.0","parameters":[{"name":"plane","summary":"Plane in which the comparison is performed."},{"name":"ellipse","summary":"On success, the Ellipse will be filled in."}],"returns":"True if the curve could be converted into an Ellipse within the given plane."},{"signature":"bool TryGetEllipse(Plane plane, out Ellipse ellipse, double tolerance)","summary":"Try to convert this curve into an Ellipse using a custom tolerance.","since":"5.0","parameters":[{"name":"plane","summary":"Plane in which the comparison is performed."},{"name":"ellipse","summary":"On success, the Ellipse will be filled in."},{"name":"tolerance","summary":"Tolerance to use when checking."}],"returns":"True if the curve could be converted into an Ellipse within the given plane."},{"signature":"bool TryGetPlane(out Plane plane)","summary":"Test a curve for planarity and return the plane.","since":"5.0","parameters":[{"name":"plane","summary":"On success, the plane parameters are filled in."}],"returns":"True if there is a plane such that the maximum distance from the curve to the plane is <= RhinoMath.ZeroTolerance."},{"signature":"bool TryGetPlane(out Plane plane, double tolerance)","summary":"Test a curve for planarity and return the plane.","since":"5.0","parameters":[{"name":"plane","summary":"On success, the plane parameters are filled in."},{"name":"tolerance","summary":"Tolerance to use when checking."}],"returns":"True if there is a plane such that the maximum distance from the curve to the plane is <= tolerance."},{"signature":"bool TryGetPolyline(out Polyline polyline)","summary":"Several types of Curve can have the form of a polyline including a degree 1 NurbsCurve, a PolylineCurve, and a PolyCurve all of whose segments are some form of polyline. IsPolyline tests a curve to see if it can be represented as a polyline.","since":"5.0","parameters":[{"name":"polyline","summary":"If True is returned, then the polyline form is returned here."}],"returns":"True if this curve can be represented as a polyline; otherwise, false."},{"signature":"bool TryGetPolyline(out Polyline polyline, out double[] parameters)","summary":"Several types of Curve can have the form of a polyline including a degree 1 NurbsCurve, a PolylineCurve, and a PolyCurve all of whose segments are some form of polyline. IsPolyline tests a curve to see if it can be represented as a polyline.","since":"5.0","parameters":[{"name":"polyline","summary":"If True is returned, then the polyline form is returned here."},{"name":"parameters","summary":"if True is returned, then the parameters of the polyline points are returned here."}],"returns":"True if this curve can be represented as a polyline; otherwise, false."}]},{"namespace":"Rhino.Geometry","name":"CurveBooleanRegions","dataType":"class","summary":"Represents the results of a Curve.CreateBooleanRegions calculation.","interfaces":["IDisposable"],"properties":[{"signature":"int PlanarCurveCount","summary":"Returns number of planar curves that were calculated by Curve.CreateBooleanRegions.","since":"7.0","property":["get"]},{"signature":"int PointCount","summary":"If this object were created using the Curve.CreateBooleanRegions override that accepts a collection of points as input, then this value will be equal to the length of the points collection.","since":"7.0","property":["get"]},{"signature":"int RegionCount","summary":"Returns the number of curve regions. A curve region is a collection of curves that bound a single connected region of the plane.","since":"7.0","property":["get"]}],"methods":[{"signature":"int BoundaryCount(int regionIndex)","summary":"Returns the number of boundary curves in a curve region.","since":"7.0","parameters":[{"name":"regionIndex","summary":"The curve region index."}],"returns":"The number of boundary curves in the curve region."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"7.0"},{"signature":"Curve PlanarCurve(int planarCurveIndex)","summary":"Returns a planar curve that was calculated by Curve.CreateBooleanRegions.","since":"7.0","returns":"The planar curve if successful, None if not successful."},{"signature":"Curve[] RegionCurves(int regionIndex)","summary":"Returns the boundary curves in a curve region. A curve region is a collection of curves that bound a single connected region of the plane. Note, the first curve is always the outer boundary.","since":"7.0","parameters":[{"name":"regionIndex","summary":"The curve region index."}],"returns":"An array of boundary curves if successful, an empty array if not successful."},{"signature":"int RegionPointIndex(int pointIndex)","summary":"If this object were created using the Curve.CreateBooleanRegions override that accepts a collection of points as input, then you this method to retrieve the index of the point contained in a curve region. If this.RegionPointIndex(i) = n, then points[i] is contained in this.RegionCurves(n). If points[i] is not in any region, then this.RegionPointIndex(i) = -1.","since":"7.0","parameters":[{"name":"pointIndex","summary":"The point index."}],"returns":"The index of the input point contained in the specified region if successful, or -1 if points[i] was not used in any region or if not successful."},{"signature":"int SegmentCount(int regionIndex, int boundaryIndex)","summary":"Returns the number of segments in a boundary curve in a curve region.","since":"7.0","parameters":[{"name":"regionIndex","summary":"The curve region index."},{"name":"boundaryIndex","summary":"The boundary curve index."}],"returns":"The number of curve segments in th boundary curves."},{"signature":"int SegmentDetails(int regionIndex, int boundaryIndex, int segmmentIndex, out Interval subDomain, out bool reversed)","summary":"Returns the details of a segment in a boundary curve in a curve region.","since":"7.0","parameters":[{"name":"regionIndex","summary":"The curve region index."},{"name":"boundaryIndex","summary":"The boundary curve index."},{"name":"segmmentIndex","summary":"The segment index."},{"name":"subDomain","summary":"The sub-domain of the planar curve used by the segment."},{"name":"reversed","summary":"True if the piece of the planar curve should be reversed."}],"returns":"The index of the planar curve used by the specified segment if successful, -1 if not successful."}]},{"namespace":"Rhino.Geometry","name":"CurveEnd","dataType":"enum","summary":"Defines the extremes of a curve through a flagged enumeration.","since":"5.0","values":[{"signature":"None = 0","summary":"Not the start nor the end."},{"signature":"Start = 1","summary":"The frontal part of the curve."},{"signature":"End = 2","summary":"The tail part of the curve."},{"signature":"Both = 3","summary":"Both the start and the end of the curve."}]},{"namespace":"Rhino.Geometry","name":"CurveEvaluationSide","dataType":"enum","summary":"Defines enumerated values for the options that defines a curve evaluation side when evaluating kinks.","since":"5.0","values":[{"signature":"Default = 0","summary":"The default evaluation side."},{"signature":"Below = -1","summary":"The below evaluation side."},{"signature":"Above = +1","summary":"The above evaluation side."}]},{"namespace":"Rhino.Geometry","name":"CurveExtensionStyle","dataType":"enum","summary":"Defines enumerated values for styles to use during curve extension, such as \\"Line\\", \\"Arc\\" or \\"Smooth\\".","since":"5.0","values":[{"signature":"Line = 0","summary":"Curve ends will be propagated linearly according to tangents."},{"signature":"Arc = 1","summary":"Curve ends will be propagated arc-wise according to curvature."},{"signature":"Smooth = 2","summary":"Curve ends will be propagated smoothly according to curvature."}]},{"namespace":"Rhino.Geometry","name":"CurveKnotStyle","dataType":"enum","summary":"Defines enumerated values for knot spacing styles in interpolated curves.","since":"5.0","values":[{"signature":"Uniform = 0","summary":"Parameter spacing between consecutive knots is 1.0."},{"signature":"Chord = 1","summary":"Chord length spacing, requires degree=3 with CV1 and CVn1 specified."},{"signature":"ChordSquareRoot = 2","summary":"Square root of chord length, requires degree=3 with CV1 and CVn1 specified."},{"signature":"UniformPeriodic = 3","summary":"Periodic with uniform spacing."},{"signature":"ChordPeriodic = 4","summary":"Periodic with chord length spacing."},{"signature":"ChordSquareRootPeriodic = 5","summary":"Periodic with square root of chord length spacing."}]},{"namespace":"Rhino.Geometry","name":"CurveOffsetCornerStyle","dataType":"enum","summary":"Defines enumerated values for all implemented corner styles in curve offsets.","since":"5.0","values":[{"signature":"None = 0","summary":"The default value."},{"signature":"Sharp = 1","summary":"Offsets and extends curves with a straight line until they intersect."},{"signature":"Round = 2","summary":"Offsets and fillets curves with an arc of radius equal to the offset distance."},{"signature":"Smooth = 3","summary":"Offsets and connects curves with a smooth (G1 continuity) curve."},{"signature":"Chamfer = 4","summary":"Offsets and connects curves with a straight line between their endpoints."}]},{"namespace":"Rhino.Geometry","name":"CurveOffsetEndStyle","dataType":"enum","summary":"Defines enumerated values for all implemented end styles in curve offsets.","since":"7.0","values":[{"signature":"None = 0","summary":"No closing segments are added."},{"signature":"Flat = 1","summary":"Straight-line segments are added between the curves."},{"signature":"Round = 2","summary":"Tangent arcs are added between the curves."}]},{"namespace":"Rhino.Geometry","name":"CurveOrientation","dataType":"enum","summary":"Defines enumerated values for closed curve orientations.","since":"5.0","values":[{"signature":"Undefined = 0","summary":"Unable to compute the curve\'s orientation."},{"signature":"Clockwise = -1","summary":"The curve\'s orientation is clockwise in the XY plane."},{"signature":"CounterClockwise = +1","summary":"The curve\'s orientation is counter clockwise in the XY plane."}]},{"namespace":"Rhino.Geometry","name":"CurveProxy","dataType":"class","summary":"Represent curve geometry. Usually this is part of another piece of geometry that can be represented as a \\"proxy\\".","baseclass":"Rhino.Geometry.Curve","properties":[{"signature":"bool ProxyCurveIsReversed","summary":"True if \\"this\\" is a curve is reversed from the \\"real\\" curve geometry","since":"5.10","property":["get"]}]},{"namespace":"Rhino.Geometry","name":"CurveSimplifyOptions","dataType":"enum","summary":"Enumerates the options to use when simplifying a curve.","since":"5.0","values":[{"signature":"None = 0","summary":"No option is specified."},{"signature":"SplitAtFullyMultipleKnots = 1","summary":"Split NurbsCurves at fully multiple knots. Effectively turning single NURBS segments with kinks into multiple segments."},{"signature":"RebuildLines = 2","summary":"Replace linear segments with LineCurves."},{"signature":"RebuildArcs = 4","summary":"Replace partially circular segments with ArcCurves."},{"signature":"RebuildRationals = 8","summary":"Replace rational NURBS curve with constant weights with an equivalent non-rational NurbsCurve."},{"signature":"AdjustG1 = 16","summary":"Adjust Curves at G1-joins."},{"signature":"Merge = 32","summary":"Merge adjacent co-linear lines or co-circular arcs or combine consecutive line segments into a polyline."},{"signature":"All = SplitAtFullyMultipleKnots | RebuildLines | RebuildArcs | RebuildRationals | AdjustG1 | Merge","summary":"Implies all of the simplification functions will be used."}]},{"namespace":"Rhino.Geometry","name":"Cylinder","dataType":"struct","summary":"Represents the values of a plane, a radius and two heights -on top and beneath- that define a right circular cylinder.","constructors":[{"signature":"Cylinder(Circle baseCircle)","summary":"Constructs a new cylinder with infinite height.","since":"5.0","parameters":[{"name":"baseCircle","summary":"Base circle for infinite cylinder."}]},{"signature":"Cylinder(Circle baseCircle, double height)","summary":"Constructs a new cylinder with a finite height.","since":"5.0","parameters":[{"name":"baseCircle","summary":"Base circle for cylinder."},{"name":"height","summary":"Height of cylinder (zero for infinite cylinder)."}]}],"properties":[{"signature":"static Cylinder Unset","summary":"Gets an invalid Cylinder.","since":"5.0","property":["get"]},{"signature":"Vector3d Axis","summary":"Gets the axis direction of the cylinder.","since":"5.0","property":["get"]},{"signature":"Plane BasePlane","summary":"Gets or sets the base plane of the cylinder.","since":"6.0","property":["get","set"]},{"signature":"Point3d Center","summary":"Gets the center point of the defining circle.","since":"5.0","property":["get"]},{"signature":"double Height1","summary":"Gets or sets the start height of the cylinder. The center of bottom cap is: BasePlane.Origin + Height1 * BasePlane.ZAxis.","since":"5.0","property":["get","set"]},{"signature":"double Height2","summary":"Gets or sets the end height of the cylinder. If the end height equals the start height, the cylinder is presumed to be infinite. The center of top cap is: BasePlane.Origin + Height2 * BasePlane.ZAxis.","since":"5.0","property":["get","set"]},{"signature":"bool IsFinite","summary":"True if the cylinder is finite (Height0 != Height1) False if the cylinder is infinite.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Gets a boolean value indicating whether this cylinder is valid.  \\nA valid cylinder is represented by a valid circle and two valid heights.","since":"5.0","property":["get"]},{"signature":"double Radius","summary":"Gets or sets the radius of the cylinder.","since":"6.0","property":["get","set"]},{"signature":"double TotalHeight","summary":"Gets the height of the cylinder. Infinite cylinders have a height of zero, not Double.PositiveInfinity.","since":"5.0","property":["get"]}],"methods":[{"signature":"Circle CircleAt(double linearParameter)","summary":"Compute the circle at the given elevation parameter.","since":"5.0","parameters":[{"name":"linearParameter","summary":"Height parameter for circle section."}]},{"signature":"bool EpsilonEquals(Cylinder other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"Line LineAt(double angularParameter)","summary":"Compute the line at the given angle parameter. This line will be degenerate if the cylinder is infinite.","since":"5.0","parameters":[{"name":"angularParameter","summary":"Angle parameter for line section."}]},{"signature":"Brep ToBrep(bool capBottom, bool capTop)","summary":"Constructs a Brep representation of this Cylinder. This is synonymous with calling NurbsSurface.CreateFromCylinder().","since":"5.0","parameters":[{"name":"capBottom","summary":"If true, the bottom of the cylinder will be capped."},{"name":"capTop","summary":"If true, the top of the cylinder will be capped."}],"returns":"A Brep representation of the cylinder or null."},{"signature":"NurbsSurface ToNurbsSurface()","summary":"Constructs a Nurbs surface representation of this cylinder. This is synonymous with calling NurbsSurface.CreateFromCylinder().","since":"5.0","returns":"A Nurbs surface representation of the cylinder or null."},{"signature":"RevSurface ToRevSurface()","summary":"Constructs a RevSurface representation of this Cylinder. This is synonymous with calling RevSurface.CreateFromCylinder().","since":"5.0","returns":"A RevSurface representation of the cylinder or null."}]},{"namespace":"Rhino.Geometry","name":"DetailView","dataType":"class","summary":"Represents a view of the model placed on a page layout.","baseclass":"Rhino.Geometry.GeometryBase","properties":[{"signature":"bool IsParallelProjection","summary":"Gets or sets whether the view is parallel.","since":"5.0","property":["get","set"]},{"signature":"bool IsPerspectiveProjection","summary":"Gets or sets whether the view is perspective.","since":"5.0","property":["get","set"]},{"signature":"bool IsProjectionLocked","summary":"Gets or sets whether the view projection is locked.","since":"5.0","property":["get","set"]},{"signature":"double PageToModelRatio","summary":"Gets the page units/model units quotient.","since":"5.0","property":["get"]}],"methods":[{"signature":"bool SetScale(double modelLength, UnitSystem modelUnits, double pageLength, UnitSystem pageUnits)","summary":"Sets the detail viewport\'s projection so geometry is displayed at a certain scale.","since":"5.0","parameters":[{"name":"modelLength","summary":"Reference model length."},{"name":"modelUnits","summary":"Units for model length."},{"name":"pageLength","summary":"Length on page that the modelLength should equal."},{"name":"pageUnits","summary":"Units for page length."}],"returns":"True on success. False if the DetailView projection is perspective or input values are incongruous."}]},{"namespace":"Rhino.Geometry","name":"DevelopableSrf","dataType":"class","summary":"Helpers for developable surface functions","methods":[{"signature":"static int GetLocalDevopableRuling(NurbsCurve rail0, double t0, Interval dom0, NurbsCurve rail1, double t1, Interval dom1, ref double t0_out, ref double t1_out)","summary":"Finds minimum twist ruling between 2 curves at local domains","since":"6.0","parameters":[{"name":"rail0","summary":"First rail"},{"name":"t0","summary":"Seed parameter on first rail"},{"name":"dom0","summary":"Parameter sub-domain to adjust in on first rail"},{"name":"rail1","summary":"Second rail"},{"name":"t1","summary":"Seed parameter on second rail"},{"name":"dom1","summary":"Parameter sub-domain to adjust in on second rail"},{"name":"t0_out","summary":"Result ruling on first rail"},{"name":"t1_out","summary":"Result ruling on second rail"}],"returns":"-1: Error 0: Exact non-twisting ruling found between t0_out and t1_out 1: Ruling found between t0_out and t1_out that has less twist the ruling between t0 and t1"},{"signature":"static bool RulingMinTwist(NurbsCurve rail0, double t0, Interval dom0, NurbsCurve rail1, double t1, Interval dom1, ref double t0_out, ref double t1_out, ref double cos_twist_out)","summary":"Find a ruling from rail0(t0_out) to rail1(t1_out) that has the least twist across the ruling with t0_out in domain0 and t1_out in domain1. max_cos_twist is cos(twist) for the returned ruling","since":"6.0"},{"signature":"static bool RulingMinTwist(NurbsCurve rail0, double t0, NurbsCurve rail1, double t1, Interval dom1, ref double t1_out, ref double cos_twist_out)","summary":"Find a ruling from rail0(t0) to rail1(t1_out) that has the least twist across the ruling with t1_out in domain1. max_cos_twist is cos(twist) for the returned ruling","since":"6.0"},{"signature":"static bool UntwistRulings(NurbsCurve rail0, NurbsCurve rail1, ref IEnumerable<Point2d> rulings)"}]},{"namespace":"Rhino.Geometry","name":"Dimension","dataType":"class","summary":"Base class for dimensions","baseclass":"Rhino.Geometry.AnnotationBase","properties":[{"signature":"bool AlternateBelowLine","since":"6.0","property":["get","set"]},{"signature":"double AltLengthFactor","since":"6.0","property":["get","set"]},{"signature":"int AltLengthResolution","since":"6.0","property":["get","set"]},{"signature":"double AltLengthRoundoff","since":"6.0","property":["get","set"]},{"signature":"string AltPrefix","since":"6.0","property":["get","set"]},{"signature":"string AltSuffix","since":"6.0","property":["get","set"]},{"signature":"int AltToleranceResolution","since":"6.0","property":["get","set"]},{"signature":"bool AltUnitsDisplay","since":"6.0","property":["get","set"]},{"signature":"ZeroSuppression AltZeroSuppression","since":"6.0","property":["get","set"]},{"signature":"Guid ArrowBlockId1","since":"6.0","property":["get","set"]},{"signature":"Guid ArrowBlockId2","since":"6.0","property":["get","set"]},{"signature":"ArrowFit ArrowFit","since":"6.20","property":["get","set"]},{"signature":"ArrowType ArrowheadType1","since":"6.0","property":["get","set"]},{"signature":"ArrowType ArrowheadType2","since":"6.0","property":["get","set"]},{"signature":"double ArrowSize","since":"6.0","property":["get","set"]},{"signature":"double BaselineSpacing","since":"6.0","property":["get","set"]},{"signature":"double CentermarkSize","since":"6.0","property":["get","set"]},{"signature":"CenterMarkStyle CentermarkStyle","since":"6.0","property":["get","set"]},{"signature":"Guid DetailMeasured","since":"6.0","property":["get","set"]},{"signature":"double DimensionLineExtension","since":"6.0","property":["get","set"]},{"signature":"double DistanceScale","since":"6.0","property":["get","set"]},{"signature":"double ExtensionLineExtension","since":"6.0","property":["get","set"]},{"signature":"double ExtensionLineOffset","since":"6.0","property":["get","set"]},{"signature":"double FixedExtensionLength","since":"6.0","property":["get","set"]},{"signature":"bool FixedLengthExtensionOn","since":"6.0","property":["get","set"]},{"signature":"ForceArrow ForceArrowPosition","since":"6.0","property":["get","set"]},{"signature":"bool ForceDimensionLineBetweenExtensionLines","since":"6.20","property":["get","set"]},{"signature":"bool ForceDimLine","since":"6.20","property":["get","set"]},{"signature":"ForceText ForceTextPosition","since":"6.0","property":["get","set"]},{"signature":"double LengthFactor","since":"6.0","property":["get","set"]},{"signature":"int LengthResolution","since":"6.0","property":["get","set"]},{"signature":"double LengthRoundoff","since":"6.0","property":["get","set"]},{"signature":"double NumericValue","summary":"Gets the numeric value (or measurement), depending on geometry type.  \\nLinearDimension: distance between arrow tips  \\nRadialDimension: radius or diameter depending on type  \\nAngularDimension: angle in degrees","since":"6.0","property":["get"]},{"signature":"string PlainUserText","since":"6.0","property":["get"]},{"signature":"string Prefix","since":"6.0","property":["get","set"]},{"signature":"string Suffix","since":"6.0","property":["get","set"]},{"signature":"bool SuppressExtension1","since":"6.0","property":["get","set"]},{"signature":"bool SuppressExtension2","since":"6.0","property":["get","set"]},{"signature":"LeaderContentAngleStyle TextAngleType","since":"6.0","property":["get","set"]},{"signature":"TextFit TextFit","since":"6.20","property":["get","set"]},{"signature":"string TextFormula","since":"6.0","property":["get","set"]},{"signature":"TextLocation TextLocation","since":"6.0","property":["get","set"]},{"signature":"TextOrientation TextOrientation","since":"6.0","property":["get","set"]},{"signature":"Point2d TextPosition","summary":"Gets and sets the position of text on the plane.","since":"6.0","property":["get","set"]},{"signature":"double TextRotation","since":"6.0","property":["get","set"]},{"signature":"ToleranceDisplayFormat ToleranceFormat","since":"6.0","property":["get","set"]},{"signature":"double ToleranceHeightScale","since":"6.0","property":["get","set"]},{"signature":"double ToleranceLowerValue","since":"6.0","property":["get","set"]},{"signature":"int ToleranceResolution","since":"6.0","property":["get","set"]},{"signature":"double ToleranceUpperValue","since":"6.0","property":["get","set"]},{"signature":"bool UseDefaultTextPoint","since":"6.0","property":["get","set"]},{"signature":"ZeroSuppression ZeroSuppression","since":"6.0","property":["get","set"]}],"methods":[{"signature":"Transform GetTextTransform(ViewportInfo viewport, DimensionStyle style, double textScale, bool drawForward)","summary":"Get the transform for this text object\'s text geometry","since":"6.0","parameters":[{"name":"viewport","summary":"Viewport where text is being used"},{"name":"style","summary":"Dimension\'s DimensionStyle"},{"name":"textScale","summary":"Scale to apply to text"},{"name":"drawForward","summary":"Draw text front-facing"}]},{"signature":"void SetAltDimensionLengthDisplayWithZeroSuppressionReset(LengthDisplay ld)","since":"6.0"},{"signature":"void SetDimensionLengthDisplayWithZeroSuppressionReset(LengthDisplay ld)","since":"6.0"}]},{"namespace":"Rhino.Geometry","name":"Dimension.ForceArrow","dataType":"enum","summary":"OBSOLETE enum do not use.","values":[{"signature":"Auto = 0"},{"signature":"Inside = 1"},{"signature":"Outside = 2"}]},{"namespace":"Rhino.Geometry","name":"Dimension.ForceText","dataType":"enum","summary":"OBSOLETE enum do not use.","values":[{"signature":"Auto = 0"},{"signature":"Inside = 1"},{"signature":"Right = 2"},{"signature":"Left = 3"},{"signature":"HintRight = 4"},{"signature":"HintLeft = 5"}]},{"namespace":"Rhino.Geometry","name":"DistancingMode","dataType":"enum","summary":"Defines how offset and similar operations should work.","since":"6.0","values":[{"signature":"Undefined","summary":"Nothing is defined. This serves as null."},{"signature":"Linear","summary":"When geometrically possible, offsets with a linear distance."},{"signature":"LinearFromEnd","summary":"When geometrically possible and an opposite side exists, offsets with a linear distance from that side."},{"signature":"Ratio","summary":"When geometrically possible, uses a percentage of respective neighbours to compute offsets."},{"signature":"RatioFromEnd","summary":"When geometrically possible and an opposite side exists, uses a percentage of respective neighbours to compute offsets."}]},{"namespace":"Rhino.Geometry","name":"EdgeAdjacency","dataType":"enum","summary":"Enumerates all possible Topological Edge adjacency types.","since":"5.0","values":[{"signature":"None = 0","summary":"Edge is not used by any faces and is therefore superfluous."},{"signature":"Naked = 1","summary":"Edge is used by a single face."},{"signature":"Interior = 2","summary":"Edge is used by two adjacent faces."},{"signature":"NonManifold = 3","summary":"Edge is used by three or more adjacent faces."}]},{"namespace":"Rhino.Geometry","name":"Ellipse","dataType":"struct","summary":"Represents the values of a plane and the two semi-axes radii in an ellipse.","constructors":[{"signature":"Ellipse(Plane plane, double radius1, double radius2)","summary":"Initializes a new ellipse from base plane and both principal radii.","since":"5.0","parameters":[{"name":"plane","summary":"Base plane of ellipse."},{"name":"radius1","summary":"Ellipse radius along base plane X direction."},{"name":"radius2","summary":"Ellipse radius along base plane Y direction."}]},{"signature":"Ellipse(Point3d center, Point3d second, Point3d third)","summary":"Initializes a new ellipse from a center point and the two semi-axes intersections.","since":"5.0","parameters":[{"name":"center","summary":"A center for the ellipse. The average of the foci."},{"name":"second","summary":"The intersection of the ellipse X axis with the ellipse itself."},{"name":"third","summary":"A point that determines the radius along the Y semi-axis.  \\nIf the point is at right angle with the (center - second point) vector, it will be the intersection of the ellipse Y axis with the ellipse itself."}]}],"properties":[{"signature":"bool IsValid","summary":"Returns an indication of the validity of this ellipse.","since":"6.0","property":["get"]},{"signature":"Plane Plane","summary":"Gets or sets the base plane of the ellipse.","since":"5.0","property":["get","set"]},{"signature":"double Radius1","summary":"Gets or sets the radius of the ellipse along the base plane X semi-axis.","since":"5.0","property":["get","set"]},{"signature":"double Radius2","summary":"Gets or sets the radius of the ellipse along the base plane Y semi-axis.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"bool EpsilonEquals(Ellipse other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"NurbsCurve ToNurbsCurve()","summary":"Constructs a nurbs curve representation of this ellipse.  \\nThis is equivalent to calling NurbsCurve.CreateFromEllipse().","since":"5.0","returns":"A nurbs curve representation of this ellipse or None if no such representation could be made."}]},{"namespace":"Rhino.Geometry","name":"ExtrudeCornerType","dataType":"enum","summary":"Corner types used for creating a tapered extrusion","since":"5.1","values":[{"signature":"None = 0","summary":"No Corner"},{"signature":"Sharp = 1"},{"signature":"Round = 2"},{"signature":"Smooth = 3"},{"signature":"Chamfer = 4"}]},{"namespace":"Rhino.Geometry","name":"Extrusion","dataType":"class","summary":"Represents an extrusion, or objects such as beams or linearly extruded elements, that can be represented by profile curves and two miter planes at the extremes.","baseclass":"Rhino.Geometry.Surface","constructors":[{"signature":"Extrusion()","summary":"Initializes a new instance of the Extrusionclass.","since":"5.0"}],"properties":[{"signature":"int CapCount","summary":"Gets the amount of capping surfaces.","since":"5.0","property":["get"]},{"signature":"bool IsCappedAtBottom","summary":"Gets a value indicating whether the surface that fills the bottom profile is existing.","since":"5.0","property":["get"]},{"signature":"bool IsCappedAtTop","summary":"Gets a value indicating whether the surface that fills the top profile is existing.","since":"5.0","property":["get"]},{"signature":"bool IsMiteredAtEnd","summary":"Gets a value indicating whether a miter plane at the end is defined.","since":"5.0","property":["get"]},{"signature":"bool IsMiteredAtStart","summary":"Returns a value indicating whether a miter plane at start is defined.","since":"5.0","property":["get"]},{"signature":"bool IsSolid","summary":"Gets a value indicating whether there is no gap among all surfaces constructing this object.","since":"5.0","property":["get"]},{"signature":"Vector3d MiterPlaneNormalAtEnd","summary":"Gets or sets the normal of the miter plane at the end in profile coordinates. In profile coordinates, 0,0,1 always maps to the extrusion axis","since":"5.0","property":["get","set"]},{"signature":"Vector3d MiterPlaneNormalAtStart","summary":"Gets or sets the normal of the miter plane at the start in profile coordinates. In profile coordinates, 0,0,1 always maps to the extrusion axis","since":"5.0","property":["get","set"]},{"signature":"Point3d PathEnd","summary":"Gets the end point of the path.","since":"5.0","property":["get"]},{"signature":"Point3d PathStart","summary":"Gets the start point of the path.","since":"5.0","property":["get"]},{"signature":"Vector3d PathTangent","summary":"Gets the up vector of the path.","since":"5.0","property":["get"]},{"signature":"int ProfileCount","summary":"Gets the amount of profile curves.","since":"5.0","property":["get"]}],"methods":[{"signature":"static Extrusion Create(Curve planarCurve, double height, bool cap)","summary":"Creates an extrusion of a 3d curve (which must be planar) and a height.","since":"5.1","parameters":[{"name":"planarCurve","summary":"Planar curve used as profile"},{"name":"height","summary":"If the height > 0, the bottom of the extrusion will be in plane and the top will be height units above the plane. If the height < 0, the top of the extrusion will be in plane and the bottom will be height units below the plane. The plane used is the one that is returned from the curve\'s TryGetPlane function."},{"name":"cap","summary":"If the curve is closed and cap is true, then the resulting extrusion is capped."}],"returns":"If the input is valid, then a new extrusion is returned. Otherwise None is returned"},{"signature":"static Extrusion CreateBoxExtrusion(Box box, bool cap)","summary":"Gets an extrusion from a box.","since":"6.0","parameters":[{"name":"box","summary":"IsValid must be true."},{"name":"cap","summary":"If true, the base and the top of the box will be capped. Defaults to true."}],"returns":"Extrusion on success. None on failure."},{"signature":"static Extrusion CreateCylinderExtrusion(Cylinder cylinder, bool capBottom, bool capTop)","summary":"Gets an extrusion form of a cylinder.","since":"5.0","parameters":[{"name":"cylinder","summary":"IsFinite must be true."},{"name":"capBottom","summary":"If true, the end at cylinder.Height1 will be capped."},{"name":"capTop","summary":"If true, the end at cylinder.Height2 will be capped."}],"returns":"Extrusion on success. None on failure."},{"signature":"static Extrusion CreatePipeExtrusion(Cylinder cylinder, double otherRadius, bool capTop, bool capBottom)","summary":"Gets an extrusion form of a pipe.","since":"5.0","parameters":[{"name":"cylinder","summary":"IsFinite must be true."},{"name":"otherRadius","summary":"If cylinder.Radius is less than other radius, then the cylinder will be the inside of the pipe."},{"name":"capTop","summary":"If true, the end at cylinder.Height2 will be capped."},{"name":"capBottom","summary":"If true, the end at cylinder.Height1 will be capped."}],"returns":"Extrusion on success. None on failure."},{"signature":"bool AddInnerProfile(Curve innerProfile)","summary":"Adds an inner profile.","since":"5.0","parameters":[{"name":"innerProfile","summary":"Closed curve in the XY plane or a 2d curve."}],"returns":"True if the profile was set."},{"signature":"Mesh GetMesh(MeshType meshType)","summary":"Obtains a reference to a specified type of mesh for this extrusion.","since":"5.6","parameters":[{"name":"meshType","summary":"The mesh type."}],"returns":"A mesh."},{"signature":"Plane GetPathPlane(double s)","summary":"Gets the 3D plane perpendicular to the path at a normalized path parameter.","since":"5.0","parameters":[{"name":"s","summary":"0.0 = starting profile 1.0 = ending profile."}],"returns":"A plane. The plane is Invalid on failure."},{"signature":"Plane GetProfilePlane(double s)","summary":"Gets the 3D plane containing the profile curve at a normalized path parameter.","since":"5.0","parameters":[{"name":"s","summary":"0.0 = starting profile 1.0 = ending profile."}],"returns":"A plane. The plane is Invalid on failure."},{"signature":"Transform GetProfileTransformation(double s)","summary":"Gets the transformation that maps the XY profile curve to its 3d location.","since":"5.0","parameters":[{"name":"s","summary":"0.0 = starting profile 1.0 = ending profile."}],"returns":"A Transformation. The transform is Invalid on failure."},{"signature":"Curve[] GetWireframe()","summary":"Constructs all the Wireframe curves for this Extrusion.","since":"5.6","returns":"An array of Wireframe curves."},{"signature":"LineCurve PathLineCurve()","summary":"Gets the line-like curve that is the conceptual axis of the extrusion.","since":"5.0","returns":"The path as a line curve."},{"signature":"Curve Profile3d(ComponentIndex ci)","summary":"Gets one of the profiles.","since":"5.0","parameters":[{"name":"ci","summary":"The index of this profile."}],"returns":"The profile."},{"signature":"Curve Profile3d(int profileIndex, double s)","summary":"Gets a transversal isocurve of the extruded profile.","since":"5.0","parameters":[{"name":"profileIndex","summary":"0 <= profileIndex < ProfileCount The outer profile has index 0."},{"name":"s","summary":"0.0 <= s <= 1.0 A relative parameter controlling which profile is returned. 0 = bottom profile and 1 = top profile."}],"returns":"The profile."},{"signature":"int ProfileIndex(double profileParameter)","summary":"Gets the index of the profile curve at a domain related to a parameter.","since":"5.0","parameters":[{"name":"profileParameter","summary":"Parameter on profile curve."}],"returns":"-1 if profileParameter does not correspond to a point on the profile curve. When the profileParameter corresponds to the end of one profile and the beginning of the next profile, the index of the next profile is returned."},{"signature":"bool SetOuterProfile(Curve outerProfile, bool cap)","summary":"Sets the outer profile of the extrusion.","since":"5.0","parameters":[{"name":"outerProfile","summary":"curve in the XY plane or a 2D curve."},{"name":"cap","summary":"If outerProfile is a closed curve, then cap determines if the extrusion has end caps. If outerProfile is an open curve, cap is ignored."}],"returns":"True if the profile was set. If the outer profile is closed, then the extrusion may also have inner profiles. If the outer profile is open, the extrusion may not have inner profiles. If the extrusion already has a profile, the set will fail."},{"signature":"bool SetPathAndUp(Point3d a, Point3d b, Vector3d up)","summary":"Allows to set the two points at the extremes and the up vector.","since":"5.0","parameters":[{"name":"a","summary":"The start point."},{"name":"b","summary":"The end point."},{"name":"up","summary":"The up vector."}],"returns":"True if the operation succeeded; otherwise false. Setting up=a-b will make the operation fail."},{"signature":"Brep ToBrep(bool splitKinkyFaces)","summary":"Constructs a brep form of the extrusion. The outer profile is always the first face of the brep. If there are inner profiles, additional brep faces are created for each profile. If the outer profile is closed, then end caps are added as the last two faces of the brep.","since":"5.0","parameters":[{"name":"splitKinkyFaces","summary":"If True and the profiles have kinks, then the faces corresponding to those profiles are split so they will be G1."}],"returns":"A brep with a similar shape like this extrusion, or None on error."},{"signature":"Curve WallEdge(ComponentIndex ci)","summary":"Gets one of the longitudinal curves along the beam or extrusion.","since":"5.0","parameters":[{"name":"ci","summary":"The index of this profile."}],"returns":"The profile."},{"signature":"Surface WallSurface(ComponentIndex ci)","summary":"Gets one of the longitudinal surfaces of the extrusion.","since":"5.0","parameters":[{"name":"ci","summary":"The index specifying which precise item to retrieve."}],"returns":"The surface."}]},{"namespace":"Rhino.Geometry","name":"GeometryBase","dataType":"class","summary":"Provides a common base for most geometric classes. This class is abstract.","baseclass":"Rhino.Runtime.CommonObject","properties":[{"signature":"bool HasBrepForm","summary":"Returns True if the Brep.TryConvertBrep function will be successful for this object","since":"5.6","property":["get"]},{"signature":"bool IsDeformable","summary":"True if object can be accurately modified with \\"squishy\\" transformations like projections, shears, and non-uniform scaling.","since":"5.0","property":["get"]},{"signature":"bool IsDocumentControlled","summary":"If True this object may not be modified. Any properties or functions that attempt to modify this object when it is set to \\"IsReadOnly\\" will throw a NotSupportedException.","since":"5.0","property":["get"]},{"signature":"ObjectType ObjectType","summary":"Useful for switch statements that need to differentiate between basic object types like points, curves, surfaces, and so on.","since":"5.0","property":["get"]},{"signature":"int UserStringCount","summary":"Gets the amount of user strings.","since":"5.0","property":["get"]}],"methods":[{"signature":"static bool GeometryEquals(GeometryBase first, GeometryBase second)","summary":"Determines if two geometries equal one another, in pure geometrical shape. This version only compares the geometry itself and does not include any user data comparisons. This is a comparison by value: for two identical items it will be true, no matter where in memory they may be stored.","since":"6.0","parameters":[{"name":"first","summary":"The first geometry"},{"name":"second","summary":"The second geometry"}],"returns":"The indication of equality"},{"signature":"ComponentIndex ComponentIndex()","summary":"If this piece of geometry is a component in something larger, like a BrepEdge in a Brep, then this function returns the component index.","since":"5.0","returns":"This object\'s component index.  If this object is not a sub-piece of a larger geometric entity, then the returned index has m_type = ComponentIndex.InvalidType and m_index = -1."},{"signature":"GeometryBase Duplicate()","summary":"Constructs a deep (full) copy of this object.","since":"5.0","returns":"An object of the same type as this, with the same properties and behavior."},{"signature":"GeometryBase DuplicateShallow()","summary":"Constructs a light copy of this object. By \\"light\\", it is meant that the same underlying data is used until something is done to attempt to change it. For example, you could have a shallow copy of a very heavy mesh object and the same underlying data will be used when doing things like inspecting the number of faces on the mesh. If you modify the location of one of the mesh vertices, the shallow copy will create a full duplicate of the underlying mesh data and the shallow copy will become a deep copy.","since":"5.0","returns":"An object of the same type as this object.  \\nThis behavior is overridden by implementing classes."},{"signature":"BoundingBox GetBoundingBox(bool accurate)","summary":"Bounding box solver. Gets the world axis aligned bounding box for the geometry.","since":"5.0","parameters":[{"name":"accurate","summary":"If true, a physically accurate bounding box will be computed. If not, a bounding box estimate will be computed. For some geometry types there is no difference between the estimate and the accurate bounding box. Estimated bounding boxes can be computed much (much) faster than accurate (or \\"tight\\") bounding boxes. Estimated bounding boxes are always similar to or larger than accurate bounding boxes."}],"returns":"The bounding box of the geometry in world coordinates or BoundingBox.Empty if not bounding box could be found."},{"signature":"BoundingBox GetBoundingBox(Plane plane)","summary":"Aligned Bounding box solver. Gets the plane aligned bounding box.","since":"5.0","parameters":[{"name":"plane","summary":"Orientation plane for BoundingBox."}],"returns":"A BoundingBox in plane coordinates."},{"signature":"BoundingBox GetBoundingBox(Plane plane, out Box worldBox)","summary":"Aligned Bounding box solver. Gets the plane aligned bounding box.","since":"5.0","parameters":[{"name":"plane","summary":"Orientation plane for BoundingBox."},{"name":"worldBox","summary":"Aligned box in World coordinates."}],"returns":"A BoundingBox in plane coordinates."},{"signature":"BoundingBox GetBoundingBox(Transform xform)","summary":"Aligned Bounding box solver. Gets the world axis aligned bounding box for the transformed geometry.","since":"5.0","parameters":[{"name":"xform","summary":"Transformation to apply to object prior to the BoundingBox computation. The geometry itself is not modified."}],"returns":"The accurate bounding box of the transformed geometry in world coordinates or BoundingBox.Empty if not bounding box could be found."},{"signature":"string GetUserString(string key)","summary":"Gets user string from this geometry.","since":"5.0","parameters":[{"name":"key","summary":"id used to retrieve the string."}],"returns":"string associated with the key if successful. None if no key was found."},{"signature":"System.Collections.Specialized.NameValueCollection GetUserStrings()","summary":"Gets a copy of all (user key string, user value string) pairs attached to this geometry.","since":"5.0","returns":"A new collection."},{"signature":"bool MakeDeformable()","summary":"If possible, converts the object into a form that can be accurately modified with \\"squishy\\" transformations like projections, shears, an non-uniform scaling.","since":"5.0","returns":"False if object cannot be converted to a deformable object. True if object was already deformable or was converted into a deformable object."},{"signature":"uint MemoryEstimate()","summary":"Computes an estimate of the number of bytes that this object is using in memory.","since":"5.0","returns":"An estimated memory footprint."},{"signature":"bool Rotate(double angleRadians, Vector3d rotationAxis, Point3d rotationCenter)","summary":"Rotates the object about the specified axis. A positive rotation angle results in a counter-clockwise rotation about the axis (right hand rule).","since":"5.0","parameters":[{"name":"angleRadians","summary":"Angle of rotation in radians."},{"name":"rotationAxis","summary":"Direction of the axis of rotation."},{"name":"rotationCenter","summary":"Point on the axis of rotation."}],"returns":"True if geometry successfully rotated."},{"signature":"bool Scale(double scaleFactor)","summary":"Scales the object by the specified factor. The scale is centered at the origin.","since":"5.0","parameters":[{"name":"scaleFactor","summary":"The uniform scaling factor."}],"returns":"True if geometry successfully scaled."},{"signature":"bool SetUserString(string key, string value)","summary":"Attach a user string (key,value combination) to this geometry.","since":"5.0","parameters":[{"name":"key","summary":"id used to retrieve this string."},{"name":"value","summary":"string associated with key."}],"returns":"True on success."},{"signature":"bool Transform(Transform xform)","summary":"Transforms the geometry. If the input Transform has a SimilarityType of OrientationReversing, you may want to consider flipping the transformed geometry after calling this function when it makes sense. For example, you may want to call Flip() on a Brep after transforming it.","since":"5.0","parameters":[{"name":"xform","summary":"Transformation to apply to geometry."}],"returns":"True if geometry successfully transformed."},{"signature":"bool Translate(double x, double y, double z)","summary":"Translates the object along the specified vector.","since":"5.0","parameters":[{"name":"x","summary":"The X component."},{"name":"y","summary":"The Y component."},{"name":"z","summary":"The Z component."}],"returns":"True if geometry successfully translated."},{"signature":"bool Translate(Vector3d translationVector)","summary":"Translates the object along the specified vector.","since":"5.0","parameters":[{"name":"translationVector","summary":"A moving vector."}],"returns":"True if geometry successfully translated."}]},{"namespace":"Rhino.Geometry","name":"Hatch","dataType":"class","summary":"Represents a hatch in planar boundary loop or loops. This is a 2d entity with a plane defining a local coordinate system. The loops, patterns, angles, etc are all in this local coordinate system. The Hatch object manages the plane and loop array Fill definitions are in the HatchPattern or class derived from HatchPattern Hatch has an index to get the pattern definition from the pattern table.","baseclass":"Rhino.Geometry.GeometryBase","properties":[{"signature":"Point3d BasePoint","summary":"Gets or sets the hatch pattern base point","since":"6.11","property":["get","set"]},{"signature":"int PatternIndex","summary":"Gets or sets the index of the pattern in the document hatch pattern table.","since":"5.0","property":["get","set"]},{"signature":"double PatternRotation","summary":"Gets or sets the relative rotation of the pattern.","since":"5.0","property":["get","set"]},{"signature":"double PatternScale","summary":"Gets or sets the scaling factor of the pattern.","since":"5.0","property":["get","set"]},{"signature":"Plane Plane","summary":"Gets or sets the hatch plane","since":"6.11","property":["get","set"]}],"methods":[{"signature":"static Hatch[] Create(Curve curve, int hatchPatternIndex, double rotationRadians, double scale)","summary":"Constructs an array of Hatchfrom one curve.","since":"5.0","deprecated":"6.0","parameters":[{"name":"curve","summary":"A Curve."},{"name":"hatchPatternIndex","summary":"The index of the hatch pattern in the document hatch pattern table."},{"name":"rotationRadians","summary":"The relative rotation of the pattern."},{"name":"scale","summary":"A scaling factor."}],"returns":"An array of hatches. The array might be empty on error."},{"signature":"static Hatch[] Create(Curve curve, int hatchPatternIndex, double rotationRadians, double scale, double tolerance)","summary":"Constructs an array of Hatchfrom one curve.","since":"6.0","parameters":[{"name":"curve","summary":"A Curve."},{"name":"hatchPatternIndex","summary":"The index of the hatch pattern in the document hatch pattern table."},{"name":"rotationRadians","summary":"The relative rotation of the pattern."},{"name":"scale","summary":"A scaling factor."},{"name":"tolerance","summary":""}],"returns":"An array of hatches. The array might be empty on error."},{"signature":"static Hatch[] Create(IEnumerable<Curve> curves, int hatchPatternIndex, double rotationRadians, double scale)","summary":"Constructs an array of Hatchfrom a set of curves.","since":"5.0","deprecated":"6.0","parameters":[{"name":"curves","summary":"An array, a list or any enumerable set of Curve."},{"name":"hatchPatternIndex","summary":"The index of the hatch pattern in the document hatch pattern table."},{"name":"rotationRadians","summary":"The relative rotation of the pattern."},{"name":"scale","summary":"A scaling factor."}],"returns":"An array of hatches. The array might be empty on error."},{"signature":"static Hatch[] Create(IEnumerable<Curve> curves, int hatchPatternIndex, double rotationRadians, double scale, double tolerance)","summary":"Constructs an array of Hatchfrom a set of curves.","since":"6.0","parameters":[{"name":"curves","summary":"An array, a list or any enumerable set of Curve."},{"name":"hatchPatternIndex","summary":"The index of the hatch pattern in the document hatch pattern table."},{"name":"rotationRadians","summary":"The relative rotation of the pattern."},{"name":"scale","summary":"A scaling factor."},{"name":"tolerance","summary":""}],"returns":"An array of hatches. The array might be empty on error."},{"signature":"void CreateDisplayGeometry(HatchPattern pattern, double patternScale, out Curve[] bounds, out Line[] lines, out Brep solidBrep)","summary":"Generate geometry that would be used to draw the hatch with a given hatch pattern","since":"5.6"},{"signature":"GeometryBase[] Explode()","summary":"Decomposes the hatch pattern into an array of geometry.","since":"5.0","returns":"An array of geometry that formed the appearance of the original elements."},{"signature":"Curve[] Get3dCurves(bool outer)","summary":"Gets 3d curves that define the boundaries of the hatch","since":"5.0","parameters":[{"name":"outer","summary":"True to get the outer curves, False to get the inner curves"}]},{"signature":"Rhino.Display.ColorGradient GetGradientFill()","summary":"Get gradient fill information for this hatch. If the \\"GradientType\\" for the fill is None, then this hatch doesn\'t have any gradient fill.","since":"7.0"},{"signature":"void ScalePattern(Transform xform)","summary":"Scale the hatch\'s pattern","since":"6.11"},{"signature":"void SetGradientFill(ColorGradient fill)","since":"7.0"}]},{"namespace":"Rhino.Geometry","name":"HermiteSurface","dataType":"class","summary":"Create an ON_NurbsSurface satisfying Hermite interpolation conditions at a grid of points.","interfaces":["IDisposable"],"constructors":[{"signature":"HermiteSurface()","summary":"Initializes a new HermiteSurfaceinstance.","since":"7.0"},{"signature":"HermiteSurface(int uCount, int vCount)","summary":"Initializes a new HermiteSurfaceinstance.","since":"7.0","parameters":[{"name":"uCount","summary":"The number of parameters in the \\"u\\" direction."},{"name":"vCount","summary":"The number of parameters in the \\"v\\" direction."}]}],"properties":[{"signature":"bool IsValid","summary":"Returns True if the all of values in all of the internal data structures contain valid values, False otherwise.","since":"7.0","property":["get"]},{"signature":"int UCount","summary":"Gets the number of parameters in the \\"u\\" direction.","since":"7.0","property":["get"]},{"signature":"int VCount","summary":"Gets the number of parameters in the \\"v\\" direction.","since":"7.0","property":["get"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"7.0"},{"signature":"Point3d PointAt(int uIndex, int vIndex)","summary":"Gets the interpolation point at the u,v parameter location.","since":"7.0","parameters":[{"name":"uIndex","summary":"The \\"u\\" index."},{"name":"vIndex","summary":"The \\"v\\" index."}],"returns":"The point location."},{"signature":"void SetPointAt(int uIndex, int vIndex, Point3d point)","summary":"Sets the interpolation point at the u,v parameter location.","since":"7.0","parameters":[{"name":"uIndex","summary":"The \\"u\\" index."},{"name":"vIndex","summary":"The \\"v\\" index."},{"name":"point","summary":"The point location."}]},{"signature":"void SetTwistAt(int uIndex, int vIndex, Vector3d twist)","summary":"Set the twist direction (mixed second partial derivative) to interpolate at the u,v parameter location.","since":"7.0","parameters":[{"name":"uIndex","summary":"The \\"u\\" index."},{"name":"vIndex","summary":"The \\"v\\" index."},{"name":"twist","summary":"The twist direction."}]},{"signature":"void SetUParameterAt(int index, double parameter)","summary":"Sets the \\"u\\" parameter at an index. These parameters are strictly increasing.","since":"7.0","parameters":[{"name":"index","summary":"The index."},{"name":"parameter","summary":"The parameter value."}]},{"signature":"void SetUTangentAt(int uIndex, int vIndex, Vector3d tangent)","summary":"Set the \\"u\\" tangent direction (actually first derivative) to interpolate at the u,v parameter location.","since":"7.0","parameters":[{"name":"uIndex","summary":"The \\"u\\" index."},{"name":"vIndex","summary":"The \\"v\\" index."},{"name":"tangent","summary":"The tangent direction."}]},{"signature":"void SetVParameterAt(int index, double parameter)","summary":"Sets the \\"v\\" parameter at an index. These parameters are strictly increasing.","since":"7.0","parameters":[{"name":"index","summary":"The index."},{"name":"parameter","summary":"The parameter value."}]},{"signature":"void SetVTangentAt(int uIndex, int vIndex, Vector3d tangent)","summary":"Set the \\"v\\" tangent direction (actually first derivative) to interpolate at the u,v parameter location.","since":"7.0","parameters":[{"name":"uIndex","summary":"The \\"u\\" index."},{"name":"vIndex","summary":"The \\"v\\" index."},{"name":"tangent","summary":"The tangent direction."}]},{"signature":"NurbsSurface ToNurbsSurface()","summary":"Constructs a NURBS surface satisfying the Hermite interpolation conditions.","since":"7.0","returns":"A NURBS surface is successful, None otherwise."},{"signature":"Vector3d TwistAt(int uIndex, int vIndex)","summary":"Get the twist direction (mixed second partial derivative) to interpolate at the u,v parameter location.","since":"7.0","parameters":[{"name":"uIndex","summary":"The \\"u\\" index."},{"name":"vIndex","summary":"The \\"v\\" index."}],"returns":"The twist direction."},{"signature":"double UParameterAt(int index)","summary":"Gets the \\"u\\" parameter at an index. These parameters are strictly increasing.","since":"7.0","parameters":[{"name":"index","summary":"The index."}],"returns":"The parameter."},{"signature":"Vector3d UTangentAt(int uIndex, int vIndex)","summary":"Get the \\"u\\" tangent direction (actually first derivative) to interpolate at the u,v parameter location.","since":"7.0","parameters":[{"name":"uIndex","summary":"The \\"u\\" index."},{"name":"vIndex","summary":"The \\"v\\" index."}],"returns":"The tangent direction."},{"signature":"double VParameterAt(int index)","summary":"Gets the \\"v\\" parameter at an index. These parameters are strictly increasing.","since":"7.0","parameters":[{"name":"index","summary":"The index."}],"returns":"The parameter."},{"signature":"Vector3d VTangentAt(int uIndex, int vIndex)","summary":"Get the \\"v\\" tangent direction (actually first derivative) to interpolate at the u,v parameter location.","since":"7.0","parameters":[{"name":"uIndex","summary":"The \\"u\\" index."},{"name":"vIndex","summary":"The \\"v\\" index."}],"returns":"The tangent direction."}]},{"namespace":"Rhino.Geometry","name":"HiddenLineDrawing","dataType":"class","summary":"Represents a hidden line drawing object. A hidden line drawing consists of curves generated from source objects. The curves correspond to edges, and silhouettes of  source objects and intersections with cutting planes.","interfaces":["IDisposable"],"properties":[{"signature":"IEnumerable<HiddenLineDrawingPoint> Points","summary":"Point objects calculated by the hidden line drawing.","since":"6.8","property":["get"]},{"signature":"IEnumerable<HiddenLineDrawingSegment> Segments","summary":"Sub-curve objects calculated by the hidden line drawing.","since":"6.0","property":["get"]},{"signature":"ViewportInfo Viewport","summary":"Returns the ViewportInfo used by the hidden line drawing.","since":"6.0","property":["get"]},{"signature":"Transform WorldToHiddenLine","summary":"Returns the world-coordinate system to HLD-coordinate system transformation.","since":"6.0","property":["get"]}],"methods":[{"signature":"static HiddenLineDrawing Compute(HiddenLineDrawingParameters parameters, bool multipleThreads)","summary":"Perform the hidden line drawing calculation based on input parameters","since":"6.0","returns":"Results of calculation on success, None on failure"},{"signature":"static HiddenLineDrawing Compute(HiddenLineDrawingParameters parameters, bool multipleThreads, IProgress<double> progress, CancellationToken cancelToken)","summary":"Perform the hidden line drawing calculation based on input parameters","since":"6.0","returns":"Results of calculation on success, None on failure or cancellation"},{"signature":"BoundingBox BoundingBox(bool includeHidden)","summary":"Get tight bounding box of the hidden line drawing.","since":"6.0","parameters":[{"name":"includeHidden","summary":"Include hidden objects."}],"returns":"The tight bounding box."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"}]},{"namespace":"Rhino.Geometry","name":"HiddenLineDrawingObject","dataType":"class","summary":"Represents an object added to a HiddenLineDrawing","properties":[{"signature":"GeometryBase Geometry","summary":"Returns the geometry in world coordinates if UseXform is false. Otherwise, the geometry in object space coordinates is returned.","since":"6.0","property":["get"]},{"signature":"object Tag","summary":"Returns the extra data used to cross-reference the object specified in HiddenLineDrawing.AddObject.","since":"6.0","property":["get"]},{"signature":"Transform Transform","summary":"Returns the transformation passed into the Add... function when setting up the hidden line drawing parameters.","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Geometry","name":"HiddenLineDrawingObjectCurve","dataType":"class","summary":"Curves generated from source objects which correspond to edges, and silhouettes of source objects and intersections with cutting planes. A HiddenLineDrawingObjectCurve is partitioned into hidden and visible segments called HiddenLineDrawingSegment","properties":[{"signature":"int ClippingPlaneIndex","summary":"Index into HiddenLineDrawing.ClippingPlanes when SilhouetteType == SilhouetteType.SectionCut.","since":"6.0","property":["get"]},{"signature":"int Index","summary":"Index of this object in HiddenLineDrawing.FullCurves.","since":"6.0","property":["get"]},{"signature":"bool IsProjecting","summary":"Returns True if all the non clipped portions of this curve are projecting.","since":"6.0","property":["get"]},{"signature":"bool IsValid","summary":"Verifies the object is valid.","since":"6.0","property":["get"]},{"signature":"double OriginalDomainStart","summary":"Initialized to RhinoMath.UnsetValue. Valid if the full curve is closed. Rejoin can reparameterize the curve by moving the seam.  When this has been done the original domain start is stored here.","since":"6.0","property":["get"]},{"signature":"double[] Parameters","summary":"Increasing, partition of curve.Domain.","since":"6.0","property":["get"]},{"signature":"HiddenLineDrawingSegment[] Segments","summary":"The HiddenLineDrawingCurve objects that make up this full curve.","since":"6.0","property":["get"]},{"signature":"SilhouetteType SilhouetteType","summary":"The silhouette event type","since":"6.0","property":["get"]},{"signature":"HiddenLineDrawingObject SourceObject","summary":"Return the source object that this curve came from","since":"6.0","property":["get"]},{"signature":"ComponentIndex SourceObjectComponentIndex","summary":"Component of source object part that generated this curve.","since":"6.0","property":["get"]}],"methods":[{"signature":"HiddenLineDrawingSegment Curve(double t)","summary":"Returns the HiddenLineDrawingCurve object containing parameter \'t\'.","since":"6.0","parameters":[{"name":"t","summary":"The parameter."}],"returns":"The HiddenLineDrawingCurve object if successful."},{"signature":"HiddenLineDrawingSegment Curve(double t, int side)","summary":"Returns the HiddenLineDrawingCurve object containing parameter \'t\'.","since":"6.0","parameters":[{"name":"t","summary":"The parameter."},{"name":"side","summary":"Determines which side to return at breakpoints, where: 0 - default, <0 - curve that contains an interval [t-, t], for some t- < t, >0 - curve that contains an interval [t, t+], for some t+ > t."}],"returns":"The HiddenLineDrawingCurve object if successful."}]},{"namespace":"Rhino.Geometry","name":"HiddenLineDrawingParameters","dataType":"class","summary":"Input used for computing a hidden line drawing","constructors":[{"signature":"HiddenLineDrawingParameters()","summary":"default constructor","since":"6.0"}],"properties":[{"signature":"double AbsoluteTolerance","summary":"Absolute tolerance is used to decide if curves overlap or intersect. A suggested value is to use RhinoDoc.AbsoluteTolerance","since":"6.0","property":["get","set"]},{"signature":"bool Flatten","summary":"Flatten the computed geometry","since":"6.0","property":["get","set"]},{"signature":"bool IncludeHiddenCurves","summary":"Include hidden curves in hidden line drawing (default is true)","since":"6.0","property":["get","set"]},{"signature":"bool IncludeTangentEdges","summary":"Include tangent edges in hidden line drawing (default is true)","since":"6.0","property":["get","set"]},{"signature":"bool IncludeTangentSeams","summary":"Include tangent seams in hidden line drawing (default is true)","since":"6.0","property":["get","set"]}],"methods":[{"signature":"void AddClippingPlane(Plane plane)","summary":"Specify clipping planes that are active for this view.","since":"6.0"},{"signature":"bool AddGeometry(GeometryBase geometry, object tag)","summary":"Add geometry that should be included in the calculation","since":"6.0","parameters":[{"name":"geometry","summary":"Currently only curves, meshes, breps, surfaces, and extrusions are supported"},{"name":"tag","summary":"arbitrary data to be associated with this geometry"}],"returns":"True if the type of geometry can be added for calculations. Currently only curves, meshes, breps, surfaces and extrusions are supported"},{"signature":"bool AddGeometry(GeometryBase geometry, Transform xform, object tag)","summary":"Add geometry that should be included in the calculation","since":"6.0","parameters":[{"name":"geometry","summary":"Currently only points, point clouds, curves, meshes, breps, surfaces, and extrusions are supported"},{"name":"xform","summary":""},{"name":"tag","summary":"arbitrary data to be associated with this geometry"}],"returns":"True if the type of geometry can be added for calculations. Currently only points, point clouds, curves, meshes, breps, surfaces and extrusions are supported"},{"signature":"void SetViewport(RhinoViewport viewport)","summary":"Set the viewport for the hidden line drawing (HLD). The viewport supplies the projection that determines the visibility of curves, and the HLD coordinate system in which the resulting curves are represented. The HLD-coordinate system is a right handed system for 3-D model space, in which the 3rd coordinate direction is the projection direction. In particular the z-coordinate direction points from the scene toward the camera.","since":"6.0","parameters":[{"name":"viewport","summary":"A copy of rhinoViewport is made inside of HiddenLineDrawing."}],"returns":"True if the viewport has been set."},{"signature":"void SetViewport(ViewportInfo viewport)","summary":"Set the viewport for the hidden line drawing (HLD). The viewport supplies the projection that determines the visibility of curves, and the HLD coordinate system in which the resulting curves are represented. The HLD-coordinate system is a right handed system for 3-D model space, in which the 3rd coordinate direction is the projection direction. In particular the z-coordinate direction points from the scene toward the camera.","since":"6.0","parameters":[{"name":"viewport","summary":"A copy of viewportInfo is made inside of HiddenLineDrawing."}],"returns":"True if the viewport has been set."}]},{"namespace":"Rhino.Geometry","name":"HiddenLineDrawingPoint","dataType":"class","summary":"Points generated from source objects which correspond to point and point cloud source objects.","properties":[{"signature":"int ClippingPlaneIndex","summary":"Index into HiddenLineDrawing.ClippingPlanes when SilhouetteType == SilhouetteType.SectionCut.","since":"6.8","property":["get"]},{"signature":"int Index","summary":"Index of this object in HiddenLineDrawing.Points.","since":"6.8","property":["get"]},{"signature":"Point3d Location","summary":"Returns the location of this object in HiddenLineDrawing coordinates.","since":"6.8","property":["get"]},{"signature":"Visibility PointVisibility","summary":"Returns the point\'s visibility","since":"6.8","property":["get"]},{"signature":"HiddenLineDrawingObject SourceObject","summary":"Return the source object that this point came from.","since":"6.8","property":["get"]},{"signature":"ComponentIndex SourceObjectComponentIndex","summary":"Component of source object part that generated this curve.","since":"6.8","property":["get"]}]},{"namespace":"Rhino.Geometry","name":"HiddenLineDrawingPoint.Visibility","dataType":"enum","summary":"The different types of HiddenLineObjectPoint visibility","since":"6.8","values":[{"signature":"Unset = UnsafeNativeMethods.HldPointVisibility.PointUnset","summary":"Unset value"},{"signature":"Visible = UnsafeNativeMethods.HldPointVisibility.PointVisible","summary":"Visible"},{"signature":"Hidden = UnsafeNativeMethods.HldPointVisibility.PointHidden","summary":"Hidden"},{"signature":"Duplicate = UnsafeNativeMethods.HldPointVisibility.PointDuplicate","summary":"Duplicate"}]},{"namespace":"Rhino.Geometry","name":"HiddenLineDrawingSegment","dataType":"class","summary":"The results of HiddenLineDrawing calculation are a collection of segments. A segment is a sub-curve of a HiddenLineDrawingObjectCurve.","properties":[{"signature":"Curve CurveGeometry","summary":"The actual curve geometry","since":"6.0","property":["get"]},{"signature":"SideFill[] CurveSideFills","summary":"The SideFill fields are only valid for visible curves. With respect to the HiddenLineDrawing, the region to the left (or right respectively) of this curve is described by CurveSideFills[0] or CurveSideFills[1], respectively.  If exactly one of these regions is empty this is a scene silhouette. If this region contains a surface it is either a surface which in 3-D is adjacent to this edge or it an surface that is further away from the camera, we call this a shadow surface. unknown is used for unset values and for projecting curves","since":"6.0","property":["get"]},{"signature":"int Index","summary":"Index of this curve in HiddenLineDrawing.Curves.","since":"6.0","property":["get"]},{"signature":"bool IsSceneSilhouette","summary":"Returns True if this curve is a scene silhouette.","since":"6.0","property":["get"]},{"signature":"HiddenLineDrawingObjectCurve ParentCurve","summary":"This curve is a sub-curve of the returned HiddenLineDrawingFullCurve object.","since":"6.0","property":["get"]},{"signature":"Visibility SegmentVisibility","summary":"Returns the segment\'s visibility","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Geometry","name":"HiddenLineDrawingSegment.SideFill","dataType":"enum","summary":"When a silhouette is projected on the image plane (determined by the camera location or direction), and projects to a curve (not a point), the image area to the left or right of a projected silhouette curve is filled with either the surface or a void.","since":"6.0","values":[{"signature":"SideUnset = UnsafeNativeMethods.HldSilhouetteSideFill.SideUnset","summary":"Unset"},{"signature":"SideSurface = UnsafeNativeMethods.HldSilhouetteSideFill.SideSurface","summary":"Surface"},{"signature":"SideVoid = UnsafeNativeMethods.HldSilhouetteSideFill.SideVoid","summary":"Void"},{"signature":"OtherSurface = UnsafeNativeMethods.HldSilhouetteSideFill.SideOtherSurface","summary":"Other Surface"}]},{"namespace":"Rhino.Geometry","name":"HiddenLineDrawingSegment.Visibility","dataType":"enum","summary":"The different types of HiddenLineDrawingSegment visibility","since":"6.0","values":[{"signature":"Unset = UnsafeNativeMethods.HldCurveVisibility.Unset","summary":"Unset value"},{"signature":"Visible = UnsafeNativeMethods.HldCurveVisibility.Visible","summary":"Visible"},{"signature":"Hidden = UnsafeNativeMethods.HldCurveVisibility.Hidden","summary":"Hidden"},{"signature":"Duplicate = UnsafeNativeMethods.HldCurveVisibility.Duplicate","summary":"Duplicate"},{"signature":"Projecting = UnsafeNativeMethods.HldCurveVisibility.Projecting","summary":"Projects to a point (smaller than tolerance)"},{"signature":"Clipped = UnsafeNativeMethods.HldCurveVisibility.Clipped","summary":"Clipped by clipping planes"}]},{"namespace":"Rhino.Geometry","name":"InstanceDefinitionGeometry","dataType":"class","summary":"Represents a block definition in a File3dm. This is the same as Rhino.DocObjects.InstanceDefinition, but not associated with a RhinoDoc.","baseclass":"Rhino.DocObjects.ModelComponent","constructors":[{"signature":"InstanceDefinitionGeometry()","summary":"Initializes a new block definition.","since":"5.0"}],"properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.InstanceDefinition.","since":"6.0","property":["get"]},{"signature":"string Description","summary":"Gets or sets the description of the definition.","since":"5.0","property":["get","set"]},{"signature":"string Url","summary":"Gets or sets the URL or hyperlink of the definition.","since":"7.0","property":["get","set"]},{"signature":"string UrlDescription","summary":"Gets or sets the description of the URL or hyperlink of the definition.","since":"7.0","property":["get","set"]}],"methods":[{"signature":"Guid[] GetObjectIds()","summary":"list of object ids in the instance geometry table","since":"5.6"}]},{"namespace":"Rhino.Geometry","name":"InstanceReferenceGeometry","dataType":"class","summary":"Represents a reference to the geometry in a block definition.","baseclass":"Rhino.Geometry.GeometryBase","constructors":[{"signature":"InstanceReferenceGeometry(Guid instanceDefinitionId, Transform transform)","summary":"Constructor used when creating nested instance references.","since":"5.1"}],"properties":[{"signature":"Guid ParentIdefId","summary":"The unique id for the parent instance definition of this instance reference.","since":"5.6","property":["get"]},{"signature":"Transform Xform","summary":"Transformation for this reference.","since":"5.6","property":["get"]}]},{"namespace":"Rhino.Geometry","name":"Interpolator","dataType":"class","summary":"Exposes a set of standard numeric interpolation algorithms.","baseclass":"RhinoList<double>","constructors":[{"signature":"Interpolator()","summary":"Constructs a new, empty Interpolator.","since":"5.0"},{"signature":"Interpolator(IEnumerable<double> collection)","summary":"Constructs an Interpolator from a collection of numbers.","since":"5.0","parameters":[{"name":"collection","summary":"Collection of numbers to duplicate."}]},{"signature":"Interpolator(int initialCapacity)","summary":"Constructs an empty Interpolator with a certain capacity.","since":"5.0","parameters":[{"name":"initialCapacity","summary":"Number of items this interpolator can store without resizing."}]},{"signature":"Interpolator(int amount, double defaultValue)","summary":"Constructs a new Interpolator with a specified amount of numbers.","since":"5.0","parameters":[{"name":"amount","summary":"Number of values to add to this Interpolator. Must be equal to or larger than zero."},{"name":"defaultValue","summary":"Number to add."}]},{"signature":"Interpolator(RhinoList<double> list)","summary":"Copy all the numbers from an existing RhinoList.","since":"5.0","parameters":[{"name":"list","summary":"List to mimic."}]}],"properties":[{"signature":"bool Cyclical","summary":"Gets or sets a value indicating whether or not the values inside this Interpolator are to be treated as cyclical (i.e. circular).","since":"5.0","property":["get","set"]}],"methods":[{"signature":"double InterpolateCatmullRom(double t)","summary":"Sample the list of numbers with Catmull-Rom interpolation.","since":"5.0","parameters":[{"name":"t","summary":"Parameter to sample at. The integer portion of the parameter indicates the index of the left-hand value. If this Interpolator is cyclical, parameters will be wrapped."}],"returns":"The sampled value at t."},{"signature":"double InterpolateCosine(double t)","summary":"Sample the list of numbers with cosine interpolation.","since":"5.0","parameters":[{"name":"t","summary":"Parameter to sample at. The integer portion of the parameter indicates the index of the left-hand value. If this Interpolator is cyclical, parameters will be wrapped."}],"returns":"The sampled value at t."},{"signature":"double InterpolateCubic(double t)","summary":"Sample the list of numbers with cubic interpolation.","since":"5.0","parameters":[{"name":"t","summary":"Parameter to sample at. The integer portion of the parameter indicates the index of the left-hand value. If this Interpolator is cyclical, parameters will be wrapped."}],"returns":"The sampled value at t."},{"signature":"double InterpolateLinear(double t)","summary":"Sample the list of numbers with linear interpolation.","since":"5.0","parameters":[{"name":"t","summary":"Parameter to sample at. The integer portion of the parameter indicates the index of the left-hand value. If this Interpolator is cyclical, parameters will be wrapped."}],"returns":"The sampled value at t."},{"signature":"double InterpolateNearestNeighbour(double t)","summary":"Sample the list of numbers with Nearest Neighbor interpolation.","since":"5.0","parameters":[{"name":"t","summary":"Parameter to sample at. The integer portion of the parameter indicates the index of the left-hand value. If this Interpolator is cyclical, parameters will be wrapped."}],"returns":"The sampled value at t."}]},{"namespace":"Rhino.Geometry.Intersect","name":"CurveIntersections","dataType":"class","summary":"Maintains an ordered list of Curve Intersection results.","interfaces":["IDisposable","IList<IntersectionEvent>"],"properties":[{"signature":"int Count","summary":"Gets the number of recorded intersection events.","since":"5.0","property":["get"]}],"methods":[{"signature":"void CopyTo(IntersectionEvent[] array, int arrayIndex)","summary":"Copies all intersection results into another array, departing at an index in the target array.","since":"5.0","parameters":[{"name":"array","summary":"The target array. This value cannot be null."},{"name":"arrayIndex","summary":"Zero-based index in which to start the copy."}]},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"IEnumerator<IntersectionEvent> GetEnumerator()","summary":"Returns an enumerator that is capable of yielding all IntersectionEvents in the collection.","since":"5.0","returns":"The constructed enumerator."}]},{"namespace":"Rhino.Geometry.Intersect","name":"Intersection","dataType":"class","summary":"Provides static methods for the computation of intersections, projections, sections and similar.","properties":[{"signature":"static double MeshIntersectionsTolerancesCoefficient","summary":"Offers a requested adjustment coefficient for mesh-mesh intersections tolerances. The value can be used to multiply the document absolute tolerance.  \\nThis is only a UI value; it is up to developer to honor (or not) this request, depending on application needs.","since":"7.0","property":["get","set"]}],"methods":[{"signature":"static bool BrepBrep(Brep brepA, Brep brepB, double tolerance, out Curve[] intersectionCurves, out Point3d[] intersectionPoints)","summary":"Intersects two Breps.","since":"5.0","parameters":[{"name":"brepA","summary":"First Brep for intersection."},{"name":"brepB","summary":"Second Brep for intersection."},{"name":"tolerance","summary":"Intersection tolerance."},{"name":"intersectionCurves","summary":"The intersection curves will be returned here."},{"name":"intersectionPoints","summary":"The intersection points will be returned here."}],"returns":"True on success; False on failure."},{"signature":"static bool BrepPlane(Brep brep, Plane plane, double tolerance, out Curve[] intersectionCurves, out Point3d[] intersectionPoints)","summary":"Intersects a Brep with an (infinite) plane.","since":"5.0","parameters":[{"name":"brep","summary":"Brep to intersect."},{"name":"plane","summary":"Plane to intersect with."},{"name":"tolerance","summary":"Tolerance to use for intersections."},{"name":"intersectionCurves","summary":"The intersection curves will be returned here."},{"name":"intersectionPoints","summary":"The intersection points will be returned here."}],"returns":"True on success, False on failure."},{"signature":"static bool BrepSurface(Brep brep, Surface surface, double tolerance, out Curve[] intersectionCurves, out Point3d[] intersectionPoints)","summary":"Intersects a Brep and a Surface.","since":"5.0","parameters":[{"name":"brep","summary":"A brep to be intersected."},{"name":"surface","summary":"A surface to be intersected."},{"name":"tolerance","summary":"A tolerance value."},{"name":"intersectionCurves","summary":"The intersection curves array argument. This out reference is assigned during the call."},{"name":"intersectionPoints","summary":"The intersection points array argument. This out reference is assigned during the call."}],"returns":"True on success; False on failure."},{"signature":"static bool CurveBrep(Curve curve, Brep brep, double tolerance, double angleTolerance, out double[] t)","summary":"Intersect a curve with a Brep. This function returns the intersection parameters on the curve.","since":"6.0","parameters":[{"name":"curve","summary":"Curve."},{"name":"brep","summary":"Brep."},{"name":"tolerance","summary":"Absolute tolerance for intersections."},{"name":"angleTolerance","summary":"Angle tolerance in radians."},{"name":"t","summary":"Curve parameters at intersections."}],"returns":"True on success, False on failure."},{"signature":"static bool CurveBrep(Curve curve, Brep brep, double tolerance, out Curve[] overlapCurves, out Point3d[] intersectionPoints)","summary":"Intersects a curve with a Brep. This function returns the 3D points of intersection and 3D overlap curves. If an error occurs while processing overlap curves, this function will return false, but it will still provide partial results.","since":"5.0","parameters":[{"name":"curve","summary":"Curve for intersection."},{"name":"brep","summary":"Brep for intersection."},{"name":"tolerance","summary":"Fitting and near miss tolerance."},{"name":"overlapCurves","summary":"The overlap curves will be returned here."},{"name":"intersectionPoints","summary":"The intersection points will be returned here."}],"returns":"True on success, False on failure."},{"signature":"static bool CurveBrep(Curve curve, Brep brep, double tolerance, out Curve[] overlapCurves, out Point3d[] intersectionPoints, out double[] curveParameters)","summary":"Intersects a curve with a Brep. This function returns the 3D points of intersection, curve parameters at the intersection locations, and 3D overlap curves. If an error occurs while processing overlap curves, this function will return false, but it will still provide partial results.","since":"6.0","parameters":[{"name":"curve","summary":"Curve for intersection."},{"name":"brep","summary":"Brep for intersection."},{"name":"tolerance","summary":"Fitting and near miss tolerance."},{"name":"overlapCurves","summary":"The overlap curves will be returned here."},{"name":"intersectionPoints","summary":"The intersection points will be returned here."},{"name":"curveParameters","summary":"The intersection curve parameters will be returned here."}],"returns":"True on success, False on failure."},{"signature":"static bool CurveBrepFace(Curve curve, BrepFace face, double tolerance, out Curve[] overlapCurves, out Point3d[] intersectionPoints)","summary":"Intersects a curve with a Brep face.","since":"5.0","parameters":[{"name":"curve","summary":"A curve."},{"name":"face","summary":"A brep face."},{"name":"tolerance","summary":"Fitting and near miss tolerance."},{"name":"overlapCurves","summary":"A overlap curves array argument. This out reference is assigned during the call."},{"name":"intersectionPoints","summary":"A points array argument. This out reference is assigned during the call."}],"returns":"True on success, False on failure."},{"signature":"static CurveIntersections CurveCurve(Curve curveA, Curve curveB, double tolerance, double overlapTolerance)","summary":"Finds the intersections between two curves.","since":"5.0","parameters":[{"name":"curveA","summary":"First curve for intersection."},{"name":"curveB","summary":"Second curve for intersection."},{"name":"tolerance","summary":"Intersection tolerance. If the curves approach each other to within tolerance, an intersection is assumed."},{"name":"overlapTolerance","summary":"The tolerance with which the curves are tested."}],"returns":"A collection of intersection events."},{"signature":"static CurveIntersections CurveCurveValidate(Curve curveA, Curve curveB, double tolerance, double overlapTolerance, out int[] invalidIndices, out TextLog textLog)","summary":"Finds the intersections between two curves.","since":"7.0","parameters":[{"name":"curveA","summary":"First curve for intersection."},{"name":"curveB","summary":"Second curve for intersection."},{"name":"tolerance","summary":"Intersection tolerance. If the curves approach each other to within tolerance, an intersection is assumed."},{"name":"overlapTolerance","summary":"The tolerance with which the curves are tested."},{"name":"invalidIndices","summary":"The indices in the resulting CurveIntersections collection that are invalid."},{"name":"textLog","summary":"A text log that contains tails about the invalid intersection events."}],"returns":"A collection of intersection events."},{"signature":"static CurveIntersections CurveLine(Curve curve, Line line, double tolerance, double overlapTolerance)","summary":"Intersects a curve and an infinite line.","since":"6.0","parameters":[{"name":"curve","summary":"Curve for intersection."},{"name":"line","summary":"Infinite line to intersect."},{"name":"tolerance","summary":"Intersection tolerance. If the curves approach each other to within tolerance, an intersection is assumed."},{"name":"overlapTolerance","summary":"The tolerance with which the curves are tested."}],"returns":"A collection of intersection events."},{"signature":"static CurveIntersections CurvePlane(Curve curve, Plane plane, double tolerance)","summary":"Intersects a curve with an (infinite) plane.","since":"5.0","parameters":[{"name":"curve","summary":"Curve to intersect."},{"name":"plane","summary":"Plane to intersect with."},{"name":"tolerance","summary":"Tolerance to use during intersection."}],"returns":"A list of intersection events or None if no intersections were recorded."},{"signature":"static CurveIntersections CurveSelf(Curve curve, double tolerance)","summary":"Finds the places where a curve intersects itself.","since":"5.0","parameters":[{"name":"curve","summary":"Curve for self-intersections."},{"name":"tolerance","summary":"Intersection tolerance. If the curve approaches itself to within tolerance, an intersection is assumed."}],"returns":"A collection of intersection events."},{"signature":"static CurveIntersections CurveSurface(Curve curve, Interval curveDomain, Surface surface, double tolerance, double overlapTolerance)","summary":"Intersects a sub-curve and a surface.","since":"5.0","parameters":[{"name":"curve","summary":"Curve for intersection."},{"name":"curveDomain","summary":"Domain of sub-curve to take into consideration for Intersections."},{"name":"surface","summary":"Surface for intersection."},{"name":"tolerance","summary":"Intersection tolerance. If the curve approaches the surface to within tolerance, an intersection is assumed."},{"name":"overlapTolerance","summary":"The tolerance with which the curves are tested."}],"returns":"A collection of intersection events."},{"signature":"static CurveIntersections CurveSurface(Curve curve, Surface surface, double tolerance, double overlapTolerance)","summary":"Intersects a curve and a surface.","since":"5.0","parameters":[{"name":"curve","summary":"Curve for intersection."},{"name":"surface","summary":"Surface for intersection."},{"name":"tolerance","summary":"Intersection tolerance. If the curve approaches the surface to within tolerance, an intersection is assumed."},{"name":"overlapTolerance","summary":"The tolerance with which the curves are tested."}],"returns":"A collection of intersection events."},{"signature":"static CurveIntersections CurveSurfaceValidate(Curve curve, Interval curveDomain, Surface surface, double tolerance, double overlapTolerance, out int[] invalidIndices, out TextLog textLog)","summary":"Intersects a sub-curve and a surface.","since":"7.0","parameters":[{"name":"curve","summary":"Curve for intersection."},{"name":"curveDomain","summary":"Domain of sub-curve to take into consideration for Intersections."},{"name":"surface","summary":"Surface for intersection."},{"name":"tolerance","summary":"Intersection tolerance. If the curve approaches the surface to within tolerance, an intersection is assumed."},{"name":"overlapTolerance","summary":"The tolerance with which the curves are tested."},{"name":"invalidIndices","summary":"The indices in the resulting CurveIntersections collection that are invalid."},{"name":"textLog","summary":"A text log that contains tails about the invalid intersection events."}],"returns":"A collection of intersection events."},{"signature":"static CurveIntersections CurveSurfaceValidate(Curve curve, Surface surface, double tolerance, double overlapTolerance, out int[] invalidIndices, out TextLog textLog)","summary":"Intersects a curve and a surface.","since":"7.0","parameters":[{"name":"curve","summary":"Curve for intersection."},{"name":"surface","summary":"Surface for intersection."},{"name":"tolerance","summary":"Intersection tolerance. If the curve approaches the surface to within tolerance, an intersection is assumed."},{"name":"overlapTolerance","summary":"The tolerance with which the curves are tested."},{"name":"invalidIndices","summary":"The indices in the resulting CurveIntersections collection that are invalid."},{"name":"textLog","summary":"A text log that contains tails about the invalid intersection events."}],"returns":"A collection of intersection events."},{"signature":"static bool LineBox(Line line, BoundingBox box, double tolerance, out Interval lineParameters)","summary":"Intersects an infinite line and an axis aligned bounding box.","since":"5.0","parameters":[{"name":"line","summary":"Line for intersection."},{"name":"box","summary":"BoundingBox to intersect."},{"name":"tolerance","summary":"If tolerance > 0.0, then the intersection is performed against a box that has each side moved out by tolerance."},{"name":"lineParameters","summary":"The chord from line.PointAt(lineParameters.T0) to line.PointAt(lineParameters.T1) is the intersection."}],"returns":"True if the line intersects the box, False if no intersection occurs."},{"signature":"static bool LineBox(Line line, Box box, double tolerance, out Interval lineParameters)","summary":"Intersects an infinite line with a box volume.","since":"5.0","parameters":[{"name":"line","summary":"Line for intersection."},{"name":"box","summary":"Box to intersect."},{"name":"tolerance","summary":"If tolerance > 0.0, then the intersection is performed against a box that has each side moved out by tolerance."},{"name":"lineParameters","summary":"The chord from line.PointAt(lineParameters.T0) to line.PointAt(lineParameters.T1) is the intersection."}],"returns":"True if the line intersects the box, False if no intersection occurs."},{"signature":"static LineCircleIntersection LineCircle(Line line, Circle circle, out double t1, out Point3d point1, out double t2, out Point3d point2)","summary":"Intersects a line with a circle using exact calculations.","since":"5.0","parameters":[{"name":"line","summary":"Line for intersection."},{"name":"circle","summary":"Circle for intersection."},{"name":"t1","summary":"Parameter on line for first intersection."},{"name":"point1","summary":"Point on circle closest to first intersection."},{"name":"t2","summary":"Parameter on line for second intersection."},{"name":"point2","summary":"Point on circle closest to second intersection."}],"returns":"If LineCircleIntersection.Singleis returned, only t1 and point1 will have valid values. If LineCircleIntersection.Multipleis returned, t2 and point2 will also be filled out."},{"signature":"static LineCylinderIntersection LineCylinder(Line line, Cylinder cylinder, out Point3d intersectionPoint1, out Point3d intersectionPoint2)","summary":"Intersects a line with a cylinder using exact calculations.","since":"5.0","parameters":[{"name":"line","summary":"Line for intersection."},{"name":"cylinder","summary":"Cylinder for intersection."},{"name":"intersectionPoint1","summary":"First intersection point."},{"name":"intersectionPoint2","summary":"Second intersection point."}],"returns":"If None is returned, the first point is the point on the line closest to the cylinder and the second point is the point on the cylinder closest to the line.  \\nIf  is returned, the first point is the point on the line and the second point is the  same point on the cylinder."},{"signature":"static bool LineLine(Line lineA, Line lineB, out double a, out double b)","summary":"Finds the closest point between two infinite lines.","since":"5.0","parameters":[{"name":"lineA","summary":"First line."},{"name":"lineB","summary":"Second line."},{"name":"a","summary":"Parameter on lineA that is closest to lineB. The shortest distance between the lines is the chord from lineA.PointAt(a) to lineB.PointAt(b)"},{"name":"b","summary":"Parameter on lineB that is closest to lineA. The shortest distance between the lines is the chord from lineA.PointAt(a) to lineB.PointAt(b)"}],"returns":"True if points are found and False if the lines are numerically parallel. Numerically parallel means the 2x2 matrix:  \\n+AoA  -AoB  \\n-AoB  +BoB is numerically singular, where A = (lineA.To - lineA.From) and B = (lineB.To-lineB.From)"},{"signature":"static bool LineLine(Line lineA, Line lineB, out double a, out double b, double tolerance, bool finiteSegments)","summary":"Intersects two lines.","since":"5.0","parameters":[{"name":"lineA","summary":"First line for intersection."},{"name":"lineB","summary":"Second line for intersection."},{"name":"a","summary":"Parameter on lineA that is closest to LineB. The shortest distance between the lines is the chord from lineA.PointAt(a) to lineB.PointAt(b)"},{"name":"b","summary":"Parameter on lineB that is closest to LineA. The shortest distance between the lines is the chord from lineA.PointAt(a) to lineB.PointAt(b)"},{"name":"tolerance","summary":"If tolerance > 0.0, then an intersection is reported only if the distance between the points is <= tolerance. If tolerance <= 0.0, then the closest point between the lines is reported."},{"name":"finiteSegments","summary":"If true, the input lines are treated as finite segments. If false, the input lines are treated as infinite lines."}],"returns":"True if a closest point can be calculated and the result passes the tolerance parameter test; otherwise false."},{"signature":"static bool LinePlane(Line line, Plane plane, out double lineParameter)","summary":"Intersects a line and a plane. This function only returns True if the intersection result is a single point (i.e. if the line is coincident with the plane then no intersection is assumed).","since":"5.0","parameters":[{"name":"line","summary":"Line for intersection."},{"name":"plane","summary":"Plane to intersect."},{"name":"lineParameter","summary":"Parameter on line where intersection occurs. If the parameter is not within the {0, 1} Interval then the finite segment does not intersect the plane."}],"returns":"True on success, False on failure."},{"signature":"static LineSphereIntersection LineSphere(Line line, Sphere sphere, out Point3d intersectionPoint1, out Point3d intersectionPoint2)","summary":"Intersects a line with a sphere using exact calculations.","since":"5.0","parameters":[{"name":"line","summary":"Line for intersection."},{"name":"sphere","summary":"Sphere for intersection."},{"name":"intersectionPoint1","summary":"First intersection point."},{"name":"intersectionPoint2","summary":"Second intersection point."}],"returns":"If LineSphereIntersection.Noneis returned, the first point is the point on the line closest to the sphere and the second point is the point on the sphere closest to the line. If LineSphereIntersection.Singleis returned, the first point is the point on the line and the second point is the same point on the sphere."},{"signature":"static Point3d[] MeshLine(Mesh mesh, Line line, out int[] faceIds)","summary":"Finds the intersections of a mesh and a line. The points are not necessarily sorted.","since":"5.0","parameters":[{"name":"mesh","summary":"A mesh to intersect"},{"name":"line","summary":"The line to intersect with the mesh"},{"name":"faceIds","summary":"The indices of the intersecting faces. This out reference is assigned during the call."}],"returns":"An array of points: one for each face that was passed by the faceIds out reference."},{"signature":"static Point3d[] MeshLineSorted(Mesh mesh, Line line, out int[] faceIds)","summary":"Finds the intersections of a mesh and a line. Points are sorted along the line.","since":"5.0","parameters":[{"name":"mesh","summary":"A mesh to intersect"},{"name":"line","summary":"The line to intersect with the mesh"},{"name":"faceIds","summary":"The indices of the intersecting faces. This out reference is assigned during the call."}],"returns":"An array of points: one for each face that was passed by the faceIds out reference."},{"signature":"static bool MeshMesh(IEnumerable<Mesh> meshes, double tolerance, out Polyline[] intersections, bool overlapsPolylines, out Polyline[] overlapsPolylinesResult, bool overlapsMesh, out Mesh overlapsMeshResult, TextLog textLog, CancellationToken cancel, IProgress<double> progress)","summary":"Intersects meshes. Overlaps and perforations are provided in the output list.","since":"7.0","parameters":[{"name":"meshes","summary":"The mesh input list. This cannot be null. Null entries are tolerated."},{"name":"tolerance","summary":"A tolerance value. If negative, the positive value will be used. WARNING! Good tolerance values are in the magnitude of 10^-7, or RhinoMath.SqrtEpsilon*10."},{"name":"intersections","summary":"Returns the intersections."},{"name":"overlapsPolylines","summary":"If true, overlaps are computed and returned."},{"name":"overlapsPolylinesResult","summary":"If requested, overlaps are returned here."},{"name":"overlapsMesh","summary":"If true, an overlaps mesh is computed and returned."},{"name":"overlapsMeshResult","summary":"If requested, overlaps are returned here."},{"name":"textLog","summary":"A text log, or null."},{"name":"cancel","summary":"A cancellation token to stop the computation at a given point."},{"name":"progress","summary":"A progress reporter to inform the user about progress, or null. The reported value is indicative."}],"returns":"True, if the operation succeeded, otherwise false."},{"signature":"static Polyline[] MeshMeshAccurate(Mesh meshA, Mesh meshB, double tolerance)","summary":"Intersects two meshes. Overlaps and near misses are handled. This is an old method kept for compatibility.","since":"5.0","parameters":[{"name":"meshA","summary":"First mesh for intersection."},{"name":"meshB","summary":"Second mesh for intersection."},{"name":"tolerance","summary":"A tolerance value. If negative, the positive value will be used. WARNING! Good tolerance values are in the magnitude of 10^-7, or RhinoMath.SqrtEpsilon*10."}],"returns":"An array of intersection and overlaps polylines."},{"signature":"static Line[] MeshMeshFast(Mesh meshA, Mesh meshB)","summary":"This is an old overload kept for compatibility. Overlaps and near misses are ignored.","since":"5.0","deprecated":"7.0","parameters":[{"name":"meshA","summary":"First mesh for intersection."},{"name":"meshB","summary":"Second mesh for intersection."}],"returns":"An array of intersection line segments, or None if no intersections were found."},{"signature":"static Polyline[] MeshPlane(Mesh mesh, IEnumerable<Plane> planes)","summary":"Intersects a mesh with a collection of (infinite) planes.","since":"5.0","parameters":[{"name":"mesh","summary":"Mesh to intersect."},{"name":"planes","summary":"Planes to intersect with."}],"returns":"An array of polylines describing the intersection loops or None (Nothing in Visual Basic) if no intersections could be found."},{"signature":"static Polyline[] MeshPlane(Mesh mesh, Plane plane)","summary":"Intersects a mesh with an (infinite) plane.","since":"5.0","parameters":[{"name":"mesh","summary":"Mesh to intersect."},{"name":"plane","summary":"Plane to intersect with."}],"returns":"An array of polylines describing the intersection loops or None (Nothing in Visual Basic) if no intersections could be found."},{"signature":"static Point3d[] MeshPolyline(Mesh mesh, PolylineCurve curve, out int[] faceIds)","summary":"Finds the intersection of a mesh and a polyline. Points are not guaranteed to be sorted along the polyline.","since":"5.0","parameters":[{"name":"mesh","summary":"A mesh to intersect."},{"name":"curve","summary":"A polyline curves to intersect."},{"name":"faceIds","summary":"The indices of the intersecting faces. This out reference is assigned during the call."}],"returns":"An array of points: one for each face that was passed by the faceIds out reference."},{"signature":"static Point3d[] MeshPolylineSorted(Mesh mesh, PolylineCurve curve, out int[] faceIds)","summary":"Finds the intersection of a mesh and a polyline. Points are guaranteed to be sorted along the polyline.","since":"5.0","parameters":[{"name":"mesh","summary":"A mesh to intersect."},{"name":"curve","summary":"A polyline curves to intersect."},{"name":"faceIds","summary":"The indices of the intersecting faces. This out reference is assigned during the call."}],"returns":"An array of points: one for each face that was passed by the faceIds out reference."},{"signature":"static double MeshRay(Mesh mesh, Ray3d ray)","summary":"Finds the first intersection of a ray with a mesh.","since":"5.0","parameters":[{"name":"mesh","summary":"A mesh to intersect."},{"name":"ray","summary":"A ray to be casted."}],"returns":">= 0.0 parameter along ray if successful. < 0.0 if no intersection found."},{"signature":"static double MeshRay(Mesh mesh, Ray3d ray, out int[] meshFaceIndices)","summary":"Finds the first intersection of a ray with a mesh.","since":"5.0","parameters":[{"name":"mesh","summary":"A mesh to intersect."},{"name":"ray","summary":"A ray to be casted."},{"name":"meshFaceIndices","summary":"faces on mesh that ray intersects."}],"returns":">= 0.0 parameter along ray if successful. < 0.0 if no intersection found."},{"signature":"static PlaneCircleIntersection PlaneCircle(Plane plane, Circle circle, out double firstCircleParameter, out double secondCircleParameter)","summary":"Intersects a plane with a circle using exact calculations.","since":"5.0","parameters":[{"name":"plane","summary":"Plane to intersect."},{"name":"circle","summary":"Circe to intersect."},{"name":"firstCircleParameter","summary":"First intersection parameter on circle if successful or RhinoMath.UnsetValue if not."},{"name":"secondCircleParameter","summary":"Second intersection parameter on circle if successful or RhinoMath.UnsetValue if not."}],"returns":"The type of intersection that occurred."},{"signature":"static bool PlanePlane(Plane planeA, Plane planeB, out Line intersectionLine)","summary":"Intersects two planes and return the intersection line. If the planes are parallel or coincident, no intersection is assumed.","since":"5.0","parameters":[{"name":"planeA","summary":"First plane for intersection."},{"name":"planeB","summary":"Second plane for intersection."},{"name":"intersectionLine","summary":"If this function returns true, the intersectionLine parameter will return the line where the planes intersect."}],"returns":"True on success, False on failure."},{"signature":"static bool PlanePlanePlane(Plane planeA, Plane planeB, Plane planeC, out Point3d intersectionPoint)","summary":"Intersects three planes to find the single point they all share.","since":"5.0","parameters":[{"name":"planeA","summary":"First plane for intersection."},{"name":"planeB","summary":"Second plane for intersection."},{"name":"planeC","summary":"Third plane for intersection."},{"name":"intersectionPoint","summary":"Point where all three planes converge."}],"returns":"True on success, False on failure. If at least two out of the three planes are parallel or coincident, failure is assumed."},{"signature":"static PlaneSphereIntersection PlaneSphere(Plane plane, Sphere sphere, out Circle intersectionCircle)","summary":"Intersects a plane with a sphere using exact calculations.","since":"5.0","parameters":[{"name":"plane","summary":"Plane to intersect."},{"name":"sphere","summary":"Sphere to intersect."},{"name":"intersectionCircle","summary":"Intersection result."}],"returns":"If PlaneSphereIntersection.Noneis returned, the intersectionCircle has a radius of zero and the center point is the point on the plane closest to the sphere."},{"signature":"static Point3d[] ProjectPointsToBreps(IEnumerable<Brep> breps, IEnumerable<Point3d> points, Vector3d direction, double tolerance)","summary":"Projects points onto breps.","since":"5.0","parameters":[{"name":"breps","summary":"The breps projection targets."},{"name":"points","summary":"The points to project."},{"name":"direction","summary":"The direction to project."},{"name":"tolerance","summary":"The tolerance used for intersections."}],"returns":"Array of projected points, or None in case of any error or invalid input."},{"signature":"static Point3d[] ProjectPointsToBrepsEx(IEnumerable<Brep> breps, IEnumerable<Point3d> points, Vector3d direction, double tolerance, out int[] indices)","summary":"Projects points onto breps.","since":"5.10","parameters":[{"name":"breps","summary":"The breps projection targets."},{"name":"points","summary":"The points to project."},{"name":"direction","summary":"The direction to project."},{"name":"tolerance","summary":"The tolerance used for intersections."},{"name":"indices","summary":"Return points[i] is a projection of points[indices[i]]"}],"returns":"Array of projected points, or None in case of any error or invalid input."},{"signature":"static Point3d[] ProjectPointsToMeshes(IEnumerable<Mesh> meshes, IEnumerable<Point3d> points, Vector3d direction, double tolerance)","summary":"Projects points onto meshes.","since":"5.0","parameters":[{"name":"meshes","summary":"the meshes to project on to."},{"name":"points","summary":"the points to project."},{"name":"direction","summary":"the direction to project."},{"name":"tolerance","summary":"Projection tolerances used for culling close points and for line-mesh intersection."}],"returns":"Array of projected points, or None in case of any error or invalid input."},{"signature":"static Point3d[] ProjectPointsToMeshesEx(IEnumerable<Mesh> meshes, IEnumerable<Point3d> points, Vector3d direction, double tolerance, out int[] indices)","summary":"Projects points onto meshes.","since":"5.10","parameters":[{"name":"meshes","summary":"the meshes to project on to."},{"name":"points","summary":"the points to project."},{"name":"direction","summary":"the direction to project."},{"name":"tolerance","summary":"Projection tolerances used for culling close points and for line-mesh intersection."},{"name":"indices","summary":"Return points[i] is a projection of points[indices[i]]"}],"returns":"Array of projected points, or None in case of any error or invalid input."},{"signature":"static RayShootEvent[] RayShoot(IEnumerable<GeometryBase> geometry, Ray3d ray, int maxReflections)","summary":"Computes point intersections that occur when shooting a ray to a collection of surfaces and Breps.","since":"7.0","parameters":[{"name":"geometry","summary":"The collection of surfaces and Breps to intersect. Trims are ignored on Breps."},{"name":"ray","summary":">A ray used in intersection."},{"name":"maxReflections","summary":"The maximum number of reflections. This value should be any value between 1 and 1000, inclusive."}],"returns":"An array of RayShootEvent structs if successful, or an empty array on failure."},{"signature":"static Point3d[] RayShoot(Ray3d ray, IEnumerable<GeometryBase> geometry, int maxReflections)","summary":"Computes point intersections that occur when shooting a ray to a collection of surfaces and Breps.","since":"5.0","parameters":[{"name":"ray","summary":"A ray used in intersection."},{"name":"geometry","summary":"Only Surface and Brep objects are currently supported. Trims are ignored on Breps."},{"name":"maxReflections","summary":"The maximum number of reflections. This value should be any value between 1 and 1000, inclusive."}],"returns":"An array of points: one for each surface or Brep face that was hit, or an empty array on failure."},{"signature":"static SphereSphereIntersection SphereSphere(Sphere sphereA, Sphere sphereB, out Circle intersectionCircle)","summary":"Intersects two spheres using exact calculations.","since":"5.0","parameters":[{"name":"sphereA","summary":"First sphere to intersect."},{"name":"sphereB","summary":"Second sphere to intersect."},{"name":"intersectionCircle","summary":"If intersection is a point, then that point will be the center, radius 0."}],"returns":"The intersection type."},{"signature":"static bool SurfaceSurface(Surface surfaceA, Surface surfaceB, double tolerance, out Curve[] intersectionCurves, out Point3d[] intersectionPoints)","summary":"Intersects two Surfaces.","since":"5.0","parameters":[{"name":"surfaceA","summary":"First Surface for intersection."},{"name":"surfaceB","summary":"Second Surface for intersection."},{"name":"tolerance","summary":"Intersection tolerance."},{"name":"intersectionCurves","summary":"The intersection curves will be returned here."},{"name":"intersectionPoints","summary":"The intersection points will be returned here."}],"returns":"True on success, False on failure."}]},{"namespace":"Rhino.Geometry.Intersect","name":"IntersectionEvent","dataType":"class","summary":"Provides all the information for a single Curve Intersection event.","properties":[{"signature":"bool IsOverlap","summary":"All curve intersection events are either a single point or an overlap.","since":"5.0","property":["get"]},{"signature":"bool IsPoint","summary":"All curve intersection events are either a single point or an overlap.","since":"5.0","property":["get"]},{"signature":"Interval OverlapA","summary":"Gets the interval on curve A where the overlap occurs. If the intersection type is not overlap, this value is meaningless.","since":"5.0","property":["get"]},{"signature":"Interval OverlapB","summary":"Gets the interval on curve B where the overlap occurs. If the intersection type is not overlap, this value is meaningless.","since":"5.0","property":["get"]},{"signature":"double ParameterA","summary":"Gets the parameter on Curve A where the intersection occurred. If the intersection type is overlap, then this will return the start of the overlap region.","since":"5.0","property":["get"]},{"signature":"double ParameterB","summary":"Gets the parameter on Curve B where the intersection occurred. If the intersection type is overlap, then this will return the start of the overlap region.","since":"5.0","property":["get"]},{"signature":"Point3d PointA","summary":"Gets the point on Curve A where the intersection occurred. If the intersection type is overlap, then this will return the start of the overlap region.","since":"5.0","property":["get"]},{"signature":"Point3d PointA2","summary":"Gets the end point of the overlap on Curve A. If the intersection type is not overlap, this value is meaningless.","since":"5.0","property":["get"]},{"signature":"Point3d PointB","summary":"Gets the point on Curve B (or Surface B) where the intersection occurred. If the intersection type is overlap, then this will return the start of the overlap region.","since":"5.0","property":["get"]},{"signature":"Point3d PointB2","summary":"Gets the end point of the overlap on Curve B (or Surface B). If the intersection type is not overlap, this value is meaningless.","since":"5.0","property":["get"]}],"methods":[{"signature":"static bool CompareEquivalent(IntersectionEvent eventA, IntersectionEvent eventB, double relativePointTolerance)","summary":"Compare intersection events.","since":"7.0","parameters":[{"name":"eventA","summary":"The first intersection event to compare."},{"name":"eventB","summary":"The second intersection event to compare."},{"name":"relativePointTolerance","summary":"The comparison tolerance. If RhinoMath.UnsetValue, then RhinoMath.SqrtEpsilon is used."}],"returns":"True if the two inputs represent the same intersection, False otherwise."},{"signature":"static bool CompareEquivalent(IntersectionEvent eventA, IntersectionEvent eventB, double relativePointTolerance, TextLog log)","summary":"Compare intersection events.","since":"7.0","parameters":[{"name":"eventA","summary":"The first intersection event to compare."},{"name":"eventB","summary":"The second intersection event to compare."},{"name":"relativePointTolerance","summary":"The comparison tolerance. If RhinoMath.UnsetValue, then RhinoMath.SqrtEpsilon is used."},{"name":"log","summary":"If not None and False is returned, then a description of the error is appended to log."}]},{"signature":"void SurfaceOverlapParameter(out Interval uDomain, out Interval vDomain)","summary":"If this instance records a Curve|Surface intersection event, andthe intersection type ifoverlap, then use this function to get the U and V domains on the surface where the overlap occurs.","since":"5.0","parameters":[{"name":"uDomain","summary":"Domain along surface U direction for overlap event."},{"name":"vDomain","summary":"Domain along surface V direction for overlap event."}]},{"signature":"void SurfacePointParameter(out double u, out double v)","summary":"If this instance records a Curve|Surface intersection event, andthe intersection type ispoint, then use this function to get the U and V parameters on the surface where the intersection occurs.","since":"5.0","parameters":[{"name":"u","summary":"Parameter on surface u direction where the intersection occurs."},{"name":"v","summary":"Parameter on surface v direction where the intersection occurs."}]}]},{"namespace":"Rhino.Geometry.Intersect","name":"LineCircleIntersection","dataType":"enum","summary":"Represents all possible cases of a Line|Circle intersection event.","since":"5.0","values":[{"signature":"None = 0","summary":"No intersections."},{"signature":"Single = 1","summary":"One intersection."},{"signature":"Multiple = 2","summary":"Two intersections."}]},{"namespace":"Rhino.Geometry.Intersect","name":"LineCylinderIntersection","dataType":"enum","summary":"Represents all possible cases of a Line|Cylinder intersection event.","since":"5.0","values":[{"signature":"None = 0","summary":"No intersections."},{"signature":"Single = 1","summary":"One intersection."},{"signature":"Multiple = 2","summary":"Two intersections."},{"signature":"Overlap = 3","summary":"Line lies on cylinder."}]},{"namespace":"Rhino.Geometry.Intersect","name":"LineSphereIntersection","dataType":"enum","summary":"Represents all possible cases of a Line|Sphere intersection event.","since":"5.0","values":[{"signature":"None = 0","summary":"No intersections."},{"signature":"Single = 1","summary":"One intersection."},{"signature":"Multiple = 2","summary":"Two intersections."}]},{"namespace":"Rhino.Geometry.Intersect","name":"MeshClash","dataType":"class","summary":"Represents a particular instance of a clash or intersection between two meshes.","properties":[{"signature":"Point3d ClashPoint","summary":"If valid, then the sphere centered at ClashPoint of ClashRadius distance intersects the clashing meshes.","since":"5.0","property":["get"]},{"signature":"double ClashRadius","summary":"Gets the clash, or intersection, radius.","since":"5.0","property":["get"]},{"signature":"Mesh MeshA","summary":"Gets the first mesh.","since":"5.0","property":["get"]},{"signature":"Mesh MeshB","summary":"Gets the second mesh.","since":"5.0","property":["get"]}],"methods":[{"signature":"static Mesh[] FindDetail(RhinoObject objA, RhinoObject objB, double distance)","summary":"Finds all of the mesh faces on each of two Rhino objects that interfere within a clash distance. This function uses the object\'s mesh to calculate the interferences. Acceptable object types include: BrepObject, ExtrusionObject, MeshObject, and SubDObject.","since":"7.0","parameters":[{"name":"objA","summary":"The first Rhino object."},{"name":"objB","summary":"The second Rhino object."},{"name":"distance","summary":"The largest distance at which a clash can occur."}],"returns":"The resulting meshes are sub-meshes of the input meshes if successful, or an empty array on error."},{"signature":"static Mesh[] FindDetail(RhinoObject objA, RhinoObject objB, double distance, MeshType meshType, MeshingParameters meshingParameters)","summary":"Finds all of the mesh faces on each of two Rhino objects that interfere within a clash distance. This function uses the object\'s mesh to calculate the interferences. Acceptable object types include: BrepObject, ExtrusionObject, MeshObject, and SubDObject.","since":"7.0","parameters":[{"name":"objA","summary":"The first Rhino object."},{"name":"objB","summary":"The second Rhino object."},{"name":"distance","summary":"The largest distance at which a clash can occur."},{"name":"meshType","summary":"The type of mesh to be used for the calculation."},{"name":"meshingParameters","summary":"The meshing parameters used to generate meshes for the calculation."}],"returns":"The resulting meshes are sub-meshes of the input meshes if successful, or an empty array on error."},{"signature":"static MeshClash[] Search(IEnumerable<Mesh> setA, IEnumerable<Mesh> setB, double distance, int maxEventCount)","summary":"Searches for locations where the distance froma mesh in one setof meshes is less than distance toanother mesh in a second setof meshes.","since":"5.0","parameters":[{"name":"setA","summary":"The first set of meshes."},{"name":"setB","summary":"The second set of meshes."},{"name":"distance","summary":"The largest distance at which there is a clash. All values smaller than this cause a clash as well."},{"name":"maxEventCount","summary":"The maximum number of clash objects."}],"returns":"An array of clash objects."},{"signature":"static MeshInterference[] Search(IEnumerable<RhinoObject> setA, IEnumerable<RhinoObject> setB, double distance)","summary":"Searches for locations where the distance from a RhinoObject, in one set of objects, is less than the specified distance to another RhinoObject in a second set of objects. This function uses the object\'s mesh to calculate the interferences. Acceptable object types include: BrepObject, ExtrusionObject, MeshObject, and SubDObject.","since":"7.0","parameters":[{"name":"setA","summary":"The first set of Rhino objects."},{"name":"setB","summary":"The second set of Rhino objects."},{"name":"distance","summary":"The largest distance at which a clash can occur."}],"returns":"An array of mesh interference object if successful, or an empty array on failure."},{"signature":"static MeshInterference[] Search(IEnumerable<RhinoObject> setA, IEnumerable<RhinoObject> setB, double distance, MeshType meshType, MeshingParameters meshingParameters)","summary":"Searches for locations where the distance from a RhinoObject, in one set of objects, is less than the specified distance to another RhinoObject in a second set of objects. This function uses the object\'s mesh to calculate the interferences. Acceptable object types include: BrepObject, ExtrusionObject, MeshObject, and SubDObject.","since":"7.0","parameters":[{"name":"setA","summary":"The first set of Rhino objects."},{"name":"setB","summary":"The second set of Rhino objects."},{"name":"distance","summary":"The largest distance at which a clash can occur."},{"name":"meshType","summary":"The type of mesh to be used for the calculation."},{"name":"meshingParameters","summary":"The meshing parameters used to generate meshes for the calculation."}],"returns":"An array of mesh interference object if successful, or an empty array on failure."},{"signature":"static MeshClash[] Search(Mesh meshA, IEnumerable<Mesh> setB, double distance, int maxEventCount)","summary":"Searches the locations where the distance fromthe first meshtoa mesh in the second setof meshes is less than the provided value.","since":"5.0","parameters":[{"name":"meshA","summary":"The first mesh."},{"name":"setB","summary":"The second set of meshes."},{"name":"distance","summary":"The largest distance at which there is a clash. All values smaller than this cause a clash as well."},{"name":"maxEventCount","summary":"The maximum number of clash objects."}],"returns":"An array of clash objects."},{"signature":"static MeshClash[] Search(Mesh meshA, Mesh meshB, double distance, int maxEventCount)","summary":"Searches the locations where the distance fromthe first meshtothe second mesh is less than the provided value.","since":"5.0","parameters":[{"name":"meshA","summary":"The first mesh."},{"name":"meshB","summary":"The second mesh."},{"name":"distance","summary":"The largest distance at which there is a clash. All values smaller than this cause a clash as well."},{"name":"maxEventCount","summary":"The maximum number of clash objects."}],"returns":"An array of clash objects."}]},{"namespace":"Rhino.Geometry.Intersect","name":"MeshInterference","dataType":"struct","summary":"Represents an element which is part of a clash or intersection between two meshes.","properties":[{"signature":"Point3d[] HitPoints","summary":"Array of hit points where the objects of IndexA and IndexB interfere.","since":"7.0","property":["get","set"]},{"signature":"int IndexA","summary":"The index of the first clashing, or interfering object.","since":"7.0","property":["get","set"]},{"signature":"int IndexB","summary":"The index of the second clashing, or interfering object.","since":"7.0","property":["get","set"]}]},{"namespace":"Rhino.Geometry.Intersect","name":"PlaneCircleIntersection","dataType":"enum","summary":"Represents all possible cases of a Plane|Circle intersection event.","since":"5.0","values":[{"signature":"None = 0","summary":"No intersections. Either because radius is too small or because circle plane is parallel but not coincident with the intersection plane."},{"signature":"Tangent = 1","summary":"Tangent (one point) intersection."},{"signature":"Secant = 2","summary":"Secant (two point) intersection."},{"signature":"Parallel = 3","summary":"Circle and plane are planar but not coincident. Parallel indicates no intersection took place."},{"signature":"Coincident = 4","summary":"Circle and plane are co-planar, they intersect everywhere."}]},{"namespace":"Rhino.Geometry.Intersect","name":"PlaneSphereIntersection","dataType":"enum","summary":"Represents all possible cases of a Plane|Sphere intersection event.","since":"5.0","values":[{"signature":"None = 0","summary":"No intersections."},{"signature":"Point = 1","summary":"Tangent intersection."},{"signature":"Circle = 2","summary":"Circular intersection."}]},{"namespace":"Rhino.Geometry.Intersect","name":"RayShootEvent","dataType":"struct","summary":"Represents an element which is part of a ray shoot.","since":"7.0","properties":[{"signature":"int BrepFaceIndex","summary":"If GeometryIndex references a Brep, then the index of the Brep face that was hit. If GeometryIndex references a surface, than RhinoMath.UnsetIntIndex.","since":"7.0","property":["get","set"]},{"signature":"int GeometryIndex","summary":"The index of the surface or Brep that was hit.","since":"7.0","property":["get","set"]},{"signature":"Point3d Point","summary":"The 3d hit point.","since":"7.0","property":["get","set"]}]},{"namespace":"Rhino.Geometry.Intersect","name":"SphereSphereIntersection","dataType":"enum","summary":"Represents all possible cases of a Sphere|Sphere intersection event.","since":"5.0","values":[{"signature":"None = 0","summary":"Spheres do not intersect."},{"signature":"Point = 1","summary":"Spheres touch at a single point."},{"signature":"Circle = 2","summary":"Spheres intersect at a circle."},{"signature":"Overlap = 3","summary":"Spheres are identical."}]},{"namespace":"Rhino.Geometry","name":"Interval","dataType":"struct","summary":"Represents an interval in one-dimensional space, that is defined as two extrema or bounds.","constructors":[{"signature":"Interval(double t0, double t1)","summary":"Initializes a new instance of the Rhino.Geometry.Interval class.","since":"5.0","parameters":[{"name":"t0","summary":"The first value."},{"name":"t1","summary":"The second value."}]},{"signature":"Interval(Interval other)","summary":"Initializes a new instance copying the other instance values.","since":"5.0","parameters":[{"name":"other","summary":"The Rhino.Geometry.Interval to use as a base."}]}],"properties":[{"signature":"static Interval Unset","summary":"Gets an Interval whose limits are RhinoMath.UnsetValue.","since":"5.0","property":["get"]},{"signature":"bool IsDecreasing","summary":"Returns True if T[0] > T[1].","since":"5.0","property":["get"]},{"signature":"bool IsIncreasing","summary":"Returns True if T0 < T1.","since":"5.0","property":["get"]},{"signature":"bool IsSingleton","summary":"Returns True if T0 == T1 != ON.UnsetValue.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Gets a value indicating whether or not this Interval is valid. Valid intervals must contain valid numbers.","since":"5.0","property":["get"]},{"signature":"double Length","summary":"Gets the signed length of the numeric range. If the interval is decreasing, a negative length will be returned.","since":"5.0","property":["get"]},{"signature":"double Max","summary":"Gets the larger of T0 and T1.","since":"5.0","property":["get"]},{"signature":"double Mid","summary":"Gets the average of T0 and T1.","since":"5.0","property":["get"]},{"signature":"double Min","summary":"Gets the smaller of T0 and T1.","since":"5.0","property":["get"]},{"signature":"double T0","summary":"Gets or sets the lower bound of the Interval.","since":"5.0","property":["get","set"]},{"signature":"double T1","summary":"Gets or sets the upper bound of the Interval.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static Interval FromIntersection(Interval a, Interval b)","summary":"Returns a new Interval that is the Intersection of the two input Intervals.","since":"5.0","parameters":[{"name":"a","summary":"The first input interval."},{"name":"b","summary":"The second input interval."}],"returns":"If the intersection is not empty, then intersection = [max(a.Min(),b.Min()), min(a.Max(),b.Max())] The interval [ON.UnsetValue,ON.UnsetValue] is considered to be the empty set interval.  The result of any intersection involving an empty set interval or disjoint intervals is the empty set interval."},{"signature":"static Interval FromUnion(Interval a, Interval b)","summary":"Returns a new Interval which contains both inputs.","since":"5.0","parameters":[{"name":"a","summary":"The first input interval."},{"name":"b","summary":"The second input interval."}],"returns":"The union of an empty set and an increasing interval is the increasing interval.  \\nThe union of two empty sets is empty.  \\nThe union of an empty set an a non-empty interval is the non-empty interval.  \\nThe union of two non-empty intervals is [min(a.Min(),b.Min()), max(a.Max(),b.Max())]"},{"signature":"int CompareTo(Interval other)","summary":"Compares this Intervalwith another interval.  \\nThe lower bound has first evaluation priority.","since":"5.0","parameters":[{"name":"other","summary":"The other Intervalto compare with."}],"returns":"0: if this is identical to other  \\n-1: if this[0] < other[0]  \\n+1: if this[0] > other[0]  \\n-1: if this[0] == other[0] and this[1] < other[1]  \\n+1: if this[0] == other[0] and this[1] > other[1]."},{"signature":"bool EpsilonEquals(Interval other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(Interval other)","summary":"Determines whether the specified Intervalis equal to the current Interval, comparing by value.","since":"5.0","parameters":[{"name":"other","summary":"The other interval to compare with."}],"returns":"True if obj is an Intervaland has the same bounds; False otherwise."},{"signature":"bool Equals(object obj)","summary":"Determines whether the specified objectis equal to the current Interval, comparing by value.","parameters":[{"name":"obj","summary":"The other object to compare with."}],"returns":"True if obj is an Intervaland has the same bounds; False otherwise."},{"signature":"int GetHashCode()","summary":"Computes the hash code for this Intervalobject.","returns":"A hash value that might be equal for two different Intervalvalues."},{"signature":"void Grow(double value)","summary":"Grows the Intervalto include the given number.","since":"5.0","parameters":[{"name":"value","summary":"Number to include in this interval."}]},{"signature":"bool IncludesInterval(Interval interval)","summary":"Tests another interval for Interval inclusion.","since":"5.0","parameters":[{"name":"interval","summary":"Interval to test."}],"returns":"True if the other interval is contained within or is coincident with the limits of this Interval; otherwise false."},{"signature":"bool IncludesInterval(Interval interval, bool strict)","summary":"Tests another interval for Interval inclusion.","since":"5.0","parameters":[{"name":"interval","summary":"Interval to test."},{"name":"strict","summary":"If true, the other interval must be fully on the inside of the Interval."}],"returns":"True if the other interval is contained within the limits of this Interval; otherwise false."},{"signature":"bool IncludesParameter(double t)","summary":"Tests a parameter for Interval inclusion.","since":"5.0","parameters":[{"name":"t","summary":"Parameter to test."}],"returns":"True if t is contained within or is coincident with the limits of this Interval."},{"signature":"bool IncludesParameter(double t, bool strict)","summary":"Tests a parameter for Interval inclusion.","since":"5.0","parameters":[{"name":"t","summary":"Parameter to test."},{"name":"strict","summary":"If true, the parameter must be fully on the inside of the Interval."}],"returns":"True if t is contained within the limits of this Interval."},{"signature":"void MakeIncreasing()","summary":"Ensures this Intervalis either singleton or increasing.","since":"5.0"},{"signature":"Interval NormalizedIntervalAt(Interval intervalParameter)","summary":"Converts interval value, or pair of values, to normalized parameter.","since":"5.0","returns":"Normalized parameter x so that min*(1.0-x) + max*x = intervalParameter."},{"signature":"double NormalizedParameterAt(double intervalParameter)","summary":"Converts interval value, or pair of values, to normalized parameter.","since":"5.0","returns":"Normalized parameter x so that min*(1.0-x) + max*x = intervalParameter."},{"signature":"double ParameterAt(double normalizedParameter)","summary":"Converts normalized parameter to interval value, or pair of values.","since":"5.0","returns":"Interval parameter min*(1.0-normalizedParameter) + max*normalizedParameter."},{"signature":"Interval ParameterIntervalAt(Interval normalizedInterval)","summary":"Converts normalized parameter to interval value, or pair of values.","since":"5.0","returns":"Interval parameter min*(1.0-normalizedParameter) + max*normalized_paramete."},{"signature":"void Reverse()","summary":"Changes interval to [-T1, -T0].","since":"5.0"},{"signature":"void Swap()","summary":"Exchanges T0 and T1.","since":"5.0"},{"signature":"string ToString()","summary":"Returns a string representation of this Interval.","returns":"A string with T0,T1."}]},{"namespace":"Rhino.Geometry","name":"InvalidDimensionStyleIdException","dataType":"class","summary":"General exception that can be thrown by annotations","baseclass":"InvalidOperationException","constructors":[{"signature":"InvalidDimensionStyleIdException(string msg)","since":"6.0"}]},{"namespace":"Rhino.Geometry","name":"IsoStatus","dataType":"enum","summary":"Defines enumerated values for isoparametric curve direction on a surface, such as X or Y, and curve sides, such as North or West boundary.  \\nNote: odd values are all x-constant; even values > 0 are all y-constant.","since":"5.0","values":[{"signature":"None = 0","summary":"curve is not an isoparametric curve."},{"signature":"X = 1","summary":"curve is a \\"x\\" = constant (vertical) isoparametric curve in the interior of the surface\'s domain."},{"signature":"Y = 2","summary":"curve is a \\"y\\" = constant (horizontal) isoparametric curve in the interior of the surface\'s domain."},{"signature":"West = 3","summary":"curve is a \\"x\\" = constant isoparametric curve along the west side of the surface\'s domain."},{"signature":"South = 4","summary":"curve is a \\"y\\" = constant isoparametric curve along the south side of the surface\'s domain."},{"signature":"East = 5","summary":"curve is a \\"x\\" = constant isoparametric curve along the east side of the surface\'s domain."},{"signature":"North = 6","summary":"curve is a \\"y\\" = constant isoparametric curve along the north side of the surface\'s domain."}]},{"namespace":"Rhino.Geometry","name":"KnotStyle","dataType":"enum","summary":"Knot styles for NURBS curves and surfaces. If a knot vector meets the conditions of two styles, then the style with the lowest value is used.","since":"7.0","values":[{"signature":"Unknown = 0","summary":"Unknown knot style"},{"signature":"Uniform = 1","summary":"Uniform knots (ends not clamped)."},{"signature":"QuasiUniform = 2","summary":"Uniform knots (clamped ends, degree >= 2)."},{"signature":"PiecewiseBezier= 3","summary":"All internal knots have full multiplicity."},{"signature":"ClampedEnd = 4","summary":"Clamped end knots (with at least one interior non-uniform knot)."},{"signature":"NonUniform = 5","summary":"Known to be none of the other styles"}]},{"namespace":"Rhino.Geometry","name":"Leader","dataType":"class","summary":"Leader geometry class","baseclass":"Rhino.Geometry.AnnotationBase","constructors":[{"signature":"Leader()","summary":"Constructor","since":"6.0"}],"properties":[{"signature":"NurbsCurve Curve","summary":"Gets the curve used by this leader","since":"6.0","property":["get"]},{"signature":"Guid LeaderArrowBlockId","summary":"Id of the block used as the arrow for the leader when the arrow type is \'User arrow\'","since":"6.0","property":["get","set"]},{"signature":"double LeaderArrowSize","summary":"The size of the leader arrow","since":"6.0","property":["get","set"]},{"signature":"ArrowType LeaderArrowType","summary":"The arrowhead type for the leader","since":"6.0","property":["get","set"]},{"signature":"LeaderContentAngleStyle LeaderContentAngleStyle","summary":"Angle for text of leader text","since":"6.0","property":["get","set"]},{"signature":"LeaderCurveStyle LeaderCurveStyle","summary":"The style of the leader curve: polyline or spline","since":"6.0","property":["get","set"]},{"signature":"bool LeaderHasLanding","summary":"Returns True if the leader has a landing line","since":"6.0","property":["get","set"]},{"signature":"double LeaderLandingLength","summary":"Gets or sets the length of the landing line","since":"6.0","property":["get","set"]},{"signature":"TextHorizontalAlignment LeaderTextHorizontalAlignment","summary":"Gets or sets the horizontal alignment of the leader\'s text","since":"6.0","property":["get","set"]},{"signature":"TextVerticalAlignment LeaderTextVerticalAlignment","summary":"Gets or sets the vertical alignment of the leader\'s text","since":"6.0","property":["get","set"]},{"signature":"Point2d[] Points2D","summary":"Get or set the 2d points defining the curve used by this leader","since":"6.0","property":["get","set"]},{"signature":"Point3d[] Points3D","summary":"Get or set the 3d points defining the curve used by this leader","since":"6.0","property":["get","set"]}],"methods":[{"signature":"static Leader Create(string text, Plane plane, DimensionStyle dimstyle, Point3d[] points)","summary":"Creates a Leader geometry object","since":"6.0"},{"signature":"static Leader CreateWithRichText(string richText, Plane plane, DimensionStyle dimstyle, Point3d[] points)","summary":"Creates a Leader geometry object","since":"6.0"}]},{"namespace":"Rhino.Geometry","name":"Light","dataType":"class","summary":"Represents a light that shines in the modeling space.","baseclass":"Rhino.Geometry.GeometryBase","constructors":[{"signature":"Light()","summary":"Initializes a new light.","since":"5.0"}],"properties":[{"signature":"Color Ambient","summary":"Gets or sets the ambient color.","since":"5.0","property":["get","set"]},{"signature":"Attenuation AttenuationType","summary":"Get the type of attenuation for this light.","since":"7.0","property":["get","set"]},{"signature":"Vector3d AttenuationVector","summary":"Gets or Sets the attenuation vector.","since":"5.7","property":["get","set"]},{"signature":"CoordinateSystem CoordinateSystem","summary":"Gets a value, determined by LightStyle, that explains whether the camera directions are relative to World or Camera spaces.","since":"5.0","property":["get"]},{"signature":"Color Diffuse","summary":"Gets or sets the diffuse color.","since":"5.0","property":["get","set"]},{"signature":"Vector3d Direction","summary":"Gets or sets the vector direction of the camera.","since":"5.0","property":["get","set"]},{"signature":"double HotSpot","summary":"The hot spot setting runs from 0.0 to 1.0 and is used to provides a linear interface for controlling the focus or concentration of a spotlight. A hot spot setting of 0.0 corresponds to a spot exponent of 128. A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.","since":"5.0","property":["get","set"]},{"signature":"Guid Id","summary":"Gets the ID of this light.","since":"6.0","property":["get","set"]},{"signature":"double Intensity","summary":"Gets or sets the light intensity.","since":"5.0","property":["get","set"]},{"signature":"bool IsDirectionalLight","summary":"Gets a value indicating whether the light style is LightStyleCameraDirectional or WorldDirectional.","since":"5.0","property":["get"]},{"signature":"bool IsEnabled","summary":"Gets or sets a value that defines if the light is turned on (true) or off (false).","since":"5.0","property":["get","set"]},{"signature":"bool IsLinearLight","summary":"Gets a value indicating whether the light style is LightStyleWorldLinear.","since":"5.0","property":["get"]},{"signature":"bool IsPointLight","summary":"Gets a value indicating whether the light style is LightStyleCameraPoint or WorldPoint.","since":"5.0","property":["get"]},{"signature":"bool IsRectangularLight","summary":"Gets a value indicating whether the light style is LightStyleWorldRectangular.","since":"5.0","property":["get"]},{"signature":"bool IsSpotLight","summary":"Gets a value indicating whether the light style is LightStyleCameraSpot or WorldSpot.","since":"5.0","property":["get"]},{"signature":"bool IsSunLight","summary":"Gets a value indicating whether this object is a Sun light.","since":"5.0","property":["get"]},{"signature":"Vector3d Length","summary":"Gets or sets the height in linear and rectangular lights.  \\n(ignored for non-linear/rectangular lights.)","since":"5.0","property":["get","set"]},{"signature":"LightStyle LightStyle","summary":"Gets or sets a light style on this camera.","since":"5.0","property":["get","set"]},{"signature":"Point3d Location","summary":"Gets or sets the light or 3D position or location.","since":"5.0","property":["get","set"]},{"signature":"string Name","summary":"Gets or sets the spot light name.","since":"5.0","property":["get","set"]},{"signature":"Vector3d PerpendicularDirection","summary":"Gets a perpendicular vector to the camera direction.","since":"5.0","property":["get"]},{"signature":"double PowerCandela","summary":"Gets or sets the light power in candelas (cd).","since":"5.0","property":["get","set"]},{"signature":"double PowerLumens","summary":"Gets or sets the light power in lumens (lm).","since":"5.0","property":["get","set"]},{"signature":"double PowerWatts","summary":"Gets or sets the light power in watts (W).","since":"5.0","property":["get","set"]},{"signature":"double ShadowIntensity","summary":"Gets or sets the shadow intensity for the light.","since":"6.0","property":["get","set"]},{"signature":"Color Specular","summary":"Gets or sets the specular color.","since":"5.0","property":["get","set"]},{"signature":"double SpotAngleRadians","summary":"Gets or sets the spot angle in radians.  \\nIgnored for non-spot lights.  \\nangle = 0 to pi/2  (0 to 90 degrees).","since":"5.0","property":["get","set"]},{"signature":"double SpotExponent","summary":"The spot exponent varies from 0.0 to 128.0 and provides an exponential interface for controlling the focus or concentration of a spotlight (like the OpenGL GL_SPOT_EXPONENT parameter).  The spot exponent and hot spot parameters are linked; changing one will change the other. A hot spot setting of 0.0 corresponds to a spot exponent of 128. A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.","since":"5.0","property":["get","set"]},{"signature":"double SpotLightShadowIntensity","summary":"Gets or sets the spot light shadow intensity.  \\n(ignored for non-spot lights.)","since":"5.0","property":["get","set"]},{"signature":"Vector3d Width","summary":"Gets or sets the width in linear and rectangular lights.  \\n(ignored for non-linear/rectangular lights.)","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static Light CreateSunLight(double northAngleDegrees, DateTime when, double latitudeDegrees, double longitudeDegrees)","summary":"Constructs a light which simulates the Sun based on a given time and location on Earth.","since":"5.0","parameters":[{"name":"northAngleDegrees","summary":"The angle of North in degrees. North is the angle between positive World Y axis and model North, as measured on World XY plane."},{"name":"when","summary":"The time of the measurement. The Kind property of DateTime specifies whether this is in local or universal time.  \\nLocal and Undefined daytime kinds in this argument are considered local."},{"name":"latitudeDegrees","summary":"The latitude, in degrees, of the location on Earth."},{"name":"longitudeDegrees","summary":"The longitude, in degrees, of the location on Earth."}],"returns":"A newly constructed light object."},{"signature":"static Light CreateSunLight(double northAngleDegrees, double azimuthDegrees, double altitudeDegrees)","summary":"Constructs a light that represents the Sun.","since":"5.0","parameters":[{"name":"northAngleDegrees","summary":"The angle of North in degrees. North is the angle between positive World Y axis and model North, as measured on World XY plane."},{"name":"azimuthDegrees","summary":"The Azimuth angle value in degrees. Azimuth is the compass angle from North."},{"name":"altitudeDegrees","summary":"The Altitude angle in degrees. Altitude is the angle above the ground plane."}],"returns":"A new sun light."},{"signature":"static Light CreateSunLight(Sun sun)","summary":"Constructs a light which simulates a Rhino.Render.Sun.","since":"5.0","parameters":[{"name":"sun","summary":"A Sun object from the Rhino.Render namespace."}],"returns":"A light."},{"signature":"double GetAttenuation(double d)","summary":"Gets the attenuation settings (ignored for \\"directional\\" and \\"ambient\\" lights).  \\nattenuation = 1/(a0 + d*a1 + d^2*a2) where d = distance to light.","since":"5.0","parameters":[{"name":"d","summary":"The distance to evaluate."}],"returns":"0 if a0 + d*a1 + d^2*a2 <= 0."},{"signature":"bool GetSpotLightRadii(out double innerRadius, out double outerRadius)","summary":"Gets the spot light radii.","since":"5.0","parameters":[{"name":"innerRadius","summary":"The inner radius. This out parameter is assigned during this call."},{"name":"outerRadius","summary":"The outer radius. This out parameter is assigned during this call."}],"returns":"True if operation succeeded; otherwise, false."},{"signature":"void SetAttenuation(double a0, double a1, double a2)","summary":"Sets the attenuation settings (ignored for \\"directional\\" and \\"ambient\\" lights).  \\nattenuation = 1/(a0 + d*a1 + d^2*a2) where d = distance to light.","since":"5.0","parameters":[{"name":"a0","summary":"The new constant attenuation divisor term."},{"name":"a1","summary":"The new reverse linear attenuation divisor term."},{"name":"a2","summary":"The new reverse quadratic attenuation divisor term."}]}]},{"namespace":"Rhino.Geometry","name":"Light.Attenuation","dataType":"enum","summary":"Types of light attenuation available.","since":"7.0","values":[{"signature":"Constant","summary":"Constant light attenuation, meaning no light energy fall-off."},{"signature":"Linear","summary":"Linear light attenuation, meaning linear light energy fall-off."},{"signature":"InverseSquared","summary":"Inverse squared light attenuation, meaning light energy falls off in spherical order."}]},{"namespace":"Rhino.Geometry","name":"LightStyle","dataType":"enum","summary":"Defines enumerated values to represent light styles or types, such as directional or spotlight.","since":"5.0","values":[{"signature":"None = 0","summary":"No light type. This is the default value of the enumeration type."},{"signature":"CameraDirectional = 4","summary":"Light location and direction in camera coordinates. +x points to right, +y points up, +z points towards camera."},{"signature":"CameraPoint = 5","summary":"Light location and direction in camera coordinates. +x points to right, +y points up, +z points towards camera."},{"signature":"CameraSpot = 6","summary":"Light location and direction in camera coordinates. +x points to right, +y points up, +z points towards camera."},{"signature":"WorldDirectional = 7","summary":"Light location and direction in world coordinates."},{"signature":"WorldPoint = 8","summary":"Light location and direction in world coordinates."},{"signature":"WorldSpot = 9","summary":"Light location and direction in world coordinates."},{"signature":"Ambient = 10","summary":"Ambient light."},{"signature":"WorldLinear = 11","summary":"Linear light in world coordinates."},{"signature":"WorldRectangular = 12","summary":"Rectangular light in world coordinates."}]},{"namespace":"Rhino.Geometry","name":"Line","dataType":"struct","summary":"Represents the value of start and end points in a single line segment.","constructors":[{"signature":"Line(double x0, double y0, double z0, double x1, double y1, double z1)","summary":"Constructs a new line segment between two points.","since":"5.0","parameters":[{"name":"x0","summary":"The X coordinate of the first point."},{"name":"y0","summary":"The Y coordinate of the first point."},{"name":"z0","summary":"The Z coordinate of the first point."},{"name":"x1","summary":"The X coordinate of the second point."},{"name":"y1","summary":"The Y coordinate of the second point."},{"name":"z1","summary":"The Z coordinate of the second point."}]},{"signature":"Line(Point3d from, Point3d to)","summary":"Constructs a new line segment between two points.","since":"5.0","parameters":[{"name":"from","summary":"Start point of line."},{"name":"to","summary":"End point of line."}]},{"signature":"Line(Point3d start, Vector3d span)","summary":"Constructs a new line segment from start point and span vector.","since":"5.0","parameters":[{"name":"start","summary":"Start point of line segment."},{"name":"span","summary":"Direction and length of line segment."}]},{"signature":"Line(Point3d start, Vector3d direction, double length)","summary":"Constructs a new line segment from start point, direction and length.","since":"5.0","parameters":[{"name":"start","summary":"Start point of line segment."},{"name":"direction","summary":"Direction of line segment."},{"name":"length","summary":"Length of line segment."}]}],"properties":[{"signature":"static Line Unset","summary":"Gets a line segment which has Point3d.Unsetend points.","since":"5.0","property":["get"]},{"signature":"BoundingBox BoundingBox","summary":"Gets the line\'s 3d axis aligned bounding box.","since":"5.0","property":["get"]},{"signature":"Vector3d Direction","summary":"Gets the direction of this line segment. The length of the direction vector equals the length of the line segment.","since":"5.0","property":["get"]},{"signature":"Point3d From","summary":"Start point of line segment.","since":"5.0","property":["get","set"]},{"signature":"double FromX","summary":"Gets or sets the X coordinate of the line From point.","since":"5.0","property":["get","set"]},{"signature":"double FromY","summary":"Gets or sets the Y coordinate of the line From point.","since":"5.0","property":["get","set"]},{"signature":"double FromZ","summary":"Gets or sets the Z coordinate of the line From point.","since":"5.0","property":["get","set"]},{"signature":"bool IsValid","summary":"Gets a value indicating whether or not this line is valid. Valid lines must have valid start and end points, and the points must not be equal.","since":"5.0","property":["get"]},{"signature":"double Length","summary":"Gets or sets the length of this line segment. Note that a negative length will invert the line segment without making the actual length negative. The line From point will remain fixed when a new Length is set.","since":"5.0","property":["get","set"]},{"signature":"Point3d To","summary":"End point of line segment.","since":"5.0","property":["get","set"]},{"signature":"double ToX","summary":"Gets or sets the X coordinate of the line To point.","since":"5.0","property":["get","set"]},{"signature":"double ToY","summary":"Gets or sets the Y coordinate of the line To point.","since":"5.0","property":["get","set"]},{"signature":"double ToZ","summary":"Gets or sets the Z coordinate of the line To point.","since":"5.0","property":["get","set"]},{"signature":"Vector3d UnitTangent","summary":"Gets the tangent of the line segment. Note that tangent vectors are always unit vectors.","since":"5.0","property":["get"]}],"methods":[{"signature":"static bool TryCreateBetweenCurves(Curve curve0, Curve curve1, ref double t0, ref double t1, bool perpendicular0, bool perpendicular1, out Line line)","summary":"Creates a line segment between a pair of curves such that the line segment is either tangent or perpendicular to each of the curves.","since":"5.2","parameters":[{"name":"curve0","summary":"The first curve."},{"name":"curve1","summary":"The second curve."},{"name":"t0","summary":"Parameter value of point on curve0. Seed value at input and solution at output."},{"name":"t1","summary":"Parameter value of point on curve 0.  Seed value at input and solution at output."},{"name":"perpendicular0","summary":"Find line perpendicular to (true) or tangent to (false) curve0."},{"name":"perpendicular1","summary":"Find line Perpendicular to (true) or tangent to (false) curve1."},{"name":"line","summary":"The line segment if successful."}],"returns":"True on success, False on failure."},{"signature":"static bool TryFitLineToPoints(IEnumerable<Point3d> points, out Line fitLine)","summary":"Attempt to fit a line through a set of points.","since":"5.0","parameters":[{"name":"points","summary":"The points through which to fit."},{"name":"fitLine","summary":"The resulting line on success."}],"returns":"True on success, False on failure."},{"signature":"double ClosestParameter(Point3d testPoint)","summary":"Finds the parameter on the infinite line segment that is closest to a test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to project onto the line."}],"returns":"The parameter on the line that is closest to testPoint."},{"signature":"Point3d ClosestPoint(Point3d testPoint, bool limitToFiniteSegment)","summary":"Finds the point on the (in)finite line segment that is closest to a test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to project onto the line."},{"name":"limitToFiniteSegment","summary":"If true, the projection is limited to the finite line segment."}],"returns":"The point on the (in)finite line that is closest to testPoint."},{"signature":"double DistanceTo(Point3d testPoint, bool limitToFiniteSegment)","summary":"Compute the shortest distance between this line segment and a test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point for distance computation."},{"name":"limitToFiniteSegment","summary":"If true, the distance is limited to the finite line segment."}],"returns":"The shortest distance between this line segment and testPoint."},{"signature":"bool EpsilonEquals(Line other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(Line other)","summary":"Determines whether a line has the same value as this line.","since":"5.0","parameters":[{"name":"other","summary":"A line."}],"returns":"True if other has the same coordinates as this; otherwise false."},{"signature":"bool Equals(object obj)","summary":"Determines whether an object is a line that has the same value as this line.","parameters":[{"name":"obj","summary":"An object."}],"returns":"True if obj is a Line and has the same coordinates as this; otherwise false."},{"signature":"bool Extend(double startLength, double endLength)","summary":"Extend the line by custom distances on both sides.","since":"5.0","parameters":[{"name":"startLength","summary":"Distance to extend the line at the start point. Positive distance result in longer lines."},{"name":"endLength","summary":"Distance to extend the line at the end point. Positive distance result in longer lines."}],"returns":"True on success, False on failure."},{"signature":"bool ExtendThroughBox(BoundingBox box)","summary":"Ensure the line extends all the way through a box. Note, this does not result in the shortest possible line that overlaps the box.","since":"5.0","parameters":[{"name":"box","summary":"Box to extend through."}],"returns":"True on success, False on failure."},{"signature":"bool ExtendThroughBox(BoundingBox box, double additionalLength)","summary":"Ensure the line extends all the way through a box. Note, this does not result in the shortest possible line that overlaps the box.","since":"5.0","parameters":[{"name":"box","summary":"Box to extend through."},{"name":"additionalLength","summary":"Additional length to append at both sides of the line."}],"returns":"True on success, False on failure."},{"signature":"bool ExtendThroughBox(Box box)","summary":"Ensure the line extends all the way through a box. Note, this does not result in the shortest possible line that overlaps the box.","since":"5.0","parameters":[{"name":"box","summary":"Box to extend through."}],"returns":"True on success, False on failure."},{"signature":"bool ExtendThroughBox(Box box, double additionalLength)","summary":"Ensure the line extends all the way through a box. Note, this does not result in the shortest possible line that overlaps the box.","since":"5.0","parameters":[{"name":"box","summary":"Box to extend through."},{"name":"additionalLength","summary":"Additional length to append at both sides of the line."}],"returns":"True on success, False on failure."},{"signature":"void Flip()","summary":"Flip the endpoints of the line segment.","since":"5.0"},{"signature":"int GetHashCode()","summary":"Computes a hash number that represents this line.","returns":"A number that is not unique to the value of this line."},{"signature":"double MaximumDistanceTo(Line testLine)","summary":"Finds the largest distance between this line as a finite segment and another finite segment.","since":"5.0","parameters":[{"name":"testLine","summary":"A line to test."}],"returns":"The maximum distance."},{"signature":"double MaximumDistanceTo(Point3d testPoint)","summary":"Finds the largest distance between this line as a finite segment and a test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"A point to test."}],"returns":"The maximum distance."},{"signature":"double MinimumDistanceTo(Line testLine)","summary":"Finds the shortest distance between this line as a finite segment and another finite segment.","since":"5.0","parameters":[{"name":"testLine","summary":"A line to test."}],"returns":"The minimum distance."},{"signature":"double MinimumDistanceTo(Point3d testPoint)","summary":"Finds the shortest distance between this line as a finite segment and a test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"A point to test."}],"returns":"The minimum distance."},{"signature":"Point3d PointAt(double t)","summary":"Evaluates the line at the specified parameter.","since":"5.0","parameters":[{"name":"t","summary":"Parameter to evaluate line segment at. Line parameters are normalized parameters."}],"returns":"The point at the specified parameter."},{"signature":"Point3d PointAtLength(double distance)","summary":"Computes a point located at a specific metric distance from the line origin ( From).  \\nIf line start and end coincide, then the start point is always returned.","since":"6.0","parameters":[{"name":"distance","summary":"A positive, 0, or a negative value that will be the distance from From."}],"returns":"The newly found point."},{"signature":"NurbsCurve ToNurbsCurve()","summary":"Constructs a nurbs curve representation of this line. This amounts to the same as calling NurbsCurve.CreateFromLine().","since":"5.0","returns":"A nurbs curve representation of this line or None if no such representation could be made."},{"signature":"string ToString()","summary":"Constructs the string representation of this line, in the form \\"From,To\\".","returns":"A text string."},{"signature":"string ToString(string format, IFormatProvider formatProvider)","since":"7.0"},{"signature":"bool Transform(Transform xform)","summary":"Transform the line using a Transformation matrix.","since":"5.0","parameters":[{"name":"xform","summary":"Transform to apply to this line."}],"returns":"True on success, False on failure."},{"signature":"bool TryGetPlane(out Plane plane)","summary":"Gets a plane that contains the line. The origin of the plane is at the start of the line. If possible, a plane parallel to the world XY, YZ, or ZX plane is returned.","since":"5.0","parameters":[{"name":"plane","summary":"If the return value is true, the plane out parameter is assigned during this call."}],"returns":"True on success."}]},{"namespace":"Rhino.Geometry","name":"LinearDimension","dataType":"class","summary":"Represents a linear dimension","baseclass":"Rhino.Geometry.Dimension","constructors":[{"signature":"LinearDimension()","since":"5.0"},{"signature":"LinearDimension(Plane dimensionPlane, Point2d extensionLine1End, Point2d extensionLine2End, Point2d pointOnDimensionLine)","since":"5.0"}],"properties":[{"signature":"bool Aligned","summary":"Gets or sets a value indicating whether this annotation is aligned.","since":"5.0","property":["get","set"]},{"signature":"AnnotationType AnnotationType","since":"6.0","property":["get","set"]},{"signature":"Point2d Arrowhead1End","summary":"Gets the arrow head end of the first extension line.","since":"5.0","property":["get"]},{"signature":"Point2d Arrowhead2End","summary":"Gets the arrow head end of the second extension line.","since":"5.0","property":["get"]},{"signature":"Point2d DimensionLinePoint","summary":"Point on annotation plane where dimension line starts","since":"6.0","property":["get","set"]},{"signature":"double DistanceBetweenArrowTips","summary":"Gets the distance between arrow tips.","since":"5.0","property":["get"]},{"signature":"Point2d ExtensionLine1End","summary":"End of the first extension line.","since":"5.0","property":["get","set"]},{"signature":"Point2d ExtensionLine2End","summary":"End of the second extension line.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static LinearDimension Create(AnnotationType dimtype, DimensionStyle dimStyle, Plane plane, Vector3d horizontal, Point3d defpoint1, Point3d defpoint2, Point3d dimlinepoint, double rotationInPlane)","summary":"Initialize Dimension parameters","since":"6.0","parameters":[{"name":"dimtype","summary":"AnnotationType.Rotated or AnnotationType.Aligned"},{"name":"dimStyle","summary":"Dimension\'s DimensionStyle"},{"name":"plane","summary":"Dimension\'s plane"},{"name":"horizontal","summary":"Horizontal reference direction"},{"name":"defpoint1","summary":"First definition point"},{"name":"defpoint2","summary":"Second definition point"},{"name":"dimlinepoint","summary":"Point on dimension line"},{"name":"rotationInPlane","summary":"For Rotated style"}]},{"signature":"static LinearDimension FromPoints(Point3d extensionLine1End, Point3d extensionLine2End, Point3d pointOnDimensionLine)","summary":"Initializes a new instance of the LinearDimensionclass, based on three points.","since":"5.0"},{"signature":"bool Get3dPoints(out Point3d extensionLine1End, out Point3d extensionLine2End, out Point3d arrowhead1End, out Point3d arrowhead2End, out Point3d dimlinepoint, out Point3d textpoint)","summary":"Get locations of dimension\'s 3d points","since":"6.0","parameters":[{"name":"extensionLine1End","summary":"First definition point"},{"name":"extensionLine2End","summary":"Second definition point"},{"name":"arrowhead1End","summary":"First arrowhead point"},{"name":"arrowhead2End","summary":"Second Arrowhead point"},{"name":"dimlinepoint","summary":"Point on dimension line"},{"name":"textpoint","summary":"Text location"}],"returns":"True = success"},{"signature":"bool GetDisplayLines(DimensionStyle style, double scale, out IEnumerable<Line> lines)"},{"signature":"string GetDistanceDisplayText(UnitSystem unitsystem, DimensionStyle style)","since":"6.0"},{"signature":"bool GetTextRectangle(out Point3d[] corners)","since":"6.0"},{"signature":"void SetLocations(Point2d extensionLine1End, Point2d extensionLine2End, Point2d pointOnDimensionLine)","summary":"Sets the three locations of the point, using two-dimensional points that refer to the plane of the annotation.","since":"5.0"}]},{"namespace":"Rhino.Geometry","name":"LineCurve","dataType":"class","summary":"Represents a linear curve.","baseclass":"Rhino.Geometry.Curve","constructors":[{"signature":"LineCurve()","summary":"Initializes a new instance of the LineCurveclass.","since":"5.0"},{"signature":"LineCurve(Line line)","summary":"Initializes a new instance of the LineCurveclass, by retrieving its value from a Line.","since":"5.0","parameters":[{"name":"line","summary":"A line to use as model."}]},{"signature":"LineCurve(Line line, double t0, double t1)","summary":"Initializes a new instance of the LineCurveclass, by retrieving its value from a Lineand setting the domain.","since":"5.0","parameters":[{"name":"line","summary":"A line to use as model."},{"name":"t0","summary":"The new domain start."},{"name":"t1","summary":"The new domain end."}]},{"signature":"LineCurve(LineCurve other)","summary":"Initializes a new instance of the LineCurveclass, by copying values from another linear curve.","since":"5.0"},{"signature":"LineCurve(Point2d from, Point2d to)","summary":"Initializes a new instance of the LineCurveclass, by setting start and end point from two Point2d.","since":"5.0","parameters":[{"name":"from","summary":"A start point."},{"name":"to","summary":"An end point."}]},{"signature":"LineCurve(Point3d from, Point3d to)","summary":"Initializes a new instance of the LineCurveclass, by setting start and end point from two Point3d.","since":"5.0","parameters":[{"name":"from","summary":"A start point."},{"name":"to","summary":"An end point."}]}],"properties":[{"signature":"Line Line","summary":"Gets or sets the Line value inside this curve.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.Geometry","name":"LoftType","dataType":"enum","summary":"Specifies enumerated constants for all supported loft types.","since":"5.0","values":[{"signature":"Normal = 0","summary":"Uses chord-length parameterization in the loft direction."},{"signature":"Loose = 1","summary":"The surface is allowed to move away from the original curves to make a smoother surface. The surface control points are created at the same locations as the control points of the loft input curves."},{"signature":"Tight = 2","summary":"The surface sticks closely to the original curves. Uses square root of chord-length parameterization in the loft direction."},{"signature":"Straight = 3","summary":"The sections between the curves are straight. This is also known as a ruled surface."},{"signature":"    Developable = 4","summary":"Obsolete, do not use."},{"signature":"Uniform = 5","summary":"Constructs a uniform loft. The object knot vectors will be uniform."}]},{"namespace":"Rhino.Geometry","name":"Matrix","dataType":"class","summary":"Represents an arbitrarily sized matrix of double-precision floating point numbers. If you are working with a 4x4 matrix, then you may want to use the Transformclass instead.","interfaces":["IDisposable"],"constructors":[{"signature":"Matrix(int rowCount, int columnCount)","summary":"Initializes a new instance of the matrix.","since":"5.0","parameters":[{"name":"rowCount","summary":"A positive integer, or 0, for the number of rows."},{"name":"columnCount","summary":"A positive integer, or 0, for the number of columns."}]},{"signature":"Matrix(Transform xform)","summary":"Initializes a new instance of the matrix based on a 4x4 matrix Transform.","since":"5.0","parameters":[{"name":"xform","summary":"A 4x4 matrix to copy from."}]}],"properties":[{"signature":"int ColumnCount","summary":"Gets the amount of columns.","since":"5.0","property":["get"]},{"signature":"bool IsColumnOrthogonal","summary":"Gets a value indicating whether the matrix is column orthogonal.","since":"5.0","property":["get"]},{"signature":"bool IsColumnOrthoNormal","summary":"Gets a value indicating whether the matrix is column orthonormal.","since":"5.0","property":["get"]},{"signature":"bool IsRowOrthogonal","summary":"Gets a value indicating whether the matrix is row orthogonal.","since":"5.0","property":["get"]},{"signature":"bool IsRowOrthoNormal","summary":"Gets a value indicating whether the matrix is row orthonormal.","since":"5.0","property":["get"]},{"signature":"bool IsSquare","summary":"Gets a value indicating whether this matrix has the same number of rows and columns. 0x0 matrices are not considered square.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Gets a value indicating whether this matrix is valid.","since":"5.0","property":["get"]},{"signature":"int RowCount","summary":"Gets the amount of rows.","since":"5.0","property":["get"]}],"methods":[{"signature":"double[] BackSolve(double zeroTolerance, double[] b)","summary":"Solves M*x=b where M is upper triangular with a unit diagonal and b is a column of values.","since":"5.0","parameters":[{"name":"zeroTolerance","summary":"(>=0.0) used to test for \\"zero\\" values in b in under determined systems of equations."},{"name":"b","summary":"The values in B[RowCount],...,B[B.Length-1] are tested to make sure they are within \\"zeroTolerance\\"."}],"returns":"Array of length ColumnCount on success. None on error."},{"signature":"Point3d[] BackSolvePoints(double zeroTolerance, Point3d[] b)","summary":"Solves M*x=b where M is upper triangular with a unit diagonal and b is a column of 3d points.","since":"5.0","parameters":[{"name":"zeroTolerance","summary":"(>=0.0) used to test for \\"zero\\" values in b in under determined systems of equations."},{"name":"b","summary":"The values in B[RowCount],...,B[B.Length-1] are tested to make sure they are \\"zero\\"."}],"returns":"Array of length ColumnCount on success. None on error."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"Matrix Duplicate()","summary":"Create a duplicate of this matrix.","since":"5.1","returns":"An exact duplicate of this matrix."},{"signature":"int GetHashCode()","summary":"Gets the hash code for this matrix. The hash code will change when the matrix changes so you cannot change matrices while they are stored in hash tables.","returns":"Hash code."},{"signature":"bool Invert(double zeroTolerance)","summary":"Modifies this matrix to become its own inverse.  \\nMatrix might be non-invertible (singular) and the return value will be false.","since":"5.0","parameters":[{"name":"zeroTolerance","summary":"The admitted tolerance for 0."}],"returns":"True if operation succeeded; otherwise false."},{"signature":"int RowReduce(double zeroTolerance, double[] b, out double pivot)","summary":"Row reduces a matrix as the first step in solving M*X=b where b is a column of values.","since":"5.0","parameters":[{"name":"zeroTolerance","summary":"(>=0.0) zero tolerance for pivot test. If the absolute value of a pivot is <= zero_tolerance, then the pivot is assumed to be zero."},{"name":"b","summary":"an array of RowCount values that is row reduced with the matrix."},{"name":"pivot","summary":"the value of the smallest pivot is returned here."}],"returns":"Rank of the matrix."},{"signature":"int RowReduce(double zeroTolerance, out double determinant, out double pivot)","summary":"Row reduces a matrix to calculate rank and determinant.","since":"5.0","parameters":[{"name":"zeroTolerance","summary":"(>=0.0) zero tolerance for pivot test.  If a the absolute value of a pivot is <= zeroTolerance, then the pivot is assumed to be zero."},{"name":"determinant","summary":"value of determinant is returned here."},{"name":"pivot","summary":"value of the smallest pivot is returned here."}],"returns":"Rank of the matrix."},{"signature":"int RowReduce(double zeroTolerance, Point3d[] b, out double pivot)","summary":"Row reduces a matrix as the first step in solving M*X=b where b is a column of 3d points.","since":"5.0","parameters":[{"name":"zeroTolerance","summary":"(>=0.0) zero tolerance for pivot test. If the absolute value of a pivot is <= zero_tolerance, then the pivot is assumed to be zero."},{"name":"b","summary":"An array of RowCount 3d points that is row reduced with the matrix."},{"name":"pivot","summary":"The value of the smallest pivot is returned here."}],"returns":"Rank of the matrix."},{"signature":"void Scale(double s)","summary":"Modifies the current matrix by multiplying its values by a number.","since":"5.0","parameters":[{"name":"s","summary":"A scale factor."}]},{"signature":"void SetDiagonal(double d)","summary":"Sets diagonal value and zeros off all non-diagonal values.","since":"5.0","parameters":[{"name":"d","summary":"The new diagonal value."}]},{"signature":"bool SwapColumns(int columnA, int columnB)","summary":"Exchanges two columns.","since":"5.0","parameters":[{"name":"columnA","summary":"A first column."},{"name":"columnB","summary":"Another column."}],"returns":"True if operation succeeded; otherwise false."},{"signature":"bool SwapRows(int rowA, int rowB)","summary":"Exchanges two rows.","since":"5.0","parameters":[{"name":"rowA","summary":"A first row."},{"name":"rowB","summary":"Another row."}],"returns":"True if operation succeeded; otherwise false."},{"signature":"bool Transpose()","summary":"Modifies this matrix to be its transpose.  \\nThis is like swapping rows with columns.  \\nhttp://en.wikipedia.org/wiki/Transpose","since":"5.0","returns":"True if operation succeeded; otherwise false."},{"signature":"void Zero()","summary":"Sets all values inside the matrix to zero.","since":"5.0"}]},{"namespace":"Rhino.Geometry","name":"Mesh","dataType":"class","summary":"Represents a geometry type that is defined by vertices and faces.  \\nThis is often called a face-vertex mesh.","baseclass":"Rhino.Geometry.GeometryBase","constructors":[{"signature":"Mesh()","summary":"Initializes a new empty mesh.","since":"5.0"}],"properties":[{"signature":"MeshVertexStatusList ComponentStates","summary":"Gets access to the vertex hidden/visibility collection in this mesh. This is a runtime property and it is not saved in the 3dm file.","since":"6.0","property":["get"]},{"signature":"int DisjointMeshCount","summary":"Gets the number of disjoint (topologically unconnected) pieces in this mesh.","since":"5.0","property":["get"]},{"signature":"MeshFaceNormalList FaceNormals","summary":"Gets access to the face normal collection in this mesh.","since":"5.0","property":["get"]},{"signature":"MeshFaceList Faces","summary":"Gets access to the mesh face list.","since":"5.0","property":["get"]},{"signature":"bool HasCachedTextureCoordinates","summary":"Will return True if SetCachedTextureCoordinates has been called; otherwise will return false.","since":"5.10","property":["get"]},{"signature":"bool HasPrincipalCurvatures","summary":"HasPrincipalCurvatures","since":"7.0","property":["get"]},{"signature":"bool IsClosed","summary":"Gets a value indicating whether a mesh is considered to be closed (solid). A mesh is considered solid when every mesh edge borders two or more faces.","since":"5.0","property":["get"]},{"signature":"MeshNgonList Ngons","summary":"Gets access to the mesh ngon list.  \\nNgons represent groups of Faces (triangles + quads).  \\nFaces are used to tessellate an Ngon internally.  \\nWhen a triangle or quad is referenced in the Ngon list, it is no longer visualized and conceived as a single entity, but takes part of the Ngon.  \\nIf you need to get access to both Ngons and the faces that are not referenced by Ngons, that is, all polygons that are visible in the mesh, then use the helper method.","since":"6.0","property":["get"]},{"signature":"MeshVertexNormalList Normals","summary":"Gets access to the vertex normal collection in this mesh.","since":"5.0","property":["get"]},{"signature":"int PartitionCount","summary":"Number of partition information chunks stored on this mesh based on the last call to CreatePartitions","since":"5.6","property":["get"]},{"signature":"MeshTextureCoordinateList TextureCoordinates","summary":"Gets access to the vertex texture coordinate collection in this mesh.","since":"5.0","property":["get"]},{"signature":"MeshTopologyEdgeList TopologyEdges","summary":"Gets the Rhino.Geometry.Collections.MeshTopologyEdgeListobject associated with this mesh.  \\nThis object stores edge connectivity.","since":"5.0","property":["get"]},{"signature":"MeshTopologyVertexList TopologyVertices","summary":"Gets the Rhino.Geometry.Collections.MeshTopologyVertexListobject associated with this mesh.  \\nThis object stores vertex connectivity and the indices of vertices that were unified while computing the edge topology.","since":"5.0","property":["get"]},{"signature":"MeshVertexColorList VertexColors","summary":"Gets access to the (optional) vertex color collection in this mesh.","since":"5.0","property":["get"]},{"signature":"MeshVertexList Vertices","summary":"Gets access to the vertices set of this mesh.","since":"5.0","property":["get"]}],"methods":[{"signature":"static MeshThicknessMeasurement[] ComputeThickness(IEnumerable<Mesh> meshes, double maximumThickness)","summary":"Compute thickness metrics for this mesh.","since":"6.0","parameters":[{"name":"meshes","summary":"Meshes to include in thickness analysis."},{"name":"maximumThickness","summary":"Maximum thickness to consider. Use as small a thickness as possible to speed up the solver."}],"returns":"Array of thickness measurements."},{"signature":"static MeshThicknessMeasurement[] ComputeThickness(IEnumerable<Mesh> meshes, double maximumThickness, CancellationToken cancelToken)","summary":"Compute thickness metrics for this mesh.","since":"6.0","parameters":[{"name":"meshes","summary":"Meshes to include in thickness analysis."},{"name":"maximumThickness","summary":"Maximum thickness to consider. Use as small a thickness as possible to speed up the solver."},{"name":"cancelToken","summary":"Computation cancellation token."}],"returns":"Array of thickness measurements."},{"signature":"static MeshThicknessMeasurement[] ComputeThickness(IEnumerable<Mesh> meshes, double maximumThickness, double sharpAngle, CancellationToken cancelToken)","summary":"Compute thickness metrics for this mesh.","since":"6.0","parameters":[{"name":"meshes","summary":"Meshes to include in thickness analysis."},{"name":"maximumThickness","summary":"Maximum thickness to consider. Use as small a thickness as possible to speed up the solver."},{"name":"sharpAngle","summary":"Sharpness angle in radians."},{"name":"cancelToken","summary":"Computation cancellation token."}],"returns":"Array of thickness measurements."},{"signature":"static Mesh[] CreateBooleanDifference(IEnumerable<Mesh> firstSet, IEnumerable<Mesh> secondSet)","summary":"Computes the solid difference of two sets of Meshes.","since":"5.0","parameters":[{"name":"firstSet","summary":"First set of Meshes (the set to subtract from)."},{"name":"secondSet","summary":"Second set of Meshes (the set to subtract)."}],"returns":"An array of Mesh results or None on failure."},{"signature":"static Mesh[] CreateBooleanIntersection(IEnumerable<Mesh> firstSet, IEnumerable<Mesh> secondSet)","summary":"Computes the solid intersection of two sets of meshes.","since":"5.0","parameters":[{"name":"firstSet","summary":"First set of Meshes."},{"name":"secondSet","summary":"Second set of Meshes."}],"returns":"An array of Mesh results or None on failure."},{"signature":"static Mesh[] CreateBooleanSplit(IEnumerable<Mesh> meshesToSplit, IEnumerable<Mesh> meshSplitters)","summary":"Splits a set of meshes with another set.","since":"5.0","parameters":[{"name":"meshesToSplit","summary":"A list, an array, or any enumerable set of meshes to be split. If this is null, None will be returned."},{"name":"meshSplitters","summary":"A list, an array, or any enumerable set of meshes that cut. If this is null, None will be returned."}],"returns":"A new mesh array, or None on error."},{"signature":"static Mesh[] CreateBooleanUnion(IEnumerable<Mesh> meshes)","summary":"Computes the solid union of a set of meshes.","since":"5.0","parameters":[{"name":"meshes","summary":"Meshes to union."}],"returns":"An array of Mesh results or None on failure."},{"signature":"static Curve[] CreateContourCurves(Mesh meshToContour, Plane sectionPlane)","summary":"Constructs contour curves for a mesh, sectioned at a plane.","since":"5.0","parameters":[{"name":"meshToContour","summary":"A mesh to contour."},{"name":"sectionPlane","summary":"A cutting plane."}],"returns":"An array of curves. This array can be empty."},{"signature":"static Curve[] CreateContourCurves(Mesh meshToContour, Point3d contourStart, Point3d contourEnd, double interval)","summary":"Constructs contour curves for a mesh, sectioned along a linear axis.","since":"5.0","parameters":[{"name":"meshToContour","summary":"A mesh to contour."},{"name":"contourStart","summary":"A start point of the contouring axis."},{"name":"contourEnd","summary":"An end point of the contouring axis."},{"name":"interval","summary":"An interval distance."}],"returns":"An array of curves. This array can be empty."},{"signature":"static Mesh CreateFromBox(BoundingBox box, int xCount, int yCount, int zCount)","summary":"Constructs new mesh that matches a bounding box.","since":"5.6","parameters":[{"name":"box","summary":"A box to use for creation."},{"name":"xCount","summary":"Number of faces in x-direction."},{"name":"yCount","summary":"Number of faces in y-direction."},{"name":"zCount","summary":"Number of faces in z-direction."}],"returns":"A new brep, or None on failure."},{"signature":"static Mesh CreateFromBox(Box box, int xCount, int yCount, int zCount)","summary":"Constructs new mesh that matches an aligned box.","since":"5.3","parameters":[{"name":"box","summary":"Box to match."},{"name":"xCount","summary":"Number of faces in x-direction."},{"name":"yCount","summary":"Number of faces in y-direction."},{"name":"zCount","summary":"Number of faces in z-direction."}]},{"signature":"static Mesh CreateFromBox(IEnumerable<Point3d> corners, int xCount, int yCount, int zCount)","summary":"Constructs new mesh from 8 corner points.","since":"5.3","parameters":[{"name":"corners","summary":"8 points defining the box corners arranged as the vN labels indicate. v7_____________v6|\\\\             |\\\\| \\\\            | \\\\|  \\\\ _____________\\\\|   v4         |   v5|   |          |   ||   |          |   |v3--|----------v2  | \\\\  |           \\\\  |  \\\\ |            \\\\ |   \\\\|             \\\\|    v0_____________v1"},{"name":"xCount","summary":"Number of faces in x-direction."},{"name":"yCount","summary":"Number of faces in y-direction."},{"name":"zCount","summary":"Number of faces in z-direction."}],"returns":"A new brep, or None on failure."},{"signature":"static Mesh[] CreateFromBrep(Brep brep)","summary":"Constructs a mesh from a brep.","since":"5.0","deprecated":"6.0","parameters":[{"name":"brep","summary":"Brep to approximate."}],"returns":"An array of meshes."},{"signature":"static Mesh[] CreateFromBrep(Brep brep, MeshingParameters meshingParameters)","summary":"Constructs a mesh from a brep.","since":"5.0","parameters":[{"name":"brep","summary":"Brep to approximate."},{"name":"meshingParameters","summary":"Parameters to use during meshing."}],"returns":"An array of meshes."},{"signature":"static Mesh CreateFromClosedPolyline(Polyline polyline)","summary":"Attempts to create a Mesh that is a triangulation of a simple closed polyline that projects onto a plane.","since":"5.0","parameters":[{"name":"polyline","summary":"must be closed"}],"returns":"New mesh on success or None on failure."},{"signature":"static Mesh CreateFromCone(Cone cone, int vertical, int around)","summary":"Constructs a solid mesh cone.","since":"5.0","parameters":[{"name":"cone","summary":""},{"name":"vertical","summary":"Number of faces in the top-to-bottom direction."},{"name":"around","summary":"Number of faces around the cone."}],"returns":"A valid mesh if successful."},{"signature":"static Mesh CreateFromCone(Cone cone, int vertical, int around, bool solid)","summary":"Constructs a mesh cone.","since":"6.8","parameters":[{"name":"cone","summary":""},{"name":"vertical","summary":"Number of faces in the top-to-bottom direction."},{"name":"around","summary":"Number of faces around the cone."},{"name":"solid","summary":"If False the mesh will be open with no faces on the circular planar portion."}],"returns":"A valid mesh if successful."},{"signature":"static Mesh CreateFromCone(Cone cone, int vertical, int around, bool solid, bool quadCaps)","summary":"Constructs a mesh cone.","since":"7.0","parameters":[{"name":"cone","summary":""},{"name":"vertical","summary":"Number of faces in the top-to-bottom direction."},{"name":"around","summary":"Number of faces around the cone."},{"name":"solid","summary":"If False the mesh will be open with no faces on the circular planar portion."},{"name":"quadCaps","summary":"If True and it\'s possible to make quad caps, i.e.. around is even, then caps will have quad faces."}],"returns":"A valid mesh if successful."},{"signature":"static Mesh CreateFromCurveExtrusion(Curve curve, Vector3d direction, MeshingParameters parameters, BoundingBox boundingBox)","summary":"Constructs a new extrusion from a curve.","since":"7.0","parameters":[{"name":"curve","summary":"A curve to extrude."},{"name":"direction","summary":"The direction of extrusion."},{"name":"parameters","summary":"The parameters of meshing."},{"name":"boundingBox","summary":"The bounding box controls the length of the extrusion."}],"returns":"A new mesh, or None on failure."},{"signature":"static Mesh CreateFromCurvePipe(Curve curve, double radius, int segments, int accuracy, MeshPipeCapStyle capType, bool faceted, IEnumerable<Interval> intervals)","summary":"Constructs a new mesh pipe from a curve.","since":"6.0","parameters":[{"name":"curve","summary":"A curve to pipe."},{"name":"radius","summary":"The radius of the pipe."},{"name":"segments","summary":"The number of segments in the pipe."},{"name":"accuracy","summary":"The accuracy of the pipe."},{"name":"capType","summary":"The type of cap to be created at the end of the pipe."},{"name":"faceted","summary":"Specifies whether the pipe is faceted, or not."},{"name":"intervals","summary":"A series of intervals to pipe. This value can be null."}],"returns":"A new mesh, or None on failure."},{"signature":"static Mesh CreateFromCylinder(Cylinder cylinder, int vertical, int around)","summary":"Constructs a capped mesh cylinder.","since":"5.0","parameters":[{"name":"cylinder","summary":""},{"name":"vertical","summary":"Number of faces in the top-to-bottom direction."},{"name":"around","summary":"Number of faces around the cylinder."}],"returns":"Returns a mesh cylinder if successful, None otherwise."},{"signature":"static Mesh CreateFromCylinder(Cylinder cylinder, int vertical, int around, bool capBottom, bool capTop)","summary":"Constructs a mesh cylinder.","since":"7.0","parameters":[{"name":"cylinder","summary":""},{"name":"vertical","summary":"Number of faces in the top-to-bottom direction."},{"name":"around","summary":"Number of faces around the cylinder."},{"name":"capBottom","summary":"If True end at Cylinder.Height1 should be capped."},{"name":"capTop","summary":"If True end at Cylinder.Height2 should be capped."}],"returns":"Returns a mesh cylinder if successful, None otherwise."},{"signature":"static Mesh CreateFromCylinder(Cylinder cylinder, int vertical, int around, bool capBottom, bool capTop, bool quadCaps)","summary":"Constructs a mesh cylinder.","since":"7.0","parameters":[{"name":"cylinder","summary":""},{"name":"vertical","summary":"Number of faces in the top-to-bottom direction."},{"name":"around","summary":"Number of faces around the cylinder."},{"name":"capBottom","summary":"If True end at Cylinder.Height1 should be capped."},{"name":"capTop","summary":"If True end at Cylinder.Height2 should be capped."},{"name":"quadCaps","summary":"If True and it\'s possible to make quad caps, i.e.. around is even, then caps will have quad faces."}],"returns":"Returns a mesh cylinder if successful, None otherwise."},{"signature":"static Mesh CreateFromFilteredFaceList(Mesh original, IEnumerable<bool> inclusion)","summary":"Constructs a sub-mesh, that contains a filtered list of faces.","since":"7.0","parameters":[{"name":"original","summary":"The mesh to copy. This item can be null, and in this case an empty mesh is returned."},{"name":"inclusion","summary":"A series of True and False values, that determine if each face is used in the new mesh.  \\nIf the amount does not match the length of the face list, the pattern is repeated. If it exceeds the amount of faces in the mesh face list, the pattern is truncated. This items can be None or empty, and the mesh will simply be duplicated."}]},{"signature":"static Mesh[] CreateFromIterativeCleanup(IEnumerable<Mesh> meshes, double tolerance)","summary":"Repairs meshes with vertices that are too near, using a tolerance value.","since":"7.0","parameters":[{"name":"meshes","summary":"The meshes to be repaired."},{"name":"tolerance","summary":"A minimum distance for clean vertices."}],"returns":"A valid meshes array if successful. If no change was required, some meshes can be null. Otherwise, null, when no changes were done."},{"signature":"static Mesh CreateFromLines(Curve[] lines, int maxFaceValence, double tolerance)","summary":"Creates a mesh by analizing the edge structure. Input lines could be from the extraction of edges from an original mesh.","since":"6.0","parameters":[{"name":"lines","summary":"Lines to use for computation. If curve is non-linear, curve ends are used"},{"name":"maxFaceValence","summary":"The maximum number of edges per face."},{"name":"tolerance","summary":"The distance after which two end points of lines are considered coincident."}],"returns":"A new mesh, or None if no mesh is constructed."},{"signature":"static Mesh CreateFromPlanarBoundary(Curve boundary, MeshingParameters parameters)","summary":"Do not use this overload. Use version that takes a tolerance parameter instead.","since":"5.0","deprecated":"6.0","parameters":[{"name":"boundary","summary":"Do not use."},{"name":"parameters","summary":"Do not use."}],"returns":"Do not use."},{"signature":"static Mesh CreateFromPlanarBoundary(Curve boundary, MeshingParameters parameters, double tolerance)","summary":"Attempts to construct a mesh from a closed planar curve.RhinoMakePlanarMeshes","since":"6.0","parameters":[{"name":"boundary","summary":"must be a closed planar curve."},{"name":"parameters","summary":"parameters used for creating the mesh."},{"name":"tolerance","summary":"Tolerance to use during operation."}],"returns":"New mesh on success or None on failure."},{"signature":"static Mesh CreateFromPlane(Plane plane, Interval xInterval, Interval yInterval, int xCount, int yCount)","summary":"Constructs a planar mesh grid.","since":"5.0","parameters":[{"name":"plane","summary":"Plane of mesh."},{"name":"xInterval","summary":"Interval describing size and extends of mesh along plane x-direction."},{"name":"yInterval","summary":"Interval describing size and extends of mesh along plane y-direction."},{"name":"xCount","summary":"Number of faces in x-direction."},{"name":"yCount","summary":"Number of faces in y-direction."}]},{"signature":"static Mesh CreateFromSphere(Sphere sphere, int xCount, int yCount)","summary":"Constructs a mesh sphere.","since":"5.0","parameters":[{"name":"sphere","summary":"Base sphere for mesh."},{"name":"xCount","summary":"Number of faces in the around direction."},{"name":"yCount","summary":"Number of faces in the top-to-bottom direction."}]},{"signature":"static Mesh CreateFromSubD(SubD subd, int displayDensity)","summary":"Create a mesh from a SubD limit surface","since":"7.0"},{"signature":"static Mesh CreateFromSubDControlNet(SubD subd)","summary":"Create a mesh from a SubD control net","since":"7.0"},{"signature":"static Mesh CreateFromSurface(Surface surface)","summary":"Constructs a mesh from a surface","since":"6.5","parameters":[{"name":"surface","summary":"Surface to approximate"}],"returns":"New mesh representing the surface"},{"signature":"static Mesh CreateFromSurface(Surface surface, MeshingParameters meshingParameters)","summary":"Constructs a mesh from a surface","since":"6.5","parameters":[{"name":"surface","summary":"Surface to approximate"},{"name":"meshingParameters","summary":"settings used to create the mesh"}],"returns":"New mesh representing the surface"},{"signature":"static Mesh CreateFromTessellation(IEnumerable<Point3d> points, IEnumerable<IEnumerable<Point3d>> edges, Plane plane, bool allowNewVertices)","summary":"Attempts to create a mesh that is a triangulation of a list of points, projected on a plane, including its holes and fixed edges.","parameters":[{"name":"points","summary":"A list, an array or any enumerable of points."},{"name":"edges","summary":"A list of polylines, or other lists of points representing edges. This can be null. If nested enumerable items are null, they will be discarded."},{"name":"plane","summary":"A plane."},{"name":"allowNewVertices","summary":"If true, the mesh might have more vertices than the list of input points, if doing so will improve long thin triangles."}],"returns":"A new mesh, or None if not successful."},{"signature":"static Mesh CreateFromTorus(Torus torus, int vertical, int around)","summary":"Constructs a mesh torus.","since":"7.0","parameters":[{"name":"torus","summary":"The torus."},{"name":"vertical","summary":"Number of faces in the top-to-bottom direction."},{"name":"around","summary":"Number of faces around the torus."}],"returns":"Returns a mesh torus if successful, None otherwise."},{"signature":"static Mesh CreateIcoSphere(Sphere sphere, int subdivisions)","summary":"Constructs a icospherical mesh. A mesh icosphere differs from a standard UV mesh sphere in that it\'s vertices are evenly distributed. A mesh icosphere starts from an icosahedron (a regular polyhedron with 20 equilateral triangles). It is then refined by splitting each triangle into 4 smaller triangles. This splitting can be done several times.","since":"6.0","parameters":[{"name":"sphere","summary":"The input sphere provides the orienting plane and radius."},{"name":"subdivisions","summary":"The number of times you want the faces split, where 0  <= subdivisions <= 7. Note, the total number of mesh faces produces is: 20 * (4 ^ subdivisions)"}],"returns":"A welded mesh icosphere if successful, or None on failure."},{"signature":"static Mesh CreatePatch(Polyline outerBoundary, double angleToleranceRadians, Surface pullbackSurface, IEnumerable<Curve> innerBoundaryCurves, IEnumerable<Curve> innerBothSideCurves, IEnumerable<Point3d> innerPoints, bool trimback, int divisions)","summary":"Construct a mesh patch from a variety of input geometry.","since":"6.0","parameters":[{"name":"outerBoundary","summary":"(optional: can be null) Outer boundary polyline, if provided this will become the outer boundary of the resulting mesh. Any of the input that is completely outside the outer boundary will be ignored and have no impact on the result. If any of the input intersects the outer boundary the result will be unpredictable and is likely to not include the entire outer boundary."},{"name":"angleToleranceRadians","summary":"Maximum angle between unit tangents and adjacent vertices. Used to divide curve inputs that cannot otherwise be represented as a polyline."},{"name":"pullbackSurface","summary":"(optional: can be null) Initial surface where 3d input will be pulled to make a 2d representation used by the function that generates the mesh. Providing a pullbackSurface can be helpful when it is similar in shape to the pattern of the input, the pulled 2d points will be a better representation of the 3d points. If all of the input is more or less coplanar to start with, providing pullbackSurface has no real benefit."},{"name":"innerBoundaryCurves","summary":"(optional: can be null) Polylines to create holes in the output mesh. If innerBoundaryCurves are the only input then the result may be null if trimback is set to False (see comments for trimback) because the resulting mesh could be invalid (all faces created contained vertexes from the perimeter boundary)."},{"name":"innerBothSideCurves","summary":"(optional: can be null) These polylines will create faces on both sides of the edge. If there are only input points(innerPoints) there is no way to guarantee a triangulation that will create an edge between two particular points. Adding a line, or polyline, to innerBothsideCurves that includes points from innerPoints will help guide the triangulation."},{"name":"innerPoints","summary":"(optional: can be null) Points to be used to generate the mesh. If outerBoundary is not null, points outside of that boundary after it has been pulled to pullbackSurface (or the best plane through the input if pullbackSurface is null) will be ignored."},{"name":"trimback","summary":"Only used when a outerBoundary has not been provided. When that is the case, the function uses the perimeter of the surface as the outer boundary instead. If true, any face of the resulting triangulated mesh that contains a vertex of the perimeter boundary will be removed."},{"name":"divisions","summary":"Only used when a outerBoundary has not been provided. When that is the case, division becomes the number of divisions each side of the surface\'s perimeter will be divided into to create an outer boundary to work with."}],"returns":"mesh on success; None on failure"},{"signature":"static Mesh CreateQuadSphere(Sphere sphere, int subdivisions)","summary":"Constructs a quad mesh sphere. A quad mesh sphere differs from a standard UV mesh sphere in that it\'s vertices are evenly distributed. A quad mesh sphere starts from a cube (a regular polyhedron with 6 square sides). It is then refined by splitting each quad into 4 smaller quads. This splitting can be done several times.","since":"6.0","parameters":[{"name":"sphere","summary":"The input sphere provides the orienting plane and radius."},{"name":"subdivisions","summary":"The number of times you want the faces split, where 0  <= subdivisions <= 8. Note, the total number of mesh faces produces is: 6 * (4 ^ subdivisions)"}],"returns":"A welded quad mesh sphere if successful, or None on failure."},{"signature":"static Mesh CreateRefinedCatmullClarkMesh(Mesh mesh, RefinementSettings settings)","summary":"Instantiates a new mesh that represents a Catmull-Clark subdivision of the mesh.","since":"6.0","parameters":[{"name":"mesh","summary":"The mesh to subdivide."},{"name":"settings","summary":"An instance of the settings class, or None for defaults."}],"returns":"A new mesh. None is never returned."},{"signature":"static Mesh CreateRefinedLoopMesh(Mesh mesh, LoopFormula formula, RefinementSettings settings)","summary":"Instantiates a new mesh that represents a Loop subdivision of the mesh.","since":"6.0","parameters":[{"name":"mesh","summary":"The mesh to subdivide."},{"name":"formula","summary":"The Loop subdivision formula."},{"name":"settings","summary":"An instance of the settings class, or None for defaults."}],"returns":"A new mesh. None is never returned."},{"signature":"static Mesh QuadRemeshBrep(Brep brep, QuadRemeshParameters parameters)","summary":"Create QuadRemesh from a Brep Set Brep Face Mode by setting QuadRemeshParameters.PreserveMeshArrayEdgesMode","since":"7.0"},{"signature":"static Mesh QuadRemeshBrep(Brep brep, QuadRemeshParameters parameters, IEnumerable<Curve> guideCurves)","summary":"Create Quad Remesh from a Brep","since":"7.0","parameters":[{"name":"brep","summary":"Set Brep Face Mode by setting QuadRemeshParameters.PreserveMeshArrayEdgesMode"},{"name":"parameters","summary":""},{"name":"guideCurves","summary":"A curve array used to influence mesh face layout The curves should touch the input mesh Set Guide Curve Influence by using QuadRemeshParameters.GuideCurveInfluence"}]},{"signature":"static Task<Mesh> QuadRemeshBrepAsync(Brep brep, QuadRemeshParameters parameters, IEnumerable<Curve> guideCurves, IProgress<int> progress, CancellationToken cancelToken)","summary":"Quad remesh this Brep asynchronously.","since":"7.0","parameters":[{"name":"brep","summary":"Set Brep Face Mode by setting QuadRemeshParameters.PreserveMeshArrayEdgesMode"},{"name":"parameters","summary":""},{"name":"guideCurves","summary":"A curve array used to influence mesh face layout The curves should touch the input mesh Set Guide Curve Influence by using QuadRemeshParameters.GuideCurveInfluence"},{"name":"progress","summary":""},{"name":"cancelToken","summary":""}]},{"signature":"static Task<Mesh> QuadRemeshBrepAsync(Brep brep, QuadRemeshParameters parameters, IProgress<int> progress, CancellationToken cancelToken)","summary":"Quad remesh this Brep asynchronously.","since":"7.0","parameters":[{"name":"brep","summary":"Set Brep Face Mode by setting QuadRemeshParameters.PreserveMeshArrayEdgesMode"},{"name":"parameters","summary":""},{"name":"progress","summary":""},{"name":"cancelToken","summary":""}]},{"signature":"static bool RequireIterativeCleanup(IEnumerable<Mesh> meshes, double tolerance)","summary":"Analyzes some meshes, and determines if a pass of CreateFromIterativeCleanup would change the array.  \\nAll available cleanup steps are used. Currently available cleanup steps are:  \\n- mending of single precision coincidence even though double precision vertices differ.  \\n- union of nearly identical vertices, irrespectively of their origin.  \\n- removal of t-joints along edges.","since":"7.0","parameters":[{"name":"meshes","summary":"A list, and array or any enumerable of meshes."},{"name":"tolerance","summary":"A 3d distance. This is usually a value of about 10e-7 magnitude."}],"returns":"True if meshes would be changed, otherwise false."},{"signature":"void Append(IEnumerable<Mesh> meshes)","summary":"Append a list of meshes. This function is much more efficient than making repeated calls to Mesh.Append(Mesh) when lots of meshes are being joined into a single large mesh.","since":"6.8","parameters":[{"name":"meshes","summary":"Meshes to append to this one."}]},{"signature":"void Append(Mesh other)","summary":"Appends a copy of another mesh to this one and updates indices of appended mesh parts.","since":"5.0","parameters":[{"name":"other","summary":"Mesh to append to this one."}]},{"signature":"bool Check(TextLog textLog, ref MeshCheckParameters parameters)","summary":"Examines the mesh and logs a description of what it finds right or wrong. The various properties the function checks for are described in MeshCheckParameters.","since":"7.0","parameters":[{"name":"textLog","summary":"The text log"},{"name":"parameters","summary":"The mesh checking parameter and results."}],"returns":"Returns True if the mesh is valid, False otherwise."},{"signature":"void ClearSurfaceData()","summary":"Removes surface parameters, curvature parameters and surface statistics from the mesh.","since":"6.0"},{"signature":"void ClearTextureData()","summary":"Removes all texture coordinate information from this mesh.","since":"5.0"},{"signature":"MeshPoint ClosestMeshPoint(Point3d testPoint, double maximumDistance)","summary":"Gets the point on the mesh that is closest to a given test point. Similar to the ClosestPoint function except this returns a MeshPoint class which includes extra information beyond just the location of the closest point.","since":"5.0","parameters":[{"name":"testPoint","summary":"The source of the search."},{"name":"maximumDistance","summary":"Optional upper bound on the distance from test point to the mesh. If you are only interested in finding a point Q on the mesh when testPoint.DistanceTo(Q) < maximumDistance, then set maximumDistance to that value. This parameter is ignored if you pass 0.0 for a maximumDistance."}],"returns":"closest point information on success. None on failure."},{"signature":"Point3d ClosestPoint(Point3d testPoint)","summary":"Gets the point on the mesh that is closest to a given test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to search for."}],"returns":"The point on the mesh closest to testPoint, or Point3d.Unset on failure."},{"signature":"int ClosestPoint(Point3d testPoint, out Point3d pointOnMesh, double maximumDistance)","summary":"Gets the point on the mesh that is closest to a given test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to search for."},{"name":"pointOnMesh","summary":"Point on the mesh closest to testPoint."},{"name":"maximumDistance","summary":"Optional upper bound on the distance from test point to the mesh. If you are only interested in finding a point Q on the mesh when testPoint.DistanceTo(Q) < maximumDistance, then set maximumDistance to that value. This parameter is ignored if you pass 0.0 for a maximumDistance."}],"returns":"Index of face that the closest point lies on if successful. -1 if not successful; the value of pointOnMesh is undefined."},{"signature":"int ClosestPoint(Point3d testPoint, out Point3d pointOnMesh, out Vector3d normalAtPoint, double maximumDistance)","summary":"Gets the point on the mesh that is closest to a given test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to search for."},{"name":"pointOnMesh","summary":"Point on the mesh closest to testPoint."},{"name":"normalAtPoint","summary":"The normal vector of the mesh at the closest point."},{"name":"maximumDistance","summary":"Optional upper bound on the distance from test point to the mesh. If you are only interested in finding a point Q on the mesh when testPoint.DistanceTo(Q) < maximumDistance, then set maximumDistance to that value. This parameter is ignored if you pass 0.0 for a maximumDistance."}],"returns":"Index of face that the closest point lies on if successful. -1 if not successful; the value of pointOnMesh is undefined."},{"signature":"int CollapseFacesByArea(double lessThanArea, double greaterThanArea)","summary":"Collapses multiple mesh faces, with areas less than LessThanArea and greater than GreaterThanArea, based on the principles found in Stan Melax\'s mesh reduction PDF, see http://pomax.nihongoresources.com/downloads/PolygonReduction.pdf","since":"6.0","parameters":[{"name":"lessThanArea","summary":"Area in which faces are selected if their area is less than or equal to."},{"name":"greaterThanArea","summary":"Area in which faces are selected if their area is greater than or equal to."}],"returns":"Number of faces that were collapsed in the process."},{"signature":"int CollapseFacesByByAspectRatio(double aspectRatio)","summary":"Collapses a multiple mesh faces, determined by face aspect ratio, based on criteria found in Stan Melax\'s polygon reduction, see http://pomax.nihongoresources.com/downloads/PolygonReduction.pdf","since":"6.0","parameters":[{"name":"aspectRatio","summary":"Faces with an aspect ratio less than aspectRatio are considered as candidates."}],"returns":"Number of faces that were collapsed in the process."},{"signature":"int CollapseFacesByEdgeLength(bool bGreaterThan, double edgeLength)","summary":"Collapses multiple mesh faces, with greater/less than edge length, based on the principles found in Stan Melax\'s mesh reduction PDF, see http://pomax.nihongoresources.com/downloads/PolygonReduction.pdf","since":"6.0","parameters":[{"name":"bGreaterThan","summary":"Determines whether edge with lengths greater than or less than edgeLength are collapsed."},{"name":"edgeLength","summary":"Length with which to compare to edge lengths."}],"returns":"Number of edges (faces) that were collapsed."},{"signature":"Color ColorAt(int faceIndex, double t0, double t1, double t2, double t3)","summary":"Evaluate a mesh normal at a set of barycentric coordinates. Barycentric coordinates must be assigned in accordance with the rules as defined by MeshPoint.T.","since":"5.0","parameters":[{"name":"faceIndex","summary":"Index of triangle or quad to evaluate."},{"name":"t0","summary":"First barycentric coordinate."},{"name":"t1","summary":"Second barycentric coordinate."},{"name":"t2","summary":"Third barycentric coordinate."},{"name":"t3","summary":"Fourth barycentric coordinate. If the face is a triangle, this coordinate will be ignored."}],"returns":"The interpolated vertex color on the mesh or Color.Transparent if the faceIndex is not valid, if the barycentric coordinates could not be evaluated, or if there are no colors defined on the mesh."},{"signature":"Color ColorAt(MeshPoint meshPoint)","summary":"Evaluate a mesh color at a set of barycentric coordinates.","since":"5.0","parameters":[{"name":"meshPoint","summary":"MeshPoint instance containing a valid Face Index and Barycentric coordinates."}],"returns":"The interpolated vertex color on the mesh or Color.Transparent if the faceIndex is not valid, if the barycentric coordinates could not be evaluated, or if there are no colors defined on the mesh."},{"signature":"bool Compact()","summary":"Removes any unreferenced objects from arrays, re-indexes as needed and shrinks arrays to minimum required size.","since":"5.0","returns":"True on success, False on failure."},{"signature":"byte[] ComputeAutoCreaseInformation()","summary":"Do not use this method. Length: top.Mesh.Vertices.Count","since":"6.0","returns":"An array that is bound to change."},{"signature":"void CopyFrom(Mesh other)","summary":"Copies mesh values into this mesh from another mesh.","since":"5.0","parameters":[{"name":"other","summary":"The other mesh to copy from."}]},{"signature":"bool CreatePartitions(int maximumVertexCount, int maximumTriangleCount)","summary":"In ancient times (or modern smart phone times), some rendering engines were only able to process small batches of triangles and the CreatePartitions() function was provided to partition the mesh into subsets of vertices and faces that those rendering engines could handle.","since":"5.6","returns":"True on success"},{"signature":"void DestroyPartition()","summary":"Destroys mesh partition.","since":"6.0"},{"signature":"void DestroyTopology()","summary":"Removes topology data, forcing all topology information to be recomputed.","since":"6.0"},{"signature":"void DestroyTree()","summary":"Destroys the mesh vertex access tree.","since":"6.0"},{"signature":"GeometryBase Duplicate()","summary":"Constructs a copy of this mesh. This is the same as DuplicateMesh.","since":"5.0","returns":"A mesh."},{"signature":"Mesh DuplicateMesh()","summary":"Constructs a copy of this mesh. This is the same as Duplicate.","since":"5.0"},{"signature":"bool EvaluateMeshGeometry(Surface surface)","summary":"If the mesh has SurfaceParameters, the surface is evaluated at these parameters and the mesh geometry is updated.","since":"5.0","parameters":[{"name":"surface","summary":"An input surface."}],"returns":"True if the operation succeeded; False otherwise."},{"signature":"Mesh[] ExplodeAtUnweldedEdges()","summary":"Explode the mesh into sub-meshes where a sub-mesh is a collection of faces that are contained within a closed loop of \\"unwelded\\" edges. Unwelded edges are edges where the faces that share the edge have unique mesh vertexes (not mesh topology vertexes) at both ends of the edge.","since":"5.0","returns":"Array of sub-meshes on success; None on error. If the count in the returned array is 1, then nothing happened and the output is essentially a copy of the input."},{"signature":"int[] ExtendSelectionByEdgeRidge(int[] preselectedEdges, int newEdge, bool iterative)","summary":"Suggests an extension of a selection set by using information related with topology and alignment.","since":"6.0","parameters":[{"name":"preselectedEdges","summary":"An array of edges that were already selected."},{"name":"newEdge","summary":"A new edge index."},{"name":"iterative","summary":""}],"returns":"An array of edges that are in a visual relationship with newEdge."},{"signature":"int[] ExtendSelectionByFaceLoop(int[] preselectedFaces, int newFace, bool iterative)","summary":"Suggests an extension of a face selection set by using information related with topology and alignment.","since":"6.0","parameters":[{"name":"preselectedFaces","summary":"An array of faces that were already selected."},{"name":"newFace","summary":"A new face index. If this index is already part of the selection, no extension is suggested."},{"name":"iterative","summary":""}],"returns":"An array of faces that are in a visual relationship with newFace."},{"signature":"Mesh ExtractNonManifoldEdges(bool selective)","summary":"Extracts, or removes, non-manifold mesh edges.","since":"6.0","parameters":[{"name":"selective","summary":"If true, then extract hanging faces only."}],"returns":"A mesh containing the extracted non-manifold parts if successful, None otherwise."},{"signature":"bool FileHole(int topologyEdgeIndex)","summary":"Given a starting \\"naked\\" edge index, this function attempts to determine a \\"hole\\" by chaining additional naked edges together until if returns to the start index. Then it triangulates the closed polygon and either adds the faces to the mesh.","since":"6.0","parameters":[{"name":"topologyEdgeIndex","summary":"Starting naked edge index."}],"returns":"True if successful, False otherwise."},{"signature":"bool FillHoles()","summary":"Attempts to determine \\"holes\\" in the mesh by chaining naked edges together. Then it triangulates the closed polygons adds the faces to the mesh.","since":"6.0","returns":"True if successful, False otherwise."},{"signature":"void Flip(bool vertexNormals, bool faceNormals, bool faceOrientation)","summary":"Reverses the direction of the mesh.","since":"5.0","parameters":[{"name":"vertexNormals","summary":"If true, vertex normals will be reversed."},{"name":"faceNormals","summary":"If true, face normals will be reversed."},{"name":"faceOrientation","summary":"If true, face orientations will be reversed."}]},{"signature":"void Flip(bool vertexNormals, bool faceNormals, bool faceOrientation, bool ngonsBoundaryDirection)","summary":"Reverses the direction of the mesh.","since":"7.0","parameters":[{"name":"vertexNormals","summary":"If true, vertex normals will be reversed."},{"name":"faceNormals","summary":"If true, face normals will be reversed."},{"name":"faceOrientation","summary":"If true, face orientations will be reversed."},{"name":"ngonsBoundaryDirection","summary":"If true, ngon boundaries will be reversed"}]},{"signature":"CachedTextureCoordinates GetCachedTextureCoordinates(Guid textureMappingId)","summary":"Call this method to get cached texture coordinates for a texture mapping with the specified Id.","since":"5.10","parameters":[{"name":"textureMappingId","summary":"Texture mapping Id"}],"returns":"Object which allows access to coordinates and other props."},{"signature":"bool[] GetNakedEdgePointStatus()","summary":"Returns an array of Boolean values equal in length to the number of vertices in this mesh. Each value corresponds to a mesh vertex and is set to True if the vertex is not completely surrounded by faces.","since":"5.0","returns":"An array of true/False flags that, at each index, reveals if the corresponding vertex is completely surrounded by faces."},{"signature":"Polyline[] GetNakedEdges()","summary":"Returns all edges of a mesh that are considered \\"naked\\" in the sense that the edge only has one face.","since":"5.0","returns":"An array of polylines, or None on error."},{"signature":"int GetNgonAndFacesCount()","summary":"Retrieves the count of items that GetNgonAndFacesEnumerablewill provide.","since":"6.0","returns":"The amount of faces that are not part of an ngon + the amount of ngons."},{"signature":"IEnumerable<MeshNgon> GetNgonAndFacesEnumerable()","summary":"Retrieves a complete enumerable, i.e., one that provides an iterator over every face that is present, no matter if defined as a triangle, a quad, or a strictly over-four-sided ngon.","since":"6.0","returns":"The enumerator capable of enumerating through Mesh.Ngons> Mesh.Ngons and Faces"},{"signature":"Polyline[] GetOutlines(Plane plane)","summary":"Constructs the outlines of a mesh projected against a plane.","since":"5.0","parameters":[{"name":"plane","summary":"A plane to project against."}],"returns":"An array of polylines, or None on error."},{"signature":"Polyline[] GetOutlines(RhinoViewport viewport)","summary":"Constructs the outlines of a mesh. The projection information in the viewport is used to determine how the outlines are projected.","since":"5.0","parameters":[{"name":"viewport","summary":"A viewport to determine projection direction."}],"returns":"An array of polylines, or None on error."},{"signature":"Polyline[] GetOutlines(ViewportInfo viewportInfo, Plane plane)","summary":"Constructs the outlines of a mesh.","since":"6.0","parameters":[{"name":"viewportInfo","summary":"The viewport info that provides the outline direction."},{"name":"plane","summary":"Usually the view\'s construction plane. If a parallel projection and view plane is parallel to this, then project the results to the plane."}],"returns":"An array of polylines, or None on error."},{"signature":"MeshPart GetPartition(int which)","summary":"Retrieves a partition. See CreatePartitionsfor details.","since":"5.6","parameters":[{"name":"which","summary":"The partition index."}]},{"signature":"bool GetSelfIntersections(double tolerance, out Polyline[] intersections, bool overlapsPolylines, out Polyline[] overlapsPolylinesResult, bool overlapsMesh, out Mesh overlapsMeshResult, TextLog textLog, CancellationToken cancel, IProgress<double> progress)","summary":"Gets the self intersections of this mesh.","since":"7.0"},{"signature":"MeshUnsafeLock GetUnsafeLock(bool writable)","summary":"Allows to obtain unsafe pointers to the underlying unmanaged data structures of the mesh.","since":"6.0","parameters":[{"name":"writable","summary":"True if user will need to write onto the structure. False otherwise."}],"returns":"A lock that needs to be released."},{"signature":"bool HealNakedEdges(double distance)","summary":"Attempts to \\"heal\\" naked edges in a mesh based on a given distance. First attempts to move vertexes to neighboring vertexes that are within that distance away. Then it finds edges that have a closest point to the vertex within the distance and splits the edge. When it finds one it splits the edge and makes two new edges using that point.","since":"6.0","parameters":[{"name":"distance","summary":"Distance to not exceed when modifying the mesh."}],"returns":"True if successful, False otherwise."},{"signature":"bool IsManifold(bool topologicalTest, out bool isOriented, out bool hasBoundary)","summary":"Gets a value indicating whether or not the mesh is manifold. A manifold mesh does not have any edge that borders more than two faces.","since":"5.0","parameters":[{"name":"topologicalTest","summary":"If true, the query treats coincident vertices as the same."},{"name":"isOriented","summary":"isOriented will be set to True if the mesh is a manifold and adjacent faces have compatible face normals."},{"name":"hasBoundary","summary":"hasBoundary will be set to True if the mesh is a manifold and there is at least one \\"edge\\" with no more than one adjacent face."}],"returns":"True if every mesh \\"edge\\" has at most two adjacent faces."},{"signature":"bool IsPointInside(Point3d point, double tolerance, bool strictlyIn)","summary":"Determines if a point is inside a solid mesh.","since":"5.0","parameters":[{"name":"point","summary":"3d point to test."},{"name":"tolerance","summary":"(>=0) 3d distance tolerance used for ray-mesh intersection and determining strict inclusion."},{"name":"strictlyIn","summary":"If strictlyIn is true, then point must be inside mesh by at least tolerance in order for this function to return true. If strictlyIn is false, then this function will return True if point is inside or the distance from point to a mesh face is <= tolerance."}],"returns":"True if point is inside the solid mesh, False if not."},{"signature":"Vector3d NormalAt(int faceIndex, double t0, double t1, double t2, double t3)","summary":"Evaluate a mesh normal at a set of barycentric coordinates. Barycentric coordinates must be assigned in accordance with the rules as defined by MeshPoint.T.","since":"5.0","parameters":[{"name":"faceIndex","summary":"Index of triangle or quad to evaluate."},{"name":"t0","summary":"First barycentric coordinate."},{"name":"t1","summary":"Second barycentric coordinate."},{"name":"t2","summary":"Third barycentric coordinate."},{"name":"t3","summary":"Fourth barycentric coordinate. If the face is a triangle, this coordinate will be ignored."}],"returns":"A Normal vector to the mesh or Vector3d.Unset if the faceIndex is not valid or if the barycentric coordinates could not be evaluated."},{"signature":"Vector3d NormalAt(MeshPoint meshPoint)","summary":"Evaluate a mesh normal at a set of barycentric coordinates.","since":"5.0","parameters":[{"name":"meshPoint","summary":"MeshPoint instance containing a valid Face Index and Barycentric coordinates."}],"returns":"A Normal vector to the mesh or Vector3d.Unset if the faceIndex is not valid or if the barycentric coordinates could not be evaluated."},{"signature":"Mesh Offset(double distance)","summary":"Makes a new mesh with vertices offset a distance in the opposite direction of the existing vertex normals. Same as Mesh.Offset(distance, false)","since":"5.0","parameters":[{"name":"distance","summary":"A distance value to use for offsetting."}],"returns":"A new mesh on success, or None on failure."},{"signature":"Mesh Offset(double distance, bool solidify)","summary":"Makes a new mesh with vertices offset a distance in the opposite direction of the existing vertex normals. Optionally, based on the value of solidify, adds the input mesh and a ribbon of faces along any naked edges. If solidify is False it acts exactly as the Offset(distance) function.","since":"5.0","parameters":[{"name":"distance","summary":"A distance value."},{"name":"solidify","summary":"True if the mesh should be solidified."}],"returns":"A new mesh on success, or None on failure."},{"signature":"Mesh Offset(double distance, bool solidify, Vector3d direction)","summary":"Makes a new mesh with vertices offset a distance along the direction parameter. Optionally, based on the value of solidify, adds the input mesh and a ribbon of faces along any naked edges. If solidify is False it acts exactly as the Offset(distance) function.","since":"6.2","parameters":[{"name":"distance","summary":"A distance value."},{"name":"solidify","summary":"True if the mesh should be solidified."},{"name":"direction","summary":"Direction of offset for all vertices."}],"returns":"A new mesh on success, or None on failure."},{"signature":"Mesh Offset(double distance, bool solidify, Vector3d direction, out List<int> wallFacesOut)","summary":"Makes a new mesh with vertices offset a distance along the direction parameter. Optionally, based on the value of solidify, adds the input mesh and a ribbon of faces along any naked edges. If solidify is False it acts exactly as the Offset(distance) function. Returns list of wall faces, i.e. the faces that connect original and offset mesh when solidified.","parameters":[{"name":"distance","summary":"A distance value."},{"name":"solidify","summary":"True if the mesh should be solidified."},{"name":"direction","summary":"Direction of offset for all vertices."},{"name":"wallFacesOut","summary":"Returns list of wall faces."}],"returns":"A new mesh on success, or None on failure."},{"signature":"Point3d PointAt(int faceIndex, double t0, double t1, double t2, double t3)","summary":"Evaluates a mesh at a set of barycentric coordinates. Barycentric coordinates must be assigned in accordance with the rules as defined by MeshPoint.T.","since":"5.0","parameters":[{"name":"faceIndex","summary":"Index of triangle or quad to evaluate."},{"name":"t0","summary":"First barycentric coordinate."},{"name":"t1","summary":"Second barycentric coordinate."},{"name":"t2","summary":"Third barycentric coordinate."},{"name":"t3","summary":"Fourth barycentric coordinate. If the face is a triangle, this coordinate will be ignored."}],"returns":"A Point on the mesh or Point3d.Unset if the faceIndex is not valid or if the barycentric coordinates could not be evaluated."},{"signature":"Point3d PointAt(MeshPoint meshPoint)","summary":"Evaluate a mesh at a set of barycentric coordinates.","since":"5.0","parameters":[{"name":"meshPoint","summary":"MeshPoint instance containing a valid Face Index and Barycentric coordinates."}],"returns":"A Point on the mesh or Point3d.Unset if the faceIndex is not valid or if the barycentric coordinates could not be evaluated."},{"signature":"PolylineCurve PullCurve(Curve curve, double tolerance)","summary":"Gets a polyline approximation of the input curve and then moves its control points to the closest point on the mesh. Then it \\"connects the points\\" over edges so that a polyline on the mesh is formed.","since":"7.0","parameters":[{"name":"curve","summary":"A curve to pull."},{"name":"tolerance","summary":"A tolerance value."}],"returns":"A polyline curve, or None if none could be constructed."},{"signature":"Point3d[] PullPointsToMesh(IEnumerable<Point3d> points)","summary":"Pulls a collection of points to a mesh.","since":"5.0","parameters":[{"name":"points","summary":"An array, a list or any enumerable set of points."}],"returns":"An array of points. This can be empty."},{"signature":"Mesh QuadRemesh(QuadRemeshParameters parameters)","summary":"Quad remesh this mesh.","since":"7.0"},{"signature":"Mesh QuadRemesh(QuadRemeshParameters parameters, IEnumerable<Curve> guideCurves)","summary":"Quad remesh this mesh.","since":"7.0","parameters":[{"name":"parameters","summary":""},{"name":"guideCurves","summary":"A curve array used to influence mesh face layout The curves should touch the input mesh Set Guide Curve Influence by using QuadRemeshParameters.GuideCurveInfluence"}]},{"signature":"Task<Mesh> QuadRemeshAsync(IEnumerable<int> faceBlocks, QuadRemeshParameters parameters, IEnumerable<Curve> guideCurves, IProgress<int> progress, CancellationToken cancelToken)","summary":"Quad remesh this mesh asynchronously.","since":"7.0","parameters":[{"name":"faceBlocks","summary":""},{"name":"parameters","summary":""},{"name":"guideCurves","summary":"A curve array used to influence mesh face layout The curves should touch the input mesh Set Guide Curve Influence by using QuadRemeshParameters.GuideCurveInfluence"},{"name":"progress","summary":""},{"name":"cancelToken","summary":""}]},{"signature":"Task<Mesh> QuadRemeshAsync(QuadRemeshParameters parameters, IEnumerable<Curve> guideCurves, IProgress<int> progress, CancellationToken cancelToken)","summary":"Quad remesh this mesh asynchronously.","since":"7.0","parameters":[{"name":"parameters","summary":""},{"name":"guideCurves","summary":"A curve array used to influence mesh face layout The curves should touch the input mesh Set Guide Curve Influence by using QuadRemeshParameters.GuideCurveInfluence"},{"name":"progress","summary":""},{"name":"cancelToken","summary":""}]},{"signature":"Task<Mesh> QuadRemeshAsync(QuadRemeshParameters parameters, IProgress<int> progress, CancellationToken cancelToken)","summary":"Quad remesh this mesh asynchronously.","since":"7.0"},{"signature":"void RebuildNormals()","summary":"Removes mesh normals and reconstructs the face and vertex normals based on the orientation of the faces.","since":"6.0"},{"signature":"bool Reduce(int desiredPolygonCount, bool allowDistortion, int accuracy, bool normalizeSize)","summary":"Reduce polygon count","since":"5.10","parameters":[{"name":"desiredPolygonCount","summary":"desired or target number of faces"},{"name":"allowDistortion","summary":"If True mesh appearance is not changed even if the target polygon count is not reached"},{"name":"accuracy","summary":"Integer from 1 to 10 telling how accurate reduction algorithm to use. Greater number gives more accurate results"},{"name":"normalizeSize","summary":"If True mesh is fitted to an axis aligned unit cube until reduction is complete"}],"returns":"True if mesh is successfully reduced and False if mesh could not be reduced for some reason."},{"signature":"bool Reduce(int desiredPolygonCount, bool allowDistortion, int accuracy, bool normalizeSize, bool threaded)","summary":"Reduce polygon count","since":"6.15","parameters":[{"name":"desiredPolygonCount","summary":"desired or target number of faces"},{"name":"allowDistortion","summary":"If True mesh appearance is not changed even if the target polygon count is not reached"},{"name":"accuracy","summary":"Integer from 1 to 10 telling how accurate reduction algorithm to use. Greater number gives more accurate results"},{"name":"normalizeSize","summary":"If True mesh is fitted to an axis aligned unit cube until reduction is complete"},{"name":"threaded","summary":"If True then will run computation inside a worker thread and ignore any provided CancellationTokens and ProgressReporters. If False then will run on main thread."}],"returns":"True if mesh is successfully reduced and False if mesh could not be reduced for some reason."},{"signature":"bool Reduce(int desiredPolygonCount, bool allowDistortion, int accuracy, bool normalizeSize, CancellationToken cancelToken, IProgress<double> progress, out string problemDescription)","summary":"Reduce polygon count","since":"6.0","parameters":[{"name":"desiredPolygonCount","summary":"desired or target number of faces"},{"name":"allowDistortion","summary":"If True mesh appearance is not changed even if the target polygon count is not reached"},{"name":"accuracy","summary":"Integer from 1 to 10 telling how accurate reduction algorithm to use. Greater number gives more accurate results"},{"name":"normalizeSize","summary":"If True mesh is fitted to an axis aligned unit cube until reduction is complete"},{"name":"cancelToken","summary":""},{"name":"progress","summary":""},{"name":"problemDescription","summary":""}],"returns":"True if mesh is successfully reduced and False if mesh could not be reduced for some reason."},{"signature":"bool Reduce(int desiredPolygonCount, bool allowDistortion, int accuracy, bool normalizeSize, CancellationToken cancelToken, IProgress<double> progress, out string problemDescription, bool threaded)","summary":"Reduce polygon count","since":"6.15","parameters":[{"name":"desiredPolygonCount","summary":"desired or target number of faces"},{"name":"allowDistortion","summary":"If True mesh appearance is not changed even if the target polygon count is not reached"},{"name":"accuracy","summary":"Integer from 1 to 10 telling how accurate reduction algorithm to use. Greater number gives more accurate results"},{"name":"normalizeSize","summary":"If True mesh is fitted to an axis aligned unit cube until reduction is complete"},{"name":"cancelToken","summary":""},{"name":"progress","summary":""},{"name":"problemDescription","summary":""},{"name":"threaded","summary":"If True then will run computation inside a worker thread and ignore any provided CancellationTokens and ProgressReporters. If False then will run on main thread."}],"returns":"True if mesh is successfully reduced and False if mesh could not be reduced for some reason."},{"signature":"bool Reduce(ReduceMeshParameters parameters)","summary":"Reduce polygon count","since":"6.0","parameters":[{"name":"parameters","summary":"Parameters"}],"returns":"True if mesh is successfully reduced and False if mesh could not be reduced for some reason."},{"signature":"bool Reduce(ReduceMeshParameters parameters, bool threaded)","summary":"Reduce polygon count","since":"6.15","parameters":[{"name":"parameters","summary":"Parameters"},{"name":"threaded","summary":"If True then will run computation inside a worker thread and ignore any provided CancellationTokens and ProgressReporters. If False then will run on main thread."}],"returns":"True if mesh is successfully reduced and False if mesh could not be reduced for some reason."},{"signature":"void ReleaseUnsafeLock(MeshUnsafeLock meshData)","summary":"Updates the Mesh data with the information that was stored via the MeshUnsafeLock.","since":"6.0","parameters":[{"name":"meshData","summary":"The data that will be unlocked."}]},{"signature":"void SetCachedTextureCoordinates(TextureMapping tm, ref Transform xf)","summary":"Set cached texture coordinates using the specified mapping.","since":"5.10"},{"signature":"void SetTextureCoordinates(TextureMapping tm, Transform xf, bool lazy)","summary":"Set texture coordinates using given mapping and applying given transform.  Set lazy to False to generate texture coordinates right away.","since":"6.0","parameters":[{"name":"tm","summary":"Texture mapping"},{"name":"xf","summary":"Transform to apply to the texture mapping"},{"name":"lazy","summary":"Whether to generate lazily (true) or right away (false)"}]},{"signature":"void SetTextureCoordinates(TextureMapping tm, Transform xf, bool lazy, bool seamCheck)","summary":"Set texture coordinates using given mapping and applying given transform.  Set lazy to False to generate texture coordinates right away.","since":"7.0","parameters":[{"name":"tm","summary":"Texture mapping"},{"name":"xf","summary":"Transform to apply to the texture mapping"},{"name":"lazy","summary":"Whether to generate lazily (true) or right away (false)"},{"name":"seamCheck","summary":"If True then some mesh edges might be unwelded to better represent UV discontinuities in the texture mapping. This only happens for the following mappings: Box, Sphere, Cylinder"}]},{"signature":"bool Smooth(double smoothFactor, bool bXSmooth, bool bYSmooth, bool bZSmooth, bool bFixBoundaries, SmoothingCoordinateSystem coordinateSystem)","summary":"Smooths a mesh by averaging the positions of mesh vertices in a specified region.","since":"6.0","parameters":[{"name":"smoothFactor","summary":"The smoothing factor, which controls how much vertices move towards the average of the neighboring vertices."},{"name":"bXSmooth","summary":"When True vertices move in X axis direction."},{"name":"bYSmooth","summary":"When True vertices move in Y axis direction."},{"name":"bZSmooth","summary":"When True vertices move in Z axis direction."},{"name":"bFixBoundaries","summary":"When True vertices along naked edges will not be modified."},{"name":"coordinateSystem","summary":"The coordinates to determine the direction of the smoothing."}],"returns":"True if successful, False otherwise."},{"signature":"bool Smooth(double smoothFactor, bool bXSmooth, bool bYSmooth, bool bZSmooth, bool bFixBoundaries, SmoothingCoordinateSystem coordinateSystem, Plane plane)","summary":"Smooths a mesh by averaging the positions of mesh vertices in a specified region.","since":"6.0","parameters":[{"name":"smoothFactor","summary":"The smoothing factor, which controls how much vertices move towards the average of the neighboring vertices."},{"name":"bXSmooth","summary":"When True vertices move in X axis direction."},{"name":"bYSmooth","summary":"When True vertices move in Y axis direction."},{"name":"bZSmooth","summary":"When True vertices move in Z axis direction."},{"name":"bFixBoundaries","summary":"When True vertices along naked edges will not be modified."},{"name":"coordinateSystem","summary":"The coordinates to determine the direction of the smoothing."},{"name":"plane","summary":"If SmoothingCoordinateSystem.CPlane specified, then the construction plane."}],"returns":"True if successful, False otherwise."},{"signature":"bool Smooth(IEnumerable<int> vertexIndices, double smoothFactor, bool bXSmooth, bool bYSmooth, bool bZSmooth, bool bFixBoundaries, SmoothingCoordinateSystem coordinateSystem, Plane plane)","summary":"Smooths part of a mesh by averaging the positions of mesh vertices in a specified region.","since":"6.8","parameters":[{"name":"vertexIndices","summary":"The mesh vertex indices that specify the part of the mesh to smooth."},{"name":"smoothFactor","summary":"The smoothing factor, which controls how much vertices move towards the average of the neighboring vertices."},{"name":"bXSmooth","summary":"When True vertices move in X axis direction."},{"name":"bYSmooth","summary":"When True vertices move in Y axis direction."},{"name":"bZSmooth","summary":"When True vertices move in Z axis direction."},{"name":"bFixBoundaries","summary":"When True vertices along naked edges will not be modified."},{"name":"coordinateSystem","summary":"The coordinates to determine the direction of the smoothing."},{"name":"plane","summary":"If SmoothingCoordinateSystem.CPlane specified, then the construction plane."}],"returns":"True if successful, False otherwise."},{"signature":"int SolidOrientation()","summary":"Determines orientation of a \\"solid\\" mesh.","since":"5.0","returns":"+1 = mesh is solid with outward facing normals.  \\n-1 = mesh is solid with inward facing normals.  \\n0 = mesh is not solid."},{"signature":"Mesh[] Split(IEnumerable<Mesh> meshes)","summary":"Split a mesh with a collection of meshes. Suggestion: upgrade to overload with tolerance. Does not split at coplanar intersections.","since":"5.0","parameters":[{"name":"meshes","summary":"Meshes to split with."}],"returns":"An array of mesh segments representing the split result."},{"signature":"Mesh[] Split(IEnumerable<Mesh> meshes, double tolerance, bool splitAtCoplanar, bool createNgons, TextLog textLog, CancellationToken cancel, IProgress<double> progress)","summary":"Split a mesh with a collection of meshes.","since":"7.0","parameters":[{"name":"meshes","summary":"Meshes to split with."},{"name":"tolerance","summary":"A value for intersection tolerance.  \\nWARNING! Correct values are typically in the (10e-8 - 10e-4) range.  \\nAn option is to use the document tolerance diminished by a few orders or magnitude."},{"name":"splitAtCoplanar","summary":"If false, coplanar areas will not be separated."},{"name":"createNgons","summary":"If true, creates ngons along the split ridge."},{"name":"textLog","summary":"A text log to write onto."},{"name":"cancel","summary":"A cancellation token."},{"name":"progress","summary":"A progress reporter item. This can be null."}],"returns":"An array of mesh parts representing the split result, or null: when no mesh intersected, or if a cancel stopped the computation."},{"signature":"Mesh[] Split(IEnumerable<Mesh> meshes, double tolerance, bool splitAtCoplanar, TextLog textLog, CancellationToken cancel, IProgress<double> progress)","summary":"Split a mesh with a collection of meshes.","since":"7.0","parameters":[{"name":"meshes","summary":"Meshes to split with."},{"name":"tolerance","summary":"A value for intersection tolerance.  \\nWARNING! Correct values are typically in the (10e-8 - 10e-4) range.  \\nAn option is to use the document tolerance diminished by a few orders or magnitude."},{"name":"splitAtCoplanar","summary":"If false, coplanar areas will not be separated."},{"name":"textLog","summary":"A text log to write onto."},{"name":"cancel","summary":"A cancellation token."},{"name":"progress","summary":"A progress reporter item. This can be null."}],"returns":"An array of mesh parts representing the split result, or null: when no mesh intersected, or if a cancel stopped the computation."},{"signature":"Mesh[] Split(Mesh mesh)","summary":"Split a mesh with another mesh. Suggestion: upgrade to overload with tolerance.","since":"5.0","parameters":[{"name":"mesh","summary":"Mesh to split with."}],"returns":"An array of mesh segments representing the split result."},{"signature":"Mesh[] Split(Plane plane)","summary":"Split a mesh by an infinite plane.","since":"5.0","parameters":[{"name":"plane","summary":"The splitting plane."}],"returns":"A new mesh array with the split result. This can be None if no result was found."},{"signature":"Mesh[] SplitDisjointPieces()","summary":"Splits up the mesh into its unconnected pieces.","since":"5.0","returns":"An array containing all the disjoint pieces that make up this Mesh."},{"signature":"Mesh[] SplitWithProjectedPolylines(IEnumerable<PolylineCurve> curves, double tolerance)","summary":"Splits a mesh by adding edges in correspondence with input polylines, and divides the mesh at partitioned areas. Polyline segments that are measured not to be on the mesh will be ignored.","since":"7.0","parameters":[{"name":"curves","summary":"An array, a list or any enumerable of polyline curves."},{"name":"tolerance","summary":"A tolerance value."}],"returns":"An array of meshes, or None if no change would happen."},{"signature":"Mesh[] SplitWithProjectedPolylines(IEnumerable<PolylineCurve> curves, double tolerance, TextLog textLog, CancellationToken cancel, IProgress<double> progress)","summary":"Splits a mesh by adding edges in correspondence with input polylines, and divides the mesh at partitioned areas. Polyline segments that are measured not to be on the mesh will be ignored.","since":"7.0","parameters":[{"name":"curves","summary":"An array, a list or any enumerable of polyline curves."},{"name":"tolerance","summary":"A tolerance value."},{"name":"textLog","summary":"A text log, or null."},{"name":"cancel","summary":"A cancellation token to stop the computation at a given point."},{"name":"progress","summary":"A progress reporter to inform the user about progress. The reported value is indicative."}],"returns":"An array of meshes, or None if no change would happen."},{"signature":"int UnifyNormals()","summary":"Attempts to fix inconsistencies in the directions of mesh faces in a mesh. This function does not modify mesh vertex normals, it rearranges the mesh face winding and face normals to make them all consistent. Note, you may want to call Mesh.Normals.ComputeNormals() to recompute vertex normals after calling this functions.","since":"5.0","returns":"number of faces that were modified."},{"signature":"int UnifyNormals(bool countOnly)","summary":"Attempts to fix inconsistencies in the directions of mesh faces in a mesh. This function does not modify mesh vertex normals, it rearranges the mesh face winding and face normals to make them all consistent. Note, you may want to call Mesh.Normals.ComputeNormals() to recompute vertex normals after calling this functions.","since":"6.0","parameters":[{"name":"countOnly","summary":"If true, then only the number of faces that would be modified is determined."}],"returns":"If countOnly=false, the number of faces that were modified. If countOnly=true, the number of faces that would be modified."},{"signature":"void Unweld(double angleToleranceRadians, bool modifyNormals)","summary":"Makes sure that faces sharing an edge and having a difference of normal greater than or equal to angleToleranceRadians have unique vertexes along that edge, adding vertices if necessary.","since":"5.0","parameters":[{"name":"angleToleranceRadians","summary":"Angle at which to make unique vertices."},{"name":"modifyNormals","summary":"Determines whether new vertex normals will have the same vertex normal as the original (false) or vertex normals made from the corresponding face normals (true)"}]},{"signature":"bool UnweldEdge(IEnumerable<int> edgeIndices, bool modifyNormals)","summary":"Adds creases to a smooth mesh by creating coincident vertices along selected edges.","since":"6.3","parameters":[{"name":"edgeIndices","summary":"An array of mesh topology edge indices."},{"name":"modifyNormals","summary":"If true, the vertex normals on each side of the edge take the same value as the face to which they belong, giving the mesh a hard edge look. If false, each of the vertex normals on either side of the edge is assigned the same value as the original normal that the pair is replacing, keeping a smooth look."}],"returns":"True if successful, False otherwise."},{"signature":"bool UnweldVertices(IEnumerable<int> topologyVertexIndices, bool modifyNormals)","summary":"Ensures that faces sharing a common topological vertex have unique indices into the Collections.MeshVertexListcollection.","since":"7.0","parameters":[{"name":"topologyVertexIndices","summary":"Topological vertex indices, from the Collections.MeshTopologyVertexListcollection, to be unwelded. Use Collections.MeshTopologyVertexList.TopologyVertexIndexto convert from vertex indices to topological vertex indices."},{"name":"modifyNormals","summary":"If true, the new vertex normals will be calculated from the face normal."}],"returns":"True if successful, False otherwise."},{"signature":"double Volume()","summary":"Compute volume of the mesh.","since":"6.0","returns":"Volume of the mesh."},{"signature":"void Weld(double angleToleranceRadians)","summary":"Makes sure that faces sharing an edge and having a difference of normal greater than or equal to angleToleranceRadians share vertexes along that edge, vertex normals are averaged.","since":"5.0","parameters":[{"name":"angleToleranceRadians","summary":"Angle at which to weld vertices."}]},{"signature":"Mesh WithDisplacement(MeshDisplacementInfo displacement)","summary":"Constructs new mesh from the current one, with displacement applied to it.","since":"6.0","parameters":[{"name":"displacement","summary":"Information on mesh displacement."}],"returns":"A new mesh with shutlining."},{"signature":"Mesh WithEdgeSoftening(double softeningRadius, bool chamfer, bool faceted, bool force, double angleThreshold)","summary":"Constructs new mesh from the current one, with edge softening applied to it.","since":"6.0","parameters":[{"name":"softeningRadius","summary":"The softening radius."},{"name":"chamfer","summary":"Specifies whether to chamfer the edges."},{"name":"faceted","summary":"Specifies whether the edges are faceted."},{"name":"force","summary":"Specifies whether to soften edges despite too large a radius."},{"name":"angleThreshold","summary":"Threshold angle (in degrees) which controls whether an edge is softened or not. The angle refers to the angles between the adjacent faces of an edge."}],"returns":"A new mesh with soft edges."},{"signature":"Mesh WithShutLining(bool faceted, double tolerance, IEnumerable<ShutLiningCurveInfo> curves)","summary":"Constructs new mesh from the current one, with shut lining applied to it.","since":"6.0","parameters":[{"name":"faceted","summary":"Specifies whether the shutline is faceted."},{"name":"tolerance","summary":"The tolerance of the shutline."},{"name":"curves","summary":"A collection of curve arguments."}],"returns":"A new mesh with shutlining. Null on failure."}]},{"namespace":"Rhino.Geometry","name":"MeshCheckParameters","dataType":"struct","summary":"Output of a mesh checking operations.","properties":[{"signature":"bool CheckForBadNormals","summary":"If true, then look for vertex normals that are not unit vectors, are zero length or vary greatly from the general direction of the face normals.","since":"7.0","property":["get","set"]},{"signature":"bool CheckForDegenerateFaces","summary":"If true, then look for triangles and quads that have zero area and quads where one sub triangle has zero area.","since":"7.0","property":["get","set"]},{"signature":"bool CheckForDisjointMeshes","summary":"If true, then look for faces in the mesh that are totally isolated from other faces in the mesh. (i.e. an island of faces, or many islands, that have a boundary of naked edges)","since":"7.0","property":["get","set"]},{"signature":"bool CheckForDuplicateFaces","summary":"If true, then look for faces that have vertexes (not necessarily vertex indexes) that are identical.","since":"7.0","property":["get","set"]},{"signature":"bool CheckForExtremelyShortEdges","summary":"If true, then look for topological edges where the distance between the endpoints is less than ExtremelyShortEdgeDistance.","since":"7.0","property":["get","set"]},{"signature":"bool CheckForInvalidNgons","summary":"If true, then look for ngons that have invalid information.","since":"7.0","property":["get","set"]},{"signature":"bool CheckForNakedEdges","summary":"If true, then look for topological edges in the mesh topology where the face count is 1. Note, this check is also made if CheckForDuplicateFaces is True but the output is not shown if CheckForNakedEdges is false.","since":"7.0","property":["get","set"]},{"signature":"bool CheckForNonManifoldEdges","summary":"If true, then look for topological edges in the mesh topology where the face count is greater than 2. Note, this check is also made if CheckForDuplicateFaces is True but the output is not shown if CheckForNonManifoldEdges is false.","since":"7.0","property":["get","set"]},{"signature":"bool CheckForRandomFaceNormals","summary":"If true, then look for adjacent faces that have the same edge orientation. This typically means that clockwise/counterclockwise orientation, and face normal are not in sync.","since":"7.0","property":["get","set"]},{"signature":"bool CheckForSelfIntersection","summary":"If true, then look for self intersections.","since":"7.0","property":["get","set"]},{"signature":"bool CheckForUnusedVertices","summary":"If true, then look for vertices that are not referenced by any face in the mesh.","since":"7.0","property":["get","set"]},{"signature":"int DegenerateFaceCount","summary":"Gets the total degenerate face count for all meshes.","since":"7.0","property":["get"]},{"signature":"int DisjointMeshCount","summary":"Gets the total count of disjoint pieces for all meshes.","since":"7.0","property":["get"]},{"signature":"int DuplicateFaceCount","summary":"Gets the total count of duplicate faces for all meshes.","since":"7.0","property":["get"]},{"signature":"int ExtremelyShortEdgeCount","summary":"Gets the total number of extremely short edges for all meshes.","since":"7.0","property":["get"]},{"signature":"int InvalidNgonCount","summary":"Gets the total number of invalid ngons for all meshes.","since":"7.0","property":["get"]},{"signature":"int NakedEdgeCount","summary":"Gets the total number of naked edges for all meshes.","since":"7.0","property":["get"]},{"signature":"int NonManifoldEdgeCount","summary":"Gets the total number of non-manifold edges for all meshes.","since":"7.0","property":["get"]},{"signature":"int NonUnitVectorNormalCount","summary":"Get the total count of normals that are not unit vectors for all meshes.","since":"7.0","property":["get"]},{"signature":"int RandomFaceNormalCount","summary":"Gets the total count of random face normals for all meshes.","since":"7.0","property":["get"]},{"signature":"int SelfIntersectingPairsCount","summary":"Gets the total count of self intersections for all meshes.","since":"7.0","property":["get"]},{"signature":"int UnusedVertexCount","summary":"Gets the total count of unused vertices for all meshes.","since":"7.0","property":["get"]},{"signature":"int VertexFaceNormalsDifferCount","summary":"Gets the total count of vertex normals that differ greatly from face normals for all meshes.","since":"7.0","property":["get"]},{"signature":"int ZeroLengthNormalCount","summary":"Gets the total count of zero length normals for all meshes.","since":"7.0","property":["get"]}],"methods":[{"signature":"static MeshCheckParameters Defaults()","summary":"Gets the default mesh check parameters.","since":"7.0","returns":"The default mesh check parameters."}]},{"namespace":"Rhino.Geometry","name":"MeshDisplacementInfo","dataType":"class","summary":"Contains mesh displacement information.","constructors":[{"signature":"MeshDisplacementInfo(RenderTexture texture, TextureMapping mapping)","summary":"Constructs a displacement information instance with default values. Users of this class should not rely on default values to stay constant across service releases.","since":"6.0"}],"properties":[{"signature":"double Black","summary":"Value considered lowest point in the displacement.","since":"6.0","property":["get","set"]},{"signature":"double BlackMove","summary":"The amount of displacement for the black color in the texture.","since":"6.0","property":["get","set"]},{"signature":"int ChannelNumber","summary":"Mapping channel number for the displacement mapping.","since":"6.0","property":["get","set"]},{"signature":"int FaceLimit","summary":"Runs a mesh reduction as a post process o simplify the result of displacement to meet the specified number of faces.","since":"6.0","property":["get","set"]},{"signature":"int FairingAmount","summary":"Straightens rough feature edges. The value specifies the number of passes.","since":"6.0","property":["get","set"]},{"signature":"Transform InstanceTransform","summary":"Instance transformation of the mesh.","since":"6.0","property":["get","set"]},{"signature":"TextureMapping Mapping","summary":"The texture mapping of the mesh.","since":"6.0","property":["get","set"]},{"signature":"Transform MappingTransform","summary":"Texture mapping transform.","since":"6.0","property":["get","set"]},{"signature":"int MemoryLimit","summary":"Specifies how much memory can be allocated for use by the displacement mesh. Value in megabytes.","since":"6.0","property":["get","set"]},{"signature":"double PostWeldAngle","summary":"Specifies the maximum angle between face normals of adjacent faces that will get welded together.","since":"6.0","property":["get","set"]},{"signature":"double RefineSensitivity","summary":"Specifies how sensitive the divider for contrasts is on the displacement texture.  \\nSpecify 1 to split all mesh edges on each refine step.  \\nSpecify 0.99 to make even slight contrasts on the displacement texture cause edges to be split.  \\nSpecifying 0.01 only splits edges where heavy contrast exists.","since":"6.0","property":["get","set"]},{"signature":"int RefineStepCount","summary":"Specifies the number of refinement passes.","since":"6.0","property":["get","set"]},{"signature":"double SweepPitch","summary":"Specifies how densely the object is initially subdivided. The lower the value, the higher the resolution of the displaced mesh.","since":"6.0","property":["get","set"]},{"signature":"RenderTexture Texture","summary":"The texture used as displacement.","since":"6.0","property":["get","set"]},{"signature":"double White","summary":"Value considered highest point of the displacement texture.","since":"6.0","property":["get","set"]},{"signature":"double WhiteMove","summary":"The amount of displacement for the white color in the texture.","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Geometry","name":"MeshExtruder","dataType":"class","summary":"Extrudes a mesh and provides preview","interfaces":["IDisposable"],"constructors":[{"signature":"MeshExtruder(Mesh inputMesh, IEnumerable<ComponentIndex> componentIndices)","summary":"Construct object to extrude given mesh faces, edges and ngons.","since":"6.3","parameters":[{"name":"inputMesh","summary":"Mesh to use as starting point. Will not be modified."},{"name":"componentIndices","summary":"Mesh faces, edges and ngons to extrude."}]}],"properties":[{"signature":"bool EdgeBasedUVN","summary":"Edge based UVN defines UVN directions according to boundary edge directions","since":"6.4","property":["get","set"]},{"signature":"MeshExtruderFaceDirectionMode FaceDirectionMode","summary":"Face direction mode determines how faces are oriented","since":"6.3","property":["get","set"]},{"signature":"bool KeepOriginalFaces","summary":"Whether or not to keep original faces.","since":"6.3","property":["get","set"]},{"signature":"Line[] PreviewLines","summary":"Gets Line objects to preview extruded mesh.","since":"6.3","property":["get"]},{"signature":"MeshExtruderParameterMode SurfaceParameterMode","summary":"Mode for creating surface parameters for extruded areas","since":"6.3","property":["get","set"]},{"signature":"MeshExtruderParameterMode TextureCoordinateMode","summary":"Mode for creating texture coordinates for extruded areas","since":"6.3","property":["get","set"]},{"signature":"Transform Transform","summary":"Transform of extrusion","since":"6.3","property":["get","set"]},{"signature":"bool UVN","summary":"Whether or not to perform extrude in UVN basis.","since":"6.3","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Dispose of this object and any unmanaged memory associated with it.","since":"6.3"},{"signature":"bool ExtrudedMesh(out Mesh extrudedMeshOut)","summary":"Creates new extruded mesh. Returns True if any edges or faces were extruded.","since":"6.3","parameters":[{"name":"extrudedMeshOut","summary":"Extruded mesh"}]},{"signature":"bool ExtrudedMesh(out Mesh extrudedMeshOut, out List<ComponentIndex> componentIndicesOut)","summary":"Creates new extruded mesh. Returns True if any edges or faces were extruded.","parameters":[{"name":"extrudedMeshOut","summary":"Extruded mesh"},{"name":"componentIndicesOut","summary":"Component indices of extruded faces and vertices"}]},{"signature":"List<int> GetWallFaces()","summary":"Return list of faces that were added to connect transformed edges/faces to non-transformed edges/faces.","since":"6.16","returns":"List of wall faces"}]},{"namespace":"Rhino.Geometry","name":"MeshExtruderFaceDirectionMode","dataType":"enum","summary":"Defines how mesh extruder decides orients faces","values":[{"signature":"Keep = 0","summary":"Maintain all face directions"},{"signature":"OrientClosedFrontOut = 1","summary":"Orient closed meshes front face out"}]},{"namespace":"Rhino.Geometry","name":"MeshExtruderParameterMode","dataType":"enum","summary":"Parameter mode for creating texture coordinates and surface parameters","values":[{"signature":"CoverWalls = 0","summary":"Stretch parameters slightly on extruded faces to cover walls"},{"signature":"KeepAndStretch = 1","summary":"Keep parameters on extruded faces and stretch on walls"}]},{"namespace":"Rhino.Geometry","name":"MeshFace","dataType":"struct","summary":"Represents the values of the four indices of a mesh face quad.  \\nIf the third and fourth values are the same, this face represents a triangle.","constructors":[{"signature":"MeshFace(int a, int b, int c)","summary":"Constructs a new triangular Mesh face.","since":"5.0","parameters":[{"name":"a","summary":"Index of first corner."},{"name":"b","summary":"Index of second corner."},{"name":"c","summary":"Index of third corner."}]},{"signature":"MeshFace(int a, int b, int c, int d)","summary":"Constructs a new quadrangular Mesh face.","since":"5.0","parameters":[{"name":"a","summary":"Index of first corner."},{"name":"b","summary":"Index of second corner."},{"name":"c","summary":"Index of third corner."},{"name":"d","summary":"Index of fourth corner."}]}],"properties":[{"signature":"static MeshFace Unset","summary":"Gets an Unset MeshFace. Unset faces have Int32.MinValue for all corner indices.","since":"5.0","property":["get"]},{"signature":"int A","summary":"Gets or sets the first corner index of the mesh face.","since":"5.0","property":["get","set"]},{"signature":"int B","summary":"Gets or sets the second corner index of the mesh face.","since":"5.0","property":["get","set"]},{"signature":"int C","summary":"Gets or sets the third corner index of the mesh face.","since":"5.0","property":["get","set"]},{"signature":"int D","summary":"Gets or sets the fourth corner index of the mesh face. If D equals C, the mesh face is considered to be a triangle rather than a quad.","since":"5.0","property":["get","set"]},{"signature":"bool IsQuad","summary":"Gets a value indicating whether or not this mesh face is a quad. A mesh face is considered to be a triangle when C does not equal D, thus it is possible for an Invalid mesh face to also be a quad.","since":"5.0","property":["get"]},{"signature":"bool IsTriangle","summary":"Gets a value indicating whether or not this mesh face is a triangle. A mesh face is considered to be a triangle when C equals D, thus it is possible for an Invalid mesh face to also be a triangle.","since":"5.0","property":["get"]}],"methods":[{"signature":"int CompareTo(MeshFace other)","summary":"Compares this MeshFacewith another MeshFace and returns a value of 1, 0, or -1, referring to dictionary order.  \\nIndex evaluation priority is first A, then B, then C, then D.","since":"6.0","parameters":[{"name":"other","summary":"The other MeshFaceto use in comparison."}],"returns":"0: if this is identical to other  \\n-1: if this < other. Priority is for index of corner A first, then B, then C, then D.  \\n+1: otherwise."},{"signature":"bool Equals(MeshFace other)","summary":"Returns a value indicating whether the other mesh face has precisely the same value as the current one.","since":"6.0","parameters":[{"name":"other","summary":"The other mesh face for comparison."}],"returns":"True if the other face is, also orderly, equal to the present one; otherwise false."},{"signature":"bool Equals(object obj)","summary":"Returns a value indicating whether the other object obj has precisely the same value as the current one.","parameters":[{"name":"obj","summary":"Any object the represents the other mesh face for comparison."}],"returns":"True if obj is a mesh face that, also orderly, equals to the present one; otherwise false."},{"signature":"MeshFace Flip()","summary":"Reverses the orientation of the face by swapping corners. The first corner is always maintained.","since":"5.0"},{"signature":"int GetHashCode()","summary":"Returns a runtime-stable hash code for the current mesh face. You are not allowed to rely on persistence of this hash code in serialization, but for each version of RhinoCommon, this hash code will be the same for each mesh face.","returns":"A non-unique integer that represents this mesh face."},{"signature":"bool IsValid()","summary":"Gets a value indicating whether or not this mesh face is considered to be valid. Note that even valid mesh faces could potentially be invalid in the context of a specific Mesh, if one or more of the corner indices exceeds the number of vertices on the mesh. If you want to perform a complete validity check, use IsValid(int) instead.","since":"5.0"},{"signature":"bool IsValid(int vertexCount)","summary":"Gets a value indicating whether or not this mesh face is considered to be valid. Unlike the simple IsValid function, this function takes upper bound indices into account.","since":"5.0","parameters":[{"name":"vertexCount","summary":"Number of vertices in the mesh that this face is a part of."}],"returns":"True if the face is considered valid, False if not."},{"signature":"bool IsValid(Point3d[] points)","summary":"Gets a value indicating whether or not this mesh face is considered to be valid. Unlike the simple IsValid function, this function takes actual point locations into account.","since":"6.0","parameters":[{"name":"points","summary":"Array of vertices with which to validate the face."}],"returns":"True if the face is considered valid, False if not."},{"signature":"bool IsValidEx(ref Point3d[] points)","summary":"Gets a value indicating whether or not this mesh face is considered to be valid. Unlike the simple IsValid function, this function takes actual point locations into account.","since":"6.5","parameters":[{"name":"points","summary":"Array of vertices with which to validate the face."}],"returns":"True if the face is considered valid, False if not."},{"signature":"bool Repair(Point3d[] points)","summary":"Attempts to repair this mesh face by taking both face indexes and actual vertex locations into account.","since":"6.0","parameters":[{"name":"points","summary":"Array of vertices with which to consider when repairing the face."}],"returns":"True if the face was repaired, False if not."},{"signature":"bool RepairEx(ref Point3d[] points)","summary":"Attempts to repair this mesh face by taking both face indexes and actual vertex locations into account.","since":"6.5","parameters":[{"name":"points","summary":"Array of vertices with which to consider when repairing the face."}],"returns":"True if the face was repaired, False if not."},{"signature":"void Set(int a, int b, int c)","summary":"Sets all the corners for this face as a triangle.","since":"5.0","parameters":[{"name":"a","summary":"Index of first corner."},{"name":"b","summary":"Index of second corner."},{"name":"c","summary":"Index of third corner."}]},{"signature":"void Set(int a, int b, int c, int d)","summary":"Sets all the corners for this face as a quad.","since":"5.0","parameters":[{"name":"a","summary":"Index of first corner."},{"name":"b","summary":"Index of second corner."},{"name":"c","summary":"Index of third corner."},{"name":"d","summary":"Index of fourth corner."}]},{"signature":"string ToString()","summary":"Returns a string representation for this MeshFace. This is to provide a meaningful visualization of this structure and is subject to change in newer releases.","returns":"The string representation."}]},{"namespace":"Rhino.Geometry","name":"MeshingParameters","dataType":"class","summary":"Represents settings used for creating a mesh representation of a brep or surface.","interfaces":["IDisposable"],"constructors":[{"signature":"MeshingParameters()","summary":"Initializes a new instance with default values.  \\nInitial values are same as .","since":"5.0"},{"signature":"MeshingParameters(double density)","summary":"Initializes a new instance with simple values, similar to that of Rhino\'s meshing slider interface.","since":"6.0","parameters":[{"name":"density","summary":"The density and number of mesh polygons, where 0.0 <= density <= 1.0, where 0 quickly creates coarse meshes, and 1 slowly creates dense meshes."}]},{"signature":"MeshingParameters(double density, double minimumEdgeLength)","summary":"Initializes a new instance with simple values, similar to that of Rhino\'s meshing slider interface.","since":"6.0","parameters":[{"name":"density","summary":"The density and number of mesh polygons, where 0.0 <= density <= 1.0, where 0 quickly creates coarse meshes, and 1 slowly creates dense meshes."},{"name":"minimumEdgeLength","summary":"The minimum allowed mesh edge length."}]}],"properties":[{"signature":"static MeshingParameters Coarse","summary":"Gets mesh creation parameters for coarse meshing.  \\nThis corresponds with the \\"Jagged and Faster\\" default in Rhino.","since":"5.0","property":["get"]},{"signature":"static MeshingParameters Default","summary":"Gets mesh creation parameters to create the default render mesh. Only use this if you plan on specifying your own custom meshing parameters.","since":"5.0","property":["get"]},{"signature":"static MeshingParameters DefaultAnalysisMesh","summary":"Gets mesh creation parameters to create the default analysis mesh.","since":"6.0","property":["get"]},{"signature":"static MeshingParameters FastRenderMesh","summary":"Gets mesh creation parameters to create the a render mesh when meshing speed is preferred over mesh quality.","since":"6.0","property":["get"]},{"signature":"static MeshingParameters Minimal","summary":"Gets minimal meshing parameters.","since":"5.0","property":["get"]},{"signature":"static MeshingParameters QualityRenderMesh","summary":"Gets mesh creation parameters to create the a render mesh when mesh quality is preferred over meshing speed.","since":"6.0","property":["get"]},{"signature":"static MeshingParameters Smooth","summary":"Gets mesh creation parameters for smooth meshing.  \\nThis corresponds with the \\"Smooth and Slower\\" default in Rhino.","since":"5.0","property":["get"]},{"signature":"bool ClosedObjectPostProcess","summary":"Gets or sets a value indicating whether or not to post process non-closed meshes that should be closed. If the Brep being meshed is closed, JaggedSeams = false, and ClosedObjectPostProcess = true, and the resulting mesh is not closed, then a post meshing process is applied to find and close gaps in the mesh. Typically the resulting mesh is not closed because the input Brep has a geometric flaw, like loops in trimming curve.","since":"6.0","property":["get","set"]},{"signature":"bool ComputeCurvature","summary":"Gets or sets a value indicating whether or not surface curvature data will be embedded in the mesh.","since":"5.0","property":["get","set"]},{"signature":"double GridAmplification","summary":"Gets or sets the grid amplification factor. Values lower than 1.0 will decrease the number of initial quads, values higher than 1.0 will increase the number of initial quads.","since":"5.0","property":["get","set"]},{"signature":"double GridAngle","summary":"Gets or sets the maximum allowed angle difference (in radians) for a single sampling quad. The angle pertains to the surface normals.","since":"5.0","property":["get","set"]},{"signature":"double GridAspectRatio","summary":"Gets or sets the maximum allowed aspect ratio of sampling quads.","since":"5.0","property":["get","set"]},{"signature":"int GridMaxCount","summary":"Gets or sets the maximum number of grid quads in the initial sampling grid.","since":"5.0","property":["get","set"]},{"signature":"int GridMinCount","summary":"Gets or sets the minimum number of grid quads in the initial sampling grid.","since":"5.0","property":["get","set"]},{"signature":"bool JaggedSeams","summary":"Gets or sets whether or not the mesh is allowed to have jagged seams. When this flag is set to true, meshes on either side of a Brep Edge will not match up.","since":"5.0","property":["get","set"]},{"signature":"double MaximumEdgeLength","summary":"Gets or sets the maximum allowed mesh edge length.","since":"5.0","property":["get","set"]},{"signature":"double MinimumEdgeLength","summary":"Gets or sets the minimum allowed mesh edge length.","since":"5.0","property":["get","set"]},{"signature":"double MinimumTolerance","summary":"Gets or sets the minimum tolerance.","since":"5.0","property":["get","set"]},{"signature":"double RefineAngle","summary":"Gets or sets the mesh parameter refine angle.","since":"5.0","property":["get","set"]},{"signature":"bool RefineGrid","summary":"Gets or sets a value indicating whether or not the sampling grid can be refined when certain tolerances are not met.","since":"5.0","property":["get","set"]},{"signature":"double RelativeTolerance","summary":"Gets or sets the relative tolerance.","since":"5.0","property":["get","set"]},{"signature":"bool SimplePlanes","summary":"Gets or sets a value indicating whether or not planar areas are allowed to be meshed in a simplified manner.","since":"5.0","property":["get","set"]},{"signature":"MeshingParameterTextureRange TextureRange","summary":"Gets or sets how and if textures will be packed.","since":"6.0","property":["get","set"]},{"signature":"double Tolerance","summary":"Gets or sets the maximum allowed edge deviation. This tolerance is measured between the center of the mesh edge and the surface.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static MeshingParameters DocumentCurrentSetting(RhinoDoc doc)","summary":"Gets the MeshingParameters that are currently set for a document. These are the same settings that are shown in the DocumentProperties \\"mesh settings\\" user interface.","since":"5.0","parameters":[{"name":"doc","summary":"A Rhino document to query."}],"returns":"Meshing parameters of the document."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"}]},{"namespace":"Rhino.Geometry","name":"MeshingParameterStyle","dataType":"enum","summary":"Type of Mesh Parameters used by the RhinoDoc for meshing objects","since":"5.1","values":[{"signature":"None = 0","summary":"No style"},{"signature":"Fast = 1"},{"signature":"Quality = 2"},{"signature":"Custom = 9"},{"signature":"PerObject = 10"}]},{"namespace":"Rhino.Geometry","name":"MeshingParameterTextureRange","dataType":"enum","summary":"Defines how to pack render/meshes textures.","since":"6.0","values":[{"signature":"Unset = 0","summary":"This value is not set."},{"signature":"UnpackedUnscaledNormalized = 1","summary":"Each face has a normalized texture range [0,1]x[0,1]. The normalized coordinate is calculated using the entire surface domain.  For meshes of trimmed surfaces when the active area is a small subset of the entire surface, there will be large regions of unused texture space in [0,1]x[0,1].  When the 3d region being meshed is far from being square-ish, there will be a substantial amount of distortion mapping [0,1]x[0,1] texture space to the 3d mesh."},{"signature":"PackedScaledNormalized = 2","summary":"Each face is assigned a texture range that is a sub-rectangle of [0,1]x[0,1].  The sub-rectangles are mutually disjoint and packed into [0,1]x[0,1] in a way that minimizes distortion and maximizes the coverage of [0,1]x[0,1]. When the surface or surfaces being meshed are trimmed, this option takes into account only the region of the base surface the mesh covers and uses as much of [0,1]x[0,1] as possible. (default)"}]},{"namespace":"Rhino.Geometry","name":"MeshNgon","dataType":"class","summary":"Represents a mesh ngon.  \\nWhen retrieved from the Ngon property of a mesh, this contains faces that have edge valence strictly higher than 4.  \\nWhen retrieving Ngons from , this might contain also triangles and quads.","interfaces":["IEquatable<MeshNgon>","IComparable<MeshNgon>","IComparable"],"properties":[{"signature":"static MeshNgon Empty","summary":"Gets an empty MeshNgon.","since":"6.0","property":["get"]},{"signature":"int BoundaryVertexCount","summary":"Get the number of vertices in this ngon.  MeshNgonabout length information.","since":"6.0","property":["get"]},{"signature":"int FaceCount","summary":"Get the number of faces in this ngon.","since":"6.0","property":["get"]}],"methods":[{"signature":"static MeshNgon Create(IList<int> meshVertexIndexList, IList<int> meshFaceIndexList)","summary":"Constructs an ngon from lists of mesh vertex and face indexes.","since":"6.0","parameters":[{"name":"meshVertexIndexList","summary":"A list of mesh vertex indexes that define the outer boundary of the ngon. The mesh vertex indexes must be in the correct order."},{"name":"meshFaceIndexList","summary":"A list of mesh face indexes that define the interior of the ngon. The mesh face indexes may be in any order."}]},{"signature":"uint[] BoundaryVertexIndexList()","summary":"Get the outer boundary mesh vertex list of the ngon.  \\nVertices are sorted counterclockwise with respect to the direction of the face, although the degree by which vertex normals will respect this might vary.","since":"6.0","returns":"A list of mesh vertex indexes."},{"signature":"int CompareTo(MeshNgon otherNgon)","summary":"Compares this MeshNgonwith otherNgon and returns a value of 1, 0, or -1.  \\nPriority is for vertex count, then face count, then vertex index list values, then face index list values.","since":"6.0","parameters":[{"name":"otherNgon","summary":"The other MeshNgonto use in comparison."}],"returns":"0: if this is identical to otherNgon  \\n-1: if this < otherNgon.  \\n+1: if this > otherNgon."},{"signature":"bool Equals(MeshNgon otherNgon)","summary":"Determines if this ngon and otherNgon are identical.","since":"6.0","parameters":[{"name":"otherNgon","summary":"The other ngon for comparison."}],"returns":"True if otherNgon is identical to this ngon; otherwise false."},{"signature":"bool Equals(object otherObj)","summary":"Determines if otherObj is a MeshNgon and is identical to this ngon.","parameters":[{"name":"otherObj","summary":"Any object the represents the other mesh face for comparison."}],"returns":"True if otherObj is a MeshNgon and is identical to this ngon; otherwise false."},{"signature":"uint[] FaceIndexList()","summary":"Get the ngon\'s mesh face index list.","since":"6.0","returns":"A list of mesh face indexes."},{"signature":"int GetHashCode()","summary":"Returns a runtime-stable hash code for the current mesh ngon. You are not allowed to rely on persistence of this hash code in serialization, but for each instance of the application, this hash code will be the same for ngons with identical vertex and face lists.","returns":"A non-unique integer that represents this mesh ngon."},{"signature":"void Set(IList<int> meshVertexIndexList, IList<int> meshFaceIndexList)","summary":"Set the ngon vertex and face index lists.","since":"6.0","parameters":[{"name":"meshVertexIndexList","summary":"A list of mesh vertex indexes that define the outer boundary of the ngon. The mesh vertex indexes must be in the correct order."},{"name":"meshFaceIndexList","summary":"A list of mesh face indexes that define the interior of the ngon. The mesh face indexes may be in any order."}]},{"signature":"string ToString()","summary":"Returns a string representation for this MeshNgon. This is to provide a meaningful visualization of this structure and is subject to change in newer releases.","returns":"The string representation."}]},{"namespace":"Rhino.Geometry","name":"MeshPart","dataType":"class","summary":"Represents a portion of a mesh for partitioning","properties":[{"signature":"int EndFaceIndex","summary":"End of subinterval of parent mesh face array","since":"5.6","property":["get"]},{"signature":"int EndVertexIndex","summary":"End of subinterval of parent mesh vertex array","since":"5.6","property":["get"]},{"signature":"int StartFaceIndex","summary":"Start of subinterval of parent mesh face array","since":"5.6","property":["get"]},{"signature":"int StartVertexIndex","summary":"Start of subinterval of parent mesh vertex array","since":"5.6","property":["get"]},{"signature":"int TriangleCount","since":"5.6","property":["get"]},{"signature":"int VertexCount","summary":"EndVertexIndex - StartVertexIndex","since":"5.6","property":["get"]}]},{"namespace":"Rhino.Geometry","name":"MeshPipeCapStyle","dataType":"enum","summary":"Enumerates methods to end a mesh pipe.","values":[{"signature":"None = 0","summary":"Capping is skipped. The resulting object will be simpler."},{"signature":"Flat = 1","summary":"A flat surface will cap the pipe."},{"signature":"Box = 2","summary":"A simple construction will cap the pipe."},{"signature":"Dome = 3","summary":"A meridians-and-parallels hemisphere construction will cap the pipe."}]},{"namespace":"Rhino.Geometry","name":"MeshPoint","dataType":"class","summary":"Represents a point that is found on a mesh.","properties":[{"signature":"ComponentIndex ComponentIndex","summary":"Gets the component index of the intersecting element in the mesh.","since":"5.0","property":["get"]},{"signature":"int EdgeIndex","summary":"When set, EdgeIndex is an index of an edge in the mesh\'s edge list.","since":"5.0","property":["get"]},{"signature":"double EdgeParameter","summary":"Edge parameter when found.","since":"5.0","property":["get"]},{"signature":"int FaceIndex","summary":"FaceIndex is an index of a face in mesh.Faces. When ComponentIndex refers to a vertex, any face that uses the vertex may appear as FaceIndex.  When ComponenctIndex refers to an Edge or EdgeIndex is set, then any face that uses that edge may appear as FaceIndex.","since":"5.0","property":["get"]},{"signature":"Mesh Mesh","summary":"The mesh that is related to this point.","since":"5.0","property":["get"]},{"signature":"Point3d Point","summary":"Gets the location (position) of this point.","since":"5.0","property":["get"]},{"signature":"double[] T","summary":"Barycentric quad coordinates for the point on the mesh face mesh.Faces[FaceIndex].  If the face is a triangle disregard T[3] (it should be set to 0.0). If the face is a quad and is split between vertexes 0 and 2, then T[3] will be 0.0 when point is on the triangle defined by vi[0], vi[1], vi[2], and T[1] will be 0.0 when point is on the triangle defined by vi[0], vi[2], vi[3]. If the face is a quad and is split between vertexes 1 and 3, then T[2] will be 0.0 when point is on the triangle defined by vi[0], vi[1], vi[3], and m_t[0] will be 0.0 when point is on the triangle defined by vi[1], vi[2], vi[3].","since":"5.0","property":["get"]},{"signature":"char Triangle","summary":"Face triangle where the intersection takes place:  \\n0 is unset  \\nA is 0,1,2  \\nB is 0,2,3  \\nC is 0,1,3  \\nD is 1,2,3","since":"5.0","property":["get"]}],"methods":[{"signature":"bool GetTriangle(out int a, out int b, out int c)","summary":"Gets the mesh face indices of the triangle where the intersection is on the face takes into consideration the way the quad was split during the intersection.","since":"5.0"}]},{"namespace":"Rhino.Geometry.MeshRefinements","name":"CreaseEdges","dataType":"enum","summary":"Defines the way naked edges are handled.","since":"6.8","values":[{"signature":"    NakedFixed","summary":"Naked edges will not move or be modified."},{"signature":"    NakedSmooth","summary":"The naked edge will tend toward a spline."},{"signature":"    CornerFixedOtherCreased","summary":"Corners (2-sided vertices) will be fixed, while other naked vertices will tend toward a spline."},{"signature":"    Auto = 3","summary":"Unwelded vertices become creases, and welded are smooth."}]},{"namespace":"Rhino.Geometry.MeshRefinements","name":"LoopFormula","dataType":"enum","summary":"Enumerates the alternative Loop implementations.","since":"6.0","values":[{"signature":"Loop = 0","summary":"The original Loop formula."},{"signature":"Warren = 1","summary":"Warren\'s improved formula."},{"signature":"WarrenWeimer = 2","summary":"The formula as explained by Weimer, improving over Warren\'s."}]},{"namespace":"Rhino.Geometry.MeshRefinements","name":"RefinementSettings","dataType":"class","summary":"Defines the way a mesh refinement modifier works.","constructors":[{"signature":"RefinementSettings()","summary":"Creates a default operation settings object.","since":"6.0"}],"properties":[{"signature":"CancellationToken ContinueRequest","summary":"A token to request computation termination.","since":"6.0","property":["get","set"]},{"signature":"bool HasPull","summary":"Gets a value indicating whether this subdivision should create a result on a specific surface.","since":"6.0","property":["get"]},{"signature":"int Level","summary":"The level of subdivision to achieve.","since":"6.0","property":["get","set"]},{"signature":"CreaseEdges NakedEdgeMode","summary":"Set this property to define how naked edges should be treated.","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Geometry","name":"MeshThicknessMeasurement","dataType":"struct","summary":"Thickness measurement used in the mesh thickness solver.","constructors":[{"signature":"MeshThicknessMeasurement(int meshIndex, int vertexIndex, double thickness, Point3d point, Point3d oppositePoint)","summary":"Create a new thickness measurement.","since":"6.0","parameters":[{"name":"meshIndex","summary":"Index of mesh within collection of meshes."},{"name":"vertexIndex","summary":"Index of mesh vertex."},{"name":"thickness","summary":"Thickness of mesh at vertex."},{"name":"point","summary":"Vertex location."},{"name":"oppositePoint","summary":"Opposite location."}]}],"properties":[{"signature":"int MeshIndex","summary":"Gets the index of the mesh associated with this thickness measurement.","since":"6.0","property":["get"]},{"signature":"Point3d OppositePoint","summary":"Gets the point opposite to the measurement point.","since":"6.0","property":["get"]},{"signature":"Point3d Point","summary":"Gets the location of the thickness measurement.","since":"6.0","property":["get"]},{"signature":"double Thickness","summary":"Gets the local thickness of the mesh.","since":"6.0","property":["get"]},{"signature":"int VertexIndex","summary":"Gets the index of the vertex associated with this thickness measurement.","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Geometry","name":"MeshType","dataType":"enum","summary":"Defines enumerated values for various mesh types.","since":"5.0","values":[{"signature":"Default = 0","summary":"The default mesh."},{"signature":"Render = 1","summary":"The render mesh."},{"signature":"Analysis = 2","summary":"The analysis mesh."},{"signature":"Preview = 3","summary":"The preview mesh."},{"signature":"Any = 4","summary":"Any mesh that is available."}]},{"namespace":"Rhino.Geometry","name":"MeshUnsafeLock","dataType":"class","summary":"Permits access to the underlying mesh raw data structures in an unsafe way.","remarks":"This lock object needs to be disposed before using the Mesh in other calculations and this can be achieved with the using keyword (Using in VB.Net).","interfaces":["IDisposable"],"methods":[{"signature":"MeshFace* FacesArray(out int length)","summary":"Retrieves a pointer to the raw faces array, which uses 4 integers for each face.  MeshFace.","since":"6.20","parameters":[{"name":"length","summary":"The length of the array. This value is returned by reference (out in C#)."}],"returns":"The beginning of the vertex array. Item 0 is the first vertex, and item length-1 is the last valid one."},{"signature":"Vector3f* NormalVector3fArray(out int length)","summary":"Retrieves a pointer to the raw mesh vertex normal array, which uses vectors defined with single precision floating point numbers, or throws an exception if none is available.","since":"6.20","parameters":[{"name":"length","summary":"The length of the array. This value is returned by reference (out in C#)."}],"returns":"The beginning of the vertex array. Item 0 is the first vertex, and item length-1 is the last valid one."},{"signature":"void Release()","summary":"Releases the lock and updates the underlying unmanaged data structures.","since":"6.0"},{"signature":"Point3d* VertexPoint3dArray(out int length)","summary":"Retrieves a pointer to the raw mesh vertex array, which uses coordinates defined with double precision floating point numbers, or throws an exception if none is available.","since":"6.20","parameters":[{"name":"length","summary":"The length of the array. This value is returned by reference (out in C#)."}],"returns":"The beginning of the vertex array. Item 0 is the first vertex, and item length-1 is the last valid one. If no array is available, None is returned."},{"signature":"Point3f* VertexPoint3fArray(out int length)","summary":"Retrieves a pointer to the raw mesh vertex array, which uses coordinates defined with single precision floating point numbers, or None if none is available.","since":"6.0","parameters":[{"name":"length","summary":"The length of the array. This value is returned by reference (out in C#). 0 is returned when there is no single precision array."}],"returns":"The beginning of the vertex array. Item 0 is the first vertex, and item length-1 is the last valid one. If no array is available, None is returned."}]},{"namespace":"Rhino.Geometry","name":"MorphControl","dataType":"class","summary":"Represents a geometry that is able to control the morphing behavior of some other geometry.","baseclass":"Rhino.Geometry.GeometryBase","constructors":[{"signature":"MorphControl(NurbsCurve originCurve, NurbsCurve targetCurve)","summary":"Constructs a MorphControl that allows for morphing between two curves.","since":"5.0","parameters":[{"name":"originCurve","summary":"The origin curve for morphing."},{"name":"targetCurve","summary":"The target curve for morphing."}]}],"properties":[{"signature":"NurbsCurve Curve","summary":"Returns the morph control\'s curve.  While this should never be null, the calling function should check.","since":"6.0","property":["get"]},{"signature":"bool PreserveStructure","summary":"True if the morph should be done in a way that preserves the structure of the geometry.  In particular, for NURBS objects, True  means that only the control points are moved.  The PreserveStructure value does not affect the way meshes and points are morphed. The default is false.","since":"5.0","property":["get","set"]},{"signature":"bool QuickPreview","summary":"True if the morph should be done as quickly as possible because the result is being used for some type of dynamic preview.  If QuickPreview is true, the tolerance may be ignored. The QuickPreview value does not affect the way meshes and points are morphed. The default is false.","since":"5.0","property":["get","set"]},{"signature":"double SpaceMorphTolerance","summary":"The 3d fitting tolerance used when morphing surfaces and breps. The default is 0.0 and any value <= 0.0 is ignored by morphing functions. The value returned by Tolerance does not affect the way meshes and points are morphed.","since":"5.0","property":["get","set"]},{"signature":"NurbsSurface Surface","summary":"Returns the morph control\'s surface.  While this should never be null, the calling function should check.","since":"6.0","property":["get"]}],"methods":[{"signature":"bool Morph(GeometryBase geometry)","summary":"Applies the space morph to geometry.","since":"5.0","parameters":[{"name":"geometry","summary":"The geometry to be morphed."}],"returns":"True on success, False on failure."}]},{"namespace":"Rhino.Geometry.Morphs","name":"BendSpaceMorph","dataType":"class","summary":"Deforms objects by bending along a spine arc.","baseclass":"Rhino.Geometry.SpaceMorph","interfaces":["IDisposable"],"constructors":[{"signature":"BendSpaceMorph(Point3d start, Point3d end, Point3d point, bool straight, bool symmetric)","summary":"Constructs a bend space morph.","since":"5.9","parameters":[{"name":"start","summary":"Start of spine that represents the original orientation of the object."},{"name":"end","summary":"End of spine."},{"name":"point","summary":"Point to bend through."},{"name":"straight","summary":"If false, then point determines the region to bend. If true, only the spine region is bent."},{"name":"symmetric","summary":"If false, then only one end of the object bends. If true, then the object will bend symmetrically around the center if you start the spine in the middle of the object."}]},{"signature":"BendSpaceMorph(Point3d start, Point3d end, Point3d point, double angle, bool straight, bool symmetric)","summary":"Constructs a bend space morph.","since":"5.9","parameters":[{"name":"start","summary":"Start of spine that represents the original orientation of the object."},{"name":"end","summary":"End of spine."},{"name":"point","summary":"Used for bend direction."},{"name":"angle","summary":"Bend angle in radians."},{"name":"straight","summary":"If false, then point determines the region to bend. If true, only the spine region is bent."},{"name":"symmetric","summary":"If false, then only one end of the object bends. If true, then the object will bend symmetrically around the center if you start the spine in the middle of the object."}]}],"properties":[{"signature":"bool IsValid","summary":"Returns True if the space morph definition is valid, False otherwise.","since":"5.9","property":["get"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.9"},{"signature":"Point3d MorphPoint(Point3d point)","summary":"Morphs an Euclidean point.","since":"5.9","parameters":[{"name":"point","summary":"A point that will be morphed by this object."}],"returns":"Resulting morphed point."}]},{"namespace":"Rhino.Geometry.Morphs","name":"FlowSpaceMorph","dataType":"class","summary":"Re-aligns objects from a base curve to a target curve.","baseclass":"Rhino.Geometry.SpaceMorph","interfaces":["IDisposable"],"constructors":[{"signature":"FlowSpaceMorph(Curve curve0, Curve curve1, bool preventStretching)","summary":"Constructs a flow space morph.","since":"5.9","parameters":[{"name":"curve0","summary":"Base curve."},{"name":"curve1","summary":"Target curve."},{"name":"preventStretching","summary":""}]},{"signature":"FlowSpaceMorph(Curve curve0, Curve curve1, bool reverseCurve0, bool reverseCurve1, bool preventStretching)","summary":"Constructs a flow space morph.","since":"5.9","parameters":[{"name":"curve0","summary":"Base curve."},{"name":"curve1","summary":"Target curve."},{"name":"reverseCurve0","summary":"If true, then direction of curve0 is reversed."},{"name":"reverseCurve1","summary":"If true, then direction of curve1 is reversed."},{"name":"preventStretching","summary":"If true, the length of the objects along the curve directions are not changed. If false, objects are stretched or compressed in the curve direction so that the relationship to the target curve is the same as it is to the base curve."}]}],"properties":[{"signature":"bool IsValid","summary":"Returns True if the space morph definition is valid, False otherwise.","since":"5.9","property":["get"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.9"},{"signature":"Point3d MorphPoint(Point3d point)","summary":"Morphs an Euclidean point.","since":"5.9","parameters":[{"name":"point","summary":"A point that will be morphed by this object."}],"returns":"Resulting morphed point."}]},{"namespace":"Rhino.Geometry.Morphs","name":"MaelstromSpaceMorph","dataType":"class","summary":"Deforms objects in a spiral as if they were caught in a whirlpool.","baseclass":"Rhino.Geometry.SpaceMorph","interfaces":["IDisposable"],"constructors":[{"signature":"MaelstromSpaceMorph(Plane plane, double radius0, double radius1, double angle)","summary":"Constructs a maelstrom space morph.","since":"5.9","parameters":[{"name":"plane","summary":"Plane on which the base circle will lie. Origin of the plane will be the center point of the circle."},{"name":"radius0","summary":"First radius."},{"name":"radius1","summary":"Second radius."},{"name":"angle","summary":"Coil angle in radians."}]}],"properties":[{"signature":"bool IsValid","summary":"Returns True if the space morph definition is valid, False otherwise.","since":"5.9","property":["get"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.9"},{"signature":"Point3d MorphPoint(Point3d point)","summary":"Morphs an Euclidean point.","since":"5.9","parameters":[{"name":"point","summary":"A point that will be morphed by this object."}],"returns":"Resulting morphed point."}]},{"namespace":"Rhino.Geometry.Morphs","name":"SplopSpaceMorph","dataType":"class","summary":"Rotates, scales, and wraps objects on a surface.","baseclass":"Rhino.Geometry.SpaceMorph","interfaces":["IDisposable"],"constructors":[{"signature":"SplopSpaceMorph(Plane plane, Surface surface, Point2d surfaceParam)","summary":"Constructs a flow space morph.","since":"5.9","parameters":[{"name":"plane","summary":"Source plane of deformation."},{"name":"surface","summary":"Surface to wrap objects onto."},{"name":"surfaceParam","summary":"U,V parameter on surface used for orienting."}]},{"signature":"SplopSpaceMorph(Plane plane, Surface surface, Point2d surfaceParam, double scale)","summary":"Constructs a flow space morph.","since":"5.9","parameters":[{"name":"plane","summary":"Source plane of deformation."},{"name":"surface","summary":"Surface to wrap objects onto."},{"name":"surfaceParam","summary":"U,V parameter on surface used for orienting."},{"name":"scale","summary":"Scale factor."}]},{"signature":"SplopSpaceMorph(Plane plane, Surface surface, Point2d surfaceParam, double scale, double angle)","summary":"Constructs a flow space morph.","since":"5.9","parameters":[{"name":"plane","summary":"Source plane of deformation."},{"name":"surface","summary":"Surface to wrap objects onto."},{"name":"surfaceParam","summary":"U,V parameter on surface used for orienting."},{"name":"scale","summary":"Scale factor. To ignore, use Rhino.RhinoMath.UnsetValue."},{"name":"angle","summary":"Rotation angle in radians. To ignore, use Rhino.RhinoMath.UnsetValue."}]}],"properties":[{"signature":"bool IsValid","summary":"Returns True if the space morph definition is valid, False otherwise.","since":"5.9","property":["get"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.9"},{"signature":"Point3d MorphPoint(Point3d point)","summary":"Morphs an Euclidean point.","since":"5.9","parameters":[{"name":"point","summary":"A point that will be morphed by this object."}],"returns":"Resulting morphed point."}]},{"namespace":"Rhino.Geometry.Morphs","name":"SporphSpaceMorph","dataType":"class","summary":"Deforms an object from a source surface to a target surface.","baseclass":"Rhino.Geometry.SpaceMorph","interfaces":["IDisposable"],"constructors":[{"signature":"SporphSpaceMorph(Surface surface0, Surface surface1)","summary":"Constructs a Sporph space morph.","since":"5.9","parameters":[{"name":"surface0","summary":"Base surface."},{"name":"surface1","summary":"Target surface."}]},{"signature":"SporphSpaceMorph(Surface surface0, Surface surface1, Point2d surface0Param, Point2d surface1Param)","summary":"Constructs a Sporph space morph.","since":"5.9","parameters":[{"name":"surface0","summary":"Base surface."},{"name":"surface1","summary":"Target surface."},{"name":"surface0Param","summary":"U,V parameter on surface0 used for orienting."},{"name":"surface1Param","summary":"U,V parameter on surface1 used for orienting."}]}],"properties":[{"signature":"bool IsValid","summary":"Returns True if the space morph definition is valid, False otherwise.","since":"5.9","property":["get"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.9"},{"signature":"Point3d MorphPoint(Point3d point)","summary":"Morphs an Euclidean point.","since":"5.9","parameters":[{"name":"point","summary":"A point that will be morphed by this object."}],"returns":"Resulting morphed point."}]},{"namespace":"Rhino.Geometry.Morphs","name":"StretchSpaceMorph","dataType":"class","summary":"Deforms objects toward or away from a specified axis.","baseclass":"Rhino.Geometry.SpaceMorph","interfaces":["IDisposable"],"constructors":[{"signature":"StretchSpaceMorph(Point3d start, Point3d end, double length)","summary":"Constructs a stretch space morph.","since":"5.9","parameters":[{"name":"start","summary":"Start of stretch axis."},{"name":"end","summary":"End of stretch axis.>"},{"name":"length","summary":"Length of new stretch axis."}]},{"signature":"StretchSpaceMorph(Point3d start, Point3d end, Point3d point)","summary":"Constructs a stretch space morph.","since":"5.9","parameters":[{"name":"start","summary":"Start of stretch axis."},{"name":"end","summary":"End of stretch axis.>"},{"name":"point","summary":"End of new stretch axis."}]}],"properties":[{"signature":"bool IsValid","summary":"Returns True if the space morph definition is valid, False otherwise.","since":"5.9","property":["get"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.9"},{"signature":"Point3d MorphPoint(Point3d point)","summary":"Morphs an Euclidean point.","since":"5.9","parameters":[{"name":"point","summary":"A point that will be morphed by this object."}],"returns":"Resulting morphed point."}]},{"namespace":"Rhino.Geometry.Morphs","name":"TaperSpaceMorph","dataType":"class","summary":"Deforms objects toward or away from a specified axis.","baseclass":"Rhino.Geometry.SpaceMorph","interfaces":["IDisposable"],"constructors":[{"signature":"TaperSpaceMorph(Point3d start, Point3d end, double startRadius, double endRadius, bool bFlat, bool infiniteTaper)","summary":"Constructs a taper space morph.","since":"5.9","parameters":[{"name":"start","summary":"Start of the taper axis."},{"name":"end","summary":"End of the taper axis."},{"name":"startRadius","summary":"Radius at start point."},{"name":"endRadius","summary":"Radius at end point."},{"name":"bFlat","summary":"If true, then a one-directional, one-dimensional taper is created."},{"name":"infiniteTaper","summary":"If false, the deformation takes place only the length of the axis. If true, the deformation happens throughout the object, even if the axis is shorter."}]}],"properties":[{"signature":"bool IsValid","summary":"Returns True if the space morph definition is valid, False otherwise.","since":"5.9","property":["get"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.9"},{"signature":"Point3d MorphPoint(Point3d point)","summary":"Morphs an Euclidean point.","since":"5.9","parameters":[{"name":"point","summary":"A point that will be morphed by this object."}],"returns":"Resulting morphed point."}]},{"namespace":"Rhino.Geometry.Morphs","name":"TwistSpaceMorph","dataType":"class","summary":"Deforms objects by rotating them around an axis.","baseclass":"Rhino.Geometry.SpaceMorph","interfaces":["IDisposable"],"constructors":[{"signature":"TwistSpaceMorph()","summary":"Constructs a twist space morph.","since":"5.1"}],"properties":[{"signature":"bool InfiniteTwist","summary":"If true, the deformation is constant throughout the object, even if the axis is shorter than the object. If false, the deformation takes place only the length of the axis.","since":"5.1","property":["get","set"]},{"signature":"double TwistAngleRadians","summary":"Twist angle in radians.","since":"5.1","property":["get","set"]},{"signature":"Line TwistAxis","summary":"Axis to rotate about.","since":"5.1","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.1"},{"signature":"Point3d MorphPoint(Point3d point)","summary":"Morphs an Euclidean point.  \\nThis method is abstract.","since":"5.1","parameters":[{"name":"point","summary":"A point that will be morphed by this function."}],"returns":"Resulting morphed point."}]},{"namespace":"Rhino.Geometry","name":"NurbsCurve","dataType":"class","summary":"Represents a Non Uniform Rational B-Splines (NURBS) curve.","baseclass":"Rhino.Geometry.Curve","interfaces":["IEpsilonComparable<NurbsCurve>"],"constructors":[{"signature":"NurbsCurve(int dimension, bool rational, int order, int pointCount)","summary":"Constructs a new NURBS curve with knot and CV memory allocated.","since":"5.0","parameters":[{"name":"dimension","summary":">=1."},{"name":"rational","summary":"True to make a rational NURBS."},{"name":"order","summary":"(>= 2) The order=degree+1."},{"name":"pointCount","summary":"(>= order) number of control vertices."}]},{"signature":"NurbsCurve(int degree, int pointCount)","summary":"Constructs a new NURBS curve with a specific degree and control point count.","since":"5.0","parameters":[{"name":"degree","summary":"Degree of curve. Must be equal to or larger than 1 and smaller than or equal to 11."},{"name":"pointCount","summary":"Number of control-points."}]},{"signature":"NurbsCurve(NurbsCurve other)","summary":"Initializes a NURBS curve by copying its values from another NURBS curve.","since":"5.0","parameters":[{"name":"other","summary":"The other curve. This value can be null."}]}],"properties":[{"signature":"bool HasBezierSpans","summary":"Returns True if the NURBS curve has Bezier spans (all distinct knots have multiplicity = degree)","since":"5.0","property":["get"]},{"signature":"bool IsRational","summary":"Gets a value indicating whether or not the curve is rational. Rational curves have control-points with custom weights.","since":"5.0","property":["get"]},{"signature":"NurbsCurveKnotList Knots","summary":"Gets access to the knots (or \\"knot vector\\") of this NURBS curve.","since":"5.0","property":["get"]},{"signature":"int Order","summary":"Gets the order of the curve. Order = Degree + 1.","since":"5.0","property":["get"]},{"signature":"NurbsCurvePointList Points","summary":"Gets access to the control points of this NURBS curve.","since":"5.0","property":["get"]}],"methods":[{"signature":"static NurbsCurve Create(bool periodic, int degree, IEnumerable<Point3d> points)","summary":"Constructs a 3D NURBS curve from a list of control points.","since":"5.0","parameters":[{"name":"periodic","summary":"If true, create a periodic uniform curve. If false, create a clamped uniform curve."},{"name":"degree","summary":"(>=1) degree=order-1."},{"name":"points","summary":"control vertex locations."}],"returns":"new NURBS curve on success None on error."},{"signature":"static NurbsCurve CreateFromArc(Arc arc)","summary":"Gets a rational degree 2 NURBS curve representation of the arc. Note that the parameterization of NURBS curve does not match arc\'s transcendental parameterization.","since":"5.0","returns":"Curve on success, None on failure."},{"signature":"static NurbsCurve CreateFromArc(Arc arc, int degree, int cvCount)","summary":"Create a uniform non-rational cubic NURBS approximation of an arc.","since":"6.0","parameters":[{"name":"arc","summary":""},{"name":"degree","summary":">=1"},{"name":"cvCount","summary":"CV count >=5"}],"returns":"NURBS curve approximation of an arc on success"},{"signature":"static NurbsCurve CreateFromCircle(Circle circle)","summary":"Gets a rational degree 2 NURBS curve representation of the circle. Note that the parameterization of NURBS curve does not match circle\'s transcendental parameterization. Use GetRadianFromNurbFormParameter() and GetParameterFromRadian() to convert between the NURBS curve parameter and the transcendental parameter.","since":"5.0","returns":"Curve on success, None on failure."},{"signature":"static NurbsCurve CreateFromCircle(Circle circle, int degree, int cvCount)","summary":"Create a uniform non-rational cubic NURBS approximation of a circle.","since":"6.0","parameters":[{"name":"circle","summary":""},{"name":"degree","summary":">=1"},{"name":"cvCount","summary":"CV count >=5"}],"returns":"NURBS curve approximation of a circle on success"},{"signature":"static NurbsCurve CreateFromEllipse(Ellipse ellipse)","summary":"Gets a rational degree 2 NURBS curve representation of the ellipse.  \\nNote that the parameterization of the NURBS curve does not match with the transcendental parameterization of the ellipsis.","since":"5.0","returns":"A NURBS curve representation of this ellipse or None if no such representation could be made."},{"signature":"static NurbsCurve CreateFromLine(Line line)","summary":"Gets a non-rational, degree 1 NURBS curve representation of the line.","since":"5.0","returns":"Curve on success, None on failure."},{"signature":"static NurbsCurve CreateHSpline(IEnumerable<Point3d> points)","summary":"Construct an H-spline from a sequence of interpolation points","since":"7.0","parameters":[{"name":"points","summary":"Points to interpolate"}]},{"signature":"static NurbsCurve CreateHSpline(IEnumerable<Point3d> points, Vector3d startTangent, Vector3d endTangent)","summary":"Construct an H-spline from a sequence of interpolation points and optional start and end derivative information","since":"7.0","parameters":[{"name":"points","summary":"Points to interpolate"},{"name":"startTangent","summary":"Unit tangent vector or Unset"},{"name":"endTangent","summary":"Unit tangent vector or Unset"}]},{"signature":"static NurbsCurve CreateParabolaFromFocus(Point3d focus, Point3d startPoint, Point3d endPoint)","summary":"Creates a parabola from focus and end points.","since":"6.0","parameters":[{"name":"focus","summary":"The focal point."},{"name":"startPoint","summary":"The start point."},{"name":"endPoint","summary":"The end point"}],"returns":"A 2 degree NURBS curve if successful, False otherwise."},{"signature":"static NurbsCurve CreateParabolaFromVertex(Point3d vertex, Point3d startPoint, Point3d endPoint)","summary":"Creates a parabola from vertex and end points.","since":"6.0","parameters":[{"name":"vertex","summary":"The vertex point."},{"name":"startPoint","summary":"The start point."},{"name":"endPoint","summary":"The end point"}],"returns":"A 2 degree NURBS curve if successful, False otherwise."},{"signature":"static NurbsCurve CreateSpiral(Curve railCurve, double t0, double t1, Point3d radiusPoint, double pitch, double turnCount, double radius0, double radius1, int pointsPerTurn)","summary":"Create a C2 non-rational uniform cubic NURBS approximation of a swept helix or spiral.","since":"5.2","parameters":[{"name":"railCurve","summary":"The rail curve."},{"name":"t0","summary":"Starting portion of rail curve\'s domain to sweep along."},{"name":"t1","summary":"Ending portion of rail curve\'s domain to sweep along."},{"name":"radiusPoint","summary":"Point used only to get a vector that is perpendicular to the axis. In particular, this vector must not be (anti)parallel to the axis vector."},{"name":"pitch","summary":"The pitch. Positive values produce counter-clockwise orientation, negative values produce clockwise orientation."},{"name":"turnCount","summary":"The turn count. If != 0, then the resulting helix will have this many turns. If = 0, then pitch must be != 0 and the approximate distance between turns will be set to pitch. Positive values produce counter-clockwise orientation, negative values produce clockwise orientation."},{"name":"radius0","summary":"The starting radius. At least one radii must be nonzero. Negative values are allowed."},{"name":"radius1","summary":"The ending radius. At least one radii must be nonzero. Negative values are allowed."},{"name":"pointsPerTurn","summary":"Number of points to interpolate per turn. Must be greater than 4. When in doubt, use 12."}],"returns":"NurbsCurve on success, None on failure."},{"signature":"static NurbsCurve CreateSpiral(Point3d axisStart, Vector3d axisDir, Point3d radiusPoint, double pitch, double turnCount, double radius0, double radius1)","summary":"Creates a C1 cubic NURBS approximation of a helix or spiral. For a helix, you may have radius0 == radius1. For a spiral radius0 == radius1 produces a circle. Zero and negative radii are permissible.","since":"5.2","parameters":[{"name":"axisStart","summary":"Helix\'s axis starting point or center of spiral."},{"name":"axisDir","summary":"Helix\'s axis vector or normal to spiral\'s plane."},{"name":"radiusPoint","summary":"Point used only to get a vector that is perpendicular to the axis. In particular, this vector must not be (anti)parallel to the axis vector."},{"name":"pitch","summary":"The pitch, where a spiral has a pitch = 0, and pitch > 0 is the distance between the helix\'s \\"threads\\"."},{"name":"turnCount","summary":"The number of turns in spiral or helix. Positive values produce counter-clockwise orientation, negative values produce clockwise orientation. Note, for a helix, turnCount * pitch = length of the helix\'s axis."},{"name":"radius0","summary":"The starting radius."},{"name":"radius1","summary":"The ending radius."}],"returns":"NurbsCurve on success, None on failure."},{"signature":"static bool IsDuplicate(NurbsCurve curveA, NurbsCurve curveB, bool ignoreParameterization, double tolerance)","summary":"Determines if two curves are similar.","since":"5.0","parameters":[{"name":"curveA","summary":"First curve used in comparison."},{"name":"curveB","summary":"Second curve used in comparison."},{"name":"ignoreParameterization","summary":"if true, parameterization and orientation are ignored."},{"name":"tolerance","summary":"tolerance to use when comparing control points."}],"returns":"True if curves are similar within tolerance."},{"signature":"static NurbsCurve[] MakeCompatible(IEnumerable<Curve> curves, Point3d startPt, Point3d endPt, int simplifyMethod, int numPoints, double refitTolerance, double angleTolerance)","summary":"For expert use only. From the input curves, make an array of compatible NURBS curves.","since":"6.0","parameters":[{"name":"curves","summary":"The input curves."},{"name":"startPt","summary":"The start point. To omit, specify Point3d.Unset."},{"name":"endPt","summary":"The end point. To omit, specify Point3d.Unset."},{"name":"simplifyMethod","summary":"The simplify method."},{"name":"numPoints","summary":"The number of rebuild points."},{"name":"refitTolerance","summary":"The refit tolerance."},{"name":"angleTolerance","summary":"The angle tolerance in radians."}],"returns":"The output NURBS surfaces if successful."},{"signature":"Plane[] CreatePlanarRailFrames(IEnumerable<double> parameters, Vector3d normal)","summary":"Computes planar rail sweep frames at specified parameters.","since":"7.0","parameters":[{"name":"parameters","summary":"A collection of curve parameters."},{"name":"normal","summary":"Unit normal to the plane."}],"returns":"An array of planes if successful, or an empty array on failure."},{"signature":"Plane[] CreateRailFrames(IEnumerable<double> parameters)","summary":"Computes relatively parallel rail sweep frames at specified parameters.","since":"7.0","parameters":[{"name":"parameters","summary":"A collection of curve parameters."}],"returns":"An array of planes if successful, or an empty array on failure."},{"signature":"bool EpsilonEquals(NurbsCurve other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"double GrevilleParameter(int index)","summary":"Gets the greville (edit point) parameter that belongs to the control point at the specified index.","since":"5.0","parameters":[{"name":"index","summary":"Index of Greville (Edit) point."}]},{"signature":"double[] GrevilleParameters()","summary":"Gets all Greville parameters for this curve.","since":"5.0"},{"signature":"Point3d GrevillePoint(int index)","summary":"Gets the Greville parameter that belongs to the control point at the specified index.","since":"5.0","parameters":[{"name":"index","summary":"Index of Greville point."}]},{"signature":"Point3dList GrevillePoints()","summary":"Gets all Greville points for this curve.","since":"5.0"},{"signature":"Point3dList GrevillePoints(bool all)","summary":"Gets Greville points for this curve.","since":"6.18","parameters":[{"name":"all","summary":"If true, then all Greville points are returns. If false, only edit points are returned."}],"returns":"A list of points if successful, None otherwise."},{"signature":"bool IncreaseDegree(int desiredDegree)","summary":"Increase the degree of this curve.","since":"5.0","parameters":[{"name":"desiredDegree","summary":"The desired degree. Degrees should be number between and including 1 and 11."}],"returns":"True on success, False on failure."},{"signature":"bool MakePiecewiseBezier(bool setEndWeightsToOne)","summary":"Clamps ends and adds knots so the NURBS curve has Bezier spans (all distinct knots have multiplicity = degree).","since":"5.0","parameters":[{"name":"setEndWeightsToOne","summary":"If True and the first or last weight is not one, then the first and last spans are re-parameterized so that the end weights are one."}],"returns":"True on success, False on failure."},{"signature":"bool Reparameterize(double c)","summary":"Use a linear fractional transformation to re-parameterize the NURBS curve. This does not change the curve\'s domain.","since":"5.0","parameters":[{"name":"c","summary":"re-parameterization constant (generally speaking, c should be > 0). The control points and knots are adjusted so that output_nurbs(t) = input_nurbs(lambda(t)), where lambda(t) = c*t/( (c-1)*t + 1 ). Note that lambda(0) = 0, lambda(1) = 1, lambda\'(t) > 0, lambda\'(0) = c and lambda\'(1) = 1/c."}],"returns":"True if successful."},{"signature":"bool SetEndCondition(bool bSetEnd, NurbsCurveEndConditionType continuity, Point3d point, Vector3d tangent)","summary":"Set end condition of a NURBS curve to point, tangent and curvature.","since":"6.0","parameters":[{"name":"bSetEnd","summary":"true: set end of curve, false: set start of curve"},{"name":"continuity","summary":"Position: set start or end point, Tangency: set point and tangent, Curvature: set point, tangent and curvature"},{"name":"point","summary":"point to set"},{"name":"tangent","summary":"tangent to set"}],"returns":"True on success, False on failure."},{"signature":"bool SetEndCondition(bool bSetEnd, NurbsCurveEndConditionType continuity, Point3d point, Vector3d tangent, Vector3d curvature)","summary":"Set end condition of a NURBS curve to point, tangent and curvature.","since":"6.0","parameters":[{"name":"bSetEnd","summary":"true: set end of curve, false: set start of curve"},{"name":"continuity","summary":"Position: set start or end point, Tangency: set point and tangent, Curvature: set point, tangent and curvature"},{"name":"point","summary":"point to set"},{"name":"tangent","summary":"tangent to set"},{"name":"curvature","summary":"curvature to set"}],"returns":"True on success, False on failure."},{"signature":"bool SetGrevillePoints(IEnumerable<Point3d> points)","summary":"Sets all Greville edit points for this curve.","since":"6.4","parameters":[{"name":"points","summary":"The new point locations. The number of points should match the number of point returned by NurbsCurve.GrevillePoints(false)."}],"returns":"True if successful, False otherwise."},{"signature":"bool UVNDirectionsAt(double t, out Vector3d uDir, out Vector3d vDir, out Vector3d nDir)","summary":"Calculates the u, V, and N directions of a NURBS curve at a parameter similar to the method used by Rhino\'s MoveUVN command.","since":"7.0","parameters":[{"name":"t","summary":"The evaluation parameter."},{"name":"uDir","summary":"The U direction."},{"name":"vDir","summary":"The V direction."},{"name":"nDir","summary":"The N direction."}],"returns":"True if successful, False otherwise."}]},{"namespace":"Rhino.Geometry","name":"NurbsCurve.NurbsCurveEndConditionType","dataType":"enum","summary":"What end conditions to set","since":"6.0","values":[{"signature":"Nothing = UnsafeNativeMethods.NurbsCurveEndConditionType.Nothing","summary":"Set nothing"},{"signature":"Position = UnsafeNativeMethods.NurbsCurveEndConditionType.Position","summary":"Set endpoint"},{"signature":"Tangency = UnsafeNativeMethods.NurbsCurveEndConditionType.Tangency","summary":"Set tangent"},{"signature":"Curvature = UnsafeNativeMethods.NurbsCurveEndConditionType.Curvature","summary":"Set curvature"}]},{"namespace":"Rhino.Geometry","name":"NurbsSurface","dataType":"class","summary":"Represents a Non Uniform Rational B-Splines (NURBS) surface.","baseclass":"Rhino.Geometry.Surface","interfaces":["IEpsilonComparable<NurbsSurface>"],"constructors":[{"signature":"NurbsSurface(NurbsSurface other)","summary":"Initializes a new NURBS surface by copying the values from another surface.","since":"5.0","parameters":[{"name":"other","summary":"Another surface."}]}],"properties":[{"signature":"bool IsRational","summary":"Gets a value indicating whether or not the NURBS surface is rational.","since":"5.0","property":["get"]},{"signature":"NurbsSurfaceKnotList KnotsU","summary":"The U direction knot vector.","since":"5.0","property":["get"]},{"signature":"NurbsSurfaceKnotList KnotsV","summary":"The V direction knot vector.","since":"5.0","property":["get"]},{"signature":"int OrderU","summary":"Gets the order in the U direction.","since":"5.0","property":["get"]},{"signature":"int OrderV","summary":"Gets the order in the V direction.","since":"5.0","property":["get"]},{"signature":"NurbsSurfacePointList Points","summary":"Gets a collection of surface control points that form this surface.","since":"5.0","property":["get"]}],"methods":[{"signature":"static NurbsSurface Create(int dimension, bool isRational, int order0, int order1, int controlPointCount0, int controlPointCount1)","summary":"Constructs a new NURBS surface with internal uninitialized arrays.","since":"5.0","parameters":[{"name":"dimension","summary":"The number of dimensions.  \\n>= 1. This value is usually 3."},{"name":"isRational","summary":"True to make a rational NURBS."},{"name":"order0","summary":"The order in U direction.  \\n>= 2."},{"name":"order1","summary":"The order in V direction.  \\n>= 2."},{"name":"controlPointCount0","summary":"Control point count in U direction.  \\n>= order0."},{"name":"controlPointCount1","summary":"Control point count in V direction.  \\n>= order1."}],"returns":"A new NURBS surface, or None on error."},{"signature":"static NurbsCurve CreateCurveOnSurface(Surface surface, IEnumerable<Point2d> points, double tolerance, bool periodic)","summary":"Fit a sequence of 2d points on a surface to make a curve on the surface.","since":"6.3","parameters":[{"name":"surface","summary":"Surface on which to construct curve."},{"name":"points","summary":"Parameter space coordinates of the points to interpolate."},{"name":"tolerance","summary":"Curve should be within tolerance of surface and points."},{"name":"periodic","summary":"When True make a periodic curve."}],"returns":"A curve interpolating the points if successful, None on error."},{"signature":"static Point2d[] CreateCurveOnSurfacePoints(Surface surface, IEnumerable<Point2d> fixedPoints, double tolerance, bool periodic, int initCount, int levels)","summary":"Computes a discrete spline curve on the surface. In other words, computes a sequence of points on the surface, each with a corresponding parameter value.","since":"6.3","parameters":[{"name":"surface","summary":"The surface on which the curve is constructed. The surface should be G1 continuous. If the surface is closed in the u or v direction and is G1 at the seam, the function will construct point sequences that cross over the seam."},{"name":"fixedPoints","summary":"Surface points to interpolate given by parameters. These must be distinct."},{"name":"tolerance","summary":"Relative tolerance used by the solver. When in doubt, use a tolerance of 0.0."},{"name":"periodic","summary":"When True constructs a smoothly closed curve."},{"name":"initCount","summary":"Maximum number of points to insert between fixed points on the first level."},{"name":"levels","summary":"The number of levels (between 1 and 3) to be used in multi-level solver. Use 1 for single level solve."}],"returns":"A sequence of surface points, given by surface parameters, if successful. The number of output points is approximately: 2 ^ (level-1) * initCount * fixedPoints.Count."},{"signature":"static NurbsSurface CreateFromCone(Cone cone)","summary":"Constructs a new NURBS surfaces from cone data.","since":"5.0","parameters":[{"name":"cone","summary":"A cone value."}],"returns":"A new NURBS surface, or None on error."},{"signature":"static NurbsSurface CreateFromCorners(Point3d corner1, Point3d corner2, Point3d corner3)","summary":"Makes a surface from 3 corner points.","since":"5.0","parameters":[{"name":"corner1","summary":"The first corner."},{"name":"corner2","summary":"The second corner."},{"name":"corner3","summary":"The third corner."}],"returns":"The resulting surface or None on error."},{"signature":"static NurbsSurface CreateFromCorners(Point3d corner1, Point3d corner2, Point3d corner3, Point3d corner4)","summary":"Makes a surface from 4 corner points.  \\nThis is the same as calling  with tolerance 0.","since":"5.0","parameters":[{"name":"corner1","summary":"The first corner."},{"name":"corner2","summary":"The second corner."},{"name":"corner3","summary":"The third corner."},{"name":"corner4","summary":"The fourth corner."}],"returns":"the resulting surface or None on error."},{"signature":"static NurbsSurface CreateFromCorners(Point3d corner1, Point3d corner2, Point3d corner3, Point3d corner4, double tolerance)","summary":"Makes a surface from 4 corner points.","since":"5.0","parameters":[{"name":"corner1","summary":"The first corner."},{"name":"corner2","summary":"The second corner."},{"name":"corner3","summary":"The third corner."},{"name":"corner4","summary":"The fourth corner."},{"name":"tolerance","summary":"Minimum edge length without collapsing to a singularity."}],"returns":"The resulting surface or None on error."},{"signature":"static NurbsSurface CreateFromCylinder(Cylinder cylinder)","summary":"Constructs a new NURBS surfaces from cylinder data.","since":"5.0","parameters":[{"name":"cylinder","summary":"A cylinder value."}],"returns":"A new NURBS surface, or None on error."},{"signature":"static NurbsSurface CreateFromPlane(Plane plane, Interval uInterval, Interval vInterval, int uDegree, int vDegree, int uPointCount, int vPointCount)","summary":"Creates a NURBS surface from a plane and additonal parameters.","since":"7.0","parameters":[{"name":"plane","summary":"The plane."},{"name":"uInterval","summary":"The interval describing the extends of the output surface in the U direction."},{"name":"vInterval","summary":"The interval describing the extends of the output surface in the V direction."},{"name":"uDegree","summary":"The degree of the output surface in the U direction."},{"name":"vDegree","summary":"The degree of the output surface in the V direction."},{"name":"uPointCount","summary":"The number of control points of the output surface in the U direction."},{"name":"vPointCount","summary":"The number of control points of the output surface in the V direction."}],"returns":"A NURBS surface if successful, or None on failure."},{"signature":"static NurbsSurface CreateFromPoints(IEnumerable<Point3d> points, int uCount, int vCount, int uDegree, int vDegree)","summary":"Constructs a NURBS surface from a 2D grid of control points.","since":"5.0","parameters":[{"name":"points","summary":"Control point locations."},{"name":"uCount","summary":"Number of points in U direction."},{"name":"vCount","summary":"Number of points in V direction."},{"name":"uDegree","summary":"Degree of surface in U direction."},{"name":"vDegree","summary":"Degree of surface in V direction."}],"returns":"A NurbsSurface on success or None on failure."},{"signature":"static NurbsSurface CreateFromSphere(Sphere sphere)","summary":"Constructs a new NURBS surfaces from sphere data.","since":"5.0","parameters":[{"name":"sphere","summary":"A sphere value."}],"returns":"A new NURBS surface, or None on error."},{"signature":"static NurbsSurface CreateFromTorus(Torus torus)","summary":"Constructs a new NURBS surfaces from torus data.","since":"5.0","parameters":[{"name":"torus","summary":"A torus value."}],"returns":"A new NURBS surface, or None on error."},{"signature":"static NurbsSurface CreateNetworkSurface(IEnumerable<Curve> curves, int continuity, double edgeTolerance, double interiorTolerance, double angleTolerance, out int error)","summary":"Builds a surface from an auto-sorted network of curves/edges.","since":"5.0","parameters":[{"name":"curves","summary":"An array, a list or any enumerable set of curves/edges, sorted automatically into U and V curves."},{"name":"continuity","summary":"continuity along edges, 0 = loose, 1 = position, 2 = tan, 3 = curvature."},{"name":"edgeTolerance","summary":"tolerance to use along network surface edge."},{"name":"interiorTolerance","summary":"tolerance to use for the interior curves."},{"name":"angleTolerance","summary":"angle tolerance to use."},{"name":"error","summary":"If the NurbsSurface could not be created, the error value describes where the failure occurred.  0 = success,  1 = curve sorter failed, 2 = network initializing failed, 3 = failed to build surface, 4 = network surface is not valid."}],"returns":"A NurbsSurface or None on failure."},{"signature":"static NurbsSurface CreateNetworkSurface(IEnumerable<Curve> uCurves, int uContinuityStart, int uContinuityEnd, IEnumerable<Curve> vCurves, int vContinuityStart, int vContinuityEnd, double edgeTolerance, double interiorTolerance, double angleTolerance, out int error)","summary":"Builds a surface from an ordered network of curves/edges.","since":"5.0","parameters":[{"name":"uCurves","summary":"An array, a list or any enumerable set of U curves."},{"name":"uContinuityStart","summary":"continuity at first U segment, 0 = loose, 1 = position, 2 = tan, 3 = curvature."},{"name":"uContinuityEnd","summary":"continuity at last U segment, 0 = loose, 1 = position, 2 = tan, 3 = curvature."},{"name":"vCurves","summary":"An array, a list or any enumerable set of V curves."},{"name":"vContinuityStart","summary":"continuity at first V segment, 0 = loose, 1 = position, 2 = tan, 3 = curvature."},{"name":"vContinuityEnd","summary":"continuity at last V segment, 0 = loose, 1 = position, 2 = tan, 3 = curvature."},{"name":"edgeTolerance","summary":"tolerance to use along network surface edge."},{"name":"interiorTolerance","summary":"tolerance to use for the interior curves."},{"name":"angleTolerance","summary":"angle tolerance to use."},{"name":"error","summary":"If the NurbsSurface could not be created, the error value describes where the failure occurred.  0 = success,  1 = curve sorter failed, 2 = network initializing failed, 3 = failed to build surface, 4 = network surface is not valid."}],"returns":"A NurbsSurface or None on failure."},{"signature":"static NurbsSurface CreateRailRevolvedSurface(Curve profile, Curve rail, Line axis, bool scaleHeight)","summary":"Constructs a railed Surface-of-Revolution.","since":"5.0","parameters":[{"name":"profile","summary":"Profile curve for revolution."},{"name":"rail","summary":"Rail curve for revolution."},{"name":"axis","summary":"Axis of revolution."},{"name":"scaleHeight","summary":"If true, surface will be locally scaled."}],"returns":"A NurbsSurface or None on failure."},{"signature":"static NurbsSurface CreateRuledSurface(Curve curveA, Curve curveB)","summary":"Constructs a ruled surface between two curves. Curves must share the same knot-vector.","since":"5.0","parameters":[{"name":"curveA","summary":"First curve."},{"name":"curveB","summary":"Second curve."}],"returns":"A ruled surface on success or None on failure."},{"signature":"static NurbsSurface CreateThroughPoints(IEnumerable<Point3d> points, int uCount, int vCount, int uDegree, int vDegree, bool uClosed, bool vClosed)","summary":"Constructs a NURBS surface from a 2D grid of points.","since":"5.0","parameters":[{"name":"points","summary":"Control point locations."},{"name":"uCount","summary":"Number of points in U direction."},{"name":"vCount","summary":"Number of points in V direction."},{"name":"uDegree","summary":"Degree of surface in U direction."},{"name":"vDegree","summary":"Degree of surface in V direction."},{"name":"uClosed","summary":"True if the surface should be closed in the U direction."},{"name":"vClosed","summary":"True if the surface should be closed in the V direction."}],"returns":"A NurbsSurface on success or None on failure."},{"signature":"static bool MakeCompatible(Surface surface0, Surface surface1, out NurbsSurface nurb0, out NurbsSurface nurb1)","summary":"For expert use only. Makes a pair of compatible NURBS surfaces based on two input surfaces.","since":"6.0","parameters":[{"name":"surface0","summary":"The first surface."},{"name":"surface1","summary":"The second surface."},{"name":"nurb0","summary":"The first output NURBS surface."},{"name":"nurb1","summary":"The second output NURBS surface."}],"returns":"True if successful, False on failure."},{"signature":"void CopyFrom(NurbsSurface other)","summary":"Copies this NURBS surface from another NURBS surface.","since":"5.0","parameters":[{"name":"other","summary":"The other NURBS surface to use as source."}]},{"signature":"bool EpsilonEquals(NurbsSurface other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool IncreaseDegreeU(int desiredDegree)","summary":"Increase the degree of this surface in U direction.","since":"5.10","parameters":[{"name":"desiredDegree","summary":"The desired degree. Degrees should be number between and including 1 and 11."}],"returns":"True on success, False on failure."},{"signature":"bool IncreaseDegreeV(int desiredDegree)","summary":"Increase the degree of this surface in V direction.","since":"5.10","parameters":[{"name":"desiredDegree","summary":"The desired degree. Degrees should be number between and including 1 and 11."}],"returns":"True on success, False on failure."},{"signature":"bool MakeNonRational()","summary":"Makes this surface non-rational.","since":"5.0","returns":"True if the operation succeeded; otherwise, false."},{"signature":"bool MakeRational()","summary":"Makes this surface rational.","since":"5.0","returns":"True if the operation succeeded; otherwise, false."},{"signature":"bool UVNDirectionsAt(double u, double v, out Vector3d uDir, out Vector3d vDir, out Vector3d nDir)","summary":"Calculates the U, V, and N directions of a NURBS surface at a u,v parameter similar to the method used by Rhino\'s MoveUVN command.","since":"7.0","parameters":[{"name":"u","summary":"The u evaluation parameter."},{"name":"v","summary":"The v evaluation parameter."},{"name":"uDir","summary":"The U direction."},{"name":"vDir","summary":"The V direction."},{"name":"nDir","summary":"The N direction."}],"returns":"True if successful, False otherwise."}]},{"namespace":"Rhino.Geometry","name":"OrdinateDimension","dataType":"class","summary":"Represents an ordinate dimension","baseclass":"Rhino.Geometry.Dimension","constructors":[{"signature":"OrdinateDimension()","since":"6.0"}],"properties":[{"signature":"Point2d DefPoint","since":"6.0","property":["get","set"]},{"signature":"double KinkOffset1","since":"6.0","property":["get","set"]},{"signature":"double KinkOffset2","since":"6.0","property":["get","set"]},{"signature":"Point2d KinkPoint1","since":"6.0","property":["get"]},{"signature":"Point2d KinkPoint2","since":"6.0","property":["get"]},{"signature":"Point2d LeaderPoint","since":"6.0","property":["get","set"]}],"methods":[{"signature":"static OrdinateDimension Create(DimensionStyle dimStyle, Plane plane, MeasuredDirection direction, Point3d basepoint, Point3d defpoint, Point3d leaderpoint, double kinkoffset1, double kinkoffset2)","summary":"Initialize Dimension parameters","since":"6.0","parameters":[{"name":"dimStyle","summary":"Dimension\'s AnnotationStyle"},{"name":"plane","summary":"Dimension;s plane"},{"name":"direction","summary":"MeasuredDirection.XAxis or MeasuredDirection.YAxis"},{"name":"basepoint","summary":"Dimension\'s base point"},{"name":"defpoint","summary":"Dimension\'s definition point"},{"name":"leaderpoint","summary":"Point at tail of leader"},{"name":"kinkoffset1","summary":"Distance to first jog"},{"name":"kinkoffset2","summary":"Distance to second jog"}]},{"signature":"bool AdjustFromPoints(Plane plane, MeasuredDirection direction, Point3d basepoint, Point3d defpoint, Point3d leaderpoint, double kinkoffset1, double kinkoffset2)","summary":"Update Dimension geometry from point locations","since":"6.0","parameters":[{"name":"plane","summary":"Dimension\'s plane"},{"name":"direction","summary":"MeasuredDirection.XAxis or MeasuredDirection.YAxisw"},{"name":"basepoint","summary":"Dimension\'s base point"},{"name":"defpoint","summary":"Dimension\'s definition point"},{"name":"leaderpoint","summary":"Point at tail of leader"},{"name":"kinkoffset1","summary":"Distance to first jog"},{"name":"kinkoffset2","summary":"Distance to second jog"}]},{"signature":"bool Get3dPoints(out Point3d basepoint, out Point3d defpoint, out Point3d leaderpoint, out Point3d kinkpoint1, out Point3d kinkpoint2)","summary":"Get locations of dimension\'s 3d points","since":"6.0","parameters":[{"name":"basepoint","summary":"Dimension\'s base point"},{"name":"defpoint","summary":"Dimension\'s definition point"},{"name":"leaderpoint","summary":"Point at tail of leader"},{"name":"kinkpoint1","summary":"Point at first jog"},{"name":"kinkpoint2","summary":"Point at second jog"}]},{"signature":"bool GetDisplayLines(DimensionStyle style, double scale, out IEnumerable<Line> lines)"},{"signature":"string GetDistanceDisplayText(UnitSystem unitsystem, DimensionStyle style)","since":"6.0"},{"signature":"bool GetTextRectangle(out Point3d[] corners)","since":"6.0"}]},{"namespace":"Rhino.Geometry","name":"OrdinateDimension.MeasuredDirection","dataType":"enum","summary":"Ordinate dimension measures x or y direction","values":[{"signature":"Unset = 0"},{"signature":"Xaxis = 1","summary":"Measures horizontal distance"},{"signature":"Yaxis = 2","summary":"Measures vertical distance"}]},{"namespace":"Rhino.Geometry","name":"Particle","dataType":"class","summary":"Represents a simple particle.  \\nThis base class only defines position and display properties (size, color, bitmap id). You will most likely create a class that derives from this particle class to perform some sort of physical simulation (movement over time or frames).","constructors":[{"signature":"Particle()","summary":"Initializes a new instance of the Particleclass.","since":"5.0"}],"properties":[{"signature":"Color Color","since":"5.0","property":["get","set"]},{"signature":"int DisplayBitmapIndex","since":"5.0","property":["get","set"]},{"signature":"int Index","summary":"Index in ParentSystem for this Particle. Can change when the particle system is modified.","since":"5.0","property":["get","set"]},{"signature":"Point3d Location","summary":"3d Location of the Particle.","since":"5.0","property":["get","set"]},{"signature":"ParticleSystem ParentSystem","summary":"Gets the parent particle system of this particle.","since":"5.0","property":["get","set"]},{"signature":"float Size","since":"5.0","property":["get","set"]}],"methods":[{"signature":"void Update()","summary":"Base class implementation does nothing.","since":"5.0"}]},{"namespace":"Rhino.Geometry","name":"ParticleSystem","dataType":"class","interfaces":["IEnumerable<Particle>"],"properties":[{"signature":"BoundingBox BoundingBox","since":"5.0","property":["get"]},{"signature":"bool DisplaySizesInWorldUnits","since":"5.0","property":["get","set"]},{"signature":"bool DrawRequiresDepthSorting","since":"5.0","property":["get","set"]}],"methods":[{"signature":"bool Add(Particle particle)","summary":"Adds a particle to this ParticleSystem. A Particle can only be in one system at a time.  If the Particle already exists in a different system, this function will return false. You should remove the particle from the other system first before adding it.","since":"5.0","parameters":[{"name":"particle","summary":"A particle to be added."}],"returns":"True if this particle was added to the system or if is already in the system. False if the particle already exists in a different system."},{"signature":"void Clear()","summary":"Remove all Particles from this system.","since":"5.0"},{"signature":"IEnumerator<Particle> GetEnumerator()","since":"5.0"},{"signature":"void Remove(Particle particle)","summary":"Removes a single particle from this system.","since":"5.0","parameters":[{"name":"particle","summary":"The particle to be removed."}]},{"signature":"void Update()","summary":"Calls Update on every particle in the system.","since":"5.0"}]},{"namespace":"Rhino.Geometry","name":"PipeCapMode","dataType":"enum","summary":"Defines styles used for creating Brep pipes.","since":"5.0","values":[{"signature":"None = 0","summary":"No cap."},{"signature":"Flat = 1","summary":"Caps with planar surface."},{"signature":"Round = 2","summary":"Caps with hemispherical surface."}]},{"namespace":"Rhino.Geometry","name":"Plane","dataType":"struct","summary":"Represents the value of a center point and two axes in a plane in three dimensions.","constructors":[{"signature":"Plane(double a, double b, double c, double d)","summary":"Constructs a plane from an equation Ax+By+Cz+D=0.","since":"5.0"},{"signature":"Plane(Plane other)","summary":"Copy constructor.  \\nThis is nothing special and performs the same as assigning to another variable.","since":"5.0","parameters":[{"name":"other","summary":"The source plane value."}]},{"signature":"Plane(Point3d origin, Point3d xPoint, Point3d yPoint)","summary":"Initializes a plane from three non-collinear points.","since":"5.0","parameters":[{"name":"origin","summary":"Origin point of the plane."},{"name":"xPoint","summary":"Second point in the plane. The x-axis will be parallel to x_point-origin."},{"name":"yPoint","summary":"Third point on the plane that is not collinear with the first two points. taxis*(y_point-origin) will be > 0."}]},{"signature":"Plane(Point3d origin, Vector3d normal)","summary":"Constructs a plane from a point and a normal vector.","since":"5.0","parameters":[{"name":"origin","summary":"Origin point of the plane."},{"name":"normal","summary":"Non-zero normal to the plane."}]},{"signature":"Plane(Point3d origin, Vector3d xDirection, Vector3d yDirection)","summary":"Constructs a plane from a point and two vectors in the plane.","since":"5.0","parameters":[{"name":"origin","summary":"Origin point of the plane."},{"name":"xDirection","summary":"Non-zero vector in the plane that determines the x-axis direction."},{"name":"yDirection","summary":"Non-zero vector not parallel to x_dir that is used to determine the y-axis direction. y_dir does not need to be perpendicular to x_dir."}]}],"properties":[{"signature":"static Plane Unset","summary":"Gets a plane that contains Unset origin and axis vectors.","since":"5.0","property":["get"]},{"signature":"static Plane WorldXY","summary":"plane coincident with the World XY plane.","since":"5.0","property":["get"]},{"signature":"static Plane WorldYZ","summary":"plane coincident with the World YZ plane.","since":"5.0","property":["get"]},{"signature":"static Plane WorldZX","summary":"plane coincident with the World ZX plane.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Gets a value indicating whether or not this is a valid plane. A plane is considered to be valid when all fields contain reasonable information and the equation jibes with point and z-axis.","since":"5.0","property":["get"]},{"signature":"Vector3d Normal","summary":"Gets the normal of this plane. This is essentially the ZAxis of the plane.","since":"5.0","property":["get"]},{"signature":"Point3d Origin","summary":"Gets or sets the origin point of this plane.","since":"5.0","property":["get","set"]},{"signature":"double OriginX","summary":"Gets or sets the X coordinate of the origin of this plane.","since":"5.0","property":["get","set"]},{"signature":"double OriginY","summary":"Gets or sets the Y coordinate of the origin of this plane.","since":"5.0","property":["get","set"]},{"signature":"double OriginZ","summary":"Gets or sets the Z coordinate of the origin of this plane.","since":"5.0","property":["get","set"]},{"signature":"Vector3d XAxis","summary":"Gets or sets the X axis vector of this plane.","since":"5.0","property":["get","set"]},{"signature":"Vector3d YAxis","summary":"Gets or sets the Y axis vector of this plane.","since":"5.0","property":["get","set"]},{"signature":"Vector3d ZAxis","summary":"Gets or sets the Z axis vector of this plane.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static PlaneFitResult FitPlaneToPoints(IEnumerable<Point3d> points, out Plane plane)","summary":"Fit a plane through a collection of points.","since":"5.0","parameters":[{"name":"points","summary":"Points to fit to."},{"name":"plane","summary":"Resulting plane."}],"returns":"A value indicating the result of the operation."},{"signature":"static PlaneFitResult FitPlaneToPoints(IEnumerable<Point3d> points, out Plane plane, out double maximumDeviation)","summary":"Fit a plane through a collection of points.","since":"5.0","parameters":[{"name":"points","summary":"Points to fit to."},{"name":"plane","summary":"Resulting plane."},{"name":"maximumDeviation","summary":"The distance from the furthest point to the plane."}],"returns":"A value indicating the result of the operation."},{"signature":"Plane Clone()","summary":"Returns a deep of this instance.","since":"6.0","returns":"A plane with the same values as this item."},{"signature":"bool ClosestParameter(Point3d testPoint, out double s, out double t)","summary":"Gets the parameters of the point on the plane closest to a test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to get close to."},{"name":"s","summary":"Parameter along plane X-direction."},{"name":"t","summary":"Parameter along plane Y-direction."}],"returns":"True if a parameter could be found, False if the point could not be projected successfully."},{"signature":"Point3d ClosestPoint(Point3d testPoint)","summary":"Gets the point on the plane closest to a test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to get close to."}],"returns":"The point on the plane that is closest to testPoint, or Point3d.Unset on failure."},{"signature":"bool DistanceTo(BoundingBox bbox, out double min, out double max)","summary":"Returns the signed minimum and maximum distances from bounding box to this plane.","since":"6.0","parameters":[{"name":"bbox","summary":"bounding box to get distances from"},{"name":"min","summary":"minimum signed distance from plane to box"},{"name":"max","summary":"maximum signed distance from plane to box"}],"returns":"False if plane has zero length normal"},{"signature":"double DistanceTo(Point3d testPoint)","summary":"Returns the signed distance from testPoint to its projection onto this plane. If the point is below the plane, a negative distance is returned.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to test."}],"returns":"Signed distance from this plane to testPoint."},{"signature":"bool EpsilonEquals(Plane other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(object obj)","summary":"Determines if an object is a plane and has the same components as this plane.","parameters":[{"name":"obj","summary":"An object."}],"returns":"True if obj is a plane and has the same components as this plane; False otherwise."},{"signature":"bool Equals(Plane plane)","summary":"Determines if another plane has the same components as this plane.","since":"5.0","parameters":[{"name":"plane","summary":"A plane."}],"returns":"True if plane has the same components as this plane; False otherwise."},{"signature":"bool ExtendThroughBox(BoundingBox box, out Interval s, out Interval t)","summary":"Extends this plane through a bounding box.","since":"5.0","parameters":[{"name":"box","summary":"A box to use as minimal extension boundary."},{"name":"s","summary":"If this function returns true, the s parameter returns the Interval on the plane along the X direction that will encompass the Box."},{"name":"t","summary":"If this function returns true, the t parameter returns the Interval on the plane along the Y direction that will encompass the Box."}],"returns":"True on success, False on failure."},{"signature":"bool ExtendThroughBox(Box box, out Interval s, out Interval t)","summary":"Extend this plane through a Box.","since":"5.0","parameters":[{"name":"box","summary":"A box to use for extension."},{"name":"s","summary":"If this function returns true, the s parameter returns the Interval on the plane along the X direction that will encompass the Box."},{"name":"t","summary":"If this function returns true, the t parameter returns the Interval on the plane along the Y direction that will encompass the Box."}],"returns":"True on success, False on failure."},{"signature":"void Flip()","summary":"Flip this plane by swapping out the X and Y axes and inverting the Z axis.","since":"5.0"},{"signature":"int GetHashCode()","summary":"Gets a non-unique hashing code for this entity.","returns":"A particular number for a specific instance of plane."},{"signature":"double[] GetPlaneEquation()","summary":"Gets the plane equation for this plane in the format of Ax+By+Cz+D=0.","since":"5.0","returns":"Array of four values."},{"signature":"Point3d PointAt(double u, double v)","summary":"Evaluate a point on the plane.","since":"5.0","parameters":[{"name":"u","summary":"evaluation parameter."},{"name":"v","summary":"evaluation parameter."}],"returns":"plane.origin + u*plane.xaxis + v*plane.yaxis."},{"signature":"Point3d PointAt(double u, double v, double w)","summary":"Evaluate a point on the plane.","since":"5.0","parameters":[{"name":"u","summary":"evaluation parameter."},{"name":"v","summary":"evaluation parameter."},{"name":"w","summary":"evaluation parameter."}],"returns":"plane.origin + u*plane.xaxis + v*plane.yaxis + z*plane.zaxis."},{"signature":"bool RemapToPlaneSpace(Point3d ptSample, out Point3d ptPlane)","summary":"Convert a point from World space coordinates into Plane space coordinates.","since":"5.0","parameters":[{"name":"ptSample","summary":"World point to remap."},{"name":"ptPlane","summary":"Point in plane (s,t,d) coordinates."}],"returns":"True on success, False on failure."},{"signature":"bool Rotate(double sinAngle, double cosAngle, Vector3d axis)","summary":"Rotate the plane about its origin point.","since":"5.0","parameters":[{"name":"sinAngle","summary":"Sin(angle)."},{"name":"cosAngle","summary":"Cos(angle)."},{"name":"axis","summary":"Axis of rotation."}],"returns":"True on success, False on failure."},{"signature":"bool Rotate(double sinAngle, double cosAngle, Vector3d axis, Point3d centerOfRotation)","summary":"Rotate the plane about a custom anchor point.","since":"5.0","parameters":[{"name":"sinAngle","summary":"Sin(angle)"},{"name":"cosAngle","summary":"Cos(angle)"},{"name":"axis","summary":"Axis of rotation."},{"name":"centerOfRotation","summary":"Center of rotation."}],"returns":"True on success, False on failure."},{"signature":"bool Rotate(double angle, Vector3d axis)","summary":"Rotate the plane about its origin point.","since":"5.0","parameters":[{"name":"angle","summary":"Angle in radians."},{"name":"axis","summary":"Axis of rotation."}],"returns":"True on success, False on failure."},{"signature":"bool Rotate(double angle, Vector3d axis, Point3d centerOfRotation)","summary":"Rotate the plane about a custom anchor point.","since":"5.0","parameters":[{"name":"angle","summary":"Angle in radians."},{"name":"axis","summary":"Axis of rotation."},{"name":"centerOfRotation","summary":"Center of rotation."}],"returns":"True on success, False on failure."},{"signature":"string ToString()","summary":"Constructs the string representation of this plane.","returns":"Text."},{"signature":"string ToString(string format, IFormatProvider formatProvider)","since":"7.0"},{"signature":"bool Transform(Transform xform)","summary":"Transform the plane with a Transformation matrix.","since":"5.0","parameters":[{"name":"xform","summary":"Transformation to apply to plane."}],"returns":"True on success, False on failure."},{"signature":"bool Translate(Vector3d delta)","summary":"Translate (move) the plane along a vector.","since":"5.0","parameters":[{"name":"delta","summary":"Translation (motion) vector."}],"returns":"True on success, False on failure."},{"signature":"bool UpdateEquation()","summary":"Update Equations","since":"6.0","returns":"bool"},{"signature":"double ValueAt(Point3d p)","summary":"Get the value of the plane equation at the point.","since":"5.7","parameters":[{"name":"p","summary":"evaluation point."}],"returns":"returns pe[0]*p.X + pe[1]*p.Y + pe[2]*p.Z + pe[3] where pe[0], pe[1], pe[2] and pe[3] are the coefficients of the plane equation."}]},{"namespace":"Rhino.Geometry","name":"PlaneFitResult","dataType":"enum","summary":"Enumerates all possible outcomes of a Least-Squares plane fitting operation.","since":"5.0","values":[{"signature":"Failure = -1","summary":"No plane could be found."},{"signature":"Success = 0","summary":"A plane was successfully fitted."},{"signature":"Inconclusive = 1","summary":"A valid plane was found, but it is an inconclusive result. This might happen with co-linear points for example."}]},{"namespace":"Rhino.Geometry","name":"PlaneSurface","dataType":"class","summary":"Represents a plane surface, with plane and two intervals.","baseclass":"Rhino.Geometry.Surface","constructors":[{"signature":"PlaneSurface(Plane plane, Interval xExtents, Interval yExtents)","summary":"Initializes a plane surface with x and y intervals.","since":"5.0","parameters":[{"name":"plane","summary":"The plane."},{"name":"xExtents","summary":"The x interval of the plane that defines the rectangle. The corresponding evaluation interval domain is set so that it matches the extents interval."},{"name":"yExtents","summary":"The y interval of the plane that defines the rectangle. The corresponding evaluation interval domain is set so that it matches the extents interval."}]}],"methods":[{"signature":"static PlaneSurface CreateThroughBox(Line lineInPlane, Vector3d vectorInPlane, BoundingBox box)","summary":"Makes a plane that includes a line and a vector and goes through a bounding box.","since":"5.0","parameters":[{"name":"lineInPlane","summary":"A line that will lie on the plane."},{"name":"vectorInPlane","summary":"A vector the direction of which will be in plane."},{"name":"box","summary":"A box to cut through."}],"returns":"A new plane surface on success, or None on error."},{"signature":"static PlaneSurface CreateThroughBox(Plane plane, BoundingBox box)","summary":"Extends a plane into a plane surface so that the latter goes through a bounding box.","since":"5.0","parameters":[{"name":"plane","summary":"An original plane value."},{"name":"box","summary":"A box to use for extension boundary."}],"returns":"A new plane surface on success, or None on error."}]},{"namespace":"Rhino.Geometry","name":"Point","dataType":"class","summary":"Represents a geometric point.  \\nThis is fundamentally a class that derives from and contains a single  location.","baseclass":"Rhino.Geometry.GeometryBase","constructors":[{"signature":"Point(Point3d location)","summary":"Initializes a new point instance with a location.","since":"5.0","parameters":[{"name":"location","summary":"A position in 3D space."}]}],"properties":[{"signature":"Point3d Location","summary":"Gets or sets the location (position) of this point.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.Geometry","name":"Point2d","dataType":"struct","summary":"Represents the two coordinates of a point in two-dimensional space, using double-precision floating point numbers.","constructors":[{"signature":"Point2d(double x, double y)","summary":"Initializes a new instance of Point2dfrom coordinates.","since":"5.0","parameters":[{"name":"x","summary":"The X (first) coordinate."},{"name":"y","summary":"The Y (second) coordinate."}]},{"signature":"Point2d(Point2d point)","summary":"Initializes a new instance of Point2dby copying another Point2d.","since":"5.0","parameters":[{"name":"point","summary":"The point that will be copied."}]},{"signature":"Point2d(Point3d point)","summary":"Initializes a new instance of Point3dby copying the first two coordinates of a Point3d.","since":"5.0","parameters":[{"name":"point","summary":"The point that will be used: the Z (third) coordinate is discarded."}]},{"signature":"Point2d(Vector2d vector)","summary":"Initializes a new instance of Point2dby converting a vector.","since":"5.0","parameters":[{"name":"vector","summary":"The vector that will be copied."}]}],"properties":[{"signature":"static Point2d Origin","summary":"Gets a point at 0,0.","since":"5.0","property":["get"]},{"signature":"static Point2d Unset","summary":"Gets a point at RhinoMath.UnsetValue,RhinoMath.UnsetValue.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"If any coordinate of a point is UnsetValue, then the point is not valid.","since":"5.0","property":["get"]},{"signature":"double MaximumCoordinate","summary":"Gets the largest valid coordinate, or RhinoMath.UnsetValue if no coordinate is valid.","since":"5.0","property":["get"]},{"signature":"double MinimumCoordinate","summary":"Gets the smallest (both positive and negative) valid coordinate, or RhinoMath.UnsetValue if no coordinate is valid.","since":"5.0","property":["get"]},{"signature":"double X","summary":"Gets or sets the X (first) coordinate of the point.","since":"5.0","property":["get","set"]},{"signature":"double Y","summary":"Gets or sets the Y (second) coordinate of the point.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static Point2d Add(Point2d point1, Point2d point2)","summary":"Adds a point with a point.  \\n(Provided for languages that do not support operator overloading. You can use the + operator otherwise)","since":"5.0","parameters":[{"name":"point1","summary":"A point."},{"name":"point2","summary":"A point."}],"returns":"A new point that is coordinate-wise summed with the other point."},{"signature":"static Point2d Add(Point2d point, Vector2d vector)","summary":"Adds a point with a vector.  \\n(Provided for languages that do not support operator overloading. You can use the + operator otherwise)","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"vector","summary":"A vector."}],"returns":"A new point that is coordinate-wise summed with the vector."},{"signature":"static Point2d Add(Vector2d vector, Point2d point)","summary":"Adds a vector with a point.  \\n(Provided for languages that do not support operator overloading. You can use the + operator otherwise)","since":"5.0","parameters":[{"name":"vector","summary":"A vector."},{"name":"point","summary":"A point."}],"returns":"A new point that is coordinate-wise summed with the vector."},{"signature":"static Point2d Divide(Point2d point, double t)","summary":"Divides a Point2dby a number.  \\n(Provided for languages that do not support operator overloading. You can use the / operator otherwise)","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"t","summary":"A number."}],"returns":"A new point that is coordinate-wise divided by t."},{"signature":"static Point2d Multiply(double t, Point2d point)","summary":"Multiplies a Point2dby a number.  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"5.0","parameters":[{"name":"t","summary":"A number."},{"name":"point","summary":"A point."}],"returns":"A new point that is coordinate-wise multiplied by t."},{"signature":"static Point2d Multiply(Point2d point, double t)","summary":"Multiplies a Point2dby a number.  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"t","summary":"A number."}],"returns":"A new point that is coordinate-wise multiplied by t."},{"signature":"static Vector2d Subtract(Point2d point1, Point2d point2)","summary":"Subtracts the second point from the first point.  \\n(Provided for languages that do not support operator overloading. You can use the - operator otherwise)","since":"5.0","parameters":[{"name":"point1","summary":"A point (minuend)."},{"name":"point2","summary":"A point (subtrahend)."}],"returns":"A new vector that is point1 coordinate-wise subtracted by point2."},{"signature":"static Point2d Subtract(Point2d point, Vector2d vector)","summary":"Subtracts a vector from a point.  \\n(Provided for languages that do not support operator overloading. You can use the - operator otherwise)","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"vector","summary":"A vector."}],"returns":"A new point that is coordinate-wise subtracted by vector."},{"signature":"int CompareTo(Point2d other)","summary":"Compares this Point2dwith another Point2d.  \\nCoordinates evaluation priority is first X, then Y.","since":"5.0","parameters":[{"name":"other","summary":"The other Point2dto use in comparison."}],"returns":"0: if this is identical to other  \\n-1: if this.X < other.X  \\n-1: if this.X == other.X and this.Y < other.Y  \\n+1: otherwise."},{"signature":"double DistanceTo(Point2d other)","summary":"Computes the distance between two points.","since":"5.0","parameters":[{"name":"other","summary":"Another point."}],"returns":"The length of the line between the two points, or 0 if either point is invalid."},{"signature":"bool EpsilonEquals(Point2d other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(object obj)","summary":"Determines whether the specified System.Object is a Point2d and has the same values as the present point.","parameters":[{"name":"obj","summary":"The specified object."}],"returns":"True if obj is a Point2d and has the same coordinates as this; otherwise false."},{"signature":"bool Equals(Point2d point)","summary":"Determines whether the specified Point2d has the same values as the present point.","since":"5.0","parameters":[{"name":"point","summary":"The specified point."}],"returns":"True if point has the same coordinates as this; otherwise false."},{"signature":"int GetHashCode()","summary":"Computes a hash number that represents the current point.","returns":"A hash code that is not unique for each point."},{"signature":"string ToString()","summary":"Constructs the string representation for the current point.","returns":"The point representation in the form X,Y."},{"signature":"string ToString(string format, IFormatProvider formatProvider)","since":"7.0"},{"signature":"void Transform(Transform xform)","summary":"Transforms the present point in place. The transformation matrix acts on the left of the point. i.e.,  \\nresult = transformation*point","since":"5.1","parameters":[{"name":"xform","summary":"Transformation to apply."}]}]},{"namespace":"Rhino.Geometry","name":"Point2f","dataType":"struct","summary":"Represents the two coordinates of a point in two-dimensional space, using Single-precision floating point numbers.","constructors":[{"signature":"Point2f(double x, double y)","summary":"Initializes a new two-dimensional point from two double-precision floating point numbers as coordinates.  \\nCoordinates will be internally converted to floating point numbers. This might cause precision loss.","since":"5.0","parameters":[{"name":"x","summary":"X component of vector."},{"name":"y","summary":"Y component of vector."}]},{"signature":"Point2f(float x, float y)","summary":"Initializes a new two-dimensional point from two components.","since":"5.0","parameters":[{"name":"x","summary":"X component of vector."},{"name":"y","summary":"Y component of vector."}]}],"properties":[{"signature":"static Point2f Unset","summary":"Gets the standard unset point.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Gets a value indicating whether this point is considered valid.","since":"5.0","property":["get"]},{"signature":"float X","summary":"Gets or sets the X (first) component of the vector.","since":"5.0","property":["get","set"]},{"signature":"float Y","summary":"Gets or sets the Y (second) component of the vector.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"int CompareTo(Point2f other)","summary":"Compares this Point2fwith another Point2f.  \\nCoordinates evaluation priority is first X, then Y.","since":"5.0","parameters":[{"name":"other","summary":"The other Point2fto use in comparison."}],"returns":"0: if this is identical to other  \\n-1: if this.X < other.X  \\n-1: if this.X == other.X and this.Y < other.Y  \\n+1: otherwise."},{"signature":"bool EpsilonEquals(Point2f other, float epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(object obj)","summary":"Determines whether the specified System.Object is a Point2fand has the same values as the present point.","parameters":[{"name":"obj","summary":"The specified object."}],"returns":"True if obj is Point2f and has the same coordinates as this; otherwise false."},{"signature":"bool Equals(Point2f point)","summary":"Determines whether the specified Point2fhas the same values as the present point.","since":"5.0","parameters":[{"name":"point","summary":"The specified point."}],"returns":"True if point has the same coordinates as this; otherwise false."},{"signature":"int GetHashCode()","summary":"Computes a hash number that represents the current point.","returns":"A hash code that is not unique for each point."},{"signature":"string ToString()","summary":"Constructs the string representation for the current point.","returns":"The point representation in the form X,Y."},{"signature":"string ToString(string format, IFormatProvider formatProvider)","since":"7.0"}]},{"namespace":"Rhino.Geometry","name":"Point3d","dataType":"struct","summary":"Represents the three coordinates of a point in three-dimensional space, using double-precision floating point values.","constructors":[{"signature":"Point3d(double x, double y, double z)","summary":"Initializes a new point by defining the X, Y and Z coordinates.","since":"5.0","parameters":[{"name":"x","summary":"The value of the X (first) coordinate."},{"name":"y","summary":"The value of the Y (second) coordinate."},{"name":"z","summary":"The value of the Z (third) coordinate."}]},{"signature":"Point3d(Point3d point)","summary":"Initializes a new point by copying coordinates from another point.","since":"5.0","parameters":[{"name":"point","summary":"A point."}]},{"signature":"Point3d(Point3f point)","summary":"Initializes a new point by copying coordinates from a single-precision point.","since":"5.0","parameters":[{"name":"point","summary":"A point."}]},{"signature":"Point3d(Point4d point)","summary":"Initializes a new point by copying coordinates from a four-dimensional point. The first three coordinates are divided by the last one. If the W (fourth) dimension of the input point is zero, then it will be just discarded.","since":"5.0","parameters":[{"name":"point","summary":"A point."}]},{"signature":"Point3d(Vector3d vector)","summary":"Initializes a new point by copying coordinates from the components of a vector.","since":"5.0","parameters":[{"name":"vector","summary":"A vector."}]}],"properties":[{"signature":"static Point3d Origin","summary":"Gets the value of a point at location 0,0,0.","since":"5.0","property":["get"]},{"signature":"static Point3d Unset","summary":"Gets the value of a point at location RhinoMath.UnsetValue,RhinoMath.UnsetValue,RhinoMath.UnsetValue.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Each coordinate of the point must pass the RhinoMath.IsValidDoubletest.","since":"5.0","property":["get"]},{"signature":"double MaximumCoordinate","summary":"Gets the largest (both positive and negative) valid coordinate in this point, or RhinoMath.UnsetValue if no coordinate is valid.","since":"5.0","property":["get"]},{"signature":"double MinimumCoordinate","summary":"Gets the smallest (both positive and negative) coordinate value in this point.","since":"5.0","property":["get"]},{"signature":"double X","summary":"Gets or sets the X (first) coordinate of this point.","since":"5.0","property":["get","set"]},{"signature":"double Y","summary":"Gets or sets the Y (second) coordinate of this point.","since":"5.0","property":["get","set"]},{"signature":"double Z","summary":"Gets or sets the Z (third) coordinate of this point.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static Point3d Add(Point3d point1, Point3d point2)","summary":"Sums two Point3dinstances.  \\n(Provided for languages that do not support operator overloading. You can use the + operator otherwise)","since":"5.0","parameters":[{"name":"point1","summary":"A point."},{"name":"point2","summary":"A point."}],"returns":"A new point that results from the addition of point1 and point2."},{"signature":"static Point3d Add(Point3d point, Vector3d vector)","summary":"Sums up a point and a vector, and returns a new point.  \\n(Provided for languages that do not support operator overloading. You can use the + operator otherwise)","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"vector","summary":"A vector."}],"returns":"A new point that results from the addition of point and vector."},{"signature":"static Point3d Add(Point3d point, Vector3f vector)","summary":"Sums up a point and a vector, and returns a new point.  \\n(Provided for languages that do not support operator overloading. You can use the + operator otherwise)","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"vector","summary":"A vector."}],"returns":"A new point that results from the addition of point and vector."},{"signature":"static Point3d Add(Vector3d vector, Point3d point)","summary":"Sums up a point and a vector, and returns a new point.  \\n(Provided for languages that do not support operator overloading. You can use the + operator otherwise)","since":"5.0","parameters":[{"name":"vector","summary":"A vector."},{"name":"point","summary":"A point."}],"returns":"A new point that results from the addition of point and vector."},{"signature":"static bool ArePointsCoplanar(IEnumerable<Point3d> points, double tolerance)","summary":"Determines whether a set of points is coplanar within a given tolerance.","since":"5.0","parameters":[{"name":"points","summary":"A list, an array or any enumerable of Point3d."},{"name":"tolerance","summary":"A tolerance value. A default might be RhinoMath.ZeroTolerance."}],"returns":"True if points are on the same plane; False otherwise."},{"signature":"static Point3d[] CullDuplicates(IEnumerable<Point3d> points, double tolerance)","summary":"Removes duplicates in the supplied set of points.","since":"5.0","parameters":[{"name":"points","summary":"A list, an array or any enumerable of Point3d."},{"name":"tolerance","summary":"The minimum distance between points.  \\nPoints that fall within this tolerance will be discarded. ."}],"returns":"An array of points without duplicates; or None on error."},{"signature":"static Point3d Divide(Point3d point, double t)","summary":"Divides a Point3dby a number.  \\n(Provided for languages that do not support operator overloading. You can use the / operator otherwise)","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"t","summary":"A number."}],"returns":"A new point that is coordinate-wise divided by t."},{"signature":"static Point3d FromPoint3f(Point3f point)","summary":"Converts a single-precision point in a double-precision point.","since":"6.0","parameters":[{"name":"point","summary":"A point."}],"returns":"The resulting point."},{"signature":"static Point3d Multiply(double t, Point3d point)","summary":"Multiplies a Point3dby a number.  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"5.0","parameters":[{"name":"t","summary":"A number."},{"name":"point","summary":"A point."}],"returns":"A new point that is coordinate-wise multiplied by t."},{"signature":"static Point3d Multiply(Point3d point, double t)","summary":"Multiplies a Point3dby a number.  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"t","summary":"A number."}],"returns":"A new point that is coordinate-wise multiplied by t."},{"signature":"static Point3d[] SortAndCullPointList(IEnumerable<Point3d> points, double minimumDistance)","summary":"Orders a set of points so they will be connected in a \\"reasonable polyline\\" order.  \\nAlso, removes points from the list if their common distance exceeds a specified threshold.","since":"5.0","parameters":[{"name":"points","summary":"A list, an array or any enumerable of Point3d."},{"name":"minimumDistance","summary":"Minimum allowed distance among a pair of points. If points are closer than this, only one of them will be kept."}],"returns":"The new array of sorted and culled points."},{"signature":"static Vector3d Subtract(Point3d point1, Point3d point2)","summary":"Subtracts a point from another point.  \\n(Provided for languages that do not support operator overloading. You can use the - operator otherwise)","since":"5.0","parameters":[{"name":"point1","summary":"A point."},{"name":"point2","summary":"Another point."}],"returns":"A new vector that is the difference of point minus vector."},{"signature":"static Point3d Subtract(Point3d point, Vector3d vector)","summary":"Subtracts a vector from a point.  \\n(Provided for languages that do not support operator overloading. You can use the - operator otherwise)","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"vector","summary":"A vector."}],"returns":"A new point that is the difference of point minus vector."},{"signature":"static bool TryParse(string input, out Point3d result)","summary":"Converts the string representation of a point to the equivalent Point3d structure.","since":"6.12","parameters":[{"name":"input","summary":"The point to convert."},{"name":"result","summary":"The structure that will contain the parsed value."}],"returns":"True if successful, False otherwise."},{"signature":"int CompareTo(Point3d other)","summary":"Compares this Point3dwith another Point3d.  \\nComponent evaluation priority is first X, then Y, then Z.","since":"5.0","parameters":[{"name":"other","summary":"The other Point3dto use in comparison."}],"returns":"0: if this is identical to other  \\n-1: if this.X < other.X  \\n-1: if this.X == other.X and this.Y < other.Y  \\n-1: if this.X == other.X and this.Y == other.Y and this.Z < other.Z  \\n+1: otherwise."},{"signature":"double DistanceTo(Point3d other)","summary":"Computes the distance between two points.","since":"5.0","parameters":[{"name":"other","summary":"Other point for distance measurement."}],"returns":"The length of the line between this and the other point; or 0 if any of the points is not valid."},{"signature":"double DistanceToSquared(Point3d other)","summary":"Computes the square of the distance between two points.  \\nThis method is usually largely faster than DistanceTo().","since":"6.0","parameters":[{"name":"other","summary":"Other point for squared distance measurement."}],"returns":"The squared length of the line between this and the other point; or 0 if any of the points is not valid."},{"signature":"bool EpsilonEquals(Point3d other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(object obj)","summary":"Determines whether the specified objectis a Point3dand has the same values as the present point.","parameters":[{"name":"obj","summary":"The specified object."}],"returns":"True if obj is a Point3d and has the same coordinates as this; otherwise false."},{"signature":"bool Equals(Point3d point)","summary":"Determines whether the specified Point3dhas the same values as the present point.","since":"5.0","parameters":[{"name":"point","summary":"The specified point."}],"returns":"True if point has the same coordinates as this; otherwise false."},{"signature":"int GetHashCode()","summary":"Computes a hash code for the present point.","returns":"A non-unique integer that represents this point."},{"signature":"void Interpolate(Point3d pA, Point3d pB, double t)","summary":"Interpolate between two points.","since":"5.0","parameters":[{"name":"pA","summary":"First point."},{"name":"pB","summary":"Second point."},{"name":"t","summary":"Interpolation parameter. If t=0 then this point is set to pA. If t=1 then this point is set to pB. Values of t in between 0.0 and 1.0 result in points between pA and pB."}]},{"signature":"string ToString()","summary":"Constructs the string representation for the current point.","returns":"The point representation in the form X,Y,Z."},{"signature":"string ToString(string format, IFormatProvider formatProvider)","since":"7.0"},{"signature":"void Transform(Transform xform)","summary":"Transforms the present point in place. The transformation matrix acts on the left of the point. i.e.,  \\nresult = transformation*point","since":"5.0","parameters":[{"name":"xform","summary":"Transformation to apply."}]}]},{"namespace":"Rhino.Geometry","name":"Point3dGrid","dataType":"class","summary":"Represents a rectangular grid of 3D points.","baseclass":"Rhino.Geometry.GeometryBase","constructors":[{"signature":"Point3dGrid()","summary":"Initializes a rectangular grid of points, with no points in it.","since":"5.0"},{"signature":"Point3dGrid(int rows, int columns)","summary":"Initializes a rectangular grid of points with a given number of columns and rows.","since":"5.0","parameters":[{"name":"rows","summary":"An amount of rows."},{"name":"columns","summary":"An amount of columns."}]}]},{"namespace":"Rhino.Geometry","name":"Point3f","dataType":"struct","summary":"Represents the three coordinates of a point in three-dimensional space, using Single-precision floating point numbers.","constructors":[{"signature":"Point3f(float x, float y, float z)","summary":"Initializes a new two-dimensional vector from two components.","since":"5.0","parameters":[{"name":"x","summary":"X component of vector."},{"name":"y","summary":"Y component of vector."},{"name":"z","summary":"Z component of vector."}]}],"properties":[{"signature":"static Point3f Origin","summary":"Gets the value of a point at location 0,0,0.","since":"5.0","property":["get"]},{"signature":"static Point3f Unset","summary":"Gets the value of a point at location RhinoMath.UnsetValue,RhinoMath.UnsetValue,RhinoMath.UnsetValue.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Each coordinate of the point must pass the RhinoMath.IsValidSingletest.","since":"5.0","property":["get"]},{"signature":"float X","summary":"Gets or sets the X (first) component of the vector.","since":"5.0","property":["get","set"]},{"signature":"float Y","summary":"Gets or sets the Y (second) component of the vector.","since":"5.0","property":["get","set"]},{"signature":"float Z","summary":"Gets or sets the Z (third) component of the vector.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static Vector3f Subtract(Point3f point1, Point3f point2)","summary":"Subtracts a point from another point.  \\n(Provided for languages that do not support operator overloading. You can use the - operator otherwise)","since":"5.0","parameters":[{"name":"point1","summary":"A point."},{"name":"point2","summary":"Another point."}],"returns":"A new vector that is the difference of point minus vector."},{"signature":"int CompareTo(Point3f other)","summary":"Compares this Point3fwith another Point3f.  \\nComponent evaluation priority is first X, then Y, then Z.","since":"5.0","parameters":[{"name":"other","summary":"The other Point3dto use in comparison."}],"returns":"0: if this is identical to other  \\n-1: if this.X < other.X  \\n-1: if this.X == other.X and this.Y < other.Y  \\n-1: if this.X == other.X and this.Y == other.Y and this.Z < other.Z  \\n+1: otherwise."},{"signature":"double DistanceTo(Point3f other)","summary":"Computes the distance between two points.","since":"5.0","parameters":[{"name":"other","summary":"Other point for distance measurement."}],"returns":"The length of the line between this and the other point; or 0 if any of the points is not valid."},{"signature":"bool EpsilonEquals(Point3f other, float epsilon)","summary":"Check that all values in other are withing epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(object obj)","summary":"Determines whether the specified System.Object is a Point3f and has the same values as the present point.","parameters":[{"name":"obj","summary":"The specified object."}],"returns":"True if obj is Point3f and has the same coordinates as this; otherwise false."},{"signature":"bool Equals(Point3f point)","summary":"Determines whether the specified Point3f has the same values as the present point.","since":"5.0","parameters":[{"name":"point","summary":"The specified point."}],"returns":"True if point has the same coordinates as this; otherwise false."},{"signature":"int GetHashCode()","summary":"Computes a hash code for the present point.","returns":"A non-unique integer that represents this point."},{"signature":"string ToString()","summary":"Constructs the string representation for the current point.","returns":"The point representation in the form X,Y,Z."},{"signature":"string ToString(string format, IFormatProvider formatProvider)","since":"7.0"},{"signature":"void Transform(Transform xform)","summary":"Transforms the present point in place. The transformation matrix acts on the left of the point. i.e.,  \\nresult = transformation*point","since":"5.0","parameters":[{"name":"xform","summary":"Transformation to apply."}]}]},{"namespace":"Rhino.Geometry","name":"Point4d","dataType":"struct","summary":"Represents the four coordinates of a point in four-dimensional space.  \\nThe W (fourth) dimension is often considered the weight of the point as seen in 3D space.","constructors":[{"signature":"Point4d(double x, double y, double z, double w)","summary":"Initializes a new instance of the Point4dclass based on coordinates.","since":"5.0","parameters":[{"name":"x","summary":"The X (first) dimension."},{"name":"y","summary":"The Y (second) dimension."},{"name":"z","summary":"The Z (third) dimension."},{"name":"w","summary":"The W (fourth) dimension, or weight."}]},{"signature":"Point4d(Point3d point)","summary":"Initializes a new instance of the Point4dclass from the coordinates of a point.","since":"5.0","parameters":[{"name":"point","summary":"."}]},{"signature":"Point4d(Point4d point)","summary":"Initializes a new point by copying coordinates from another point.","since":"6.0","parameters":[{"name":"point","summary":"A point."}]}],"properties":[{"signature":"static Point4d Unset","summary":"Gets the value of a point with all coordinates set as RhinoMath.UnsetValue.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Returns an indication regarding the validity of this point.","since":"6.0","property":["get"]},{"signature":"double W","summary":"Gets or sets the W (fourth) coordinate -or weight- of this point.","since":"5.0","property":["get","set"]},{"signature":"double X","summary":"Gets or sets the X (first) coordinate of this point.","since":"5.0","property":["get","set"]},{"signature":"double Y","summary":"Gets or sets the Y (second) coordinate of this point.","since":"5.0","property":["get","set"]},{"signature":"double Z","summary":"Gets or sets the Z (third) coordinate of this point.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static Point4d Add(Point4d point1, Point4d point2)","summary":"Sums two Point4dtogether.  \\n(Provided for languages that do not support operator overloading. You can use the + operator otherwise)","since":"5.0","parameters":[{"name":"point1","summary":"First point."},{"name":"point2","summary":"Second point."}],"returns":"A new point that results from the weighted addition of point1 and point2."},{"signature":"static Point4d Multiply(Point4d point, double d)","summary":"Multiplies a point by a number.  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"d","summary":"A number."}],"returns":"A new point that results from the coordinate-wise multiplication of point with d."},{"signature":"static Point4d Subtract(Point4d point1, Point4d point2)","summary":"Subtracts the second point from the first point.  \\n(Provided for languages that do not support operator overloading. You can use the - operator otherwise)","since":"5.0","parameters":[{"name":"point1","summary":"First point."},{"name":"point2","summary":"Second point."}],"returns":"A new point that results from the weighted subtraction of point2 from point1."},{"signature":"bool EpsilonEquals(Point4d other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(object obj)","summary":"Determines whether the specified System.Object is Point4d and has same coordinates as the present point.","parameters":[{"name":"obj","summary":"The specified object."}],"returns":"True if obj is Point4d and has the same coordinates as this; otherwise false."},{"signature":"bool Equals(Point4d point)","summary":"Determines whether the specified point has same value as the present point.","since":"5.0","parameters":[{"name":"point","summary":"The specified point."}],"returns":"True if point has the same value as this; otherwise false."},{"signature":"int GetHashCode()","summary":"Computes the hash code for the present point.","returns":"A non-unique hash code, which uses all coordinates of this object."},{"signature":"string ToString()"},{"signature":"string ToString(string format, IFormatProvider formatProvider)","since":"7.0"},{"signature":"void Transform(Transform xform)","summary":"Transforms the present point in place. The transformation matrix acts on the left of the point. i.e.,  \\nresult = transformation*point","since":"6.0","parameters":[{"name":"xform","summary":"Transformation to apply."}]}]},{"namespace":"Rhino.Geometry","name":"PointCloud","dataType":"class","summary":"Represents a collection of coordinates with optional normal vectors and colors.","baseclass":"Rhino.Geometry.GeometryBase","interfaces":["IEnumerable<PointCloudItem>"],"constructors":[{"signature":"PointCloud()","summary":"Initializes a new instance of the PointCloudclass that is empty.","since":"5.0"},{"signature":"PointCloud(IEnumerable<Point3d> points)","summary":"Initializes a new instance of the PointCloudclass, copying the content from a set of points.","since":"5.0","parameters":[{"name":"points","summary":"A list or an array of Point3d, or any object that implements IEnumerable{Point3d}."}]},{"signature":"PointCloud(PointCloud other)","summary":"Initializes a new instance of the PointCloudclass, copying (Merge) the content of another point cloud.","since":"5.0"}],"properties":[{"signature":"bool ContainsColors","summary":"Gets a value indicating whether or not the points in this point cloud have colors assigned to them.","since":"5.0","property":["get"]},{"signature":"bool ContainsHiddenFlags","summary":"Gets a value indicating whether or not the points in this point cloud have hidden flags assigned to them.","since":"5.0","property":["get"]},{"signature":"bool ContainsNormals","summary":"Gets a value indicating whether or not the points in this point cloud have normals assigned to them.","since":"5.0","property":["get"]},{"signature":"int Count","summary":"Gets the number of points in this point cloud.","since":"5.0","property":["get"]},{"signature":"int HiddenPointCount","summary":"Gets the number of points that have their Hidden flag set.","since":"5.0","property":["get"]}],"methods":[{"signature":"void Add(Point3d point)","summary":"Append a new point to the end of the list.","since":"5.0","parameters":[{"name":"point","summary":"Point to append."}]},{"signature":"void Add(Point3d point, Color color)","summary":"Append a new point to the end of the list.","since":"5.0","parameters":[{"name":"point","summary":"Point to append."},{"name":"color","summary":"Color of new point."}]},{"signature":"void Add(Point3d point, Vector3d normal)","summary":"Append a new point to the end of the list.","since":"5.0","parameters":[{"name":"point","summary":"Point to append."},{"name":"normal","summary":"Normal vector of new point."}]},{"signature":"void Add(Point3d point, Vector3d normal, Color color)","summary":"Append a new point to the end of the list.","since":"5.0","parameters":[{"name":"point","summary":"Point to append."},{"name":"normal","summary":"Normal vector of new point."},{"name":"color","summary":"Color of new point."}]},{"signature":"void AddRange(IEnumerable<Point3d> points)","summary":"Appends a collection of points to this point cloud.","since":"5.0","parameters":[{"name":"points","summary":"Points to append."}]},{"signature":"void AddRange(IEnumerable<Point3d> points, IEnumerable<Color> colors)","summary":"Appends a collection of points and normal vectors to this point cloud.","since":"6.0","parameters":[{"name":"points","summary":"Points to append."},{"name":"colors","summary":"Colors to append."}]},{"signature":"void AddRange(IEnumerable<Point3d> points, IEnumerable<Vector3d> normals)","summary":"Appends a collection of points and normal vectors to this point cloud.","since":"6.0","parameters":[{"name":"points","summary":"Points to append."},{"name":"normals","summary":"Normal Vectors to append."}]},{"signature":"void AddRange(IEnumerable<Point3d> points, IEnumerable<Vector3d> normals, IEnumerable<Color> colors)","summary":"Appends a collection of points and normal vectors to this point cloud.","since":"6.0","parameters":[{"name":"points","summary":"Points to append."},{"name":"normals","summary":"Normal Vectors to append."},{"name":"colors","summary":"Colors to append."}]},{"signature":"PointCloudItem AppendNew()","summary":"Appends a new PointCloudItem to the end of this point cloud.","since":"5.0","returns":"The newly appended item."},{"signature":"IReadOnlyList<Point3d> AsReadOnlyListOfPoints()","summary":"Returns an enumerator and list indexer over point cloud locations.","since":"6.0","returns":"The read-only list. This is a reference to the present point cloud."},{"signature":"void ClearColors()","summary":"Destroys the color information in this point cloud.","since":"5.0"},{"signature":"void ClearHiddenFlags()","summary":"Destroys the hidden flag information in this point cloud.","since":"5.0"},{"signature":"void ClearNormals()","summary":"Destroys the normal vector information in this point cloud.","since":"5.0"},{"signature":"int ClosestPoint(Point3d testPoint)","summary":"Returns index of the closest point in the point cloud to a given test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"."}],"returns":"Index of point in the point cloud on success. -1 on failure."},{"signature":"Color[] GetColors()","summary":"Copy all the point colors in this point cloud to an array.","since":"5.0","returns":"An array containing all the colors in this point cloud."},{"signature":"IEnumerator<PointCloudItem> GetEnumerator()","summary":"Gets an enumerator that allows to modify each point cloud point.","since":"5.0","returns":"A instance of IEnumerator{PointCloudItem}."},{"signature":"Vector3d[] GetNormals()","summary":"Copy all the normal vectors in this point cloud to an array.","since":"5.0","returns":"An array containing all the normals in this point cloud."},{"signature":"Point3d[] GetPoints()","summary":"Copy all the point coordinates in this point cloud to an array.","since":"5.0","returns":"An array containing all the points in this point cloud."},{"signature":"void Insert(int index, Point3d point)","summary":"Inserts a new point into the point list.","since":"5.0","parameters":[{"name":"index","summary":"Insertion index."},{"name":"point","summary":"Point to append."}]},{"signature":"void Insert(int index, Point3d point, Color color)","summary":"Inserts a new point into the point list.","since":"5.0","parameters":[{"name":"index","summary":"Insertion index."},{"name":"point","summary":"Point to append."},{"name":"color","summary":"Color of new point."}]},{"signature":"void Insert(int index, Point3d point, Vector3d normal)","summary":"Inserts a new point into the point list.","since":"5.0","parameters":[{"name":"index","summary":"Insertion index."},{"name":"point","summary":"Point to append."},{"name":"normal","summary":"Normal vector of new point."}]},{"signature":"void Insert(int index, Point3d point, Vector3d normal, Color color)","summary":"Inserts a new point into the point list.","since":"5.0","parameters":[{"name":"index","summary":"Insertion index."},{"name":"point","summary":"Point to append."},{"name":"normal","summary":"Normal vector of new point."},{"name":"color","summary":"Color of new point."}]},{"signature":"PointCloudItem InsertNew(int index)","summary":"Inserts a new PointCloudItemat a specific position of the point cloud.","since":"5.0","parameters":[{"name":"index","summary":"Index of new item."}],"returns":"The newly inserted item."},{"signature":"void InsertRange(int index, IEnumerable<Point3d> points)","summary":"Append a collection of points to this point cloud.","since":"5.0","parameters":[{"name":"index","summary":"Index at which to insert the new collection."},{"name":"points","summary":"Points to append."}]},{"signature":"void Merge(PointCloud other)","summary":"Copies the point values of another point cloud into this one.","since":"5.0","parameters":[{"name":"other","summary":"PointCloud to merge with this one."}]},{"signature":"Point3d PointAt(int index)","summary":"Returns the location of the point at a specific index.","since":"6.0","parameters":[{"name":"index","summary":"The index."}]},{"signature":"void RemoveAt(int index)","summary":"Remove the point at the given index.","since":"5.0","parameters":[{"name":"index","summary":"Index of point to remove."}]}]},{"namespace":"Rhino.Geometry","name":"PointCloudItem","dataType":"class","summary":"Represents a single item in a point cloud. A PointCloud item always has a location, but it has an optional normal vector and color.","properties":[{"signature":"Color Color","summary":"Gets or sets the color of this point cloud item.","since":"5.0","property":["get","set"]},{"signature":"bool Hidden","summary":"Gets or sets the hidden flag of this point cloud item.","since":"5.0","property":["get","set"]},{"signature":"int Index","summary":"Gets the index of this point cloud item.","since":"5.0","property":["get"]},{"signature":"Point3d Location","summary":"Gets or sets the location of this point cloud item.","since":"5.0","property":["get","set"]},{"signature":"Vector3d Normal","summary":"Gets or sets the normal vector for this point cloud item.","since":"5.0","property":["get","set"]},{"signature":"double X","summary":"Gets or sets the X component of this point cloud item location.","since":"5.0","property":["get","set"]},{"signature":"double Y","summary":"Gets or sets the Y component of this point cloud item location.","since":"5.0","property":["get","set"]},{"signature":"double Z","summary":"Gets or sets the Z component of this point cloud item location.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.Geometry","name":"PointContainment","dataType":"enum","summary":"Defines enumerated values for closed curve/point spatial relationships.","since":"5.0","values":[{"signature":"Unset","summary":"Relation is meaningless."},{"signature":"Inside","summary":"Point is on the interior of the region implied by the closed curve."},{"signature":"Outside","summary":"Point is on the exterior of the region implied by the closed curve."},{"signature":"Coincident","summary":"Point is coincident with the curve and therefor neither inside not outside."}]},{"namespace":"Rhino.Geometry","name":"PointFaceRelation","dataType":"enum","summary":"Enumerates the possible point/BrepFace spatial relationships.","since":"5.0","values":[{"signature":"Exterior = 0","summary":"Point is on the exterior (the trimmed part) of the face."},{"signature":"Interior = 1","summary":"Point is on the interior (the existing part) of the face."},{"signature":"Boundary = 2","summary":"Point is in limbo."}]},{"namespace":"Rhino.Geometry","name":"PolyCurve","dataType":"class","summary":"Represents a curve that is the result of joining several (possibly different) types of curves.","baseclass":"Rhino.Geometry.Curve","constructors":[{"signature":"PolyCurve()","summary":"Initializes a new, empty polycurve.","since":"5.0"}],"properties":[{"signature":"bool HasGap","summary":"This is a quick way to see if the curve has gaps between the sub curve segments.","since":"5.0","property":["get"]},{"signature":"bool IsNested","summary":"Gets a value indicating whether or not a PolyCurve contains nested PolyCurves.","since":"5.0","property":["get"]},{"signature":"int SegmentCount","summary":"Gets the number of segments that make up this Polycurve.","since":"5.0","property":["get"]}],"methods":[{"signature":"bool Append(Arc arc)","summary":"Appends and matches the start of the arc to the end of polycurve. This function will fail if the polycurve is closed or if SegmentCount > 0 and the arc is closed.","since":"5.0","parameters":[{"name":"arc","summary":"Arc segment to append."}],"returns":"True on success, False on failure."},{"signature":"bool Append(Curve curve)","summary":"Appends and matches the start of the curve to the end of polycurve. This function will fail if the PolyCurve is closed or if SegmentCount > 0 and the new segment is closed.","since":"5.0","parameters":[{"name":"curve","summary":"Segment to append."}],"returns":"True on success, False on failure."},{"signature":"bool Append(Line line)","summary":"Appends and matches the start of the line to the end of polycurve. This function will fail if the polycurve is closed.","since":"5.0","parameters":[{"name":"line","summary":"Line segment to append."}],"returns":"True on success, False on failure."},{"signature":"bool AppendSegment(Curve curve)","summary":"Appends the curve to the polycurve without changing the new segment\'s geometry. This function will fail if the PolyCurve is closed or if SegmentCount > 0 and the new segment is closed.","since":"6.0","parameters":[{"name":"curve","summary":"Segment to append."}],"returns":"True on success, False on failure."},{"signature":"Curve CleanUp()","summary":"Removes any nesting of polycurves. If this polycurve has just a single segment, the segment is returned. If, after nest removal, there are adjacent segments which are polylines, they are combined into a single polyline. The new curve may have a different domain from this polycurve. If the start and end segments of a closed input are polylines, the result may have a different seam location since the start and end segments will be combined.","since":"7.0","returns":"A new curve that is not necessarily a polycurve if successful, None otherwise."},{"signature":"GeometryBase Duplicate()","summary":"Duplicates this polycurve.  \\nWhen not overridden in a derived class, this calls .","since":"5.0","returns":"An exact duplicate of this curve."},{"signature":"PolyCurve DuplicatePolyCurve()","summary":"Duplicates this polycurve.  \\nThis is the same as .","since":"5.0","returns":"An exact duplicate of this curve."},{"signature":"Curve[] Explode()","summary":"Explodes this PolyCurve into a list of Curve segments. This willnot explodenested polycurves. Call RemoveNestingfirst if you need all individual segments.","since":"5.0","returns":"An array of polycurve segments."},{"signature":"double PolyCurveParameter(int segmentIndex, double segmentCurveParameter)","summary":"Converts a segment curve parameter to a polycurve parameter.","since":"5.0","parameters":[{"name":"segmentIndex","summary":"Index of segment."},{"name":"segmentCurveParameter","summary":"Parameter on segment."}],"returns":"Polycurve evaluation parameter or UnsetValue if the polycurve curve parameter could not be computed."},{"signature":"bool RemoveNesting()","summary":"Explodes nested polycurve segments and reconstructs this curve from the shattered remains. The result will have not have any PolyCurves as segments but it will have identical locus and parameterization.","since":"5.0","returns":"True if any nested PolyCurve was found and absorbed, False if no PolyCurve segments could be found."},{"signature":"Curve SegmentCurve(int index)","summary":"Gets the segment curve at the given index.","since":"5.0","parameters":[{"name":"index","summary":"Index of segment to retrieve."}],"returns":"The segment at the given index or None on failure."},{"signature":"double SegmentCurveParameter(double polycurveParameter)","summary":"Converts a polycurve parameter to a segment curve parameter.","since":"5.0","parameters":[{"name":"polycurveParameter","summary":"Parameter on PolyCurve to convert."}],"returns":"Segment curve evaluation parameter or UnsetValue if the segment curve parameter could not be computed."},{"signature":"Interval SegmentDomain(int segmentIndex)","summary":"Returns the polycurve sub-domain assigned to a segment curve.","since":"5.0","parameters":[{"name":"segmentIndex","summary":"Index of segment."}],"returns":"The polycurve sub-domain assigned to a segment curve. Returns Interval.Unset if segment_index < 0 or segment_index >= Count()."},{"signature":"int SegmentIndex(double polycurveParameter)","summary":"Finds the segment used for evaluation at polycurve_parameter.","since":"5.0","parameters":[{"name":"polycurveParameter","summary":"Parameter on polycurve for segment lookup."}],"returns":"Index of the segment used for evaluation at polycurve_parameter. If polycurve_parameter < Domain.Min(), then 0 is returned. If polycurve_parameter > Domain.Max(), then Count()-1 is returned."},{"signature":"int SegmentIndexes(Interval subdomain, out int segmentIndex0, out int segmentIndex1)","summary":"Finds the segments that overlap the Polycurve sub domain.","since":"5.0","parameters":[{"name":"subdomain","summary":"Domain on this PolyCurve."},{"name":"segmentIndex0","summary":"Index of first segment that overlaps the sub-domain."},{"name":"segmentIndex1","summary":"Index of last segment that overlaps the sub-domain. Note that segmentIndex0 <= i < segmentIndex1."}],"returns":"Number of segments that overlap the sub-domain."}]},{"namespace":"Rhino.Geometry","name":"Polyline","dataType":"class","summary":"Represents an ordered set of points connected by linear segments.  \\nPolylines are closed if start and end points coincide.","baseclass":"Rhino.Collections.Point3dList","interfaces":["ICloneable"],"constructors":[{"signature":"Polyline()","summary":"Initializes a new empty polyline.","since":"5.0"},{"signature":"Polyline(IEnumerable<Point3d> collection)","summary":"Initializes a new polyline from a collection of points.","since":"5.0","parameters":[{"name":"collection","summary":"Points to copy into the local vertex array."}]},{"signature":"Polyline(int initialCapacity)","summary":"Initializes a new empty polyline with an initial capacity.","since":"5.0","parameters":[{"name":"initialCapacity","summary":"Number of vertices this polyline can contain without resizing."}]}],"properties":[{"signature":"bool IsClosed","summary":"Gets a value that indicates whether this polyline is closed.  \\nThe polyline is considered to be closed if its start is identical to its endpoint.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Gets a value that indicates whether this polyline is valid.  \\nValid polylines have at least one segment, no Invalid points and no zero length segments.  \\nClosed polylines with only two segments are also not considered valid.","since":"5.0","property":["get"]},{"signature":"double Length","summary":"Gets the total length of the polyline.","since":"5.0","property":["get"]},{"signature":"int SegmentCount","summary":"Gets the number of segments for this polyline.","since":"5.0","property":["get"]}],"methods":[{"signature":"static Polyline CreateCircumscribedPolygon(Circle circle, int sideCount)","summary":"Create a regular polygon circumscribe about a circle. The midpoints of the polygon\'s edges will be tangent to the circle.","since":"6.10","parameters":[{"name":"circle","summary":"The circle."},{"name":"sideCount","summary":"The number of sides"}],"returns":"A closed polyline if successful, None otherwise."},{"signature":"static Polyline CreateInscribedPolygon(Circle circle, int sideCount)","summary":"Create a regular polygon inscribed in a circle. The vertices of the polygon will be on the circle.","since":"6.10","parameters":[{"name":"circle","summary":"The circle."},{"name":"sideCount","summary":"The number of sides"}],"returns":"A closed polyline if successful, None otherwise."},{"signature":"static Polyline CreateStarPolygon(Circle circle, double radius, int cornerCount)","summary":"Create a regular star polygon. The star begins at circle.PointAt(0) and the vertices alternate between being on circle and begin on a concentric circle of other_radius.","since":"6.10","parameters":[{"name":"circle","summary":"The circle."},{"name":"radius","summary":"The radius of other circle."},{"name":"cornerCount","summary":"The number of corners on the circle. There will be 2*cornerCount sides and 2*cornerCount vertices."}],"returns":"A closed polyline if successful, None otherwise."},{"signature":"Polyline[] BreakAtAngles(double angle)","summary":"Breaks this polyline into sections at sharp kinks. Closed polylines will also be broken at the first and last vertex.","since":"5.0","parameters":[{"name":"angle","summary":"Angle (in radians) between adjacent segments for a break to occur."}],"returns":"An array of polyline segments, or None on error."},{"signature":"Point3d CenterPoint()","summary":"Compute the center point of the polyline as the weighted average of all segments.","since":"5.0","returns":"The weighted average of all segments."},{"signature":"double ClosestParameter(Point3d testPoint)","summary":"Gets the parameter along the polyline which is closest to a test-point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to approximate."}],"returns":"The parameter along the polyline closest to testPoint."},{"signature":"Point3d ClosestPoint(Point3d testPoint)","summary":"Gets the point on the polyline which is closest to a test-point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to approximate."}],"returns":"The point on the polyline closest to testPoint."},{"signature":"int CollapseShortSegments(double tolerance)","summary":"Collapses all segments until none are shorter than tolerance. This function is significantly slower than DeleteShortSegments, since it recursively operates on the shortest segment. When a segment is collapsed the end-points are placed in the center of the segment.","since":"5.0","parameters":[{"name":"tolerance","summary":"Tolerance to use during collapsing."}],"returns":"The number of segments that were collapsed."},{"signature":"int DeleteShortSegments(double tolerance)","summary":"Removes all points that are closer than tolerance to the previous point.  \\nStart and end points are left intact.","since":"5.0","parameters":[{"name":"tolerance","summary":"Vertices closer together than tolerance will be removed."}],"returns":"Number of points (and segments) removed."},{"signature":"Polyline Duplicate()","summary":"Returns a deep copy of this polyline instance.","since":"6.0","returns":"The duplicated polyline."},{"signature":"Line[] GetSegments()","summary":"Constructs an array of line segments that make up the entire polyline.","since":"5.0","returns":"An array of line segments or None if the polyline contains fewer than 2 points."},{"signature":"bool IsClosedWithinTolerance(double tolerance)","summary":"Determines whether the polyline is closed, provided a tolerance value.","since":"5.0","parameters":[{"name":"tolerance","summary":"If the distance between the start and end point of the polyline is less than tolerance, the polyline is considered to be closed."}],"returns":"True if the polyline is closed to within tolerance, False otherwise."},{"signature":"int MergeColinearSegments(double angleTolerance, bool includeSeam)","summary":"Merge co-linear consecutive segments in a polyline. This method will automatically remove any zero-length segments as well.","since":"6.3","parameters":[{"name":"angleTolerance","summary":"The angle tolerance between adjacent segments for collinearity test."},{"name":"includeSeam","summary":"If true, the seam point of a closed polyline will be moved forwards if it is collinear too."}],"returns":"Number of segments removed from the entire polyline."},{"signature":"Point3d PointAt(double t)","summary":"Gets the point on the polyline at the given parameter. The integer part of the parameter indicates the index of the segment.","since":"5.0","parameters":[{"name":"t","summary":"Polyline parameter."}],"returns":"The point on the polyline at t."},{"signature":"int ReduceSegments(double tolerance)","summary":"Constructs a reduction of this polyline by recursively removing the least significant segments.","since":"5.0","parameters":[{"name":"tolerance","summary":"Tolerance for reduction. Whenever a vertex of the polyline is more significant than tolerance, it will be included in the reduction."}],"returns":"The number of vertices that disappeared due to reduction."},{"signature":"Line SegmentAt(int index)","summary":"Gets the line segment at the given index.","since":"5.0","parameters":[{"name":"index","summary":"Index of segment to retrieve."}],"returns":"Line segment at index or Line.Unset on failure."},{"signature":"bool Smooth(double amount)","summary":"Smoothen the polyline segments by averaging adjacent vertices. Smoothing requires a polyline with exclusively valid vertices.","since":"5.0","parameters":[{"name":"amount","summary":"Amount to smooth. Zero equals no smoothing, one equals complete smoothing."}],"returns":"True on success, False on failure."},{"signature":"Vector3d TangentAt(double t)","summary":"Gets the unit tangent vector along the polyline at the given parameter. The integer part of the parameter indicates the index of the segment.","since":"5.0","parameters":[{"name":"t","summary":"Polyline parameter."}],"returns":"The tangent along the polyline at t."},{"signature":"NurbsCurve ToNurbsCurve()","summary":"Constructs a nurbs curve representation of this polyline.","since":"5.0","returns":"A Nurbs curve shaped like this polyline or None on failure."},{"signature":"PolylineCurve ToPolylineCurve()","summary":"Constructs a polyline curve representation of this polyline.","since":"6.0","returns":"A curve shaped like this polyline or None on failure."},{"signature":"MeshFace[] TriangulateClosedPolyline()","summary":"Attempts to create a list of triangles which represent a triangulation of a closed polyline","since":"5.0"},{"signature":"Polyline Trim(Interval domain)","summary":"Constructs a polyline out of a parameter sub-domain in this curve.","since":"5.0","parameters":[{"name":"domain","summary":"The sub-domain of the polyline. The integer part of the domain parameters indicate the index of the segment."}],"returns":"The polyline as defined by the sub-domain, or None on failure."}]},{"namespace":"Rhino.Geometry","name":"PolylineCurve","dataType":"class","summary":"Represents the geometry of a set of linked line segments.  \\nThis is fundamentally a class that derives from and internally contains a .","baseclass":"Rhino.Geometry.Curve","constructors":[{"signature":"PolylineCurve()","summary":"Initializes a new empty polyline curve.","since":"5.0"},{"signature":"PolylineCurve(IEnumerable<Point3d> points)","summary":"Initializes a new polyline curve by copying its content from another set of points.","since":"5.0","parameters":[{"name":"points","summary":"A list, an array or any enumerable set of points to copy from. This includes a Polylineobject."}]},{"signature":"PolylineCurve(PolylineCurve other)","summary":"Initializes a new polyline curve by copying its content from another polyline curve.","since":"5.0","parameters":[{"name":"other","summary":"Another polyline curve."}]}],"properties":[{"signature":"int PointCount","summary":"Gets the number of points in this polyline.","since":"5.0","property":["get"]}],"methods":[{"signature":"double Parameter(int index)","summary":"Gets a parameter at a specified index in the polyline curve.","since":"6.0","parameters":[{"name":"index","summary":"An index."}],"returns":"A parameter."},{"signature":"Point3d Point(int index)","summary":"Gets a point at a specified index in the polyline curve.","since":"5.0","parameters":[{"name":"index","summary":"An index."}],"returns":"A point."},{"signature":"void SetParameter(int index, double parameter)","summary":"Sets a parameter at a specified index in the polyline curve.","since":"6.0","parameters":[{"name":"index","summary":"An index."},{"name":"parameter","summary":"A parameter to set."}]},{"signature":"void SetPoint(int index, Point3d point)","summary":"Sets a point at a specified index in the polyline curve.","since":"5.0","parameters":[{"name":"index","summary":"An index."},{"name":"point","summary":"A point location to set."}]},{"signature":"Polyline ToPolyline()","summary":"Returns the underlying Polyline, or points.","since":"6.0","returns":"The Polyline if successful, None of the curve has no points."}]},{"namespace":"Rhino.Geometry","name":"QuadRemeshParameters","dataType":"class","summary":"Parameters for QuadRemesh method","properties":[{"signature":"bool AdaptiveQuadCount","summary":"Respect the original Target Quad Count value as much as possible. True returns more quads than TargetQuadCount depending on amount of high-curvature areas.","since":"7.0","property":["get","set"]},{"signature":"double AdaptiveSize","summary":"Larger values results in for quad sizes that adjust to match input curvature. Smaller values results in more uniform quad sizes at the risk of less feature preservation. Range [0 - 100]","since":"7.0","property":["get","set"]},{"signature":"bool DetectHardEdges","summary":"When enabled the hard edges in models will be retained.","since":"7.0","property":["get","set"]},{"signature":"int GuideCurveInfluence","summary":"0 = Approximate 1 = Interpolate Edge Ring 2 = Interpolate Edge Loop This value is ignored if Guide Curves are not supplied","since":"7.0","property":["get","set"]},{"signature":"int PreserveMeshArrayEdgesMode","summary":"0=off, 1=On(Smart), 2=On(Strict) : Mesh array\'s created from Breps will have their brep face edge boundaries retained. Smart - Small or insignificant input faces are ignored. Strict - All input faces are factored in re-meshed result.","since":"7.0","property":["get","set"]},{"signature":"QuadRemeshSymmetryAxis SymmetryAxis","summary":"Symmetry axis to use for symmetric re-meshing","since":"7.0","property":["get","set"]},{"signature":"int TargetQuadCount","summary":"The number of quads to try to achieve in the final re-meshed object","since":"7.0","property":["get","set"]}]},{"namespace":"Rhino.Geometry","name":"QuadRemeshSymmetryAxis","dataType":"enum","summary":"Symmetrical meshing axis","since":"7.0","values":[{"signature":"None = 0","summary":"No symmetric re-meshing"},{"signature":"X = 1","summary":"Symmetry across X axis"},{"signature":"Y = 2","summary":"Symmetry across Y axis"},{"signature":"Z = 4","summary":"Symmetry across Z axis"}]},{"namespace":"Rhino.Geometry","name":"Quaternion","dataType":"struct","summary":"Represents the four coefficient values in a quaternion.  \\nThe first value a is the real part, while the rest multiplies i, j and k, that are imaginary.  \\nquaternion = a + bi + cj + dk","constructors":[{"signature":"Quaternion(double a, double b, double c, double d)","summary":"Initializes a new quaternion with the provided coefficients.","since":"5.0","parameters":[{"name":"a","summary":"A number. This is the real part."},{"name":"b","summary":"Another number. This is the first coefficient of the imaginary part."},{"name":"c","summary":"Another number. This is the second coefficient of the imaginary part."},{"name":"d","summary":"Another number. This is the third coefficient of the imaginary part."}]}],"properties":[{"signature":"static Quaternion I","summary":"Returns the (0,1,0,0) quaternion.","since":"5.0","property":["get"]},{"signature":"static Quaternion Identity","summary":"Returns the (1,0,0,0) quaternion.","since":"5.0","property":["get"]},{"signature":"static Quaternion J","summary":"Returns the (0,0,1,0) quaternion.","since":"5.0","property":["get"]},{"signature":"static Quaternion K","summary":"Returns the (0,0,0,1) quaternion.","since":"5.0","property":["get"]},{"signature":"static Quaternion Zero","summary":"Returns the default quaternion, where all coefficients are 0.","since":"5.0","property":["get"]},{"signature":"double A","summary":"Gets or sets the real part of the quaternion.","since":"5.0","property":["get","set"]},{"signature":"double B","summary":"Gets or sets the first imaginary coefficient of the quaternion.","since":"5.0","property":["get","set"]},{"signature":"double C","summary":"Gets or sets the second imaginary coefficient of the quaternion.","since":"5.0","property":["get","set"]},{"signature":"Quaternion Conjugate","summary":"Gets a new quaternion that is the conjugate of this quaternion.  \\nThis is (a,-b,-c,-d)","since":"5.0","property":["get"]},{"signature":"double D","summary":"Gets or sets the third imaginary coefficient of the quaternion.","since":"5.0","property":["get","set"]},{"signature":"Quaternion Inverse","summary":"Computes a new inverted quaternion,  \\n(a/L2, -b/L2, -c/L2, -d/L2),  \\nwhere L2 = length squared = (a*a + b*b + c*c + d*d). This is the multiplicative inverse, i.e., (a,b,c,d)*(a/L2, -b/L2, -c/L2, -d/L2) = (1,0,0,0). If this is the zero quaternion, then the zero quaternion is returned.","since":"5.0","property":["get"]},{"signature":"bool IsScalar","summary":"True if b, c, and d are all zero.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Determines if the four coefficients are valid numbers within RhinoCommon.  \\nSee .","since":"5.0","property":["get"]},{"signature":"bool IsVector","summary":"True if a = 0 and at least one of b, c, or d is not zero.","since":"5.0","property":["get"]},{"signature":"bool IsZero","summary":"True if a, b, c, and d are all zero.","since":"5.0","property":["get"]},{"signature":"double Length","summary":"Returns the length or norm of the quaternion.","since":"5.0","property":["get"]},{"signature":"double LengthSquared","summary":"Gets the result of (a^2 + b^2 + c^2 + d^2).","since":"5.0","property":["get"]},{"signature":"double Scalar","summary":"The real (scalar) part of the quaternion  \\nThis is .","since":"5.0","property":["get"]},{"signature":"Vector3d Vector","summary":"The imaginary part of the quaternion  \\n(B,C,D)","since":"5.0","property":["get"]}],"methods":[{"signature":"static Quaternion CrossProduct(Quaternion p, Quaternion q)","summary":"Computes the vector cross product of p and q = (0,x,y,z),  \\nwhere (x,y,z) = CrossProduct(p.Vector,q.Vector).  \\nThis is not the same as the quaternion product p*q.","since":"5.0","parameters":[{"name":"p","summary":"A quaternion."},{"name":"q","summary":"Another quaternion."}],"returns":"A new quaternion."},{"signature":"static double Distance(Quaternion p, Quaternion q)","summary":"Returns the distance or norm of the difference between two quaternions.","since":"5.0","parameters":[{"name":"p","summary":"A quaternion."},{"name":"q","summary":"Another quaternion."}],"returns":"(p - q).Length()"},{"signature":"static Quaternion Product(Quaternion p, Quaternion q)","summary":"The quaternion product of p and q.  This is the same value as p*q.","since":"5.0","parameters":[{"name":"p","summary":"The first transform."},{"name":"q","summary":"The second transform."}],"returns":"A transform value."},{"signature":"static Quaternion Rotation(double angle, Vector3d axisOfRotation)","summary":"Returns the unit quaternion cos(angle/2), sin(angle/2)*x, sin(angle/2)*y, sin(angle/2)*z where (x,y,z) is the unit vector parallel to axis.  This is the unit quaternion that represents the rotation of angle about axis.","since":"5.0","parameters":[{"name":"angle","summary":"An angle in radians."},{"name":"axisOfRotation","summary":"The axis of rotation."}],"returns":"A new quaternion."},{"signature":"static Quaternion Rotation(Plane plane0, Plane plane1)","summary":"Returns the unit quaternion that represents the rotation that maps plane0.xaxis to plane1.xaxis, plane0.yaxis to plane1.yaxis, and plane0.zaxis to plane1.zaxis.","since":"5.0","parameters":[{"name":"plane0","summary":"The first plane."},{"name":"plane1","summary":"The second plane."}],"returns":"A quaternion value."},{"signature":"double DistanceTo(Quaternion q)","summary":"Computes the distance or norm of the difference between this and another quaternion.","since":"5.0","parameters":[{"name":"q","summary":"Another quaternion."}],"returns":"(this - q).Length."},{"signature":"bool EpsilonEquals(Quaternion other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(object obj)","summary":"Determines whether an object is a quaternion and has the same value of this quaternion.","parameters":[{"name":"obj","summary":"Another object to compare."}],"returns":"True if obj is a quaternion and has exactly equal coefficients; otherwise false."},{"signature":"bool Equals(Quaternion other)","summary":"Determines whether this quaternion has the same value of another quaternion.","since":"5.0","parameters":[{"name":"other","summary":"Another quaternion to compare."}],"returns":"True if the quaternions have exactly equal coefficients; otherwise false."},{"signature":"int GetHashCode()","summary":"Gets a non-unique but repeatable hashing code for this quaternion.","returns":"A signed number."},{"signature":"bool GetRotation(out double angle, out Vector3d axis)","summary":"Returns the rotation defined by the quaternion.","since":"5.0","parameters":[{"name":"angle","summary":"An angle in radians."},{"name":"axis","summary":"unit axis of rotation of 0 if (b,c,d) is the zero vector."}],"returns":"True if the operation succeeded; otherwise, false."},{"signature":"bool GetRotation(out Plane plane)","summary":"Returns the frame created by applying the quaternion\'s rotation to the canonical world frame (1,0,0),(0,1,0),(0,0,1).","since":"5.0","parameters":[{"name":"plane","summary":"A plane. This out value will be assigned during this call."}],"returns":"True if the operation succeeded; otherwise, false."},{"signature":"bool Invert()","summary":"Modifies this quaternion to become  \\n(a/L2, -b/L2, -c/L2, -d/L2),  \\nwhere L2 = length squared = (a*a + b*b + c*c + d*d).  \\nThis is the multiplicative inverse, i.e., (a,b,c,d)*(a/L2, -b/L2, -c/L2, -d/L2) = (1,0,0,0).","since":"5.0","returns":"True if successful. False if the quaternion is zero and cannot be inverted."},{"signature":"Transform MatrixForm()","summary":"Returns 4x4 real valued matrix form of the quaternion a  b  c  d -b  a -d  c -c  d  a -b -d -c  b  a which has the same arithmetic properties as the quaternion.","since":"5.0","returns":"A transform value."},{"signature":"Vector3d Rotate(Vector3d v)","summary":"Rotates a 3d vector. This operation is also called conjugation, because the result is the same as (q.Conjugate()*(0,x,y,x)*q/q.LengthSquared).Vector.","since":"5.0","parameters":[{"name":"v","summary":"The vector to be rotated."}],"returns":"R*v, where R is the rotation defined by the unit quaternion. This is mathematically the same as the values (Inverse(q)*(0,x,y,z)*q).Vector and (q.Conjugate()*(0,x,y,x)*q/q.LengthSquared).Vector."},{"signature":"void Set(double a, double b, double c, double d)","summary":"Sets all coefficients of the quaternion.","since":"5.0"},{"signature":"void SetRotation(double angle, Vector3d axisOfRotation)","summary":"Sets the quaternion to cos(angle/2), sin(angle/2)*x, sin(angle/2)*y, sin(angle/2)*z where (x,y,z) is the unit vector parallel to axis.  This is the unit quaternion that represents the rotation of angle about axis.","since":"5.0","parameters":[{"name":"angle","summary":"in radians."},{"name":"axisOfRotation","summary":"The direction of the axis of rotation."}]},{"signature":"void SetRotation(Plane plane0, Plane plane1)","summary":"Sets the quaternion to the unit quaternion which rotates plane0.xaxis to plane1.xaxis, plane0.yaxis to plane1.yaxis, and plane0.zaxis to plane1.zaxis.","since":"5.0","parameters":[{"name":"plane0","summary":"The \\"from\\" rotation plane. Origin point is ignored."},{"name":"plane1","summary":"The \\"to\\" rotation plane. Origin point is ignored."}]},{"signature":"bool Unitize()","summary":"Scales the quaternion\'s coordinates so that a*a + b*b + c*c + d*d = 1.","since":"5.0","returns":"True if successful.  False if the quaternion is zero and cannot be unitized."}]},{"namespace":"Rhino.Geometry","name":"RadialDimension","dataType":"class","summary":"Represents a dimension of a circular entity that can be measured with radius or diameter.","baseclass":"Rhino.Geometry.Dimension","constructors":[{"signature":"RadialDimension()","since":"6.0"}],"properties":[{"signature":"AnnotationType AnnotationType","since":"6.0","property":["get","set"]},{"signature":"Point2d CenterPoint","since":"6.0","property":["get","set"]},{"signature":"Point2d DimlinePoint","since":"6.0","property":["get","set"]},{"signature":"bool IsDiameterDimension","summary":"Gets a value indicating whether the value refers to the diameter, rather than the radius.","since":"5.0","property":["get"]},{"signature":"Point2d KneePoint","since":"6.0","property":["get"]},{"signature":"Guid LeaderArrowBlockId","since":"6.0","property":["get","set"]},{"signature":"double LeaderArrowSize","since":"6.0","property":["get","set"]},{"signature":"ArrowType LeaderArrowType","since":"6.0","property":["get","set"]},{"signature":"LeaderCurveStyle LeaderCurveStyle","since":"6.0","property":["get","set"]},{"signature":"TextHorizontalAlignment LeaderTextHorizontalAlignment","summary":"Gets or sets the horizontal alignment of the radial dimension\'s text","since":"6.9","property":["get","set"]},{"signature":"Point2d RadiusPoint","since":"6.0","property":["get","set"]},{"signature":"LeaderContentAngleStyle TextAngleType","since":"6.0","property":["get","set"]},{"signature":"TextLocation TextLocation","since":"6.0","property":["get","set"]},{"signature":"TextOrientation TextOrientation","since":"6.0","property":["get","set"]}],"methods":[{"signature":"static RadialDimension Create(DimensionStyle dimStyle, AnnotationType dimtype, Plane plane, Point3d centerpoint, Point3d radiuspoint, Point3d dimlinepoint)","summary":"Initialize Dimension parameters","since":"6.0","parameters":[{"name":"dimStyle","summary":"Dimension\'s dimstyle"},{"name":"dimtype","summary":"AnnotationType.Diameter or AnnotationType.Radius"},{"name":"plane","summary":"Dimension\'s plane"},{"name":"centerpoint","summary":"Dimension\'s center point"},{"name":"radiuspoint","summary":"Point on dimension radius"},{"name":"dimlinepoint","summary":"Point on dimension line"}]},{"signature":"bool AdjustFromPoints(Plane plane, Point3d centerpoint, Point3d radiuspoint, Point3d dimlinepoint, double rotationInPlane)","summary":"Update Dimension geometry from point locations","since":"6.0","parameters":[{"name":"plane","summary":"Dimension\'s plane"},{"name":"centerpoint","summary":"Dimension\'s center point"},{"name":"radiuspoint","summary":"Point on dimension radius"},{"name":"dimlinepoint","summary":"Point on dimension line"},{"name":"rotationInPlane","summary":"Rotation around plane origin"}]},{"signature":"bool Get3dPoints(out Point3d centerpoint, out Point3d radiuspoint, out Point3d dimlinepoint, out Point3d kneepoint)","summary":"Get locations of dimension\'s 3d points","since":"6.0","parameters":[{"name":"centerpoint","summary":"Dimension\'s center point"},{"name":"radiuspoint","summary":"Point on dimension\'s radius"},{"name":"dimlinepoint","summary":"Point on dimension line"},{"name":"kneepoint","summary":"Point where dimension line jogs"}]},{"signature":"bool GetDisplayLines(DimensionStyle style, double scale, out IEnumerable<Line> lines)"},{"signature":"string GetDistanceDisplayText(UnitSystem unitsystem, DimensionStyle style)","since":"6.0"},{"signature":"bool GetTextRectangle(out Point3d[] corners)","since":"6.0"}]},{"namespace":"Rhino.Geometry","name":"RailType","dataType":"enum","summary":"Rail types used for creating filleted Brep edges","since":"6.0","values":[{"signature":"DistanceFromEdge = 0","summary":"The distance from the edge curves determines the intersection."},{"signature":"RollingBall = 1","summary":"The radius of a rolling ball determines the intersection."},{"signature":"DistanceBetweenRails = 2","summary":"The distance between the edge rails determines the intersection."}]},{"namespace":"Rhino.Geometry","name":"Ray3d","dataType":"struct","summary":"Represents an immutable ray in three dimensions, using position and direction.","constructors":[{"signature":"Ray3d(Point3d position, Vector3d direction)","summary":"Initializes a new Ray3d instance.","since":"5.0","parameters":[{"name":"position","summary":"The position."},{"name":"direction","summary":"The direction."}]}],"properties":[{"signature":"Vector3d Direction","summary":"Gets the direction vector of this ray.","since":"5.0","property":["get"]},{"signature":"Point3d Position","summary":"Gets the starting position of this ray.","since":"5.0","property":["get"]}],"methods":[{"signature":"bool EpsilonEquals(Ray3d other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(object obj)","summary":"Determines whether the specified System.Object is a Ray3d and has the same values as the present ray.","parameters":[{"name":"obj","summary":"The specified object."}],"returns":"True if obj is a Ray3d and has the same position and direction as this; otherwise false."},{"signature":"bool Equals(Ray3d ray)","summary":"Determines whether the specified Ray3d has the same value as the present ray.","since":"5.0","parameters":[{"name":"ray","summary":"The specified ray."}],"returns":"True if ray has the same position and direction as this; otherwise false."},{"signature":"int GetHashCode()","summary":"Computes a hashing number that represents the current ray.","returns":"A signed integer that represents both position and direction, but is not unique."},{"signature":"Point3d PointAt(double t)","summary":"Evaluates a point along the ray.","since":"5.0","parameters":[{"name":"t","summary":"The t parameter."}],"returns":"A point at (Direction*t + Position)."}]},{"namespace":"Rhino.Geometry","name":"Rectangle3d","dataType":"struct","summary":"Represents the values of a plane and two intervals that form an oriented rectangle in three dimensions.","constructors":[{"signature":"Rectangle3d(Plane plane, double width, double height)","summary":"Initializes a new rectangle from width and height.","since":"5.0","parameters":[{"name":"plane","summary":"Base plane for Rectangle."},{"name":"width","summary":"Width (as measured along the base plane x-axis) of rectangle."},{"name":"height","summary":"Height (as measured along the base plane y-axis) of rectangle."}]},{"signature":"Rectangle3d(Plane plane, Interval width, Interval height)","summary":"Initializes a new rectangle from dimensions.","since":"5.0","parameters":[{"name":"plane","summary":"Base plane for Rectangle."},{"name":"width","summary":"Dimension of rectangle along the base plane x-axis."},{"name":"height","summary":"Dimension of rectangle along the base plane y-axis."}]},{"signature":"Rectangle3d(Plane plane, Point3d cornerA, Point3d cornerB)","summary":"Initializes a new rectangle from a base plane and two corner points.","since":"5.0","parameters":[{"name":"plane","summary":"Base plane for Rectangle."},{"name":"cornerA","summary":"First corner of Rectangle (will be projected onto plane)."},{"name":"cornerB","summary":"Second corner of Rectangle (will be projected onto plane)."}]}],"properties":[{"signature":"static Rectangle3d Unset","summary":"Gets a rectangle with Unset components.","since":"5.0","property":["get"]},{"signature":"double Area","summary":"Gets the unsigned Area of the rectangle.","since":"5.0","property":["get"]},{"signature":"BoundingBox BoundingBox","summary":"Gets the world aligned bounding box for this rectangle.","since":"5.0","property":["get"]},{"signature":"Point3d Center","summary":"Gets the point in the center of the rectangle.","since":"5.0","property":["get"]},{"signature":"double Circumference","summary":"Gets the circumference of the rectangle.","since":"5.0","property":["get"]},{"signature":"double Height","summary":"Gets the signed height of the rectangle. If the Y dimension is decreasing, the height will be negative.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Gets a value indicating whether or not this is a valid rectangle. A rectangle is considered to be valid when the base plane and both dimensions are valid.","since":"5.0","property":["get"]},{"signature":"Plane Plane","summary":"Gets or sets the base plane of the rectangle.","since":"5.0","property":["get","set"]},{"signature":"double Width","summary":"Gets the signed width of the rectangle. If the X dimension is decreasing, the width will be negative.","since":"5.0","property":["get"]},{"signature":"Interval X","summary":"Gets or sets the dimensions of the rectangle along the base plane X-Axis (i.e. the width).","since":"5.0","property":["get","set"]},{"signature":"Interval Y","summary":"Gets or sets the dimensions of the rectangle along the base plane Y-Axis (i.e. the height).","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static Rectangle3d CreateFromPolyline(IEnumerable<Point3d> polyline)","summary":"Attempts to create a rectangle from a polyline. This method only works well for polylines that already closely resemble rectangles. If the polyline contains more than four vertices, the least significant ones will be ignored. If the polylines is non-orthogonal, the discrepancies will be averaged away. This method should not be used as a Rectangle fitter.","since":"5.0","parameters":[{"name":"polyline","summary":"Polyline to parse."}],"returns":"A rectangle that is shaped similarly to the polyline or Rectangle3d.Unset if the polyline does not represent a rectangle."},{"signature":"static Rectangle3d CreateFromPolyline(IEnumerable<Point3d> polyline, out double deviation, out double angleDeviation)","summary":"Attempts to create a rectangle from a polyline. This method only works well for polylines that already closely resemble rectangles. If the polyline contains more than four vertices, the least significant ones will be ignored. If the polylines is non-orthogonal, the discrepancies will be averaged away. This method should not be used as a Rectangle fitter.","since":"5.0","parameters":[{"name":"polyline","summary":"Polyline to parse."},{"name":"deviation","summary":"On success, the deviation will contain the largest deviation between the polyline and the rectangle."},{"name":"angleDeviation","summary":"On success, the angleDeviation will contain the largest deviation (in radians) between the polyline edges and the rectangle edges."}],"returns":"A rectangle that is shaped similarly to the polyline or Rectangle3d.Unset if the polyline does not represent a rectangle."},{"signature":"Point3d ClosestPoint(Point3d point)","summary":"Gets the point on the rectangle that is closest to a test-point.","since":"5.0","parameters":[{"name":"point","summary":"Point to project."}],"returns":"The point on or in the rectangle closest to the test point or Point3d.Unset on failure."},{"signature":"Point3d ClosestPoint(Point3d point, bool includeInterior)","summary":"Gets the point on the rectangle that is closest to a test-point.","since":"5.0","parameters":[{"name":"point","summary":"Point to project."},{"name":"includeInterior","summary":"If false, the point is projected onto the boundary edge only, otherwise the interior of the rectangle is also taken into consideration."}],"returns":"The point on the rectangle closest to the test point or Point3d.Unset on failure."},{"signature":"PointContainment Contains(double x, double y)","summary":"Determines if two plane parameters are included in this rectangle.","since":"5.0","parameters":[{"name":"x","summary":"Parameter along base plane X direction."},{"name":"y","summary":"Parameter along base plane Y direction."}],"returns":"Parameter Rectangle relationship."},{"signature":"PointContainment Contains(Point3d pt)","summary":"Determines if a point is included in this rectangle.","since":"5.0","parameters":[{"name":"pt","summary":"Point to test. The point will be projected onto the Rectangle plane before inclusion is determined."}],"returns":"Point Rectangle relationship."},{"signature":"Point3d Corner(int index)","summary":"Gets the corner at the given index.","since":"5.0","parameters":[{"name":"index","summary":"Index of corner, valid values are:  \\n0 = lower left (min-x, min-y)  \\n1 = lower right (max-x, min-y)  \\n2 = upper right (max-x, max-y)  \\n3 = upper left (min-x, max-y)"}],"returns":"The point at the given corner index."},{"signature":"bool EpsilonEquals(Rectangle3d other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"void MakeIncreasing()","summary":"Ensures the X and Y dimensions are increasing or singleton intervals.","since":"5.0"},{"signature":"Point3d PointAt(double t)","summary":"Gets a point along the rectangle boundary.","since":"5.0","parameters":[{"name":"t","summary":"Parameter along rectangle boundary. Valid values range from 0.0 to 4.0, where each integer domain represents a single boundary edge."}],"returns":"The point at the given boundary parameter."},{"signature":"Point3d PointAt(double x, double y)","summary":"Gets a point in Rectangle space.","since":"5.0","parameters":[{"name":"x","summary":"Normalized parameter along Rectangle width."},{"name":"y","summary":"Normalized parameter along Rectangle height."}],"returns":"The point at the given x,y parameter."},{"signature":"void RecenterPlane(int index)","summary":"Re-centers the base plane on one of the corners.","since":"5.0","parameters":[{"name":"index","summary":"Index of corner, valid values are:  \\n0 = lower left (min-x, min-y)  \\n1 = lower right (max-x, min-y)  \\n2 = upper right (max-x, max-y)  \\n3 = upper left (min-x, max-y)"}]},{"signature":"void RecenterPlane(Point3d origin)","summary":"Re-centers the base plane on a new origin.","since":"5.0","parameters":[{"name":"origin","summary":"New origin for plane."}]},{"signature":"NurbsCurve ToNurbsCurve()","summary":"Constructs a nurbs curve representation of this rectangle.","since":"5.0","returns":"A nurbs curve with the same shape as this rectangle."},{"signature":"Polyline ToPolyline()","summary":"Constructs a polyline from this rectangle.","since":"5.0","returns":"A polyline with the same shape as this rectangle."},{"signature":"bool Transform(Transform xform)","summary":"Transforms this rectangle. Note that rectangles cannot be skewed or tapered.","since":"5.0","parameters":[{"name":"xform","summary":"Transformation to apply."}]}]},{"namespace":"Rhino.Geometry","name":"ReduceMeshParameters","dataType":"class","summary":"Parameters for Reduce method","constructors":[{"signature":"ReduceMeshParameters()","summary":"Constructs a polygon reduction parameter object with default values. Users of this class should not rely on default values to stay constant across service releases.","since":"6.0"}],"properties":[{"signature":"int Accuracy","summary":"Integer from 1 to 10 telling how accurate reduction algorithm to use. Greater number gives more accurate results","since":"6.0","property":["get","set"]},{"signature":"bool AllowDistortion","summary":"If True mesh appearance is not changed even if the target polygon count is not reached","since":"6.0","property":["get","set"]},{"signature":"CancellationToken CancelToken","since":"6.0","property":["get","set"]},{"signature":"int DesiredPolygonCount","summary":"Desired or target number of faces","since":"6.0","property":["get","set"]},{"signature":"string Error","since":"6.0","property":["get","set"]},{"signature":"int[] FaceTags","since":"6.0","property":["get","set"]},{"signature":"ComponentIndex[] LockedComponents","summary":"List of topological mesh vertices and mesh vertices that will not be moved or deleted in reduction process. Each mesh vertex will lock the corresponding topological mesh vertex. In other words it is not possible to have a locked and non-locked mesh vertex at the same location.","since":"6.0","property":["get","set"]},{"signature":"bool NormalizeMeshSize","summary":"If True mesh is fitted to an axis aligned unit cube until reduction is complete","since":"6.0","property":["get","set"]},{"signature":"IProgress<double> ProgressReporter","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Geometry","name":"RegionContainment","dataType":"enum","summary":"Defines enumerated values for closed curve/closed curve relationships.","since":"5.0","values":[{"signature":"Disjoint = 0","summary":"There is no common area between the two regions."},{"signature":"MutualIntersection = 1","summary":"The two curves intersect. There is therefore no full containment relationship either way."},{"signature":"AInsideB = 2","summary":"Region bounded by curveA (first curve) is inside of curveB (second curve)."},{"signature":"BInsideA = 3","summary":"Region bounded by curveB (second curve) is inside of curveA (first curve)."}]},{"namespace":"Rhino.Geometry","name":"RevSurface","dataType":"class","summary":"Represents a surface of revolution.  \\nRevolutions can be incomplete (they can form arcs).","baseclass":"Rhino.Geometry.Surface","properties":[{"signature":"Interval Angle","summary":"Gets the start and end angles of revolution in radians. The interval angle must be increasing and satisfy RhinoMath.ZeroTolerance < Angle.Length<= 2.0 * System.Math.PI.","since":"6.0","property":["get"]},{"signature":"Line Axis","summary":"Gets the axis of revolution.","since":"6.0","property":["get"]},{"signature":"Curve Curve","summary":"Gets the revolute curve.","since":"6.0","property":["get"]}],"methods":[{"signature":"static RevSurface Create(Curve revoluteCurve, Line axisOfRevolution)","summary":"Constructs a new surface of revolution from a generatrix curve and an axis.","since":"5.0","parameters":[{"name":"revoluteCurve","summary":"A generatrix."},{"name":"axisOfRevolution","summary":"An axis."}],"returns":"A new surface of revolution, or None if any of the inputs is invalid or on error."},{"signature":"static RevSurface Create(Curve revoluteCurve, Line axisOfRevolution, double startAngleRadians, double endAngleRadians)","summary":"Constructs a new surface of revolution from a generatrix curve and an axis.  \\nThis overload accepts a slice start and end angles.","since":"5.0","parameters":[{"name":"revoluteCurve","summary":"A generatrix."},{"name":"axisOfRevolution","summary":"An axis."},{"name":"startAngleRadians","summary":"An angle in radians for the start."},{"name":"endAngleRadians","summary":"An angle in radians for the end."}],"returns":"A new surface of revolution, or None if any of the inputs is invalid or on error."},{"signature":"static RevSurface Create(Line revoluteLine, Line axisOfRevolution)","summary":"Constructs a new surface of revolution from a generatrix line and an axis.  \\nIf the operation succeeds, results can be (truncated) cones, cylinders and circular hyperboloids.","since":"5.0","parameters":[{"name":"revoluteLine","summary":"A generatrix."},{"name":"axisOfRevolution","summary":"An axis."}],"returns":"A new surface of revolution, or None if any of the inputs is invalid or on error."},{"signature":"static RevSurface Create(Line revoluteLine, Line axisOfRevolution, double startAngleRadians, double endAngleRadians)","summary":"Constructs a new surface of revolution from a generatrix line and an axis.  \\nThis overload accepts a slice start and end angles.  \\nResults can be (truncated) cones, cylinders and circular hyperboloids, or can fail.","since":"5.0","parameters":[{"name":"revoluteLine","summary":"A generatrix."},{"name":"axisOfRevolution","summary":"An axis."},{"name":"startAngleRadians","summary":"An angle in radians for the start."},{"name":"endAngleRadians","summary":"An angle in radians for the end."}],"returns":"A new surface of revolution, or None if any of the inputs is invalid or on error."},{"signature":"static RevSurface Create(Polyline revolutePolyline, Line axisOfRevolution)","summary":"Constructs a new surface of revolution from a generatrix polyline and an axis.","since":"5.0","parameters":[{"name":"revolutePolyline","summary":"A generatrix."},{"name":"axisOfRevolution","summary":"An axis."}],"returns":"A new surface of revolution, or None if any of the inputs is invalid or on error."},{"signature":"static RevSurface Create(Polyline revolutePolyline, Line axisOfRevolution, double startAngleRadians, double endAngleRadians)","summary":"Constructs a new surface of revolution from a generatrix polyline and an axis.  \\nThis overload accepts a slice start and end angles.","since":"5.0","parameters":[{"name":"revolutePolyline","summary":"A generatrix."},{"name":"axisOfRevolution","summary":"An axis."},{"name":"startAngleRadians","summary":"An angle in radians for the start."},{"name":"endAngleRadians","summary":"An angle in radians for the end."}],"returns":"A new surface of revolution, or None if any of the inputs is invalid or on error."},{"signature":"static RevSurface CreateFromCone(Cone cone)","summary":"Constructs a new surface of revolution from the values of a cone.","since":"5.0","parameters":[{"name":"cone","summary":"A cone."}],"returns":"A new surface of revolution, or None if any of the inputs is invalid or on error."},{"signature":"static RevSurface CreateFromCylinder(Cylinder cylinder)","summary":"Constructs a new surface of revolution from the values of a cylinder.","since":"5.0","parameters":[{"name":"cylinder","summary":"A cylinder."}],"returns":"A new surface of revolution, or None if any of the inputs is invalid or on error."},{"signature":"static RevSurface CreateFromSphere(Sphere sphere)","summary":"Constructs a new surface of revolution from the values of a sphere.","since":"5.0","parameters":[{"name":"sphere","summary":"A sphere."}],"returns":"A new surface of revolution, or None if any of the inputs is invalid or on error."},{"signature":"static RevSurface CreateFromTorus(Torus torus)","summary":"Constructs a new surface of revolution from the values of a torus.","since":"5.0","parameters":[{"name":"torus","summary":"A torus."}],"returns":"A new surface of revolution, or None if any of the inputs is invalid or on error."}]},{"namespace":"Rhino.Geometry","name":"RTree","dataType":"class","summary":"Represents a spatial search structure based on implementations of the R-tree algorithm by Toni Gutman.","remarks":"The opennurbs rtree code is a modified version of the free and unrestricted R-tree implementation obtained from http://www.superliminal.com/sources/sources.htm .","interfaces":["IDisposable"],"constructors":[{"signature":"RTree()","summary":"Initializes a new, empty instance of the tree.","since":"5.0"}],"properties":[{"signature":"int Count","summary":"Gets the number of items in this tree.","since":"5.0","property":["get"]}],"methods":[{"signature":"static RTree CreateFromPointArray(IEnumerable<Point3d> points)","summary":"Constructs a new tree with an element for each point cloud point.","since":"6.0","parameters":[{"name":"points","summary":"Points."}],"returns":"A new tree, or None on error."},{"signature":"static RTree CreateMeshFaceTree(Mesh mesh)","summary":"Constructs a new tree with an element for each face in the mesh. The element id is set to the index of the face.","since":"5.0","parameters":[{"name":"mesh","summary":"A mesh."}],"returns":"A new tree, or None on error."},{"signature":"static RTree CreatePointCloudTree(PointCloud cloud)","summary":"Constructs a new tree with an element for each point cloud point.","since":"5.0","parameters":[{"name":"cloud","summary":"A point cloud."}],"returns":"A new tree, or None on error."},{"signature":"static IEnumerable<int[]> Point3dClosestPoints(IEnumerable<Point3d> hayPoints, IEnumerable<Point3d> needlePts, double limitDistance)","summary":"Finds the point in a list of 3D points that is closest to a test point.","since":"6.0","parameters":[{"name":"hayPoints","summary":"A series of points."},{"name":"needlePts","summary":"Points to search for."},{"name":"limitDistance","summary":"The maximum allowed distance."}],"returns":"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{"signature":"static IEnumerable<int[]> Point3dKNeighbors(IEnumerable<Point3d> hayPoints, IEnumerable<Point3d> needlePts, int amount)","summary":"Finds a certain amount of points in a list of 3D points that are the k-closest to a test point.","since":"6.0","parameters":[{"name":"hayPoints","summary":"A series of points."},{"name":"needlePts","summary":"Points to search for."},{"name":"amount","summary":"The required amount of closest neighbors to find."}],"returns":"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{"signature":"static IEnumerable<int[]> PointCloudClosestPoints(PointCloud pointcloud, IEnumerable<Point3d> needlePts, double limitDistance)","summary":"Finds the point in a list of 3D points that is closest to a test point.","since":"6.0","parameters":[{"name":"pointcloud","summary":"A point cloud to be searched."},{"name":"needlePts","summary":"Points to search for."},{"name":"limitDistance","summary":"The maximum allowed distance."}],"returns":"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{"signature":"static IEnumerable<int[]> PointCloudKNeighbors(PointCloud pointcloud, IEnumerable<Point3d> needlePts, int amount)","summary":"Finds a certain amount of points in a list of 3D points that are the k-closest to a test point.","since":"6.0","parameters":[{"name":"pointcloud","summary":"A point cloud to be searched."},{"name":"needlePts","summary":"Points to search for."},{"name":"amount","summary":"The required amount of closest neighbors to find."}],"returns":"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{"signature":"static bool SearchOverlaps(RTree treeA, RTree treeB, double tolerance, EventHandler<RTreeEventArgs> callback)","summary":"Searches two R-trees for all pairs elements whose bounding boxes overlap.","since":"5.0","parameters":[{"name":"treeA","summary":"A first tree."},{"name":"treeB","summary":"A second tree."},{"name":"tolerance","summary":"If the distance between a pair of bounding boxes is less than tolerance, then callback is called."},{"name":"callback","summary":"A callback event handler."}],"returns":"True if entire tree was searched.  It is possible no results were found."},{"signature":"void Clear()","summary":"Removes all elements.","since":"5.0"},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"bool Insert(BoundingBox box, int elementId)","summary":"Inserts an element into the tree.","since":"5.0","parameters":[{"name":"box","summary":"A bounding box."},{"name":"elementId","summary":"A number."}],"returns":"True if element was successfully inserted."},{"signature":"bool Insert(BoundingBox box, IntPtr elementId)","summary":"Inserts an element into the tree.","since":"5.0","parameters":[{"name":"box","summary":"A bounding box."},{"name":"elementId","summary":"A pointer."}],"returns":"True if element was successfully inserted."},{"signature":"bool Insert(Point2d point, int elementId)","summary":"Inserts an element into the tree.","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"elementId","summary":"A number."}],"returns":"True if element was successfully inserted."},{"signature":"bool Insert(Point2d point, IntPtr elementId)","summary":"Inserts an element into the tree.","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"elementId","summary":"A pointer."}],"returns":"True if element was successfully inserted."},{"signature":"bool Insert(Point3d point, int elementId)","summary":"Inserts an element into the tree.","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"elementId","summary":"A number."}],"returns":"True if element was successfully inserted."},{"signature":"bool Insert(Point3d point, IntPtr elementId)","summary":"Inserts an element into the tree.","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"elementId","summary":"A pointer."}],"returns":"True if element was successfully inserted."},{"signature":"bool Remove(BoundingBox box, int elementId)","summary":"Removes an element from the tree.","since":"5.0","parameters":[{"name":"box","summary":"A bounding box."},{"name":"elementId","summary":"A number."}],"returns":"True if element was successfully removed."},{"signature":"bool Remove(BoundingBox box, IntPtr elementId)","summary":"Removes an element from the tree.","since":"5.0","parameters":[{"name":"box","summary":"A bounding box."},{"name":"elementId","summary":"A pointer."}],"returns":"True if element was successfully removed."},{"signature":"bool Remove(Point2d point, int elementId)","summary":"Removes an element from the tree.","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"elementId","summary":"A number."}],"returns":"True if element was successfully removed."},{"signature":"bool Remove(Point3d point, int elementId)","summary":"Removes an element from the tree.","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"elementId","summary":"A number."}],"returns":"True if element was successfully removed."},{"signature":"bool Remove(Point3d point, IntPtr elementId)","summary":"Removes an element from the tree.","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"elementId","summary":"A pointer."}],"returns":"True if element was successfully removed."},{"signature":"bool Search(BoundingBox box, EventHandler<RTreeEventArgs> callback)","summary":"Searches for items in a bounding box.  \\nThe bounding box can be singular and contain exactly one single point.","since":"5.0","parameters":[{"name":"box","summary":"A bounding box."},{"name":"callback","summary":"An event handler to be raised when items are found."}],"returns":"True if entire tree was searched. It is possible no results were found."},{"signature":"bool Search(BoundingBox box, EventHandler<RTreeEventArgs> callback, object tag)","summary":"Searches for items in a bounding box.  \\nThe bounding box can be singular and contain exactly one single point.","since":"5.0","parameters":[{"name":"box","summary":"A bounding box."},{"name":"callback","summary":"An event handler to be raised when items are found."},{"name":"tag","summary":"State to be passed inside the RTreeEventArgsTag property."}],"returns":"True if entire tree was searched. It is possible no results were found."},{"signature":"bool Search(Sphere sphere, EventHandler<RTreeEventArgs> callback)","summary":"Searches for items in a sphere.","since":"5.0","parameters":[{"name":"sphere","summary":"bounds used for searching."},{"name":"callback","summary":"An event handler to be raised when items are found."}],"returns":"True if entire tree was searched. It is possible no results were found."},{"signature":"bool Search(Sphere sphere, EventHandler<RTreeEventArgs> callback, object tag)","summary":"Searches for items in a sphere.","since":"5.0","parameters":[{"name":"sphere","summary":"bounds used for searching."},{"name":"callback","summary":"An event handler to be raised when items are found."},{"name":"tag","summary":"State to be passed inside the RTreeEventArgsTag property."}],"returns":"True if entire tree was searched. It is possible no results were found."}]},{"namespace":"Rhino.Geometry","name":"RTreeEventArgs","dataType":"class","summary":"Represents event data that is passed when an item that meets certain criteria is found and the passed RTree event is raised.","baseclass":"EventArgs","properties":[{"signature":"bool Cancel","summary":"Gets or sets a value that determines if the search should be conducted farther.","since":"5.0","property":["get","set"]},{"signature":"int Id","summary":"Gets the identifier of the found item.","since":"5.0","property":["get"]},{"signature":"int IdB","summary":"If search is using two r-trees, IdB is element b in the search.","since":"5.0","property":["get"]},{"signature":"IntPtr IdBPtr","summary":"If search is using two r-trees, IdB is the element b pointer in the search.","since":"5.0","property":["get"]},{"signature":"IntPtr IdPtr","summary":"Gets the identifier pointer of the found item.","since":"5.0","property":["get"]},{"signature":"BoundingBox SearchBoundingBox","summary":"Bounding box bounds used during a search. You may modify the box in a search callback to help reduce the bounds to search.","since":"5.0","property":["get","set"]},{"signature":"Sphere SearchSphere","summary":"Sphere bounds used during a search. You can modify the sphere in a search callback to help reduce the bounds to search.","since":"5.0","property":["get","set"]},{"signature":"object Tag","summary":"Gets or sets an arbitrary object that can be attached to this event args. This object will \\"stick\\" through a single search and can represent user-defined state.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.Geometry","name":"ShutLiningCurveInfo","dataType":"class","summary":"Contains shutlining curve information. This is used in Mesh.WithShutLining.","constructors":[{"signature":"ShutLiningCurveInfo(Curve curve, double radius, int profile, bool pull, bool isBump, IEnumerable<Interval> curveIntervals, bool enabled)","summary":"Creates a new instance of the ShutLining curve information class.","since":"6.0","parameters":[{"name":"curve","summary":"The profile curve."},{"name":"radius","summary":"The profile radius."},{"name":"profile","summary":"The profile type."},{"name":"pull","summary":"True if the curve should be pulled."},{"name":"isBump","summary":"True if profile constitutes a bump. See Rhino\'s Help for more information."},{"name":"curveIntervals","summary":"The parts of the curve to use as profiles."},{"name":"enabled","summary":"If true, this curve is active."}]}],"properties":[{"signature":"Curve Curve","summary":"The profile curve.","since":"6.0","property":["get"]},{"signature":"ReadOnlyCollection<Interval> CurveIntervals","summary":"The parts of the curve to use as profiles.","since":"6.0","property":["get"]},{"signature":"bool Enabled","summary":"If true, this curve is active.","since":"6.0","property":["get"]},{"signature":"bool IsBump","summary":"True if profile constitutes a bump. See Rhino\'s Help for more information.","since":"6.0","property":["get"]},{"signature":"int Profile","summary":">The profile type.","since":"6.0","property":["get"]},{"signature":"bool Pull","summary":"True if the curve should be pulled.","since":"6.0","property":["get"]},{"signature":"double Radius","summary":"The profile radius.","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Geometry","name":"Silhouette","dataType":"class","summary":"Information about silhouette curves that are generated from geometry (surfaces, brep faces, meshes)","properties":[{"signature":"Curve Curve","summary":"3D curve representing the shape of the silhouette.","since":"6.0","property":["get","set"]},{"signature":"ComponentIndex GeometryComponentIndex","summary":"Gets the component index corresponding with this silhouette curve. This field is only set when the entire silhouette curve is part of some geometry component.","since":"6.0","property":["get","set"]},{"signature":"SilhouetteType SilhouetteType","summary":"Gets the type of this silhouette curve.","since":"6.0","property":["get","set"]}],"methods":[{"signature":"static Silhouette[] Compute(GeometryBase geometry, SilhouetteType silhouetteType, Point3d perspectiveCameraLocation, double tolerance, double angleToleranceRadians)","summary":"Compute silhouettes of a shape for a perspective projection.","since":"6.0","parameters":[{"name":"geometry","summary":"Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion."},{"name":"silhouetteType","summary":"Types of silhouette to compute."},{"name":"perspectiveCameraLocation","summary":"Location of perspective camera."},{"name":"tolerance","summary":"Tolerance to use for determining projecting relationships. Surfaces and curves that are closer than tolerance, may be treated as projecting. When in doubt use RhinoDoc.ModelAbsoluteTolerance."},{"name":"angleToleranceRadians","summary":"Angular tolerance to use for determining projecting relationships. A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. When in doubt use RhinoDoc.ModelAngleToleranceRadians."}],"returns":"Array of silhouette curves."},{"signature":"static Silhouette[] Compute(GeometryBase geometry, SilhouetteType silhouetteType, Point3d perspectiveCameraLocation, double tolerance, double angleToleranceRadians, IEnumerable<Plane> clippingPlanes, CancellationToken cancelToken)","summary":"Compute silhouettes of a shape for a perspective projection.","since":"6.0","parameters":[{"name":"geometry","summary":"Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion."},{"name":"silhouetteType","summary":"Types of silhouette to compute."},{"name":"perspectiveCameraLocation","summary":"Location of perspective camera."},{"name":"tolerance","summary":"Tolerance to use for determining projecting relationships. Surfaces and curves that are closer than tolerance, may be treated as projecting. When in doubt use RhinoDoc.ModelAbsoluteTolerance."},{"name":"angleToleranceRadians","summary":"Angular tolerance to use for determining projecting relationships. A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. When in doubt use RhinoDoc.ModelAngleToleranceRadians."},{"name":"clippingPlanes","summary":"Optional collection of clipping planes."},{"name":"cancelToken","summary":"Computation cancellation token."}],"returns":"Array of silhouette curves."},{"signature":"static Silhouette[] Compute(GeometryBase geometry, SilhouetteType silhouetteType, Vector3d parallelCameraDirection, double tolerance, double angleToleranceRadians)","summary":"Compute silhouettes of a shape for a parallel projection.","since":"6.0","parameters":[{"name":"geometry","summary":"Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion."},{"name":"silhouetteType","summary":"Types of silhouette to compute."},{"name":"parallelCameraDirection","summary":"Direction of parallel camera."},{"name":"tolerance","summary":"Tolerance to use for determining projecting relationships. Surfaces and curves that are closer than tolerance, may be treated as projecting. When in doubt use RhinoDoc.ModelAbsoluteTolerance."},{"name":"angleToleranceRadians","summary":"Angular tolerance to use for determining projecting relationships. A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. When in doubt use RhinoDoc.ModelAngleToleranceRadians."}],"returns":"Array of silhouette curves."},{"signature":"static Silhouette[] Compute(GeometryBase geometry, SilhouetteType silhouetteType, Vector3d parallelCameraDirection, double tolerance, double angleToleranceRadians, IEnumerable<Plane> clippingPlanes, CancellationToken cancelToken)","summary":"Compute silhouettes of a shape for a parallel projection.","since":"6.0","parameters":[{"name":"geometry","summary":"Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion."},{"name":"silhouetteType","summary":"Types of silhouette to compute."},{"name":"parallelCameraDirection","summary":"Direction of parallel camera."},{"name":"tolerance","summary":"Tolerance to use for determining projecting relationships. Surfaces and curves that are closer than tolerance, may be treated as projecting. When in doubt use RhinoDoc.ModelAbsoluteTolerance."},{"name":"angleToleranceRadians","summary":"Angular tolerance to use for determining projecting relationships. A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. When in doubt use RhinoDoc.ModelAngleToleranceRadians."},{"name":"clippingPlanes","summary":"Optional collection of clipping planes."},{"name":"cancelToken","summary":"Computation cancellation token."}],"returns":"Array of silhouette curves."},{"signature":"static Silhouette[] Compute(GeometryBase geometry, SilhouetteType silhouetteType, ViewportInfo viewport, double tolerance, double angleToleranceRadians)","summary":"Compute silhouettes of a shape for a specified projection.","since":"6.0","parameters":[{"name":"geometry","summary":"Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion."},{"name":"silhouetteType","summary":"Types of silhouette to compute."},{"name":"viewport","summary":"Projection."},{"name":"tolerance","summary":"Tolerance to use for determining projecting relationships. Surfaces and curves that are closer than tolerance, may be treated as projecting. When in doubt use RhinoDoc.ModelAbsoluteTolerance."},{"name":"angleToleranceRadians","summary":"Angular tolerance to use for determining projecting relationships. A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. When in doubt use RhinoDoc.ModelAngleToleranceRadians."}],"returns":"Array of silhouette curves."},{"signature":"static Silhouette[] Compute(GeometryBase geometry, SilhouetteType silhouetteType, ViewportInfo viewport, double tolerance, double angleToleranceRadians, IEnumerable<Plane> clippingPlanes, CancellationToken cancelToken)","summary":"Compute silhouettes of a shape for a specified projection.","since":"6.0","parameters":[{"name":"geometry","summary":"Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion."},{"name":"silhouetteType","summary":"Types of silhouette to compute."},{"name":"viewport","summary":"Projection."},{"name":"tolerance","summary":"Tolerance to use for determining projecting relationships. Surfaces and curves that are closer than tolerance, may be treated as projecting. When in doubt use RhinoDoc.ModelAbsoluteTolerance."},{"name":"angleToleranceRadians","summary":"Angular tolerance to use for determining projecting relationships. A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. When in doubt use RhinoDoc.ModelAngleToleranceRadians."},{"name":"clippingPlanes","summary":"Optional collection of clipping planes."},{"name":"cancelToken","summary":"Computation cancellation token."}],"returns":"Array of silhouette curves."},{"signature":"static Silhouette[] ComputeDraftCurve(GeometryBase geometry, double draftAngle, Vector3d pullDirection, double tolerance, double angleToleranceRadians)","summary":"Computes draft curve silhouettes of a shape.","since":"7.0","parameters":[{"name":"geometry","summary":"Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion."},{"name":"draftAngle","summary":"The draft angle in radians. Draft angle can be a positive or negative value."},{"name":"pullDirection","summary":"3d direction for the mold to be pulled in, directed away from the object."},{"name":"tolerance","summary":"Tolerance to use for determining projecting relationships. Surfaces and curves that are closer than tolerance, may be treated as projecting. When in doubt use RhinoDoc.ModelAbsoluteTolerance."},{"name":"angleToleranceRadians","summary":"Angular tolerance to use for determining projecting relationships. A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. When in doubt use RhinoDoc.ModelAngleToleranceRadians."}],"returns":"Array of silhouette curves."},{"signature":"static Silhouette[] ComputeDraftCurve(GeometryBase geometry, double draftAngle, Vector3d pullDirection, double tolerance, double angleToleranceRadians, CancellationToken cancelToken)","summary":"Computes draft curve silhouettes of a shape.","since":"7.0","parameters":[{"name":"geometry","summary":"Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion."},{"name":"draftAngle","summary":"The draft angle in radians. Draft angle can be a positive or negative value."},{"name":"pullDirection","summary":"3d direction for the mold to be pulled in, directed away from the object."},{"name":"tolerance","summary":"Tolerance to use for determining projecting relationships. Surfaces and curves that are closer than tolerance, may be treated as projecting. When in doubt use RhinoDoc.ModelAbsoluteTolerance."},{"name":"angleToleranceRadians","summary":"Angular tolerance to use for determining projecting relationships. A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. When in doubt use RhinoDoc.ModelAngleToleranceRadians."},{"name":"cancelToken","summary":"Computation cancellation token."}],"returns":"Array of silhouette curves."}]},{"namespace":"Rhino.Geometry","name":"SilhouetteType","dataType":"enum","summary":"Enumerates the different types of silhouettes and their origins.","since":"6.0","values":[{"signature":"None = UnsafeNativeMethods.SilEventType.None","summary":"None."},{"signature":"Projecting = UnsafeNativeMethods.SilEventType.Projecting","summary":"Boundary of a region that projects to a curve. The view direction is tangent to the surface over the entire region."},{"signature":"TangentProjects = UnsafeNativeMethods.SilEventType.TanProjects","summary":"Tangent silhouette curve where the curve projects to a point (within tolerance). In this case side_fill[i] is meaningless so it\'s left unset."},{"signature":"Tangent = UnsafeNativeMethods.SilEventType.Tangent","summary":"Tangent silhouette curve. The view direction is tangent to the surface along the curve."},{"signature":"Crease = UnsafeNativeMethods.SilEventType.Crease","summary":"Crease on geometry that is a silhouette."},{"signature":"Boundary = UnsafeNativeMethods.SilEventType.Boundary","summary":"Boundary of geometry is always a silhouette."},{"signature":"NonSilhouetteCrease = UnsafeNativeMethods.SilEventType.NonSilCrease","summary":"A non-silhouette crease, meaning both sides are visible."},{"signature":"NonSilhouetteTangent = UnsafeNativeMethods.SilEventType.NonSilTangent","summary":"A non-silhouette tangent edge that is not a crease."},{"signature":"NonSilhouetteSeam = UnsafeNativeMethods.SilEventType.NonSilSeam","summary":"A non-silhouette surface seam."},{"signature":"SectionCut = UnsafeNativeMethods.SilEventType.SectionCut","summary":"Intersection with a clipping plane."},{"signature":"MiscellaneousFeature = UnsafeNativeMethods.SilEventType.MiscFeature","summary":"Miscellaneous curve feature."},{"signature":"DraftCurve = UnsafeNativeMethods.SilEventType.DraftCurve","summary":"Draft curve is a curve of constant draft angle."}]},{"namespace":"Rhino.Geometry","name":"SmoothingCoordinateSystem","dataType":"enum","summary":"The direction of the smoothing used by Curve, Surface, and Mesh Smooth.","since":"6.0","values":[{"signature":"World = 0","summary":"World coordinates"},{"signature":"CPlane = 1","summary":"Construction plane coordinates"},{"signature":"Object = 2","summary":"Object u, v, and n coordinates"}]},{"namespace":"Rhino.Geometry","name":"SpaceMorph","dataType":"class","summary":"Represents a spacial, Euclidean morph.","properties":[{"signature":"bool PreserveStructure","summary":"True if the morph should be done in a way that preserves the structure of the geometry. In particular, for NURBS objects, True means that only the control points are moved. The PreserveStructure value does not affect the way meshes and points are morphed. The default is false.","since":"5.0","property":["get","set"]},{"signature":"bool QuickPreview","summary":"True if the morph should be done as quickly as possible because the result is being used for some type of dynamic preview. If QuickPreview is true, the tolerance may be ignored. The QuickPreview value does not affect the way meshes and points are morphed. The default is false.","since":"5.0","property":["get","set"]},{"signature":"double Tolerance","summary":"The desired accuracy of the morph. This value is primarily used for deforming surfaces and breps. The default is 0.0 and any value <= 0.0 is ignored by morphing functions. The Tolerance value does not affect the way meshes and points are morphed.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static bool IsMorphable(GeometryBase geometry)","summary":"True if the geometry can be morphed by calling SpaceMorph.Morph(geometry)","since":"5.0"},{"signature":"bool Morph(GeometryBase geometry)","summary":"Apply the space morph to geometry.","since":"5.0","parameters":[{"name":"geometry","summary":"Geometry to morph."}],"returns":"True on success, False on failure."},{"signature":"bool Morph(ref Plane plane)","summary":"Apply the space morph to a plane.","since":"6.0","parameters":[{"name":"plane","summary":"Plane to morph."}],"returns":"True on success, False on failure."},{"signature":"Point3d MorphPoint(Point3d point)","summary":"Morphs an Euclidean point.  \\nThis method is abstract.","since":"5.0","parameters":[{"name":"point","summary":"A point that will be morphed by this function."}],"returns":"Resulting morphed point."}]},{"namespace":"Rhino.Geometry","name":"Sphere","dataType":"struct","summary":"Represents the plane and radius values of a sphere.","constructors":[{"signature":"Sphere(Plane equatorialPlane, double radius)","summary":"Initializes a new sphere given the plane of the equator circle and radius.","since":"5.0","parameters":[{"name":"equatorialPlane","summary":"A plane that will be intersecting the sphere at the same distance from both poles (parameterization singularities)."},{"name":"radius","summary":"A radius value."}]},{"signature":"Sphere(Point3d center, double radius)","summary":"Initializes a new sphere given center point and radius.","since":"5.0","parameters":[{"name":"center","summary":"A center point."},{"name":"radius","summary":"A radius value."}]}],"properties":[{"signature":"static Sphere Unset","summary":"Gets a sphere with invalid members.","since":"5.0","property":["get"]},{"signature":"BoundingBox BoundingBox","summary":"Gets the world aligned bounding box for this Sphere. If the Sphere is Invalid, an empty box is returned.","since":"5.0","property":["get"]},{"signature":"Point3d Center","summary":"Gets or sets the center point of the sphere.","since":"5.0","property":["get","set"]},{"signature":"double Diameter","summary":"Gets or sets the diameter for this sphere.","since":"5.0","property":["get","set"]},{"signature":"Plane EquatorialPlane","summary":"Gets or sets the Equatorial plane for this sphere.","since":"6.0","property":["get","set"]},{"signature":"Plane EquitorialPlane","summary":"Gets or sets the Equatorial plane for this sphere.","since":"5.0","property":["get","set"]},{"signature":"bool IsValid","summary":"Gets a value that indicates whether the sphere is valid.","since":"5.0","property":["get"]},{"signature":"Point3d NorthPole","summary":"Gets the point at the North Pole of the sphere.  \\nThis is the parameterization singularity that can be obtained, at V value +Math.Pi/2.","since":"5.0","property":["get"]},{"signature":"double Radius","summary":"Gets or sets the Radius for this sphere.","since":"5.0","property":["get","set"]},{"signature":"Point3d SouthPole","summary":"Gets the point at the South Pole of the sphere.  \\nThis is the parameterization singularity that can be obtained, at V value -Math.Pi/2.","since":"5.0","property":["get"]}],"methods":[{"signature":"static Sphere FitSphereToPoints(IEnumerable<Point3d> points)","summary":"Attempts to fit a sphere to a collection of points.","since":"5.0","parameters":[{"name":"points","summary":"Points to fit. The collection must contain at least two points."}],"returns":"The Sphere that best approximates the points or Sphere.Unset on failure."},{"signature":"bool ClosestParameter(Point3d testPoint, out double longitudeRadians, out double latitudeRadians)","summary":"Finds the angle parameters on this sphere that are closest to a test point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to project onto the sphere."},{"name":"longitudeRadians","summary":"The longitudinal angle (in radians; 0.0 to 2pi) where the sphere approaches testPoint best."},{"name":"latitudeRadians","summary":"The latitudinal angle (in radians; -0.5pi to +0.5pi) where the sphere approaches testPoint best."}],"returns":"True on success, False on failure. This function will fail if the point it coincident with the sphere center."},{"signature":"Point3d ClosestPoint(Point3d testPoint)","summary":"Returns point on sphere that is closest to given point.","since":"5.0","parameters":[{"name":"testPoint","summary":"Point to project onto Sphere."}],"returns":"Point on sphere surface closest to testPoint."},{"signature":"bool EpsilonEquals(Sphere other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"Circle LatitudeDegrees(double degrees)","summary":"Computes the parallel at a specific latitude angle.  \\nThe angle is specified in degrees.","since":"5.0","parameters":[{"name":"degrees","summary":"An angle in degrees for the meridian."}],"returns":"A circle."},{"signature":"Circle LatitudeRadians(double radians)","summary":"Computes the parallel at a specific latitude angle.  \\nThe angle is specified in radians.","since":"5.0","parameters":[{"name":"radians","summary":"An angle in radians for the parallel."}],"returns":"A circle."},{"signature":"Circle LongitudeDegrees(double degrees)","summary":"Computes the meridian at a specific longitude angle.  \\nThe angle is specified in degrees.","since":"5.0","parameters":[{"name":"degrees","summary":"An angle in degrees."}],"returns":"A circle."},{"signature":"Circle LongitudeRadians(double radians)","summary":"Computes the meridian at a specific longitude angle.  \\nThe angle is specified in radians.","since":"5.0","parameters":[{"name":"radians","summary":"An angle in radians."}],"returns":"A circle."},{"signature":"Vector3d NormalAt(double longitudeRadians, double latitudeRadians)","summary":"Computes the normal at a specific angular location on the sphere.","since":"5.0","parameters":[{"name":"longitudeRadians","summary":"A number within the interval [0, 2pi]."},{"name":"latitudeRadians","summary":"A number within the interval [-pi/2, pi/2]."}],"returns":"A vector."},{"signature":"Point3d PointAt(double longitudeRadians, double latitudeRadians)","summary":"Evaluates the sphere at specific longitude and latitude angles.","since":"5.0","parameters":[{"name":"longitudeRadians","summary":"A number within the interval [0, 2pi]."},{"name":"latitudeRadians","summary":"A number within the interval [-pi/2,pi/2]."}],"returns":"A point value."},{"signature":"bool Rotate(double sinAngle, double cosAngle, Vector3d axisOfRotation)","summary":"Rotates this sphere about the center point.","since":"5.0","parameters":[{"name":"sinAngle","summary":"sin(angle)"},{"name":"cosAngle","summary":"cos(angle)"},{"name":"axisOfRotation","summary":"The direction of the axis of rotation."}],"returns":"True on success; False on failure."},{"signature":"bool Rotate(double sinAngle, double cosAngle, Vector3d axisOfRotation, Point3d centerOfRotation)","summary":"Rotates this sphere about a point and an axis.","since":"5.0","parameters":[{"name":"sinAngle","summary":"sin(angle)"},{"name":"cosAngle","summary":"cod(angle)"},{"name":"axisOfRotation","summary":"Axis of rotation."},{"name":"centerOfRotation","summary":"Center of rotation."}],"returns":"True on success; False on failure."},{"signature":"bool Rotate(double angleRadians, Vector3d axisOfRotation)","summary":"Rotates the sphere about the center point.","since":"5.0","parameters":[{"name":"angleRadians","summary":"Angle of rotation (in radians)"},{"name":"axisOfRotation","summary":"Rotation axis."}],"returns":"True on success; False on failure."},{"signature":"bool Rotate(double angleRadians, Vector3d axisOfRotation, Point3d centerOfRotation)","summary":"Rotates this sphere about a point and an axis.","since":"5.0","parameters":[{"name":"angleRadians","summary":"Rotation angle (in Radians)"},{"name":"axisOfRotation","summary":"Axis of rotation."},{"name":"centerOfRotation","summary":"Center of rotation."}],"returns":"True on success; False on failure."},{"signature":"Brep ToBrep()","summary":"Converts this sphere is it Brep representation","since":"5.0"},{"signature":"NurbsSurface ToNurbsSurface()","summary":"Converts this sphere to its NurbsSurface representation. This is synonymous with calling NurbsSurface.CreateFromSphere().","since":"5.0","returns":"A nurbs surface representation of this sphere or null."},{"signature":"RevSurface ToRevSurface()","summary":"Converts this Sphere to a RevSurface representation. This is synonymous with calling RevSurface.CreateFromSphere().","since":"5.0","returns":"A surface of revolution representation of this sphere or null."},{"signature":"bool Transform(Transform xform)","summary":"Transforms this sphere. Note that non-similarity preserving transformations cannot be applied to a sphere as that would result in an ellipsoid.","since":"5.0","parameters":[{"name":"xform","summary":"Transformation matrix to apply."}],"returns":"True on success, False on failure."},{"signature":"bool Translate(Vector3d delta)","summary":"Moves this sphere along a motion vector.","since":"5.0","parameters":[{"name":"delta","summary":"Motion vector."}],"returns":"True on success; False on failure."}]},{"namespace":"Rhino.Geometry","name":"SubD","dataType":"class","summary":"Subdivision surface","baseclass":"Rhino.Geometry.GeometryBase","constructors":[{"signature":"SubD()","summary":"Create a new instance of SubD geometry","since":"7.0"}],"properties":[{"signature":"SubDEdgeList Edges","summary":"All edges in this SubD","since":"7.0","property":["get"]},{"signature":"SubDFaceList Faces","summary":"All faces in this SubD","since":"7.0","property":["get"]},{"signature":"bool IsSolid","summary":"Test SubD to see if the active level is a solid. A \\"solid\\" is a closed oriented manifold, or a closed oriented manifold.","since":"7.0","property":["get"]},{"signature":"SubDVertexList Vertices","summary":"All vertices in this SubD","since":"7.0","property":["get"]}],"methods":[{"signature":"static SubD CreateFromLoft(IEnumerable<NurbsCurve> curves, bool closed, bool addCorners, bool addCreases, int divisions)","summary":"Creates a SubD lofted through shape curves.","since":"7.0","parameters":[{"name":"curves","summary":"An enumeration of SubD-friendly NURBS curves to loft through."},{"name":"closed","summary":"Creates a SubD that is closed in the lofting direction. Must have three or more shape curves."},{"name":"addCorners","summary":"With open curves, adds creased vertices to the SubD at both ends of the first and last curves."},{"name":"addCreases","summary":"With kinked curves, adds creased edges to the SubD along the kinks."},{"name":"divisions","summary":"The segment number between adjacent input curves."}],"returns":"A new SubD if successful, or None on failure."},{"signature":"static SubD CreateFromMesh(Mesh mesh)","summary":"Create a new SubD from a mesh.","since":"7.0","parameters":[{"name":"mesh","summary":"The input mesh."}],"returns":"A new SubD if successful, or None on failure."},{"signature":"static SubD CreateFromMesh(Mesh mesh, SubDCreationOptions options)","summary":"Create a new SubD from a mesh.","since":"7.0","parameters":[{"name":"mesh","summary":"The input mesh."},{"name":"options","summary":"The SubD creation options."}],"returns":"A new SubD if successful, or None on failure."},{"signature":"static SubD CreateFromSweep(NurbsCurve rail1, IEnumerable<NurbsCurve> shapes, bool closed, bool addCorners, bool roadlikeFrame, Vector3d roadlikeNormal)","summary":"Fits a SubD through a series of profile curves that define the SubD cross-sections and one curve that defines a SubD edge.","since":"7.0","parameters":[{"name":"rail1","summary":"A SubD-friendly NURBS curve to sweep along."},{"name":"shapes","summary":"An enumeration of SubD-friendly NURBS curves to sweep through."},{"name":"closed","summary":"Creates a SubD that is closed in the rail curve direction."},{"name":"addCorners","summary":"With open curves, adds creased vertices to the SubD at both ends of the first and last curves."},{"name":"roadlikeFrame","summary":"Determines how sweep frame rotations are calculated. If False (Freeform), frame are propogated based on a refrence direction taken from the rail curve curvature direction. If True (Roadlike), frame rotations are calculated based on a vector supplied in \\"roadlikeNormal\\" and the world coordinate system."},{"name":"roadlikeNormal","summary":"If roadlikeFrame = true, provide 3D vector used to calculate the frame rotations for sweep shapes. If roadlikeFrame = false, then pass  Vector3d.Unset."}],"returns":"A new SubD if successful, or None on failure."},{"signature":"static SubD CreateFromSweep(NurbsCurve rail1, NurbsCurve rail2, IEnumerable<NurbsCurve> shapes, bool closed, bool addCorners)","summary":"Fits a SubD through a series of profile curves that define the SubD cross-sections and two curves that defines SubD edges.","since":"7.0","parameters":[{"name":"rail1","summary":"The first SubD-friendly NURBS curve to sweep along."},{"name":"rail2","summary":"The second SubD-friendly NURBS curve to sweep along."},{"name":"shapes","summary":"An enumeration of SubD-friendly NURBS curves to sweep through."},{"name":"closed","summary":"Creates a SubD that is closed in the rail curve direction."},{"name":"addCorners","summary":"With open curves, adds creased vertices to the SubD at both ends of the first and last curves."}],"returns":"A new SubD if successful, or None on failure."},{"signature":"void ClearEvaluationCache()","summary":"Clear cached information that depends on the location of vertex control points","since":"7.0"},{"signature":"SubD Offset(double distance, bool solidify)","summary":"Makes a new SubD with vertices offset at distance in the direction of the control net vertex normals. Optionally, based on the value of solidify, adds the input SubD and a ribbon of faces along any naked edges.","since":"7.0","parameters":[{"name":"distance","summary":"The distance to offset."},{"name":"solidify","summary":"True if the output SubD should be turned into a closed SubD."}],"returns":"A new SubD if successful, or None on failure."},{"signature":"bool Subdivide(int count)","summary":"Apply the Catmull-Clark subdivision algorithm and save the results in this SubD","since":"7.0","parameters":[{"name":"count","summary":"Number of times to subdivide (must be greater than 0)"}],"returns":"True on success"},{"signature":"Brep ToBrep()","summary":"Create a Brep based on this SubD geometry.","since":"7.0","returns":"A new Brep if successful, or None on failure."},{"signature":"uint UpdateAllTagsAndSectorCoefficients()","summary":"Updates vertex tag, edge tag, and edge coefficient values on the active level. After completing custom editing operations that modify the topology of the SubD control net or changing values of vertex or edge tags, the tag and sector coefficients information on nearby components in the edited areas need to be updated.","since":"7.0","returns":"Number of vertices and edges that were changed during the update."}]},{"namespace":"Rhino.Geometry","name":"SubD.NurbsSurfaceType","dataType":"enum","summary":"ON_SubD::NurbsSurfaceType specifies what type of NURBS surfaces are returned by ON_SubD.GetSurfaceNurbsFragments()","values":[{"signature":"Unset = 0","summary":"Not a valid type. Used to indicate the type has not been set and to encourage developers to explicitly specify a type. When in doubt, specify NurbsSurfaceType::Large."},{"signature":"Large = 1","summary":"Onee NURBS surface will be generated for each SubD quad. N NURBS surfaces will be generated for each SubD N-gon (N = 3, 5 or more). ON_Brepface may cover multiple Near extraordinary vertices, the surfaces may have lots of knots."},{"signature":"Medium = 2","summary":"NURBS surfaces will be as large as possible without the addition of extra knots. Near extraordinary vertices, the surfaces may have lots of knots. This option is prefered when a user wants larger NURBS surfaces but not at the cost of addtional NURBS control points."},{"signature":"Small = 3","summary":"NURBS surfaces will not be merged and will have clamped knots."},{"signature":"Unprocessed = 4","summary":"NURBS surfaces will not be merged and will have unclamped uniform knots. This is useful as a starting point for customized merging and modifying continuity at extraordinary vertices."}]},{"namespace":"Rhino.Geometry","name":"SubDAutomaticMeshToSubDContext","dataType":"enum","summary":"ON_SubD::AutomaticMeshToSubDContext indentifies a context where meshes can automatically be converted to subds.","values":[{"signature":"Unset = 0","summary":"Indicates the context has not been initialized."},{"signature":"Rhino5BoxModeTSpline = 1","summary":"A mesh in a Rhino 5 3dm file that is a representation of a box mode T-spline. By default, these meshes are automatically converted to subds."},{"signature":"FBXMeshWithDivisionLevels = 2","summary":"A mesh in an FBX file that has nonzero values for either preview division levels or render division levels. Some FBX files created by Maya save subdivision objects as meshes with nonzero division level values. By default, FBX division levels are ignored."}]},{"namespace":"Rhino.Geometry","name":"SubDChainType","dataType":"enum","summary":"SubD::ChainType specifies what edge and vertex tag tests are used when creating edge chains.","values":[{"signature":"Unset = 0","summary":"Unset."},{"signature":"MixedTag = 1","summary":"All types of edges and vertices can be in the chain."},{"signature":"EqualEdgeTag = 2","summary":"Every edge in an edge chain has the same smooth/crease property."},{"signature":"EqualEdgeAndVertexTag = 3","summary":"Every edge in an edge chain has the same smooth/crease edge tag and interior vertices have the corresponding smooth/crease vertex tag."},{"signature":"EqualEdgeTagAndOrdinary = 4","summary":"Every edge in an edge chain has the same smooth/crease property and every edge has the same number of faces. If the edges have 1 face, then interior vertices have valence = 3. If the edges have 2 faces, then interior vertices have valence = 4."},{"signature":"EqualEdgeAndVertexTagAndOrdinary = 5","summary":"Every edge in an edge chain has the same smooth/crease edge tag, every edge has the same number of faces, and interior vertices have the corresponding smooth/crease vertex tag. If the edges have 1 face, then interior vertices have valence = 3. If the edges have 2 faces, then interior vertices have valence = 4."}]},{"namespace":"Rhino.Geometry","name":"SubDComponent","dataType":"class","summary":"A part of SubD geometry. Common base class for vertices, faces, and edges","properties":[{"signature":"uint Id","summary":"Unique id within the parent SubD for this item","since":"7.0","property":["get"]},{"signature":"SubD ParentSubD","summary":"SubD that this component belongs to","since":"7.0","property":["get"]}]},{"namespace":"Rhino.Geometry","name":"SubDCreationOptions","dataType":"class","summary":"Options used for creating a SubD","interfaces":["IDisposable"],"constructors":[{"signature":"SubDCreationOptions()","summary":"Create default options","since":"7.0"}],"properties":[{"signature":"static SubDCreationOptions ConvexCornersAndInteriorCreases","summary":"Look for convex corners at sub-D vertices with 2 edges that have an included angle <= 90 degrees.","since":"7.0","property":["get"]},{"signature":"static SubDCreationOptions InteriorCreases","summary":"Create an interior sub-D crease along all input mesh double edges","since":"7.0","property":["get"]},{"signature":"static SubDCreationOptions Smooth","summary":"No interior creases and no corners.","since":"7.0","property":["get"]},{"signature":"ConcaveCornerOption ConcaveCornerTest","summary":"Get or sets the concave corner test option.","since":"7.0","property":["get","set"]},{"signature":"ConvexCornerOption ConvexCornerTest","summary":"Get or sets the convex corner test option.","since":"7.0","property":["get","set"]},{"signature":"InteriorCreaseOption InteriorCreaseTest","summary":"Get or sets the interior crease test option.","since":"7.0","property":["get","set"]},{"signature":"bool InterpolateMeshVertices","summary":"If false, input mesh vertex locations will be used to set SubD vertex control net locations. If true, input mesh vertex locations will be used to set SubD vertex limit surface locations.","since":"7.0","property":["get","set"]},{"signature":"double MaximumConvexCornerAngleRadians","summary":"If ConvexCornerTest == ConvexCornerOption.AtMeshCorner, then an input mesh boundary vertex becomes a SubD corner when the number of edges that end at the vertex is <= MaximumConvexCornerEdgeCount edges and the corner angle is <= MaximumConvexCornerAngleRadians.","since":"7.0","property":["get","set"]},{"signature":"uint MaximumConvexCornerEdgeCount","summary":"If ConvexCornerTest == ConvexCornerOption.AtMeshCorner, then an input mesh boundary vertex becomes a SubD corner when the number of edges that end at the vertex is <= MaximumConvexCornerEdgeCount edges and the corner angle is <= MaximumConvexCornerAngleRadians.","since":"7.0","property":["get","set"]},{"signature":"double MinimumConcaveCornerAngleRadians","summary":"If ConcaveCornerTest == ConcaveCornerOption.AtMeshCorner, then an input mesh boundary vertex becomes a SubD corner when the number of edges that end at the vertex is >= MinimumConcaveCornerEdgeCount edges and the corner angle is >= MinimumConcaveCornerAngleRadians.","since":"7.0","property":["get","set"]},{"signature":"uint MinimumConcaveCornerEdgeCount","summary":"If ConcaveCornerTest == ConcaveCornerOption.AtMeshCorner, then an input mesh boundary vertex becomes a SubD corner when the number of edges that end at the vertex is >= MinimumConcaveCornerEdgeCount edges and the corner angle is >= MinimumConcaveCornerAngleRadians.","since":"7.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Delete unmanaged pointer for this","since":"7.0"}]},{"namespace":"Rhino.Geometry","name":"SubDCreationOptions.ConcaveCornerOption","dataType":"enum","summary":"Defines how concave corners are treated.","values":[{"signature":"Unset = 0","summary":"The option is not set."},{"signature":"None = 1","summary":"No concave coners. In general, this is the best choice."},{"signature":"AtMeshCorner = 2","summary":"A concave subd corner will appear at input mesh boundary vertices where the corner angle >= MinimumConcaveCornerAngleRadians() and the number of edges the end at the vertex is >= MinimumConcaveCornerEdgeCount()."}]},{"namespace":"Rhino.Geometry","name":"SubDCreationOptions.ConvexCornerOption","dataType":"enum","summary":"Defines how convex corners are treated.","values":[{"signature":"Unset = 0","summary":"The option is not set."},{"signature":"None = 1","summary":"No convex coners."},{"signature":"AtMeshCorner = 2","summary":"A convex subd corner will appear at input mesh boundary vertices where the corner angle <= MaximumConvexCornerAngleRadians() and the number of edges the end at the vertex is <= MaximumConvexCornerEdgeCount()."}]},{"namespace":"Rhino.Geometry","name":"SubDCreationOptions.InteriorCreaseOption","dataType":"enum","summary":"Specifies the test used to determine when an interior mesh edge generates an interior SubD creased edge.","values":[{"signature":"Unset = 0","summary":"The interior crease test is not defined."},{"signature":"None = 1","summary":"No interior creases."},{"signature":"AtMeshDoubleEdge = 2","summary":"An interior mesh double edge will create an interior SubD creased edge. An interior mesh double edge occurs when the sides of two mesh faces have have distinct vertex indices and identical vertex locations."}]},{"namespace":"Rhino.Geometry","name":"SubDCreationOptions.TextureCoordinateOption","dataType":"enum","summary":"Specifies how texture coordinate information is transfered from the mesh to the SubD.","values":[{"signature":"Unset = 0","summary":"The option is not set."},{"signature":"None = 1","summary":"No texture coordianate information is transfered from the mesh."},{"signature":"Automatic = 2","summary":"If the mesh has a mapping, then TextureCoordinatesOption::CopyMapping is used. Otherwise if the mesh has texture coordinates, then TextureCoordinatesOption::CopyCoordinates is used. Otherwise TextureCoordinatesOption::Packed is used."},{"signature":"Packed = 3","summary":"No texture coordianate information is transfered from the mesh. The SubD faces are packed."},{"signature":"CopyMapping = 4","summary":"Texture coordinates mapping information is copied from the mesh. Generally this is the best choice because common mappings, like planar, will appear as most people expect on the SubD."},{"signature":"CopyCoordinates = 5","summary":"If a mesh has custom texture coordinates, the custom texture coordinates are transfered to the SubD. This requires more memory resources, slows subdivision evaluation, often produces unattractive results on n-gons, and distorts the texture when comes from a common mapping technique, like planar. This option may be useful when the mesh contains only triangles and quads and the custom texture coordinates are of high quality."}]},{"namespace":"Rhino.Geometry","name":"SubDEdge","dataType":"class","summary":"Single edge of a SubD","baseclass":"Rhino.Geometry.SubDComponent","properties":[{"signature":"Line ControlNetLine","summary":"Line representing the control net end points","since":"7.0","property":["get"]},{"signature":"int FaceCount","summary":"Number of faces for this edge","since":"7.0","property":["get"]},{"signature":"SubDEdgeTag Tag","summary":"identifies the type of subdivision edge","since":"7.0","property":["get","set"]},{"signature":"SubDVertex VertexFrom","summary":"Start vertex for this edge","since":"7.0","property":["get"]},{"signature":"SubDVertex VertexTo","summary":"End vertex for this edge","since":"7.0","property":["get"]}],"methods":[{"signature":"SubDFace FaceAt(int index)","summary":"Retrieve a SubDFace from this edge","since":"7.0"},{"signature":"NurbsCurve ToNurbsCurve(bool clampEnds)","summary":"Get a cubic, uniform, non-rational, NURBS curve that is on the edge\'s limit curve.","since":"7.0","parameters":[{"name":"clampEnds","summary":"If true, the end knots are clamped. Otherwise the end knots are(-2,-1,0,...., k1, k1+1, k1+2)."}]}]},{"namespace":"Rhino.Geometry","name":"SubDEdgeTag","dataType":"enum","summary":"ON_SubDEdgeTag identifies the type of subdivision edge.  Different tags use different subdivision algorithms to calculate the subdivision point.","values":[{"signature":"Unset = 0","summary":"Not a valid edge tag and the default value for ON_SubDEdge.m_edge_tag. This encourages developers to thoughtfully initialize ON_SubDEdge.m_edge_tag. or use ON_SubD.UpdateAllTagsAndSectorCoefficients() to automatically set the m_edge_tag values at an appropriate time."},{"signature":"Smooth = 1","summary":"At least one the edge\'s vertices must be tagged as ON_SubDVertexTag::Smooth. The edge must have exactly two faces. The edge\'s subdivision point is (A1 + A2 + S(f1) + S(f2))/4, where Ai = ON_SubDEdge.Vertex(i)->ControlNetPoint() and S(fi) = ON_SubDEdge.Face(i)->SubdivisionPoint()."},{"signature":"Crease = 2","summary":"Both of the edge\'s vertices must be tagged as ON_SubDVertexTag::Dart, ON_SubDVertexTag::Crease, or ON_SubDVertexTag::Corner. (The vertex tags can be different.) The edge can have any number of faces. The edge\'s subdivision point is (A1+A2)/2 where Ai = ON_SubDEdge.Vertex(i)->ControlNetPoint()."},{"signature":"SmoothX = 4","summary":"This tag appears only on level 0 edges that have exactly two neighboring faces and both of the edge\'s vertices are tagged as ON_SubDVertexTag::Dart, ON_SubDVertexTag::Crease, or ON_SubDVertexTag::Corner. The level 1 subdivision point for a level 0 edge tagged as ON_SubDEdgeTag::SmoothX is the standard smooth edge subdivision point. When subdivided, the new subdivision vertex will be tagged as ON_SubDVertexTag::Smooth and the subdivided edges will be tagged as ON_SubDEdgeTag::Smooth. The tag ON_SubDEdgeTag::SmoothX can only appear on a level 0 edge. This tag exists because the ON_SubD subdivision algorithm requires any edge with both end vertices tagged as not smooth must be subdivided at its midpoint. Sector iterators treat \\"SmoothX\\" edges as smooth. Both edge m_sector_coefficient[] values must be set so the smooth subdivided edges will be valid."}]},{"namespace":"Rhino.Geometry","name":"SubDFace","dataType":"class","summary":"Single face of a SubD","baseclass":"Rhino.Geometry.SubDComponent","properties":[{"signature":"int EdgeCount","summary":"Number of edges for this face. Note that EdgeCount is always the same as VertexCount. Two properties are provided simply for clarity.","since":"7.0","property":["get"]},{"signature":"Point3d LimitSurfaceCenterPoint","summary":"Get the limit surface point location at the center of the face","since":"7.0","property":["get"]},{"signature":"Color PerFaceColor","summary":"If per-face color is \\"Empty\\", then this face does not have a custom color","since":"7.0","property":["get","set"]},{"signature":"int VertexCount","summary":"Number of vertices for this face. Note that EdgeCount is always the same as VertexCount. Two properties are provided simply for clarity.","since":"7.0","property":["get"]}],"methods":[{"signature":"SubDEdge EdgeAt(int index)","summary":"Get an edge at a given index","since":"7.0"},{"signature":"bool EdgeDirectionMatchesFaceOrientation(int index)","summary":"Check if a given edge in this face has the same direction as the face orientation","since":"7.0"},{"signature":"SubDVertex VertexAt(int index)","summary":"Get a vertex that this face uses by index","since":"7.0"}]},{"namespace":"Rhino.Geometry","name":"SubDFriendlyKnotType","dataType":"enum","summary":"ON_SubD::SubDFriendlyKnotType identifies the types of subd friendly NURBS knot vectors. SubD friendly NURBS curves and surfacaes are always cubic and nonrational. Any time there is a multiple knot, the 2nd derivative is zero at the corresponding parameter. SubD friendly NURBS curves are either periodic or have zero 2nd derivative at the ends.","values":[{"signature":"Unset = 0","summary":"Not a valid type. Used to indicate the type has not been set and to encourage developers to explicitly specify a type."},{"signature":"UnclampedUniform = 1","summary":"NURBS knot vector is an unclamped uniform cubic knot vector. Every knot interval has the same length. Every knot has multiplicity 1."},{"signature":"ClampedUniform = 2","summary":"NURBS knot vector is a clamped uniform cubic knot vector. Every interior knot interval has the same length. End knots have multiplicity 3 and interior knots have multiplicity 1."},{"signature":"ClampedPiecewiseUniform = 4","summary":"NURBS knot vector is a clamped piecewise uniform cubic knot vector. All nonzero knot intervals have the same length. End knots have multiplicity 3 and interior knots have multiplicity 1 or 3. Interior knots with multiplicity 3 correspond to interior SubD creases."},{"signature":"Unfriendly = 127","summary":"NURBS knot vector is not subd friendly."}]},{"namespace":"Rhino.Geometry","name":"SubDFromSurfaceMethods","dataType":"enum","summary":"ON_SubDFromSurfaceParameters::Method are ways to create a SubD from a surface.","values":[{"signature":"Unset = 0","summary":"Used to indicate the method is not set."},{"signature":"SubDFriendlyFit = 1","summary":"The surface is approximated with a SubD friendly NURBS surface and the SubD is created to match the subd friendly nurbs surface. If the input surface is a subd friendly NURBS surface, the subd and surface have the same geometry."},{"signature":"FromNurbsControlNet = 2","summary":"The surface is converted to a NURBS surface and then a subd with one face per NURBS bispan is created by using an appropriate subset of the NURBS surface control net. If the input surface is a subd friendly NURBS surface, the subd and surface have the same geometry."}]},{"namespace":"Rhino.Geometry","name":"SubDPatchStyle","dataType":"enum","summary":"SubD::PatchStyle identifies the style of patch used to fill holes.","values":[{"signature":"Unset = 0","summary":"Not a valid style. This encourages developers to thoughtfully select a patch style and can be used to indicate a UI control is not initialized."},{"signature":"Automatic = 1","summary":"Automatically choose a patch style that will generally create a good looking result. If a hole boundary is not convex, it is triangulated. Otherwise: If a hole has 3 edges, a single triangle face is used. If a hole has 4 edges, a single quad face is used. If a hole has 5 or more edges and an odd number of edges, a triangle fan is used. If a hole has 6 or more edges and an even number of edges, a quad fan is used."},{"signature":"SingleFace = 2","summary":"A single face is used under all conditions."},{"signature":"TriangleFan = 3","summary":"A triangle fan used under all conditions. The center of the fan is the average of the hole boundary vertex control net points."},{"signature":"QuadOrTriangleFan = 4","summary":"If the hole boundary has an even mumber of edges, a quad fan is used. Otherwise a triangle fan is used. The center of the fan is the average of the hole boundary vertex control net points."},{"signature":"Triangulated = 5","summary":"The hole boundary is triangluated. Typically this style is selected when a boundary not convex and the other styles produce faces with overlapping regions."}]},{"namespace":"Rhino.Geometry","name":"SubDVertex","dataType":"class","summary":"Single vertex of a SubD","baseclass":"Rhino.Geometry.SubDComponent","properties":[{"signature":"Point3d ControlNetPoint","summary":"Location of the \\"control net\\" point that this SubDVertex represents","since":"7.0","property":["get","set"]},{"signature":"int EdgeCount","summary":"Number of edges for this vertex","since":"7.0","property":["get"]},{"signature":"IEnumerable<SubDEdge> Edges","summary":"All edges that this vertex is part of","since":"7.0","property":["get"]},{"signature":"int FaceCount","summary":"Number of faces for this vertex","since":"7.0","property":["get"]},{"signature":"SubDVertex Next","summary":"Next vertex in linked list of vertices on this level","since":"7.0","property":["get"]},{"signature":"SubDVertex Previous","summary":"Previous vertex in linked list of vertices on this level","since":"7.0","property":["get"]}],"methods":[{"signature":"SubDEdge EdgeAt(int index)","summary":"Retrieve a SubDEdge from this vertex","since":"7.0"}]},{"namespace":"Rhino.Geometry","name":"SubDVertexFacetType","dataType":"enum","summary":"Summarizes the number of edges in faces in the whole object.","values":[{"signature":"Unset = 0","summary":"Not a valid vertex face type."},{"signature":"Tri = 3","summary":"All faces are triangular."},{"signature":"Quad = 4","summary":"All faces are quads."},{"signature":"Ngon = 5","summary":"Edge count of faces is constant and > 4."},{"signature":"Mixed = 0xFF","summary":"Edge count of faces is not constant."}]},{"namespace":"Rhino.Geometry","name":"SubDVertexTag","dataType":"enum","summary":"ON_SubDVertexTag identifies the type of subdivision vertex.  Different tags use different subdivision algorithms to determine where the subdivision point and limit point are located.  There are toplological constraints that restrict which tags can be assigned.","values":[{"signature":"Unset = 0","summary":"Not a valid vertex tag and the default value for ON_SubDVertex.m_vertex_tag. This encourages developers to thoughtfully initialize ON_SubDVertex.m_vertex_tag or use ON_SubD.UpdateAllTagsAndSectorCoefficients() to automatically set the m_vertex_tag values at an appropriate time."},{"signature":"Smooth = 1","summary":"Must be an interior vertex. All edges attached to a smooth vertex must be tagged as ON_SubDEdgeTag::Smooth and must have 2 faces."},{"signature":"Crease = 2","summary":"Can be an interior or a boundary vertex. Exactly two edges ending at a crease vertex must be tagged as ON_SubDEdgeTag::Crease and may have 1 or 2 faces. All other edges ending at a crease must be tagged as tagON_SubD::EdgeTag::Smooth and have 2 faces. Below P = ON_SubDVertex.ControlNetPoint() and Ai = ON_SubDVertex.Edge(i)->OtherEndVertex()->ControlNetPoint(). A crease vertex subdivision point is (6*P + A1 + A2)/8. A crease vertex limit surface point is (4*P + A1 + A2)/6."},{"signature":"Corner = 3","summary":"Can be an interior, boundary, nonmanifold, or isolated vertex. The location of a corner vertex is fixed. The all subdivision points and the limit point are at the initial vertex location. The edges ending at a corner vertex can be smooth or crease edges. A corner vertex subdivision point is P where P = ON_SubDVertex.ControlNetPoint(). A corner vertex limit surface point is P where P = ON_SubDVertex.ControlNetPoint()."},{"signature":"Dart = 4","summary":"Must be an interior vertex. Every edge attached to a dart vertex must have 2 faces. Exactly one edge attached to a dart vertex must be tagged as ON_SubDEdgeTag::Crease and every other attached edge must be tagged as ON_SubDEdgeTag::smooth."}]},{"namespace":"Rhino.Geometry","name":"SumSurface","dataType":"class","summary":"Represents a sum surface, or an extrusion of a curve along a curved path.","baseclass":"Rhino.Geometry.Surface","methods":[{"signature":"static SumSurface Create(Curve curveA, Curve curveB)","summary":"Constructs a new sum surface by extruding a curve A along a path B.","since":"5.0","parameters":[{"name":"curveA","summary":"The curve used as extrusion profile."},{"name":"curveB","summary":"The curve used as path."}],"returns":"A new sum surface on success; None on failure."}]},{"namespace":"Rhino.Geometry","name":"Surface","dataType":"class","summary":"Represents a base class that is common to most RhinoCommon surface types.  \\nA surface represents an entity that can be all visited by providing two independent parameters, usually called (u, v), or sometimes (s, t).","baseclass":"Rhino.Geometry.GeometryBase","properties":[{"signature":"bool IsSolid","summary":"Gets a values indicating whether a surface is solid.","since":"5.0","property":["get"]}],"methods":[{"signature":"static Surface CreateExtrusion(Curve profile, Vector3d direction)","summary":"Constructs a surface by extruding a curve along a vector.","since":"5.0","parameters":[{"name":"profile","summary":"Profile curve to extrude."},{"name":"direction","summary":"Direction and length of extrusion."}],"returns":"A surface on success or None on failure."},{"signature":"static Surface CreateExtrusionToPoint(Curve profile, Point3d apexPoint)","summary":"Constructs a surface by extruding a curve to a point.","since":"5.0","parameters":[{"name":"profile","summary":"Profile curve to extrude."},{"name":"apexPoint","summary":"Apex point of extrusion."}],"returns":"A Surface on success or None on failure."},{"signature":"static Surface CreatePeriodicSurface(Surface surface, int direction)","summary":"Constructs a periodic surface from a base surface and a direction.","since":"5.0","parameters":[{"name":"surface","summary":"The surface to make periodic."},{"name":"direction","summary":"The direction to make periodic, either 0 = U, or 1 = V."}],"returns":"A Surface on success or None on failure."},{"signature":"static Surface CreatePeriodicSurface(Surface surface, int direction, bool bSmooth)","summary":"Constructs a periodic surface from a base surface and a direction.","since":"6.0","parameters":[{"name":"surface","summary":"The surface to make periodic."},{"name":"direction","summary":"The direction to make periodic, either 0 = U, or 1 = V."},{"name":"bSmooth","summary":"Controls kink removal. If true, smooths any kinks in the surface and moves control points to make a smooth surface. If false, control point locations are not changed or changed minimally (only one point may move) and only the knot vector is altered."}],"returns":"A periodic surface if successful, None on failure."},{"signature":"static Surface[] CreateRollingBallFillet(Surface surfaceA, bool flipA, Surface surfaceB, bool flipB, double radius, double tolerance)","summary":"Constructs a rolling ball fillet between two surfaces.","since":"5.0","parameters":[{"name":"surfaceA","summary":"A first surface."},{"name":"flipA","summary":"A value that indicates whether A should be used in flipped mode."},{"name":"surfaceB","summary":"A second surface."},{"name":"flipB","summary":"A value that indicates whether B should be used in flipped mode."},{"name":"radius","summary":"A radius value."},{"name":"tolerance","summary":"A tolerance value."}],"returns":"A new array of rolling ball fillet surfaces; this array can be empty on failure."},{"signature":"static Surface[] CreateRollingBallFillet(Surface surfaceA, Point2d uvA, Surface surfaceB, Point2d uvB, double radius, double tolerance)","summary":"Constructs a rolling ball fillet between two surfaces.","since":"5.0","parameters":[{"name":"surfaceA","summary":"A first surface."},{"name":"uvA","summary":"A point in the parameter space of FaceA near where the fillet is expected to hit the surface."},{"name":"surfaceB","summary":"A second surface."},{"name":"uvB","summary":"A point in the parameter space of FaceB near where the fillet is expected to hit the surface."},{"name":"radius","summary":"A radius value."},{"name":"tolerance","summary":"A tolerance value used for approximating and intersecting offset surfaces."}],"returns":"A new array of rolling ball fillet surfaces; this array can be empty on failure."},{"signature":"static Surface[] CreateRollingBallFillet(Surface surfaceA, Surface surfaceB, double radius, double tolerance)","summary":"Constructs a rolling ball fillet between two surfaces.","since":"5.0","parameters":[{"name":"surfaceA","summary":"A first surface."},{"name":"surfaceB","summary":"A second surface."},{"name":"radius","summary":"A radius value."},{"name":"tolerance","summary":"A tolerance value."}],"returns":"A new array of rolling ball fillet surfaces; this array can be empty on failure."},{"signature":"static Surface CreateSoftEditSurface(Surface surface, Point2d uv, Vector3d delta, double uLength, double vLength, double tolerance, bool fixEnds)","summary":"Creates a soft edited surface from an existing surface using a smooth field of influence.","since":"6.0","parameters":[{"name":"surface","summary":"The surface to soft edit."},{"name":"uv","summary":"A point in the parameter space to move from. This location on the surface is moved, and the move is smoothly tapered off with increasing distance along the surface from this parameter."},{"name":"delta","summary":"The direction and magnitude, or maximum distance, of the move."},{"name":"uLength","summary":"The distance along the surface\'s u-direction from the editing point over which the strength of the editing falls off smoothly."},{"name":"vLength","summary":"The distance along the surface\'s v-direction from the editing point over which the strength of the editing falls off smoothly."},{"name":"tolerance","summary":"The active document\'s model absolute tolerance."},{"name":"fixEnds","summary":"Keeps edge locations fixed."}],"returns":"The soft edited surface if successful. None on failure."},{"signature":"bool ClosestPoint(Point3d testPoint, out double u, out double v)","summary":"Input the parameters of the point on the surface that is closest to testPoint.","since":"5.0","parameters":[{"name":"testPoint","summary":"A point to test against."},{"name":"u","summary":"U parameter of the surface that is closest to testPoint."},{"name":"v","summary":"V parameter of the surface that is closest to testPoint."}],"returns":"True on success, False on failure."},{"signature":"IsoStatus ClosestSide(double u, double v)","summary":"Gets the side that is closest, in terms of 3D-distance, to a U and V parameter.","since":"5.0","parameters":[{"name":"u","summary":"A u parameter."},{"name":"v","summary":"A v parameter."}],"returns":"A side."},{"signature":"SurfaceCurvature CurvatureAt(double u, double v)","summary":"Computes the curvature at the given UV coordinate.","since":"5.0","parameters":[{"name":"u","summary":"U parameter for evaluation."},{"name":"v","summary":"V parameter for evaluation."}],"returns":"Surface Curvature data for the point at UV or None on failure."},{"signature":"int Degree(int direction)","summary":"Returns the maximum algebraic degree of any span (or a good estimate if curve spans are not algebraic).","since":"5.0","parameters":[{"name":"direction","summary":"0 gets first parameter\'s domain, 1 gets second parameter\'s domain."}],"returns":"The maximum degree."},{"signature":"Interval Domain(int direction)","summary":"Gets the domain in a direction.","since":"5.0","parameters":[{"name":"direction","summary":"0 gets first parameter, 1 gets second parameter."}],"returns":"An interval value."},{"signature":"bool Evaluate(double u, double v, int numberDerivatives, out Point3d point, out Vector3d[] derivatives)","summary":"Evaluates a surface mathematically.","since":"5.0","parameters":[{"name":"u","summary":"A U parameter."},{"name":"v","summary":"A V parameter."},{"name":"numberDerivatives","summary":"The number of derivatives."},{"name":"point","summary":"A point. This out parameter will be assigned during this call."},{"name":"derivatives","summary":"A vector array. This out parameter will be assigned during this call. This can be null."}],"returns":"True if the operation succeeded; False otherwise."},{"signature":"Surface Extend(IsoStatus edge, double extensionLength, bool smooth)","summary":"Extends an untrimmed surface along one edge.","since":"5.0","parameters":[{"name":"edge","summary":"Edge to extend.  Must be North, South, East, or West."},{"name":"extensionLength","summary":"distance to extend."},{"name":"smooth","summary":"True for smooth (C-infinity) extension. False for a C1- ruled extension."}],"returns":"New extended surface on success."},{"signature":"Surface Fit(int uDegree, int vDegree, double fitTolerance)","summary":"Fits a new surface through an existing surface.","since":"5.0","parameters":[{"name":"uDegree","summary":"the output surface U degree. Must be bigger than 1."},{"name":"vDegree","summary":"the output surface V degree. Must be bigger than 1."},{"name":"fitTolerance","summary":"The fitting tolerance."}],"returns":"A surface, or None on error."},{"signature":"bool FrameAt(double u, double v, out Plane frame)","summary":"Computes the orient plane on a surface given a U and V parameter.  \\nThis is the simple evaluation call with no error handling.","since":"5.0","parameters":[{"name":"u","summary":"A first parameter."},{"name":"v","summary":"A second parameter."},{"name":"frame","summary":"A frame plane that will be computed during this call."}],"returns":"True if this operation succeeded; otherwise false."},{"signature":"bool GetNextDiscontinuity(int direction, Continuity continuityType, double t0, double t1, out double t)","summary":"Searches for a derivative, tangent, or curvature discontinuity.","since":"5.0","parameters":[{"name":"direction","summary":"If 0, then \\"u\\" parameter is checked. If 1, then the \\"v\\" parameter is checked."},{"name":"continuityType","summary":"The desired continuity."},{"name":"t0","summary":"Search begins at t0. If there is a discontinuity at t0, it will be ignored. This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities."},{"name":"t1","summary":"(t0 != t1) If there is a discontinuity at t1 is will be ignored unless c is a locus discontinuity type and t1 is at the start or end of the curve."},{"name":"t","summary":"if a discontinuity is found, then t reports the parameter at the discontinuity."}],"returns":"Parametric continuity tests c = (C0_continuous, ..., G2_continuous): TRUE if a parametric discontinuity was found strictly between t0 and t1. Note well that all curves are parametrically continuous at the ends of their domains.  Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous): TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1 is the at the end of a curve. Note well that all open curves (IsClosed()=false) are locus discontinuous at the ends of their domains.  All closed curves (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains."},{"signature":"bool GetNurbsFormParameterFromSurfaceParameter(double surfaceS, double surfaceT, out double nurbsS, out double nurbsT)","summary":"Translates a parameter from the current surface to the parameter space of the surface returned by ToNurbsSurface().","since":"6.0","parameters":[{"name":"surfaceS","summary":"The parameter in the S, or sometimes U, direction, of this surface."},{"name":"surfaceT","summary":"The parameter in the T, or sometimes V, direction of this surface."},{"name":"nurbsS","summary":"S on the NURBS form."},{"name":"nurbsT","summary":"T on the NURBS form."}],"returns":"True if the operation succeeded; otherwise, false."},{"signature":"double[] GetSpanVector(int direction)","summary":"Gets array of span \\"knots\\".","since":"5.0","parameters":[{"name":"direction","summary":"0 gets first parameter\'s domain, 1 gets second parameter\'s domain."}],"returns":"An array with span vectors; or None on error."},{"signature":"bool GetSurfaceParameterFromNurbsFormParameter(double nurbsS, double nurbsT, out double surfaceS, out double surfaceT)","summary":"Translates a parameter from a value on the surface returned by ToNurbsSurface()to the current surface.","since":"6.0","parameters":[{"name":"nurbsS","summary":"The parameter in the S, or sometimes U, direction of the NURBS form surface."},{"name":"nurbsT","summary":"The parameter in the T, or sometimes V, direction of the NURBS form surface."},{"name":"surfaceS","summary":"S on this surface."},{"name":"surfaceT","summary":"T o n this surface."}],"returns":"True if the operation succeeded; otherwise, false."},{"signature":"bool GetSurfaceSize(out double width, out double height)","summary":"Gets an estimate of the size of the rectangle that would be created if the 3d surface where flattened into a rectangle.","since":"5.0","parameters":[{"name":"width","summary":"corresponds to the first surface parameter."},{"name":"height","summary":"corresponds to the second surface parameter."}],"returns":"True if successful."},{"signature":"int HasNurbsForm()","summary":"Is there a NURBS surface representation of this surface.","since":"5.0","returns":"0 unable to create NURBS representation with desired accuracy. 1 success - NURBS parameterization matches the surface\'s 2 success - NURBS point locus matches the surface\'s and the domain of the NURBS surface is correct. However, This surface\'s parameterization and the NURBS surface parameterization may not match.  This situation happens when getting NURBS representations of surfaces that have a transcendental parameterization like spheres, cylinders, and cones."},{"signature":"NurbsCurve InterpolatedCurveOnSurface(IEnumerable<Point3d> points, double tolerance)","summary":"Constructs an interpolated curve on a surface, using 3D points.","since":"5.0","parameters":[{"name":"points","summary":"A list, an array or any enumerable set of points."},{"name":"tolerance","summary":"A tolerance value."}],"returns":"A new NURBS curve, or None on error."},{"signature":"NurbsCurve InterpolatedCurveOnSurfaceUV(IEnumerable<Point2d> points, double tolerance)","summary":"Returns a curve that interpolates points on a surface. The interpolant lies on the surface.","since":"5.0","parameters":[{"name":"points","summary":"List of at least two UV parameter locations on the surface."},{"name":"tolerance","summary":"Tolerance used for the fit of the push-up curve. Generally, the resulting interpolating curve will be within tolerance of the surface."}],"returns":"A new NURBS curve if successful, or None on error."},{"signature":"NurbsCurve InterpolatedCurveOnSurfaceUV(IEnumerable<Point2d> points, double tolerance, bool closed, int closedSurfaceHandling)","summary":"Returns a curve that interpolates points on a surface. The interpolant lies on the surface.","since":"6.18","parameters":[{"name":"points","summary":"List of at least two UV parameter locations on the surface."},{"name":"tolerance","summary":"Tolerance used for the fit of the push-up curve. Generally, the resulting interpolating curve will be within tolerance of the surface."},{"name":"closed","summary":"If false, the interpolating curve is not closed. If true, the interpolating curve is closed, and the last point and first point should generally not be equal."},{"name":"closedSurfaceHandling","summary":"If 0, all points must be in the rectangular domain of the surface. If the surface is closed in some direction, then this routine will interpret each point and place it at an appropriate location in the covering space. This is the simplest option and should give good results. If 1, then more options for more control of handling curves going across seams are available. If the surface is closed in some direction, then the points are taken as points in the covering space. Example, if srf.IsClosed(0)=True and srf.IsClosed(1)=False and srf.Domain(0)=srf.Domain(1)=Interval(0,1) then if closedSurfaceHandling=1 a point(u, v) in points can have any value for the u coordinate, but must have 0<=v<=1. In particular, if points = { (0.0,0.5), (2.0,0.5) } then the interpolating curve will wrap around the surface two times in the closed direction before ending at start of the curve. If closed=True the last point should equal the first point plus an integer multiple of the period on a closed direction."}],"returns":"A new NURBS curve if successful, or None on error."},{"signature":"int IsAtSeam(double u, double v)","summary":"Tests if a surface parameter value is at a seam.","since":"5.0","parameters":[{"name":"u","summary":"Surface u parameter to test."},{"name":"v","summary":"Surface v parameter to test."}],"returns":"0 if not a seam, 1 if u == Domain(0)[i] and srf(u, v) == srf(Domain(0)[1-i], v) 2 if v == Domain(1)[i] and srf(u, v) == srf(u, Domain(1)[1-i]) 3 if 1 and 2 are true."},{"signature":"bool IsAtSingularity(double u, double v, bool exact)","summary":"Tests if a surface parameter value is at a singularity.","since":"5.0","parameters":[{"name":"u","summary":"Surface u parameter to test."},{"name":"v","summary":"Surface v parameter to test."},{"name":"exact","summary":"If true, test if (u,v) is exactly at a singularity. If false, test if close enough to cause numerical problems."}],"returns":"True if surface is singular at (s,t)"},{"signature":"bool IsClosed(int direction)","summary":"Gets a value indicating if the surface is closed in a direction.","since":"5.0","parameters":[{"name":"direction","summary":"0 = U, 1 = V."}],"returns":"The indicating boolean value."},{"signature":"bool IsCone()","summary":"Determines if the surface is a portion of a cone within RhinoMath.ZeroTolerance.","since":"5.0","returns":"True if the surface is a portion of a cone."},{"signature":"bool IsCone(double tolerance)","summary":"Determines if the surface is a portion of a cone within a given tolerance.","since":"5.0","parameters":[{"name":"tolerance","summary":"tolerance to use when checking."}],"returns":"True if the surface is a portion of a cone."},{"signature":"bool IsContinuous(Continuity continuityType, double u, double v)","summary":"Tests continuity at a surface parameter value.","since":"5.0","parameters":[{"name":"continuityType","summary":"The continuity type to sample."},{"name":"u","summary":"Surface u parameter to test."},{"name":"v","summary":"Surface v parameter to test."}],"returns":"True if the surface has at least the specified continuity at the (u,v) parameter."},{"signature":"bool IsCylinder()","summary":"Determines if the surface is a portion of a cylinder within RhinoMath.ZeroTolerance.","since":"5.0","returns":"True if the surface is a portion of a cylinder."},{"signature":"bool IsCylinder(double tolerance)","summary":"Determines if the surface is a portion of a cylinder within a given tolerance.","since":"5.0","parameters":[{"name":"tolerance","summary":"tolerance to use when checking."}],"returns":"True if the surface is a portion of a cylinder."},{"signature":"IsoStatus IsIsoparametric(BoundingBox bbox)","summary":"Determines if a 2d bounding box is isoparametric in the parameter space of this surface.","since":"5.0","parameters":[{"name":"bbox","summary":"Bounding box to test."}],"returns":"IsoStatus flag describing the iso-parametric relationship between the surface and the bounding box."},{"signature":"IsoStatus IsIsoparametric(Curve curve)","summary":"Determines if a 2d curve is isoparametric in the parameter space of this surface.","since":"5.0","parameters":[{"name":"curve","summary":"Curve to test."}],"returns":"IsoStatus flag describing the iso-parametric relationship between the surface and the curve."},{"signature":"IsoStatus IsIsoparametric(Curve curve, Interval curveDomain)","summary":"Determines if a 2D curve is isoparametric in the parameter space of this surface.","since":"5.0","parameters":[{"name":"curve","summary":"Curve to test."},{"name":"curveDomain","summary":"Sub domain of the curve."}],"returns":"IsoStatus flag describing the iso-parametric relationship between the surface and the curve."},{"signature":"Curve IsoCurve(int direction, double constantParameter)","summary":"Gets isoparametric curve.","since":"5.0","parameters":[{"name":"direction","summary":"0 first parameter varies and second parameter is constant e.g., point on IsoCurve(0,c) at t is srf(t,c) This is a horizontal line from left to right  1 first parameter is constant and second parameter varies e.g., point on IsoCurve(1,c) at t is srf(c,t This is a vertical line from bottom to top."},{"name":"constantParameter","summary":"The parameter that was constant on the original surface."}],"returns":"An isoparametric curve or None on error."},{"signature":"bool IsPeriodic(int direction)","summary":"Gets a value indicating if the surface is periodic in a direction (default is false).","since":"5.0","parameters":[{"name":"direction","summary":"0 = U, 1 = V."}],"returns":"The indicating boolean value."},{"signature":"bool IsPlanar()","summary":"Tests a surface to see if it is planar to zero tolerance.","since":"5.0","returns":"True if the surface is planar (flat) to within RhinoMath.ZeroTolerance units (1e-12)."},{"signature":"bool IsPlanar(double tolerance)","summary":"Tests a surface to see if it is planar to a given tolerance.","since":"5.0","parameters":[{"name":"tolerance","summary":"tolerance to use when checking."}],"returns":"True if there is a plane such that the maximum distance from the surface to the plane is <= tolerance."},{"signature":"bool IsSingular(int side)","summary":"True if surface side is collapsed to a point.","since":"5.0","parameters":[{"name":"side","summary":"side of parameter space to test 0 = south, 1 = east, 2 = north, 3 = west."}],"returns":"True if this specific side of the surface is singular; otherwise, false."},{"signature":"bool IsSphere()","summary":"Determines if the surface is a portion of a sphere within RhinoMath.ZeroTolerance.","since":"5.0","returns":"True if the surface is a portion of a sphere."},{"signature":"bool IsSphere(double tolerance)","summary":"Determines if the surface is a portion of a sphere within a given tolerance.","since":"5.0","parameters":[{"name":"tolerance","summary":"tolerance to use when checking."}],"returns":"True if the surface is a portion of a sphere."},{"signature":"bool IsTorus()","summary":"Determines if the surface is a portion of a torus within RhinoMath.ZeroTolerance.","since":"5.0","returns":"True if the surface is a portion of a torus."},{"signature":"bool IsTorus(double tolerance)","summary":"Determines if the surface is a portion of a torus within a given tolerance.","since":"5.0","parameters":[{"name":"tolerance","summary":"tolerance to use when checking."}],"returns":"True if the surface is a portion of a torus."},{"signature":"bool LocalClosestPoint(Point3d testPoint, double seedU, double seedV, out double u, out double v)","summary":"Find parameters of the point on a surface that is locally closest to the testPoint. The search for a local close point starts at seed parameters.","since":"6.3","parameters":[{"name":"testPoint","summary":"A point to test against."},{"name":"seedU","summary":"The seed parameter in the U direction."},{"name":"seedV","summary":"The seed parameter in the V direction."},{"name":"u","summary":"U parameter of the surface that is closest to testPoint."},{"name":"v","summary":"V parameter of the surface that is closest to testPoint."}],"returns":"True if the search is successful, False if the search fails."},{"signature":"Vector3d NormalAt(double u, double v)","summary":"Computes the surface normal at a point.  \\nThis is the simple evaluation call - it does not support error handling.","since":"5.0","parameters":[{"name":"u","summary":"A U parameter."},{"name":"v","summary":"A V parameter."}],"returns":"The normal."},{"signature":"Surface Offset(double distance, double tolerance)","summary":"Constructs a new surface which is offset from the current surface.","since":"5.0","parameters":[{"name":"distance","summary":"Distance (along surface normal) to offset."},{"name":"tolerance","summary":"Offset accuracy."}],"returns":"The offset surface or None on failure."},{"signature":"Point3d PointAt(double u, double v)","summary":"Evaluates a point at a given parameter.","since":"5.0","parameters":[{"name":"u","summary":"evaluation parameters."},{"name":"v","summary":"evaluation parameters."}],"returns":"Point3d.Unset on failure."},{"signature":"Curve Pullback(Curve curve3d, double tolerance)","summary":"Pulls a 3d curve back to the surface\'s parameter space.","since":"5.0","parameters":[{"name":"curve3d","summary":"The curve to pull."},{"name":"tolerance","summary":"the maximum acceptable 3d distance between from surface(curve_2d(t)) to the locus of points on the surface that are closest to curve_3d."}],"returns":"2d curve."},{"signature":"Curve Pullback(Curve curve3d, double tolerance, Interval curve3dSubdomain)","summary":"Pulls a 3d curve back to the surface\'s parameter space.","since":"5.0","parameters":[{"name":"curve3d","summary":"A curve."},{"name":"tolerance","summary":"the maximum acceptable 3d distance between from surface(curve_2d(t)) to the locus of points on the surface that are closest to curve_3d."},{"name":"curve3dSubdomain","summary":"A sub-domain of the curve to sample."}],"returns":"2d curve."},{"signature":"Curve Pushup(Curve curve2d, double tolerance)","summary":"Computes a 3d curve that is the composite of a 2d curve and the surface map.","since":"5.0","parameters":[{"name":"curve2d","summary":"a 2d curve whose image is in the surface\'s domain."},{"name":"tolerance","summary":"the maximum acceptable distance from the returned 3d curve to the image of curve_2d on the surface."}],"returns":"3d curve."},{"signature":"Curve Pushup(Curve curve2d, double tolerance, Interval curve2dSubdomain)","summary":"Computes a 3d curve that is the composite of a 2d curve and the surface map.","since":"5.0","parameters":[{"name":"curve2d","summary":"a 2d curve whose image is in the surface\'s domain."},{"name":"tolerance","summary":"the maximum acceptable distance from the returned 3d curve to the image of curve_2d on the surface."},{"name":"curve2dSubdomain","summary":"The curve interval (a sub-domain of the original curve) to use."}],"returns":"3d curve."},{"signature":"NurbsSurface Rebuild(int uDegree, int vDegree, int uPointCount, int vPointCount)","summary":"Rebuilds an existing surface to a given degree and point count.","since":"5.0","parameters":[{"name":"uDegree","summary":"the output surface u degree."},{"name":"vDegree","summary":"the output surface u degree."},{"name":"uPointCount","summary":"The number of points in the output surface u direction. Must be bigger than uDegree (maximum value is 1000)"},{"name":"vPointCount","summary":"The number of points in the output surface v direction. Must be bigger than vDegree (maximum value is 1000)"}],"returns":"new rebuilt surface on success. None on failure."},{"signature":"NurbsSurface RebuildOneDirection(int direction, int pointCount, LoftType loftType, double refitTolerance)","summary":"Rebuilds an existing surface with a new surface to a given point count in either the u or v directions independently.","since":"6.7","parameters":[{"name":"direction","summary":"The direction (0 = U, 1 = V)."},{"name":"pointCount","summary":"The number of points in the output surface in the \\"direction\\" direction."},{"name":"loftType","summary":"The loft type"},{"name":"refitTolerance","summary":"The refit tolerance. When in doubt, use the document\'s model absolute tolerance."}],"returns":"new rebuilt surface on success. None on failure."},{"signature":"Surface Reverse(int direction)","summary":"Reverses parameterization Domain changes from [a,b] to [-b,-a]","since":"5.0","parameters":[{"name":"direction","summary":"0 for first parameter\'s domain, 1 for second parameter\'s domain."}],"returns":"a new reversed surface on success."},{"signature":"Surface Reverse(int direction, bool inPlace)","summary":"Same as Reverse, but if inPlace is set to True this Surface is modified instead of a new copy being created.","since":"5.8","parameters":[{"name":"direction","summary":"0 for first parameter\'s domain, 1 for second parameter\'s domain."},{"name":"inPlace","summary":""}],"returns":"If inPlace is False, a new reversed surface on success. If inPlace is true, this surface instance is returned on success."},{"signature":"bool SetDomain(int direction, Interval domain)","summary":"Sets the domain in a direction.","since":"5.0","parameters":[{"name":"direction","summary":"0 sets first parameter\'s domain, 1 sets second parameter\'s domain."},{"name":"domain","summary":"A new domain to be assigned."}],"returns":"True if setting succeeded, otherwise false."},{"signature":"Curve ShortPath(Point2d start, Point2d end, double tolerance)","summary":"Constructs a geodesic between 2 points, used by ShortPath command in Rhino.","since":"5.0","parameters":[{"name":"start","summary":"start point of curve in parameter space. Points must be distinct in the domain of the surface."},{"name":"end","summary":"end point of curve in parameter space. Points must be distinct in the domain of the surface."},{"name":"tolerance","summary":"tolerance used in fitting discrete solution."}],"returns":"a geodesic curve on the surface on success. None on failure."},{"signature":"Surface Smooth(double smoothFactor, bool bXSmooth, bool bYSmooth, bool bZSmooth, bool bFixBoundaries, SmoothingCoordinateSystem coordinateSystem)","summary":"Smooths a surface by averaging the positions of control points in a specified region.","since":"6.0","parameters":[{"name":"smoothFactor","summary":"The smoothing factor, which controls how much control points move towards the average of the neighboring control points."},{"name":"bXSmooth","summary":"When True control points move in X axis direction."},{"name":"bYSmooth","summary":"When True control points move in Y axis direction."},{"name":"bZSmooth","summary":"When True control points move in Z axis direction."},{"name":"bFixBoundaries","summary":"When True the surface edges don\'t move."},{"name":"coordinateSystem","summary":"The coordinates to determine the direction of the smoothing."}],"returns":"The smoothed surface if successful, None otherwise."},{"signature":"Surface Smooth(double smoothFactor, bool bXSmooth, bool bYSmooth, bool bZSmooth, bool bFixBoundaries, SmoothingCoordinateSystem coordinateSystem, Plane plane)","summary":"Smooths a surface by averaging the positions of control points in a specified region.","since":"6.0","parameters":[{"name":"smoothFactor","summary":"The smoothing factor, which controls how much control points move towards the average of the neighboring control points."},{"name":"bXSmooth","summary":"When True control points move in X axis direction."},{"name":"bYSmooth","summary":"When True control points move in Y axis direction."},{"name":"bZSmooth","summary":"When True control points move in Z axis direction."},{"name":"bFixBoundaries","summary":"When True the surface edges don\'t move."},{"name":"coordinateSystem","summary":"The coordinates to determine the direction of the smoothing."},{"name":"plane","summary":"If SmoothingCoordinateSystem.CPlane specified, then the construction plane."}],"returns":"The smoothed surface if successful, None otherwise."},{"signature":"int SpanCount(int direction)","summary":"Gets number of smooth nonempty spans in the parameter direction.","since":"5.0","parameters":[{"name":"direction","summary":"0 gets first parameter\'s domain, 1 gets second parameter\'s domain."}],"returns":"The span count."},{"signature":"Surface[] Split(int direction, double parameter)","summary":"Splits (divides) the surface into two parts at the specified parameter","since":"5.0","parameters":[{"name":"direction","summary":"0 = The surface is split vertically. The \\"west\\" side is returned as the first surface in the array and the \\"east\\" side is returned as the second surface in the array. 1 = The surface is split horizontally. The \\"south\\" side is returned as the first surface in the array and the \\"north\\" side is returned as the second surface in the array"},{"name":"parameter","summary":"value of constant parameter in interval returned by Domain(direction)"}],"returns":"Array of two surfaces on success"},{"signature":"Brep ToBrep()","summary":"Converts the surface into a Brep.","since":"5.0","returns":"A Brep with a similar shape like this surface or null."},{"signature":"NurbsSurface ToNurbsSurface()","summary":"Gets a NURBS surface representation of this surface. Default tolerance of 0.0 is used.","since":"5.0","returns":"NurbsSurface on success, None on failure."},{"signature":"NurbsSurface ToNurbsSurface(double tolerance, out int accuracy)","summary":"Gets a NURBS surface representation of this surface.","since":"5.0","parameters":[{"name":"tolerance","summary":"tolerance to use when creating NURBS representation."},{"name":"accuracy","summary":"0 = unable to create NURBS representation with desired accuracy.  \\n1 = success - returned NURBS parameterization matches the surface\'s to the desired accuracy.  \\n2 = success - returned NURBS point locus matches the surface\'s to the desired accuracy and the domain of the NURBS surface is correct. However, this surface\'s parameterization and the NURBS surface parameterization may not match to the desired accuracy. This situation happens when getting NURBS representations of surfaces that have a transcendental parameterization like spheres, cylinders, and cones."}],"returns":"NurbsSurface on success, None on failure."},{"signature":"Surface Transpose()","summary":"Transposes surface parameterization (swap U and V)","since":"5.0","returns":"New transposed surface on success, None on failure."},{"signature":"Surface Transpose(bool inPlace)","summary":"Transposes surface parameterization (swap U and V)","since":"5.8","returns":"New transposed surface on success, None on failure."},{"signature":"Surface Trim(Interval u, Interval v)","summary":"Constructs a sub-surface that covers the specified UV trimming domain.","since":"5.0","parameters":[{"name":"u","summary":"Domain of surface along U direction to include in the subsurface."},{"name":"v","summary":"Domain of surface along V direction to include in the subsurface."}],"returns":"SubSurface on success, None on failure."},{"signature":"bool TryGetCone(out Cone cone)","summary":"Tests a surface to see if it is a portion of a cone within RhinoMath.ZeroTolerance and return the cone.","since":"5.0","parameters":[{"name":"cone","summary":"On success, the cone parameters are filled in."}],"returns":"True if the surface is a portion of a cone."},{"signature":"bool TryGetCone(out Cone cone, double tolerance)","summary":"Tests a surface to see if it is a portion of a cone and returns the cone.","since":"5.0","parameters":[{"name":"cone","summary":"On success, the cone parameters are filled in."},{"name":"tolerance","summary":"tolerance to use when checking."}],"returns":"True if the surface is a portion of a cone."},{"signature":"bool TryGetCylinder(out Cylinder cylinder)","summary":"Tests a surface to see if it is a portion of a cylinder within RhinoMath.ZeroTolerance and return the cylinder.","since":"5.0","parameters":[{"name":"cylinder","summary":"On success, the cylinder parameters are filled in."}],"returns":"True if the surface is a portion of a cylinder."},{"signature":"bool TryGetCylinder(out Cylinder cylinder, double tolerance)","summary":"Tests a surface to see if it is a portion of a cylinder and return the infinite cylinder.","since":"5.0","parameters":[{"name":"cylinder","summary":"On success, the cylinder parameters are filled in."},{"name":"tolerance","summary":"tolerance to use when checking."}],"returns":"True if the surface is a portion of a cylinder."},{"signature":"bool TryGetFiniteCylinder(out Cylinder cylinder, double tolerance)","summary":"Tests a surface with the assumption that it might be a right circular cylinder and returns this geometry.","since":"6.0","parameters":[{"name":"cylinder","summary":"On success, the cylinder parameters are filled in."},{"name":"tolerance","summary":"tolerance to use when checking."}],"returns":"True if the surface is a portion of a cylinder."},{"signature":"bool TryGetPlane(out Plane plane)","summary":"Tests a surface for planarity and return the plane.","since":"5.0","parameters":[{"name":"plane","summary":"On success, the plane parameters are filled in."}],"returns":"True if there is a plane such that the maximum distance from the surface to the plane is <= RhinoMath.ZeroTolerance."},{"signature":"bool TryGetPlane(out Plane plane, double tolerance)","summary":"Tests a surface for planarity and return the plane.","since":"5.0","parameters":[{"name":"plane","summary":"On success, the plane parameters are filled in."},{"name":"tolerance","summary":"tolerance to use when checking."}],"returns":"True if there is a plane such that the maximum distance from the surface to the plane is <= tolerance."},{"signature":"bool TryGetSphere(out Sphere sphere)","summary":"Test a surface to see if it is a portion of a sphere and return the sphere.","since":"5.0","parameters":[{"name":"sphere","summary":"On success, the sphere parameters are filled in."}],"returns":"True if the surface is a portion of a sphere."},{"signature":"bool TryGetSphere(out Sphere sphere, double tolerance)","summary":"Test a surface to see if it is a portion of a sphere and return the sphere.","since":"5.0","parameters":[{"name":"sphere","summary":"On success, the sphere parameters are filled in."},{"name":"tolerance","summary":"tolerance to use when checking."}],"returns":"True if the surface is a portion of a sphere."},{"signature":"bool TryGetTorus(out Torus torus)","summary":"Tests a surface to see if it is a portion of a torus within RhinoMath.ZeroTolerance and returns the torus.","since":"5.0","parameters":[{"name":"torus","summary":"On success, the torus parameters are filled in."}],"returns":"True if the surface is a portion of a torus."},{"signature":"bool TryGetTorus(out Torus torus, double tolerance)","summary":"Tests a surface to see if it is a portion of a torus and returns the torus.","since":"5.0","parameters":[{"name":"torus","summary":"On success, the torus parameters are filled in."},{"name":"tolerance","summary":"tolerance to use when checking."}],"returns":"True if the surface is a portion of a torus."},{"signature":"Surface VariableOffset(double uMinvMin, double uMinvMax, double uMaxvMin, double uMaxvMax, double tolerance)","summary":"Copies a surface so that all locations at the corners of the copied surface are specified distances from the original surface.","since":"6.13","parameters":[{"name":"uMinvMin","summary":"Offset distance at Domain(0).Min, Domain(1).Min."},{"name":"uMinvMax","summary":"Offset distance at Domain(0).Min, Domain(1).Max."},{"name":"uMaxvMin","summary":"Offset distance at Domain(0).Max, Domain(1).Min."},{"name":"uMaxvMax","summary":"Offset distance at Domain(0).Max, Domain(1).Max."},{"name":"tolerance","summary":"The offset tolerance."}],"returns":"The offset surface if successful, None otherwise."},{"signature":"Surface VariableOffset(double uMinvMin, double uMinvMax, double uMaxvMin, double uMaxvMax, IEnumerable<Point2d> interiorParameters, IEnumerable<double> interiorDistances, double tolerance)","summary":"Copies a surface so that all locations at the corners, and from specified interior locations, of the copied surface are specified distances from the original surface.","since":"6.13","parameters":[{"name":"uMinvMin","summary":"Offset distance at Domain(0).Min, Domain(1).Min."},{"name":"uMinvMax","summary":"Offset distance at Domain(0).Min, Domain(1).Max."},{"name":"uMaxvMin","summary":"Offset distance at Domain(0).Max, Domain(1).Min."},{"name":"uMaxvMax","summary":"Offset distance at Domain(0).Max, Domain(1).Max."},{"name":"interiorParameters","summary":"An array of interior UV parameters to offset from."},{"name":"interiorDistances","summary":">An array of offset distances at the interior UV parameters."},{"name":"tolerance","summary":"The offset tolerance."}],"returns":"The offset surface if successful, None otherwise."}]},{"namespace":"Rhino.Geometry","name":"SurfaceCurvature","dataType":"class","summary":"Maintains computed information for surface curvature evaluation.","properties":[{"signature":"double Gaussian","summary":"Gets the Gaussian curvature value at UV.","since":"5.0","property":["get"]},{"signature":"double Mean","summary":"Gets the Mean curvature value at UV.","since":"5.0","property":["get"]},{"signature":"Vector3d Normal","summary":"Gets the surface normal at UV.","since":"5.0","property":["get"]},{"signature":"Point3d Point","summary":"Gets the surface point at UV.","since":"5.0","property":["get"]},{"signature":"Point2d UVPoint","summary":"Gets the UV location where the curvature was computed.","since":"5.0","property":["get"]}],"methods":[{"signature":"Vector3d Direction(int direction)","summary":"Gets the principal curvature direction vector.","since":"5.0","parameters":[{"name":"direction","summary":"Direction index, valid values are 0 and 1."}],"returns":"The specified direction vector."},{"signature":"double Kappa(int direction)","summary":"Gets the Kappa curvature value.","since":"5.0","parameters":[{"name":"direction","summary":"Kappa index, valid values are 0 and 1."}],"returns":"The specified kappa value."},{"signature":"Circle OsculatingCircle(int direction)","summary":"Computes the osculating circle along the given direction.","since":"5.0","parameters":[{"name":"direction","summary":"Direction index, valid values are 0 and 1."}],"returns":"The osculating circle in the given direction or Circle.Unset on failure."}]},{"namespace":"Rhino.Geometry","name":"SurfaceProxy","dataType":"class","summary":"Provides a base class to brep faces and other surface proxies.","baseclass":"Rhino.Geometry.Surface"},{"namespace":"Rhino.Geometry","name":"SweepBlend","dataType":"enum","summary":"Blend types for creating swept surfaces","since":"7.0","values":[{"signature":"Local = 0","summary":"The sweep stays constant at the ends and changes more rapidly in the middle."},{"signature":"Global = 1","summary":"The sweep is linearly blended from one end to the other, creating sweeps that taper from one cross-section curve to the other."}]},{"namespace":"Rhino.Geometry","name":"SweepFrame","dataType":"enum","summary":"Frame types for creating swept surfaces","since":"7.0","values":[{"signature":"Freeform = 0","summary":"The cross-section curve rotates to maintain its angle to the rail throughout the sweep."},{"signature":"Roadlike = 1","summary":"Specify an axis for calculating the 3-D rotation of the cross-section."}]},{"namespace":"Rhino.Geometry","name":"SweepMiter","dataType":"enum","summary":"Miter types for creating swept surfaces","since":"7.0","values":[{"signature":"None = 0","summary":"No mitering"},{"signature":"Trimmed = 1","summary":"If the sweep creates a polysurface with kinks, the component surfaces will be trimmed."},{"signature":"Untrimmed = 2","summary":"If the sweep creates a polysurface with kinks, the component surfaces will be untrimmed."}]},{"namespace":"Rhino.Geometry","name":"SweepOneRail","dataType":"class","summary":"Utility class for generating Breps by sweeping cross section curves over a single rail curve. Note, this class has been superseded by the Rhino.Geometry.Brep.CreateFromSweep static functions.","constructors":[{"signature":"SweepOneRail()","since":"5.0"}],"properties":[{"signature":"double AngleToleranceRadians","since":"5.0","property":["get","set"]},{"signature":"bool ClosedSweep","summary":"If the input rail is closed, ClosedSweep determines if the swept breps will also be closed.","since":"5.0","property":["get","set"]},{"signature":"bool GlobalShapeBlending","summary":"If true, the sweep is linearly blended from one end to the other, creating sweeps that taper from one cross-section curve to the other. If false, the sweep stays constant at the ends and changes more rapidly in the middle.","since":"5.1","property":["get","set"]},{"signature":"bool IsFreeform","since":"5.0","property":["get"]},{"signature":"bool IsRoadlike","since":"5.0","property":["get"]},{"signature":"bool IsRoadlikeFront","since":"5.0","property":["get"]},{"signature":"bool IsRoadlikeTop","since":"5.0","property":["get"]},{"signature":"bool IsRoadlineRight","since":"5.0","property":["get"]},{"signature":"int MiterType","summary":"0: don\'t miter,  1: intersect surfaces and trim sweeps,  2: rotate shapes at kinks and don\'t trim.","since":"5.0","property":["get","set"]},{"signature":"double SweepTolerance","since":"5.0","property":["get","set"]}],"methods":[{"signature":"Brep[] PerformSweep(Curve rail, Curve crossSection)","since":"5.0"},{"signature":"Brep[] PerformSweep(Curve rail, Curve crossSection, double crossSectionParameter)","since":"5.0"},{"signature":"Brep[] PerformSweep(Curve rail, IEnumerable<Curve> crossSections)","since":"5.0"},{"signature":"Brep[] PerformSweep(Curve rail, IEnumerable<Curve> crossSections, IEnumerable<double> crossSectionParameters)","since":"5.0"},{"signature":"Brep[] PerformSweepRebuild(Curve rail, Curve crossSection, double crossSectionParameter, int rebuildCount)","since":"5.0"},{"signature":"Brep[] PerformSweepRebuild(Curve rail, Curve crossSection, int rebuildCount)","since":"5.0"},{"signature":"Brep[] PerformSweepRebuild(Curve rail, IEnumerable<Curve> crossSections, IEnumerable<double> crossSectionParameters, int rebuildCount)","since":"5.0"},{"signature":"Brep[] PerformSweepRebuild(Curve rail, IEnumerable<Curve> crossSections, int rebuildCount)","since":"5.0"},{"signature":"Brep[] PerformSweepRefit(Curve rail, Curve crossSection, double refitTolerance)","since":"5.0"},{"signature":"Brep[] PerformSweepRefit(Curve rail, Curve crossSection, double crossSectionParameter, double refitTolerance)","since":"5.0"},{"signature":"Brep[] PerformSweepRefit(Curve rail, IEnumerable<Curve> crossSections, double refitTolerance)","since":"5.0"},{"signature":"Brep[] PerformSweepRefit(Curve rail, IEnumerable<Curve> crossSections, IEnumerable<double> crossSectionParameters, double refitTolerance)","since":"5.0"},{"signature":"void SetRoadlikeUpDirection(Vector3d up)","since":"5.0"},{"signature":"void SetToRoadlikeFront()","since":"5.0"},{"signature":"void SetToRoadlikeRight()","since":"5.0"},{"signature":"void SetToRoadlikeTop()","since":"5.0"}]},{"namespace":"Rhino.Geometry","name":"SweepRebuild","dataType":"enum","summary":"Rebuild types for creating swept surfaces","since":"6.16","values":[{"signature":"None = 0","summary":"Do not simplify cross section curves."},{"signature":"Rebuild = 1","summary":"Rebuild cross section curves through points."},{"signature":"Refit = 2","summary":"Refit cross section curves to tolerance."}]},{"namespace":"Rhino.Geometry","name":"SweepTwoRail","dataType":"class","summary":"Utility class for generating Breps by sweeping cross section curves over two rail curves. Note, this class has been superseded by the Rhino.Geometry.Brep.CreateFromSweep static functions.","constructors":[{"signature":"SweepTwoRail()","since":"5.0"}],"properties":[{"signature":"double AngleToleranceRadians","summary":"Gets or sets the angle tolerance in radians.","since":"5.0","property":["get","set"]},{"signature":"bool ClosedSweep","summary":"If the input rails are closed, ClosedSweep determines if the swept Breps will also be closed.","since":"5.0","property":["get","set"]},{"signature":"bool MaintainHeight","summary":"Removes the association between the height scaling from the width scaling.","since":"5.0","property":["get","set"]},{"signature":"double SweepTolerance","summary":"Gets or sets the sweeping tolerance.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"Brep[] PerformSweep(Curve rail1, Curve rail2, Curve crossSection)","summary":"Sweep2 function that fits a surface through profile curves that define the surface cross-sections and two curves that defines a surface edge.","since":"5.0","parameters":[{"name":"rail1","summary":"Rail to sweep shapes along"},{"name":"rail2","summary":"Rail to sweep shapes along"},{"name":"crossSection","summary":"Shape curve"}],"returns":"Array of Brep sweep results"},{"signature":"Brep[] PerformSweep(Curve rail1, Curve rail2, Curve crossSection, double crossSectionParameterRail1, double crossSectionParameterRail2)","since":"5.0","deprecated":"7.0"},{"signature":"Brep[] PerformSweep(Curve rail1, Curve rail2, IEnumerable<Curve> crossSections)","summary":"Sweep2 function that fits a surface through profile curves that define the surface cross-sections and two curves that defines a surface edge.","since":"5.0","parameters":[{"name":"rail1","summary":"Rail to sweep shapes along"},{"name":"rail2","summary":"Rail to sweep shapes along"},{"name":"crossSections","summary":"Shape curves"}],"returns":"Array of Brep sweep results"},{"signature":"Brep[] PerformSweep(Curve rail1, Curve rail2, IEnumerable<Curve> crossSections, IEnumerable<double> crossSectionParameters1, IEnumerable<double> crossSectionParameters2)","since":"5.0","deprecated":"7.0"},{"signature":"Brep[] PerformSweepRebuild(Curve rail1, Curve rail2, Curve crossSection, double crossSectionParameterRail1, double crossSectionParameterRail2, int rebuildCount)","since":"5.0","deprecated":"7.0"},{"signature":"Brep[] PerformSweepRebuild(Curve rail1, Curve rail2, Curve crossSection, int rebuildCount)","summary":"Sweep2 function that fits a surface through profile curves that define the surface cross-sections and two curves that defines a surface edge.","since":"5.0","parameters":[{"name":"rail1","summary":"Rail to sweep shapes along"},{"name":"rail2","summary":"Rail to sweep shapes along"},{"name":"crossSection","summary":"Shape curve"},{"name":"rebuildCount","summary":"Rebuild point count"}],"returns":"Array of Brep sweep results"},{"signature":"Brep[] PerformSweepRebuild(Curve rail1, Curve rail2, IEnumerable<Curve> crossSections, IEnumerable<double> crossSectionParametersRail1, IEnumerable<double> crossSectionParametersRail2, int rebuildCount)","since":"5.0","deprecated":"7.0"},{"signature":"Brep[] PerformSweepRebuild(Curve rail1, Curve rail2, IEnumerable<Curve> crossSections, int rebuildCount)","summary":"Sweep2 function that fits a surface through profile curves that define the surface cross-sections and two curves that defines a surface edge.","since":"5.0","parameters":[{"name":"rail1","summary":"Rail to sweep shapes along"},{"name":"rail2","summary":"Rail to sweep shapes along"},{"name":"crossSections","summary":"Shape curves"},{"name":"rebuildCount","summary":"Rebuild point count"}],"returns":"Array of Brep sweep results"},{"signature":"Brep[] PerformSweepRefit(Curve rail1, Curve rail2, Curve crossSection, double refitTolerance)","summary":"Sweep2 function that fits a surface through profile curves that define the surface cross-sections and two curves that defines a surface edge.","since":"5.0","parameters":[{"name":"rail1","summary":"Rail to sweep shapes along"},{"name":"rail2","summary":"Rail to sweep shapes along"},{"name":"crossSection","summary":"Shape curve"},{"name":"refitTolerance","summary":"Refit tolerance"}],"returns":"Array of Brep sweep results"},{"signature":"Brep[] PerformSweepRefit(Curve rail1, Curve rail2, Curve crossSection, double crossSectionParameterRail1, double crossSectionParameterRail2, double refitTolerance)","since":"5.0","deprecated":"7.0"},{"signature":"Brep[] PerformSweepRefit(Curve rail1, Curve rail2, IEnumerable<Curve> crossSections, double refitTolerance)","summary":"Sweep2 function that fits a surface through profile curves that define the surface cross-sections and two curves that defines a surface edge.","since":"5.0","parameters":[{"name":"rail1","summary":"Rail to sweep shapes along"},{"name":"rail2","summary":"Rail to sweep shapes along"},{"name":"crossSections","summary":"Shape curves"},{"name":"refitTolerance","summary":"Refit tolerance"}],"returns":"Array of Brep sweep results"},{"signature":"Brep[] PerformSweepRefit(Curve rail1, Curve rail2, IEnumerable<Curve> crossSections, IEnumerable<double> crossSectionParametersRail1, IEnumerable<double> crossSectionParametersRail2, double refitTolerance)","since":"5.0","deprecated":"7.0"}]},{"namespace":"Rhino.Geometry","name":"TextDot","dataType":"class","summary":"Represents a text dot, or an annotation entity with text that always faces the camera and always has the same size.  \\nThis class refers to the geometric element that is independent from the document.","baseclass":"Rhino.Geometry.GeometryBase","constructors":[{"signature":"TextDot(string text, Point3d location)","summary":"Initializes a new text dot based on the text and the location.","since":"5.0","parameters":[{"name":"text","summary":"Text."},{"name":"location","summary":"A position."}]}],"properties":[{"signature":"string FontFace","summary":"Font face used for displaying the dot","since":"5.2","property":["get","set"]},{"signature":"int FontHeight","summary":"Height of font used for displaying the dot","since":"5.2","property":["get","set"]},{"signature":"Point3d Point","summary":"Gets or sets the position of the text dot.","since":"5.0","property":["get","set"]},{"signature":"string SecondaryText","summary":"Gets or sets the secondary text of the text dot.","since":"6.0","property":["get","set"]},{"signature":"string Text","summary":"Gets or sets the primary text of the text dot.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.Geometry","name":"TextEntity","dataType":"class","baseclass":"Rhino.Geometry.AnnotationBase","constructors":[{"signature":"TextEntity()","summary":"Initializes a new instance of the TextEntityclass.","since":"5.0"}],"properties":[{"signature":"TextJustification Justification","summary":"Gets or sets the justification of text in relation to its base point.","since":"5.0","property":["get","set"]},{"signature":"TextHorizontalAlignment TextHorizontalAlignment","since":"6.0","property":["get","set"]},{"signature":"TextOrientation TextOrientation","since":"6.0","property":["get","set"]},{"signature":"TextVerticalAlignment TextVerticalAlignment","since":"6.0","property":["get","set"]}],"methods":[{"signature":"static TextEntity Create(string text, Plane plane, DimensionStyle style, bool wrapped, double rectWidth, double rotationRadians)","summary":"Create Text geometry or None if input is invalid","since":"6.0"},{"signature":"static TextEntity CreateWithRichText(string richTextString, Plane plane, DimensionStyle style, bool wrapped, double rectWidth, double rotationRadians)","summary":"Create RichText geometry or None if input is invalid","since":"6.0"},{"signature":"Curve[] CreateCurves(DimensionStyle dimstyle, bool bAllowOpen, double smallCapsScale, double spacing)","summary":"Returns the outline curves.","since":"6.0","parameters":[{"name":"dimstyle","summary":""},{"name":"bAllowOpen","summary":"Set to True to prevent forced closing of open curves retrieved from glyphs."},{"name":"smallCapsScale","summary":"Set to create small caps out of lower case letters."},{"name":"spacing","summary":"Set to add additional spacing between glyph output."}],"returns":"An array of curves that forms the outline or content of this text entity."},{"signature":"Extrusion[] CreateExtrusions(DimensionStyle dimstyle, double height, double smallCapsScale, double spacing)","summary":"Creates extrusions from the outline curves with specified height.","since":"6.0","parameters":[{"name":"dimstyle","summary":""},{"name":"height","summary":"Height in direction perpendicular to plane of text."},{"name":"smallCapsScale","summary":"Set to create small caps out of lower case letters."},{"name":"spacing","summary":"Set to add additional spacing between glyph output."}],"returns":"An array of planar breps."},{"signature":"Brep[] CreatePolySurfaces(DimensionStyle dimstyle, double height, double smallCapsScale, double spacing)","summary":"Creates breps from the outline curves with specified height.","since":"6.0","parameters":[{"name":"dimstyle","summary":""},{"name":"height","summary":"Height in direction perpendicular to plane of text."},{"name":"smallCapsScale","summary":"Set to create small caps out of lower case letters."},{"name":"spacing","summary":"Set to add additional spacing between glyph output."}],"returns":"An array of planar breps."},{"signature":"Brep[] CreateSurfaces(DimensionStyle dimstyle, double smallCapsScale, double spacing)","summary":"Creates planar breps from the outline curves.","since":"6.0","parameters":[{"name":"dimstyle","summary":""},{"name":"smallCapsScale","summary":"Set to create small caps out of lower case letters."},{"name":"spacing","summary":"Set to add additional spacing between glyph output."}],"returns":"An array of planar breps."},{"signature":"Curve[] Explode()","summary":"Explodes this text entity into an array of curves.","since":"5.0","returns":"An array of curves that forms the outline or content of this text entity."},{"signature":"Transform GetTextTransform(double textscale, DimensionStyle dimstyle)","summary":"Get the transform for this text object\'s text geometry","since":"6.0"},{"signature":"bool Transform(Transform transform, DimensionStyle style)","summary":"Transform the object by a 4x4 transform matrix and change text height override to accommodate scaling in the transform if necessary","since":"6.0","parameters":[{"name":"transform","summary":"An Transform with the transformation information"},{"name":"style","summary":""}],"returns":"Returns True on success otherwise returns false."}]},{"namespace":"Rhino.Geometry","name":"TextJustification","dataType":"enum","summary":"Specifies enumerated constants used to indicate the internal alignment and justification of text.","since":"5.0","values":[{"signature":"None = 0","summary":"The default justification."},{"signature":"Left = 1 << 0","summary":"Left justification."},{"signature":"Center = 1 << 1","summary":"Center justification."},{"signature":"Right = 1 << 2","summary":"Right justification."},{"signature":"Bottom = 1 << 16","summary":"Bottom inner alignment."},{"signature":"Middle = 1 << 17","summary":"Middle inner alignment."},{"signature":"Top = 1 << 18","summary":"Top inner alignment."},{"signature":"BottomLeft = Bottom | Left","summary":"Combination of left justification and bottom alignment."},{"signature":"BottomCenter = Bottom | Center","summary":"Combination of center justification and bottom alignment."},{"signature":"BottomRight = Bottom | Right","summary":"Combination of right justification and bottom alignment."},{"signature":"MiddleLeft = Middle | Left","summary":"Combination of left justification and middle alignment."},{"signature":"MiddleCenter = Middle | Center","summary":"Combination of center justification and middle alignment."},{"signature":"MiddleRight = Middle | Right","summary":"Combination of right justification and middle alignment."},{"signature":"TopLeft = Top | Left","summary":"Combination of left justification and top alignment."},{"signature":"TopCenter = Top | Center","summary":"Combination of center justification and top alignment."},{"signature":"TopRight = Top | Right","summary":"Combination of right justification and top alignment."}]},{"namespace":"Rhino.Geometry","name":"TextRunType","dataType":"enum","since":"6.0","values":[{"signature":"None = UnsafeNativeMethods.TextRunTypeConsts.None"},{"signature":"Text = UnsafeNativeMethods.TextRunTypeConsts.Text"},{"signature":"Newline = UnsafeNativeMethods.TextRunTypeConsts.Newline"},{"signature":"Paragraph = UnsafeNativeMethods.TextRunTypeConsts.Paragraph"},{"signature":"Column = UnsafeNativeMethods.TextRunTypeConsts.Column"},{"signature":"Field = UnsafeNativeMethods.TextRunTypeConsts.Field"},{"signature":"Fontdef = UnsafeNativeMethods.TextRunTypeConsts.Fontdef"},{"signature":"Header = UnsafeNativeMethods.TextRunTypeConsts.Header"}]},{"namespace":"Rhino.Geometry","name":"Torus","dataType":"struct","summary":"Represents the value of a plane and two radii in a torus that is oriented in three-dimensional space.","constructors":[{"signature":"Torus(Plane basePlane, double majorRadius, double minorRadius)","summary":"Initializes a new Torus from base pane and two radii.","since":"5.0","parameters":[{"name":"basePlane","summary":"Base plane for major radius circle."},{"name":"majorRadius","summary":"Radius of circle that lies at the heart of the torus."},{"name":"minorRadius","summary":"Radius of torus section."}]}],"properties":[{"signature":"static Torus Unset","summary":"Gets an invalid Torus.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Gets a value indicating whether this torus is valid.","since":"5.0","property":["get"]},{"signature":"double MajorRadius","summary":"Gets or sets the radius of the circle that lies at the heart of the torus.","since":"5.0","property":["get","set"]},{"signature":"double MinorRadius","summary":"Gets or sets the radius of the torus section.","since":"5.0","property":["get","set"]},{"signature":"Plane Plane","summary":"Gets or sets the plane for the torus large circle.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"bool EpsilonEquals(Torus other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"NurbsSurface ToNurbsSurface()","summary":"Converts this torus to its NURBS surface representation. This is synonymous with calling NurbsSurface.CreateFromTorus().","since":"5.0","returns":"A NURBS surface representation of this torus, or None on error."},{"signature":"RevSurface ToRevSurface()","summary":"Convert this torus to a surface of revolution representation. This is synonymous with calling RevSurface.CreateFromTorus().","since":"5.0","returns":"A surface of revolution representation of this torus, or None on error."}]},{"namespace":"Rhino.Geometry","name":"Transform","dataType":"struct","summary":"Represents the values in a 4x4 transform matrix.  \\nThis is parallel to C++ ON_Xform.","constructors":[{"signature":"Transform(double diagonalValue)","summary":"Initializes a new transform matrix with a specified value along the diagonal.","since":"5.0","parameters":[{"name":"diagonalValue","summary":"Value to assign to all diagonal cells except M33 which is set to 1.0."}]},{"signature":"Transform(Transform value)","summary":"Initializes a new transform matrix with a specified value.","since":"6.0","parameters":[{"name":"value","summary":"Value to assign to all cells."}]}],"properties":[{"signature":"static Transform Identity","summary":"Gets a new identity transform matrix. An identity matrix defines no transformation.","since":"5.0","property":["get"]},{"signature":"static Transform Unset","summary":"Gets an XForm filled with RhinoMath.UnsetValue.","since":"5.0","property":["get"]},{"signature":"static Transform ZeroTransformation","summary":"ZeroTransformation diagonal = (0,0,0,1)","since":"6.1","property":["get"]},{"signature":"double Determinant","summary":"The determinant of this 4x4 matrix.","since":"5.0","property":["get"]},{"signature":"bool IsAffine","summary":"Tests for an affine transformation. An affine transformation can be broken into a linear transformation and a translation.","since":"6.12","property":["get"]},{"signature":"bool IsIdentity","summary":"Return True if this Transform is the identity transform","since":"6.0","property":["get"]},{"signature":"bool IsLinear","summary":"Tests for a linear transformation. An affine transformation can be broken into a linear transformation and a translation.","since":"6.12","property":["get"]},{"signature":"bool IsRotation","summary":"Returns True if this is a proper rotation.","since":"6.12","property":["get"]},{"signature":"bool IsValid","summary":"Gets a value indicating whether or not this Transform is a valid matrix. A valid transform matrix is not allowed to have any invalid numbers.","since":"5.0","property":["get"]},{"signature":"bool IsZero","summary":"True if matrix is Zero4x4, ZeroTransformation, or some other type of zero. The value xform[3][3] can be anything.","since":"6.1","property":["get"]},{"signature":"bool IsZero4x4","summary":"True if all values are 0","since":"6.1","property":["get"]},{"signature":"bool IsZeroTransformation","summary":"True if all values are 0 and M33 is 1","since":"6.1","property":["get"]},{"signature":"double M00","summary":"Gets or sets this[0,0].","since":"5.0","property":["get","set"]},{"signature":"double M01","summary":"Gets or sets this[0,1].","since":"5.0","property":["get","set"]},{"signature":"double M02","summary":"Gets or sets this[0,2].","since":"5.0","property":["get","set"]},{"signature":"double M03","summary":"Gets or sets this[0,3].","since":"5.0","property":["get","set"]},{"signature":"double M10","summary":"Gets or sets this[1,0].","since":"5.0","property":["get","set"]},{"signature":"double M11","summary":"Gets or sets this[1,1].","since":"5.0","property":["get","set"]},{"signature":"double M12","summary":"Gets or sets this[1,2].","since":"5.0","property":["get","set"]},{"signature":"double M13","summary":"Gets or sets this[1,3].","since":"5.0","property":["get","set"]},{"signature":"double M20","summary":"Gets or sets this[2,0].","since":"5.0","property":["get","set"]},{"signature":"double M21","summary":"Gets or sets this[2,1].","since":"5.0","property":["get","set"]},{"signature":"double M22","summary":"Gets or sets this[2,2].","since":"5.0","property":["get","set"]},{"signature":"double M23","summary":"Gets or sets this[2,3].","since":"5.0","property":["get","set"]},{"signature":"double M30","summary":"Gets or sets this[3,0].","since":"5.0","property":["get","set"]},{"signature":"double M31","summary":"Gets or sets this[3,1].","since":"5.0","property":["get","set"]},{"signature":"double M32","summary":"Gets or sets this[3,2].","since":"5.0","property":["get","set"]},{"signature":"double M33","summary":"Gets or sets this[3,3].","since":"5.0","property":["get","set"]},{"signature":"TransformRigidType RigidType","summary":"Gets a value indicating whether or not the Transform is rigid. A rigid transformation can be broken into  a proper rotation and a translation, while an isometry transformation could also include a reflection.","since":"6.12","property":["get"]},{"signature":"TransformSimilarityType SimilarityType","summary":"Gets a value indicating whether or not the Transform maintains similarity. The easiest way to think of Similarity is that any circle, when transformed, remains a circle. Whereas a non-similarity Transform deforms circles into ellipses.","since":"5.0","property":["get"]}],"methods":[{"signature":"static Transform ChangeBasis(Plane plane0, Plane plane1)","summary":"Computes a change of basis transformation. A basis change is essentially a remapping of geometry from one coordinate system to another.","since":"5.0","parameters":[{"name":"plane0","summary":"Coordinate system in which the geometry is currently described."},{"name":"plane1","summary":"Target coordinate system in which we want the geometry to be described."}],"returns":"A transformation matrix which orients geometry from one coordinate system to another on success. Transform.Unset on failure."},{"signature":"static Transform ChangeBasis(Vector3d initialBasisX, Vector3d initialBasisY, Vector3d initialBasisZ, Vector3d finalBasisX, Vector3d finalBasisY, Vector3d finalBasisZ)","summary":"Computes a change of basis transformation. A basis change is essentially a remapping of geometry from one coordinate system to another.","since":"5.0","parameters":[{"name":"initialBasisX","summary":"can be any 3d basis."},{"name":"initialBasisY","summary":"can be any 3d basis."},{"name":"initialBasisZ","summary":"can be any 3d basis."},{"name":"finalBasisX","summary":"can be any 3d basis."},{"name":"finalBasisY","summary":"can be any 3d basis."},{"name":"finalBasisZ","summary":"can be any 3d basis."}],"returns":"A transformation matrix which orients geometry from one coordinate system to another on success. Transform.Unset on failure."},{"signature":"static Transform Diagonal(double d0, double d1, double d2)","summary":"Constructs a new transformation with diagonal (d0,d1,d2,1.0).","since":"6.12","parameters":[{"name":"d0","summary":"Transform.M00 value."},{"name":"d1","summary":"Transform.M11 value."},{"name":"d2","summary":"Transform.M22 value."}],"returns":"A transformation with diagonal (d0,d1,d2,1.0)."},{"signature":"static Transform Diagonal(Vector3d diagonal)","summary":"Constructs a new transformation with diagonal (d0,d1,d2,1.0).","since":"6.12","parameters":[{"name":"diagonal","summary":"The diagonal values."}],"returns":"A transformation with diagonal (d0,d1,d2,1.0)."},{"signature":"static Transform Mirror(Plane mirrorPlane)","summary":"Constructs a new Mirror transformation.","since":"5.0","parameters":[{"name":"mirrorPlane","summary":"Plane that defines the mirror orientation and position."}],"returns":"A transformation matrix which mirrors geometry in a specified plane."},{"signature":"static Transform Mirror(Point3d pointOnMirrorPlane, Vector3d normalToMirrorPlane)","summary":"Create mirror transformation matrix The mirror transform maps a point Q to Q - (2*(Q-P)oN)*N, where P = pointOnMirrorPlane and N = normalToMirrorPlane.","since":"5.0","parameters":[{"name":"pointOnMirrorPlane","summary":"Point on the mirror plane."},{"name":"normalToMirrorPlane","summary":"Normal vector to the mirror plane."}],"returns":"A transformation matrix which mirrors geometry in a specified plane."},{"signature":"static Transform Multiply(Transform a, Transform b)","summary":"Multiplies (combines) two transformations.  \\nThis is the same as the * operator between two transformations.","since":"5.0","parameters":[{"name":"a","summary":"First transformation."},{"name":"b","summary":"Second transformation."}],"returns":"A transformation matrix that combines the effect of both input transformations. The resulting Transform gives the same result as though you\'d first apply B then A."},{"signature":"static Transform PlanarProjection(Plane plane)","summary":"Constructs a projection transformation.","since":"5.0","parameters":[{"name":"plane","summary":"Plane onto which everything will be perpendicularly projected."}],"returns":"A transformation matrix which projects geometry onto a specified plane."},{"signature":"static Transform PlaneToPlane(Plane plane0, Plane plane1)","summary":"Create a rotation transformation that orients plane0 to plane1. If you want to orient objects from one plane to another, use this form of transformation.","since":"5.0","parameters":[{"name":"plane0","summary":"The plane to orient from."},{"name":"plane1","summary":"the plane to orient to."}],"returns":"The translation transformation if successful, Transform.Unset on failure."},{"signature":"static Transform ProjectAlong(Plane plane, Vector3d direction)","summary":"Construct a projection onto a plane along a specific direction.","since":"6.0","parameters":[{"name":"plane","summary":"Plane to project onto."},{"name":"direction","summary":"Projection direction, must not be parallel to the plane."}],"returns":"Projection transformation or identity transformation if projection could not be calculated."},{"signature":"static Transform Rotation(double sinAngle, double cosAngle, Vector3d rotationAxis, Point3d rotationCenter)","summary":"Constructs a new rotation transformation with specified angle, rotation center and rotation axis.","since":"5.0","parameters":[{"name":"sinAngle","summary":"Sin of the rotation angle."},{"name":"cosAngle","summary":"Cos of the rotation angle."},{"name":"rotationAxis","summary":"Axis direction of rotation."},{"name":"rotationCenter","summary":"Center point of rotation."}],"returns":"A transformation matrix which rotates geometry around an anchor point."},{"signature":"static Transform Rotation(double angleRadians, Point3d rotationCenter)","summary":"Constructs a new rotation transformation with specified angle and rotation center.","since":"5.0","parameters":[{"name":"angleRadians","summary":"Angle (in Radians) of the rotation."},{"name":"rotationCenter","summary":"Center point of rotation. Rotation axis is vertical."}],"returns":"A transformation matrix which rotates geometry around an anchor point."},{"signature":"static Transform Rotation(double angleRadians, Vector3d rotationAxis, Point3d rotationCenter)","summary":"Constructs a new rotation transformation with specified angle, rotation center and rotation axis.","since":"5.0","parameters":[{"name":"angleRadians","summary":"Angle (in Radians) of the rotation."},{"name":"rotationAxis","summary":"Axis direction of rotation operation."},{"name":"rotationCenter","summary":"Center point of rotation. Rotation axis is vertical."}],"returns":"A transformation matrix which rotates geometry around an anchor point."},{"signature":"static Transform Rotation(Vector3d startDirection, Vector3d endDirection, Point3d rotationCenter)","summary":"Constructs a new rotation transformation with start and end directions and rotation center.","since":"5.0","parameters":[{"name":"startDirection","summary":"A start direction."},{"name":"endDirection","summary":"An end direction."},{"name":"rotationCenter","summary":"A rotation center."}],"returns":"A transformation matrix which rotates geometry around an anchor point."},{"signature":"static Transform Rotation(Vector3d x0, Vector3d y0, Vector3d z0, Vector3d x1, Vector3d y1, Vector3d z1)","summary":"Constructs a transformation that maps X0 to X1, Y0 to Y1, Z0 to Z1.","since":"5.0","parameters":[{"name":"x0","summary":"First \\"from\\" vector."},{"name":"y0","summary":"Second \\"from\\" vector."},{"name":"z0","summary":"Third \\"from\\" vector."},{"name":"x1","summary":"First \\"to\\" vector."},{"name":"y1","summary":"Second \\"to\\" vector."},{"name":"z1","summary":"Third \\"to\\" vector."}],"returns":"A rotation transformation value."},{"signature":"static Transform RotationZYX(double yaw, double pitch, double roll)","summary":"Create rotation transformation From Tait-Byran angles (also loosely known as Euler angles).","since":"6.11","parameters":[{"name":"yaw","summary":"Angle, in radians, to rotate about the Z axis."},{"name":"pitch","summary":"Angle, in radians, to rotate about the Y axis."},{"name":"roll","summary":"Angle, in radians, to rotate about the X axis."}],"returns":"A transform matrix from Tait-Byran angles."},{"signature":"static Transform RotationZYZ(double alpha, double beta, double gamma)","summary":"Create rotation transformation From Euler angles.","since":"6.11","parameters":[{"name":"alpha","summary":"Angle, in radians, to rotate about the Z axis."},{"name":"beta","summary":"Angle, in radians, to rotate about the Y axis."},{"name":"gamma","summary":"Angle, in radians, to rotate about the X axis."}],"returns":"A transform matrix from Euler angles."},{"signature":"static Transform Scale(Plane plane, double xScaleFactor, double yScaleFactor, double zScaleFactor)","summary":"Constructs a new non-uniform scaling transformation with a specified scaling anchor point.","since":"5.0","parameters":[{"name":"plane","summary":"Defines the center and orientation of the scaling operation."},{"name":"xScaleFactor","summary":"Scaling factor along the anchor plane X-Axis direction."},{"name":"yScaleFactor","summary":"Scaling factor along the anchor plane Y-Axis direction."},{"name":"zScaleFactor","summary":"Scaling factor along the anchor plane Z-Axis direction."}],"returns":"A transformation matrix which scales geometry non-uniformly."},{"signature":"static Transform Scale(Point3d anchor, double scaleFactor)","summary":"Constructs a new uniform scaling transformation with a specified scaling anchor point.","since":"5.0","parameters":[{"name":"anchor","summary":"Defines the anchor point of the scaling operation."},{"name":"scaleFactor","summary":"Scaling factor in all directions."}],"returns":"A transform matrix which scales geometry uniformly around the anchor point."},{"signature":"static Transform Shear(Plane plane, Vector3d x, Vector3d y, Vector3d z)","summary":"Constructs a Shear transformation.","since":"5.0","parameters":[{"name":"plane","summary":"Base plane for shear."},{"name":"x","summary":"Shearing vector along plane x-axis."},{"name":"y","summary":"Shearing vector along plane y-axis."},{"name":"z","summary":"Shearing vector along plane z-axis."}],"returns":"A transformation matrix which shear geometry."},{"signature":"static Transform Translation(double dx, double dy, double dz)","summary":"Constructs a new translation (move) transformation. Right column is (dx, dy, dz, 1.0).","since":"5.0","parameters":[{"name":"dx","summary":"Distance to translate (move) geometry along the world X axis."},{"name":"dy","summary":"Distance to translate (move) geometry along the world Y axis."},{"name":"dz","summary":"Distance to translate (move) geometry along the world Z axis."}],"returns":"A transform matrix which moves geometry with the specified distances."},{"signature":"static Transform Translation(Vector3d motion)","summary":"Constructs a new translation (move) transformation.","since":"5.0","parameters":[{"name":"motion","summary":"Translation (motion) vector."}],"returns":"A transform matrix which moves geometry along the motion vector."},{"signature":"void Affineize()","summary":"Replaces the last row with (0 0 0 1), discarding any perspective part of this transform","since":"6.12"},{"signature":"Transform Clone()","summary":"Returns a deep copy of the transform. For languages that treat structures as value types, this can be accomplished by a simple assignment.","since":"6.0","returns":"A deep copy of this data structure."},{"signature":"int CompareTo(Transform other)","summary":"Compares this transform with another transform.  \\nM33 has highest value, then M32, etc..","since":"5.0","parameters":[{"name":"other","summary":"Another transform."}],"returns":"-1 if this < other; 0 if both are equal; 1 otherwise."},{"signature":"bool DecomposeAffine(out Transform linear, out Vector3d translation)","summary":"Decomposes an affine transformation. An affine transformation can be broken into a linear transformation and a translation. Note, a perspective transformation is not affine.","since":"6.12","parameters":[{"name":"linear","summary":"Linear transformation."},{"name":"translation","summary":"Translation vector."}],"returns":"True if successful decomposition."},{"signature":"bool DecomposeAffine(out Vector3d translation, out Transform linear)","summary":"Decomposes an affine transformation. An affine transformation can be broken into a linear transformation and a translation. Note, a perspective transformation is not affine.","since":"6.12","parameters":[{"name":"translation","summary":"Translation vector."},{"name":"linear","summary":"Linear transformation."}],"returns":"True if successful decomposition."},{"signature":"bool DecomposeAffine(out Vector3d translation, out Transform rotation, out Transform orthogonal, out Vector3d diagonal)","summary":"An affine transformation can be decomposed into a Symmetric, Rotation and Translation. Then the Symmetric component may be further decomposed as non-uniform scale in an orthonormal coordinate system.","since":"6.12","parameters":[{"name":"translation","summary":"Translation vector."},{"name":"rotation","summary":"Proper rotation transformation."},{"name":"orthogonal","summary":"Orthogonal basis."},{"name":"diagonal","summary":"Diagonal elements of a Diagonal transformation."}],"returns":"True if successful decomposition."},{"signature":"TransformRigidType DecomposeRigid(out Vector3d translation, out Transform rotation, double tolerance)","summary":"Decomposes a rigid transformation. The transformation must be affine.","since":"6.12","parameters":[{"name":"translation","summary":"Translation vector."},{"name":"rotation","summary":"Proper rotation transformation, where R*Transpose(R)=I and det(R)=1."},{"name":"tolerance","summary":"The evaluation tolerance."}],"returns":"The rigid type."},{"signature":"TransformSimilarityType DecomposeSimilarity(out Vector3d translation, out double dilation, out Transform rotation, double tolerance)","summary":"Decomposes a similarity transformation. The transformation must be affine. A similarity transformation can be broken into a sequence of a dilation, translation, rotation, and a reflection.","since":"6.12","parameters":[{"name":"translation","summary":"Translation vector."},{"name":"dilation","summary":"Dilation, where dilation lt; 0 if this is an orientation reversing similarity."},{"name":"rotation","summary":"A proper rotation transformation, where R*Transpose(R)=I and Determinant(R)=1."},{"name":"tolerance","summary":"The evaluation tolerance."}],"returns":"The similarity type."},{"signature":"bool DecomposeSymmetric(out Transform matrix, out Vector3d diagonal)","summary":"A Symmetric linear transformation can be decomposed A = Q * Diag * Q ^ T, where Diag is a diagonal transformation. Diag[i][i] is an eigenvalue of A and the i-th column of Q is a corresponding unit length eigenvector. Note, this transformation must be Linear and Symmetric.","since":"6.12","parameters":[{"name":"matrix","summary":"An orthonormal matrix of eigenvectors (Q)."},{"name":"diagonal","summary":"A vector of eigenvalues."}],"returns":"True if successful, False otherwise."},{"signature":"bool Equals(object obj)","summary":"Determines if another object is a transform and its value equals this transform value.","parameters":[{"name":"obj","summary":"Another object."}],"returns":"True if obj is a transform and has the same value as this transform; otherwise, false."},{"signature":"bool Equals(Transform other)","summary":"Determines if another transform equals this transform value.","since":"5.0","parameters":[{"name":"other","summary":"Another transform."}],"returns":"True if other has the same value as this transform; otherwise, false."},{"signature":"bool GetEulerZYZ(out double alpha, out double beta, out double gamma)","summary":"Find the Euler angles for a rotation transformation.","since":"6.11","parameters":[{"name":"alpha","summary":"Angle of rotation, in radians, about the Z axis."},{"name":"beta","summary":"Angle of rotation, in radians, about the Y axis."},{"name":"gamma","summary":"Angle of rotation, in radians, about the Z axis."}],"returns":"If true, then RotationZYZ(alpha, beta, gamma) = R_z(alpha) * R_y(beta) * R_z(gamma) where R_*(angle) is rotation of angle radians about the corresponding *-world coordinate axis. If false, then this is not a rotation."},{"signature":"int GetHashCode()","summary":"Gets a non-unique hashing code for this transform.","returns":"A number that can be used to hash this transform in a dictionary."},{"signature":"bool GetYawPitchRoll(out double yaw, out double pitch, out double roll)","summary":"Find the Tait-Byran angles (also loosely called Euler angles) for a rotation transformation.","since":"6.11","parameters":[{"name":"yaw","summary":"Angle of rotation, in radians, about the Z axis."},{"name":"pitch","summary":"Angle of rotation, in radians, about the Y axis."},{"name":"roll","summary":"Angle of rotation, in radians, about the X axis."}],"returns":"If true, then RotationZYX(yaw, pitch, roll) = R_z(yaw) * R_y(pitch) * R_x(roll) where R_*(angle) is rotation of angle radians about the corresponding world coordinate axis. If false, then this is not a rotation."},{"signature":"TransformRigidType IsRigid(double tolerance)","summary":"Gets a value indicating whether or not the Transform is rigid. A rigid transformation can be broken into  a proper rotation and a translation, while an isometry transformation could also include a reflection.","since":"6.12","parameters":[{"name":"tolerance","summary":"The evaluation tolerance."}],"returns":"The rigid type."},{"signature":"TransformSimilarityType IsSimilarity(double tolerance)","summary":"Gets a value indicating whether or not the Transform maintains similarity. A similarity transformation can be broken into a sequence of a dilation, translation, rotation, and a reflection.","since":"6.12","parameters":[{"name":"tolerance","summary":"The evaluation tolerance."}],"returns":"The similarity type."},{"signature":"bool IsZeroTransformaton(double zeroTolerance)","summary":"True if all values are 0 and M33 is 1 within tolerance.","since":"6.12","parameters":[{"name":"zeroTolerance","summary":"The zero tolerance."}],"returns":"Returns True if all values are 0 and M33 is 1 within tolerance."},{"signature":"void Linearize()","summary":"Affinitize() and replaces the last column with (0 0 0 1)^T, discarding any translation part of this transform.","since":"6.12"},{"signature":"bool Orthogonalize(double tolerance)","summary":"Force the linear part of this transformation to be a rotation (or a rotation with reflection). Use DecomposeRigid(T,R) to find the nearest rotation.","since":"6.12","parameters":[{"name":"tolerance","summary":"The evaluation tolerance"}],"returns":"True if successful, False otherwise."},{"signature":"float[] ToFloatArray(bool rowDominant)","summary":"Return the matrix as a linear array of 16 float values","since":"5.9"},{"signature":"string ToString()","summary":"Returns a string representation of this transform.","returns":"A textual representation."},{"signature":"BoundingBox TransformBoundingBox(BoundingBox bbox)","summary":"Computes a new bounding box that is the smallest axis aligned bounding box that contains the transformed result of its 8 original corner points.","since":"5.0","returns":"A new bounding box."},{"signature":"Point3d[] TransformList(IEnumerable<Point3d> points)","summary":"Given a list, an array or any enumerable set of points, computes a new array of transformed points.","since":"5.0","parameters":[{"name":"points","summary":"A list, an array or any enumerable set of points to be left untouched and copied."}],"returns":"A new array."},{"signature":"Transform Transpose()","summary":"Flip row/column values","since":"5.9"},{"signature":"bool TryGetInverse(out Transform inverseTransform)","summary":"Attempts to get the inverse transform of this transform.","since":"5.0","parameters":[{"name":"inverseTransform","summary":"The inverse transform. This out reference will be assigned during this call."}],"returns":"True on success. If False is returned and this Transform is Invalid, inserveTransform will be set to this Transform. If False is returned and this Transform is Valid, inverseTransform will be set to a pseudo inverse."}]},{"namespace":"Rhino.Geometry","name":"TransformRigidType","dataType":"enum","summary":"Lists all possible outcomes for rigid transformation.","since":"6.12","values":[{"signature":"RigidReversing = -1","summary":"Transformation is an orientation reversing isometry."},{"signature":"NotRigid = 0","summary":"Transformation is not an orthogonal transformation."},{"signature":"Rigid = 1","summary":"Transformation is an rigid transformation."}]},{"namespace":"Rhino.Geometry","name":"TransformSimilarityType","dataType":"enum","summary":"Lists all possible outcomes for transform similarity.","since":"5.0","values":[{"signature":"OrientationReversing = -1","summary":"Similarity is preserved, but orientation is flipped."},{"signature":"NotSimilarity = 0","summary":"Similarity is not preserved. Geometry needs to be deformable for this Transform to operate correctly."},{"signature":"OrientationPreserving = 1","summary":"Similarity and orientation are preserved."}]},{"namespace":"Rhino.Geometry","name":"Unroller","dataType":"class","summary":"Represents the operation of unrolling a single surface.","constructors":[{"signature":"Unroller(Brep brep)","summary":"Initializes a new instance of the Unrollerclass with a brep.","since":"5.0","parameters":[{"name":"brep","summary":"A brep to be unrolled."}]},{"signature":"Unroller(Surface surface)","summary":"Initializes a new instance of the Unrollerclass with surface.","since":"5.0","parameters":[{"name":"surface","summary":"A surface to be unrolled."}]}],"properties":[{"signature":"double AbsoluteTolerance","summary":"Gets or sets the absolute tolerance for the unrolling operation.  \\nAbsolute tolerance is used in the evaluation of new entities, such as intersections, re-projections and splits.  \\nIn the current implementation, absolute tolerance is used in tessellating rails, fitting curves and pulling back trims.","since":"5.0","property":["get","set"]},{"signature":"bool ExplodeOutput","summary":"Gets or sets a value determining whether geometry should be exploded.","since":"5.0","property":["get","set"]},{"signature":"double ExplodeSpacing","summary":"Gets or sets a value determining whether spacing should be exploded.","since":"5.0","property":["get","set"]},{"signature":"double RelativeTolerance","summary":"Gets or sets the relative tolerance for the unrolling operation.  \\nRelative tolerance is used in the evaluation of intrinsic properties, such as computations \\"along\\" the surface or brep.  \\nIn the current implementation, relative tolerance is used to decide if a surface is flat enough to try to unroll. That helps ease the scale dependency. The surface has to be linear in one direction within (length * RelativeTolerance) to be considered linear for that purpose. Otherwise smash will ignore that tolerance and unroll anything.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"void AddFollowingGeometry(Curve curve)","summary":"Adds a curve that should be unrolled along with the surface/brep.","since":"5.0","parameters":[{"name":"curve","summary":"The curve."}]},{"signature":"void AddFollowingGeometry(IEnumerable<Curve> curves)","summary":"Adds curves that should be unrolled along with the surface/brep.","since":"5.0","parameters":[{"name":"curves","summary":"An array, a list or any enumerable set of curves."}]},{"signature":"void AddFollowingGeometry(IEnumerable<Point3d> points)","summary":"Adds points that should be unrolled along with the surface/brep.","since":"5.0","parameters":[{"name":"points","summary":"An array, a list or any enumerable set of points."}]},{"signature":"void AddFollowingGeometry(IEnumerable<Point3d> dotLocations, IEnumerable<string> dotText)","summary":"Adds text dots that should be unrolled along with the surface/brep.","since":"5.0","parameters":[{"name":"dotLocations","summary":"An array, a list, or any enumerable set of dot locations."},{"name":"dotText","summary":"An array, a list, or any enumerable set of dot strings."}]},{"signature":"void AddFollowingGeometry(IEnumerable<TextDot> dots)","summary":"Adds text dots that should be unrolled along with the surface/brep.","since":"5.0","parameters":[{"name":"dots","summary":"An array, a list or any enumerable set of text dots."}]},{"signature":"void AddFollowingGeometry(Point point)","summary":"Adds a point that should be unrolled along with the surface/brep.","since":"5.0","parameters":[{"name":"point","summary":"A point."}]},{"signature":"void AddFollowingGeometry(Point3d point)","summary":"Adds a point that should be unrolled along with the surface/brep.","since":"5.0","parameters":[{"name":"point","summary":"A point."}]},{"signature":"void AddFollowingGeometry(Point3d dotLocation, string dotText)","summary":"Adds a text dot that should be unrolled along with the surface/brep.","since":"5.0","parameters":[{"name":"dotLocation","summary":"A dot point."},{"name":"dotText","summary":"A dot text."}]},{"signature":"void AddFollowingGeometry(TextDot dot)","summary":"Adds a text dot that should be unrolled along with the surface/brep.","since":"5.0","parameters":[{"name":"dot","summary":"A text dot."}]},{"signature":"int FollowingGeometryIndex(Curve curve)","summary":"Given an unrolled curve, returns the index of the source, or following curve.","since":"6.0","parameters":[{"name":"curve","summary":"An unrolled curve returned by Unroller.PerformUnroll."}],"returns":"The index of the curve added by Unroller.AddFollowingGeometry if successful, otherwise -1."},{"signature":"int FollowingGeometryIndex(TextDot dot)","summary":"Given an unrolled text dot, returns the index of the source, or following text dot.","since":"6.0","parameters":[{"name":"dot","summary":"An unrolled text dot returned by Unroller.PerformUnroll."}],"returns":"The index of the text dot added by Unroller.AddFollowingGeometry if successful, otherwise -1."},{"signature":"int PerformUnroll(List<Brep> flatbreps)","summary":"Executes unrolling operations.","since":"6.0","parameters":[{"name":"flatbreps","summary":"List of breps containing flattened results."}],"returns":"Number of breps in result"},{"signature":"Brep[] PerformUnroll(out Curve[] unrolledCurves, out Point3d[] unrolledPoints, out TextDot[] unrolledDots)","summary":"Executes unrolling operations.","since":"5.0","parameters":[{"name":"unrolledCurves","summary":"An array of unrolled curves is assigned during the call in this out parameter."},{"name":"unrolledPoints","summary":"An array of unrolled points is assigned during the call in this out parameter."},{"name":"unrolledDots","summary":"An array of unrolled text dots is assigned during the call in this out parameter."}],"returns":"An array of breps. This array can be empty."}]},{"namespace":"Rhino.Geometry","name":"Vector2d","dataType":"struct","summary":"Represents the two components of a vector in two-dimensional space, using double-precision floating point numbers.","constructors":[{"signature":"Vector2d(double x, double y)","summary":"Initializes a new instance of the vector based on two, X and Y, components.","since":"5.0","parameters":[{"name":"x","summary":"The X (first) component."},{"name":"y","summary":"The Y (second) component."}]}],"properties":[{"signature":"static Vector2d Unset","summary":"Gets the value of the vector with components set as RhinoMath.UnsetValue,RhinoMath.UnsetValue.","since":"5.0","property":["get"]},{"signature":"static Vector2d Zero","summary":"Gets the value of the vector with components 0,0.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Gets a value indicating whether this vector is valid. A valid vector must be formed of valid component values for x, y and z.","since":"5.7","property":["get"]},{"signature":"double Length","summary":"Computes the length (or magnitude, or size) of this vector. This is an application of Pythagoras\' theorem.","since":"5.0","property":["get"]},{"signature":"double SquareLength","summary":"Returns the square of the length of the vector.","since":"6.0","property":["get"]},{"signature":"double X","summary":"Gets or sets the X (first) component of this vector.","since":"5.0","property":["get","set"]},{"signature":"double Y","summary":"Gets or sets the Y (second) component of this vector.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static Vector2d Add(Vector2d vector1, Vector2d vector2)","summary":"Sums up two vectors.  \\n(Provided for languages that do not support operator overloading. You can use the + operator otherwise)","since":"6.0","parameters":[{"name":"vector1","summary":"A vector."},{"name":"vector2","summary":"A second vector."}],"returns":"A new vector that results from the component-wise addition of the two vectors."},{"signature":"static Vector2d Divide(Vector2d vector, double t)","summary":"Divides a Vector2dby a number, having the effect of shrinking it.  \\n(Provided for languages that do not support operator overloading. You can use the / operator otherwise)","since":"6.0","parameters":[{"name":"vector","summary":"A vector."},{"name":"t","summary":"A number."}],"returns":"A new vector that is component-wise divided by t."},{"signature":"static Vector2d Multiply(double t, Vector2d vector)","summary":"Multiplies a vector by a number, having the effect of scaling it.  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"6.0","parameters":[{"name":"t","summary":"A number."},{"name":"vector","summary":"A vector."}],"returns":"A new vector that is the original vector coordinate-wise multiplied by t."},{"signature":"static Vector2d Multiply(Vector2d vector, double t)","summary":"Multiplies a vector by a number, having the effect of scaling it.  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"6.0","parameters":[{"name":"vector","summary":"A vector."},{"name":"t","summary":"A number."}],"returns":"A new vector that is the original vector coordinate-wise multiplied by t."},{"signature":"static double Multiply(Vector2d vector1, Vector2d vector2)","summary":"Multiplies two vectors together, returning the dot product (or inner product).  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"6.0","parameters":[{"name":"vector1","summary":"A vector."},{"name":"vector2","summary":"A second vector."}],"returns":"A value that results from the evaluation of v1.X*v2.X + v1.Y*v2.Y.  \\nThis value equals v1.Length * v2.Length * cos(alpha), where alpha is the angle between vectors."},{"signature":"static Vector2d Negate(Vector2d vector)","summary":"Computes the reversed vector.  \\n(Provided for languages that do not support operator overloading. You can use the - unary operator otherwise)","since":"6.0","parameters":[{"name":"vector","summary":"A vector to negate."}],"returns":"A new vector where all components were multiplied by -1."},{"signature":"static Vector2d Subtract(Vector2d vector1, Vector2d vector2)","summary":"Subtracts the second vector from the first one.  \\n(Provided for languages that do not support operator overloading. You can use the - operator otherwise)","since":"6.0","parameters":[{"name":"vector1","summary":"A vector."},{"name":"vector2","summary":"A second vector."}],"returns":"A new vector that results from the component-wise difference of vector1 - vector2."},{"signature":"int CompareTo(Vector2d other)","summary":"Compares this Vector2dwith another Vector2d.  \\nComponents evaluation priority is first X, then Y.","since":"5.0","parameters":[{"name":"other","summary":"The other Vector2dto use in comparison."}],"returns":"0: if this is identical to other  \\n-1: if this.X < other.X  \\n-1: if this.X == other.X and this.Y < other.Y  \\n+1: otherwise."},{"signature":"bool EpsilonEquals(Vector2d other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(object obj)","summary":"Determines whether the specified System.Object is a Vector2d and has the same value as the present vector.","parameters":[{"name":"obj","summary":"The specified object."}],"returns":"True if obj is Vector2d and has the same components as this; otherwise false."},{"signature":"bool Equals(Vector2d vector)","summary":"Determines whether the specified vector has the same value as the present vector.","since":"5.0","parameters":[{"name":"vector","summary":"The specified vector."}],"returns":"True if vector has the same components as this; otherwise false."},{"signature":"int GetHashCode()","summary":"Provides a hashing value for the present vector.","returns":"A non-unique number based on vector components."},{"signature":"bool IsTiny()","summary":"Uses RhinoMath.ZeroTolerance for IsTiny calculation.","since":"6.0","returns":"True if vector is very small, otherwise false."},{"signature":"bool IsTiny(double tolerance)","summary":"Determines whether a vector is very short.","since":"6.0","parameters":[{"name":"tolerance","summary":"A nonzero value used as the coordinate zero tolerance. ."}],"returns":"(Math.Abs(X) <= tiny_tol) AND (Math.Abs(Y) <= tiny_tol) AND (Math.Abs(Z) <= tiny_tol)."},{"signature":"bool Rotate(double angleRadians)","summary":"Rotates this vector.","since":"6.0","parameters":[{"name":"angleRadians","summary":"Angle of rotation (in radians)."}],"returns":"True on success, False on failure."},{"signature":"string ToString()","summary":"Constructs a string representation of the current vector.","returns":"A string in the form X,Y."},{"signature":"string ToString(string format, IFormatProvider formatProvider)","since":"7.0"},{"signature":"bool Unitize()","summary":"Unitizes the vector in place. A unit vector has length 1 unit.  \\nAn invalid or zero length vector cannot be unitized.","since":"5.7","returns":"True on success or False on failure."}]},{"namespace":"Rhino.Geometry","name":"Vector2f","dataType":"struct","summary":"Represents the two components of a vector in two-dimensional space, using Single-precision floating point numbers.","constructors":[{"signature":"Vector2f(float x, float y)","summary":"Creates an instance.","since":"6.0","parameters":[{"name":"x","summary":"X component."},{"name":"y","summary":"Y component."}]}],"properties":[{"signature":"bool IsValid","summary":"Returns an indication regarding the validity of this vector.","since":"6.0","property":["get"]},{"signature":"float SquareLength","summary":"Returns the square of the length of this vector. This method does not check for the validity of its inputs.","since":"6.0","property":["get"]},{"signature":"float X","summary":"Gets or sets the X (first) component of this vector.","since":"5.0","property":["get","set"]},{"signature":"float Y","summary":"Gets or sets the Y (second) component of this vector.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static double Multiply(Vector2f point1, Vector2f point2)","summary":"Multiplies two Vector2ftogether, returning the dot (internal) product of the two.  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"6.0","parameters":[{"name":"point1","summary":"The first point."},{"name":"point2","summary":"The second point."}],"returns":"A value that results from the coordinate-wise multiplication of point1 and point2."},{"signature":"int CompareTo(Vector2f other)","summary":"Compares this Vector2fwith another Vector2f.  \\nComponents evaluation priority is first X, then Y.","since":"5.0","parameters":[{"name":"other","summary":"The other Vector2fto use in comparison."}],"returns":"0: if this is identical to other  \\n-1: if this.X < other.X  \\n-1: if this.X == other.X and this.Y < other.Y  \\n+1: otherwise."},{"signature":"bool EpsilonEquals(Vector2f other, float epsilon)","summary":"Check that all values in other are withing epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(object obj)","summary":"Determines whether the specified System.Object is a Vector2f and has the same values as the present vector.","parameters":[{"name":"obj","summary":"The specified object."}],"returns":"True if obj is Vector2f and has the same coordinates as this; otherwise false."},{"signature":"bool Equals(Vector2f vector)","summary":"Determines whether the specified vector has the same values as the present vector.","since":"5.0","parameters":[{"name":"vector","summary":"The specified vector."}],"returns":"True if obj is Vector2f and has the same coordinates as this; otherwise false."},{"signature":"int GetHashCode()","summary":"Computes a hash number that represents the current vector.","returns":"A hash code that is not unique for each vector."},{"signature":"string ToString()","summary":"Constructs the string representation of the current vector.","returns":"The vector representation in the form X,Y,Z."},{"signature":"string ToString(string format, IFormatProvider formatProvider)","since":"7.0"}]},{"namespace":"Rhino.Geometry","name":"Vector3d","dataType":"struct","summary":"Represents the three components of a vector in three-dimensional space, using double-precision floating point numbers.","constructors":[{"signature":"Vector3d(double x, double y, double z)","summary":"Initializes a new instance of a vector, using its three components.","since":"5.0","parameters":[{"name":"x","summary":"The X (first) component."},{"name":"y","summary":"The Y (second) component."},{"name":"z","summary":"The Z (third) component."}]},{"signature":"Vector3d(Point3d point)","summary":"Initializes a new instance of a vector, copying the three components from the three coordinates of a point.","since":"5.0","parameters":[{"name":"point","summary":"The point to copy from."}]},{"signature":"Vector3d(Vector3d vector)","summary":"Initializes a new instance of a vector, copying the three components from a vector.","since":"5.0","parameters":[{"name":"vector","summary":"A double-precision vector."}]},{"signature":"Vector3d(Vector3f vector)","summary":"Initializes a new instance of a vector, copying the three components from a single-precision vector.","since":"5.0","parameters":[{"name":"vector","summary":"A single-precision vector."}]}],"properties":[{"signature":"static Vector3d Unset","summary":"Gets the value of the vector with each component set to RhinoMath.UnsetValue.","since":"5.0","property":["get"]},{"signature":"static Vector3d XAxis","summary":"Gets the value of the vector with components 1,0,0.","since":"5.0","property":["get"]},{"signature":"static Vector3d YAxis","summary":"Gets the value of the vector with components 0,1,0.","since":"5.0","property":["get"]},{"signature":"static Vector3d ZAxis","summary":"Gets the value of the vector with components 0,0,1.","since":"5.0","property":["get"]},{"signature":"static Vector3d Zero","summary":"Gets the value of the vector with components 0,0,0.","since":"5.0","property":["get"]},{"signature":"bool IsUnitVector","summary":"Gets a value indicating whether or not this is a unit vector. A unit vector has length 1.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Gets a value indicating whether this vector is valid. A valid vector must be formed of valid component values for x, y and z.","since":"5.0","property":["get"]},{"signature":"bool IsZero","summary":"Gets a value indicating whether the X, Y, and Z values are all equal to 0.0.","since":"5.0","property":["get"]},{"signature":"double Length","summary":"Computes the length (or magnitude, or size) of this vector. This is an application of Pythagoras\' theorem. If this vector is invalid, its length is considered 0.","since":"5.0","property":["get"]},{"signature":"double MaximumCoordinate","summary":"Gets the largest (both positive and negative) component value in this vector.","since":"5.0","property":["get"]},{"signature":"double MinimumCoordinate","summary":"Gets the smallest (both positive and negative) component value in this vector.","since":"5.0","property":["get"]},{"signature":"double SquareLength","summary":"Computes the squared length (or magnitude, or size) of this vector. This is an application of Pythagoras\' theorem. While the Length property checks for input validity, this property does not. You should check validity in advance, if this vector can be invalid.","since":"5.0","property":["get"]},{"signature":"double X","summary":"Gets or sets the X (first) component of the vector.","since":"5.0","property":["get","set"]},{"signature":"double Y","summary":"Gets or sets the Y (second) component of the vector.","since":"5.0","property":["get","set"]},{"signature":"double Z","summary":"Gets or sets the Z (third) component of the vector.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static Vector3d Add(Vector3d vector1, Vector3d vector2)","summary":"Sums up two vectors.  \\n(Provided for languages that do not support operator overloading. You can use the + operator otherwise)","since":"5.0","parameters":[{"name":"vector1","summary":"A vector."},{"name":"vector2","summary":"A second vector."}],"returns":"A new vector that results from the component-wise addition of the two vectors."},{"signature":"static bool AreOrthogonal(Vector3d x, Vector3d y, Vector3d z)","summary":"Test whether three vectors describe an orthogonal axis system. All vectors must be mutually perpendicular this to be the case.","since":"6.7","parameters":[{"name":"x","summary":"X axis vector."},{"name":"y","summary":"Y axis vector."},{"name":"z","summary":"Z axis vector."}],"returns":"True if all vectors are non-zero and mutually perpendicular."},{"signature":"static bool AreOrthonormal(Vector3d x, Vector3d y, Vector3d z)","summary":"Test whether three vectors describe an orthogonal, unit axis system. All vectors must be mutually perpendicular and have unit length for this to be the case.","since":"6.7","parameters":[{"name":"x","summary":"X axis vector."},{"name":"y","summary":"Y axis vector."},{"name":"z","summary":"Z axis vector."}],"returns":"True if all vectors are non-zero and mutually perpendicular."},{"signature":"static bool AreRighthanded(Vector3d x, Vector3d y, Vector3d z)","summary":"Test whether three vectors describe a right-handed, orthogonal, unit axis system. The vectors must be orthonormal and follow the right-hand ordering; index-finger=x, middle-finger=y, thumb=z.","since":"6.7","parameters":[{"name":"x","summary":"X axis vector."},{"name":"y","summary":"Y axis vector."},{"name":"z","summary":"Z axis vector."}],"returns":"True if all vectors are non-zero and mutually perpendicular."},{"signature":"static Vector3d CrossProduct(Vector3d a, Vector3d b)","summary":"Computes the cross product (or vector product, or exterior product) of two vectors.  \\nThis operation is not commutative.","since":"5.0","parameters":[{"name":"a","summary":"First vector."},{"name":"b","summary":"Second vector."}],"returns":"A new vector that is perpendicular to both a and b,  \\nhas Length == a.Length * b.Length * sin(theta) where theta is the angle between a and b.  \\nThe resulting vector is oriented according to the right hand rule."},{"signature":"static Vector3d Divide(Vector3d vector, double t)","summary":"Divides a Vector3dby a number, having the effect of shrinking it.  \\n(Provided for languages that do not support operator overloading. You can use the / operator otherwise)","since":"5.0","parameters":[{"name":"vector","summary":"A vector."},{"name":"t","summary":"A number."}],"returns":"A new vector that is component-wise divided by t."},{"signature":"static Vector3d Multiply(double t, Vector3d vector)","summary":"Multiplies a vector by a number, having the effect of scaling it.  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"5.0","parameters":[{"name":"t","summary":"A number."},{"name":"vector","summary":"A vector."}],"returns":"A new vector that is the original vector coordinate-wise multiplied by t."},{"signature":"static Vector3d Multiply(Vector3d vector, double t)","summary":"Multiplies a vector by a number, having the effect of scaling it.  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"5.0","parameters":[{"name":"vector","summary":"A vector."},{"name":"t","summary":"A number."}],"returns":"A new vector that is the original vector coordinate-wise multiplied by t."},{"signature":"static double Multiply(Vector3d vector1, Vector3d vector2)","summary":"Multiplies two vectors together, returning the dot product (or inner product). This differs from the cross product.  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"5.0","parameters":[{"name":"vector1","summary":"A vector."},{"name":"vector2","summary":"A second vector."}],"returns":"A value that results from the evaluation of v1.X*v2.X + v1.Y*v2.Y + v1.Z*v2.Z.  \\nThis value equals v1.Length * v2.Length * cos(alpha), where alpha is the angle between vectors."},{"signature":"static Vector3d Negate(Vector3d vector)","summary":"Computes the reversed vector.  \\n(Provided for languages that do not support operator overloading. You can use the - unary operator otherwise)","since":"5.0","parameters":[{"name":"vector","summary":"A vector to negate."}],"returns":"A new vector where all components were multiplied by -1."},{"signature":"static Vector3d Subtract(Vector3d vector1, Vector3d vector2)","summary":"Subtracts the second vector from the first one.  \\n(Provided for languages that do not support operator overloading. You can use the - operator otherwise)","since":"5.0","parameters":[{"name":"vector1","summary":"A vector."},{"name":"vector2","summary":"A second vector."}],"returns":"A new vector that results from the component-wise difference of vector1 - vector2."},{"signature":"static double VectorAngle(Vector3d a, Vector3d b)","summary":"Compute the angle between two vectors.  \\nThis operation is commutative.","since":"5.0","parameters":[{"name":"a","summary":"First vector for angle."},{"name":"b","summary":"Second vector for angle."}],"returns":"If the input is valid, the angle (in radians) between a and b; RhinoMath.UnsetValue otherwise."},{"signature":"static double VectorAngle(Vector3d a, Vector3d b, Plane plane)","summary":"Computes the angle on a plane between two vectors.","since":"5.0","parameters":[{"name":"a","summary":"First vector."},{"name":"b","summary":"Second vector."},{"name":"plane","summary":"Two-dimensional plane on which to perform the angle measurement."}],"returns":"On success, the angle (in radians) between a and b as projected onto the plane; RhinoMath.UnsetValue on failure."},{"signature":"static double VectorAngle(Vector3d v1, Vector3d v2, Vector3d vNormal)","summary":"Computes the angle of v1, v2 with a normal vector.","since":"6.0","parameters":[{"name":"v1","summary":"First vector."},{"name":"v2","summary":"Second vector."},{"name":"vNormal","summary":"Normal vector."}],"returns":"On success, the angle (in radians) between a and b with respect of normal vector; RhinoMath.UnsetValue on failure."},{"signature":"int CompareTo(Vector3d other)","summary":"Compares this Vector3dwith another Vector3d.  \\nComponent evaluation priority is first X, then Y, then Z.","since":"5.0","parameters":[{"name":"other","summary":"The other Vector3dto use in comparison."}],"returns":"0: if this is identical to other  \\n-1: if this.X < other.X  \\n-1: if this.X == other.X and this.Y < other.Y  \\n-1: if this.X == other.X and this.Y == other.Y and this.Z < other.Z  \\n+1: otherwise."},{"signature":"bool EpsilonEquals(Vector3d other, double epsilon)","summary":"Check that all values in other are within epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(object obj)","summary":"Determines whether the specified System.Object is a Vector3d and has the same values as the present vector.","parameters":[{"name":"obj","summary":"The specified object."}],"returns":"True if obj is a Vector3d and has the same coordinates as this; otherwise false."},{"signature":"bool Equals(Vector3d vector)","summary":"Determines whether the specified vector has the same value as the present vector.","since":"5.0","parameters":[{"name":"vector","summary":"The specified vector."}],"returns":"True if vector has the same coordinates as this; otherwise false."},{"signature":"int GetHashCode()","summary":"Computes the hash code for the current vector.","returns":"A non-unique number that represents the components of this vector."},{"signature":"int IsParallelTo(Vector3d other)","summary":"Determines whether this vector is parallel to another vector, within one degree (within Pi / 180).","since":"5.0","parameters":[{"name":"other","summary":"Vector to use for comparison."}],"returns":"Parallel indicator:  \\n+1 = both vectors are parallel  \\n0 = vectors are not parallel, or at least one of the vectors is zero  \\n-1 = vectors are anti-parallel."},{"signature":"int IsParallelTo(Vector3d other, double angleTolerance)","summary":"Determines whether this vector is parallel to another vector, within a provided tolerance.","since":"5.0","parameters":[{"name":"other","summary":"Vector to use for comparison."},{"name":"angleTolerance","summary":"Angle tolerance (in radians)."}],"returns":"Parallel indicator:  \\n+1 = both vectors are parallel.  \\n0 = vectors are not parallel or at least one of the vectors is zero.  \\n-1 = vectors are anti-parallel."},{"signature":"bool IsPerpendicularTo(Vector3d other)","summary":"Test to see whether this vector is perpendicular to within one degree of another one.","since":"5.0","parameters":[{"name":"other","summary":"Vector to compare to."}],"returns":"True if both vectors are perpendicular, False if otherwise."},{"signature":"bool IsPerpendicularTo(Vector3d other, double angleTolerance)","summary":"Determines whether this vector is perpendicular to another vector, within a provided angle tolerance.","since":"5.0","parameters":[{"name":"other","summary":"Vector to use for comparison."},{"name":"angleTolerance","summary":"Angle tolerance (in radians)."}],"returns":"True if vectors form Pi-radians (90-degree) angles with each other; otherwise false."},{"signature":"bool IsTiny()","summary":"Uses RhinoMath.ZeroTolerance for IsTiny calculation.","since":"5.0","returns":"True if vector is very small, otherwise false."},{"signature":"bool IsTiny(double tolerance)","summary":"Determines whether a vector is very short.","since":"5.0","parameters":[{"name":"tolerance","summary":"A nonzero value used as the coordinate zero tolerance. ."}],"returns":"(Math.Abs(X) <= tiny_tol) AND (Math.Abs(Y) <= tiny_tol) AND (Math.Abs(Z) <= tiny_tol)."},{"signature":"bool PerpendicularTo(Vector3d other)","summary":"Sets this vector to be perpendicular to another vector. Result is not unitized.","since":"5.0","parameters":[{"name":"other","summary":"Vector to use as guide."}],"returns":"True on success, False if input vector is zero or invalid."},{"signature":"bool Reverse()","summary":"Reverses this vector in place (reverses the direction).  \\nIf this vector is Invalid, no changes will occur and False will be returned.","since":"5.0","returns":"True on success or False if the vector is invalid."},{"signature":"bool Rotate(double angleRadians, Vector3d rotationAxis)","summary":"Rotates this vector around a given axis.","since":"5.0","parameters":[{"name":"angleRadians","summary":"Angle of rotation (in radians)."},{"name":"rotationAxis","summary":"Axis of rotation."}],"returns":"True on success, False on failure."},{"signature":"string ToString()","summary":"Returns the string representation of the current vector, in the form X,Y,Z.","returns":"A string with the current location of the point."},{"signature":"string ToString(string format, IFormatProvider formatProvider)","since":"7.0"},{"signature":"void Transform(Transform transformation)","summary":"Transforms the vector in place.  \\nThe transformation matrix acts on the left of the vector; i.e.,  \\nresult = transformation*vector","since":"5.0","parameters":[{"name":"transformation","summary":"Transformation matrix to apply."}]},{"signature":"bool Unitize()","summary":"Unitizes the vector in place. A unit vector has length 1 unit.  \\nAn invalid or zero length vector cannot be unitized.","since":"5.0","returns":"True on success or False on failure."}]},{"namespace":"Rhino.Geometry","name":"Vector3f","dataType":"struct","summary":"Represents the three components of a vector in three-dimensional space, using Single-precision floating point numbers.","constructors":[{"signature":"Vector3f(float x, float y, float z)","summary":"Constructs a new vector from 3 single precision numbers.","since":"5.0","parameters":[{"name":"x","summary":"X component of vector."},{"name":"y","summary":"Y component of vector."},{"name":"z","summary":"Z component of vector."}]}],"properties":[{"signature":"static Vector3f Unset","summary":"Gets the value of the vector with each component set to RhinoMath.UnsetValue.","since":"5.0","property":["get"]},{"signature":"static Vector3f XAxis","summary":"Gets the value of the vector with components 1,0,0.","since":"5.0","property":["get"]},{"signature":"static Vector3f YAxis","summary":"Gets the value of the vector with components 0,1,0.","since":"5.0","property":["get"]},{"signature":"static Vector3f ZAxis","summary":"Gets the value of the vector with components 0,0,1.","since":"5.0","property":["get"]},{"signature":"static Vector3f Zero","summary":"Gets the value of the vector with components 0,0,0.","since":"5.0","property":["get"]},{"signature":"bool IsUnitVector","summary":"Gets a value indicating whether or not this is a unit vector. A unit vector has length 1.","since":"6.0","property":["get"]},{"signature":"bool IsValid","summary":"Returns an indication regarding the validity of this vector.","since":"6.0","property":["get"]},{"signature":"bool IsZero","summary":"Gets a value indicating whether the X, Y, and Z values are all equal to 0.0.","since":"6.0","property":["get"]},{"signature":"float Length","summary":"Computes the length (or magnitude, or size) of this vector. This is an application of Pythagoras\' theorem. If this vector is invalid, its length is considered 0.","since":"5.0","property":["get"]},{"signature":"float SquareLength","summary":"Returns the square length of the vector. This property does not check for the validity of the inputs.","since":"6.0","property":["get"]},{"signature":"float X","summary":"Gets or sets the X (first) component of this vector.","since":"5.0","property":["get","set"]},{"signature":"float Y","summary":"Gets or sets the Y (second) component of this vector.","since":"5.0","property":["get","set"]},{"signature":"float Z","summary":"Gets or sets the Z (third) component of this vector.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static Point3f Add(Point3f point, Vector3f vector)","summary":"Sums up a point and a vector, and returns a new point.  \\n(Provided for languages that do not support operator overloading. You can use the + operator otherwise)","since":"5.0","parameters":[{"name":"point","summary":"A point."},{"name":"vector","summary":"A vector."}],"returns":"A new point that results from the addition of point and vector."},{"signature":"static Vector3f Add(Vector3f vector1, Vector3f vector2)","summary":"Sums up two vectors.  \\n(Provided for languages that do not support operator overloading. You can use the + operator otherwise)","since":"6.0","parameters":[{"name":"vector1","summary":"A vector."},{"name":"vector2","summary":"A second vector."}],"returns":"A new vector that results from the component-wise addition of the two vectors."},{"signature":"static Vector3f CrossProduct(Vector3f a, Vector3f b)","summary":"Computes the cross product (or vector product, or exterior product) of two vectors.  \\nThis operation is not commutative.","since":"5.0","parameters":[{"name":"a","summary":"First vector."},{"name":"b","summary":"Second vector."}],"returns":"A new vector that is perpendicular to both a and b,  \\nhas Length == a.Length * b.Length and  \\nwith a result that is oriented following the right hand rule."},{"signature":"static Vector3f Divide(Vector3f vector, double t)","summary":"Divides a Vector3fby a number, having the effect of shrinking it, t times.  \\n(Provided for languages that do not support operator overloading. You can use the / operator otherwise)","since":"6.0","parameters":[{"name":"vector","summary":"A vector."},{"name":"t","summary":"A number."}],"returns":"A new vector that is component-wise divided by t."},{"signature":"static Vector3f Divide(Vector3f vector, float t)","summary":"Divides a Vector3fby a number, having the effect of shrinking it, t times.  \\n(Provided for languages that do not support operator overloading. You can use the / operator otherwise)","since":"6.0","parameters":[{"name":"vector","summary":"A vector."},{"name":"t","summary":"A number."}],"returns":"A new vector that is component-wise divided by t."},{"signature":"static Vector3f Multiply(float t, Vector3f vector)","summary":"Multiplies a vector by a number, having the effect of scaling it.  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"5.0","parameters":[{"name":"t","summary":"A number."},{"name":"vector","summary":"A vector."}],"returns":"A new vector that is the original vector coordinate-wise multiplied by t."},{"signature":"static Vector3f Multiply(Vector3f vector, float t)","summary":"Multiplies a vector by a number, having the effect of scaling it.  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"5.0","parameters":[{"name":"vector","summary":"A vector."},{"name":"t","summary":"A number."}],"returns":"A new vector that is the original vector coordinate-wise multiplied by t."},{"signature":"static double Multiply(Vector3f point1, Vector3f point2)","summary":"Multiplies two Vector3ftogether, returning the dot (internal) product of the two. This is not the cross product.  \\n(Provided for languages that do not support operator overloading. You can use the * operator otherwise)","since":"6.0","parameters":[{"name":"point1","summary":"The first point."},{"name":"point2","summary":"The second point."}],"returns":"A value that results from the coordinate-wise multiplication of point1 and point2."},{"signature":"static Vector3f Negate(Vector3f vector)","summary":"Computes the reversed vector.  \\n(Provided for languages that do not support operator overloading. You can use the - unary operator otherwise)","since":"6.0","parameters":[{"name":"vector","summary":"A vector to negate."}],"returns":"A new vector where all components were multiplied by -1."},{"signature":"static Vector3f Subtract(Vector3f vector1, Vector3f vector2)","summary":"Subtracts the second vector from the first one.  \\n(Provided for languages that do not support operator overloading. You can use the - operator otherwise)","since":"6.0","parameters":[{"name":"vector1","summary":"A vector."},{"name":"vector2","summary":"A second vector."}],"returns":"A new vector that results from the component-wise difference of vector1 - vector2."},{"signature":"int CompareTo(Vector3f other)","summary":"Compares this Vector3fwith another Vector3f.  \\nComponent evaluation priority is first X, then Y, then Z.","since":"5.0","parameters":[{"name":"other","summary":"The other Vector3fto use in comparison."}],"returns":"0: if this is identical to other  \\n-1: if this.X < other.X  \\n-1: if this.X == other.X and this.Y < other.Y  \\n-1: if this.X == other.X and this.Y == other.Y and this.Z < other.Z  \\n+1: otherwise."},{"signature":"bool EpsilonEquals(Vector3f other, float epsilon)","summary":"Check that all values in other are withing epsilon of the values in this","since":"5.4"},{"signature":"bool Equals(object obj)","summary":"Determines whether the specified System.Object is a Vector3f and has the same values as the present vector.","parameters":[{"name":"obj","summary":"The specified object."}],"returns":"True if obj is Vector3f and has the same components as this; otherwise false."},{"signature":"bool Equals(Vector3f vector)","summary":"Determines whether the specified vector has the same values as the present vector.","since":"5.0","parameters":[{"name":"vector","summary":"The specified vector."}],"returns":"True if vector has the same components as this; otherwise false."},{"signature":"int GetHashCode()","summary":"Computes a hash number that represents the current vector.","returns":"A hash code that is not unique for each vector."},{"signature":"bool PerpendicularTo(Vector3f other)","summary":"Sets this vector to be perpendicular to another vector. Result is not unitized.","since":"5.0","parameters":[{"name":"other","summary":"Vector to use as guide."}],"returns":"True on success, False if input vector is zero or invalid."},{"signature":"bool Reverse()","summary":"Reverses this vector in place (reverses the direction).  \\nIf this vector contains RhinoMath.UnsetValue, the reverse will also be invalid and False will be returned.","since":"5.0","returns":"True on success or False if the vector is invalid."},{"signature":"bool Rotate(double angleRadians, Vector3f rotationAxis)","summary":"Rotates this vector around a given axis.","since":"5.0","parameters":[{"name":"angleRadians","summary":"Angle of rotation (in radians)."},{"name":"rotationAxis","summary":"Axis of rotation."}],"returns":"True on success, False on failure."},{"signature":"string ToString()","summary":"Constructs the string representation of the current vector.","returns":"The vector representation in the form X,Y,Z."},{"signature":"string ToString(string format, IFormatProvider formatProvider)","since":"7.0"},{"signature":"void Transform(Transform transformation)","summary":"Transforms the vector in place.  \\nThe transformation matrix acts on the left of the vector; i.e.,  \\nresult = transformation*vector","since":"5.0","parameters":[{"name":"transformation","summary":"Transformation matrix to apply."}]},{"signature":"bool Unitize()","summary":"Unitizes the vector in place. A unit vector has length 1 unit.  \\nAn invalid or zero length vector cannot be unitized.","since":"5.0","returns":"True on success or False on failure."}]},{"namespace":"Rhino.Geometry","name":"VolumeMassProperties","dataType":"class","summary":"Contains static initialization methods and allows access to the computed metrics of volume, volume centroid and volume moments in in solid meshes, in solid surfaces and in solid (closed) boundary representations.","interfaces":["IDisposable"],"properties":[{"signature":"Point3d Centroid","summary":"Gets the volume centroid in the world coordinate system.","since":"5.0","property":["get"]},{"signature":"Vector3d CentroidCoordinatesMomentsOfInertia","summary":"Moments of inertia with respect to centroid coordinate system. X = integral of ((y-y0)^2 + (z-z0)^2) dm Y = integral of ((z-z0)^2 + (x-x0)^2) dm Z = integral of ((z-z0)^2 + (y-y0)^2) dm where (x0,y0,z0) = centroid.","since":"5.0","property":["get"]},{"signature":"Vector3d CentroidCoordinatesMomentsOfInertiaError","summary":"Uncertainty in centroid coordinates moments of inertia calculation.","since":"5.0","property":["get"]},{"signature":"Vector3d CentroidCoordinatesProductMoments","summary":"Product moments with respect to centroid coordinate system.","since":"6.26","property":["get"]},{"signature":"Vector3d CentroidCoordinatesProductMomentsError","summary":"Uncertainty in product moments with respect to centroid coordinate system.","since":"6.26","property":["get"]},{"signature":"Vector3d CentroidCoordinatesRadiiOfGyration","summary":"Radii of gyration with respect to centroid coordinate system. X = sqrt(integral of ((y-y0)^2 + (z-z0)^2) dm/M) Y = sqrt(integral of ((z-z0)^2 + (x-x0)^2) dm/M) Z = sqrt(integral of ((z-z0)^2 + (y-y0)^2) dm/M) where (x0,y0,z0) = centroid.","since":"5.0","property":["get"]},{"signature":"Vector3d CentroidCoordinatesSecondMoments","summary":"Second moments with respect to centroid coordinate system. X = integral of (x-x0)^2 dm Y = integral of (y-y0)^2 dm Z = integral of (z-z0)^2 dm where (x0,y0,z0) = centroid.","since":"5.0","property":["get"]},{"signature":"Vector3d CentroidCoordinatesSecondMomentsError","summary":"Uncertainty in centroid coordinates second moments calculation.","since":"5.0","property":["get"]},{"signature":"Vector3d CentroidError","summary":"Gets the uncertainty in the Centroid calculation.","since":"5.0","property":["get"]},{"signature":"double Volume","summary":"Gets the volume solution.","since":"5.0","property":["get"]},{"signature":"double VolumeError","summary":"Gets the uncertainty in the volume calculation.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesFirstMoments","summary":"Returns the world coordinate first moments if they were able to be calculated. X is integral of \\"x dm\\" over the volume Y is integral of \\"y dm\\" over the volume Z is integral of \\"z dm\\" over the volume.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesFirstMomentsError","summary":"Uncertainty in world coordinates first moments calculation.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesMomentsOfInertia","summary":"The moments of inertia about the world coordinate axes. X = integral of (y^2 + z^2) dm Y = integral of (z^2 + x^2) dm Z = integral of (z^2 + y^2) dm.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesMomentsOfInertiaError","summary":"Uncertainty in world coordinates moments of inertia calculation.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesProductMoments","summary":"Returns the world coordinate product moments if they were able to be calculated. X is integral of \\"xy dm\\" over the area Y is integral of \\"yz dm\\" over the area Z is integral of \\"zx dm\\" over the area.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesProductMomentsError","summary":"Uncertainty in world coordinates second moments calculation.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesRadiiOfGyration","summary":"Radii of gyration with respect to world coordinate system. X = sqrt(integral of (y^2 + z^2) dm/M) Y = sqrt(integral of (z^2 + x^2) dm/M) Z = sqrt(integral of (z^2 + y^2) dm/M)","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesSecondMoments","summary":"Returns the world coordinate first moments if they were able to be calculated. X is integral of \\"xx dm\\" over the area Y is integral of \\"yy dm\\" over the area Z is integral of \\"zz dm\\" over the area.","since":"5.0","property":["get"]},{"signature":"Vector3d WorldCoordinatesSecondMomentsError","summary":"Uncertainty in world coordinates second moments calculation.","since":"5.0","property":["get"]}],"methods":[{"signature":"static VolumeMassProperties Compute(Brep brep)","summary":"Compute the VolumeMassProperties for a single Brep.","since":"5.0","parameters":[{"name":"brep","summary":"Brep to measure."}],"returns":"The VolumeMassProperties for the given Brep or None on failure."},{"signature":"static VolumeMassProperties Compute(Brep brep, bool volume, bool firstMoments, bool secondMoments, bool productMoments)","summary":"Compute the VolumeMassProperties for a single Brep.","since":"6.3","parameters":[{"name":"brep","summary":"Brep to measure."},{"name":"volume","summary":"True to calculate volume."},{"name":"firstMoments","summary":"True to calculate volume first moments, volume, and volume centroid."},{"name":"secondMoments","summary":"True to calculate volume second moments."},{"name":"productMoments","summary":"True to calculate volume product moments."}],"returns":"The VolumeMassProperties for the given Brep or None on failure."},{"signature":"static VolumeMassProperties Compute(IEnumerable<GeometryBase> geometry)","summary":"Computes the VolumeMassProperties for a collection of geometric objects. At present only Breps, Surfaces, and Meshes are supported.","since":"6.3","parameters":[{"name":"geometry","summary":"Objects to include in the area computation."}],"returns":"The VolumeMassProperties for the entire collection or None on failure."},{"signature":"static VolumeMassProperties Compute(IEnumerable<GeometryBase> geometry, bool volume, bool firstMoments, bool secondMoments, bool productMoments)","summary":"Computes the VolumeMassProperties for a collection of geometric objects. At present only Breps, Surfaces, Meshes and Planar Closed Curves are supported.","since":"6.3","parameters":[{"name":"geometry","summary":"Objects to include in the area computation."},{"name":"volume","summary":"True to calculate volume."},{"name":"firstMoments","summary":"True to calculate volume first moments, volume, and volume centroid."},{"name":"secondMoments","summary":"True to calculate volume second moments."},{"name":"productMoments","summary":"True to calculate volume product moments."}],"returns":"The VolumeMassProperties for the entire collection or None on failure."},{"signature":"static VolumeMassProperties Compute(Mesh mesh)","summary":"Compute the VolumeMassProperties for a single Mesh.","since":"5.0","parameters":[{"name":"mesh","summary":"Mesh to measure."}],"returns":"The VolumeMassProperties for the given Mesh or None on failure."},{"signature":"static VolumeMassProperties Compute(Mesh mesh, bool volume, bool firstMoments, bool secondMoments, bool productMoments)","summary":"Compute the VolumeMassProperties for a single Mesh.","since":"6.3","parameters":[{"name":"mesh","summary":"Mesh to measure."},{"name":"volume","summary":"True to calculate volume."},{"name":"firstMoments","summary":"True to calculate volume first moments, volume, and volume centroid."},{"name":"secondMoments","summary":"True to calculate volume second moments."},{"name":"productMoments","summary":"True to calculate volume product moments."}],"returns":"The VolumeMassProperties for the given Mesh or None on failure."},{"signature":"static VolumeMassProperties Compute(Surface surface)","summary":"Compute the VolumeMassProperties for a single Surface.","since":"5.0","parameters":[{"name":"surface","summary":"Surface to measure."}],"returns":"The VolumeMassProperties for the given Surface or None on failure."},{"signature":"static VolumeMassProperties Compute(Surface surface, bool volume, bool firstMoments, bool secondMoments, bool productMoments)","summary":"Compute the VolumeMassProperties for a single Surface.","since":"6.3","parameters":[{"name":"surface","summary":"Surface to measure."},{"name":"volume","summary":"True to calculate volume."},{"name":"firstMoments","summary":"True to calculate volume first moments, volume, and volume centroid."},{"name":"secondMoments","summary":"True to calculate volume second moments."},{"name":"productMoments","summary":"True to calculate volume product moments."}],"returns":"The VolumeMassProperties for the given Surface or None on failure."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"bool Sum(VolumeMassProperties summand)","summary":"Sum mass properties together to get an aggregate mass.","since":"5.0","parameters":[{"name":"summand","summary":"mass properties to add."}],"returns":"True if successful."}]},{"namespace":"Rhino","name":"IEpsilonComparable","dataType":"interface","methods":[{"signature":"bool EpsilonEquals(T other, double epsilon)"}]},{"namespace":"Rhino","name":"IEpsilonFComparable","dataType":"interface","methods":[{"signature":"bool EpsilonEquals(T other, float epsilon)"}]},{"namespace":"Rhino","name":"IndexPair","dataType":"struct","summary":"Represents two indices: I and J.","constructors":[{"signature":"IndexPair(int i, int j)","summary":"Initializes a new instance of IndexPairwith two indices.","since":"5.0","parameters":[{"name":"i","summary":"A first index."},{"name":"j","summary":"A second index."}]}],"properties":[{"signature":"int Count","summary":"Returns the amount of elements in this pair of indices, which is always 2.","since":"6.0","property":["get"]},{"signature":"int I","summary":"Gets or sets the first, I index.","since":"5.0","property":["get","set"]},{"signature":"int J","summary":"Gets or sets the second, J index.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"bool Contains(int item)","summary":"Determines whether the IndexPaircontains a specific value.","since":"6.0","parameters":[{"name":"item","summary":"The number to locate in the IndexPair."}],"returns":"True ifis found in the IndexPair; otherwise, false."},{"signature":"void CopyTo(int[] array, int arrayIndex)","summary":"Copies the elements of the IndexPairto an T:System.Array, starting at a particular T:System.Arrayindex.","since":"6.0","parameters":[{"name":"array","summary":"The one-dimensional T:System.Arraythat is the destination of the elements copied from IndexPair. The T:System.Arraymust have zero-based indexing."},{"name":"arrayIndex","summary":"The zero-based index inat which copying begins."}]},{"signature":"IEnumerator<int> GetEnumerator()","summary":"Gets an enumerator that goes over Iand J, in this order.","since":"6.0","returns":"The needed enumerator."},{"signature":"int IndexOf(int item)","summary":"Determines the index of a specific item in IndexPair.","since":"6.0","parameters":[{"name":"item","summary":"The object to locate in the T:System.Collections.Generic.IList`1."}],"returns":"The index, 0 for I or 1 for J ofif found in the list; otherwise, -1."}]},{"namespace":"Rhino.Input.Custom","name":"CommandLineOption","dataType":"class","properties":[{"signature":"int CurrentListOptionIndex","since":"5.0","property":["get"]},{"signature":"string EnglishName","summary":"The English command option name","since":"5.0","property":["get"]},{"signature":"int Index","since":"5.0","property":["get"]},{"signature":"string LocalName","summary":"The localized command option name","since":"6.24","property":["get"]},{"signature":"string StringOptionValue","summary":"Assigned by RhinoGet.Get if an option value is specified in a script or by a command window control.","since":"6.24","property":["get"]}],"methods":[{"signature":"static bool IsValidOptionName(string optionName)","summary":"Test a string to see if it can be used as an option name in any of the RhinoGet::AddCommandOption...() functions.","since":"5.0","parameters":[{"name":"optionName","summary":"The string to be tested."}],"returns":"True if string can be used as an option name."},{"signature":"static bool IsValidOptionValueName(string optionValue)","summary":"Test a string to see if it can be used as an option value in RhinoGet::AddCommandOption, RhinoGet::AddCommandOptionToggle, or RhinoGet::AddCommandOptionList.","since":"5.0","parameters":[{"name":"optionValue","summary":"The string to be tested."}],"returns":"True if string can be used as an option value."}]},{"namespace":"Rhino.Input.Custom","name":"ConeConstraint","dataType":"enum","since":"6.0","values":[{"signature":"None = 0"},{"signature":"Vertical = 1"},{"signature":"AroundCurve = 2"}]},{"namespace":"Rhino.Input.Custom","name":"CylinderConstraint","dataType":"enum","since":"6.0","values":[{"signature":"None = 0"},{"signature":"Vertical = 1"},{"signature":"AroundCurve = 2"}]},{"namespace":"Rhino.Input.Custom","name":"GeometryAttributeFilter","dataType":"enum","summary":"If an object passes the geometry TYPE filter, then the geometry ATTRIBUTE filter is applied.","since":"5.0","values":[{"signature":"WireCurve = 1<<0","summary":"3d wire curve If you want to accept only wire or edge curves, then specify wire_curve or edge_curve, otherwise both wire and edge curves will pass the attribute filter."},{"signature":"EdgeCurve = 1 << 1","summary":"3d curve of a surface edge If you want to accept only wire or edge curves, then specify wire_curve or edge_curve, otherwise both wire and edge curves will pass the attribute filter."},{"signature":"ClosedCurve = 1<<2","summary":"Closed Curves and Edges are acceptable If you want to accept only closed or open curves, then specify either closed_curve or open_curve.  Otherwise both closed and open curves will pass the attribute filter."},{"signature":"OpenCurve = 1 << 3","summary":"Open Curves and Edges are acceptable If you want to accept only closed or open curves, then specify either closed_curve or open_curve.  Otherwise both closed and open curves will pass the attribute filter."},{"signature":"SeamEdge = 1<<4","summary":"seam edges are acceptable attributes of acceptable trimming edge objects (associated with an ON_BrepTrim).  If none of these attributes are explicitly specified, then any kind of trimming edge will pass the attribute filter."},{"signature":"ManifoldEdge = 1 << 5","summary":"edges with 2 different surfaces pass attributes of acceptable trimming edge objects (associated with an ON_BrepTrim).  If none of these attributes are explicitly specified, then any kind of trimming edge will pass the attribute filter."},{"signature":"NonmanifoldEdge = 1 << 6","summary":"edges with 3 or more surfaces pass attributes of acceptable trimming edge objects (associated with an ON_BrepTrim).  If none of these attributes are explicitly specified, then any kind of trimming edge will pass the attribute filter."},{"signature":"MatedEdge = (1 << 4) | (1 << 5) | (1 << 6)","summary":"any mated edge passes attributes of acceptable trimming edge objects (associated with an ON_BrepTrim).  If none of these attributes are explicitly specified, then any kind of trimming edge will pass the attribute filter."},{"signature":"SurfaceBoundaryEdge = 1 << 7","summary":"boundary edges on surface sides pass attributes of acceptable trimming edge objects (associated with an ON_BrepTrim).  If none of these attributes are explicitly specified, then any kind of trimming edge will pass the attribute filter."},{"signature":"TrimmingBoundaryEdge = 1 << 8","summary":"boundary edges that trim a surface pass attributes of acceptable trimming edge objects (associated with an ON_BrepTrim).  If none of these attributes are explicitly specified, then any kind of trimming edge will pass the attribute filter."},{"signature":"BoundaryEdge = (1 << 7) | (1 << 8)","summary":"ant boundary edge passes attributes of acceptable trimming edge objects (associated with an ON_BrepTrim).  If none of these attributes are explicitly specified, then any kind of trimming edge will pass the attribute filter."},{"signature":"ClosedSurface = 1 << 9","summary":"If you want to accept only closed or open surfaces, then specify either closed_surface or open_surface.  Otherwise both closed and open surfaces will pass the attribute filter."},{"signature":"OpenSurface = 1 << 10","summary":"If you want to accept only closed or open surfaces, then specify either closed_surface or open_surface.  Otherwise both closed and open surfaces will pass the attribute filter."},{"signature":"TrimmedSurface = 1 << 11","summary":"If you want to accept only trimmed or untrimmed surfaces, then specify either trimmed_surface or untrimmed_surface.  Otherwise both trimmed and untrimmed surfaces will pass the attribute filter."},{"signature":"UntrimmedSurface = 1 << 12","summary":"If you want to accept only trimmed or untrimmed surfaces, then specify either trimmed_surface or untrimmed_surface.  Otherwise both trimmed and untrimmed surfaces will pass the attribute filter."},{"signature":"SubSurface = 1 << 13","summary":"If you want to accept only sub-surfaces of (multi-surface) polysurface, then specify sub_surface.  If you do not want to accept sub-surfaces, then specify top_surface.  Otherwise sub-surfaces and top surfaces will pass the attribute filter."},{"signature":"TopSurface = 1 << 14","summary":"If you want to accept only sub-surfaces of (multi-surface) polysurface, then specify sub_surface.  If you do not want to accept sub-surfaces, then specify top_surface.  Otherwise sub-surfaces and top surfaces will pass the attribute filter."},{"signature":"ManifoldPolysrf = 1 << 15","summary":"If you want to accept only manifold or non-manifold polysurfaces, then specify manifold_polysrf or nonmanifold_polysrf. Otherwise both manifold and non-manifold polysurfaces will pass the attribute filter."},{"signature":"NonmanifoldPolysrf = 1 << 16","summary":"If you want to accept only manifold or non-manifold polysurfaces, then specify manifold_polysrf or nonmanifold_polysrf. Otherwise both manifold and non-manifold polysurfaces will pass the attribute filter."},{"signature":"ClosedPolysrf = 1 << 17","summary":"If you want to accept only closed or open polysurfaces, then specify either closed_polysrf or open_polysrf.  Otherwise both closed and open polysurfaces will pass the attribute filter."},{"signature":"OpenPolysrf = 1 << 18","summary":"If you want to accept only closed or open polysurfaces, then specify either closed_polysrf or open_polysrf.  Otherwise both closed and open polysurfaces will pass the attribute filter."},{"signature":"ClosedMesh = 1 << 19","summary":"If you want to accept only closed or open meshes, then specify either closed_mesh or open_mesh.  Otherwise both closed and open meshes will pass the attribute filter."},{"signature":"OpenMesh = 1 << 20","summary":"If you want to accept only closed or open meshes, then specify either closed_mesh or open_mesh.  Otherwise both closed and open meshes will pass the attribute filter."},{"signature":"BoundaryInnerLoop = 1 << 21","summary":"all trimming edges are boundary edges."},{"signature":"MatedInnerLoop = 1 << 22","summary":"all trimming edges are mated."},{"signature":"InnerLoop = (1 << 21) | (1 << 22)","summary":"any inner loop is acceptable."},{"signature":"BoundaryOuterLoop = 1 << 23","summary":"all trimming edges are boundary edges."},{"signature":"MatedOuterLoop = 1 << 24","summary":"all trimming edges are mated."},{"signature":"OuterLoop = (1 << 23) | (1 << 24)","summary":"any outer loop is acceptable."},{"signature":"SpecialLoop = (1 << 25)","summary":"slit, curve-on-surface, point-on-surface, etc."},{"signature":"AcceptAllAttributes = 0xffffffff"}]},{"namespace":"Rhino.Input.Custom","name":"GetArc","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"GetArc()","since":"6.0"}],"properties":[{"signature":"bool AllowDeformable","summary":"Allow for deformable options","since":"6.0","property":["get","set"]},{"signature":"double DefaultRadius","summary":"Default radius used for start and end radius","since":"6.0","property":["get","set"]},{"signature":"bool Deformable","summary":"Is the deformable option set","since":"6.0","property":["get","set"]},{"signature":"int DeformableDegree","since":"6.0","property":["get","set"]},{"signature":"int DeformablePointCount","since":"6.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"},{"signature":"Commands.Result Get(out Arc arc)","summary":"Perform the \'get\' operation.","since":"6.0"}]},{"namespace":"Rhino.Input.Custom","name":"GetBaseClass","dataType":"class","summary":"Base class for GetObject, GetPoint, GetSphere, etc.  You will never directly create a GetBaseClass but you will use its member functions after calling GetObject.Gets(), GetPoint.Get(), and so on.  Provides tools to set command prompt, set command options, and specify if the \\"get\\" can optionally accept numbers, nothing (pressing enter), and undo.","interfaces":["IDisposable"],"methods":[{"signature":"static void PostCustomMessage(object messageData)","since":"5.0"},{"signature":"void AcceptColor(bool enable)","summary":"If you want to allow the user to be able to type in a color r,g,b or name during GetPoint.Get(), GetObject::GetObjects(), etc., then call AcceptColor(true) before calling GetPoint()/GetObject(). If the user chooses to type in a color, then the result code GetResult.Color is returned and you can use RhinoGet.Color() to get the value of the color.  If the get accepts points, then the user will not be able to type in r,g,b colors but will be able to type color names.","since":"5.0","parameters":[{"name":"enable","summary":"True if user is able to type a color."}]},{"signature":"void AcceptCustomMessage(bool enable)","since":"5.0"},{"signature":"void AcceptEnterWhenDone(bool enable)","summary":"There are instances of RhinoGet that prompt with \\"Press Enter when Done.\\" yet do not call AcceptNothing(). On the Mac, these instances need an additional call to AcceptEnterWhenDone() so the GetPointOptions dialog can correctly enable the Done button.","since":"6.0"},{"signature":"void AcceptNothing(bool enable)","summary":"If you want to allow the user to be able to press enter in order to skip selecting a something in GetPoint.Get(), GetObject::GetObjects(), etc., then call AcceptNothing( True ) beforehand.","since":"5.0","parameters":[{"name":"enable","summary":"True if user is able to press enter in order to skip selecting."}]},{"signature":"void AcceptNumber(bool enable, bool acceptZero)","summary":"If you want to allow the user to be able to type in a number during GetPoint.Get(), GetObject::GetObjects(), etc., then call AcceptNumber() beforehand. If the user chooses to type in a number, then the result code GetResult.Number is returned and you can use RhinoGet.Number() to get the value of the number. If you are using GetPoint and you want \\"0\\" to return (0,0,0) instead of the number zero, then set acceptZero = false.","since":"5.0","parameters":[{"name":"enable","summary":"True if user is able to type a number."},{"name":"acceptZero","summary":"If you are using GetPoint and you want \\"0\\" to return (0,0,0) instead of the number zero, then set acceptZero = false."}]},{"signature":"void AcceptPoint(bool enable)","summary":"If you want to allow the user to be able to type in a point then call AcceptPoint(true) before calling GetPoint()/GetObject(). If the user chooses to type in a number, then the result code GetResult.Point is returned and you can use RhinoGet.Point() to get the value of the point.","since":"5.0","parameters":[{"name":"enable","summary":"True if user is able to type in a point."}]},{"signature":"void AcceptString(bool enable)","summary":"If you want to allow the user to be able to type in a string during GetPoint.Get(), GetObject::GetObjects(), etc., then call AcceptString(true) before calling GetPoint()/GetObject(). If the user chooses to type in a string, then the result code GetResult.String is returned and you can use RhinoGet.String() to get the value of the string.","since":"5.0","parameters":[{"name":"enable","summary":"True if user is able to type a string."}]},{"signature":"void AcceptUndo(bool enable)","summary":"If you want to allow the user to have an \'undo\' option in GetPoint.Get(), GetObject.GetObjects(), etc., then call AcceptUndo(true) beforehand.","since":"5.0","parameters":[{"name":"enable","summary":"True if user is able to choose the \'Undo\' option."}]},{"signature":"int AddOption(LocalizeStringPair optionName)","summary":"Adds a command line option.","since":"5.0","parameters":[{"name":"optionName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOption(LocalizeStringPair optionName, LocalizeStringPair optionValue)","summary":"Adds a command line option.","since":"5.0","parameters":[{"name":"optionName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)."},{"name":"optionValue","summary":"The localized value visualized after an equality sign."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOption(LocalizeStringPair optionName, LocalizeStringPair optionValue, bool hiddenOption)","summary":"Adds a command line option.","since":"6.9","parameters":[{"name":"optionName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)."},{"name":"optionValue","summary":"The localized value visualized after an equality sign."},{"name":"hiddenOption","summary":"If true, the option is not displayed on the command line and the full option name must be typed in order to activate the option."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOption(string englishOption)","summary":"Adds a command line option.","since":"5.0","parameters":[{"name":"englishOption","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOption(string englishOption, string englishOptionValue)","summary":"Adds a command line option.","since":"5.0","parameters":[{"name":"englishOption","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)."},{"name":"englishOptionValue","summary":"The option value in English, visualized after an equality sign."}],"returns":"Option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOption(string englishOption, string englishOptionValue, bool hiddenOption)","summary":"Adds a command line option.","since":"6.9","parameters":[{"name":"englishOption","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)."},{"name":"englishOptionValue","summary":"The option value in English, visualized after an equality sign."},{"name":"hiddenOption","summary":"If true, the option is not displayed on the command line and the full option name must be typed in order to activate the option."}],"returns":"Option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionColor(LocalizeStringPair optionName, ref OptionColor colorValue)","summary":"Add a command line option to get colors and automatically save the value.","since":"5.0","parameters":[{"name":"optionName","summary":"option description"},{"name":"colorValue","summary":"The current color value."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionColor(LocalizeStringPair optionName, ref OptionColor colorValue, string prompt)","summary":"Add a command line option to get colors and automatically save the value.","since":"5.0","parameters":[{"name":"optionName","summary":"option description."},{"name":"colorValue","summary":"The current color value."},{"name":"prompt","summary":"option prompt shown if the user selects this option"}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionColor(string englishName, ref OptionColor colorValue)","summary":"Add a command line option to get colors and automatically save the value.","since":"5.0","parameters":[{"name":"englishName","summary":"option description"},{"name":"colorValue","summary":"The current color value."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionColor(string englishName, ref OptionColor colorValue, string prompt)","summary":"Add a command line option to get colors and automatically save the value.","since":"5.0","parameters":[{"name":"englishName","summary":"option description"},{"name":"colorValue","summary":"The current color value."},{"name":"prompt","summary":"The command prompt will show this during picking."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionDouble(LocalizeStringPair optionName, ref OptionDouble numberValue)","summary":"Adds a command line option to get numbers and automatically save the value.","since":"5.0","parameters":[{"name":"optionName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)"},{"name":"numberValue","summary":"The current number value."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionDouble(LocalizeStringPair optionName, ref OptionDouble numberValue, string prompt)","summary":"Adds a command line option to get numbers and automatically saves the value.","since":"5.0","parameters":[{"name":"optionName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)"},{"name":"numberValue","summary":"The current number value."},{"name":"prompt","summary":"option prompt shown if the user selects this option.  If None or empty, then the option name is used as the get number prompt."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionDouble(string englishName, ref OptionDouble numberValue)","summary":"Adds a command line option to get numbers and automatically save the value.","since":"5.0","parameters":[{"name":"englishName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)"},{"name":"numberValue","summary":"The current number value."}],"returns":"Option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionDouble(string englishName, ref OptionDouble numberValue, string prompt)","summary":"Adds a command line option to get numbers and automatically save the value.","since":"5.0","parameters":[{"name":"englishName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)"},{"name":"numberValue","summary":"Current value."},{"name":"prompt","summary":"option prompt shown if the user selects this option.  If None or empty, then the option name is used as the get number prompt."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionEnumList(string englishOptionName, T defaultValue)","summary":"Adds a choice of enumerated values as list option","since":"5.4","parameters":[{"name":"englishOptionName","summary":"The name of the option"},{"name":"defaultValue","summary":"The default value"}],"returns":"Option index"},{"signature":"int AddOptionEnumList(string englishOptionName, T defaultValue, T[] include)","summary":"Adds a choice of enumerated values as list option. Allows to include only some enumerated values.","since":"6.0","parameters":[{"name":"englishOptionName","summary":"The name of the option"},{"name":"defaultValue","summary":"The default value"},{"name":"include","summary":"An array of enumerated values to use. This argument can also be null; in this case, the whole enumerated is used."}],"returns":"Option index"},{"signature":"int AddOptionEnumSelectionList(string englishOptionName, IEnumerable<T> enumSelection, int listCurrentIndex)","summary":"Adds a list of enumerated values as option list. Use enumSelection[go.Option.CurrentListOptionIndex] to retrieve selection.","since":"5.4"},{"signature":"int AddOptionInteger(LocalizeStringPair optionName, ref OptionInteger intValue)","summary":"Adds a command line option to get integers and automatically save the value.","since":"5.0","parameters":[{"name":"optionName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)"},{"name":"intValue","summary":"The current integer value."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionInteger(LocalizeStringPair optionName, ref OptionInteger intValue, string prompt)","summary":"Adds a command line option to get integers and automatically save the value.","since":"5.0","parameters":[{"name":"optionName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)"},{"name":"intValue","summary":"The current integer value."},{"name":"prompt","summary":"option prompt shown if the user selects this option.  If None or empty, then the option name is used as the get number prompt."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionInteger(string englishName, ref OptionInteger intValue)","summary":"Adds a command line option to get integers and automatically save the value.","since":"5.0","parameters":[{"name":"englishName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)"},{"name":"intValue","summary":"The current integer value."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionInteger(string englishName, ref OptionInteger intValue, string prompt)","summary":"Adds a command line option to get integers and automatically save the value.","since":"5.0","parameters":[{"name":"englishName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)"},{"name":"intValue","summary":"The current integer value."},{"name":"prompt","summary":"option prompt shown if the user selects this option.  If None or empty, then the option name is used as the get number prompt."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionList(LocalizeStringPair optionName, IEnumerable<LocalizeStringPair> listValues, int listCurrentIndex)","summary":"Adds a command line list option.","since":"5.0","parameters":[{"name":"optionName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)"},{"name":"listValues","summary":"The string values."},{"name":"listCurrentIndex","summary":"Zero based index of current option."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionList(string englishOptionName, IEnumerable<string> listValues, int listCurrentIndex)","summary":"Adds a command line list option.","since":"5.0","parameters":[{"name":"englishOptionName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)"},{"name":"listValues","summary":"The string values."},{"name":"listCurrentIndex","summary":"Zero based index of current option."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionToggle(LocalizeStringPair optionName, ref OptionToggle toggleValue)","summary":"Adds a command line option to toggle a setting.","since":"5.0","parameters":[{"name":"optionName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)"},{"name":"toggleValue","summary":"The current toggle value."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"int AddOptionToggle(string englishName, ref OptionToggle toggleValue)","summary":"Adds a command line option to toggle a setting.","since":"5.0","parameters":[{"name":"englishName","summary":"Must only consist of letters and numbers (no characters list periods, spaces, or dashes)"},{"name":"toggleValue","summary":"The current toggle value."}],"returns":"option index value (>0) or 0 if option cannot be added."},{"signature":"void ClearCommandOptions()","summary":"Clear all command options.","since":"5.0"},{"signature":"void ClearDefault()","summary":"Clears any defaults set using SetDefaultPoint, SetDefaultNumber, SetDefaultString, or SetCommandPromptDefault.","since":"5.0"},{"signature":"Color Color()","summary":"Gets a color if Get*() returns GetResult.Color.","since":"5.0","returns":"The color chosen by the user."},{"signature":"Result CommandResult()","summary":"Helper method for getting command result value from getter results.","since":"5.0","returns":"The converted command result."},{"signature":"object CustomMessage()","since":"5.0"},{"signature":"void Dispose()","since":"5.0"},{"signature":"void EnableTransparentCommands(bool enable)","summary":"Control the availability of transparent commands during the get.","since":"5.0","parameters":[{"name":"enable","summary":"If true, then transparent commands can be run during the get. If false, then transparent commands cannot be run during the get."}]},{"signature":"T GetSelectedEnumValue()","summary":"Returns the selected enumerated value. Use this in combination with AddOptionEnumList{T}(string, T).  \\nThis must be called directly after having called a Get method, and having obtained a  value.","since":"5.4"},{"signature":"T GetSelectedEnumValueFromSelectionList(IEnumerable<T> selectionList)","summary":"Returns the selected enumerated value by looking at the list of values from which to select. Use this in combination with AddOptionEnumSelectionList{T}","since":"5.4"},{"signature":"bool GotDefault()","summary":"Returns True if user pressed Enter to accept a default point, number, or string set using SetDefaultPoint, SetDefaultNumber, or SetDefaultString.","since":"5.0","returns":"True if the result if the default point, number or string set. Otherwise, false."},{"signature":"System.Drawing.Point[] Line2d()","summary":"Returns two points defining the location in the view window of the 2d line selected in GetPoint::Get2dLine().  \\n(0,0) = upper left corner of window.","since":"5.0","returns":"An array with two 2D points."},{"signature":"double Number()","summary":"Gets a number if GetPoint.Get(), GetObject.GetObjects(), etc., returns GetResult.Number.","since":"5.0","returns":"The number chosen by the user."},{"signature":"CommandLineOption Option()","since":"5.0"},{"signature":"int OptionIndex()","since":"5.0"},{"signature":"Rectangle PickRectangle()","summary":"If the get was a GetObjects() and the mouse was used to select the objects, then the returned rectangle has left < right and top < bottom. This rectangle is the Windows GDI screen coordinates of the picking rectangle. RhinoViewport.GetPickXform( pick_rect, pick_xform ) will calculate the picking transformation that was used. In all other cases, left=right=top=bottom=0;","since":"5.0","returns":"The picking rectangle; or 0 in the specified cases."},{"signature":"Point3d Point()","summary":"Gets a point if Get*() returns GetResult.Point.","since":"5.0","returns":"The point chosen by the user."},{"signature":"System.Drawing.Point Point2d()","summary":"Returns location in view of point in selected in GetPoint::Get() or GetPoint::Get2dPoint(). (0,0) = upper left corner of window.","since":"5.0","returns":"The location."},{"signature":"Rectangle Rectangle2d()","summary":"Returns the location in the view of the 2d rectangle selected in GetPoint::Get2dRectangle(). rect.left < rect.right and rect.top < rect.bottom (0,0) = upper left corner of window.","since":"5.0","returns":"The rectangle."},{"signature":"GetResult Result()","summary":"Returns result of the Get*() call.","since":"5.0","returns":"The result of the last Get*() call."},{"signature":"void SetCommandPrompt(string prompt)","summary":"Sets prompt message that appears in the command prompt window.","since":"5.0","parameters":[{"name":"prompt","summary":"command prompt message."}]},{"signature":"void SetCommandPromptDefault(string defaultValue)","summary":"Sets message that describes what default value will be used if the user presses enter. This description appears in angle brackets <> in the command prompt window. You do not need to provide a default value description unless you explicitly enable AcceptNothing.","since":"5.0","parameters":[{"name":"defaultValue","summary":"description of default value."}]},{"signature":"void SetDefaultColor(Color defaultColor)","summary":"Sets a color as default value that will be returned if the user presses ENTER key during the get.","since":"5.0","parameters":[{"name":"defaultColor","summary":"value for default color."}]},{"signature":"void SetDefaultInteger(int defaultValue)","summary":"Sets a number as default value that will be returned if the user presses ENTER key during the get.","since":"5.0","parameters":[{"name":"defaultValue","summary":"value for default number."}]},{"signature":"void SetDefaultNumber(double defaultNumber)","summary":"Sets a number as default value that will be returned if the user presses ENTER key during the get.","since":"5.0","parameters":[{"name":"defaultNumber","summary":"value for default number."}]},{"signature":"void SetDefaultPoint(Point3d point)","summary":"Sets a point as default value that will be returned if the user presses the ENTER key during the get.","since":"5.0","parameters":[{"name":"point","summary":"value for default point."}]},{"signature":"void SetDefaultString(string defaultValue)","summary":"Sets a string as default value that will be returned if the user presses ENTER key during the get.","since":"5.0","parameters":[{"name":"defaultValue","summary":"value for default string."}]},{"signature":"void SetWaitDuration(int milliseconds)","summary":"Sets the wait duration (in milliseconds) of the getter. If the duration passes without the user making a decision, the GetResult.Timeout code is returned.","since":"5.0","parameters":[{"name":"milliseconds","summary":"Number of milliseconds to wait."}]},{"signature":"string StringResult()","summary":"Gets a string if GetPoint.Get(), GetObject.GetObjects(), etc., returns GetResult.String.","since":"5.0","returns":"The string chosen by the user."},{"signature":"Vector3d Vector()","summary":"Gets a direction if Get*() returns GetResult.Point (Set by some digitizers, but in general it\'s (0,0,0).","since":"5.0","returns":"The vector chosen by the user."},{"signature":"RhinoView View()","summary":"Gets a view the user clicked in during GetPoint.Get(), GetObject.GetObjects(), etc.","since":"5.0","returns":"The view chosen by the user."}]},{"namespace":"Rhino.Input.Custom","name":"GetCancel","dataType":"class","baseclass":"Rhino.Input.Custom.GetBaseClass","constructors":[{"signature":"GetCancel()","since":"6.0"}],"properties":[{"signature":"IProgress<double> Progress","since":"6.0","property":["get"]},{"signature":"string ProgressMessage","since":"6.0","property":["get","set"]},{"signature":"bool ProgressReporting","since":"6.0","property":["get","set"]},{"signature":"CancellationToken Token","since":"6.0","property":["get"]}],"methods":[{"signature":"Result Wait(Task task, RhinoDoc doc)","summary":"Awaits a particular task to finish.","since":"7.0","parameters":[{"name":"task","summary":"The task."},{"name":"doc","summary":"A document to set progress reporting."}],"returns":"A result enumeration."},{"signature":"Result Wait(Task<TResult> task, RhinoDoc doc)","summary":"Awaits a particular task to finish.","since":"6.0","parameters":[{"name":"task","summary":"The task."},{"name":"doc","summary":"A document to set progress reporting."}],"returns":"A result enumeration."},{"signature":"Result WaitAll(IEnumerable<Task<TResult>> tasks, RhinoDoc doc)","summary":"Awaits some tasks to finish.","parameters":[{"name":"tasks","summary":"The tasks."},{"name":"doc","summary":"A document to set progress reporting."}],"returns":"A result enumeration."},{"signature":"Result WaitAll(IEnumerable<Task> tasks, RhinoDoc doc)","summary":"Awaits some tasks to finish.","since":"7.0","parameters":[{"name":"tasks","summary":"The tasks."},{"name":"doc","summary":"A document to set progress reporting."}],"returns":"A result enumeration."}]},{"namespace":"Rhino.Input.Custom","name":"GetCircle","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"GetCircle()","since":"6.0"}],"properties":[{"signature":"bool AllowDeformable","summary":"Allow for deformable options","since":"6.0","property":["get","set"]},{"signature":"double DefaultSize","summary":"Default radius or diameter (based on InDiameterMode)","since":"6.0","property":["get","set"]},{"signature":"bool Deformable","summary":"Is the deformable option set","since":"6.0","property":["get","set"]},{"signature":"int DeformableDegree","since":"6.0","property":["get","set"]},{"signature":"int DeformablePointCount","since":"6.0","property":["get","set"]},{"signature":"bool InDiameterMode","summary":"Determines if the \\"size\\" value is representing a radius or diameter","since":"6.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"},{"signature":"Commands.Result Get(out Circle circle)","summary":"Perform the \'get\' operation.","since":"6.0"}]},{"namespace":"Rhino.Input.Custom","name":"GetCone","dataType":"class","summary":"Class provides user interface to define a cone.","interfaces":["IDisposable"],"constructors":[{"signature":"GetCone()","since":"6.0"}],"properties":[{"signature":"bool AllowInputAngle","since":"6.0","property":["get","set"]},{"signature":"double ApexAngleDegrees","since":"6.0","property":["get","set"]},{"signature":"double BaseAngleDegrees","since":"6.0","property":["get","set"]},{"signature":"bool Cap","summary":"Gets or sets whether or not the output should be capped.","since":"6.0","property":["get","set"]},{"signature":"ConeConstraint ConeConstraint","summary":"State of the cone/cylinder constraint option. When the cone/cylinder option is selected, the circle is being made as a base for a cone/cylinder. By default the vertical cone/cylinder option not available but is not selected.  By default the \\"Vertical\\" option applies to VerticalCircle.","since":"6.0","property":["get","set"]},{"signature":"double DefaultSize","summary":"Default radius or diameter (based on InDiameterMode)","since":"6.0","property":["get","set"]},{"signature":"double Height","since":"6.0","property":["get","set"]},{"signature":"bool InDiameterMode","summary":"Determines if the \\"size\\" value is representing a radius or diameter","since":"6.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"},{"signature":"Commands.Result Get(out Cone cone)","summary":"Prompt for the getting of a cone.","since":"6.0","parameters":[{"name":"cone","summary":"The cone geometry defined by the user."}],"returns":"The result of the getting operation."},{"signature":"Commands.Result GetMesh(ref int verticalFaces, ref int aroundFaces, out Cone cone)","summary":"Prompt for the getting of a mesh cone.","since":"7.0","parameters":[{"name":"verticalFaces","summary":"The number of faces in the vertical direction."},{"name":"aroundFaces","summary":"The number of faces in the around direction"},{"name":"cone","summary":"The cone geometry defined by the user."}],"returns":"The result of the getting operation."},{"signature":"Commands.Result GetMesh(ref int verticalFaces, ref int aroundFaces, ref int capStyle, out Cone cone)","summary":"Prompt for the getting of a mesh cone.","since":"7.0","parameters":[{"name":"verticalFaces","summary":"The number of faces in the vertical direction."},{"name":"aroundFaces","summary":"The number of faces in the around direction"},{"name":"capStyle","summary":"Set to 0 if you don\'t want the prompt, 3 is triangles, 4 is quads."},{"name":"cone","summary":"The cone geometry defined by the user."}],"returns":"The result of the getting operation."}]},{"namespace":"Rhino.Input.Custom","name":"GetCylinder","dataType":"class","summary":"Class provides user interface to define a cylinder.","interfaces":["IDisposable"],"constructors":[{"signature":"GetCylinder()","since":"6.0"}],"properties":[{"signature":"bool BothSidesOption","summary":"Determine if the \\"both sides\\" option is enabled","since":"6.0","property":["get","set"]},{"signature":"bool Cap","summary":"Gets or sets whether or not the output should be capped.","since":"6.0","property":["get","set"]},{"signature":"CylinderConstraint CylinderConstraint","summary":"State of the cone/cylinder constraint option. When the cone/cylinder option is selected, the circle is being made as a base for a cone/cylinder. By default the vertical cone/cylinder option not available but is not selected.  By default the \\"Vertical\\" option applies to VerticalCircle.","since":"6.0","property":["get","set"]},{"signature":"double DefaultSize","summary":"Default radius or diameter (based on InDiameterMode)","since":"6.0","property":["get","set"]},{"signature":"double Height","summary":"Height of cylinder","since":"6.0","property":["get","set"]},{"signature":"bool InDiameterMode","summary":"Determines if the \\"size\\" value is representing a radius or diameter","since":"6.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"},{"signature":"Commands.Result Get(out Cylinder cylinder)","summary":"Prompt for the getting of a cylinder.","since":"6.0","parameters":[{"name":"cylinder","summary":"The cylinder geometry defined by the user."}],"returns":"The result of the getting operation."},{"signature":"Commands.Result GetMesh(ref int verticalFaces, ref int aroundFaces, out Cylinder cylinder)","summary":"Prompt for the getting of a mesh cylinder.","since":"7.0","parameters":[{"name":"verticalFaces","summary":"The number of faces in the vertical direction."},{"name":"aroundFaces","summary":"The number of faces in the around direction"},{"name":"cylinder","summary":"The cylinder geometry defined by the user."}],"returns":"The result of the getting operation."},{"signature":"Commands.Result GetMesh(ref int verticalFaces, ref int aroundFaces, ref int capStyle, out Cylinder cylinder)","summary":"Prompt for the getting of a mesh cylinder.","since":"7.0","parameters":[{"name":"verticalFaces","summary":"The number of faces in the vertical direction."},{"name":"aroundFaces","summary":"The number of faces in the around direction"},{"name":"capStyle","summary":"Set to 0 if you don\'t want the prompt, 3 is triangles, 4 is quads."},{"name":"cylinder","summary":"The cylinder geometry defined by the user."}],"returns":"The result of the getting operation."}]},{"namespace":"Rhino.Input.Custom","name":"GetEllipsoid","dataType":"class","summary":"Class provides user interface to define a truncated cone.","interfaces":["IDisposable"],"constructors":[{"signature":"GetEllipsoid()","since":"7.0"}],"properties":[{"signature":"Point3d FirstPoint","summary":"Returns the first point. If in \\"from foci\\" mode, then this is the first foci point.","since":"7.0","property":["get"]},{"signature":"bool IsModeFromFoci","summary":"Indicates the ellipsoid was created from foci.","since":"7.0","property":["get"]},{"signature":"bool MarkFoci","summary":"Indicates the user wants the ellipsoid foci marked with point objects.","since":"7.0","property":["get","set"]},{"signature":"Point3d SecondPoint","summary":"Returns the second point. If in \\"from foci\\" mode, then this is the second foci point.","since":"7.0","property":["get"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"7.0"},{"signature":"Commands.Result Get(out NurbsSurface ellipsoid)","summary":"Prompt for the getting of a ellipsoid.","since":"7.0","parameters":[{"name":"ellipsoid","summary":"The truncated cone in NURB form."}],"returns":"The result of the getting operation."},{"signature":"Commands.Result GetMesh(ref int verticalFaces, ref int aroundFaces, out Mesh ellipsoid)","summary":"Prompt for the getting of a mesh ellipsoid.","since":"7.0","parameters":[{"name":"verticalFaces","summary":"The number of faces in the vertical direction."},{"name":"aroundFaces","summary":"The number of faces in the around direction"},{"name":"ellipsoid","summary":"The ellipsoid in Mesh form."}],"returns":"The result of the getting operation."},{"signature":"Commands.Result GetMesh(ref int verticalFaces, ref int aroundFaces, ref bool quadCaps, out Mesh ellipsoid)","summary":"Prompt for the getting of a mesh ellipsoid.","since":"7.0","parameters":[{"name":"verticalFaces","summary":"The number of faces in the vertical direction."},{"name":"aroundFaces","summary":"The number of faces in the around direction"},{"name":"quadCaps","summary":"Set True to create quad faces at the caps, False for triangles."},{"name":"ellipsoid","summary":"The ellipsoid in Mesh form."}],"returns":"The result of the getting operation."}]},{"namespace":"Rhino.Input.Custom","name":"GetFileNameMode","dataType":"enum","since":"5.0","values":[{"signature":"Open = 0"},{"signature":"OpenTemplate = 1"},{"signature":"OpenImage = 2"},{"signature":"OpenRhinoOnly = 3"},{"signature":"OpenTextFile = 5"},{"signature":"OpenWorksession = 6"},{"signature":"Import = 7"},{"signature":"Attach = 8"},{"signature":"LoadPlugIn = 9"},{"signature":"Save = 10"},{"signature":"SaveSmall = 11"},{"signature":"SaveTemplate = 12"},{"signature":"SaveImage = 13"},{"signature":"Export = 14"},{"signature":"SaveTextFile = 17"},{"signature":"SaveWorksession = 18"}]},{"namespace":"Rhino.Input.Custom","name":"GetInteger","dataType":"class","summary":"Used to get integer numbers.","baseclass":"Rhino.Input.Custom.GetBaseClass","constructors":[{"signature":"GetInteger()","since":"5.0"}],"methods":[{"signature":"GetResult Get()","summary":"Call to get an integer.","since":"5.0","returns":"If the user chose a number, then GetResult.Number; another enumeration value otherwise."},{"signature":"int Number()","since":"5.0"},{"signature":"void SetLowerLimit(int lowerLimit, bool strictlyGreaterThan)","summary":"Sets a lower limit on the number that can be returned. By default there is no lower limit.","since":"5.0","parameters":[{"name":"lowerLimit","summary":"smallest acceptable number."},{"name":"strictlyGreaterThan","summary":"If true, then the returned number will be > lower_limit."}]},{"signature":"void SetUpperLimit(int upperLimit, bool strictlyLessThan)","summary":"Sets an upper limit on the number that can be returned. By default there is no upper limit.","since":"5.0","parameters":[{"name":"upperLimit","summary":"largest acceptable number."},{"name":"strictlyLessThan","summary":"If true, then the returned number will be < upper_limit."}]}]},{"namespace":"Rhino.Input.Custom","name":"GetLine","dataType":"class","summary":"Use to interactively get a line.  The Rhino \\"Line\\" command uses GetLine.","interfaces":["IDisposable"],"constructors":[{"signature":"GetLine()","since":"5.1"}],"properties":[{"signature":"bool AcceptZeroLengthLine","summary":"Controls whether or not a zero length line is acceptable. The default is to require the user to keep picking the end point until we get a point different than the start point.","since":"5.1","property":["get","set"]},{"signature":"Color FeedbackColor","summary":"If set, the feedback color is used to draw the dynamic line when the second point is begin picked.  If not set, the active layer color is used.","since":"5.1","property":["get","set"]},{"signature":"string FirstPointPrompt","summary":"Prompt when getting first point","since":"5.1","property":["get","set"]},{"signature":"double FixedLength","summary":"If FixedLength > 0, the line must have the specified length","since":"5.1","property":["get","set"]},{"signature":"GetLineMode GetLineMode","summary":"Mode used","since":"5.1","property":["get","set"]},{"signature":"bool HaveFeedbackColor","summary":"If true, the feedback color is used to draw the dynamic line when the second point is begin picked.  If false, the active layer color is used.","since":"5.1","property":["get"]},{"signature":"string MidPointPrompt","summary":"Prompt when getting midpoint","since":"5.1","property":["get","set"]},{"signature":"string SecondPointPrompt","summary":"Prompt when getting second point","since":"5.1","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.1"},{"signature":"void EnableAllVariations(bool on)","summary":"If true, then all line variations are shown if the default line mode is used","since":"5.1"},{"signature":"void EnableFromBothSidesOption(bool on)","summary":"If true, then the \\"BothSides\\" option shows up when the start point is interactively picked.","since":"5.1"},{"signature":"void EnableFromMidPointOption(bool on)","summary":"If true, the \\"MidPoint\\" options shows up","since":"5.1"},{"signature":"Commands.Result Get(out Line line)","summary":"Perform the \'get\' operation.","since":"5.1"},{"signature":"void SetFirstPoint(Point3d point)","summary":"Use SetFirstPoint to specify the line\'s starting point and skip the start point interactive picking","since":"5.1"}]},{"namespace":"Rhino.Input.Custom","name":"GetLineMode","dataType":"enum","since":"5.1","values":[{"signature":"TwoPoint = 0"},{"signature":"SurfaceNormal = 1"},{"signature":"Angled = 2"},{"signature":"Vertical = 3"},{"signature":"FourPoint = 4"},{"signature":"Bisector = 5"},{"signature":"Perpendicular = 6"},{"signature":"Tangent = 7"},{"signature":"CurveEnd = 8"},{"signature":"CPlaneNormalVector = 9"}]},{"namespace":"Rhino.Input.Custom","name":"GetNumber","dataType":"class","summary":"Used to get double precision numbers.","baseclass":"Rhino.Input.Custom.GetBaseClass","constructors":[{"signature":"GetNumber()","summary":"Create a new GetNumber.","since":"5.0"}],"methods":[{"signature":"GetResult Get()","summary":"Call to get a number.","since":"5.0","returns":"If the user chose a number, then GetResult.Number; another enumeration value otherwise."},{"signature":"void SetLowerLimit(double lowerLimit, bool strictlyGreaterThan)","summary":"Sets a lower limit on the number that can be returned. By default there is no lower limit.","since":"5.0","parameters":[{"name":"lowerLimit","summary":"smallest acceptable number."},{"name":"strictlyGreaterThan","summary":"If true, then the returned number will be > lower_limit."}]},{"signature":"void SetUpperLimit(double upperLimit, bool strictlyLessThan)","summary":"Sets an upper limit on the number that can be returned. By default there is no upper limit.","since":"5.0","parameters":[{"name":"upperLimit","summary":"largest acceptable number."},{"name":"strictlyLessThan","summary":"If true, then the returned number will be < upper_limit."}]}]},{"namespace":"Rhino.Input.Custom","name":"GetObject","dataType":"class","summary":"The GetObject class is the tool commands use to interactively select objects.","baseclass":"Rhino.Input.Custom.GetBaseClass","constructors":[{"signature":"GetObject()","since":"5.0"}],"properties":[{"signature":"bool AlreadySelectedObjectSelect","summary":"Allow selecting objects that are already selected. By default, GetObjects() disallows selection of objects that are already selected to avoid putting the same object in the selection set more than once. Calling EnableAlreadySelectedObjectSelect = true overrides that restriction and allows selected objects to be selected and returned by GetObjects. This is useful because, coupled with the return immediately mode of GetObjects(1, -1), it is possible to select a selected object to deselect when the selected objects are being managed outside GetObjects() as in the case of CRhinoPolyEdge::GetEdge().","since":"5.0","property":["get","set"]},{"signature":"bool BottomObjectPreference","summary":"By default, if a call to Input is permitted to select different parts of the same object, like a polysurface, a surface and an edge, then the top-most object is preferred. (polysurface beats face beats edge). If you want the bottom most object to be preferred, then call EnableBottomObjectPreference = True before calling GetObjects().","since":"5.0","property":["get","set"]},{"signature":"bool ChooseOneQuestion","summary":"By default, if a call to Input is permitted to select different parts of the same object, like a polysurface and an edge of that polysurface, then the top-most object is automatically selected. If you want the choose-one-object mechanism to include pop up in these cases, then call EnableChooseOneQuestion = True before calling GetObjects().","since":"5.0","property":["get","set"]},{"signature":"bool DeselectAllBeforePostSelect","summary":"True if pre-selected input will be deselected before post-selection begins when no pre-selected input is valid.","since":"5.0","property":["get","set"]},{"signature":"GeometryAttributeFilter GeometryAttributeFilter","summary":"The geometry attribute filter provides a secondary filter that can be used to restrict which objects can be selected. Control of the type of geometry (points, curves, surfaces, meshes, etc.) is provided by GetObject.SetGeometryFilter. The geometry attribute filter is used to require the selected geometry to have certain attributes (open, closed, etc.). The default attribute filter permits selection of all types of geometry.","since":"5.0","property":["get","set"]},{"signature":"ObjectType GeometryFilter","summary":"The geometry type filter controls which types of geometry (points, curves, surfaces, meshes, etc.) can be selected. The default geometry type filter permits selection of all types of geometry. NOTE: the filter can be a bitwise combination of multiple ObjectTypes.","since":"5.0","property":["get","set"]},{"signature":"bool GroupSelect","summary":"By default, groups are ignored in GetObject. If you want your call to GetObjects() to select every object in a group that has any objects selected, then enable group selection.","since":"5.0","property":["get","set"]},{"signature":"bool InactiveDetailPickEnabled","summary":"By default, objects in inactive details are not permitted to be picked. In a few rare cases this is used (ex. picking circles during DimRadius)","since":"5.8","property":["get","set"]},{"signature":"int ObjectCount","summary":"Gets the number of objects that were selected.","since":"5.0","property":["get"]},{"signature":"bool ObjectsWerePreselected","since":"5.0","property":["get"]},{"signature":"bool OneByOnePostSelect","summary":"In one-by-one post selection, the user is forced to select objects by post picking them one at a time.","since":"5.0","property":["get","set"]},{"signature":"bool ProxyBrepFromSubD","summary":"If a subd (or a subd component) cannot be selected, but a brep (or brep component) can be selected, then automatically create and use a proxy brep.","since":"7.0","property":["get","set"]},{"signature":"bool ReferenceObjectSelect","summary":"By default, reference objects can be selected. If you do not want to be able to select reference objects, then call EnableReferenceObjectSelect=false.","since":"5.0","property":["get","set"]},{"signature":"uint SerialNumber","summary":"Each instance of GetObject has a unique runtime serial number that is used to identify object selection events associated with that instance.","since":"5.0","property":["get"]},{"signature":"bool SubObjectSelect","summary":"By default, GetObject.Input will permit a user to select sub-objects (like a curve in a b-rep or a curve in a group). If you only want the user to select \\"top\\" level objects, then call EnableSubObjectSelect = false.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static GetObject ActiveGetObject(RhinoDoc doc)","summary":"Get the currently running GetObject for a given document","since":"6.3"},{"signature":"void AppendToPickList(ObjRef objref)","since":"6.3"},{"signature":"void ClearObjects()","summary":"Clear possible special object drawing","since":"6.12"},{"signature":"bool CustomGeometryFilter(RhinoObject rhObject, GeometryBase geometry, ComponentIndex componentIndex)","summary":"Checks geometry to see if it can be selected. Override to provide fancy filtering.","since":"5.0","parameters":[{"name":"rhObject","summary":"parent object being considered."},{"name":"geometry","summary":"geometry being considered."},{"name":"componentIndex","summary":"if >= 0, geometry is a proper sub-part of object->Geometry() with componentIndex."}],"returns":"The default returns True unless you\'ve set a custom geometry filter. If a custom filter has been set, that delegate is called."},{"signature":"void DisablePreSelect()","since":"5.0"},{"signature":"void EnableClearObjectsOnEntry(bool enable)","summary":"By default the picked object list is cleared when GetObject.GetObjects() is called. If you are reusing a GetObject class and do not want the existing object list cleared when you call Input, then call EnableClearObjectsOnEntry(false) before calling GetObjects().","since":"5.0","parameters":[{"name":"enable","summary":"The state to set."}]},{"signature":"void EnableHighlight(bool enable)","summary":"By default, any object post-pick selected by GetObjects() is highlighted. If you want to post-pick objects and not have them automatically highlight, then call EnableHighlight = false.","since":"5.0"},{"signature":"void EnableIgnoreGrips(bool enable)","summary":"By default, post selection will select objects with grips on. If you do not want to be able to post select objects with grips on, then call EnableIgnoreGrips = false. The ability to preselect an object with grips on is determined by the value returned by the virtual RhinoObject.IsSelectableWithGripsOn.","since":"5.0"},{"signature":"void EnablePostSelect(bool enable)","summary":"Control the availability of post selection in GetObjects.","since":"5.0"},{"signature":"void EnablePreSelect(bool enable, bool ignoreUnacceptablePreselectedObjects)","summary":"Control the pre-selection behavior GetObjects.","since":"5.0","parameters":[{"name":"enable","summary":"if true, pre-selection is enabled."},{"name":"ignoreUnacceptablePreselectedObjects","summary":"If True and some acceptable objects are pre-selected, then any unacceptable pre-selected objects are ignored. If False and any unacceptable are pre-selected, then the user is forced to post-select."}]},{"signature":"void EnablePressEnterWhenDonePrompt(bool enable)","summary":"By default, when GetObject.GetObjects is called with minimumNumber > 0 and maximumNumber = 0, the command prompt automatically includes \\"Press Enter when done\\" after the user has selected at least minimumNumber of objects. If you want to prohibit the addition of the \\"Press Enter when done\\", then call EnablePressEnterWhenDonePrompt = false;","since":"5.0"},{"signature":"void EnableSelPrevious(bool enable)","summary":"By default, any object selected during a command becomes part of the \\"previous selection set\\" and can be reselected by the SelPrev command. If you need to select objects but do not want them to be selected by a subsequent call to SelPrev, then call EnableSelPrev = false.","since":"5.0"},{"signature":"void EnableUnselectObjectsOnExit(bool enable)","summary":"By default any objects in the object list are unselected when GetObject.GetObjects() exits with any return code besides Object. If you want to leave the objects selected when non-object input is returned, then call EnableUnselectObjectsOnExit(false) before calling GetObjects().","since":"5.0","parameters":[{"name":"enable","summary":"The state to set."}]},{"signature":"GetResult Get()","summary":"Call to select a single object.","since":"5.0","returns":"GetResult.Object if an object was selected. GetResult.Cancel if the user pressed ESCAPE to cancel the selection. See GetResults for other possible values that may be returned when options, numbers, etc., are acceptable responses."},{"signature":"GetResult GetMultiple(int minimumNumber, int maximumNumber)","summary":"Call to select objects.","since":"5.0","parameters":[{"name":"minimumNumber","summary":"minimum number of objects to select."},{"name":"maximumNumber","summary":"maximum number of objects to select. If 0, then the user must press enter to finish object selection. If -1, then object selection stops as soon as there are at least minimumNumber of object selected. If >0, then the picking stops when there are maximumNumber objects.  If a window pick, crossing pick, or Sel* command attempts to add more than maximumNumber, then the attempt is ignored."}],"returns":"GetResult.Object if one or more objects were selected. GetResult.Cancel if the user pressed ESCAPE to cancel the selection. See GetResults for other possible values that may be returned when options, numbers, etc., are acceptable responses."},{"signature":"ObjRef Object(int index)","since":"5.0"},{"signature":"ObjRef[] Objects()","since":"5.0"},{"signature":"bool PassesGeometryAttributeFilter(RhinoObject rhObject, GeometryBase geometry, ComponentIndex componentIndex)","summary":"Checks geometry to see if it passes the basic GeometryAttributeFilter.","since":"5.0","parameters":[{"name":"rhObject","summary":"parent object being considered."},{"name":"geometry","summary":"geometry being considered."},{"name":"componentIndex","summary":"if >= 0, geometry is a proper sub-part of object->Geometry() with componentIndex."}],"returns":"True if the geometry passes the filter returned by GeometryAttributeFilter()."},{"signature":"void SetCustomGeometryFilter(GetObjectGeometryFilter filter)","summary":"Set filter callback function that will be called by the CustomGeometryFilter","since":"5.0"},{"signature":"void SetPressEnterWhenDonePrompt(string prompt)","summary":"The default prompt when EnablePressEnterWhenDonePrompt is enabled is \\"Press Enter when done\\". Use this function to specify a different string to be appended.","since":"5.0","parameters":[{"name":"prompt","summary":"The text that will be displayed just after the prompt, after the selection has been made."}]}]},{"namespace":"Rhino.Input.Custom","name":"GetOption","dataType":"class","summary":"If you want to explicitly get string input, then use GetString class with options. If you only want to get options, then use this class (GetOption)","baseclass":"Rhino.Input.Custom.GetBaseClass","constructors":[{"signature":"GetOption()","since":"5.0"}],"methods":[{"signature":"GetResult Get()","summary":"Call to get an option. A return value of \\"option\\" means the user selected a valid option. Use Option() the determine which option.","since":"5.0","returns":"If the user chose an option, then GetResult.Option; another enumeration value otherwise."}]},{"namespace":"Rhino.Input.Custom","name":"GetPoint","dataType":"class","summary":"Used to interactively get a point.","baseclass":"Rhino.Input.Custom.GetBaseClass","constructors":[{"signature":"GetPoint()","summary":"Create a new GetPoint.","since":"5.0"}],"properties":[{"signature":"Color DynamicDrawColor","summary":"Color used by CRhinoGetPoint::DynamicDraw to draw the current point and the line from the base point to the current point.","since":"5.0","property":["get","set"]},{"signature":"bool FullFrameRedrawDuringGet","summary":"In the \\"RARE\\" case that you need to draw some depth buffered geometry during a Get() operation, setting this value to True will force entire frames to be redrawn while the user moves the mouse. This allows DisplayPipeline events to be triggered as well as OnPostDrawObjects NOTE!! Setting this value to True comes with a significant performance penalty because the scene needs to be fully regenerated every frame where the standard DynamicDraw event draws temporary decorations (geometry) on top of a static scene.","since":"5.0","property":["get","set"]},{"signature":"OsnapModes OsnapEventType","summary":"Gets the type of object snap used to obtain the point.","since":"6.24","property":["get"]},{"signature":"object Tag","summary":"Gets or sets an arbitrary object that can be attached to this GetPointinstance. Useful for passing some/ information that you may need in a DynamicDraw event since you can get at this Tag from the GetPointDrawEventArgs.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"int AddConstructionPoint(Point3d point)","summary":"Adds a point to the list of construction points.","since":"5.0","parameters":[{"name":"point","summary":"A point to be added."}],"returns":"Total number of construction points."},{"signature":"int AddConstructionPoints(Point3d[] points)","summary":"Adds points to the list of construction points.","since":"5.0","parameters":[{"name":"points","summary":"An array of points to be added."}],"returns":"Total number of construction points."},{"signature":"int AddSnapPoint(Point3d point)","summary":"Adds a point to the list of osnap points.","since":"5.0","parameters":[{"name":"point","summary":"A point."}],"returns":"Total number of snap points."},{"signature":"int AddSnapPoints(Point3d[] points)","summary":"Adds points to the list of osnap points.","since":"5.0","parameters":[{"name":"points","summary":"An array of points to snap onto."}],"returns":"Total number of snap points."},{"signature":"void ClearConstraints()","summary":"Removes any explicit constraints added by calls to GetPoint::Constraint() and enable the built-in constraint options.","since":"5.0"},{"signature":"void ClearConstructionPoints()","summary":"Remove all construction points.","since":"5.0"},{"signature":"void ClearSnapPoints()","summary":"Remove all snap points.","since":"5.0"},{"signature":"bool Constrain(Arc arc)","summary":"Constrains the picked point to lie on an arc.","since":"5.0","parameters":[{"name":"arc","summary":"An arc to use as constraint."}],"returns":"True if constraint could be applied."},{"signature":"bool Constrain(Brep brep, int wireDensity, int faceIndex, bool allowPickingPointOffObject)","summary":"Constrains the picked point to lie on a brep.","since":"5.0","parameters":[{"name":"brep","summary":"A brep to use as constraint."},{"name":"wireDensity","summary":"When wire_density<0, isocurve intersection snapping is turned off, when wire_density>=0, the value defines the isocurve density used for isocurve intersection snapping."},{"name":"faceIndex","summary":"When face_index <0, constrain to whole brep. When face_index >=0, constrain to individual face."},{"name":"allowPickingPointOffObject","summary":"defines whether the point pick is allowed to happen off object. When false, a \\"no no\\" cursor is shown when the cursor is not on the object. When true, a normal point picking cursor is used and the marker is visible also when the cursor is not on the object."}],"returns":"True if constraint could be applied."},{"signature":"bool Constrain(Circle circle)","summary":"Constrains the picked point to lie on a circle.","since":"5.0","parameters":[{"name":"circle","summary":"A circle to use as constraint."}],"returns":"True if constraint could be applied."},{"signature":"bool Constrain(Curve curve, bool allowPickingPointOffObject)","summary":"Constrains the picked point to lie on a curve.","since":"5.0","parameters":[{"name":"curve","summary":"A curve to use as constraint."},{"name":"allowPickingPointOffObject","summary":"defines whether the point pick is allowed to happen off object. When false, a \\"no no\\" cursor is shown when the cursor is not on the object. When true, a normal point picking cursor is used and the marker is visible also when the cursor is not on the object."}],"returns":"True if constraint could be applied."},{"signature":"bool Constrain(Cylinder cylinder)","summary":"Constrains the picked point to lie on a cylinder.","since":"5.0","parameters":[{"name":"cylinder","summary":"A cylinder to use as constraint."}],"returns":"True if constraint could be applied."},{"signature":"bool Constrain(Line line)","summary":"Constrains the picked point to lie on a line.","since":"5.0","parameters":[{"name":"line","summary":"A line to use as constraint."}],"returns":"True if constraint could be applied."},{"signature":"bool Constrain(Mesh mesh, bool allowPickingPointOffObject)","summary":"Constrains the picked point to lie on a mesh.","since":"5.0","parameters":[{"name":"mesh","summary":"A mesh to use as constraint."},{"name":"allowPickingPointOffObject","summary":"defines whether the point pick is allowed to happen off object. When false, a \\"no no\\" cursor is shown when the cursor is not on the object. When true, a normal point picking cursor is used and the marker is visible also when the cursor is not on the object."}],"returns":"True if constraint could be applied."},{"signature":"bool Constrain(Plane plane, bool allowElevator)","summary":"constrain the picked point to lie on a plane.","since":"5.0","parameters":[{"name":"plane","summary":"A plane to use as constraint."},{"name":"allowElevator","summary":"True if elevator mode should be allowed at user request."}],"returns":"True if constraint could be applied."},{"signature":"bool Constrain(Point3d from, Point3d to)","summary":"Constrains the picked point to lie on a line.","since":"5.0","parameters":[{"name":"from","summary":"The start point of constraint."},{"name":"to","summary":"The end point of constraint."}],"returns":"True if constraint could be applied."},{"signature":"bool Constrain(Sphere sphere)","summary":"Constrains the picked point to lie on a sphere.","since":"5.0","parameters":[{"name":"sphere","summary":"A sphere to use as constraint."}],"returns":"True if constraint could be applied."},{"signature":"bool Constrain(Surface surface, bool allowPickingPointOffObject)","summary":"Constrains the picked point to lie on a surface.","since":"5.0","parameters":[{"name":"surface","summary":"A surface to use as constraint."},{"name":"allowPickingPointOffObject","summary":"defines whether the point pick is allowed to happen off object. When false, a \\"no no\\" cursor is shown when the cursor is not on the object. When true, a normal point picking cursor is used and the marker is visible also when the cursor is not on the object."}],"returns":"True if constraint could be applied."},{"signature":"void ConstrainDistanceFromBasePoint(double distance)","summary":"Sets distance constraint from base point.","since":"5.0","parameters":[{"name":"distance","summary":"pass UnsetValue to clear this constraint. Pass 0.0 to disable the ability to set this constraint by typing a number during GetPoint."}]},{"signature":"bool ConstrainToConstructionPlane(bool throughBasePoint)","summary":"If enabled, the picked point is constrained to be on the active construction plane. If the base point is set, then the point is constrained to be on the plane that contains the base point and is parallel to the active construction plane. By default this constraint is enabled.","since":"5.0","parameters":[{"name":"throughBasePoint","summary":"True if the base point should be used as compulsory level reference."}],"returns":"If True and the base point is set, then the point is constrained to be on the plane parallel to the construction plane that passes through the base point, even when planar mode is off. If throughBasePoint is false, then the base point shift only happens if planar mode is on."},{"signature":"void ConstrainToTargetPlane()","summary":"Constrains point to lie on a plane that is parallel to the viewing plane and passes through the view\'s target point.","since":"5.0"},{"signature":"bool ConstrainToVirtualCPlaneIntersection(Plane plane)","summary":"If enabled, the picked point is constrained to be on the intersection of the plane and the virtual CPlane going through the plane origin. If the planes are parallel, the constraint works just like planar constraint.","since":"5.0","parameters":[{"name":"plane","summary":"The plane used for the plane - virtual CPlane intersection."}],"returns":"True if the operation succeeded; False otherwise."},{"signature":"void DrawLineFromPoint(Point3d startPoint, bool showDistanceInStatusBar)","summary":"Use DrawLineFromPoint() if you want a dynamic line drawn from a point to the point being picked.","since":"5.0","parameters":[{"name":"startPoint","summary":"The line is drawn from startPoint to the point being picked. If the base point has not been set, then it is set to startPoint."},{"name":"showDistanceInStatusBar","summary":"if true, the distance from the basePoint to the point begin picked is shown in the status bar."}]},{"signature":"void EnableCurveSnapArrow(bool drawDirectionArrowAtSnapPoint, bool reverseArrow)","summary":"Controls display of the curve snap arrow icon.","since":"5.0","parameters":[{"name":"drawDirectionArrowAtSnapPoint","summary":"True to draw arrow icon whenever GetPoint snaps to a curve."},{"name":"reverseArrow","summary":"True if arrow icon direction should be the reverse of the first derivative direction."}]},{"signature":"void EnableCurveSnapPerpBar(bool drawPerpBarAtSnapPoint, bool drawEndPoints)","summary":"Controls display of the curve snap perpendicular bar icon.","since":"5.0","parameters":[{"name":"drawPerpBarAtSnapPoint","summary":"True to draw a tangent bar icon  whenever GetPoint snaps to a curve."},{"name":"drawEndPoints","summary":"True to draw points at the end of the tangent bar."}]},{"signature":"void EnableCurveSnapTangentBar(bool drawTangentBarAtSnapPoint, bool drawEndPoints)","summary":"Controls display of the curve snap tangent bar icon.","since":"5.0","parameters":[{"name":"drawTangentBarAtSnapPoint","summary":"True to draw a tangent bar icon whenever GetPoint snaps to a curve."},{"name":"drawEndPoints","summary":"True to draw points at the end of the tangent bar."}]},{"signature":"void EnableDrawLineFromPoint(bool enable)","summary":"Controls drawing of dynamic a line from the start point.","since":"5.0","parameters":[{"name":"enable","summary":"if true, a dynamic line is drawn from the DrawLineFromPoint startPoint to the point being picked."}]},{"signature":"void EnableNoRedrawOnExit(bool noRedraw)","summary":"The default functionality of the GetPoint operation is to perform a redraw on exit. Calling this function with True turns off automatic redraw at the end of GetPoint. May be needed in some commands for flicker free feedback. When set to true, the caller is responsible for cleaning up the screen after GetPoint.","since":"6.0"},{"signature":"void EnableObjectSnapCursors(bool enable)","summary":"Enables or disables object snap cursors. By default, object snap cursors are enabled.","since":"6.0","parameters":[{"name":"enable","summary":"If True then object snap cursors (plus sign with \\"near\\", \\"end\\", etc.) are used when the point snaps to a object."}]},{"signature":"void EnableSnapToCurves(bool enable)","summary":"If you want GetPoint() to try to snap to curves when the mouse is near a curve (like the center point in the Circle command when the AroundCurve option is on), then enable the snap to curves option.","since":"5.0","parameters":[{"name":"enable","summary":"Whether points should be enabled."}]},{"signature":"GetResult Get()","summary":"After setting up options and so on, call GetPoint::Get to get a 3d point. The point is retrieved when the mouse goes down.","since":"5.0"},{"signature":"GetResult Get(bool onMouseUp)","summary":"After setting up options and so on, call this method to get a 3d point.","since":"5.0","parameters":[{"name":"onMouseUp","summary":"If false, the point is returned when the left mouse button goes down. If true, the point is returned when the left mouse button goes up."}],"returns":"GetResult.Pointif the user chose a point; other enumeration value otherwise."},{"signature":"GetResult Get(bool onMouseUp, bool get2DPoint)","summary":"After setting up options and so on, call this method to get a 2d or 3d point.","since":"5.12","parameters":[{"name":"onMouseUp","summary":"If false, the point is returned when the left mouse button goes down. If true, the point is returned when the left mouse button goes up."},{"name":"get2DPoint","summary":"If True then get a 2d point otherwise get a 2d point"}],"returns":"GetResult.Pointif the user chose a 3d point; GetResult.Point2dif the user chose a 2d point; other enumeration value otherwise."},{"signature":"Point3d[] GetConstructionPoints()","summary":"Gets current construction points.","since":"5.0","returns":"An array of points."},{"signature":"bool GetPlanarConstraint(ref RhinoViewport vp, out Plane plane)","since":"6.0"},{"signature":"Point3d[] GetSnapPoints()","summary":"Gets current snap points.","since":"5.0","returns":"An array of points."},{"signature":"bool InterruptMouseMove()","summary":"If you have lengthy computations in OnMouseMove() and/or DymanicDraw() overrides, then periodically call InterruptMouseMove() to see if you should interrupt your work because the mouse has moved again.","since":"5.0","returns":"True if you should interrupt your work; False otherwise."},{"signature":"void PermitConstraintOptions(bool permit)","summary":"Control the availability of the built-in linear, planar, curve, and surface constraint options like \\"Along\\", \\"AlongPerp\\", \\"AlongTan\\", \\"AlongParallel\\", \\"Between\\", \\"OnCrv\\", \\"OnSrf\\", \\".x\\", \\".y\\", \\".z\\", \\".xy\\", etc.","since":"5.0","parameters":[{"name":"permit","summary":"if true, then the built-in constraint options are automatically available in GetPoint."}]},{"signature":"void PermitElevatorMode(int permitMode)","summary":"Permits the use of the control key to define a line constraint.","since":"5.0","parameters":[{"name":"permitMode","summary":"0: no elevator modes are permitted 1: fixed plane elevator mode (like the Line command) 2: cplane elevator mode (like object dragging)"}]},{"signature":"void PermitFromOption(bool permit)","summary":"Control the availability of the built-in \\"From\\" option. By default, the \\"From\\" option is enabled.","since":"5.0","parameters":[{"name":"permit","summary":"if true, then the \\"From\\" option is automatically available in GetPoint."}]},{"signature":"void PermitObjectSnap(bool permit)","summary":"By default, object snaps like \\"end\\", \\"near\\", etc. are controlled by the user. If you want to disable this ability, then call PermitObjectSnap(false).","since":"5.0","parameters":[{"name":"permit","summary":"True to permit snapping to objects."}]},{"signature":"void PermitOrthoSnap(bool permit)","summary":"Controls availability of ortho snap. Default is true.","since":"5.0","parameters":[{"name":"permit","summary":"if true, then GetPoint pays attention to the Rhino \\"ortho snap\\" and \\"planar snap\\" settings reported by ModelAidSettings.Ortho and ModelAidSettings.Planar."}]},{"signature":"void PermitTabMode(bool permit)","summary":"Permits the use of the tab key to define a line constraint.","since":"5.0","parameters":[{"name":"permit","summary":"If true, then the built-in tab key mode is available."}]},{"signature":"BrepFace PointOnBrep(out double u, out double v)","summary":"Use to determine if point was on a Brep face. If the point was on a Brep face, then the (u,v) are the face parameters for the point.","since":"6.0","parameters":[{"name":"u","summary":"If the point was on a Brep face, then the u parameter."},{"name":"v","summary":"If the point was on a Brep face, then the v parameter."}],"returns":"The Brep face or None if the point was not on a Brep face."},{"signature":"Curve PointOnCurve(out double t)","summary":"Use to determine is point was on a curve.","since":"5.0","parameters":[{"name":"t","summary":"If the point was on a curve, then the t is the curve parameter for the point.  The point returned by Point() is the same as curve.PointAt(t)."}],"returns":"A curve at a specified parameter value."},{"signature":"DocObjects.ObjRef PointOnObject()","summary":"Call this function to see if the point was on an object. If the point was on an object an ObjRef is returned; otherwise None is returned.","since":"5.0","returns":"A point object reference."},{"signature":"Surface PointOnSurface(out double u, out double v)","summary":"Use to determine if point was on a surface. If the point was on a surface, then the (u,v) are the surface parameters for the point. The point returned by Point() is the same as surface.PointAt(u,v).","since":"6.0","parameters":[{"name":"u","summary":"If the point was on a surface, then the u parameter."},{"name":"v","summary":"If the point was on a surface, then the v parameter."}],"returns":"The surface or None if the point was not on a surface."},{"signature":"void SetBasePoint(Point3d basePoint, bool showDistanceInStatusBar)","summary":"Sets a base point used by ortho snap, from snap, planar snap, etc.","since":"5.0","parameters":[{"name":"basePoint","summary":"The new base point."},{"name":"showDistanceInStatusBar","summary":"If true, then the distance from base_point to the current point will be in the status bar distance pane."}]},{"signature":"void SetCursor(CursorStyle cursor)","summary":"Sets cursor that will be used when Get() is called and snap is not happening.","since":"6.0"},{"signature":"bool TryGetBasePoint(out Point3d basePoint)","since":"5.0"}]},{"namespace":"Rhino.Input.Custom","name":"GetPointDrawEventArgs","dataType":"class","summary":"Arguments for drawing during point getting.","baseclass":"Rhino.Display.DrawEventArgs","properties":[{"signature":"Point3d CurrentPoint","since":"5.0","property":["get"]},{"signature":"GetPoint Source","summary":"GetPoint class that this draw event originated from.","since":"5.0","property":["get"]}]},{"namespace":"Rhino.Input.Custom","name":"GetPointMouseEventArgs","dataType":"class","summary":"Arguments for mouse information during point getting.","baseclass":"EventArgs","properties":[{"signature":"bool ControlKeyDown","since":"5.0","property":["get"]},{"signature":"bool LeftButtonDown","since":"5.0","property":["get"]},{"signature":"bool MiddleButtonDown","since":"5.0","property":["get"]},{"signature":"Point3d Point","since":"5.0","property":["get"]},{"signature":"bool RightButtonDown","since":"5.0","property":["get"]},{"signature":"bool ShiftKeyDown","since":"5.0","property":["get"]},{"signature":"GetPoint Source","since":"5.0","property":["get"]},{"signature":"RhinoViewport Viewport","since":"5.0","property":["get"]},{"signature":"Point WindowPoint","since":"5.0","property":["get"]}]},{"namespace":"Rhino.Input.Custom","name":"GetPolyline","dataType":"class","summary":"Use to interactively get a polyline.","interfaces":["IDisposable"],"constructors":[{"signature":"GetPolyline()","since":"6.0"}],"properties":[{"signature":"string FirstPointPrompt","summary":"Prompt when getting first point","since":"6.0","property":["get","set"]},{"signature":"string FourthPointPrompt","summary":"Prompt when getting fourth point","since":"6.0","property":["get","set"]},{"signature":"int MaxPointCount","since":"6.0","property":["get","set"]},{"signature":"int MinPointCount","since":"6.0","property":["get","set"]},{"signature":"string SecondPointPrompt","summary":"Prompt when getting second point","since":"6.0","property":["get","set"]},{"signature":"string ThirdPointPrompt","summary":"Prompt when getting third point","since":"6.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"},{"signature":"Commands.Result Get(out Polyline polyline)","summary":"Perform the \'get\' operation.","since":"6.0"},{"signature":"void SetFirstPoint(Point3d point)","summary":"Use SetFirstPoint to specify the line\'s starting point and skip the start point interactive picking","since":"6.0"}]},{"namespace":"Rhino.Input.Custom","name":"GetSphere","dataType":"class","summary":"Class provides user interface to define a sphere.","interfaces":["IDisposable"],"constructors":[{"signature":"GetSphere()","since":"7.0"}],"properties":[{"signature":"double DefaultSize","summary":"Default radius or diameter (based on InDiameterMode)","since":"7.0","property":["get","set"]},{"signature":"bool InDiameterMode","summary":"Determines if the \\"size\\" value is representing a radius or diameter","since":"7.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"7.0"},{"signature":"Commands.Result Get(out Sphere sphere)","summary":"Prompt for the getting of a sphere.","since":"7.0","parameters":[{"name":"sphere","summary":"The sphere geometry defined by the user."}],"returns":"The result of the getting operation."},{"signature":"Commands.Result GetMesh(ref MeshSphereStyle style, ref int verticalFaces, ref int aroundFaces, ref int triangleSubdivisions, ref int quadSubdivisions, out Sphere sphere)","summary":"Prompt for the getting of a mesh sphere.","since":"7.0","parameters":[{"name":"style","summary":"The style of the mesh sphere."},{"name":"verticalFaces","summary":"The number of UV mesh faces in the vertical direction."},{"name":"aroundFaces","summary":"The number of UV mesh faces in the around direction."},{"name":"triangleSubdivisions","summary":"The number of triangle mesh subdivisions."},{"name":"quadSubdivisions","summary":"The number of quad mesh subdivisions."},{"name":"sphere","summary":"The sphere geometry defined by the user."}],"returns":"The result of the getting operation."}]},{"namespace":"Rhino.Input.Custom","name":"GetSphere.MeshSphereStyle","dataType":"enum","summary":"Mesh sphere styles enumeration.","values":[{"signature":"UV = 0","summary":"UV Sphere."},{"signature":"Triangle = 1","summary":"Icosahedron Sphere."},{"signature":"Quad = 2","summary":"Quad Sphere."}]},{"namespace":"Rhino.Input.Custom","name":"GetString","dataType":"class","summary":"Used to get strings.","baseclass":"Rhino.Input.Custom.GetBaseClass","constructors":[{"signature":"GetString()","summary":"Constructs a new GetString.","since":"5.0"}],"methods":[{"signature":"GetResult Get()","summary":"Returns the string that the user typed. By default, space stops the string input.","since":"5.0","returns":"The result type. If the user typed a string, this is GetResult.String."},{"signature":"GetResult GetLiteralString()","summary":"Returns the string that the user typed. By default, space does not stop input.","since":"5.0","returns":"The result type. If the user typed a string, this is GetResult.String."}]},{"namespace":"Rhino.Input.Custom","name":"GetTorus","dataType":"class","summary":"Class provides user interface to define a torus.","interfaces":["IDisposable"],"constructors":[{"signature":"GetTorus()","since":"7.0"}],"properties":[{"signature":"double DefaultSize","summary":"Default radius or diameter (based on InDiameterMode)","since":"7.0","property":["get","set"]},{"signature":"bool FixInnerRadius","summary":"Second radius option. The first radius chosen sets the inner dimension of the torus and the second radius is constrained to be outside of the first radius.","since":"7.0","property":["get","set"]},{"signature":"bool InDiameterMode","summary":"Determines if the \\"size\\" value is representing a radius or diameter","since":"7.0","property":["get","set"]},{"signature":"bool InSecondDiameterMode","summary":"Second radius option. Determines if the second \\"size\\" value is representing a radius or diameter","since":"7.0","property":["get","set"]},{"signature":"double SecondSize","summary":"Second radius or diameter (based on InSecondDiameterMode)","since":"7.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"7.0"},{"signature":"Commands.Result Get(out Torus torus)","summary":"Prompt for the getting of a torus.","since":"7.0","parameters":[{"name":"torus","summary":"The torus geometry defined by the user."}],"returns":"The result of the getting operation."},{"signature":"Commands.Result GetMesh(ref int verticalFaces, ref int aroundFaces, out Torus torus)","summary":"Prompt for the getting of a mesh torus.","since":"7.0","parameters":[{"name":"verticalFaces","summary":"The number of faces in the vertical direction."},{"name":"aroundFaces","summary":"The number of faces in the around direction"},{"name":"torus","summary":"The torus geometry defined by the user."}],"returns":"The result of the getting operation."}]},{"namespace":"Rhino.Input.Custom","name":"GetTransform","dataType":"class","summary":"Used for getting a Transform","baseclass":"Rhino.Input.Custom.GetPoint","properties":[{"signature":"bool HaveTransform","since":"5.0","property":["get","set"]},{"signature":"TransformObjectList ObjectList","since":"5.0","property":["get"]},{"signature":"Transform Transform","since":"5.0","property":["get","set"]}],"methods":[{"signature":"void AddTransformObjects(TransformObjectList list)","summary":"Adds any objects you want transformed and grips you want transformed. Make sure no duplicates are in the list and that no grip owners are passed in as objects.","since":"5.0","parameters":[{"name":"list","summary":"A custom transform object list."}]},{"signature":"Transform CalculateTransform(RhinoViewport viewport, Point3d point)","summary":"Retrieves the final transformation.  \\nOverride this virtual function to provide your own custom transformation method.","since":"5.0","parameters":[{"name":"viewport","summary":"A Rhino viewport that the user is using."},{"name":"point","summary":"A point that the user is selecting."}],"returns":"A transformation matrix value."},{"signature":"GetResult GetXform()","summary":"Gets the Transformation.  \\nCall this after having set up options and so on.","since":"5.0","returns":"The result based on user choice."}]},{"namespace":"Rhino.Input.Custom","name":"GetTruncatedCone","dataType":"class","summary":"Class provides user interface to define a truncated cone.","interfaces":["IDisposable"],"constructors":[{"signature":"GetTruncatedCone()","since":"7.0"}],"properties":[{"signature":"bool Cap","summary":"Gets or sets whether or not the output should be capped.","since":"7.0","property":["get","set"]},{"signature":"CylinderConstraint CylinderConstraint","summary":"State of the cone/cylinder constraint option. When the cone/cylinder option is selected, the circle is being made as a base for a cone/cylinder. By default the vertical cone/cylinder option not available but is not selected.  By default the \\"Vertical\\" option applies to VerticalCircle.","since":"7.0","property":["get","set"]},{"signature":"double DefaultSize","summary":"Default radius or diameter (based on InDiameterMode)","since":"7.0","property":["get","set"]},{"signature":"double Height","summary":"Height of truncated cone.","since":"7.0","property":["get","set"]},{"signature":"bool InDiameterMode","summary":"Determines if the \\"size\\" value is representing a radius or diameter","since":"7.0","property":["get","set"]},{"signature":"double SecondRadius","summary":"Radius of second circle.","since":"7.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"7.0"},{"signature":"Commands.Result Get(out Brep truncatedCone)","summary":"Prompt for the getting of a truncated cone.","since":"7.0","parameters":[{"name":"truncatedCone","summary":"The truncated cone in Brep form."}],"returns":"The result of the getting operation."},{"signature":"Commands.Result GetMesh(ref int verticalFaces, ref int aroundFaces, out Mesh truncatedCone)","summary":"Prompt for the getting of a mesh truncated cone.","since":"7.0","parameters":[{"name":"verticalFaces","summary":"The number of faces in the vertical direction."},{"name":"aroundFaces","summary":"The number of faces in the around direction"},{"name":"truncatedCone","summary":"The truncated cone in Mesh form."}],"returns":"The result of the getting operation."},{"signature":"Commands.Result GetMesh(ref int verticalFaces, ref int aroundFaces, ref int capStyle, out Mesh truncatedCone)","summary":"Prompt for the getting of a mesh truncated cone.","since":"7.0","parameters":[{"name":"verticalFaces","summary":"The number of faces in the vertical direction."},{"name":"aroundFaces","summary":"The number of faces in the around direction"},{"name":"capStyle","summary":"Set to 0 if you don\'t want the prompt, 3 is triangles, 4 is quads."},{"name":"truncatedCone","summary":"The truncated cone in Mesh form."}],"returns":"The result of the getting operation."}]},{"namespace":"Rhino.Input.Custom","name":"OptionColor","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"OptionColor(Color initialValue)","since":"5.0"}],"properties":[{"signature":"Color CurrentValue","since":"5.0","property":["get","set"]},{"signature":"Color InitialValue","since":"5.0","property":["get"]}],"methods":[{"signature":"void Dispose()","since":"5.0"}]},{"namespace":"Rhino.Input.Custom","name":"OptionDouble","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"OptionDouble(double initialValue)","since":"5.0"},{"signature":"OptionDouble(double initialValue, bool setLowerLimit, double limit)","summary":"Initializes a new instance of the double option class.","since":"5.0","parameters":[{"name":"initialValue","summary":"The initial number ."},{"name":"setLowerLimit","summary":"If true, limit sets the lower limit and upper limit is undefined. If false, limit sets the upper limit and lower limit is undefined."},{"name":"limit","summary":"The lower limit if setLowerLimit is true; otherwise, the upper limit."}]},{"signature":"OptionDouble(double initialValue, double lowerLimit, double upperLimit)","summary":"Initializes a new instance of the OptionDoubleclass with lower and upper limits.","since":"5.0","parameters":[{"name":"initialValue","summary":"The initial number ."},{"name":"lowerLimit","summary":"The minimum value."},{"name":"upperLimit","summary":"The maximum value."}]}],"properties":[{"signature":"double CurrentValue","since":"5.0","property":["get","set"]},{"signature":"double InitialValue","since":"5.0","property":["get"]}],"methods":[{"signature":"void Dispose()","since":"5.0"}]},{"namespace":"Rhino.Input.Custom","name":"OptionInteger","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"OptionInteger(int initialValue)","since":"5.0"},{"signature":"OptionInteger(int initialValue, bool setLowerLimit, int limit)","summary":"Initializes a new instance of the OptionIntegerclass.","since":"5.0","parameters":[{"name":"initialValue","summary":"The initial value."},{"name":"setLowerLimit","summary":"If true, limit sets the lower limit and upper limit is undefined If false, limit sets the upper limit and lower limit is undefined."},{"name":"limit","summary":"IfsetLowerLimitis true, thenlimitis the minimum value. Otherwise, it is the maximum."}]},{"signature":"OptionInteger(int initialValue, int lowerLimit, int upperLimit)","summary":"Initializes a new instance of the OptionIntegerclass with both lower and upper limits.","since":"5.0","parameters":[{"name":"initialValue","summary":"The initial value."},{"name":"lowerLimit","summary":"The minimum value."},{"name":"upperLimit","summary":"The maximum value."}]}],"properties":[{"signature":"int CurrentValue","since":"5.0","property":["get","set"]},{"signature":"int InitialValue","since":"5.0","property":["get"]}],"methods":[{"signature":"void Dispose()","since":"5.0"}]},{"namespace":"Rhino.Input.Custom","name":"OptionToggle","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"OptionToggle(bool initialValue, LocalizeStringPair offValue, LocalizeStringPair onValue)","since":"5.0"},{"signature":"OptionToggle(bool initialValue, string offValue, string onValue)","since":"5.0"}],"properties":[{"signature":"bool CurrentValue","since":"5.0","property":["get","set"]},{"signature":"bool InitialValue","since":"5.0","property":["get"]}],"methods":[{"signature":"void Dispose()","since":"5.0"}]},{"namespace":"Rhino.Input.Custom","name":"PickContext","dataType":"class","summary":"Utility for determining if objects are picked","interfaces":["IDisposable"],"constructors":[{"signature":"PickContext()","since":"5.0"}],"properties":[{"signature":"GetObject GetObjectUsed","since":"5.0","property":["get"]},{"signature":"bool PickGroupsEnabled","summary":"True if GroupObjects should be added to the pick list","since":"5.0","property":["get","set"]},{"signature":"Line PickLine","summary":"pick chord starts on near clipping plane and ends on far clipping plane.","since":"5.0","property":["get","set"]},{"signature":"PickMode PickMode","since":"5.0","property":["get","set"]},{"signature":"PickStyle PickStyle","since":"5.0","property":["get","set"]},{"signature":"bool SubObjectSelectionEnabled","summary":"True if the user had activated sub-object selection","since":"5.0","property":["get","set"]},{"signature":"RhinoView View","summary":"This view can be a model view or a page view. When view is a page view, then you need to distinguish between the viewports MainViewport() and ActiveViewport().  When m_view is a model view, both MainViewport() and ActiveViewport() return the world view\'s viewport.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","since":"5.0"},{"signature":"bool PickFrustumTest(BezierCurve bezier, out double t, out double depth, out double distance)","since":"5.0"},{"signature":"bool PickFrustumTest(BoundingBox box, out bool boxCompletelyInFrustum)","summary":"Fast test to check if a bounding box intersects a pick frustum.","since":"5.0","parameters":[{"name":"box","summary":""},{"name":"boxCompletelyInFrustum","summary":"Set to True if the box is completely contained in the pick frustum. When doing a window or crossing pick, you can immediately return a hit if the object\'s bounding box is completely inside of the pick frustum."}],"returns":"False if bounding box is invalid or box does not intersect the pick frustum"},{"signature":"bool PickFrustumTest(Line line, out double t, out double depth, out double distance)","since":"5.0"},{"signature":"bool PickFrustumTest(Mesh mesh, MeshPickStyle pickStyle, out Point3d hitPoint, out double depth, out double distance, out MeshHitFlag hitFlag, out int hitIndex)","summary":"Utility for picking meshes","since":"5.0","parameters":[{"name":"mesh","summary":"mesh to test"},{"name":"pickStyle","summary":"mode used for pick test"},{"name":"hitPoint","summary":"location returned here for point picks"},{"name":"depth","summary":"depth returned here for point picks LARGER values are NEARER to the camera. SMALLER values are FARTHER from the camera."},{"name":"distance","summary":"planar distance returned here for point picks. SMALLER values are CLOSER to the pick point"},{"name":"hitFlag","summary":"For point picks, How to interpret the hitIndex (vertex hit, edge hit, or face hit)"},{"name":"hitIndex","summary":"index of vertex/edge/face that was hit. Use hitFlag to determine what this index corresponds to"}]},{"signature":"bool PickFrustumTest(Mesh mesh, MeshPickStyle pickStyle, out Point3d hitPoint, out Point2d hitSurfaceUV, out Point2d hitTextureCoordinate, out double depth, out double distance, out MeshHitFlag hitFlag, out int hitIndex)","summary":"Utility for picking meshes","since":"5.0","parameters":[{"name":"mesh","summary":"mesh to test"},{"name":"pickStyle","summary":"mode used for pick test"},{"name":"hitPoint","summary":"location returned here for point picks"},{"name":"hitSurfaceUV","summary":"If the mesh has surface parameters, set to the surface parameters of the hit point"},{"name":"hitTextureCoordinate","summary":"If the mesh has texture coordinates, set to the texture coordinate of the hit point.  Note that the texture coordinates can be set in many different ways and this information is useless unless you know how the texture coordinates are set on this particular mesh."},{"name":"depth","summary":"depth returned here for point picks LARGER values are NEARER to the camera. SMALLER values are FARTHER from the camera."},{"name":"distance","summary":"planar distance returned here for point picks. SMALLER values are CLOSER to the pick point"},{"name":"hitFlag","summary":"For point picks, How to interpret the hitIndex (vertex hit, edge hit, or face hit)"},{"name":"hitIndex","summary":"index of vertex/edge/face that was hit. Use hitFlag to determine what this index corresponds to"}]},{"signature":"bool PickFrustumTest(NurbsCurve curve, out double t, out double depth, out double distance)","since":"5.0"},{"signature":"bool PickFrustumTest(Point3d point, out double depth, out double distance)","summary":"Utility for picking 3d point","since":"5.0","parameters":[{"name":"point","summary":""},{"name":"depth","summary":"depth returned here for point picks. LARGER values are NEARER to the camera. SMALLER values are FARTHER from the camera."},{"name":"distance","summary":"planar distance returned here for point picks. SMALLER values are CLOSER to the pick point"}],"returns":"True if there is a hit"},{"signature":"bool PickFrustumTest(Point3d[] points, out int pointIndex, out double depth, out double distance)","since":"5.0"},{"signature":"bool PickFrustumTest(PointCloud cloud, out int pointIndex, out double depth, out double distance)","since":"5.0"},{"signature":"int[] PickMeshTopologyVertices(Mesh mesh)","summary":"Utility for picking mesh vertices","since":"5.0","returns":"indices of mesh topology vertices that were picked"},{"signature":"void SetPickTransform(Transform transform)","since":"5.0"},{"signature":"void UpdateClippingPlanes()","summary":"Updates the clipping plane information in pick region. The SetClippingPlanes and View fields must be called before calling UpdateClippingPlanes().","since":"5.0"}]},{"namespace":"Rhino.Input.Custom","name":"PickContext.MeshHitFlag","dataType":"enum","since":"5.0","values":[{"signature":"Invalid = -1"},{"signature":"Vertex = 0"},{"signature":"Edge = 1"},{"signature":"Face = 2"}]},{"namespace":"Rhino.Input.Custom","name":"PickContext.MeshPickStyle","dataType":"enum","since":"5.0","values":[{"signature":"WireframePicking = 0","summary":"Checks for vertex and edge hits"},{"signature":"ShadedModePicking = 1","summary":"Checks for face hits"},{"signature":"VertexOnlyPicking = 2","summary":"Returns False if no vertices are hit"}]},{"namespace":"Rhino.Input.Custom","name":"PickMode","dataType":"enum","summary":"Picking can happen in wireframe or shaded display mode","since":"5.0","values":[{"signature":"Wireframe = 1"},{"signature":"Shaded = 2"}]},{"namespace":"Rhino.Input.Custom","name":"PickStyle","dataType":"enum","summary":"Provides picking values that describe common CAD picking behavior.","since":"5.0","values":[{"signature":"None = 0"},{"signature":"PointPick = 1"},{"signature":"WindowPick = 2"},{"signature":"CrossingPick = 3"}]},{"namespace":"Rhino.Input.Custom","name":"TaskCompleteEventArgs","dataType":"class","baseclass":"EventArgs","constructors":[{"signature":"TaskCompleteEventArgs(Task task, RhinoDoc doc)","since":"6.0"}],"properties":[{"signature":"RhinoDoc Doc","since":"6.0","property":["get","set"]},{"signature":"bool Redraw","since":"6.0","property":["get","set"]},{"signature":"Task Task","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Input","name":"GetBoxMode","dataType":"enum","summary":"Enumerates all Box getter modes.","since":"5.0","values":[{"signature":"All = 0","summary":"All modes are allowed."},{"signature":"Corner = 1","summary":"The base rectangle is created by picking the two corner points."},{"signature":"ThreePoint = 2","summary":"The base rectangle is created by picking three points."},{"signature":"Vertical = 3","summary":"The base vertical rectangle is created by picking three points."},{"signature":"Center = 4","summary":"The base rectangle is created by picking a center point and a corner point."}]},{"namespace":"Rhino.Input","name":"GetResult","dataType":"enum","summary":"Possible results from GetObject.Get(), GetPoint.Get(), etc...","since":"5.0","values":[{"signature":"NoResult = 0"},{"signature":"Cancel = 1","summary":"User wants to cancel current command."},{"signature":"Nothing = 2","summary":"User pressed enter - typically used to accept defaults."},{"signature":"Option = 3","summary":"User specified an option - call Option() to get option index."},{"signature":"Number = 4","summary":"User entered a real number - call Number() to get value."},{"signature":"Color = 5","summary":"User entered a color - call Color() to get value."},{"signature":"Undo = 6","summary":"User pressed undo."},{"signature":"Miss = 7","summary":"User clicked and missed."},{"signature":"Point = 8","summary":"User picked 3d point - call Point() to get 3d point."},{"signature":"Point2d = 9","summary":"User picked 2d window point in CRhinoGetPoint::Get2dPoint() call ON_2dPoint() to get the point and View() to get the view."},{"signature":"Line2d = 10","summary":"User picked a 2d line in CRhinoGetPoint::Get2dLine() call Line2d() to get the line and View() to get the view."},{"signature":"Rectangle2d = 11","summary":"User picked a 2d rectangle in CRhinoGetPoint::Get2dRectangle() call Rectangle2d() to get the rectangle and View() to get the view."},{"signature":"Object = 12","summary":"User selected an object - call Object() to get object."},{"signature":"String = 13","summary":"User typed a string - call String() to get the string."},{"signature":"CustomMessage = 14","summary":"A custom message was posted to the RhinoGet"},{"signature":"Timeout = 15","summary":"The getter waited for the amount of time specified in RhinoGet::SetWaitDuration() and then gave up."},{"signature":"Circle = 16","summary":"call CRhinoGetCircle::GetCircle() to get the circle."},{"signature":"Plane = 17","summary":"call CRhinoGetPlane::GetPlane() to get the plane."},{"signature":"Cylinder = 18","summary":"call CRhinoGetCylinder::GetCylinder() to get the cylinder."},{"signature":"Sphere = 19","summary":"call CRhinoGetSphere::GetSphere() to get the sphere."},{"signature":"Angle = 20","summary":"call CRhinoGetAngle::Angle() to get the angle in radians (CRhinoGetAngle() returns this for typed number, too)."},{"signature":"Distance = 21","summary":"call CRhinoGetDistance::Distance() to get the distance value."},{"signature":"Direction = 22","summary":"call CRhinoGetDirection::Direction() to get the direction vector."},{"signature":"Frame = 23","summary":"call CRhinoGetFrame::Frame() to get the frame that was picked."},{"signature":"User1 = 0xFFFFFFFF"},{"signature":"User2 = 0xFFFFFFFE"},{"signature":"User3 = 0xFFFFFFFD"},{"signature":"User4 = 0xFFFFFFFC"},{"signature":"User5 = 0xFFFFFFFB"},{"signature":"ExitRhino = 0x0FFFFFFF","summary":"Stop now, do not cleanup, just return ASAP."}]},{"namespace":"Rhino.Input","name":"RhinoGet","dataType":"class","summary":"Base class for GetObject, GetPoint, GetSphere, etc.  You will never directly create a RhinoGet but you will use its member functions after calling GetObject::GetObjects(), GetPoint::GetPoint(), and so on.  Provides tools to set command prompt, set command options, and specify if the \\"get\\" can optionally accept numbers, nothing (pressing enter), and undo.","properties":[{"signature":"static BitmapFileTypes AllBitmapFileTypes","since":"6.0","property":["get"]}],"methods":[{"signature":"static Result Get2dRectangle(bool solidPen, out Rectangle rectangle, out RhinoView rectView)","summary":"Gets a rectangle in view window coordinates.","since":"5.0","parameters":[{"name":"solidPen","summary":"If true, a solid pen is used for drawing while the user selects a rectangle. If false, a dotted pen is used for drawing while the user selects a rectangle."},{"name":"rectangle","summary":"user selected rectangle in window coordinates."},{"name":"rectView","summary":"view that the user selected the window in."}],"returns":"Success or Cancel."},{"signature":"static Result GetAngle(string commandPrompt, Point3d basePoint, Point3d referencePoint, double defaultAngleRadians, out double angleRadians)","summary":"Allows user to interactively pick an angle","since":"5.2","parameters":[{"name":"commandPrompt","summary":"if null, a default prompt will be displayed"},{"name":"basePoint","summary":""},{"name":"referencePoint","summary":""},{"name":"defaultAngleRadians","summary":""},{"name":"angleRadians","summary":""}]},{"signature":"static Result GetArc(out Arc arc)","since":"5.0"},{"signature":"static Result GetBool(string prompt, bool acceptNothing, string offPrompt, string onPrompt, ref bool boolValue)","summary":"Easy to use Boolean getter.","since":"5.0","parameters":[{"name":"prompt","summary":"Command prompt."},{"name":"acceptNothing","summary":"If true, the user can press enter."},{"name":"offPrompt","summary":"The \'false/off\' message."},{"name":"onPrompt","summary":"The \'true/on\' message."},{"name":"boolValue","summary":"Default Boolean value set to this and returned here."}],"returns":"The getter result based on user choice.  \\nCommands.Result.Success - got value.  \\nCommands.Result.Nothing - user pressed enter.  \\nCommands.Result.Cancel - user canceled value getting."},{"signature":"static Result GetBox(out Box box)","summary":"Asks the user to select a Box in the viewport.","since":"5.0","parameters":[{"name":"box","summary":"If the result is Success, this parameter will be filled out."}],"returns":"Commands.Result.Success if successful."},{"signature":"static Result GetBox(out Box box, GetBoxMode mode, Point3d basePoint, string prompt1, string prompt2, string prompt3)","summary":"Asks the user to select a Box in the viewport.","since":"5.0","parameters":[{"name":"box","summary":"If the result is Success, this parameter will be filled out."},{"name":"mode","summary":"A particular \\"get box\\" mode, or GetBoxMode.All."},{"name":"basePoint","summary":"Optional base point. Supply Point3d.Unset if you don\'t want to use this."},{"name":"prompt1","summary":"Optional first prompt. Supply None to use the default prompt."},{"name":"prompt2","summary":"Optional second prompt. Supply None to use the default prompt."},{"name":"prompt3","summary":"Optional third prompt. Supply None to use the default prompt."}],"returns":"Commands.Result.Success if successful."},{"signature":"static Result GetBoxWithCounts(int xMin, ref int xCount, int yMin, ref int yCount, int zMin, ref int zCount, out Point3d[] corners)","summary":"Gets a 3d box with prompts for counts in X, Y and Z directions.","since":"6.0","parameters":[{"name":"xMin","summary":"Minimum value allowed for count in the x direction."},{"name":"xCount","summary":"Count in the x direction."},{"name":"yMin","summary":"Minimum value allowed for count in the y direction."},{"name":"yCount","summary":"Count in the y direction."},{"name":"zMin","summary":"Minimum value allowed for count in the z direction."},{"name":"zCount","summary":"Count in the z direction."},{"name":"corners","summary":"corners of the bottom rectangle in counter-clockwise order, followed by top rectangle."}],"returns":"Commands.Result.Success if successful."},{"signature":"static Result GetCircle(out Circle circle)","since":"5.0"},{"signature":"static Result GetColor(string prompt, bool acceptNothing, ref Color color)","summary":"Easy to use color getter.","since":"5.0","parameters":[{"name":"prompt","summary":"Command prompt."},{"name":"acceptNothing","summary":"If true, the user can press enter."},{"name":"color","summary":"Color value returned here. also used as default color."}],"returns":"Commands.Result.Success - got color.  \\nCommands.Result.Nothing - user pressed enter.  \\nCommands.Result.Cancel - user cancel color getting."},{"signature":"static string GetFileName(GetFileNameMode mode, string defaultName, string title, object parent)","since":"6.0"},{"signature":"static string GetFileName(GetFileNameMode mode, string defaultName, string title, object parent, BitmapFileTypes fileTypes)","since":"6.0"},{"signature":"static string GetFileNameScripted(GetFileNameMode mode, string defaultName)","since":"5.0"},{"signature":"static Result GetGrip(out GripObject grip, string prompt)","since":"5.0"},{"signature":"static Result GetGrips(out GripObject[] grips, string prompt)","since":"5.0"},{"signature":"static Result GetHelix(out NurbsCurve helix)","since":"5.0"},{"signature":"static Result GetInteger(string prompt, bool acceptNothing, ref int outputNumber)","summary":"Easy to use number getter.","since":"5.0","parameters":[{"name":"prompt","summary":"command prompt."},{"name":"acceptNothing","summary":"if true, the user can press enter."},{"name":"outputNumber","summary":"default number is set to this value and number value returned here."}],"returns":"Commands.Result.Success - got number Commands.Result.Nothing - user pressed enter Commands.Result.Cancel - user cancel number getting."},{"signature":"static Result GetInteger(string prompt, bool acceptNothing, ref int outputNumber, int lowerLimit, int upperLimit)","summary":"Easy to use number getter.","since":"5.0","parameters":[{"name":"prompt","summary":"The command prompt."},{"name":"acceptNothing","summary":"If true, the user can press enter."},{"name":"outputNumber","summary":"default number is set to this value and number value returned here."},{"name":"lowerLimit","summary":"The minimum allowed value."},{"name":"upperLimit","summary":"The maximum allowed value."}],"returns":"Commands.Result.Success - got number Commands.Result.Nothing - user pressed enter Commands.Result.Cancel - user cancel number getting."},{"signature":"static Result GetLine(out Line line)","since":"5.0"},{"signature":"static Result GetLinearDimension(out LinearDimension dimension)","since":"5.0"},{"signature":"static Result GetMeshParameters(RhinoDoc doc, ref MeshingParameters parameters, ref int uiStyle)","summary":"Asks the user to specify meshing parameters.","since":"7.0","parameters":[{"name":"doc","summary":"The active document"},{"name":"parameters","summary":"The initial meshing parameters. If successful, the updated meshing parameters are returned here."},{"name":"uiStyle","summary":"The user interface style, where: 0 = simple dialog, 1 = details dialog, 2 = script or batch mode."}],"returns":"Commands.Result.Success if successful."},{"signature":"static Result GetMultipleObjects(string prompt, bool acceptNothing, GetObjectGeometryFilter filter, out ObjRef[] rhObjects)","summary":"Easy to use object getter for getting multiple objects.","since":"5.0","parameters":[{"name":"prompt","summary":"command prompt."},{"name":"acceptNothing","summary":"if true, the user can press enter."},{"name":"filter","summary":"geometry filter to use when getting objects."},{"name":"rhObjects","summary":"result of the get. may be null."}],"returns":"Commands.Result.Success - got object Commands.Result.Nothing - user pressed enter Commands.Result.Cancel - user cancel object getting."},{"signature":"static Result GetMultipleObjects(string prompt, bool acceptNothing, ObjectType filter, out ObjRef[] rhObjects)","summary":"Easy to use object getter for getting multiple objects.","since":"5.0","parameters":[{"name":"prompt","summary":"command prompt."},{"name":"acceptNothing","summary":"if true, the user can press enter."},{"name":"filter","summary":"geometry filter to use when getting objects."},{"name":"rhObjects","summary":"result of the get. may be null."}],"returns":"Commands.Result.Success - got object Commands.Result.Nothing - user pressed enter Commands.Result.Cancel - user cancel object getting."},{"signature":"static Result GetNumber(string prompt, bool acceptNothing, ref double outputNumber)","summary":"Easy to use number getter.","since":"5.0","parameters":[{"name":"prompt","summary":"command prompt."},{"name":"acceptNothing","summary":"if true, the user can press enter."},{"name":"outputNumber","summary":"default number is set to this value and number value returned here."}],"returns":"Commands.Result.Success - got number Commands.Result.Nothing - user pressed enter Commands.Result.Cancel - user cancel number getting."},{"signature":"static Result GetNumber(string prompt, bool acceptNothing, ref double outputNumber, double lowerLimit, double upperLimit)","summary":"Easy to use number getter.","since":"5.0","parameters":[{"name":"prompt","summary":"The command prompt."},{"name":"acceptNothing","summary":"If true, the user can press Enter."},{"name":"outputNumber","summary":"Default number is set to this value and the return number value is assigned to this variable during the call."},{"name":"lowerLimit","summary":"The minimum allowed value."},{"name":"upperLimit","summary":"The maximum allowed value."}],"returns":"Commands.Result.Success - got number.  \\nCommands.Result.Nothing - user pressed enter.  \\nCommands.Result.Cancel - user cancel number getting."},{"signature":"static Result GetOneObject(string prompt, bool acceptNothing, GetObjectGeometryFilter filter, out ObjRef objref)","summary":"Easy to use object getter.","since":"5.0","parameters":[{"name":"prompt","summary":"command prompt."},{"name":"acceptNothing","summary":"if true, the user can press enter."},{"name":"filter","summary":"geometry filter to use when getting objects."},{"name":"objref","summary":"result of the get. may be null."}],"returns":"Commands.Result.Success - got object Commands.Result.Nothing - user pressed enter Commands.Result.Cancel - user cancel object getting."},{"signature":"static Result GetOneObject(string prompt, bool acceptNothing, ObjectType filter, out ObjRef rhObject)","summary":"Easy to use object getter.","since":"5.0","parameters":[{"name":"prompt","summary":"command prompt."},{"name":"acceptNothing","summary":"if true, the user can press enter."},{"name":"filter","summary":"geometry filter to use when getting objects."},{"name":"rhObject","summary":"result of the get. may be null."}],"returns":"Commands.Result.Success - got object Commands.Result.Nothing - user pressed enter Commands.Result.Cancel - user cancel object getting."},{"signature":"static Result GetPlane(out Plane plane)","summary":"Gets an oriented infinite plane.","since":"5.0","parameters":[{"name":"plane","summary":"The plane result."}],"returns":"Commands.Result.Success - got plane.  \\nCommands.Result.Nothing - user pressed enter.  \\nCommands.Result.Cancel - user cancel number getting."},{"signature":"static Result GetPoint(string prompt, bool acceptNothing, out Point3d point)","summary":"Gets a point coordinate from the document.","since":"5.0","parameters":[{"name":"prompt","summary":"Prompt to display in command line during the operation."},{"name":"acceptNothing","summary":"if true, the user can press enter."},{"name":"point","summary":"point value returned here."}],"returns":"Commands.Result.Success - got point Commands.Result.Nothing - user pressed enter Commands.Result.Cancel - user cancel point getting."},{"signature":"static Result GetPointOnMesh(Guid meshObjectId, string prompt, bool acceptNothing, out Point3d point)","summary":"Gets a point constrained to an existing mesh in the document.","since":"5.0","parameters":[{"name":"meshObjectId","summary":"An ID of a mesh in the document."},{"name":"prompt","summary":"Text prompt."},{"name":"acceptNothing","summary":"True if nothing else should be accepted."},{"name":"point","summary":"A point value will be assigned to this out parameter during this call."}],"returns":"A command result based on user choice."},{"signature":"static Result GetPointOnMesh(MeshObject meshObject, string prompt, bool acceptNothing, out Point3d point)","summary":"Gets a point constrained to an existing mesh in the document.","since":"5.0","parameters":[{"name":"meshObject","summary":"An mesh object in the document."},{"name":"prompt","summary":"Text prompt."},{"name":"acceptNothing","summary":"True if nothing else should be accepted."},{"name":"point","summary":"A point value will be assigned to this out parameter during this call."}],"returns":"The command result based on user choice."},{"signature":"static Result GetPolygon(ref int numberSides, ref bool inscribed, out Polyline polyline)","since":"6.0"},{"signature":"static Result GetPolyline(out Polyline polyline)","since":"5.9"},{"signature":"static Result GetPrintWindow(ref ViewCaptureSettings settings)","since":"6.1"},{"signature":"static Result GetRectangle(GetBoxMode mode, Point3d firstPoint, IEnumerable<string> prompts, out Point3d[] corners)","summary":"Gets a 3d rectangle made up of four points.","since":"5.0","parameters":[{"name":"mode","summary":"A get box mode."},{"name":"firstPoint","summary":"The first corner used. Pass Point3d.Unset if you do not want to set this."},{"name":"prompts","summary":"Optional prompts to display while getting points. May be null."},{"name":"corners","summary":"Corners of the rectangle in counter-clockwise order will be assigned to this out parameter during this call."}],"returns":"Commands.Result.Success if successful."},{"signature":"static Result GetRectangle(out Point3d[] corners)","summary":"Gets a 3d rectangle.","since":"5.0","parameters":[{"name":"corners","summary":"corners of the rectangle in counter-clockwise order."}],"returns":"Commands.Result.Success if successful."},{"signature":"static Result GetRectangle(string firstPrompt, out Point3d[] corners)","summary":"Gets a 3d rectangle.","since":"6.0","parameters":[{"name":"firstPrompt","summary":""},{"name":"corners","summary":"corners of the rectangle in counter-clockwise order."}],"returns":"Commands.Result.Success if successful."},{"signature":"static Result GetRectangleWithCounts(int xMin, ref int xCount, int yMin, ref int yCount, out Point3d[] corners)","summary":"Gets a 3d rectangle with prompts for counts in X and Y directions.","since":"6.0","parameters":[{"name":"xMin","summary":"Minimum value allowed for count in the x direction."},{"name":"xCount","summary":"Count in the x direction."},{"name":"yMin","summary":"Minimum value allowed for count in the y direction."},{"name":"yCount","summary":"Count in the y direction."},{"name":"corners","summary":"corners of the rectangle in counter-clockwise order."}],"returns":"Commands.Result.Success if successful."},{"signature":"static Result GetSpiral(out NurbsCurve spiral)","since":"5.0"},{"signature":"static Result GetString(string prompt, bool acceptNothing, ref string outputString)","summary":"Easy to use string getter.","since":"5.0","parameters":[{"name":"prompt","summary":"command prompt."},{"name":"acceptNothing","summary":"if true, the user can press enter."},{"name":"outputString","summary":"default string set to this value and string value returned here."}],"returns":"Commands.Result.Success - got string Commands.Result.Nothing - user pressed enter Commands.Result.Cancel - user cancel string getting."},{"signature":"static Result GetView(string commandPrompt, out RhinoView view)","summary":"Allows the user to interactively pick a viewport.","since":"5.0","parameters":[{"name":"commandPrompt","summary":"The command prompt during the request."},{"name":"view","summary":"The view that the user picked.  \\nIf the operation is successful, then this out parameter is assigned the correct view during this call."}],"returns":"The result based on user choice."},{"signature":"static bool InGet(RhinoDoc doc)","summary":"Returns True if the document is current in a \\"Get\\" operation.","since":"5.0","returns":"True if a getter is currently active."},{"signature":"static bool InGetObject(RhinoDoc doc)","summary":"Returns True if currently in a GetObject.GetObjects()","since":"6.0"},{"signature":"static bool InGetPoint(RhinoDoc doc)","summary":"Returns True if currently in a GetPoint.Get()","since":"6.0"},{"signature":"static string StringToCommandOptionName(string stringToConvert)","summary":"Convert some arbitrary string value to a valid command option name removing any invalid characters.","since":"6.0","parameters":[{"name":"stringToConvert","summary":"String to convert."}],"returns":"Returns None if the string is None or empty or if it contains nothing but invalid characters.  If the converted string is one or more characters in length then the converted value is returned."},{"signature":"static LocalizeStringPair StringToCommandOptionName(string englishString, string localizedString)","summary":"Convert some arbitrary string value to a valid command option name removing any invalid characters.","since":"6.0","parameters":[{"name":"englishString","summary":"English string to convert."},{"name":"localizedString","summary":"Optional localized string to convert."}],"returns":"Returns None if the strings are None or empty or if they contain nothing but invalid characters.  If the converted string is one or more characters in length then a LocalizeStringPairis returned characters the converted string values.  If the localized string is None or empty then the English string is used as the localized value."}]},{"namespace":"Rhino.Input","name":"RhinoGet.BitmapFileTypes","dataType":"enum","since":"6.0","values":[{"signature":"bmp = 1"},{"signature":"jpg = 2"},{"signature":"pcx = 4"},{"signature":"png = 8"},{"signature":"tif = 16"},{"signature":"tga = 32"}]},{"namespace":"Rhino.Input","name":"StringParser","dataType":"class","summary":"Parse strings to numbers, distances and angles","methods":[{"signature":"static int ParseAngleExpession(string expression, int start_offset, int expression_length, StringParserSettings parse_settings_in, AngleUnitSystem output_angle_unit_system, out double value_out, ref StringParserSettings parse_results, ref AngleUnitSystem parsed_unit_system)","since":"6.0"},{"signature":"static bool ParseAngleExpressionDegrees(string expression, out double angle_degrees)","since":"6.0"},{"signature":"static bool ParseAngleExpressionRadians(string expression, out double angle_radians)","since":"6.0"},{"signature":"static int ParseLengthExpession(string expression, int start_offset, int expression_length, StringParserSettings parse_settings_in, UnitSystem output_unit_system, out double value_out, ref StringParserSettings parse_results, ref UnitSystem parsed_unit_system)","summary":"Parse a string for a length value. Expression can include complex expressions Most complex version of length parsing","since":"6.0","parameters":[{"name":"expression","summary":"[In] The string to parse"},{"name":"start_offset","summary":"[In] Offset position in string to start parsing"},{"name":"expression_length","summary":"[In] Maximum length of string to parse. -1 means parse to a terminating character or end of string"},{"name":"parse_settings_in","summary":"[In] Determines what input will be parsed"},{"name":"output_unit_system","summary":"[In] Output value is returned in this unit system"},{"name":"value_out","summary":"[Out] The length value result"},{"name":"parse_results","summary":"[Out] Describes the results of the parse operation"},{"name":"parsed_unit_system","summary":"[Out] If a unit system name was found in the string, it is returned here. The output value is in the unit system specified in output_unit_system"}],"returns":"Returns the count of characters that were parsed or 0 if the operation was unsuccessful"},{"signature":"static int ParseLengthExpession(string expression, StringParserSettings parse_settings_in, UnitSystem output_unit_system, out double value_out)","summary":"Parse a string for a length value. Expression can include complex expressions Simplest version of Length parsing","since":"6.0","parameters":[{"name":"expression","summary":"[In] The string to parse"},{"name":"parse_settings_in","summary":"[In] Determines what input will be parsed"},{"name":"output_unit_system","summary":"[In] Output value is in this unit system"},{"name":"value_out","summary":"[Out] The length value result"}],"returns":"Count of characters parsed or 0 for failure"},{"signature":"static int ParseNumber(string expression, int max_count, StringParserSettings settings_in, ref StringParserSettings settings_out, out double answer)","summary":"Parse a string expression to get a number","since":"6.0","parameters":[{"name":"expression","summary":"String to parse"},{"name":"max_count","summary":"Maximum number of characters to parse"},{"name":"settings_in","summary":"Determines what input will be parsed"},{"name":"settings_out","summary":"Reports the results of the parse operation"},{"name":"answer","summary":"The number result of the parse operation"}],"returns":"Count of characters in expression parsed if ParseNumber() returns 0, parse was unsuccessful"}]},{"namespace":"Rhino.Input","name":"StringParserSettings","dataType":"class","summary":"Parameters for parsing strings","interfaces":["IDisposable"],"constructors":[{"signature":"StringParserSettings()","since":"6.0"}],"properties":[{"signature":"static StringParserSettings DefaultParseSettings","summary":"- The default settings parse just about everything in a reasonable way. - Any angle values with unspecified units will be treated as radians. Angles without units can be encountered while parsing formulas, lengths and points and need to be thoughtfully considered in most parsing situations.","since":"6.0","property":["get"]},{"signature":"static StringParserSettings ParseSettingsDegrees","summary":"- The default settings parse just about everything in a reasonable way. - Any angle values with unspecified units will be treated as degrees.Angles without units can be encountered while parsing formulas, lengths and points and need to be thoughtfully considered in most parsing situations.","since":"6.0","property":["get"]},{"signature":"static StringParserSettings ParseSettingsDoubleNumber","summary":"- The double number settings parse and optional unary + or unary - and then parse a number that can be integer, decimal, or scientific e notation.","since":"6.0","property":["get"]},{"signature":"static StringParserSettings ParseSettingsEmpty","summary":"- ON_ParseSetting::FalseSettings has all parsing options set to false. - A common use of ON_ParseSettings FalseSettings is to initialize ON_ParseSettings classes that are used to report what happened during parsing.Any parsing results value set to True after parsing indicates that type of parsing occurred.","since":"6.0","property":["get"]},{"signature":"static StringParserSettings ParseSettingsIntegerNumber","summary":"- The integer settings parse and optional unary + or unary - and then parses one or more digits.Parsing stops after the last digit.","since":"6.0","property":["get"]},{"signature":"static StringParserSettings ParseSettingsRadians","summary":"- The default settings parse just about everything in a reasonable way. - Any angle values with unspecified units will be treated as radians.Angles without units can be encountered while parsing formulas, lengths and points and need to be thoughtfully considered in most parsing situations.","since":"6.0","property":["get"]},{"signature":"static StringParserSettings ParseSettingsRationalNumber","summary":"- The rational number settings parse and optional unary + or unary - and then parse one or more digits.If a rational number fraction bar follows the last digit in the numerator, then it is parsed and an integer denominator is parsed.The denominator cannot have a unary + or - preceding the digits.Parsing stops after the last digit in the denominator.","since":"6.0","property":["get"]},{"signature":"static StringParserSettings ParseSettingsRealNumber","summary":"- The real number settings parse and optional unary + or unary - and then parse a number that can be integer, decimal, scientific e notation or pi.","since":"6.0","property":["get"]},{"signature":"AngleUnitSystem DefaultAngleUnitSystem","since":"6.0","property":["get","set"]},{"signature":"UnitSystem DefaultLengthUnitSystem","since":"6.0","property":["get","set"]},{"signature":"bool ParseAddition","since":"6.0","property":["get","set"]},{"signature":"bool ParseArcDegreesMinutesSeconds","since":"6.0","property":["get","set"]},{"signature":"bool ParseArithmeticExpression","since":"6.0","property":["get","set"]},{"signature":"bool ParseCommaAsDecimalPoint","since":"6.0","property":["get","set"]},{"signature":"bool ParseCommaAsDigitSeparator","since":"6.0","property":["get","set"]},{"signature":"bool ParseDAsExponentInScientificENotation","since":"6.0","property":["get","set"]},{"signature":"bool ParseDivision","since":"6.0","property":["get","set"]},{"signature":"bool ParseExplicitFormulaExpression","since":"6.0","property":["get","set"]},{"signature":"bool ParseFeetInches","since":"6.0","property":["get","set"]},{"signature":"bool ParseFullStopAsDecimalPoint","since":"6.0","property":["get","set"]},{"signature":"bool ParseFullStopAsDigitSeparator","since":"6.0","property":["get","set"]},{"signature":"bool ParseHyphenAsNumberDash","since":"6.0","property":["get","set"]},{"signature":"bool ParseHyphenMinusAsNumberDash","since":"6.0","property":["get","set"]},{"signature":"bool ParseIntegerDashFraction","since":"6.0","property":["get","set"]},{"signature":"bool ParseLeadingWhiteSpace","since":"6.0","property":["get","set"]},{"signature":"bool ParseMathFunctions","since":"6.0","property":["get","set"]},{"signature":"bool ParseMultiplication","since":"6.0","property":["get","set"]},{"signature":"bool ParsePairedParentheses","since":"6.0","property":["get","set"]},{"signature":"bool ParsePi","since":"6.0","property":["get","set"]},{"signature":"bool ParseRationalNumber","since":"6.0","property":["get","set"]},{"signature":"bool ParseScientificENotation","since":"6.0","property":["get","set"]},{"signature":"bool ParseSignificandDigitSeparators","since":"6.0","property":["get","set"]},{"signature":"bool ParseSignificandFractionalPart","since":"6.0","property":["get","set"]},{"signature":"bool ParseSignificandIntegerPart","since":"6.0","property":["get","set"]},{"signature":"bool ParseSpaceAsDigitSeparator","since":"6.0","property":["get","set"]},{"signature":"bool ParseSubtraction","since":"6.0","property":["get","set"]},{"signature":"bool ParseSurveyorsNotation","since":"6.0","property":["get","set"]},{"signature":"bool ParseUnaryMinus","since":"6.0","property":["get","set"]},{"signature":"bool ParseUnaryPlus","since":"6.0","property":["get","set"]},{"signature":"uint PreferedLocaleId","since":"6.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","since":"6.0"},{"signature":"void SetAllExpressionSettingsToFalse()","since":"6.0"},{"signature":"void SetAllFieldsToFalse()","since":"6.0"}]},{"namespace":"Rhino","name":"IRhinoDocObserver","dataType":"interface","summary":"Implement this interface if you are a modeless interface to aid in handling multiple document implementations","methods":[{"signature":"void ActiveRhinoDocChanged(RhinoDocObserverArgs e)","summary":"In Windows Rhino this will mean a new document has been created or opened.  In Mac Rhino this can mean the same thing as well it can indicate switching from one active open document to another.","since":"6.0"},{"signature":"void RhinoDocClosed(RhinoDocObserverArgs e)","summary":"When a document is closed","since":"6.0"}]},{"namespace":"Rhino","name":"LengthValue","dataType":"class","summary":"Represents a length with an associated unit system and a string representation of that length. This allows for going back and forth from numerical representation of a length and a string representation without \\"guessing\\" at the initial string","interfaces":["IDisposable"],"properties":[{"signature":"AngleUnitSystem ContextAngleUnitSystem","summary":"Returns the context AngleUnitSystem from this LengthValue\'s ParseSettings","since":"6.0","property":["get"]},{"signature":"uint ContextLocaleId","summary":"returns the context LocaleId from this LengthValue","since":"6.0","property":["get"]},{"signature":"string LengthString","summary":"Return length as a string","since":"6.0","property":["get"]},{"signature":"StringFormat LengthStringFormat","summary":"Returns the StringFormat from this LengthValue","since":"6.0","property":["get"]},{"signature":"StringParserSettings ParseSettings","summary":"Parse settings","since":"6.0","property":["get"]},{"signature":"UnitSystem UnitSystem","summary":"UnitSystem used by this LengthValue","since":"6.0","property":["get"]}],"methods":[{"signature":"static LengthValue Create(double length, UnitSystem us, StringFormat format)","summary":"Create from Length and UnitSystem","since":"6.0","parameters":[{"name":"length","summary":"Numeric length value"},{"name":"us","summary":"Unit system"},{"name":"format","summary":""}]},{"signature":"static LengthValue Create(double length, UnitSystem us, StringFormat format, uint localeId)","summary":"Create from Length and UnitSystem","since":"6.0","parameters":[{"name":"length","summary":"Numeric length value"},{"name":"us","summary":"Unit system"},{"name":"format","summary":""},{"name":"localeId","summary":""}]},{"signature":"static LengthValue Create(string s, StringParserSettings ps, out bool parsedAll)","summary":"Create from string","since":"6.0","parameters":[{"name":"s","summary":"string to parse"},{"name":"ps","summary":""},{"name":"parsedAll","summary":"True if the whole string was parsed"}]},{"signature":"LengthValue ChangeLength(double newLength)","summary":"Changes the numeric value in a LengthValue and leaves all of the other info unchanged UnitSystem, ParseSettings and StringFormat stay as they were","since":"6.0","returns":"A new LengthValue"},{"signature":"LengthValue ChangeUnitSystem(UnitSystem newUnits)","summary":"Change the UnitSystem of a LengthValue The numeric value of Length is scaled by new_us / current unit system so that the absolute length stays the same","since":"6.0"},{"signature":"void Dispose()","summary":"actively reclaim native allocated ON_LenghtValue*","since":"6.0"},{"signature":"bool IsUnset()","summary":"Test IsUnset","since":"6.0"},{"signature":"double Length()","summary":"Length value in this instance\'s current unit system","since":"6.0"},{"signature":"double Length(UnitSystem units)","summary":"Length value in a given unit system","since":"6.0"}]},{"namespace":"Rhino","name":"LengthValue.StringFormat","dataType":"enum","summary":"Formatting to apply when creating a length value from a double.","values":[{"signature":"ExactDecimal = 0","summary":"Use exact decimal string."},{"signature":"ExactProperFraction = 1","summary":"If possible, use exact integer-fraction format (1.125 becomes 1-1/8)."},{"signature":"ExactImproperFraction = 2","summary":"If possible, use exact fraction format (1.125 becomes 9/8)."},{"signature":"CleanDecimal = 3","summary":"The value may be adjusted slightly to improve clarity (1.124999... becomes 1.125)."},{"signature":"CleanProperFraction = 4","summary":"The value may be adjusted slightly to improve clarity (1.124999... becomes 1-1/8)."},{"signature":"CleanImproperFraction = 5","summary":"The value may be adjusted slightly to improve clarity (1.124999... becomes 9/8)."}]},{"namespace":"Rhino.NodeInCode","name":"ComponentFunctionInfo","dataType":"class","summary":"Defines the base class for a function representing a component. This class is abstract.","properties":[{"signature":"Guid ComponentGuid","summary":"The unique identifier of the Grasshopper component. It is the original developer\'s responsibility to ensure that this ID is unique.","since":"6.0","property":["get","set"]},{"signature":"Delegate Delegate","summary":"Returns a delegate that can be directly invoked using a list of arguments. This flattens trees.","since":"6.0","property":["get"]},{"signature":"Delegate DelegateNoWarnings","summary":"Returns a delegate that can be directly invoked using a list of arguments. This flattens trees.","since":"6.0","property":["get"]},{"signature":"Delegate DelegateTree","summary":"Returns a delegate that can be directly invoked using a list of arguments. This considers trees and simplifies single-output components.","since":"6.0","property":["get"]},{"signature":"Delegate DelegateTreeNoWarnings","summary":"Returns a delegate that can be directly invoked using a list of arguments. This considers trees and simplifies single-output components.","since":"6.0","property":["get"]},{"signature":"string Description","summary":"The function description.","since":"6.0","property":["get"]},{"signature":"string FullName","summary":"Returns the name of the component prefixed by, if existing, the namespace.","since":"6.0","property":["get"]},{"signature":"string FullScriptingName","summary":"Shows the full name of the component, including optional periods. Removes spaces and common operator signs.","since":"6.0","property":["get"]},{"signature":"IReadOnlyList<string> InputDescriptions","summary":"The function input parameter descriptions.","since":"6.0","property":["get"]},{"signature":"IReadOnlyList<string> InputNames","summary":"The function input parameter names.","since":"6.0","property":["get"]},{"signature":"IReadOnlyList<bool> InputsOptional","summary":"Indications for each function input parameter whether it is optional.","since":"6.0","property":["get"]},{"signature":"IReadOnlyList<string> InputTypeNames","summary":"The function input type names.","since":"6.0","property":["get"]},{"signature":"bool IsDefault","summary":"Determines if the component is a default one.","since":"6.0","property":["get"]},{"signature":"string Name","summary":"The function name.","since":"6.0","property":["get"]},{"signature":"string Namespace","summary":"The function namespace.","since":"6.0","property":["get"]},{"signature":"IReadOnlyList<string> OutputDescriptions","summary":"Grasshopper returns several items in general. This property returns the output descriptions.","since":"6.0","property":["get"]},{"signature":"IReadOnlyList<string> OutputNames","summary":"Grasshopper returns several items in general. This property returns the output names.","since":"6.0","property":["get"]},{"signature":"IReadOnlyList<string> OutputTypeNames","summary":"Grasshopper returns several items in general. This property returns the output type names.","since":"6.0","property":["get"]}],"methods":[{"signature":"object[] Evaluate(IEnumerable args, bool keepTree, out string[] warnings)","summary":"Evaluates the component with a set of arguments. There needs to be an argument for each input param, and each output param gives an entry in the output array.","since":"6.0","parameters":[{"name":"args","summary":"The arguments list. Each item is assigned to each input param, in order."},{"name":"keepTree","summary":"A value indicating whether trees should be considered valid inputs, and should be returned. In this case, output variables are not simplified to common types."},{"name":"warnings","summary":"A possible list of warnings, or null."}],"returns":"An array of objects, each representing an output result."},{"signature":"object[] Invoke(params object[] args)","summary":"Runs Evaluatewith keepTree equal to false, and raises an exception on the first warning.","since":"7.0","parameters":[{"name":"args","summary":"Arguments. One for each component input."}],"returns":"Items."},{"signature":"object[] InvokeKeepTree(params object[] args)","summary":"Runs Evaluatewith keepTree equal to True and raises an exception on the first warning.","since":"7.0","parameters":[{"name":"args","summary":"Arguments. One for each component input."}],"returns":"Items."},{"signature":"object[] InvokeKeepTreeSilenceWarnings(params object[] args)","summary":"Runs Evaluatewith keepTree equal to true, and discards warnings (this is a dangerous operation!).","since":"7.0","parameters":[{"name":"args","summary":"Arguments."}],"returns":"Array of items."},{"signature":"object[] InvokeSilenceWarnings(params object[] args)","summary":"Runs Evaluatewith keepTree equal to false, then simplifies output with SimplifyTreeOutputand discards warnings (this is a dangerous operation!).","since":"7.0","parameters":[{"name":"args","summary":"Arguments. One for each component input."}],"returns":"Items."},{"signature":"string ToString()","summary":"Returns a string representing this function.","returns":"The namespace and the name."}]},{"namespace":"Rhino.NodeInCode","name":"Components","dataType":"class","summary":"Provides access to all Grasshopper runtime components.","properties":[{"signature":"static NodeInCodeTable NodeInCodeFunctions","summary":"Returns a collection with all component functions.","since":"6.0","property":["get"]}],"methods":[{"signature":"static ComponentFunctionInfo FindComponent(string fullName)","summary":"Finds a component given its full name.","since":"6.0","parameters":[{"name":"fullName","summary":"The name, including its library name and a period if it is made by a third-party."}]}]},{"namespace":"Rhino.NodeInCode","name":"NodeInCodeTable","dataType":"class","summary":"Permits rapid access to references to all Grasshopper functions.","baseclass":"DynamicObject","constructors":[{"signature":"NodeInCodeTable(IEnumerable<ComponentFunctionInfo> items)","summary":"Instantiates the table. Users of RhinoCommon do not typically need to call this constructor.","since":"6.0","parameters":[{"name":"items","summary":"Items."}]}],"properties":[{"signature":"int Count","summary":"Returns the amount of items in this table.","since":"6.0","property":["get"]}],"methods":[{"signature":"void Add(ComponentFunctionInfo item)","summary":"Adds, or replaces a new instance of component function information.","since":"6.0"},{"signature":"IEnumerable<string> GetDynamicMemberNames()","summary":"Returns all additional names in the table.","since":"6.0"},{"signature":"bool TryGetIndex(GetIndexBinder binder, object[] indexes, out object result)","summary":"Gets the ComponentFunctionInfo at","since":"6.0","parameters":[{"name":"binder","summary":"The binder."},{"name":"indexes","summary":"ONE string index."},{"name":"result","summary":"The bound info."}]},{"signature":"bool TryGetMember(GetMemberBinder binder, out object result)","summary":"Dynamically binds the table to property-like access via its item names.","since":"6.0","parameters":[{"name":"binder","summary":"The dynamic binder."},{"name":"result","summary":"Returns the result."}]},{"signature":"bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)","summary":"Dynamically invokes a member of the table.","since":"6.0","parameters":[{"name":"binder","summary":"The binder."},{"name":"args","summary":"The arguments."},{"name":"result","summary":"The result."}],"returns":"True on success."}]},{"namespace":"Rhino","name":"PersistentSettings","dataType":"class","summary":"A dictionary of SettingValue items.","interfaces":["ISerializable"],"properties":[{"signature":"static PersistentSettings RhinoAppSettings","since":"6.14","property":["get"]},{"signature":"static string StringListRootKey","summary":"Adding this string to a string list when calling SetStringList will cause the ProgramData setting to get inserted at that location in the list.","since":"5.0","property":["get"]},{"signature":"ICollection<string> ChildKeys","summary":"Gets a collection containing the keys in the settings dictionary.","since":"6.0","property":["get"]},{"signature":"bool HiddenFromUserInterface","summary":"If False then values will appear in the EditOptions window","since":"6.0","property":["get","set"]},{"signature":"ICollection<string> Keys","summary":"Gets a collection containing the keys in the settings dictionary.","since":"6.0","property":["get"]}],"methods":[{"signature":"static PersistentSettings FromPlugInId(Guid pluginId)","since":"5.0"},{"signature":"PersistentSettings AddChild(string key)","summary":"Call this method to add a new child key, if the key is exists then the existing key is returned otherwise a new empty PersistentSettings child key is added and the new settings are returned.","since":"6.0","parameters":[{"name":"key","summary":"Key to add to the child dictionary."}],"returns":"If the key is exists then the existing key is returned otherwise a new empty PersistentSettingschild key is added and the new settings are returned."},{"signature":"void ClearChangedFlag()","since":"6.0"},{"signature":"bool ContainsChangedValues()","since":"6.0"},{"signature":"bool ContainsModifiedValues(PersistentSettings allUserSettings)","since":"5.0"},{"signature":"void DeleteChild(string key)","summary":"Call this method to delete a child settings key.","since":"6.0"},{"signature":"void DeleteItem(string key)","since":"5.0"},{"signature":"bool GetBool(string key)","since":"5.0"},{"signature":"bool GetBool(string key, bool defaultValue)","since":"5.0"},{"signature":"bool GetBool(string key, bool defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"byte GetByte(string key)","since":"5.0"},{"signature":"byte GetByte(string key, byte defaultValue)","since":"5.0"},{"signature":"byte GetByte(string key, byte defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"char GetChar(string key)","since":"5.0"},{"signature":"char GetChar(string key, char defaultValue)","since":"5.0"},{"signature":"char GetChar(string key, char defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"PersistentSettings GetChild(string key)","summary":"Call this method to get a nested settings PersistentSettings instance, will throw a KeyNotFoundExceptionexception if the key does not exist.","since":"6.0","parameters":[{"name":"key","summary":"Key name"}],"returns":"Returns persistent settings for the specified key or throws an exception if the key is invalid."},{"signature":"Color GetColor(string key)","since":"5.0"},{"signature":"Color GetColor(string key, Color defaultValue)","since":"5.0"},{"signature":"Color GetColor(string key, Color defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"DateTime GetDate(string key)","since":"5.0"},{"signature":"DateTime GetDate(string key, DateTime defaultValue)","since":"5.0"},{"signature":"DateTime GetDate(string key, DateTime defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"double GetDouble(string key)","since":"5.0"},{"signature":"double GetDouble(string key, double defaultValue)","since":"5.0"},{"signature":"double GetDouble(string key, double defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"T GetEnumValue(String key)","summary":"Get a stored enumerated value using a custom key.","since":"5.4"},{"signature":"T GetEnumValue(String key, T defaultValue)","summary":"Gets a stored enumerated value using a custom key, or return default value if not found.","since":"5.4"},{"signature":"T GetEnumValue(T defaultValue)","summary":"Get a stored enumerated value, or return default value if not found","since":"5.4"},{"signature":"Guid GetGuid(string key)","since":"6.0"},{"signature":"Guid GetGuid(string key, Guid defaultValue)","since":"6.0"},{"signature":"Guid GetGuid(string key, Guid defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"int GetInteger(string key)","since":"5.0"},{"signature":"int GetInteger(string key, int defaultValue)","since":"5.0"},{"signature":"int GetInteger(string key, int defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"int GetInteger(string key, int defaultValue, int bound, bool boundIsLower)","since":"6.0"},{"signature":"int GetInteger(string key, int defaultValue, int lowerBound, int upperBound)","since":"6.0"},{"signature":"System.Drawing.Point GetPoint(string key)","since":"5.0"},{"signature":"System.Drawing.Point GetPoint(string key, Point defaultValue)","since":"5.0"},{"signature":"System.Drawing.Point GetPoint(string key, Point defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"Point3d GetPoint3d(string key)","since":"5.0"},{"signature":"Point3d GetPoint3d(string key, Point3d defaultValue)","since":"5.0"},{"signature":"Point3d GetPoint3d(string key, Point3d defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"Rectangle GetRectangle(string key)","since":"5.0"},{"signature":"Rectangle GetRectangle(string key, Rectangle defaultValue)","since":"5.0"},{"signature":"Rectangle GetRectangle(string key, Rectangle defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool GetSettingIsHiddenFromUserInterface(string key)","summary":"Values read from all users settings files will be marked as read-only which will cause any future calls to Set... to fail.","since":"6.0","parameters":[{"name":"key","summary":"Key name for which to search."}],"returns":"Returns True if the setting is read-only otherwise false."},{"signature":"bool GetSettingIsHiddenFromUserInterface(string key, IEnumerable<string> legacyKeyList)","summary":"Values read from all users settings files will be marked as read-only which will cause any future calls to Set... to fail.","since":"6.0","parameters":[{"name":"key","summary":"Key name for which to search."},{"name":"legacyKeyList","summary":""}],"returns":"Returns True if the setting is read-only otherwise false."},{"signature":"bool GetSettingIsReadOnly(string key)","summary":"Values read from all users settings files will be marked as read-only which will cause any future calls to Set... to fail.","since":"6.0","parameters":[{"name":"key","summary":"Key name for which to search."}],"returns":"Returns True if the setting is read-only otherwise false."},{"signature":"Type GetSettingType(string key)","summary":"Gets the type of the last value passed to Set... or Get... for the specified setting.","since":"6.0","parameters":[{"name":"key","summary":"Key name for which to search."}],"returns":"Type of the last value passed to Set... or Get... for the specified setting."},{"signature":"Size GetSize(string key)","since":"5.0"},{"signature":"Size GetSize(string key, Size defaultValue)","since":"5.0"},{"signature":"Size GetSize(string key, Size defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"string GetString(string key)","since":"5.0"},{"signature":"string GetString(string key, string defaultValue)","since":"5.0"},{"signature":"string GetString(string key, string defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"KeyValuePair<string, string>[] GetStringDictionary(string key)","since":"6.0"},{"signature":"KeyValuePair<string, string>[] GetStringDictionary(string key, KeyValuePair<string, string>[] defaultValue)"},{"signature":"KeyValuePair<string, string>[] GetStringDictionary(string key, KeyValuePair<string, string>[] defaultValue, IEnumerable<string> legacyKeyList)"},{"signature":"string[] GetStringList(string key)","since":"5.0"},{"signature":"string[] GetStringList(string key, string[] defaultValue)","since":"5.0"},{"signature":"string[] GetStringList(string key, string[] defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"uint GetUnsignedInteger(string key)","since":"5.0"},{"signature":"uint GetUnsignedInteger(string key, uint defaultValue)","since":"5.0"},{"signature":"uint GetUnsignedInteger(string key, uint defaultValue, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"EventHandler<PersistentSettingsEventArgs<T>> GetValidator(string key)","summary":"Provides a way to find a ready-to-use validator for the PersistentSetting class for the given the key, or obtaining null.","since":"5.0","parameters":[{"name":"key","summary":"The name of the setting key."}],"returns":"A valid validator, or None if no validator was found."},{"signature":"void HideSettingFromUserInterface(string key)","since":"6.0"},{"signature":"void RegisterSettingsValidator(string key, EventHandler<PersistentSettingsEventArgs<T>> validator)","summary":"Sets a validator for a given key.  \\nNote to implementers: parameter T should be one of the supported types for the PersistentSettings class and should match the type associated with the key.  \\nThis method allows to use anonymous methods and lambda expressions.","parameters":[{"name":"key","summary":"The key to which to bind the validator."},{"name":"validator","summary":"A validator instance of your own class."}]},{"signature":"void SetBool(string key, bool value)","since":"5.0"},{"signature":"void SetByte(string key, byte value)","since":"5.0"},{"signature":"void SetChar(string key, char value)","since":"5.0"},{"signature":"void SetColor(string key, Color value)","since":"5.0"},{"signature":"void SetDate(string key, DateTime value)","since":"5.0"},{"signature":"void SetDefault(string key, bool value)","since":"5.0"},{"signature":"void SetDefault(string key, byte value)","since":"5.0"},{"signature":"void SetDefault(string key, char value)","since":"5.0"},{"signature":"void SetDefault(string key, Color value)","since":"5.0"},{"signature":"void SetDefault(string key, DateTime value)","since":"5.0"},{"signature":"void SetDefault(string key, double value)","since":"5.0"},{"signature":"void SetDefault(string key, Guid value)","since":"6.0"},{"signature":"void SetDefault(string key, int value)","since":"5.0"},{"signature":"void SetDefault(string key, KeyValuePair<string, string>[] value)"},{"signature":"void SetDefault(string key, Point value)","since":"5.0"},{"signature":"void SetDefault(string key, Point3d value)","since":"5.0"},{"signature":"void SetDefault(string key, Rectangle value)","since":"5.0"},{"signature":"void SetDefault(string key, Size value)","since":"5.0"},{"signature":"void SetDefault(string key, string value)","since":"5.0"},{"signature":"void SetDefault(string key, string[] value)","since":"5.0"},{"signature":"void SetDouble(string key, double value)","since":"5.0"},{"signature":"void SetEnumValue(String key, T value)","summary":"Set an enumerated value in the settings using a custom key","since":"5.4"},{"signature":"void SetEnumValue(T enumValue)","summary":"Set an enumerated value in the settings.","since":"5.4"},{"signature":"void SetGuid(string key, Guid value)","since":"6.0"},{"signature":"void SetInteger(string key, int value)","since":"5.0"},{"signature":"void SetPoint(string key, Point value)","since":"5.0"},{"signature":"void SetPoint3d(string key, Point3d value)","since":"5.0"},{"signature":"void SetRectangle(string key, Rectangle value)","since":"5.0"},{"signature":"void SetSize(string key, Size value)","since":"5.0"},{"signature":"void SetString(string key, string value)","since":"5.0"},{"signature":"void SetStringDictionary(string key, KeyValuePair<string, string>[] value)"},{"signature":"void SetStringList(string key, string[] value)","summary":"Including a item with the value of StringListRootKey will cause the ProgramData value to get inserted at that location in the list when calling GetStringList.","since":"5.0","parameters":[{"name":"key","summary":"The string key."},{"name":"value","summary":"An array of values to set."}]},{"signature":"void SetUnsignedInteger(string key, uint value)","since":"5.0"},{"signature":"bool TryGetBool(string key, out bool value)","since":"5.0"},{"signature":"bool TryGetBool(string key, out bool value, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool TryGetByte(string key, out byte value)","since":"5.0"},{"signature":"bool TryGetByte(string key, out byte value, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool TryGetChar(string key, out char value)","since":"5.0"},{"signature":"bool TryGetChar(string key, out char value, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool TryGetChild(string key, out PersistentSettings value)","summary":"Call this method to get a nested settings PersistentSettings instance, will return True if the key exists and value was set otherwise; will return False and value will be set to null.","since":"6.0","parameters":[{"name":"key","summary":"[in] Key name"},{"name":"value","summary":"[out] Will be set the child settings if the key is valid otherwise it will be null."}],"returns":"Returns True if the key exists and value was set otherwise; returns false."},{"signature":"bool TryGetColor(string key, out Color value)","since":"5.0"},{"signature":"bool TryGetColor(string key, out Color value, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool TryGetDate(string key, out DateTime value)","since":"5.0"},{"signature":"bool TryGetDate(string key, out DateTime value, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool TryGetDefault(string key, out bool value)","since":"5.0"},{"signature":"bool TryGetDefault(string key, out byte value)","since":"5.0"},{"signature":"bool TryGetDefault(string key, out char value)","since":"5.0"},{"signature":"bool TryGetDefault(string key, out Color value)","since":"5.0"},{"signature":"bool TryGetDefault(string key, out DateTime value)","since":"5.0"},{"signature":"bool TryGetDefault(string key, out double value)","since":"5.0"},{"signature":"bool TryGetDefault(string key, out int value)","since":"5.0"},{"signature":"bool TryGetDefault(string key, out Point3d value)","since":"5.0"},{"signature":"bool TryGetDefault(string key, out Rectangle value)","since":"5.0"},{"signature":"bool TryGetDefault(string key, out Size value)","since":"5.0"},{"signature":"bool TryGetDefault(string key, out string value)","since":"5.0"},{"signature":"bool TryGetDefault(string key, out string[] value)","since":"5.0"},{"signature":"bool TryGetDouble(string key, out double value)","since":"5.0"},{"signature":"bool TryGetDouble(string key, out double value, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool TryGetEnumValue(String key, out T enumValue)","summary":"Attempt to get the stored value for an enumerated setting using a custom key. Note: the enumerated value ALWAYS gets assigned! Be sure to check for success of this method to prevent erroneous use of the value.","since":"5.4","returns":"True if successful"},{"signature":"bool TryGetGuid(string key, out Guid value)","since":"6.0"},{"signature":"bool TryGetGuid(string key, out Guid value, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool TryGetInteger(string key, out int value)","since":"5.0"},{"signature":"bool TryGetInteger(string key, out int value, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool TryGetPoint(string key, out Point value)","since":"5.0"},{"signature":"bool TryGetPoint(string key, out Point value, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool TryGetPoint3d(string key, out Point3d value)","since":"5.0"},{"signature":"bool TryGetPoint3d(string key, out Point3d value, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool TryGetRectangle(string key, out Rectangle value)","since":"5.0"},{"signature":"bool TryGetRectangle(string key, out Rectangle value, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool TryGetSettingIsHiddenFromUserInterface(string key, out bool value)","summary":"Values read from all users settings files will be marked as read-only which will cause any future calls to Set... to fail.","since":"6.0","parameters":[{"name":"key","summary":"Key name for which to search."},{"name":"value","summary":"Value will be True if the setting is read-only otherwise false. setting."}]},{"signature":"bool TryGetSettingIsHiddenFromUserInterface(string key, out bool value, IEnumerable<string> legacyKeyList)","summary":"Values read from all users settings files will be marked as read-only which will cause any future calls to Set... to fail.","since":"6.0","parameters":[{"name":"key","summary":"Key name for which to search."},{"name":"value","summary":"Value will be True if the setting is read-only otherwise false. setting."},{"name":"legacyKeyList","summary":""}]},{"signature":"bool TryGetSettingIsReadOnly(string key, out bool value)","summary":"Values read from all users settings files will be marked as read-only which will cause any future calls to Set... to fail.","since":"6.0","parameters":[{"name":"key","summary":"Key name for which to search."},{"name":"value","summary":"Value will be True if the setting is read-only otherwise false. setting."}]},{"signature":"bool TryGetSettingType(string key, out Type type)","summary":"Get the type of the last value passed to Set... or Get... for the specified setting.","since":"6.0","parameters":[{"name":"key","summary":"Key name for which to search."},{"name":"type","summary":"Type of the last value passed to Set... or Get... for the specified setting."}]},{"signature":"bool TryGetSize(string key, out Size value)","since":"5.0"},{"signature":"bool TryGetSize(string key, out Size value, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool TryGetString(string key, out string value)","since":"5.0"},{"signature":"bool TryGetString(string key, out string value, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool TryGetStringDictionary(string key, out KeyValuePair<string, string>[] value)"},{"signature":"bool TryGetStringDictionary(string key, out KeyValuePair<string, string>[] value, IEnumerable<string> legacyKeyList)"},{"signature":"bool TryGetStringList(string key, out string[] value)","since":"5.0"},{"signature":"bool TryGetStringList(string key, out string[] value, IEnumerable<string> legacyKeyList)","since":"6.0"},{"signature":"bool TryGetUnsignedInteger(string key, out uint value)","since":"5.0"},{"signature":"bool TryGetUnsignedInteger(string key, out uint value, IEnumerable<string> legacyKeyList)","since":"6.0"}]},{"namespace":"Rhino","name":"PersistentSettingsConverter","dataType":"class","summary":"Used to convert string to string lists and string dictionaries and back to strings again.","methods":[{"signature":"static bool IsStringDictionary(string s)","summary":"Determines if the string value is formatted as a key value pair string list.","since":"6.0","parameters":[{"name":"s","summary":"String to check"}],"returns":"Returns True if it is a XML key value pair list otherwise return false."},{"signature":"static bool IsStringList(string s)","summary":"Determines if the string value is formatted as a string list.","since":"6.0","parameters":[{"name":"s","summary":"String to check"}],"returns":"Returns True if it is a XML string list otherwise return false."},{"signature":"static string ToString(double value)","summary":"Converts a double value to a string.","since":"6.10","parameters":[{"name":"value","summary":"double value"}],"returns":"Returns the double value as a settings file formatted string."},{"signature":"static string ToString(KeyValuePair<string, string>[] value)","summary":"Converts a key value string pair array to a properly formatted string dictionary XML string.","parameters":[{"name":"value","summary":"List of string pairs to turn into a dictionary XML string."}],"returns":"Returns a properly formatted XML string that represents the string dictionary."},{"signature":"static string ToString(string[] values)","summary":"Converts a string array to a properly formatted string list XML string.","since":"6.0","parameters":[{"name":"values","summary":"List of strings to turn into a string list XML string."}],"returns":"Returns a properly formatted XML string that represents the list of strings."},{"signature":"static bool TryParseDouble(string s, out double value)","summary":"Converts the string representation of a number to its double-precision floating-point number equivalent. A return value indicates whether the conversion succeeded or failed. system culture.","since":"6.10","parameters":[{"name":"s","summary":"A string containing a number to convert."},{"name":"value","summary":"When this method returns, contains the double-precision floating-point number equivalent of the s parameter, if the conversion succeeded, or zero if the conversion failed. The conversion fails if the s parameter is None or Empty, is not a number in a valid format, or represents a number less than MinValue or greater than MaxValue. This parameter is passed uninitialized; any value originally supplied in result will be overwritten."}],"returns":"Returns True if s was converted successfully; otherwise, false.."},{"signature":"static bool TryParseEnum(Type type, string enumValueName, out int value)","summary":"Converts an enumerated value name to its integer equivalent.","since":"6.0","parameters":[{"name":"type","summary":"The enumerated type"},{"name":"enumValueName","summary":"Enumerated value name as string"},{"name":"value","summary":"Output value, will get set to -1 on error"}],"returns":"Returns True if the successfully converted or False if not."},{"signature":"static bool TryParseEnum(Type type, string intValueAsString, out string value)","summary":"Converts an enumerated value string (integer as string) to a enumerated value name.","since":"6.0","parameters":[{"name":"type","summary":"The enumerated type"},{"name":"intValueAsString","summary":"enumerated integer value as string"},{"name":"value","summary":"Output value, will be None on error"}],"returns":"Returns True if the successfully converted or False if not."},{"signature":"static bool TryParseStringDictionary(string s, out KeyValuePair<string, string>[] value)","summary":"Attempts to convert a string to a key value string pair array.","parameters":[{"name":"s","summary":"String to parse"},{"name":"value","summary":"Result will get copied here, if the string is None or empty then this will be an empty array, if there was an error parsing then this will be None otherwise it will be the string parsed as a key value string pair array."}],"returns":"Returns True if the string is not empty and properly formatted as a key value string pair list otherwise returns false."},{"signature":"static bool TryParseStringList(string s, out string[] value)","summary":"Attempts to convert a string to a string value list.","since":"6.0","parameters":[{"name":"s","summary":"String to parse"},{"name":"value","summary":"Result will get copied here, if the string is None or empty then this will be an empty list, if there was an error parsing then this will be None otherwise it will be the string parsed as a list."}],"returns":"Returns True if the string is not empty and properly formatted as a string list otherwise returns false."}]},{"namespace":"Rhino","name":"PersistentSettingsEventArgs","dataType":"class","summary":"Represents event data that is passed as state in persistent settings events.","baseclass":"EventArgs","properties":[{"signature":"bool Cancel","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino","name":"PersistentSettingsEventArgs<T>","dataType":"class","summary":"Represents the persistent settings modification event arguments.","baseclass":"Rhino.PersistentSettingsEventArgs","constructors":[{"signature":"PersistentSettingsEventArgs<T>(T currentValue, T newValue)"}],"properties":[{"signature":"T CurrentValue","property":["get","set"]},{"signature":"T NewValue","property":["get","set"]}]},{"namespace":"Rhino","name":"PersistentSettingsSavedEventArgs","dataType":"class","summary":"Event argument passed to the Rhino.PlugIns.PlugIn.SettingsSavedevent.","baseclass":"EventArgs","properties":[{"signature":"PersistentSettings PlugInSettings","summary":"The old PlugIn settings","since":"6.0","property":["get"]},{"signature":"bool SavedByThisRhino","summary":"Will be True if this instance of Rhino is writing the settings file or False if a different instance of Rhino has modified the settings file.","since":"6.0","property":["get","set"]}],"methods":[{"signature":"PersistentSettings CommandSettings(string englishCommandName)","summary":"The new command settings","since":"6.0","parameters":[{"name":"englishCommandName","summary":"English command to find settings for"}]}]},{"namespace":"Rhino.PlugIns","name":"CustomRenderSaveFileTypes","dataType":"class","methods":[{"signature":"void RegisterFileType(IEnumerable<string> extensions, string description, SaveFileHandler saveFileHandler)","summary":"Call this method to register a custom file save type with the render output window save dialog.","since":"5.11","parameters":[{"name":"extensions","summary":"List of one or more file extension associated with this custom type, for example: HDR, HDRI"},{"name":"description","summary":"File extension description which appears in the file save dialog file type combo box."},{"name":"saveFileHandler","summary":""}]}]},{"namespace":"Rhino.PlugIns","name":"DescriptionType","dataType":"enum","summary":"Rhino plug-in developer information fields.","since":"5.0","values":[{"signature":"Organization"},{"signature":"Address"},{"signature":"Country"},{"signature":"Phone"},{"signature":"WebSite"},{"signature":"Email"},{"signature":"UpdateUrl"},{"signature":"Fax"},{"signature":"Icon"}]},{"namespace":"Rhino.PlugIns","name":"DigitizerPlugIn","dataType":"class","summary":"A Rhino plug-in that interfaces with 3-D digitizing or input devices.","baseclass":"Rhino.PlugIns.PlugIn","methods":[{"signature":"void SendPoint(Point3d point, MouseButton mousebuttons, bool shiftKey, bool controlKey)","summary":"If the digitizer is enabled, call this function to send a point to Rhino. Call this function as much as you like.  The digitizers that Rhino currently supports send a point every 15 milliseconds or so. This function should be called when users press or release any digitizer button.","since":"6.0","parameters":[{"name":"point","summary":"3d point in digitizer coordinates."},{"name":"mousebuttons","summary":"corresponding digitizer button is down."},{"name":"shiftKey","summary":"True if the Shift keyboard key was pressed. Otherwise, false."},{"name":"controlKey","summary":"True if the Control keyboard key was pressed. Otherwise, false."}]},{"signature":"void SendRay(Ray3d ray, MouseButton mousebuttons, bool shiftKey, bool controlKey)","summary":"If the digitizer is enabled, call this function to send a point and direction to Rhino. Call this function as much as you like.  The digitizers that Rhino currently supports send a point every 15 milliseconds or so. This function should be called when users press or release any digitizer button.","since":"6.0","parameters":[{"name":"ray","summary":"3d ray in digitizer coordinates."},{"name":"mousebuttons","summary":"corresponding digitizer button is down."},{"name":"shiftKey","summary":"True if the Shift keyboard key was pressed. Otherwise, false."},{"name":"controlKey","summary":"True if the Control keyboard key was pressed. Otherwise, false."}]}]},{"namespace":"Rhino.PlugIns","name":"FileExportPlugIn","dataType":"class","summary":"Rhino plug-in that exports data from Rhino to other file formats; can support more than one format.","baseclass":"Rhino.PlugIns.PlugIn"},{"namespace":"Rhino.PlugIns","name":"FileImportPlugIn","dataType":"class","summary":"Rhino plug-in that imports data from other file formats into Rhino; can support more that one format.","baseclass":"Rhino.PlugIns.PlugIn"},{"namespace":"Rhino.PlugIns","name":"FileTypeList","dataType":"class","constructors":[{"signature":"FileTypeList()","since":"5.0"},{"signature":"FileTypeList(string description, string extension)","since":"6.0"},{"signature":"FileTypeList(string description, string extension, bool showOptionsButtonInFileDialog)","since":"6.0"}],"methods":[{"signature":"int AddFileType(string description, IEnumerable<string> extensions)","since":"5.0"},{"signature":"int AddFileType(string description, IEnumerable<string> extensions, bool showOptionsButtonInFileDialog)","since":"6.0"},{"signature":"int AddFileType(string description, string extension)","since":"5.0"},{"signature":"int AddFileType(string description, string extension, bool showOptionsButtonInFileDialog)","since":"6.0"},{"signature":"int AddFileType(string description, string extension1, string extension2)","since":"5.0"},{"signature":"int AddFileType(string description, string extension1, string extension2, bool showOptionsButtonInFileDialog)","since":"6.0"}]},{"namespace":"Rhino.PlugIns","name":"LicenseBuildType","dataType":"enum","summary":"License build contentType enumerations.","since":"5.0","values":[{"signature":"Unspecified = 0","summary":"An unspecified build"},{"signature":"Release = 100","summary":"A release build (e.g. commercial, education, NFR, etc.)"},{"signature":"Evaluation = 200","summary":"A evaluation build"},{"signature":"Beta = 300","summary":"A beta build (e.g. WIP)"}]},{"namespace":"Rhino.PlugIns","name":"LicenseCapabilities","dataType":"enum","summary":"Controls the buttons that will appear on the license notification window that is displayed if a license for the requesting product is not found. Note, the \\"Close\\" button will always be displayed.","since":"5.5","values":[{"signature":"NoCapabilities = 0x0","summary":"Only the \\"Close\\" button will be displayed"},{"signature":"CanBePurchased = 0x1","summary":"Shows \\"Buy a license\\" button"},{"signature":"CanBeSpecified = 0x2","summary":"OBSOLETE: Shows \\"\\"Enter a license\\" and \\"Use a Zoo\\" buttons. Use SupportsStandalone | SupportsZoo instead."},{"signature":"CanBeEvaluated = 0x4","summary":"Shows \\"Evaluate\\" button"},{"signature":"EvaluationIsExpired = 0x8","summary":"Shows \\"Evaluate\\" button disabled"},{"signature":"SupportsRhinoAccounts = 0x10","summary":"Supports getting a license from a Cloud Zoo / Rhino Account"},{"signature":"SupportsStandalone = 0x20","summary":"Supports single-computer licensing"},{"signature":"SupportsZooPerUser = 0x40","summary":"Supports getting a license from a Zoo server"},{"signature":"SupportsZooPerCore = 0x80","summary":"Supports getting a license from a Zoo server"}]},{"namespace":"Rhino.PlugIns","name":"LicenseChangedEventArgs","dataType":"class","baseclass":"EventArgs"},{"namespace":"Rhino.PlugIns","name":"LicenseData","dataType":"class","summary":"Zoo plug-in license data.","constructors":[{"signature":"LicenseData()","summary":"Public constructor.","since":"5.0"},{"signature":"LicenseData(string productLicense, string serialNumber, string licenseTitle)","summary":"Public constructor","since":"5.0","parameters":[{"name":"productLicense","summary":"License string to be saved by ZooClient"},{"name":"serialNumber","summary":"Serial number to be displayed to end user"},{"name":"licenseTitle","summary":"Title of license (Rhino 6.0 Evaluation)"}]},{"signature":"LicenseData(string productLicense, string serialNumber, string licenseTitle, LicenseBuildType buildType)","summary":"Public constructor","since":"5.0","parameters":[{"name":"productLicense","summary":"License string to be saved by ZooClient"},{"name":"serialNumber","summary":"Serial number to be displayed to end user"},{"name":"licenseTitle","summary":"Title of license (Rhino 6.0 Evaluation)"},{"name":"buildType","summary":"A LicenseBuildType value"}]},{"signature":"LicenseData(string productLicense, string serialNumber, string licenseTitle, LicenseBuildType buildType, int licenseCount)","summary":"Public constructor","since":"5.0","parameters":[{"name":"productLicense","summary":"License string to be saved by ZooClient"},{"name":"serialNumber","summary":"Serial number to be displayed to end user"},{"name":"licenseTitle","summary":"Title of license (Rhino 6.0 Evaluation)"},{"name":"buildType","summary":"A LicenseBuildType value"},{"name":"licenseCount","summary":"Number of licenses represented by this string. Allows the Zoo to hand out multiple license keys when greater than 1."}]},{"signature":"LicenseData(string productLicense, string serialNumber, string licenseTitle, LicenseBuildType buildType, int licenseCount, DateTime? expirationDate)","summary":"Public constructor","parameters":[{"name":"productLicense","summary":"License string to be saved by ZooClient"},{"name":"serialNumber","summary":"Serial number to be displayed to end user"},{"name":"licenseTitle","summary":"Title of license (Rhino 6.0 Evaluation)"},{"name":"buildType","summary":"A LicenseBuildType value"},{"name":"licenseCount","summary":"Number of licenses represented by this string. Allows the Zoo to hand out multiple license keys when greater than 1."},{"name":"expirationDate","summary":"Date when license expires, None if license never expires."}]},{"signature":"LicenseData(string productLicense, string serialNumber, string licenseTitle, LicenseBuildType buildType, int licenseCount, DateTime? expirationDate, Icon productIcon)","summary":"Public constructor","parameters":[{"name":"productLicense","summary":"License string to be saved by ZooClient"},{"name":"serialNumber","summary":"Serial number to be displayed to end user"},{"name":"licenseTitle","summary":"Title of license (Rhino 6.0 Evaluation)"},{"name":"buildType","summary":"A LicenseBuildType value"},{"name":"licenseCount","summary":"Number of licenses represented by this string. Allows the Zoo to hand out multiple license keys when greater than 1."},{"name":"expirationDate","summary":"Date when license expires, None if license never expires."},{"name":"productIcon","summary":"Icon to display in Rhino License Options user interface when showing this license"}]},{"signature":"LicenseData(string productLicense, string serialNumber, string licenseTitle, LicenseBuildType buildType, int licenseCount, DateTime? expirationDate, Icon productIcon, bool requiresOnlineValidation, bool isUpgradeFromPreviousVersion)","summary":"Public constructor","parameters":[{"name":"productLicense","summary":"License string to be saved by ZooClient"},{"name":"serialNumber","summary":"Serial number to be displayed to end user"},{"name":"licenseTitle","summary":"Title of license (Rhino 6.0 Evaluation)"},{"name":"buildType","summary":"A LicenseBuildType value"},{"name":"licenseCount","summary":"Number of licenses represented by this string. Allows the Zoo to hand out multiple license keys when greater than 1."},{"name":"expirationDate","summary":"Date when license expires, None if license never expires."},{"name":"productIcon","summary":"Icon to display in Rhino License Options user interface when showing this license"},{"name":"requiresOnlineValidation","summary":"True if online validation server should be called with this license key; False otherwise. If true, caller must pass implementation of VerifyOnlineValidationCodeDelegate to GetLicense/AskUserForLicense"},{"name":"isUpgradeFromPreviousVersion","summary":"True if this license key requires a previous version license; False otherwise. If true, caller must pass implementation of VerifyPreviousVersionLicenseDelegate to GetLicense/AskUserForLicense"}]}],"properties":[{"signature":"LicenseBuildType BuildType","summary":"The build of the product that this license work with. When your product requests a license from the Zoo, it will specify one of these build types.","since":"5.0","property":["get","set"]},{"signature":"DateTime? DateToExpire","summary":"The date and time the license is set to expire. This is provided by the plug in that validated the license. This time value should be in Coordinated Universal Time (UTC).","since":"5.0","property":["get","set"]},{"signature":"string ErrorMessage","summary":"Error message set by calls to callback functions","since":"6.0","property":["get","set"]},{"signature":"bool IsUpgradeFromPreviousVersion","summary":"Set to True if this license requires a previous version license to be entered. Caller must also pass VerifyPreviousVersionLicenseDelegate to GetLicense/AskUserForLicense.","since":"6.0","property":["get","set"]},{"signature":"int LicenseCount","summary":"The number of instances supported by this license. This is provided by the plug in that validated the license.","since":"5.0","property":["get","set"]},{"signature":"bool LicenseExpires","since":"6.0","property":["get"]},{"signature":"string LicenseTitle","summary":"The title of the license. This is provided by the plug-in that validated the license. (e.g. \\"Rhinoceros 6.0 Commercial\\")","since":"5.0","property":["get","set"]},{"signature":"Icon ProductIcon","summary":"The product\'s icon. This will displayed in the \\"license\\" page in the Options dialog. Note, this can be null. Note, LicenseData creates it\'s own copy of the icon.","since":"5.0","property":["get","set"]},{"signature":"string ProductLicense","summary":"The actual product license. This is provided by the plug-in that validated the license.","since":"5.0","property":["get","set"]},{"signature":"bool RequiresOnlineValidation","summary":"Set to True if this license requires online validation. Caller must also pass VerifyOnlineValidationCodeDelegate to GetLicense/AskUserForLicense","since":"6.0","property":["get","set"]},{"signature":"string SerialNumber","summary":"The \\"for display only\\" product license. This is provided by the plug-in that validated the license.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static bool IsNotValid(LicenseData data)","summary":"Indicates whether a LicenseData object is either None or invalid.","since":"5.0"},{"signature":"static bool IsValid(LicenseData data)","summary":"Indicates whether a LicenseData object is not None and valid.","since":"5.0"},{"signature":"void Dispose()","since":"5.0"},{"signature":"bool IsValid()","summary":"Public validator.","since":"5.0"},{"signature":"bool IsValid(bool ignoreExpirationDate)","since":"6.0"}]},{"namespace":"Rhino.PlugIns","name":"LicenseIdAttribute","dataType":"class","baseclass":"Attribute","constructors":[{"signature":"LicenseIdAttribute(string value)","since":"6.0"}],"properties":[{"signature":"string Value","since":"6.0","property":["get"]}]},{"namespace":"Rhino.PlugIns","name":"LicenseLease","dataType":"class","summary":"LicenseLease represents a lease returned from the Cloud Zoo","constructors":[{"signature":"LicenseLease(IntPtr unmanagedPointer)","since":"6.0"},{"signature":"LicenseLease(string productId, string groupName, string groupId, string userName, string userId, string productTitle, string productVersion, string productEdition, string leaseId, DateTime iat, DateTime exp)","since":"6.0"},{"signature":"LicenseLease(string productId, string groupName, string groupId, string userName, string userId, string productTitle, string productVersion, string productEdition, string leaseId, DateTime iat, DateTime exp, DateTime renewable_until)","since":"6.4"}],"properties":[{"signature":"DateTime Expiration","summary":"The date when this lease will expire","since":"6.0","property":["get"]},{"signature":"string GroupId","summary":"ID of Rhino Accounts group that this lease came from","since":"6.0","property":["get"]},{"signature":"string GroupName","summary":"Name of Rhino Accounts group that this lease came from","since":"6.0","property":["get"]},{"signature":"DateTime IssuedAt","summary":"The date this lease was issued","since":"6.0","property":["get"]},{"signature":"string LeaseId","summary":"The ID of this lease.","since":"6.0","property":["get"]},{"signature":"string ProductEdition","summary":"Edition of product that this lease is issued to. For example, \\"Commercial\\" or \\"Beta\\"","since":"6.0","property":["get"]},{"signature":"string ProductId","summary":"The ID of the product that this lease is issued to","since":"6.0","property":["get"]},{"signature":"string ProductTitle","summary":"Title of product that this lease is issued to. For example, \\"Rhino 6\\"","since":"6.0","property":["get"]},{"signature":"string ProductVersion","summary":"Version of product that this lease is issued to. For example, \\"6.0\\"","since":"6.0","property":["get"]},{"signature":"string UserId","summary":"ID of Rhino Accounts user that was logged in when this lease was obtained","since":"6.0","property":["get"]},{"signature":"string UserName","summary":"Name of Rhino Accounts user that was logged in when this lease was obtained","since":"6.0","property":["get"]}]},{"namespace":"Rhino.PlugIns","name":"LicenseLeaseChangedEventArgs","dataType":"class","summary":"Arguments for OnLeaseChangedDelegate","constructors":[{"signature":"LicenseLeaseChangedEventArgs(LicenseLease lease)","since":"6.0"}],"properties":[{"signature":"LicenseLease Lease","summary":"The lease returned by Rhino Accounts server","since":"6.0","property":["get"]}]},{"namespace":"Rhino.PlugIns","name":"LicenseStatus","dataType":"class","summary":"LicenseStatus class.","constructors":[{"signature":"LicenseStatus()","summary":"Public constructor.","since":"5.0"}],"properties":[{"signature":"LicenseBuildType BuildType","summary":"The build contentType of the product, where: 100 = A release build, either commercial, education, NFR, etc. 200 = A evaluation build 300 = A beta build, such as a WIP.","since":"5.0","property":["get","set"]},{"signature":"DateTime? CheckOutExpirationDate","summary":"The date and time the checked out license will expire. Note, this is only set if m_license_type = Standalone or CloudZoo and if \\"limited license checkout\\" was enabled on the Zoo server in the case of Standalone. Note, date and time is in local time coordinates.","since":"5.0","property":["get","set"]},{"signature":"DateTime? CloudZooLeaseExpiration","summary":"Returns the expiration date of the lease this instance represents.","since":"6.4","property":["get","set"]},{"signature":"bool CloudZooLeaseIsValid","summary":"Returns True if the Cloud Zoo Lease represented by this instance is actively being managed by the Cloud Zoo Manager; else returns false.","since":"6.0","property":["get","set"]},{"signature":"DateTime? ExpirationDate","summary":"The date and time the license will expire. This value can be None if: 1.) The license contentType is \\"Standalone\\" and the license does not expire. 2.) The license contentType is \\"Network\\". 3.) The license contentType is \\"NetworkCheckedOut\\" and the checkout does not expire Note, date and time is in local time coordinates.","since":"5.0","property":["get","set"]},{"signature":"string LicenseTitle","summary":"The title of the license. (e.g. \\"Rhinoceros 6.0 Commercial\\")","since":"5.0","property":["get","set"]},{"signature":"LicenseType LicenseType","summary":"The license contentType. (e.g. Standalone, Network, etc.)","since":"5.0","property":["get","set"]},{"signature":"Guid PluginId","summary":"The ID of the plug-in that owns this license information","since":"6.0","property":["get","set"]},{"signature":"Icon ProductIcon","summary":"The product\'s icon. Note, this can be null.","since":"5.0","property":["get","set"]},{"signature":"Guid ProductId","summary":"The id of the product or plug in.","since":"5.0","property":["get","set"]},{"signature":"string RegisteredOrganization","summary":"The registered organization of the product (e.g. \\"Robert McNeel and Associates\\")","since":"5.0","property":["get","set"]},{"signature":"string RegisteredOwner","summary":"The registered owner of the product. (e.g. \\"Dale Fugier\\")","since":"5.0","property":["get","set"]},{"signature":"string SerialNumber","summary":"The \\"for display only\\" product license or serial number.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.PlugIns","name":"LicenseType","dataType":"enum","summary":"LicenseType enumeration.","since":"5.0","values":[{"signature":"Standalone","summary":"A standalone license"},{"signature":"Network","summary":"A network license that has not been fulfilled by a Zoo"},{"signature":"NetworkLoanedOut","summary":"A license on temporary loan from a Zoo"},{"signature":"NetworkCheckedOut","summary":"A license on permanent check out from a Zoo"},{"signature":"CloudZoo","summary":"A lease granted by the Cloud Zoo"}]},{"namespace":"Rhino.PlugIns","name":"LicenseUtils","dataType":"class","summary":"License Manager Utilities.","methods":[{"signature":"static bool AskUserForLicense(int productType, bool standAlone, object parentWindow, string textMask, ValidateProductKeyDelegate validateProductKeyDelegate, OnLeaseChangedDelegate onLeaseChangedDelegate, string product_path, string product_title, Guid pluginId, Guid licenseId, LicenseCapabilities capabilities)","summary":"This version of Rhino.PlugIns.LicenseUtils.AskUserForLicense is used by Rhino C++ plug-ins.","since":"6.0"},{"signature":"static bool AskUserForLicense(int productType, bool standAlone, object parentWindow, string textMask, ValidateProductKeyDelegate validateProductKeyDelegate, OnLeaseChangedDelegate onLeaseChangedDelegate, VerifyLicenseKeyDelegate verifyLicenseKeyDelegate, VerifyPreviousVersionLicenseDelegate verifyPreviousVersionLicenseKeyDelegate, string product_path, string product_title, Guid pluginId, Guid licenseId, LicenseCapabilities capabilities)","since":"6.0"},{"signature":"static bool CheckInLicense(Guid productId)","summary":"Checks in a previously checked out license to the Zoo server from which it was checked out.","since":"5.0","parameters":[{"name":"productId","summary":"The Guid of the product that you want to check in."}],"returns":"True if the license was checked in successful. False if not successful or on error."},{"signature":"static bool CheckOutLicense(Guid productId)","summary":"Checks out a license that is on loan from a Zoo server on a permanent basis.","since":"5.0","parameters":[{"name":"productId","summary":"The Guid of the product that you want to check out."}],"returns":"True if the license was checked out successful. False if not successful or on error."},{"signature":"static bool ConvertLicense(Guid productId)","summary":"Converts a product license from a standalone node to a network node.","since":"5.0","parameters":[{"name":"productId","summary":"The Guid of the product that you want to check in."}],"returns":"True if the license was successfully converted. False if not successful or on error."},{"signature":"static bool DeleteLicense(Guid productId)","summary":"Deletes a license along with its license file.","since":"6.0"},{"signature":"static string Echo(string message)","summary":"Test connectivity with the Zoo.","since":"5.0"},{"signature":"static bool GetLicense(ValidateProductKeyDelegate validateProductKeyDelegate, OnLeaseChangedDelegate leaseChangedDelegate, int product_type, int capabilities, string textMask, string product_path, string product_title, Guid pluginId, Guid licenseId)","summary":"This version of Rhino.PlugIns.LicenseUtils.GetLicense is used by Rhino C++ plug-ins.","since":"6.0"},{"signature":"static bool GetLicense(ValidateProductKeyDelegate validateProductKeyDelegate, OnLeaseChangedDelegate leaseChangedDelegate, VerifyLicenseKeyDelegate verifyLicenseKeyDelegate, VerifyPreviousVersionLicenseDelegate verifyPreviousVersionLicenseKeyDelegate, int product_type, int capabilities, string textMask, string product_path, string product_title, Guid pluginId, Guid licenseId)","since":"6.0"},{"signature":"static LicenseCapabilities GetLicenseCapabilities(int filter)","summary":"Converts an integer to a LicenseCapabilities flag","since":"5.5"},{"signature":"static LicenseStatus[] GetLicenseStatus()","summary":"Returns the current status of every license for UI purposes.","since":"5.0"},{"signature":"static int GetLicenseType(Guid productId)","summary":"Returns the contentType of a specified product license","since":"5.0"},{"signature":"static LicenseStatus GetOneLicenseStatus(Guid productid)","summary":"Returns the current status of a license for UI purposes.","since":"5.5"},{"signature":"static bool Initialize()","summary":"Initializes the license manager.","since":"5.0"},{"signature":"static bool IsCheckOutEnabled()","summary":"Returns whether or not license checkout is enabled.","since":"5.0"},{"signature":"static bool LicenseOptionsHandler(Guid pluginId, Guid licenseId, string productTitle, bool standAlone)","since":"6.0"},{"signature":"static bool LoginToCloudZoo()","since":"6.0"},{"signature":"static bool LogoutOfCloudZoo()","since":"6.0"},{"signature":"static bool ReturnLicense(Guid productId)","summary":"OBSOLETE - REMOVE WHEN POSSIBLE.","since":"5.0"},{"signature":"static void ShowBuyLicenseUi(Guid productId)","since":"5.5"},{"signature":"static bool ShowLicenseValidationUi(string cdkey)","summary":"ShowLicenseValidationUi","since":"5.0"},{"signature":"static bool ShowRhinoExpiredMessage(Mode mode, ref int result)","summary":"Show Rhino or Beta expired message","since":"6.0"}]},{"namespace":"Rhino.PlugIns","name":"LoadPlugInResult","dataType":"enum","summary":"Result of attempting to load a plug-in","since":"6.0","values":[{"signature":"Success","summary":"Successfully loaded"},{"signature":"SuccessAlreadyLoaded"},{"signature":"ErrorUnknown"}]},{"namespace":"Rhino.PlugIns","name":"LoadReturnCode","dataType":"enum","summary":"Rhino plug-in loading return codes.","since":"5.0","values":[{"signature":"Success = 1"},{"signature":"ErrorShowDialog = 0"},{"signature":"ErrorNoDialog = -1"}]},{"namespace":"Rhino.PlugIns","name":"PlugIn","dataType":"class","summary":"A general purpose utility plug-in that can contain one or more commands.","properties":[{"signature":"static bool AskOnLoadProtection","summary":"If true, Rhino will display a warning dialog when load-protected plug-ins are attempting to load. If false, load-protected plug-ins will silently not load.","since":"6.0","property":["get","set"]},{"signature":"static int InstalledPlugInCount","summary":"Returns the number of installed Rhino plug-ins.","since":"5.0","property":["get"]},{"signature":"Assembly Assembly","summary":"Source assembly for this plug-in.","since":"5.0","property":["get"]},{"signature":"string Description","summary":"Returns the description of the plug-in, as found in the plug-in\'s assembly attributes.","since":"6.0","property":["get"]},{"signature":"Guid Id","summary":"Returns the Guid, or unique Id, of the plug-in.","since":"5.0","property":["get"]},{"signature":"Guid LicenseId","since":"6.0","property":["get"]},{"signature":"bool LoadAtStartup","since":"5.0","property":["get"]},{"signature":"PlugInLoadTime LoadTime","summary":"Plug-ins are typically loaded on demand when they are first needed. You can change this behavior to load the plug-in at during different stages in time by overriding this property.","since":"5.0","property":["get"]},{"signature":"string Name","summary":"Returns the name of the plug-in, as found in the plug-in\'s assembly attributes.","since":"5.0","property":["get"]},{"signature":"PersistentSettings Settings","summary":"Persistent plug-in settings.","since":"5.0","property":["get"]},{"signature":"string SettingsDirectory","since":"5.0","property":["get"]},{"signature":"string SettingsDirectoryAllUsers","since":"5.0","property":["get"]},{"signature":"string Version","summary":"Returns the version of the plug-in, as found in the plug-in\'s assembly attributes.","since":"5.0","property":["get"]},{"signature":"PersistentSettings WindowPositionSettings","since":"6.0","property":["get"]}],"methods":[{"signature":"static PlugIn Find(Assembly pluginAssembly)","summary":"Finds the plug-in instance that was loaded from a given assembly.","since":"5.0","parameters":[{"name":"pluginAssembly","summary":"The plug-in assembly.  \\nYou can get the assembly instance at runtime with the  instance property."}],"returns":"The assembly plug-in instance if successful. Otherwise, null."},{"signature":"static PlugIn Find(Guid plugInId)","summary":"Finds the plug-in instance that was loaded from a given plug-in Id.","since":"5.5","parameters":[{"name":"plugInId","summary":"The plug-in Id."}],"returns":"The plug-in instance if successful. Otherwise, null."},{"signature":"static void FlushSettingsSavedQueue()","since":"6.0"},{"signature":"static string[] GetEnglishCommandNames(Guid pluginId)","summary":"Gets names of all \\"non-test\\" commands for a given plug-in.","since":"5.0","parameters":[{"name":"pluginId","summary":"The plug-in ID."}],"returns":"An array with all plug-in names. This can be empty, but not null."},{"signature":"static string[] GetInstalledPlugInFolders()","since":"5.0"},{"signature":"static string[] GetInstalledPlugInNames()","summary":"Returns the names of all installed Rhino plug-ins.","since":"5.0","returns":"The names if successful."},{"signature":"static string[] GetInstalledPlugInNames(PlugInType typeFilter, bool loaded, bool unloaded)","summary":"Gets a list of installed plug-in names.  The list can be restricted by some filters.","since":"5.0","parameters":[{"name":"typeFilter","summary":"The enumeration flags that determine which types of plug-ins are included."},{"name":"loaded","summary":"True if loaded plug-ins are returned."},{"name":"unloaded","summary":"True if unloaded plug-ins are returned."}],"returns":"An array of installed plug-in names. This can be empty, but not null."},{"signature":"static Dictionary<Guid, string> GetInstalledPlugIns()","since":"5.0"},{"signature":"static bool GetLoadProtection(Guid pluginId, out bool loadSilently)","summary":"Get load protection state for a plug-in","since":"5.5"},{"signature":"static PlugInInfo GetPlugInInfo(Guid pluginId)","summary":"Returns detailed information about an installed Rhino plug-in.","since":"6.0","parameters":[{"name":"pluginId","summary":"The id of the plug-in."}],"returns":"Detailed information about an installed Rhino plug-in if successful, None otherwise."},{"signature":"static PersistentSettings GetPluginSettings(Guid plugInId, bool load)","since":"6.0"},{"signature":"static Guid IdFromName(string pluginName)","summary":"Gets the id of an installed plug-in giving the plug-in\'s name.","since":"5.5","parameters":[{"name":"pluginName","summary":"The name of the installed plug-in."}],"returns":"The id if successful."},{"signature":"static Guid IdFromPath(string pluginPath)","summary":"Gets the id of an installed plug-in giving the plug-in\'s file path.","since":"5.0","parameters":[{"name":"pluginPath","summary":"The path to the installed plug-in."}],"returns":"The id if successful."},{"signature":"static void LoadComputeExtensionPlugins()","summary":"Used by compute\'s startup code to load plug-ins that have registered custom endpoints","since":"7.0"},{"signature":"static bool LoadPlugIn(Guid pluginId)","summary":"Loads an installed plug-in.","since":"5.0","parameters":[{"name":"pluginId","summary":"The id of the installed plug-in."}],"returns":"True if successful, False otherwise."},{"signature":"static bool LoadPlugIn(Guid pluginId, bool loadQuietly, bool forceLoad)","summary":"Loads an installed plug-in.","since":"6.0","parameters":[{"name":"pluginId","summary":"The id of the installed plug-in."},{"name":"loadQuietly","summary":"Load the plug-in quietly."},{"name":"forceLoad","summary":"Load plug-in even if previous attempt to load has failed."}],"returns":"True if successful, False otherwise."},{"signature":"static LoadPlugInResult LoadPlugIn(string path, out Guid plugInId)","summary":"Attempt to load a plug-in at a path. Loaded plug-ins are remembered by Rhino between sessions, so this function can also be considered a plug-in installation routine","since":"6.0","parameters":[{"name":"path","summary":"full path to plug-in to attempt to load"},{"name":"plugInId","summary":"If successful (or the plug-in is already loaded), the unique id for the plug-in is returned here. Guid.Empty on failure"}]},{"signature":"static string NameFromPath(string pluginPath)","summary":"Gets a plug-in name for an installed plug-in given the path to that plug-in.","since":"5.0","parameters":[{"name":"pluginPath","summary":"The path of the plug-in."}],"returns":"The plug-in name."},{"signature":"static string PathFromId(Guid pluginId)","summary":"Gets the path to an installed plug-in given the id of that plug-in","since":"5.9"},{"signature":"static string PathFromName(string pluginName)","summary":"Gets the path to an installed plug-in given the name of that plug-in","since":"5.9"},{"signature":"static bool PlugInExists(Guid id, out bool loaded, out bool loadProtected)","summary":"Verifies that a Rhino plug-in is installed.","since":"5.0","parameters":[{"name":"id","summary":"The id of the plug-in."},{"name":"loaded","summary":"The loaded state of the plug-in."},{"name":"loadProtected","summary":"The load protected state of the plug-in."}],"returns":"Returns True if the plug-in exists, or is installed."},{"signature":"static void RaiseOnPlugInSettingsSavedEvent()","summary":"Raise any pending OnPlugInSettingsSaved events, the events are normally queued while a command is running and fired while Rhino is in an idle state.  Calling this method will raise any pending changed events regardless of Rhino\'s current idle state or if a command is running.","since":"6.0"},{"signature":"static void SavePluginSettings(Guid plugInId)","since":"6.0"},{"signature":"static void SetLoadProtection(Guid pluginId, bool loadSilently)","summary":"Set load protection state for a certain plug-in","since":"5.5"},{"signature":"PersistentSettings CommandSettings(string name)","since":"5.0"},{"signature":"Commands.Command[] GetCommands()","summary":"All of the commands associated with this plug-in.","since":"5.0"},{"signature":"object GetPlugInObject()","since":"5.0"},{"signature":"System.Drawing.Bitmap Icon(Size size)","summary":"Returns the plug-in\'s icon in bitmap form.","since":"6.0","parameters":[{"name":"size","summary":"The desired size in pixels."}],"returns":"The icon if successful, None otherwise."},{"signature":"void SaveSettings()","summary":"Write settings to disk which will raise a SettingsSaved event.","since":"6.0"}]},{"namespace":"Rhino.PlugIns","name":"PlugInDescriptionAttribute","dataType":"class","summary":"Rhino plug-in developer information attributes.","baseclass":"Attribute","constructors":[{"signature":"PlugInDescriptionAttribute(DescriptionType descriptionType, string value)","since":"5.0"}],"properties":[{"signature":"DescriptionType DescriptionType","since":"5.0","property":["get"]},{"signature":"string Value","since":"5.0","property":["get"]}]},{"namespace":"Rhino.PlugIns","name":"PlugInInfo","dataType":"class","summary":"Contains detailed information about a Rhino plug-in.","properties":[{"signature":"string Address","summary":"Returns the address of the organization or company that created the plug-in.","since":"6.0","property":["get"]},{"signature":"string[] CommandNames","summary":"Returns a plug-in\'s English command names.","since":"6.0","property":["get"]},{"signature":"string Country","summary":"Returns the country of the organization or company that created the plug-in.","since":"6.0","property":["get"]},{"signature":"string Description","summary":"Returns the plug-in\'s description.","since":"6.0","property":["get"]},{"signature":"string Email","summary":"Returns the email address of the organization or company that created the plug-in.","since":"6.0","property":["get"]},{"signature":"string Fax","summary":"Returns the fax number of the organization or company that created the plug-in.","since":"6.0","property":["get"]},{"signature":"string FileName","summary":"Returns the plug-in\'s file name.","since":"6.0","property":["get"]},{"signature":"string[] FileTypeDescriptions","summary":"Returns the description of supported file types for file import and file export plug-in.","since":"6.0","property":["get"]},{"signature":"string[] FileTypeExtensions","summary":"Returns the file types extensions supported for file import and file export plug-in.","since":"7.0","property":["get"]},{"signature":"Guid Id","summary":"Returns the plug-in\'s Id.","since":"6.0","property":["get"]},{"signature":"bool IsDotNet","summary":"Returns True if the plug-in is based on .NET, False otherwise.","since":"6.0","property":["get"]},{"signature":"bool IsLoaded","summary":"Returns True if the plug-in is loaded, False otherwise.","since":"6.0","property":["get"]},{"signature":"string Name","summary":"Returns the plug-in\'s name.","since":"6.0","property":["get"]},{"signature":"string Organization","summary":"Returns the organization or company that created the plug-in.","since":"6.0","property":["get"]},{"signature":"string Phone","summary":"Returns the phone number of the organization or company that created the plug-in.","since":"6.0","property":["get"]},{"signature":"PlugInLoadTime PlugInLoadTime","summary":"Returns the plug-in\'s load time.","since":"6.0","property":["get"]},{"signature":"PlugInType PlugInType","summary":"Returns the plug-in type.","since":"6.0","property":["get"]},{"signature":"string RegistryPath","summary":"Returns the plug-in\'s Windows Registry path.","since":"6.0","property":["get"]},{"signature":"bool ShipsWithRhino","summary":"Returns True if the plug-in ships with Rhino, False otherwise.","since":"6.0","property":["get"]},{"signature":"string UpdateUrl","summary":"Returns the web site, or URL, were an updated version of the plug-in can be found.","since":"6.0","property":["get"]},{"signature":"string Version","summary":"Returns the plug-in\'s version.","since":"6.0","property":["get"]},{"signature":"string WebSite","summary":"Returns the web site, or URL, of the organization or company that created the plug-in.","since":"6.0","property":["get"]}],"methods":[{"signature":"System.Drawing.Bitmap Icon(Size size)","summary":"Returns the plug-in\'s icon in bitmap form.","since":"6.0"},{"signature":"bool IsLoadProtected(out bool loadSilently)","summary":"Returns the load protection state for a plug-in","since":"6.0","parameters":[{"name":"loadSilently","summary":"The plug-in\'s load silently state."}],"returns":"True if the plug-in is load protected, False otherwise."}]},{"namespace":"Rhino.PlugIns","name":"PlugInLoadTime","dataType":"enum","summary":"Rhino plug-in load time enumeration.","since":"5.0","values":[{"signature":"Disabled = 0","summary":"never load plug-in."},{"signature":"AtStartup = 1","summary":"Load when Rhino starts."},{"signature":"WhenNeeded = 2","summary":"(default) Load the first time a plug-in command used."},{"signature":"WhenNeededIgnoreDockingBars = 6","summary":"Load the first time a plug-in command used NOT when restoring docking control bars."},{"signature":"WhenNeededOrOptionsDialog = 10","summary":"When a plug-in command is used or the options dialog is shown."},{"signature":"WhenNeededOrTabbedDockBar = 18","summary":"When a plug-in command is used or when a tabbed dockbar is loaded."}]},{"namespace":"Rhino.PlugIns","name":"PlugInType","dataType":"enum","summary":"Rhino plug-in type enumeration.","since":"5.0","values":[{"signature":"None = 0"},{"signature":"Render = 1"},{"signature":"FileImport = 2"},{"signature":"FileExport = 4"},{"signature":"Digitizer = 8"},{"signature":"Utility = 16"},{"signature":"DisplayPipeline = 32"},{"signature":"DisplayEngine = 64"},{"signature":"Any = Render | FileImport | FileExport | Digitizer | Utility | DisplayPipeline | DisplayEngine"}]},{"namespace":"Rhino.PlugIns","name":"PreviewNotification","dataType":"class","methods":[{"signature":"void NotifyIntermediateUpdate(RenderWindow rw)","since":"6.0"}]},{"namespace":"Rhino.PlugIns","name":"RenderPlugIn","dataType":"class","summary":"A Rhino rendering plugin; applies materials, textures, and lights to a scene to produce rendered images.","baseclass":"Rhino.PlugIns.PlugIn","properties":[{"signature":"bool PerferBasicContent","summary":"Set to True if you would like Rhino to quickly create a basic render content in response to \'Create New\' commands. Set to False if you would prefer Rhino to display the render content chooser dialog.","since":"5.12","property":["get","set"]}],"methods":[{"signature":"static bool CurrentRendererSupportsFeature(RenderFeature feature)","since":"6.1"},{"signature":"bool EnableAssignMaterialButton()","summary":"Called to enable/disable the \\"Material\\" button located on the \\"Material\\" tab in the Properties and Layer dialog boxes.  The default return value is False which will disable the button.  If the button is disabled then the OnAssignMaterial function is never called.","since":"5.12"},{"signature":"bool EnableCreateMaterialButton()","summary":"Called to enable/disable the \\"New\\" button located on the \\"Material\\" in the  Properties and Layer dialog boxes.  The default return value is False which will disable the button.  If the button is disabled then the OnEditMaterial function is never called.","since":"5.12"},{"signature":"bool EnableEditMaterialButton(RhinoDoc doc, Material material)","summary":"Called to enable/disable the \\"Edit\\" button located on the \\"Material\\" in the Properties and Layer dialog boxes.  The default return value is False  which will disable the button.  If the button is disabled then the OnEditMaterial function is never called.","since":"5.12"},{"signature":"List<Guid> GetRenderSettingsSections()","summary":"This function returns a list of Guids for the render settings pages that should be displayed.","since":"6.17","returns":"Return a Id list of the Render settings sections that will be displayed"},{"signature":"bool OnAssignMaterial(IntPtr parent, RhinoDoc doc, ref Material material)","summary":"This function is called by the Object Properties and Layer Control dialogs when the \\"Material\\" button is pressed in the \\"Render\\" tab. This is only called if EnableAssignMaterialButton returns true.","since":"5.12"},{"signature":"bool OnCreateMaterial(IntPtr parent, RhinoDoc doc, ref Material material)","summary":"This function is called by the Object Properties and Layer Control dialogs when the \\"New\\" button is pressed in the \\"Material\\" tab.  This is only called if EnableCreateMaterialButton returns true.","since":"5.12"},{"signature":"bool OnEditMaterial(IntPtr parent, RhinoDoc doc, ref Material material)","summary":"This function is called by the Object Properties and Layer Control dialogs when the \\"Edit\\" button is pressed in the \\"Material\\" tab.  This is only called if EnableEditMaterialButton returns true. A return value of True means the material has been updated.","since":"5.12"},{"signature":"void RenderSettingsCustomSections(List<ICollapsibleSection> sections)","summary":"Override this function to provide custom sections for the render settings panel that are displayed when your plug-in is the current render plug-in.","since":"6.0","parameters":[{"name":"sections","summary":"Create your sections and return a list of them"}]},{"signature":"void SunCustomSections(List<ICollapsibleSection> sections)","summary":"Override this function to provide custom sections for the sun panel that are displayed when your plug-in is the current render plug-in.","since":"6.0","parameters":[{"name":"sections","summary":"Create your sections and return a list of them"}]}]},{"namespace":"Rhino.PlugIns","name":"RenderPlugIn.PreviewRenderTypes","dataType":"enum","since":"6.0","values":[{"signature":"None = 0"},{"signature":"ThreeSeparateImages"},{"signature":"SingleImage"},{"signature":"Progressive"}]},{"namespace":"Rhino.PlugIns","name":"RenderPlugIn.RenderFeature","dataType":"enum","since":"5.0","values":[{"signature":"Materials                   = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.Materials"},{"signature":"Environments                = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.Environments"},{"signature":"Textures                    = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.Textures"},{"signature":"PostEffects                 = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.PostEffects"},{"signature":"Sun                         = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.Sun"},{"signature":"CustomRenderMeshes          = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.CustomRenderMeshes"},{"signature":"Decals                      = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.Decals"},{"signature":"GroundPlane                 = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.GroundPlane"},{"signature":"SkyLight                    = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.SkyLight"},{"signature":"CustomDecalProperties       = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.CustomDecalProperties"},{"signature":"LinearWorkflow              = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.LinearWorkflow"},{"signature":"Exposure                    = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.Exposure"},{"signature":"ShadowOnlyGroundPlane       = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.ShadowOnlyGroundPlane"},{"signature":"RenderBlowup                = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.RenderBlowup"},{"signature":"RenderWindow                = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.RenderWindow"},{"signature":"RenderInWindow              = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.RenderInWindow"},{"signature":"FocalBlur                   = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.RenderFocalBlur"},{"signature":"RenderArctic                = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.RenderArctic"},{"signature":"RenderViewSource            = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.RenderViewSource"},{"signature":"CustomSkylightEnvironment   = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.CustomSkylightEnvironment"},{"signature":"CustomReflectionEnvironment = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.CustomReflectionEnvironment"},{"signature":"RenderChannels              = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.RenderChannels"}]},{"namespace":"Rhino.PlugIns","name":"ValidateResult","dataType":"enum","summary":"ValidateProductKeyDelegate result code.","since":"5.0","values":[{"signature":"Success = 1","summary":"The product key or license is validated successfully."},{"signature":"ErrorShowMessage = 0","summary":"There was an error validating the product key or license, the license manager show an error message."},{"signature":"ErrorHideMessage = -1","summary":"There was an error validating the product key or license. The validating delegate will show an error message, not the license manager."}]},{"namespace":"Rhino.PlugIns","name":"WriteFileResult","dataType":"enum","since":"5.0","values":[{"signature":"Cancel = -1"},{"signature":"Failure = 0"},{"signature":"Success = 1"}]},{"namespace":"Rhino","name":"ReadFileResult","dataType":"enum","summary":"ON::ReadFileResult reports what happened when a file read was attempted.","values":[{"signature":"Unset = 0","summary":"No result is available."},{"signature":"Completed = 1","summary":"Read completed with no errors."},{"signature":"CompletedWithErrors = 2","summary":"Read completed with non fatal errors."},{"signature":"Failed = 3","summary":"Read failed."}]},{"namespace":"Rhino.Render","name":"AsyncRenderContext","dataType":"class","summary":"\\\\ingroup rhino_render Inherit from AsyncRenderContext to be able to create asynchronous render engine implementations through RhinoCommon.","interfaces":["IDisposable"],"properties":[{"signature":"Thread RenderThread","summary":"Holder for render thread, that gets set through StartRenderThread()","since":"6.0","property":["get","set"]},{"signature":"RenderWindow RenderWindow","summary":"Handle to the RenderWindow for the instance of this class. This is a convenience property for implementors to use.","since":"6.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","since":"6.0"},{"signature":"void JoinRenderThread()","summary":"Join the render thread, then set to null;","since":"6.0"},{"signature":"bool StartRenderThread(ThreadStart threadStart, string threadName)","summary":"Start a new render thread with given function.","since":"6.0","parameters":[{"name":"threadStart","summary":"Function to start in render thread"},{"name":"threadName","summary":"Name for the thread"}]},{"signature":"void StopRendering()","summary":"Override StopRendering if you need to do additional tasks besides having Cancel set to true.  Note: you should always base.StopRendering() in your overriding implementation.","since":"6.0"}]},{"namespace":"Rhino.Render","name":"CachedTextureCoordinates","dataType":"class","summary":"Used for cached texture coordinates","baseclass":"Rhino.Runtime.CommonObject","interfaces":["IList<Point3d>"],"properties":[{"signature":"int Count","summary":"Number of cached coordinates.","since":"5.10","property":["get"]},{"signature":"int Dim","summary":"Coordinate dimension: 2 = UV, 3 = UVW","since":"5.10","property":["get"]},{"signature":"bool IsReadOnly","summary":"This collection is always read-only","since":"5.10","property":["get"]},{"signature":"Guid MappingId","summary":"The texture mapping Id.","since":"5.10","property":["get"]}],"methods":[{"signature":"bool Contains(Point3d item)","summary":"Determines whether this collection contains a specific value.","since":"5.10"},{"signature":"void CopyTo(Point3d[] array, int arrayIndex)","summary":"Copies the elements of the this collection to an System.Array, starting at a particular System.Array index.","since":"5.10","parameters":[{"name":"array","summary":"The one-dimensional System.Array that is the destination of the elements copied from this collection. The System.Array must have zero-based indexing."},{"name":"arrayIndex","summary":"The zero-based index in array at which copying begins."}]},{"signature":"IEnumerator<Point3d> GetEnumerator()","summary":"Returns an enumerator that iterates through this collection.","since":"5.10","returns":"A enumerator that can be used to iterate through this collection."},{"signature":"int IndexOf(Point3d item)","summary":"Determines the index of a specific point in this collection.","since":"5.10","parameters":[{"name":"item","summary":"The point (UV or UVW) to locate in this collection."}],"returns":"The index of item if found in the list; otherwise, -1."},{"signature":"bool TryGetAt(int index, out double u, out double v, out double w)","summary":"Use this method to iterate the cached texture coordinate array.","since":"5.10","parameters":[{"name":"index","summary":"Index for the vertex to fetch."},{"name":"u","summary":"Output parameter which will receive the U value."},{"name":"v","summary":"Output parameter which will receive the V value."},{"name":"w","summary":"Output parameter which will receive the W value, this is only meaningful if Dimis 3."}],"returns":"Returns True if index is valid; otherwise returns false."}]},{"namespace":"Rhino.Render.ChangeQueue","name":"ChangeQueue","dataType":"class","summary":"Base class for ChangeQueue.  Generally used by render plugins to build interactive updating of scenes that are being rendered.","interfaces":["IDisposable"],"properties":[{"signature":"DisplayPipelineAttributes DisplayPipelineAttributes","summary":"Get the DisplayPipelineAttributes if available, None otherwise","since":"6.0","property":["get"]},{"signature":"bool IsPreview","summary":"Return True if this ChangeQueue is created for preview rendering.  No view was set for preview rendering.","since":"6.0","property":["get"]},{"signature":"Guid ViewId","summary":"Return view ID for a RhinoDoc based ChangeQueue.  Returns Guid.Empty if no view was associated with the changequeue, i.e. preview rendering.","since":"6.0","property":["get"]}],"methods":[{"signature":"static void ConvertCameraBasedLightToWorld(ChangeQueue changequeue, Light light, ViewInfo vp)","summary":"Convert given (camera-based) light to a world-based light (in-place)","since":"6.0"},{"signature":"static uint CrcFromGuid(Guid guid)","summary":"Helper function to get a CRC from a Guid.","since":"6.0"},{"signature":"bool AreViewsEqual(ViewInfo aView, ViewInfo bView)","summary":"Compare to ViewInfo instances and decide whether they are equal or not.  If you need to change the way the comparison is done you can override this function and implement your custom comparison.","since":"6.0","parameters":[{"name":"aView","summary":"First ViewInfo to compare"},{"name":"bView","summary":"Second ViewInfo to compare"}],"returns":"True if the views are considered equal"},{"signature":"void CreateWorld()","summary":"Calls CreateWorld with True passed.","since":"6.0"},{"signature":"void CreateWorld(bool bFlushWhenReady)","summary":"Signal the queue to do the initialisation of the queue, seeding it with the content currently available.","since":"6.0","parameters":[{"name":"bFlushWhenReady","summary":"Set to True CreateWorld should automatically flush at the end. Note that the Flush called when True is passed doesn\'t apply changes."}]},{"signature":"void Dispose()","summary":"Dispose our ChangeQueue","since":"6.0"},{"signature":"RenderEnvironment EnvironmentForid(uint crc)","summary":"Get RenderEnvironment for given RenderHash. Can return null.","since":"6.0","returns":"RenderEnvironment if render hash gives a match, None otherwise"},{"signature":"uint EnvironmentIdForUsage(Usage usage)","summary":"Get RenderEnvironment RenderHash for given usage.","since":"6.0"},{"signature":"void Flush()","summary":"Tell the ChangeQueue to flush all collected events.  This can trigger a host of Apply* calls.  The following is the order in which those calls get made if there are changes for that specific data type:  ApplyViewChange ApplyLinearWorkflowChanges ApplyDynamicObjectTransforms ApplyDynamicLightChanges ApplyRenderSettingsChanges ApplyEnvironmentChanges (background) ApplyEnvironmentChanges (refl) ApplyEnvironmentChanges (sky) ApplySkylightChanges ApplySunChanges ApplyLightChanges ApplyMaterialChanges ApplyMeshChanges ApplyMeshInstanceChanges ApplyGroundPlaneChanges ApplyClippingPlaneChanges","since":"6.0"},{"signature":"GroundPlane GetQueueGroundPlane()","summary":"Get groundplane known to the queue at the time of the Flush","since":"6.0"},{"signature":"RenderSettings GetQueueRenderSettings()","summary":"Get render settings known to the queue at the time of the Flush","since":"6.0"},{"signature":"BoundingBox GetQueueSceneBoundingBox()","summary":"Get the scene bounding box","since":"6.0","returns":"Scene bounding box"},{"signature":"Skylight GetQueueSkylight()","summary":"Get skylight known to the queue at the time of the Flush","since":"6.0"},{"signature":"Geometry.Light GetQueueSun()","summary":"Get sun known to the queue at the time of the Flush","since":"6.0"},{"signature":"ViewInfo GetQueueView()","summary":"Get view known to the queue at the time of the Flush","since":"6.0","returns":"ViewInfo"},{"signature":"RenderMaterial MaterialFromId(uint crc)","summary":"Get the RenderMaterial from the ChangeQueue material cache based on RenderHash","since":"6.0","parameters":[{"name":"crc","summary":"The RenderHash"}],"returns":"RenderMaterial"},{"signature":"void OneShot()","summary":"Call Flush() once, after that automatically dispose the queue.","since":"6.0"},{"signature":"RenderTexture TextureForId(uint crc)","summary":"Get RenderTexture for given RenderHash. Can return null.","since":"7.0","parameters":[{"name":"crc","summary":"render hash of the content to search for"}],"returns":"RenderTexture if found for render hash, None otherwise"}]},{"namespace":"Rhino.Render.ChangeQueue","name":"ChangeQueue.BakingFunctions","dataType":"enum","summary":"Enumeration of functions for baking to conduct.","since":"6.0","values":[{"signature":"None = 0x00","summary":"No baking"},{"signature":"Decals = 0x01","summary":"Bake decals"},{"signature":"ProceduralTextures = 0x02","summary":"Bake procedural textures"},{"signature":"CustomObjectMappings = 0x04","summary":"Bake custom object mappings"},{"signature":"WcsBasedMappings = 0x08","summary":"Bake WCS-based mappings"},{"signature":"MultipleMappingChannels = 0x10","summary":"Bake multiple mapping channels"},{"signature":"NoRepeatTextures = 0x20","summary":"Bake no-repeat textures"},{"signature":"All = 0xFFFFFFFF","summary":"Bake everything"}]},{"namespace":"Rhino.Render.ChangeQueue","name":"ClippingPlane","dataType":"class","summary":"ChangeQueue clipping plane","properties":[{"signature":"ObjectAttributes Attributes","summary":"Get the ClippingPlaneObject for this clipping plane","since":"6.0","property":["get"]},{"signature":"Guid Id","summary":"Get Guid for this clipping plane","since":"6.0","property":["get"]},{"signature":"bool IsEnabled","summary":"True if clipping plane is enabled","since":"6.0","property":["get"]},{"signature":"Plane Plane","summary":"Get the plane that represents this clipping plane","since":"6.0","property":["get"]},{"signature":"List<Guid> ViewIds","summary":"Get list of View IDs this clipping plane is supposed to clip.","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Render.ChangeQueue","name":"DisplayRenderSettings","dataType":"class","summary":"ChangeQueue DisplayRenderSettings","properties":[{"signature":"bool CullBackFaces","summary":"True if backfaces should be culled","since":"6.0","property":["get"]},{"signature":"bool ForceFlatShading","summary":"True if flat shading is forced","since":"6.0","property":["get"]},{"signature":"bool SceneLightingOn","summary":"True if scene lighting is enabled","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Render.ChangeQueue","name":"DynamicObjectTransform","dataType":"class","summary":"ChangeQueue DynamicObject","properties":[{"signature":"uint MeshInstanceId","summary":"Get the mesh instance id for this dynamic object.","since":"6.0","property":["get"]},{"signature":"Transform Transform","summary":"Transform for the DynamicObject","since":"6.0","property":["get"]}],"methods":[{"signature":"string ToString()","summary":"String representation of DynamicObject"}]},{"namespace":"Rhino.Render.ChangeQueue","name":"Environment","dataType":"class","summary":"ChangeQueue environment"},{"namespace":"Rhino.Render.ChangeQueue","name":"Environment.FrameBufferFillMode","dataType":"enum","summary":"Fillmode for background","since":"6.0","values":[{"signature":"None = 0","summary":"None set"},{"signature":"DefaultColor = 1","summary":"Use default color"},{"signature":"SolidColor","summary":"Use specified solid color"},{"signature":"Gradient2Color","summary":"Use 2-color gradient"},{"signature":"Gradient4Color","summary":"Use 4-color gradient (colors are specified by corners)"},{"signature":"Bitmap","summary":"Use bitmap"},{"signature":"Renderer","summary":"Use whatever renderer chooses"},{"signature":"Transparent","summary":"Transparent background"},{"signature":"Force32Bit = 0xffffffff","summary":"Use 32bit color @todo verify what this means"}]},{"namespace":"Rhino.Render.ChangeQueue","name":"GroundPlane","dataType":"class","summary":"ChangeQueue ground plane","properties":[{"signature":"double Altitude","summary":"Get the altitude for ground plane","since":"6.0","property":["get"]},{"signature":"uint Crc","summary":"Get the checksum of this groundplane object","since":"6.0","property":["get"]},{"signature":"bool Enabled","summary":"Return True if ground plane is enabled","since":"6.0","property":["get"]},{"signature":"bool IsShadowOnly","summary":"Get True if ground plane should be shadow-only","since":"6.0","property":["get"]},{"signature":"uint MaterialId","summary":"The CRC / RenderHash of the material on this ground plane","since":"6.0","property":["get"]},{"signature":"Vector2d TextureOffset","summary":"Get texture offset on the ground plane","since":"6.0","property":["get"]},{"signature":"double TextureRotation","summary":"Get texture rotation on the ground plane","since":"6.0","property":["get"]},{"signature":"Vector2d TextureScale","summary":"Get texture scale on the ground plane","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Render.ChangeQueue","name":"Light","dataType":"class","summary":"ChangeQueue Light change representation","properties":[{"signature":"Event ChangeType","summary":"Get what type of light change this represents","since":"6.0","property":["get"]},{"signature":"Light Data","summary":"Get the actual light data","since":"6.0","property":["get"]},{"signature":"Guid Id","summary":"Get the light object id","since":"6.0","property":["get"]},{"signature":"uint IdCrc","summary":"Get CRC computed from Id","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Render.ChangeQueue","name":"Light.Event","dataType":"enum","summary":"Light change type","since":"6.0","values":[{"signature":"Added","summary":"Light was added"},{"signature":"Deleted","summary":"Light was deleted"},{"signature":"Undeleted","summary":"Light was undeleted"},{"signature":"Modified","summary":"Light was modified"},{"signature":"Sorted","summary":"Light was sorted in LightTable"}]},{"namespace":"Rhino.Render.ChangeQueue","name":"MappingChannel","dataType":"class","summary":"Mapping Channel for a ChangeQueue Mesh","properties":[{"signature":"Transform Local","summary":"Local transform for the mapping","since":"6.0","property":["get"]},{"signature":"TextureMapping Mapping","summary":"Return TexturMapping for this MappingChannel","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Render.ChangeQueue","name":"MappingChannelCollection","dataType":"class","summary":"MappingChannels for a Mesh","properties":[{"signature":"IEnumerable<MappingChannel> Channels","summary":"Enumerate all available channels in this mapping","since":"6.0","property":["get"]},{"signature":"int Count","summary":"Get count of MappingChannels in this collection","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Render.ChangeQueue","name":"Material","dataType":"class","summary":"Representation of a Material through the change queue","properties":[{"signature":"uint Id","summary":"Get the material ID (crc)","since":"6.0","property":["get"]},{"signature":"int MeshIndex","summary":"Get mesh index","since":"6.0","property":["get"]},{"signature":"uint MeshInstanceId","summary":"Get the material InstanceAncestry","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Render.ChangeQueue","name":"Mesh","dataType":"class","summary":"Representation of ChangeQueue Mesh","properties":[{"signature":"ObjectAttributes Attributes","summary":"Get object attributes of object associated to this mesh. This will be possible only after returning True from ChangeQueue.ProvideOriginalObject()","since":"6.0","property":["get"]},{"signature":"MappingChannelCollection Mapping","summary":"Get the mapping for this mesh.","since":"6.0","property":["get"]},{"signature":"RhinoObject Object","summary":"Get a copy of the original RhinoObject this Mesh is created from. Possible only after return True from ChangeQueue.ProvideOriginalObject().  Access this only with a using(var o = mesh.Object) {} construct.  Note that the object is free floating, i.e. not part of a document.","since":"6.8","property":["get"]},{"signature":"MappingChannel SingleMapping","summary":"Get texture mapping info as single mapping","since":"6.0","property":["get"]}],"methods":[{"signature":"Geometry.Mesh[] GetMeshes()","summary":"Get a SimpleArrayMeshPointer containing all meshes for the related Mesh","since":"6.0"},{"signature":"Guid Id()","summary":"Get the Object Guid this mesh is for.","since":"6.0","returns":"Guid of parent object."}]},{"namespace":"Rhino.Render.ChangeQueue","name":"MeshInstance","dataType":"class","summary":"Representation of ChangeQueue MeshInstance","properties":[{"signature":"bool CastShadows","summary":"Return True if mesh instance should cast shadows","since":"6.0","property":["get"]},{"signature":"Decals Decals","summary":"Access to the decals for this MeshInstance if any. Null if no decal iterator exists for this mesh instance","since":"7.0","property":["get"]},{"signature":"uint GroupId","summary":"Get identifier that specifies the grouping of these mesh instances - usually based on the object that this originally comprised.","since":"6.0","property":["get"]},{"signature":"uint InstanceId","summary":"Get the instance identifier for this mesh instance.","since":"6.0","property":["get"]},{"signature":"uint MaterialId","summary":"The Material CRC / RenderHash","since":"6.0","property":["get"]},{"signature":"Guid MeshId","summary":"Get the mesh identifier for this mesh instance.","since":"6.0","property":["get"]},{"signature":"int MeshIndex","summary":"Get the mesh index for this mesh instance.","since":"6.0","property":["get"]},{"signature":"Transform OcsTransform","summary":"OCS Transform for the MeshInstance - this is the Object Coordinate System texture mapping transformation set in the texture mapping properties dialog. (identity means no OCS, potentially just simple WCS/WCS Box)","since":"7.0","property":["get"]},{"signature":"bool ReceiveShadows","summary":"Return True if mesh instance should receive shadows","since":"6.0","property":["get"]},{"signature":"RenderMaterial RenderMaterial","summary":"RenderMaterial associated with mesh instance","since":"6.0","property":["get"]},{"signature":"Transform Transform","summary":"Transform for the MeshInstance","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Render.ChangeQueue","name":"Skylight","dataType":"class","summary":"ChangeQueue skylight","properties":[{"signature":"bool Enabled","summary":"Return True if skylight is enabled","since":"6.0","property":["get"]},{"signature":"double ShadowIntensity","summary":"Get shadow intensity for skylight","since":"6.0","property":["get"]},{"signature":"bool UsesCustomEnvironment","summary":"Return True if skylight uses custom environment","since":"6.0","property":["get"]}],"methods":[{"signature":"string ToString()","summary":"Textual representation of Skylight"}]},{"namespace":"Rhino.Render.ChildSlotNames","name":"PhysicallyBased","dataType":"class","summary":"Helper class with properties containing the names of children available in our PBR implementation.","properties":[{"signature":"static string AmbientOcclusion","since":"7.0","property":["get"]},{"signature":"static string Anisotropic","since":"7.0","property":["get"]},{"signature":"static string AnisotropicRotation","since":"7.0","property":["get"]},{"signature":"static string BaseColor","since":"7.0","property":["get"]},{"signature":"static string Bump","since":"7.0","property":["get"]},{"signature":"static string Clearcoat","since":"7.0","property":["get"]},{"signature":"static string ClearcoatBump","since":"7.0","property":["get"]},{"signature":"static string ClearcoatRoughness","since":"7.0","property":["get"]},{"signature":"static string Displacement","since":"7.0","property":["get"]},{"signature":"static string Emission","since":"7.0","property":["get"]},{"signature":"static string Metallic","since":"7.0","property":["get"]},{"signature":"static string Opacity","since":"7.0","property":["get"]},{"signature":"static string OpacityIor","since":"7.0","property":["get"]},{"signature":"static string OpacityRoughness","since":"7.0","property":["get"]},{"signature":"static string Roughness","since":"7.0","property":["get"]},{"signature":"static string Sheen","since":"7.0","property":["get"]},{"signature":"static string SheenTint","since":"7.0","property":["get"]},{"signature":"static string Specular","since":"7.0","property":["get"]},{"signature":"static string SpecularTint","since":"7.0","property":["get"]},{"signature":"static string Subsurface","since":"7.0","property":["get"]},{"signature":"static string SubsurfaceScatteringColor","since":"7.0","property":["get"]},{"signature":"static string SubsurfaceScatteringRadius","since":"7.0","property":["get"]}],"methods":[{"signature":"static string FromTextureType(TextureType textureType)","since":"7.0"}]},{"namespace":"Rhino.Render","name":"City","dataType":"class","summary":"City","properties":[{"signature":"double Latitude","summary":"Gets latitude of city.","since":"6.0","property":["get"]},{"signature":"double Longitude","summary":"Gets longitude of city.","since":"6.0","property":["get"]},{"signature":"String Name","summary":"Gets name of city.","since":"6.0","property":["get"]},{"signature":"double TimeZone","summary":"Gets time zone of city.","since":"6.0","property":["get"]}],"methods":[{"signature":"static int Cities()","summary":"Returns number of available cities.","since":"6.0","returns":"City count."},{"signature":"static City CityAt(int index)","summary":"Returns city at given index.","since":"6.0","parameters":[{"name":"index","summary":"index."}],"returns":"City at index."},{"signature":"static City FindNearest(double latitude, double longitude)","summary":"Finds nearest city of specified input parameters.","since":"6.0","parameters":[{"name":"latitude","summary":"latitude."},{"name":"longitude","summary":"longitude."}],"returns":"Nearest city."}]},{"namespace":"Rhino.Render","name":"ComponentOrders","dataType":"enum","summary":"Pixel component order for channels in the RenderWindow and PostEffects.","since":"7.0","values":[{"signature":"Irrelevant = 0x00","summary":"Used in single-value channels."},{"signature":"RGBA = 0x01","summary":"This is the default (to match Rhino 5)"},{"signature":"ARGB = 0x02","summary":"ARGB component order"},{"signature":"RGB = 0x03","summary":"This will only access 3 components, even in the case of the RGBA channel"},{"signature":"BGR = 0x04","summary":"This will only access 3 components, even in the case of the RGBA channel."},{"signature":"ABGR = 0x05","summary":"ABGR component order"},{"signature":"BGRA = 0x06","summary":"BGRA component order"},{"signature":"XYZ = RGB","summary":"For readability when using the Normal XYZ channel.  Same as RGB"},{"signature":"ZYX = BGR","summary":"For readability when using the Normal XYZ channel.  Same as BGR"}]},{"namespace":"Rhino.Render","name":"ContentCollectionIterator","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"ContentCollectionIterator(IntPtr pCollection)","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.0","property":["get"]}],"methods":[{"signature":"void DeleteThis()","since":"6.0"},{"signature":"void Dispose()","since":"6.0"},{"signature":"RenderContent First()","since":"6.0"},{"signature":"RenderContent Next()","since":"6.0"}]},{"namespace":"Rhino.Render","name":"ContentUndoBlocker","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"ContentUndoBlocker()","summary":"Constructs a ContentUndoBlocker object inside a using block to block undo when modifying a RenderContent while a ContentUndoHelper is active. Alternatively - create the ContentUndoBlocker and explicitly call Dispose when you are done.","since":"5.10"}],"methods":[{"signature":"void Dispose()","since":"5.10"}]},{"namespace":"Rhino.Render","name":"ContentUndoHelper","dataType":"class","summary":"Content undo helper to be used with \\"using {}\\" to enclose a block of changes.","interfaces":["IDisposable"],"constructors":[{"signature":"ContentUndoHelper(RhinoDoc doc, String description)","summary":"Constructs a ContentUndoHelper object inside a using block to handle undo when modifying a RenderContent or - alternatively - create the ContentUndoHelper and explicitly call Dispose when you are done.","since":"6.0","parameters":[{"name":"doc","summary":""},{"name":"description","summary":"Undo description (which appears in the UI when undo is run)"}]}],"methods":[{"signature":"bool AddContent(RenderContent content, RenderContent parent)","summary":"Call this *after* adding a content. Undo will cause the content to be deleted.","since":"6.0","parameters":[{"name":"content","summary":"Content you just added to the ContentList."},{"name":"parent","summary":"is the content that will become the parent of the new content, or None if the new content is being added at the top level (i.e., not a child)."}],"returns":"True if the content was added."},{"signature":"void Dispose()","since":"6.0"},{"signature":"bool ModifyContent(RenderContent content)","summary":"Call this before modifying or deleting a content. Undo will cause the content to be restored.","since":"6.0","parameters":[{"name":"content","summary":"Content you are about to modify."}],"returns":"True if the content was modified."},{"signature":"bool TweakContent(RenderContent content, String parameterName)","summary":"Call this before tweaking a single content parameter. Undo will cause the parameter to be restored.","since":"6.0","parameters":[{"name":"content","summary":"The render content"},{"name":"parameterName","summary":"The parameter name you are about to change."}],"returns":"True if the content was tweaked."}]},{"namespace":"Rhino.Render","name":"ContentUuids","dataType":"class","summary":"Content Guids of RenderContent provided by the RDK SDK.  These Guids can be used to check against RenderContent.TypeId.","properties":[{"signature":"static Guid AdvancedDotTextureType","since":"6.0","property":["get"]},{"signature":"static Guid BasicEnvironmentCCI","since":"6.0","property":["get"]},{"signature":"static Guid BasicEnvironmentType","since":"6.0","property":["get"]},{"signature":"static Guid BasicMaterialCCI","since":"6.0","property":["get"]},{"signature":"static Guid BasicMaterialType","since":"6.0","property":["get"]},{"signature":"static Guid BitmapTextureType","since":"6.0","property":["get"]},{"signature":"static Guid BlendMaterialCCI","since":"6.0","property":["get"]},{"signature":"static Guid BlendMaterialType","since":"6.0","property":["get"]},{"signature":"static Guid BlendTextureType","since":"6.0","property":["get"]},{"signature":"static Guid CompositeMaterialCCI","since":"6.0","property":["get"]},{"signature":"static Guid CompositeMaterialType","since":"6.0","property":["get"]},{"signature":"static Guid CrossHatchBumpTexture","since":"6.0","property":["get"]},{"signature":"static Guid CubeMapTextureType","since":"6.0","property":["get"]},{"signature":"static Guid DefaultEnvironmentInstance","since":"6.0","property":["get"]},{"signature":"static Guid DefaultMaterialInstance","since":"6.0","property":["get"]},{"signature":"static Guid DotBumpTexture","since":"6.0","property":["get"]},{"signature":"static Guid DoubleSidedMaterialType","since":"7.0","property":["get"]},{"signature":"static Guid EmissionMaterialType","since":"7.0","property":["get"]},{"signature":"static Guid ExposureTextureType","since":"6.0","property":["get"]},{"signature":"static Guid EXRTextureType","since":"6.0","property":["get"]},{"signature":"static Guid FBmTextureType","since":"6.0","property":["get"]},{"signature":"static Guid GemMaterialType","since":"6.0","property":["get"]},{"signature":"static Guid GlassMaterialType","since":"6.0","property":["get"]},{"signature":"static Guid GradientTextureType","since":"6.0","property":["get"]},{"signature":"static Guid GraniteTextureType","since":"6.0","property":["get"]},{"signature":"static Guid GridTextureType","since":"6.0","property":["get"]},{"signature":"static Guid GritBumpTexture","since":"6.0","property":["get"]},{"signature":"static Guid HatchBumpTexture","since":"6.0","property":["get"]},{"signature":"static Guid HDRTextureType","since":"6.0","property":["get"]},{"signature":"static Guid LeatherBumpTexture","since":"6.0","property":["get"]},{"signature":"static Guid MarbleTextureType","since":"6.0","property":["get"]},{"signature":"static Guid MaskTextureType","since":"6.0","property":["get"]},{"signature":"static Guid MetalMaterialType","since":"6.0","property":["get"]},{"signature":"static Guid NoiseTextureType","since":"6.0","property":["get"]},{"signature":"static Guid PaintMaterialType","since":"6.0","property":["get"]},{"signature":"static Guid PerlinMarbleTextureType","since":"6.0","property":["get"]},{"signature":"static Guid PerturbingTextureType","since":"6.0","property":["get"]},{"signature":"static Guid PhysicallyBasedMaterialType","since":"7.0","property":["get"]},{"signature":"static Guid PictureMaterialType","since":"6.0","property":["get"]},{"signature":"static Guid PlasterMaterialType","since":"6.0","property":["get"]},{"signature":"static Guid PlasticMaterialType","since":"6.0","property":["get"]},{"signature":"static Guid ProjectionChangerTextureType","since":"6.0","property":["get"]},{"signature":"static Guid RealtimeDisplayMaterialType","since":"6.0","property":["get"]},{"signature":"static Guid ResampleTextureType","since":"6.0","property":["get"]},{"signature":"static Guid SimpleBitmapTextureType","since":"6.0","property":["get"]},{"signature":"static Guid SingleColorTextureType","since":"6.0","property":["get"]},{"signature":"static Guid SpeckleBumpTexture","since":"6.0","property":["get"]},{"signature":"static Guid StuccoTextureType","since":"6.0","property":["get"]},{"signature":"static Guid Texture2DCheckerTextureType","since":"6.0","property":["get"]},{"signature":"static Guid Texture3DCheckerTextureType","since":"6.0","property":["get"]},{"signature":"static Guid TextureAdjustmentTextureType","since":"6.0","property":["get"]},{"signature":"static Guid TileTextureType","since":"6.0","property":["get"]},{"signature":"static Guid TurbulenceTextureType","since":"6.0","property":["get"]},{"signature":"static Guid WavesTextureType","since":"6.0","property":["get"]},{"signature":"static Guid WoodBumpTexture","since":"6.0","property":["get"]},{"signature":"static Guid WoodTextureType","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Render","name":"ConvertibleExtensions","dataType":"class","summary":"Extension methods for IConvertible that work when an object is a Variant.","methods":[{"signature":"static Color4f ToColor4f(this IConvertible variant)","since":"6.0"},{"signature":"static Vector2d ToVector2d(this IConvertible variant)","since":"6.0"},{"signature":"static Vector3d ToVector3d(this IConvertible variant)","since":"6.0"}]},{"namespace":"Rhino.Render","name":"CrcRenderHashFlags","dataType":"enum","since":"6.2","values":[{"signature":"Normal                 = 0"},{"signature":"ExcludeLinearWorkflow  = 1"},{"signature":"ExcludeLocalMapping    = 2"},{"signature":"Reserved1              = 4"},{"signature":"Reserved2              = 8"}]},{"namespace":"Rhino.Render","name":"CreatePreviewEventArgs","dataType":"class","summary":"Used in RenderPlugIn virtual CreatePreview function","baseclass":"EventArgs","properties":[{"signature":"bool Cancel","summary":"Get set by Rhino if the preview generation should be canceled for this","since":"5.1","property":["get","set"]},{"signature":"RenderContentKind ContentKind","summary":"Description of content that preview is being generated for.","since":"6.0","property":["get"]},{"signature":"Guid ContentTypeId","summary":"The class Id of content that preview is being generated for.","since":"6.0","property":["get"]},{"signature":"RenderEnvironment Environment","summary":"The environment that the previewed object is rendered in.","since":"5.1","property":["get"]},{"signature":"int Id","summary":"Unique Id for this scene.","since":"5.1","property":["get"]},{"signature":"Light> Lights","since":"5.1","property":["get"]},{"signature":"List<SceneObject> Objects","since":"5.1","property":["get"]},{"signature":"RenderContent PreviewContent","summary":"Obsolete, will return always null","since":"5.1","property":["get"]},{"signature":"Bitmap PreviewImage","summary":"Initially null.  If this image is set, then this image will be used for the preview.  If never set, the default internal simulation preview will be used.","since":"5.1","property":["get","set"]},{"signature":"Size PreviewImageSize","summary":"Pixel size of the image that is being requested for the preview scene","since":"5.1","property":["get"]},{"signature":"PreviewNotification PreviewNotifier","since":"6.0","property":["get","set"]},{"signature":"PreviewSceneQuality Quality","summary":"Quality of the preview image that is being requested for the preview scene","since":"5.1","property":["get"]},{"signature":"CreatePreviewReason Reason","summary":"Reason the preview is getting generated","since":"5.11","property":["get"]},{"signature":"ViewportInfo Viewport","since":"5.1","property":["get"]}],"methods":[{"signature":"void SkipInitialisation()","summary":"Call this if you don\'t want the argument to handle data initialisation.  This is for use with the ChangeQueue","since":"6.0"}]},{"namespace":"Rhino.Render","name":"CreatePreviewEventArgs.SceneObject","dataType":"class","properties":[{"signature":"RenderMaterial Material","since":"5.1","property":["get"]},{"signature":"Mesh Mesh","since":"5.1","property":["get"]}]},{"namespace":"Rhino.Render","name":"CreatePreviewReason","dataType":"enum","summary":"Reason the content preview is being generated","since":"5.11","values":[{"signature":"ContentChanged = UnsafeNativeMethods.CRhRdkPlugInQuickPreviewReason.ContentChanged"},{"signature":"ViewChanged = UnsafeNativeMethods.CRhRdkPlugInQuickPreviewReason.ViewChanged"},{"signature":"RefreshDisplay = UnsafeNativeMethods.CRhRdkPlugInQuickPreviewReason.RefreshDisplay"},{"signature":"UpdateBitmap = UnsafeNativeMethods.CRhRdkPlugInQuickPreviewReason.UpdateBitmap"},{"signature":"Other = UnsafeNativeMethods.CRhRdkPlugInQuickPreviewReason.Other"}]},{"namespace":"Rhino.Render","name":"CreateTexture2dPreviewEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"Bitmap PreviewImage","summary":"Initially null.  If this image is set, then this image will be used for the preview.  If never set, the default internal simulation preview will be used.","since":"5.1","property":["get","set"]},{"signature":"Size PreviewImageSize","summary":"Pixel size of the image that is being requested for the preview scene","since":"5.1","property":["get"]}]},{"namespace":"Rhino.Render","name":"CustomRenderContentAttribute","dataType":"class","baseclass":"Attribute","constructors":[{"signature":"CustomRenderContentAttribute(string renderEngineGuid, bool imageBased, string category, bool is_elevated, bool is_built_in, bool is_private)","since":"6.0"},{"signature":"CustomRenderContentAttribute(string renderEngineGuid, bool imageBased, string category, bool is_elevated, bool is_built_in, bool is_private, bool is_linear, bool is_hdrcapable, bool is_normalmap)","since":"6.16"}],"properties":[{"signature":"string Category","since":"6.0","property":["get","set"]},{"signature":"bool ImageBased","since":"6.0","property":["get","set"]},{"signature":"bool IsBuiltIn","since":"6.0","property":["get","set"]},{"signature":"bool IsElevated","since":"6.0","property":["get","set"]},{"signature":"bool IsHdrCapable","since":"6.16","property":["get","set"]},{"signature":"bool IsLinear","since":"6.16","property":["get","set"]},{"signature":"bool IsNormalMap","since":"6.16","property":["get","set"]},{"signature":"bool IsPrivate","since":"6.0","property":["get","set"]},{"signature":"Guid RenderEngineId","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Render","name":"CustomRenderMeshProvider","dataType":"class","summary":"You must call CustomRenderMeshProvider.RegisterProviders() from your plug-ins OnLoad override for each assembly containing a custom mesh provider.  Only publicly exported classes derived from CustomRenderMeshProvider with a public constructor that has no parameters will get registered.","properties":[{"signature":"static Guid CurvePipingId","since":"6.0","deprecated":"6.0","property":["get"]},{"signature":"static Guid DisplacementId","since":"6.0","deprecated":"6.0","property":["get"]},{"signature":"static Guid EdgeSofteningId","since":"6.0","deprecated":"6.0","property":["get"]},{"signature":"static Guid ShutLiningId","since":"6.0","deprecated":"6.0","property":["get"]},{"signature":"static Guid ThickeningId","since":"6.0","deprecated":"6.0","property":["get"]},{"signature":"String Name","summary":"The name of the provider for UI display.","since":"5.7","deprecated":"6.0","property":["get"]}],"methods":[{"signature":"static void AllObjectsChanged()","summary":"Call this method if your render meshes change.","since":"5.7","deprecated":"6.0"},{"signature":"static void AllObjectsChanged(RhinoDoc doc)","summary":"Call this method if your render meshes change.","since":"6.0","deprecated":"6.0"},{"signature":"static void DocumentBasedMeshesChanged(RhinoDoc doc)","since":"6.0","deprecated":"6.0"},{"signature":"static void ObjectChanged(RhinoDoc doc, RhinoObject obj)","since":"6.0","deprecated":"6.0"},{"signature":"static void RegisterProviders(Assembly assembly, Guid pluginId)","summary":"Call this method once from your plug-ins OnLoad override for each assembly containing a custom mesh provider.  Only publicly exported classes derived from CustomRenderMeshProvider with a public constructor that has no parameters will get registered.","since":"5.7","deprecated":"6.0","parameters":[{"name":"assembly","summary":"Assembly to search for valid CustomRenderMeshProvider derived classes."},{"name":"pluginId","summary":"The plug-in that owns the custom mesh providers."}]},{"signature":"BoundingBox BoundingBox(ViewportInfo vp, RhinoObject obj, Guid requestingPlugIn, bool preview)","summary":"Returns a bounding box for the custom render meshes for the given object.","since":"5.7","deprecated":"6.0","parameters":[{"name":"vp","summary":"The viewport being rendered."},{"name":"obj","summary":"The Rhino object of interest.  This can be None in the case where document meshes (not associated with any object) are being requested."},{"name":"requestingPlugIn","summary":"UUID of the RDK plug-in requesting the meshes."},{"name":"preview","summary":"Type of mesh to build."}],"returns":"A bounding box value."},{"signature":"BoundingBox BoundingBox(ViewportInfo vp, RhinoObject obj, RhinoDoc doc, Guid requestingPlugIn, DisplayPipelineAttributes attrs)","since":"6.0","deprecated":"6.0"},{"signature":"bool BuildCustomMeshes(ViewportInfo vp, RenderPrimitiveList objMeshes, Guid requestingPlugIn, bool meshType)","summary":"Build custom render mesh(es).","since":"5.7","deprecated":"6.0","parameters":[{"name":"vp","summary":"The viewport being rendered."},{"name":"objMeshes","summary":"The meshes class to populate with custom meshes."},{"name":"requestingPlugIn","summary":"UUID of the RDK plug-in requesting the meshes."},{"name":"meshType","summary":"Type of mesh to build."}],"returns":"True if operation was successful."},{"signature":"bool WillBuildCustomMeshes(ViewportInfo vp, RhinoObject obj, Guid requestingPlugIn, bool preview)","summary":"Determines if custom render meshes will be built for a particular object.","since":"5.7","deprecated":"6.0","parameters":[{"name":"vp","summary":"The viewport being rendered."},{"name":"obj","summary":"The Rhino object of interest.  This can be None in the case where document meshes (not associated with any object) are being requested."},{"name":"requestingPlugIn","summary":"UUID of the RDK plug-in requesting the meshes."},{"name":"preview","summary":"Type of mesh to build."}],"returns":"True if custom meshes will be built."}]},{"namespace":"Rhino.Render","name":"CustomRenderMeshProvider2","dataType":"class","baseclass":"Rhino.Render.CustomRenderMeshProvider","methods":[{"signature":"BoundingBox BoundingBox(ViewportInfo vp, RhinoObject obj, Guid requestingPlugIn, bool preview)","since":"6.4"},{"signature":"BoundingBox BoundingBox(ViewportInfo vp, RhinoObject obj, RhinoDoc doc, Guid requestingPlugIn, DisplayPipelineAttributes attrs)","since":"6.0"},{"signature":"bool BuildCustomMeshes(ViewportInfo vp, RenderPrimitiveList objMeshes, Guid requestingPlugIn, bool preview)","since":"6.4"},{"signature":"bool BuildCustomMeshes(ViewportInfo vp, RhinoDoc doc, RenderPrimitiveList objMeshes, Guid requestingPlugIn, DisplayPipelineAttributes attrs)","since":"6.0"},{"signature":"bool WillBuildCustomMeshes(ViewportInfo vp, RhinoObject obj, Guid requestingPlugIn, bool preview)","since":"6.4"},{"signature":"bool WillBuildCustomMeshes(ViewportInfo vp, RhinoObject obj, RhinoDoc doc, Guid requestingPlugIn, DisplayPipelineAttributes attrs)","since":"6.0"}]},{"namespace":"Rhino.Render.DataSources","name":"AssignBys","dataType":"enum","since":"6.0","values":[{"signature":"Unset"},{"signature":"Layer"},{"signature":"Parent"},{"signature":"Object"},{"signature":"Varies"},{"signature":"PlugIn"}]},{"namespace":"Rhino.Render.DataSources","name":"ContentDatabaseEventInfo.AttachReason","dataType":"enum","values":[{"signature":"Attach"},{"signature":"Change"},{"signature":"Undo"},{"signature":"Open"},{"signature":"Edit"}]},{"namespace":"Rhino.Render.DataSources","name":"ContentDatabaseEventInfo.DetachReason","dataType":"enum","values":[{"signature":"Detach"},{"signature":"Change"},{"signature":"Undo"},{"signature":"Delete"},{"signature":"Edit"}]},{"namespace":"Rhino.Render.DataSources","name":"ContentDatabaseEventInfo.Types","dataType":"enum","values":[{"signature":"Attached"},{"signature":"Detaching"},{"signature":"Detached"},{"signature":"Replacing"},{"signature":"Replaced"},{"signature":"Blossom"}]},{"namespace":"Rhino.Render.DataSources","name":"ContentEditorSettings.Layouts","dataType":"enum","values":[{"signature":"Horizontal"},{"signature":"Vertical"}]},{"namespace":"Rhino.Render.DataSources","name":"ContentEditorSettings.Splitters","dataType":"enum","values":[{"signature":"HA"},{"signature":"HB"},{"signature":"HC"},{"signature":"VA"},{"signature":"VB"},{"signature":"VC"}]},{"namespace":"Rhino.Render.DataSources","name":"ContentFactories","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"ContentFactories(IntPtr pRdkContentFactories)","since":"6.1"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.1","property":["get"]}],"methods":[{"signature":"void Dispose()","since":"6.1"},{"signature":"ContentFactory FindFactory(Guid uuid)","since":"6.7"},{"signature":"ContentFactory FirstFactory()","since":"6.1"},{"signature":"ContentFactory NextFactory()","since":"6.1"}]},{"namespace":"Rhino.Render.DataSources","name":"ContentFactory","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"ContentFactory(IntPtr pRdkContentFactory)","since":"6.1"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.1","property":["get"]}],"methods":[{"signature":"Guid ContentTypeId()","since":"6.7"},{"signature":"void Dispose()","since":"6.1"},{"signature":"RenderContentKind Kind()","since":"6.3"},{"signature":"RenderContent NewContent()","summary":"New Content returns a new content, which is Initialized with the Initialize() function. The content should be unitilized after use with the Unitialize function.","since":"6.1"}]},{"namespace":"Rhino.Render.DataSources","name":"ContentParamEventInfo.Types","dataType":"enum","values":[{"signature":"Name"},{"signature":"Notes"},{"signature":"Tags"},{"signature":"GroupId"},{"signature":"Param"}]},{"namespace":"Rhino.Render.DataSources","name":"DecalEventInfo.Operations","dataType":"enum","values":[{"signature":"Add"},{"signature":"Delete"},{"signature":"Modify"}]},{"namespace":"Rhino.Render.DataSources","name":"MetaData","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"MetaData(IntPtr pMetaData)","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.0","property":["get"]}],"methods":[{"signature":"Guid ContentInstanceId()","since":"6.7"},{"signature":"void Dispose()","since":"6.0"},{"signature":"string Geometry()","since":"6.0"}]},{"namespace":"Rhino.Render.DataSources","name":"Modes","dataType":"enum","since":"6.0","values":[{"signature":"Unset"},{"signature":"Grid"},{"signature":"List"},{"signature":"Tree"}]},{"namespace":"Rhino.Render.DataSources","name":"NamedItemCommand.States","dataType":"enum","values":[{"signature":"Off = UnsafeNativeMethods.NamedItemCommand_States.Off"},{"signature":"On = UnsafeNativeMethods.NamedItemCommand_States.On"},{"signature":"Varies = UnsafeNativeMethods.NamedItemCommand_States.Varies"},{"signature":"Unknown = UnsafeNativeMethods.NamedItemCommand_States.Unknown"}]},{"namespace":"Rhino.Render.DataSources","name":"NamedItems.CommandFilters","dataType":"enum","values":[{"signature":"ToolButton = UnsafeNativeMethods.NamedItems_CommandFilters.ToolButton"},{"signature":"MenuItem = UnsafeNativeMethods.NamedItems_CommandFilters.MenuItem"},{"signature":"CheckBox = UnsafeNativeMethods.NamedItems_CommandFilters.CheckBox"},{"signature":"All = UnsafeNativeMethods.NamedItems_CommandFilters.All"}]},{"namespace":"Rhino.Render.DataSources","name":"NamedItems.DisplayModes","dataType":"enum","values":[{"signature":"List = UnsafeNativeMethods.NamedItems_DisplayMode.List"},{"signature":"Thumbnail = UnsafeNativeMethods.NamedItems_DisplayMode.Thumbnail"}]},{"namespace":"Rhino.Render.DataSources","name":"ParamBlock.UiHints","dataType":"enum","values":[{"signature":"None"},{"signature":"Folder"},{"signature":"Filename"},{"signature":"Combo"},{"signature":"Solar"},{"signature":"Location"}]},{"namespace":"Rhino.Render.DataSources","name":"RdkEdit","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"RdkEdit(IntPtr pRdkEdit)","since":"6.5"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.5","property":["get"]}],"methods":[{"signature":"void Dispose()","since":"6.5"},{"signature":"bool Execute(RenderContentCollection collection)","since":"6.5"}]},{"namespace":"Rhino.Render.DataSources","name":"RdkModalEditContentBucket","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"RdkModalEditContentBucket(IntPtr pRdkModalEditContentBucket)","since":"6.5","deprecated":"6.13"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.5","deprecated":"6.13","property":["get"]}],"methods":[{"signature":"RenderContentCollection ContentsIn()","since":"6.5","deprecated":"6.13"},{"signature":"void Dispose()","since":"6.5","deprecated":"6.13"},{"signature":"void SetContentsOut(RenderContentCollection collection)","since":"6.5","deprecated":"6.13"}]},{"namespace":"Rhino.Render.DataSources","name":"RdkSelectionNavigator","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"RdkSelectionNavigator(IntPtr pRhinoSettings)","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.0","property":["get"]}],"methods":[{"signature":"void Add(RenderContentCollection selectedContentArray)","summary":"Add a selection of contents at the current position. Clears the navigator ahead of the current position.","since":"6.0","parameters":[{"name":"selectedContentArray","summary":"The selected content"}]},{"signature":"bool CanGoBackwards()","summary":"Check the backwards status of the navigator","since":"6.0","returns":"True if it is possible to navigate backwards, else false"},{"signature":"bool CanGoForwards()","summary":"Check the forwards status of the navigator","since":"6.0","returns":"True if it is possible to navigate forwards, else false"},{"signature":"void Clear()","summary":"Clear the navigator.","since":"6.0"},{"signature":"void Dispose()","since":"6.0"},{"signature":"bool GoBackwards(ref RenderContentCollection selectedContentArray)","summary":"Navigate backwards if possible","since":"6.0","parameters":[{"name":"selectedContentArray","summary":"selectedContentArray is the new selection after navigating backwards"}],"returns":"True on success, else false"},{"signature":"bool GoForwards(ref RenderContentCollection selectedContentArray)","summary":"Navigate forwards if possible","since":"6.0","parameters":[{"name":"selectedContentArray","summary":"selectedContentArray is the new selection after navigating forwards"}],"returns":"True on success, else false"}]},{"namespace":"Rhino.Render.DataSources","name":"RhinoSettings","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"RhinoSettings(IntPtr pRhinoSettings)","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.0","property":["get"]},{"signature":"bool CustomImageSizeIsPreset","since":"7.0","property":["get","set"]}],"methods":[{"signature":"RhinoView ActiveView()","since":"6.0"},{"signature":"void Dispose()","since":"6.0"},{"signature":"List<System.Drawing.Size> GetCustomRenderSizes()","since":"6.0"},{"signature":"RenderSettings GetRenderSettings()","since":"6.0"},{"signature":"bool GroundPlaneOnInViewDisplayMode(RhinoView view)","since":"6.14"},{"signature":"Rhino.DocObjects.ViewInfo RenderingView()","since":"6.12"},{"signature":"void SetGroundPlaneOnInViewDisplayMode(RhinoView view, bool bOn)","since":"6.14"},{"signature":"void SetRenderSettings(RenderSettings renderSettings)","since":"6.0"},{"signature":"bool ViewSupportsShading(RhinoView view)","since":"6.14"}]},{"namespace":"Rhino.Render.DataSources","name":"Shapes","dataType":"enum","since":"6.0","values":[{"signature":"Square"},{"signature":"Wide"}]},{"namespace":"Rhino.Render.DataSources","name":"Sizes","dataType":"enum","since":"6.0","values":[{"signature":"Unset"},{"signature":"Tiny"},{"signature":"Small"},{"signature":"Medium"},{"signature":"Large"}]},{"namespace":"Rhino.Render","name":"Decal","dataType":"class","summary":"Represents a decal, or a picture that can be moved on an object.","interfaces":["IDisposable"],"properties":[{"signature":"int CRC","summary":"The decal CRC identifies a decal by its state. Multiple decals which would be exactly the same would have the same CRC and are culled from the system. If you store this value with the intention of using it to find the decal again later, you must update your stored value whenever the decal state changes. You can detect when a decal changes by watching for the OnUserDataTransformed event.","since":"6.0","property":["get"]},{"signature":"DecalMapping DecalMapping","summary":"Gets the mapping of the decal.","since":"5.10","property":["get"]},{"signature":"DecalProjection DecalProjection","summary":"Gets the decal\'s projection. Used only when mapping is planar.","since":"5.10","property":["get"]},{"signature":"double EndLatitude","summary":"Gets the end angle of the decal\'s arc of latitude or \'horizontal sweep\'. This is actually a LONGITUDINAL angle. Only used when mapping is cylindrical or spherical.","since":"5.10","property":["get"]},{"signature":"double EndLongitude","summary":"Gets the end angle of the decal\'s arc of longitude or \'vertical sweep\'. This is actually a LATITUDINAL angle. Only used when mapping is spherical.","since":"5.10","property":["get"]},{"signature":"double Height","summary":"Gets the height of the decal. Only used when mapping is cylindrical.","since":"5.10","property":["get"]},{"signature":"bool MapToInside","summary":"Used only when mapping is cylindrical or spherical.","since":"5.10","property":["get"]},{"signature":"Point3d Origin","summary":"Gets the origin of the decal in world space.","since":"5.10","property":["get"]},{"signature":"double Radius","summary":"Gets the radius of the decal. Only used when mapping is cylindrical or spherical.","since":"5.10","property":["get"]},{"signature":"double StartLatitude","summary":"Gets the start angle of the decal\'s arc of latitude or \'horizontal sweep\'. This is actually a LONGITUDINAL angle. Only used when mapping is cylindrical or spherical.","since":"5.10","property":["get"]},{"signature":"double StartLongitude","summary":"Gets the start angle of the decal\'s arc of longitude or \'vertical sweep\'. This is actually a LATITUDINAL angle. Only used when mapping is spherical.","since":"5.10","property":["get"]},{"signature":"Guid TextureInstanceId","summary":"Gets the texture ID for this decal.","since":"5.10","property":["get"]},{"signature":"double Transparency","summary":"Gets the decal\'s transparency in the range 0 to 1.","since":"5.10","property":["get"]},{"signature":"Vector3d VectorAcross","summary":"Gets the vector across. For cylindrical and spherical mapping, the vector is unitized.","since":"5.10","property":["get"]},{"signature":"Vector3d VectorUp","summary":"For cylindrical and spherical mapping, the vector is unitized.","since":"5.10","property":["get"]}],"methods":[{"signature":"static Decal Create(DecalCreateParams createParams)","since":"5.10"},{"signature":"IntPtr ConstPointer()","since":"5.10"},{"signature":"List<Rhino.Render.NamedValue> CustomData()","summary":"Gets custom data associated with this decal - see Rhino.Plugins.RenderPlugIn.ShowDecalProperties.","since":"6.0","returns":"The return value can be None if there is no data associated with this decal."},{"signature":"void Dispose()","since":"5.10"},{"signature":"void Dispose(bool isDisposing)","since":"5.10"},{"signature":"TextureMapping GetTextureMapping()","summary":"The TextureMapping of the decal.","since":"7.0"},{"signature":"IntPtr NonConstPointer()","since":"5.10"},{"signature":"uint TextureRenderCRC(TextureRenderHashFlags rh)","summary":"Get the texture render CRC for the referenced texture using the TextureRenderHashFlags given","since":"7.0"},{"signature":"uint TextureRenderCRC(TextureRenderHashFlags rh, LinearWorkflow lw)","summary":"Get the texture render CRC for the referenced texture using the TextureRenderHashFlags given along with the LinearWorkflow","since":"7.0"},{"signature":"bool TryGetColor(Point3d point, Vector3d normal, ref Color4f colInOut, ref Point2d uvOut)","summary":"Blend color with the decal color at a given point.","since":"5.10","parameters":[{"name":"point","summary":"The point in space or, if the decal is uv-mapped, the uv-coordinate of that point."},{"name":"normal","summary":"The face normal of the given point."},{"name":"colInOut","summary":"The color to blend the decal color to."},{"name":"uvOut","summary":"the UV on the texture that the color point was read from."}],"returns":"True if the given point hits the decal, else false."},{"signature":"void UVBounds(ref double minUOut, ref double minVOut, ref double maxUOut, ref double maxVOut)","summary":"The UV bounds of the decal. Only used when mapping is UV.","since":"5.10"}]},{"namespace":"Rhino.Render","name":"DecalCreateParams","dataType":"class","summary":"Used by RhinoObject.AddDecal() to create and add a decal","properties":[{"signature":"DecalMapping DecalMapping","since":"6.0","property":["get","set"]},{"signature":"DecalProjection DecalProjection","since":"6.0","property":["get","set"]},{"signature":"double EndLatitude","since":"6.0","property":["get","set"]},{"signature":"double EndLongitude","since":"6.0","property":["get","set"]},{"signature":"double Height","since":"6.0","property":["get","set"]},{"signature":"bool MapToInside","since":"6.0","property":["get","set"]},{"signature":"double MaxU","since":"6.0","property":["get","set"]},{"signature":"double MaxV","since":"6.0","property":["get","set"]},{"signature":"double MinU","since":"6.0","property":["get","set"]},{"signature":"double MinV","since":"6.0","property":["get","set"]},{"signature":"Point3d Origin","since":"6.0","property":["get","set"]},{"signature":"double Radius","since":"6.0","property":["get","set"]},{"signature":"double StartLatitude","since":"6.0","property":["get","set"]},{"signature":"double StartLongitude","since":"6.0","property":["get","set"]},{"signature":"Guid TextureInstanceId","since":"6.0","property":["get","set"]},{"signature":"double Transparency","since":"6.0","property":["get","set"]},{"signature":"Vector3d VectorAcross","since":"6.0","property":["get","set"]},{"signature":"Vector3d VectorUp","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Render","name":"DecalMapping","dataType":"enum","since":"5.10","values":[{"signature":"Planar = (int)UnsafeNativeMethods.RhRdkDecalMapping.Planar","summary":"Planar mapping. Uses projection, origin, up and across vectors (not unitized)."},{"signature":"Cylindrical = (int)UnsafeNativeMethods.RhRdkDecalMapping.Cylindrical","summary":"Cylindrical mapping. Uses origin, up, across, height, radius, latitude start and stop."},{"signature":"Spherical = (int)UnsafeNativeMethods.RhRdkDecalMapping.Spherical","summary":"Spherical mapping. Uses origin, up, across, radius, latitude/longitude start and stop."},{"signature":"UV = (int)UnsafeNativeMethods.RhRdkDecalMapping.UV","summary":"UV mapping."}]},{"namespace":"Rhino.Render","name":"DecalProjection","dataType":"enum","since":"5.10","values":[{"signature":"Forward = (int)UnsafeNativeMethods.RhRdkDecalProjection.Forward","summary":"Project forward"},{"signature":"Backward = (int)UnsafeNativeMethods.RhRdkDecalProjection.Backward","summary":"Project backward"},{"signature":"Both = (int)UnsafeNativeMethods.RhRdkDecalProjection.Both","summary":"Project forward and backward"}]},{"namespace":"Rhino.Render","name":"Decals","dataType":"class","summary":"Represents all the decals of an object.","interfaces":["IEnumerable<Decal>"],"methods":[{"signature":"uint Add(Decal decal)","summary":"Add a new Decal to the decals list, use Decal.Create to create a new decal instance to add.","since":"5.10"},{"signature":"void Clear()","since":"5.10"},{"signature":"IEnumerator<Decal> GetEnumerator()","since":"5.10"},{"signature":"bool Remove(Decal decal)","since":"5.10"}]},{"namespace":"Rhino.Render","name":"Dithering","dataType":"class","summary":"This is the interface to linear workflow settings.","baseclass":"Rhino.Render.DocumentOrFreeFloatingBase","constructors":[{"signature":"Dithering()","summary":"Create a utility object not associated with any document","since":"6.0"},{"signature":"Dithering(Dithering d)","summary":"Create a utility object not associated with any document from another object","since":"6.0"}],"properties":[{"signature":"Methods Method","since":"6.0","property":["get","set"]},{"signature":"bool On","since":"7.0","property":["get","set"]}],"methods":[{"signature":"void CopyFrom(FreeFloatingBase src)","since":"6.0"}]},{"namespace":"Rhino.Render","name":"Dithering.Methods","dataType":"enum","summary":"Dithering algorithm.","values":[{"signature":"None","summary":"No dithering"},{"signature":"FloydSteinberg","summary":"Floyd Steinberg algorithm"},{"signature":"SimpleNoise","summary":"Simple random noise"}]},{"namespace":"Rhino.Render","name":"DocumentOrFreeFloatingBase","dataType":"class","summary":"Base class for Rhino.Render objects that are owned by the document, or can be delivered separately from other functions.  In general, you cannot create these objects yourself.","baseclass":"Rhino.Render.FreeFloatingBase","methods":[{"signature":"void BeginChange(ChangeContexts cc)","summary":"Call this function before making any change to this object (calling a setter) otherwise undo will not work correctly.  Calls to BeginChange must be paired with a call to EndChange.","since":"6.0","parameters":[{"name":"cc","summary":"Change context"}]},{"signature":"bool EndChange()","summary":"See BeginChange","since":"6.0","returns":"True if the object has returned to no-changes mode."}]},{"namespace":"Rhino.Render","name":"DynamicIconUsage","dataType":"enum","since":"6.0","values":[{"signature":"TreeControl = 0","summary":"Dynamic icon appears in a tree control."},{"signature":"SubnodeControl = 1","summary":"Dynamic icon appears in a sub-node control (\\\\see CRhRdkSubNodeCtrl)"},{"signature":"ContentControl = 2","summary":"Dynamic icon appears in a content control  (\\\\see CRhRdkContentCtrl)"}]},{"namespace":"Rhino.Render.Fields","name":"BoolField","dataType":"class","summary":"bool field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"bool Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"ByteArrayField","dataType":"class","summary":"ByteArray field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"byte[] Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"Color4fField","dataType":"class","summary":"Color4f field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"Color SystemColorValue","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]},{"signature":"Color4f Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"DateTimeField","dataType":"class","summary":"DateTime field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"DateTime Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"DoubleField","dataType":"class","summary":"double field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"double Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"Field","dataType":"class","summary":"Generic data fields used to add publicly accessible properties to RenderContent.FieldDictionary.  These should be created by calling a FieldDictaionary.Add() method on a Render content object.  These are allocated after the RenderContent object\'s C++ object is created and added to the underlying C++ objects content dictionary, who ever allocates a field is responsible for deleting it so these objects clean up the C++ pointers when they are disposed of.","properties":[{"signature":"string Key","summary":"Field name value string passed to the constructor","since":"5.1","property":["get"]},{"signature":"string Name","summary":"Field name value string passed to the constructor.","since":"6.0","property":["get"]},{"signature":"object Tag","summary":"Gets or sets an object that contains data to associate with the field.","since":"5.1","property":["get","set"]},{"signature":"double TextureAmountMax","summary":"Set Max value for Texture amount","since":"7.0","property":["get","set"]},{"signature":"double TextureAmountMin","summary":"Set Min value for Texture amount","since":"7.0","property":["get","set"]}],"methods":[{"signature":"T GetValue()","summary":"Parametrized version of GetValue calling appropriate ValueAs* methods.","since":"6.12","returns":"Value of type T of the field"},{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"FieldDictionary","dataType":"class","summary":"Dictionary containing RenderContent data fields, add fields to this dictionary in your derived RenderContent classes constructor.  Get field values using the TryGet[data type]() methods and set them using the Set() method.","interfaces":["IEnumerable"],"methods":[{"signature":"BoolField Add(string key, bool value)","summary":"Add a new BoolField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"BoolField Add(string key, bool value, string prompt)","summary":"Add a new BoolField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"ByteArrayField Add(string key, byte[] value)","summary":"AddField a new ByteArrayField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"Color4fField Add(string key, Color value)","summary":"Add a new Color4fField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"Color4fField Add(string key, Color value, string prompt)","summary":"Add a new Color4fField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"Color4fField Add(string key, Color4f value)","summary":"Add a new Color4fField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"Color4fField Add(string key, Color4f value, string prompt)","summary":"Add a new Color4fField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"DateTimeField Add(string key, DateTime value)","summary":"Add a new DateTimeField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"DateTimeField Add(string key, DateTime value, string prompt)","summary":"Add a new DateTimeField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"DoubleField Add(string key, double value)","summary":"AddField a new DoubleField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"DoubleField Add(string key, double value, string prompt)","summary":"Add a new DoubleField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"FloatField Add(string key, float value)","summary":"Add a new FloatField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"FloatField Add(string key, float value, string prompt)","summary":"AddField a new FloatField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"GuidField Add(string key, Guid value)","summary":"Add a new GuidField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"GuidField Add(string key, Guid value, string prompt)","summary":"Add a new GuidField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"IntField Add(string key, int value)","summary":"Add a new IntField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"IntField Add(string key, int value, string prompt)","summary":"Add a new IntField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"Point2dField Add(string key, Point2d value)","summary":"Add a new Point2dField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"Point2dField Add(string key, Point2d value, string prompt)","summary":"Add a new Point2dField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"Point3dField Add(string key, Point3d value)","summary":"Add a new Point3dField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"Point3dField Add(string key, Point3d value, string prompt)","summary":"Add a new Point3dField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"Point4dField Add(string key, Point4d value)","summary":"Add a new Point4dField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"Point4dField Add(string key, Point4d value, string prompt)","summary":"Add a new Point4dField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"StringField Add(string key, string value)","summary":"Add a new StringField to the dictionary.  This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"StringField Add(string key, string value, string prompt)","summary":"Add a new StringField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"TransformField Add(string key, Transform value)","summary":"Add a new TransformField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"TransformField Add(string key, Transform value, string prompt)","summary":"Add a new TransformField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"Vector2dField Add(string key, Vector2d value)","summary":"Add a new Vector2dField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"Vector2dField Add(string key, Vector2d value, string prompt)","summary":"Add a new Vector2dField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"Vector3dField Add(string key, Vector3d value)","summary":"Add a new Vector3dField to the dictionary. This will be a data only field and not show up in the content browsers.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."}]},{"signature":"Vector3dField Add(string key, Vector3d value, string prompt)","summary":"Add a new Vector3dField to the dictionary.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"BoolField AddTextured(string key, bool value, string prompt)","summary":"Add a new BoolField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"5.7","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"BoolField AddTextured(string key, bool value, string prompt, bool treatAsLinear)","summary":"Add a new BoolField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"Color4fField AddTextured(string key, Color value, string prompt)","summary":"Add a new Color4fField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"5.7","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"Color4fField AddTextured(string key, Color value, string prompt, bool treatAsLinear)","summary":"Add a new Color4fField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"Color4fField AddTextured(string key, Color4f value, string prompt)","since":"5.7","deprecated":"7.0"},{"signature":"Color4fField AddTextured(string key, Color4f value, string prompt, bool treatAsLinear)","summary":"Add a new Color4fField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"DateTimeField AddTextured(string key, DateTime value, string prompt)","summary":"Add a new DateTimeField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"5.7","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"DateTimeField AddTextured(string key, DateTime value, string prompt, bool treatAsLinear)","summary":"Add a new DateTimeField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"DoubleField AddTextured(string key, double value, string prompt)","summary":"Add a new DoubleField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"5.7","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"DoubleField AddTextured(string key, double value, string prompt, bool treatAsLinear)","summary":"Add a new DoubleField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"FloatField AddTextured(string key, float value, string prompt)","summary":"Add a new FloatField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"5.7","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"FloatField AddTextured(string key, float value, string prompt, bool treatAsLinear)","summary":"Add a new FloatField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"GuidField AddTextured(string key, Guid value, string prompt)","summary":"Add a new GuidField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"5.7","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"GuidField AddTextured(string key, Guid value, string prompt, bool treatAsLinear)","summary":"Add a new GuidField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"IntField AddTextured(string key, int value, string prompt)","summary":"Add a new IntField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"5.7","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"IntField AddTextured(string key, int value, string prompt, bool treatAsLinear)","summary":"Add a new IntField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"Point2dField AddTextured(string key, Point2d value, string prompt)","summary":"Add a new Point2dField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"5.7","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"Point2dField AddTextured(string key, Point2d value, string prompt, bool treatAsLinear)","summary":"Add a new Point2dField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"Point3dField AddTextured(string key, Point3d value, string prompt)","summary":"Add a new Point3dField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"5.7","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"Point3dField AddTextured(string key, Point3d value, string prompt, bool treatAsLinear)","summary":"Add a new Point3dField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"Point4dField AddTextured(string key, Point4d value, string prompt)","summary":"Add a new Point4dField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"5.7","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"Point4dField AddTextured(string key, Point4d value, string prompt, bool treatAsLinear)","summary":"Add a new Point4dField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"StringField AddTextured(string key, string value, string prompt)","summary":"Add a new StringField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"5.7","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"StringField AddTextured(string key, string value, string prompt, bool treatAsLinear)","summary":"Add a new StringField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"TransformField AddTextured(string key, Transform value, string prompt)","summary":"Add a new TransformField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"5.7","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"TransformField AddTextured(string key, Transform value, string prompt, bool treatAsLinear)","summary":"Add a new TransformField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"Vector2dField AddTextured(string key, Vector2d value, string prompt)","summary":"Add a new Vector2dField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"5.7","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"Vector2dField AddTextured(string key, Vector2d value, string prompt, bool treatAsLinear)","summary":"Add a new Vector2dField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"Vector3dField AddTextured(string key, Vector3d value, string prompt)","summary":"Add a new Vector3dField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"5.7","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."}]},{"signature":"Vector3dField AddTextured(string key, Vector3d value, string prompt, bool treatAsLinear)","summary":"Add a new Vector3dField to the dictionary. This overload will cause the field to be tagged as \\"textured\\" so that the texturing UI will appear in automatic UIs.","since":"7.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"Initial value for this field."},{"name":"prompt","summary":"Prompt to display in the user interface (Content Browsers) if this is None or an empty string the this field is a data only field and will not appear in the user interface."},{"name":"treatAsLinear","summary":"Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed)."}]},{"signature":"bool ContainsField(string fieldName)","summary":"Call this method to determine if a this FieldsList contains a field with the specified field name.","since":"5.1","parameters":[{"name":"fieldName","summary":"Field to search for"}],"returns":"Returns True if a field with that matches fieldName is found or false if it is not found."},{"signature":"IEnumerator<Field> GetEnumerator()","since":"6.0"},{"signature":"Field GetField(string fieldName)","summary":"Call this method to get the field with the matching name.","since":"5.3","parameters":[{"name":"fieldName","summary":"Field name to search for."}],"returns":"If the field exists in the Fields dictionary then the field is returned otherwise; None is returned."},{"signature":"void RemoveField(string fieldName)","since":"6.0"},{"signature":"void Set(string key, bool value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, bool value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, byte[] value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, byte[] value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, Color value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, Color value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, Color4f value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, Color4f value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, DateTime value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, DateTime value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, double value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, double value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, float value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, float value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, Guid value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, Guid value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, int value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, int value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, Point2d value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, Point2d value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, Point3d value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, Point3d value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, Point4d value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, Point4d value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, string value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, string value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, Transform value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, Transform value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, Vector2d value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, Vector2d value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"void Set(string key, Vector3d value)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."}]},{"signature":"void Set(string key, Vector3d value, ChangeContexts changeContext)","summary":"Set the field value and send the appropriate change notification to the render SDK.  Will throw a InvalidOperationException exception if the key name is not valid.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field value to change."},{"name":"value","summary":"New value for this field."},{"name":"changeContext","summary":"The reason why the value is changing."}]},{"signature":"bool SetTag(string key, object tag)","summary":"Sets an object that contains data to associate with the field.  THIS IS NOW OBSOLETE - if you were using this, please email andy@mcneel.com and let me know why.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name for the field to tag."},{"name":"tag","summary":"Data to associate with the field."}],"returns":"True if the field is found and the tag was set otherwise False is returned."},{"signature":"bool TryGetTag(string key, out object tag)","summary":"Gets object that contains data associate with a field. THIS IS NOW OBSOLETE - if you were using this, please email andy@mcneel.com and let me know why.","since":"5.1","deprecated":"6.0","parameters":[{"name":"key","summary":"Key name of the field to get."},{"name":"tag","summary":"Data associated with the field."}],"returns":"Returns True if the field is found and its tag was retrieved otherwise; returns false."},{"signature":"bool TryGetValue(string key, out bool value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out byte[] value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out Color value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out Color4f value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out DateTime value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out double value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out float value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out Guid value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out int value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out Point2d value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out Point3d value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out Point4d value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out string value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out T value)","summary":"Parametrized version of TryGetValue.","since":"6.12","parameters":[{"name":"key","summary":"Name of field to find."},{"name":"value","summary":"out parameter to be set."}],"returns":"True if field was found. If False out parameter value will be set to default(T)."},{"signature":"bool TryGetValue(string key, out Transform value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out Vector2d value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."},{"signature":"bool TryGetValue(string key, out Vector3d value)","summary":"Find a field with the specified key and get its value if found.","since":"5.1","parameters":[{"name":"key","summary":"Key name of the field to get a value for."},{"name":"value","summary":"Output parameter which will receive the field value."}],"returns":"Returns True if the key is found and the value parameter is set to the field value.  Returns False if the field was not found."}]},{"namespace":"Rhino.Render.Fields","name":"FloatField","dataType":"class","summary":"float field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"float Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"GuidField","dataType":"class","summary":"Guid field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"Guid Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"IntField","dataType":"class","summary":"Integer field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"int Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"Point2dField","dataType":"class","summary":"Point2d field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"Point2d Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"Point3dField","dataType":"class","summary":"Point3d field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"Point3d Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"Point4dField","dataType":"class","summary":"Point4d field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"Point4d Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"StringField","dataType":"class","summary":"String field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"string Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"TransformField","dataType":"class","summary":"Transform field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"Transform Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"Vector2dField","dataType":"class","summary":"Vector2d field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"Vector2d Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render.Fields","name":"Vector3dField","dataType":"class","summary":"Vector3d field value class","baseclass":"Rhino.Render.Fields.Field","properties":[{"signature":"Vector3d Value","summary":"Gets or sets the field value","since":"5.1","property":["get","set"]}],"methods":[{"signature":"object ValueAsObject()","since":"5.7"}]},{"namespace":"Rhino.Render","name":"FilterContentByUsage","dataType":"enum","summary":"Content collection filter value","since":"6.9","values":[{"signature":"None","summary":"No filter in use"},{"signature":"Used","summary":"Display only used contents"},{"signature":"Unused","summary":"Display only unused contents"}]},{"namespace":"Rhino.Render","name":"FreeFloatingBase","dataType":"class","summary":"Base class for Rhino.Render objects that are owned by the document, or can be delivered separately from other functions.  In general, you cannot create these objects yourself.","methods":[{"signature":"void CopyFrom(FreeFloatingBase src)","summary":"Copy from another object","since":"6.0"}]},{"namespace":"Rhino.Render","name":"GroundPlane","dataType":"class","summary":"Represents an infinite plane for implementation by renderers. See Rhino.PlugIns.RenderPlugIn.SupportsFeature.","baseclass":"Rhino.Render.DocumentOrFreeFloatingBase","constructors":[{"signature":"GroundPlane()","summary":"Create an utility object not associated with any document","since":"6.0"},{"signature":"GroundPlane(GroundPlane g)","summary":"Create an utility object not associated with any document from another object","since":"6.0"}],"properties":[{"signature":"double Altitude","summary":"Height above world XY plane in model units.","since":"5.0","property":["get","set"]},{"signature":"bool AutoAltitude","summary":"Determines whether the ground plane is fixed by the Altitude property, or whether it is automatically placed at the lowest point in the model.","since":"6.0","property":["get","set"]},{"signature":"bool Enabled","summary":"Determines whether the document ground plane is enabled.","since":"5.0","property":["get","set"]},{"signature":"Guid MaterialInstanceId","summary":"Id of material in material table for this ground plane.","since":"5.0","property":["get","set"]},{"signature":"bool ShadowOnly","summary":"Determines whether the ground plane shows the material assigned, or whether it is transparent, but captures shadows.","since":"6.0","property":["get","set"]},{"signature":"bool ShowUnderside","summary":"If this is off, the ground plane will not be visible when seen from below.","since":"6.0","property":["get","set"]},{"signature":"Vector2d TextureOffset","summary":"Texture mapping offset in world units.","since":"5.0","property":["get","set"]},{"signature":"bool TextureOffsetLocked","summary":"Texture offset locked.","since":"6.0","property":["get","set"]},{"signature":"double TextureRotation","summary":"Texture mapping rotation around world origin + offset in degrees.","since":"5.0","property":["get","set"]},{"signature":"Vector2d TextureSize","summary":"Texture mapping single UV span size in world units.","since":"5.0","property":["get","set"]},{"signature":"bool TextureSizeLocked","summary":"Texture size locked.","since":"6.0","property":["get","set"]}],"methods":[{"signature":"void CopyFrom(FreeFloatingBase src)","since":"6.0"}],"events":[{"signature":"static Changed","summary":"This event is raised when a GroundPlane property value is changed.","since":"5.10"}]},{"namespace":"Rhino.Render","name":"ICurrentEnvironment","dataType":"interface","properties":[{"signature":"RenderEnvironment ForAnyUsage","since":"6.0","property":["set"]},{"signature":"RenderEnvironment ForBackground","since":"6.0","property":["get","set"]},{"signature":"RenderEnvironment ForBackground_CheckMode","since":"6.0","property":["get","set"]},{"signature":"RenderEnvironment ForLighting","since":"6.0","property":["get","set"]},{"signature":"RenderEnvironment ForReflectionAndRefraction","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Render","name":"ICurrentEnvironment_Get","dataType":"interface","properties":[{"signature":"RenderEnvironment ForBackground","since":"6.0","property":["get"]},{"signature":"RenderEnvironment ForBackground_CheckMode","since":"6.0","property":["get"]},{"signature":"RenderEnvironment ForLighting","since":"6.0","property":["get"]},{"signature":"RenderEnvironment ForReflectionAndRefraction","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Render","name":"ImageFile","dataType":"class","summary":"Controls interaction with RDK render image files","events":[{"signature":"static Deleted","summary":"Called when the RDK is cleaning up old render image files, a plug-in should delete any plug-in specific image files at this time.","since":"5.11"},{"signature":"static Loaded","summary":"Generally called when the \\"RenderOpenLastRender\\" command is run, this event is raised after the render window has been created and the saved scene has been loaded.","since":"5.11"},{"signature":"static Saved","summary":"Render image file saved, happens when a rendering completes. If a plug-in needs to save additional file information it should write it to the same folder as the Rhino render image file.  Rhino will take care of deleting old data.","since":"5.11"}]},{"namespace":"Rhino.Render","name":"ImageFileEvent","dataType":"enum","since":"5.11","values":[{"signature":"Saved","summary":"Render image file has been successfully written"},{"signature":"Loaded","summary":"Render image file has been successfully loaded"},{"signature":"Deleted","summary":"Render image file was just deleted"}]},{"namespace":"Rhino.Render","name":"ImageFileEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"int EllapsedTime","since":"5.11","property":["get","set"]},{"signature":"ImageFileEvent Event","since":"5.11","property":["get","set"]},{"signature":"string FileName","since":"5.11","property":["get","set"]},{"signature":"string RenderEngine","since":"5.11","property":["get","set"]},{"signature":"Guid RenderEngineId","since":"5.11","property":["get","set"]},{"signature":"Guid SessionId","since":"5.11","property":["get","set"]}]},{"namespace":"Rhino.Render","name":"IRhRdkPreviewSceneServer_eRotationType","dataType":"enum","summary":"c# version of IRhRdkPreviewSceneServer eRotationType enum","since":"6.0","values":[{"signature":"Camera","summary":"Camera"},{"signature":"Object","summary":"Object"}]},{"namespace":"Rhino.Render","name":"it_strategy","dataType":"enum","summary":"Defines the collection type to iterate.","since":"6.0","values":[{"signature":"ContentDataBase"},{"signature":"ContentSelection"}]},{"namespace":"Rhino.Render","name":"LightArray","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"LightArray()","since":"6.0"},{"signature":"LightArray(IntPtr pLightArray)","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.0","property":["get"]}],"methods":[{"signature":"void Append(Light light)","since":"6.0"},{"signature":"int Count()","since":"6.0"},{"signature":"void Dispose()","since":"6.0"},{"signature":"Rhino.Geometry.Light ElementAt(int index)","since":"6.0"}]},{"namespace":"Rhino.Render","name":"LightManagerSupport","dataType":"class","summary":"Base class for implementing custom light managers in .NET","methods":[{"signature":"static void RegisterLightManager(PlugIn plugin)","summary":"Find and register classes that derive from LightManagerSupport from the given plug-in.","since":"6.0"},{"signature":"static void RegisterProviders(Assembly assembly, Guid pluginId)","summary":"Find and register classes that derive from RealtimeDisplayMode from the given plug-in. The plug-in is found in the given assembly","since":"6.0"},{"signature":"bool DeleteLight(RhinoDoc doc, Light light, bool bUndelete)","summary":"Delete light","since":"6.0","returns":"If delete is successful, then return true, else return false"},{"signature":"void GetLights(RhinoDoc doc, ref LightArray light_array)","summary":"Get all the lights that are associated to the light manager. The lights are added to the LightArray parameter passed to the GetLights method","since":"6.0"},{"signature":"bool GetLightSolo(RhinoDoc doc, Guid uuid_light)","summary":"Returns the value of \\"ON_LIght::m_bOn\\" if the light is in solo storage, or False if not in solo storage (ie - this is the checkbox state on the light manager dialog)","since":"6.0","returns":"Returns True if the light is in solo storage, or False if not in solo storage"},{"signature":"void GroupLights(RhinoDoc doc, ref LightArray light_array)","summary":"Creates a new group with the lights","since":"6.0"},{"signature":"string LightDescription(RhinoDoc doc, ref Light light)","summary":"Gets the string representation of the light description","since":"6.0","returns":"Returns the string representation of the light description"},{"signature":"bool LightFromId(RhinoDoc doc, Guid uuid, ref Light light)","summary":"Get Rhino.Geometry.Light object associated to Guig uuid","since":"6.0"},{"signature":"int LightsInSoloStorage(RhinoDoc doc)","summary":"Returns the number of lights in solo storage - any number other than 0 means \\"in solo mode\\"","since":"6.0","returns":"Returns the number of lights in solo storage - any number other than 0 means \\"in solo mode\\""},{"signature":"void ModifyLight(RhinoDoc doc, Light light)","summary":"Modify properties of the light","since":"6.0"},{"signature":"int ObjectSerialNumberFromLight(RhinoDoc doc, ref Light light)","summary":"Get the object serial number of the light","since":"6.0"},{"signature":"void OnCustomLightEvent(RhinoDoc doc, LightMangerSupportCustomEvent le, ref Light light)","summary":"Generates LightMangerSupportCustomEvent: light_added, light_deleted, light_undeleted, light_modified, light_sorted, The event triggers a Light table event that the rdk lightmanager listens too","since":"6.0","returns":"Returns the string representation of the light description"},{"signature":"bool OnEditLight(RhinoDoc doc, ref LightArray light_array)","summary":"The default implementation of OnEditLight selects the lights and opens the Lights Properties page","since":"6.0","returns":"Returns True if successful, else false"},{"signature":"Guid PluginId()","summary":"The Guid of the plugin","since":"6.0","returns":"Returns the Guid of the plugin"},{"signature":"Guid RenderEngineId()","summary":"The Guid of the render engine","since":"6.0","returns":"Returns the Guid of the render engine that is associated with this light manager"},{"signature":"bool SetLightSolo(RhinoDoc doc, Guid uuid_light, bool bSolo)","summary":"First checks to see if we are in \\"solo mode\\" - which means that there are any lights that respond \\"true\\" to IsInSoloStorage. If in solo mode: If bSolo = true Sets this light on. If bSolo = false If this is the last light \\"on\\", forces all lights out of solo mode. If there are other lights on, turns this light off. If not in solo mode: If bSolo = true Forces all lights into solo storage and sets this light on. If bSolo = false This shouldn\'t happen.  Will cause an ASSERT","since":"6.0","returns":"Returns True if action is successful"},{"signature":"void UnGroup(RhinoDoc doc, ref LightArray light_array)","summary":"UnGroups the lights","since":"6.0"}]},{"namespace":"Rhino.Render","name":"LightManagerSupportClient","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"LightManagerSupportClient(uint doc_uuid)","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.0","property":["get"]}],"methods":[{"signature":"void DeleteLight(Light light)","since":"6.0"},{"signature":"void Dispose()","since":"6.0"},{"signature":"Rhino.Geometry.Light GetLightFromId(Guid uuid)","since":"6.0"},{"signature":"LightArray GetLights()","since":"6.0"},{"signature":"bool GetLightSolo(Light light)","since":"6.0"},{"signature":"void GroupLights(LightArray lights)","since":"6.0"},{"signature":"string LightDescription(Light light)","since":"6.0"},{"signature":"int LightsInSoloStorage()","since":"6.0"},{"signature":"void ModifyLight(Light light)","since":"6.0"},{"signature":"Rhino.DocObjects.RhinoObject ObjectFromLight(Light light)","since":"6.0"},{"signature":"void OnEditLight(LightArray lights)","since":"6.0"},{"signature":"bool SetLightSolo(Light light, bool bSolo)","since":"6.0"},{"signature":"void UnGroup(LightArray lights)","since":"6.0"}]},{"namespace":"Rhino.Render","name":"LightMangerSupportCustomEvent","dataType":"enum","summary":"LightMangerSupportCustomEvent","since":"6.0","values":[{"signature":"light_added"},{"signature":"light_deleted"},{"signature":"light_undeleted"},{"signature":"light_modified"},{"signature":"light_sorted"}]},{"namespace":"Rhino.Render","name":"LinearWorkflow","dataType":"class","summary":"This is the interface to linear workflow settings.","baseclass":"Rhino.Render.DocumentOrFreeFloatingBase","constructors":[{"signature":"LinearWorkflow()","summary":"Create a utility object not associated with any document","since":"6.0"},{"signature":"LinearWorkflow(LinearWorkflow src)","summary":"Create a utility object not associated with any document from another object","since":"6.0"}],"properties":[{"signature":"uint Hash","summary":"Linear workflow CRC","since":"6.0","property":["get"]},{"signature":"bool PostProcessFrameBuffer","summary":"Linear workflow active state","since":"6.0","property":["get","set"]},{"signature":"float PostProcessGamma","summary":"Linear workflow gamma","since":"6.0","property":["get","set"]},{"signature":"bool PostProcessGammaOn","summary":"Linear workflow gamma","since":"6.0","property":["get","set"]},{"signature":"float PostProcessGammaReciprocal","summary":"Linear workflow gamma","since":"6.0","property":["get"]},{"signature":"bool PreProcessColors","summary":"Linear workflow active state","since":"6.0","property":["get","set"]},{"signature":"float PreProcessGamma","summary":"Linear workflow gamma","since":"6.0","property":["get","set"]},{"signature":"bool PreProcessTextures","summary":"Linear workflow active state","since":"6.0","property":["get","set"]}],"methods":[{"signature":"void CopyFrom(FreeFloatingBase src)","summary":"Create a copy of linearworkflow","since":"6.0"},{"signature":"bool Equals(object obj)","summary":"Compare two LinearWorkflow objects. They are considered equal when their Hashes match."},{"signature":"int GetHashCode()","summary":"Get hash code for this object. It is the Hash property cast to int."}]},{"namespace":"Rhino.Render","name":"MappingTag","dataType":"class","summary":"Holds texture mapping information.","properties":[{"signature":"Guid Id","summary":"Gets or sets a map globally unique identifier.","since":"5.0","property":["get","set"]},{"signature":"uint MappingCRC","summary":"Gets or sets the cyclic redundancy check on the mapping. See also RhinoMath.CRC32(uint,byte[]).","since":"5.0","property":["get","set"]},{"signature":"TextureMappingType MappingType","summary":"Gets or sets a texture mapping type: linear, cylinder, etc...","since":"5.0","property":["get","set"]},{"signature":"Transform MeshTransform","summary":"Gets or sets a 4x4 matrix transform.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.Render","name":"MetaDataProxy","dataType":"class","summary":"ProxyClass for MetaData","interfaces":["IDisposable"],"constructors":[{"signature":"MetaDataProxy()","summary":"Constructor for MetaDataProxy","since":"6.8"}],"properties":[{"signature":"IntPtr CppPointer","summary":"MetaDataProxy c++ pointer","since":"6.8","property":["get"]}],"methods":[{"signature":"void Dispose()","summary":"Dispose for MetaDataProxy","since":"6.8"},{"signature":"void SetContentInstanceId(Guid uuid)","summary":"Set Content instance id for meta data","since":"6.8"}]},{"namespace":"Rhino.Render","name":"NamedValue","dataType":"class","constructors":[{"signature":"NamedValue(string name, object value)","since":"5.1"}],"properties":[{"signature":"string Name","since":"5.1","property":["get","set"]},{"signature":"object Value","since":"5.1","property":["get","set"]}]},{"namespace":"Rhino.Render.ParameterNames","name":"PhysicallyBased","dataType":"class","summary":"Helper class with properties containing the names of fields available in our PBR implementation.","properties":[{"signature":"static string AmbientOcclusion","since":"7.0","property":["get"]},{"signature":"static string Anisotropic","since":"7.0","property":["get"]},{"signature":"static string AnisotropicRotation","since":"7.0","property":["get"]},{"signature":"static string BaseColor","since":"7.0","property":["get"]},{"signature":"static string BRDF","since":"7.0","property":["get"]},{"signature":"static string Bump","since":"7.0","property":["get"]},{"signature":"static string Clearcoat","since":"7.0","property":["get"]},{"signature":"static string ClearcoatBump","since":"7.0","property":["get"]},{"signature":"static string ClearcoatRoughness","since":"7.0","property":["get"]},{"signature":"static string Displacement","since":"7.0","property":["get"]},{"signature":"static string Emission","since":"7.0","property":["get"]},{"signature":"static string Metallic","since":"7.0","property":["get"]},{"signature":"static string Opacity","since":"7.0","property":["get"]},{"signature":"static string OpacityIor","since":"7.0","property":["get"]},{"signature":"static string OpacityRoughness","since":"7.0","property":["get"]},{"signature":"static string Roughness","since":"7.0","property":["get"]},{"signature":"static string Sheen","since":"7.0","property":["get"]},{"signature":"static string SheenTint","since":"7.0","property":["get"]},{"signature":"static string Specular","since":"7.0","property":["get"]},{"signature":"static string SpecularTint","since":"7.0","property":["get"]},{"signature":"static string Subsurface","since":"7.0","property":["get"]},{"signature":"static string SubsurfaceScatteringColor","since":"7.0","property":["get"]},{"signature":"static string SubsurfaceScatteringRadius","since":"7.0","property":["get"]}]},{"namespace":"Rhino.Render","name":"PhysicallyBasedMaterial","dataType":"class"},{"namespace":"Rhino.Render","name":"PhysicallyBasedMaterial.ParametersNames","dataType":"class","summary":"Helper class with fields containing the names of fields available in our PBR implementation.","properties":[{"signature":"static string AmbientOcclusion","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string Anisotropic","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string AnisotropicRotation","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string BaseColor","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string BRDF","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string Bump","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string Clearcoat","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string ClearcoatBump","since":"6.16","deprecated":"7.0","property":["get"]},{"signature":"static string ClearcoatRoughness","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string Displacement","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string Emission","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string Metallic","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string Normal","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string Opacity","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string OpacityIor","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string OpacityRoughness","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string Roughness","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string Sheen","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string SheenTint","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string Smudge","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string Specular","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string SpecularTint","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string Subsurface","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string SubsurfaceScatteringColor","since":"6.12","deprecated":"7.0","property":["get"]},{"signature":"static string SubsurfaceScatteringRadius","since":"6.12","deprecated":"7.0","property":["get"]}]},{"namespace":"Rhino.Render","name":"PixelBuffer","dataType":"class","constructors":[{"signature":"PixelBuffer(IntPtr bufferPointer)","summary":"Create a new PixelBuffer pointing to the (unmanaged) pixel data buffer behind IntPtr","since":"6.0","parameters":[{"name":"bufferPointer","summary":"IntPtr to the unmanaged pixel data buffer"}]}],"properties":[{"signature":"IntPtr Buffer","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Render.PostEffects","name":"CustomPostEffectAttribute","dataType":"class","baseclass":"Attribute","constructors":[{"signature":"CustomPostEffectAttribute(PostEffectType postEffectType, string name, PostEffectStyles styles, PostEffectExecuteWhileRenderingOptions executeWhileRenderingOption, bool canDisplayHelp, int executeWhileRenderingDelay)","since":"7.0"}],"properties":[{"signature":"bool CanDisplayHelp","since":"7.0","property":["get","set"]},{"signature":"int ExecuteWhileRenderingDelay","since":"7.0","property":["get","set"]},{"signature":"PostEffectExecuteWhileRenderingOptions ExecuteWhileRenderingOption","since":"7.0","property":["get","set"]},{"signature":"string Name","since":"7.0","property":["get","set"]},{"signature":"PostEffectType PostEffectType","since":"7.0","property":["get","set"]},{"signature":"PostEffectStyles Styles","since":"7.0","property":["get","set"]}]},{"namespace":"Rhino.Render.PostEffects","name":"IPostEffects","dataType":"interface","methods":[{"signature":"PostEffect[] GetPostEffects(PostEffectType type)","since":"7.0"},{"signature":"PostEffect PostEffectFromId(Guid uuid)","since":"7.0"}]},{"namespace":"Rhino.Render.PostEffects","name":"PostEffect","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"PostEffect()","since":"7.0"}],"properties":[{"signature":"bool CanDisplayHelp","since":"7.0","property":["get"]},{"signature":"PostEffectExecuteWhileRenderingOptions ExecuteWhileRenderingOption","since":"7.0","property":["get"]},{"signature":"Guid Id","since":"7.0","property":["get"]},{"signature":"bool IsSelected","summary":"Return True if the post effect is selected.","since":"7.0","property":["get"]},{"signature":"string LocalName","since":"7.0","property":["get"]},{"signature":"bool On","since":"7.0","property":["get","set"]},{"signature":"PostEffectType PostEffectType","since":"7.0","property":["get"]},{"signature":"Guid[] RequiredChannels","summary":"The RDK calls this method to determine which channels a post effect requires. If a required channel is not available, the RDK will hide the post effect\'s UI and display explanatory text instead. Note: As a convenience, the default implementation adds IRhRdkRenderWindow::chanRGBA to the output array. Most post effects should be able to use this default with no need to override the method.","since":"7.0","property":["get"]},{"signature":"int SerialNumber","since":"7.0","property":["get","set"]},{"signature":"bool Shown","since":"7.0","property":["get","set"]},{"signature":"PostEffectStyles Styles","since":"7.0","property":["get"]}],"methods":[{"signature":"static Type[] RegisterPostEffect(Assembly assembly, Guid pluginId)","since":"7.0"},{"signature":"static Type[] RegisterPostEffect(PlugIn plugin)","since":"7.0"},{"signature":"void AddUISections(PostEffectUI ui)","summary":"Create each of your UI sections using \'new\' and then call ui.AddSection() on them. RDK takes ownership of the sections.If your post effect does not need a UI, then your implementation of this method can be a no-op.","since":"7.0","parameters":[{"name":"ui","summary":"PostEffectUI"}]},{"signature":"void BeginChange(ChangeContexts changeContext)","since":"7.0"},{"signature":"bool CanExecute(PostEffectPipeline pipeline)","summary":"Return True if the post effect can execute, else false. The base implementation checks if the post effect is \'On\' and \'Shown\'. Post effect authors can override this to include other criteria but cannot disable the base criteria.","since":"7.0","parameters":[{"name":"pipeline","summary":"PostEffectPipeline"}],"returns":"Return True if the post effect can execute, else false"},{"signature":"void Changed()","since":"7.0"},{"signature":"bool DisplayHelp()","summary":"Displays the post effect\'s help page, if any.","since":"7.0","returns":"Return True if successful, else false."},{"signature":"void Dispose()","since":"7.0"},{"signature":"void Dispose(bool bDisposing)","since":"7.0"},{"signature":"bool EndChange()","since":"7.0"},{"signature":"bool Execute(PostEffectPipeline pipeline, Rectangle rect)","summary":"Execute the post effect.","since":"7.0","parameters":[{"name":"pipeline","summary":"pipeline provides access to the post-effect pipeline."},{"name":"rect","summary":"rect is the pixel area to process."}],"returns":"Return True if successful, else false."},{"signature":"int GetHashCode()","summary":"A CRC of the state of this post effect.","since":"7.0","returns":"returns a crc of post effect state"},{"signature":"bool GetParam(string param, ref object v)","summary":"Get a parameter.","since":"7.0","parameters":[{"name":"param","summary":"is the name of the parameter to get."},{"name":"v","summary":"accepts the parameter value."}],"returns":"Returns True if successful or False if the parameter was not found."},{"signature":"bool ReadFromDocumentDefaults(RhinoDoc doc)","summary":"Read the state from document defaults. This is implemented by RDK to call ReadState() so usually a post effect only has to implement ReadState(). However, a post effect can override this method to take complete control of how the document defaults are read.","since":"7.0","parameters":[{"name":"doc","summary":"Rhino document"}],"returns":"Return True if read was succesfull"},{"signature":"bool ReadState(PostEffectState state)","summary":"Read the state. If your post effect has no state, you must still return True for success.","since":"7.0","parameters":[{"name":"state","summary":"PostEffectState"}],"returns":"Return True if successful, else false."},{"signature":"void ResetToFactoryDefaults()","summary":"Reset the state to factory defaults.","since":"7.0"},{"signature":"bool SetParam(string param, object v)","summary":"Set a parameter.","since":"7.0","parameters":[{"name":"param","summary":"is the name of the parameter to set."},{"name":"v","summary":"specifies the type and value to set."}],"returns":"Return True if successful or False if the parameter could not be set."},{"signature":"bool WriteState(ref PostEffectState state)","summary":"Write the state. If your post effect has no state, you must still return True for success.","since":"7.0","parameters":[{"name":"state","summary":"PostEffectState"}],"returns":"Return True if successful, else false."},{"signature":"bool WriteToDocumentDefaults(RhinoDoc doc)","summary":"Write the state to document defaults. This is implemented by RDK to call WriteState() so usually a post effect only has to implement WriteState(). However, a post effect can override this method to take complete control of how the document defaults are written.","since":"7.0","parameters":[{"name":"doc","summary":"Rhino document"}],"returns":"Return True if write was succesful"}]},{"namespace":"Rhino.Render.PostEffects","name":"PostEffectChannel","dataType":"class","interfaces":["IDisposable"],"properties":[{"signature":"Guid Id","summary":"Return the channel id which indicates what type of data is used in this channel.","since":"7.0","property":["get"]},{"signature":"int PixelSize","summary":"Return the pixel size in bytes for this channel.","since":"7.0","property":["get"]}],"methods":[{"signature":"PostEffectChannel Clone()","summary":"Return a clone of this channel.","since":"7.0"},{"signature":"void Commit()","summary":"Commit changes to the channel so that those changes can be used by subsequent post effects in the chain. Only valid for channels that were obtained by calling GetChannelForWrite(). If the channel has the same id as an existing channel, the existing channel will be replaced by the new one. If the existing channel was created by a previous post effect in the chain, it will be deleted. Changes to channels that are not commited simply get ignored. Note: This call merely sets a flag. The process is deferred until after the post effect has finished executing.","since":"7.0"},{"signature":"RenderWindow.Channel CPU()","summary":"Return an interface to this channel for doing channel operations on the CPU.","since":"7.0"},{"signature":"void Dispose()","since":"7.0"},{"signature":"RenderWindow.ChannelGPU GPU()","summary":"Return an interface to this channel for doing channel operations on the GPU.","since":"7.0"}]},{"namespace":"Rhino.Render.PostEffects","name":"PostEffectExecuteContexts","dataType":"enum","since":"7.0","values":[{"signature":"ProductionRendering = 0"},{"signature":"RealtimeRendering = 1"},{"signature":"ViewportDisplay = 2"},{"signature":"ThumbnailCreation = 3"},{"signature":"ConvertingToHDR = 4"}]},{"namespace":"Rhino.Render.PostEffects","name":"PostEffectExecuteWhileRenderingOptions","dataType":"enum","since":"7.0","values":[{"signature":"None = 0"},{"signature":"Always = 1"},{"signature":"UseDelay = 2"}]},{"namespace":"Rhino.Render.PostEffects","name":"PostEffectHistograms","dataType":"enum","since":"7.0","values":[{"signature":"None = 0"},{"signature":"BeforeEarlyEffects = 1"},{"signature":"BeforeToneMapping = 2"},{"signature":"AfterToneMapping = 4"},{"signature":"AfterLateEffects = 8"},{"signature":"All = BeforeEarlyEffects | BeforeToneMapping | AfterToneMapping | AfterLateEffects"},{"signature":"ToneMappingDisplay = BeforeToneMapping | AfterToneMapping"},{"signature":"AfterEarlyEffects = BeforeToneMapping"},{"signature":"BeforeLateEffects = AfterToneMapping"}]},{"namespace":"Rhino.Render.PostEffects","name":"PostEffectJob","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"PostEffectJob()","since":"7.0"}],"methods":[{"signature":"PostEffectJob Clone()","since":"7.0"},{"signature":"void Dispose()","since":"7.0"},{"signature":"bool Execute(Rectangle rect, PostEffectJobChannels access)","since":"7.0"}]},{"namespace":"Rhino.Render.PostEffects","name":"PostEffectJobChannels","dataType":"class","interfaces":["IDisposable"],"methods":[{"signature":"void Dispose()","since":"7.0"},{"signature":"PostEffectChannel GetChannel(Guid channelId)","since":"7.0"}]},{"namespace":"Rhino.Render.PostEffects","name":"PostEffectPipeline","dataType":"class","summary":"This object provides a way for post effects to access the frame buffer channels from a rendering and create new channels containing post-processed information which can be passed to the next post effect in the chain. Consider a simple post effect that just modifies the red component of a rendering.It will call GetChannel() to get the red channel as its input, and it will call NewChannel() to get a new red channel for its output. It will then read the input channel, do calculations and write to the output channel.When finished, it will call Commit() passing the new channel.Because both channels have the same identifier, this will replace the old channel with the new one so that subsequent post effects in the chain will use the new channel instead of the original.Note that this will only replace the channel used by the pipeline.The original channel will still exist in the frame buffer.This system allows any post effect to access any number of channels for reading and create any number of new channels which may or may not replace existing channels depending on the channel id.The final stage (convert to 8-bit) operates on the channels left in the pipeline by the post effect chain to produce the final 32-bit RGBA image in a dib.  It is also possible for a post effect to create and use any number of \'scratch\' channels.If a post effect needs a temporary pixel buffer for some intermediate results, it can call NewChannel() with a custom (random) id. Once it is finished with this scratch channel, it can call Discard() on it.","interfaces":["IDisposable","IProgress<int>","Rhino.Render.PostEffects.IPostEffects"],"properties":[{"signature":"bool GPUAllowed","summary":"Post effect authors should check that GPU use is allowed before using the GPU in a post effect.","since":"7.0","property":["get"]},{"signature":"bool IsRendering","summary":"IsRendering","since":"7.0","property":["get"]},{"signature":"Guid RenderingId","summary":"Return a UUID that uniquely identifies the rendering being processed.","since":"7.0","property":["get"]}],"methods":[{"signature":"Size Dimensions()","summary":"Get the dimensions of the frame buffer. All channels in the frame buffer have the same dimensions.","since":"7.0","returns":"Dimension as Size"},{"signature":"void Dispose()","since":"7.0"},{"signature":"bool Execute(Rectangle p, bool renderingInProgress, PostEffectExecuteContexts usageContexts, PostEffectHistograms histogramsToUpdate)","summary":"Execute the pipeline. This executes all the post effects in order. Only this rectangle need be modified by the post effects.","since":"7.0","parameters":[{"name":"p","summary":"p is a rectangle within the frame buffer."},{"name":"renderingInProgress","summary":"rendering is True if rendering is in progress."},{"name":"usageContexts","summary":"Context this pipeline is being executed in"},{"name":"histogramsToUpdate","summary":"Bitwise list of histograms to update during the execution of the pipeline"}]},{"signature":"Guid[] ExecutionOrder()","summary":"Returns a list of the post effects to be executed by this pipeline in order.","since":"7.0","returns":"A list of the post effects to be executed by this pipeline in order"},{"signature":"PostEffectChannel GetChannelForRead(Guid id)","summary":"Get a channel for reading. A post effect will use this to get channel data as input to its process. Output will be written to new channel(s). \\\\see GetChannelForWrite() This method returns the current state of the channel at this stage in the pipeline. If the first post effect calls this, it will get the actual frame buffer channel. Subsequent post effects will get the data left behind by the previous post effect. A post effect calls GetChannelForRead() to get its input and GetChannelForWrite() to get the object to which it will write its output. Even when the same channel id is specified, these are separate, unconnected objects.","since":"7.0","parameters":[{"name":"id","summary":"The channel identifier."}],"returns":"A pointer to the channel or None if the channel is not available."},{"signature":"PostEffectChannel GetChannelForWrite(Guid id)","summary":"Get a channel for writing. A post effect will use this to get channel(s) to write the output of its processing to. Input will usually come from existing channels, although a post effect is free to read its own output channels if needed. See GetChannelForRead() You are allowed to create one new channel with the same identifier as an existing channel, in which case IChannel::Commit() will replace the existing channel with the new one in the pipeline.","since":"7.0","parameters":[{"name":"id","summary":"The channel identifier."}],"returns":"A pointer to the new channel or None if the channel could not be created."},{"signature":"ulong GetEndTimeInMilliseconds()","summary":"Get the end time of the rendering expressed in milliseconds since some unspecified epoch. Do not make assumptions about what the epoch is; it might be different on different platforms.","since":"7.0","returns":"milliseconds"},{"signature":"float GetMaxLuminance()","summary":"Get the max luminance in the rendering.","since":"7.0","returns":"max luminance"},{"signature":"ulong GetStartTimeInMilliseconds()","summary":"Get the start time of the rendering expressed in milliseconds since some unspecified epoch. Do not make assumptions about what the epoch is; it might be different on different platforms.","since":"7.0","returns":"milliseconds"},{"signature":"void SetStartTimeInMilliseconds(ulong ms)","summary":"Set the start time of the rendering in milliseconds since some unspecified epoch.","parameters":[{"name":"ms","summary":"milliseconds"}]},{"signature":"PostEffectThreadEngine ThreadEngine()","summary":"Get the post effect thread engine.","since":"7.0"}]},{"namespace":"Rhino.Render.PostEffects","name":"PostEffectState","dataType":"class","interfaces":["IDisposable"],"methods":[{"signature":"void Dispose()","since":"7.0"},{"signature":"bool SetValue(string name, T vValue)","since":"7.0"},{"signature":"bool TryGetValue(string name, out T vValue)","since":"7.0"}]},{"namespace":"Rhino.Render.PostEffects","name":"PostEffectStyles","dataType":"enum","since":"7.0","values":[{"signature":"ExecuteForProductionRendering = 0x0001"},{"signature":"ExecuteForRealtimeRendering = 0x0002"},{"signature":"ExecuteForViewportDisplay = 0x0004"},{"signature":"Fixed = 0x0100"},{"signature":"DefaultShown = 0x0200"},{"signature":"DefaultOn = 0x0400"}]},{"namespace":"Rhino.Render.PostEffects","name":"PostEffectThreadEngine","dataType":"class","interfaces":["IDisposable"],"methods":[{"signature":"void Dispose()","since":"7.0"},{"signature":"bool RunPostEffect(PostEffectJob job, PostEffectPipeline pipeline, PostEffect plugin, Rectangle rect, Guid[] channels)","since":"7.0"}]},{"namespace":"Rhino.Render.PostEffects","name":"PostEffectType","dataType":"enum","since":"7.0","values":[{"signature":"Early = 0"},{"signature":"ToneMapping = 1"},{"signature":"Late = 2"}]},{"namespace":"Rhino.Render.PostEffects","name":"PostEffectUI","dataType":"class","summary":"PostEffectUI class provides a way for pep plugins to add ui sections","interfaces":["IDisposable"],"methods":[{"signature":"void AddSection(ICollapsibleSection section)","summary":"Add a section to the UI.","since":"7.0"},{"signature":"void Dispose()","since":"7.0"}]},{"namespace":"Rhino.Render","name":"PreviewAppearance","dataType":"class","summary":"PreviewAppearance class","interfaces":["IDisposable"],"constructors":[{"signature":"PreviewAppearance(IntPtr pRenderContent)","summary":"Constructor for previewappearance","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","summary":"Previewappearances c++ pointer","since":"6.0","property":["get"]},{"signature":"MetaData MetaData","summary":"Previewappearance MetaData","since":"6.0","property":["get"]},{"signature":"double Scale","summary":"Size - used in the UI.  Always meters.","since":"7.0","property":["get","set"]},{"signature":"double SceneScale","summary":"Scene size - the actual size that is rendered","since":"7.0","property":["get"]}],"methods":[{"signature":"PreviewBackground Background()","summary":"Background","since":"6.0"},{"signature":"void Dispose()","summary":"Dispose for previewappearance","since":"6.0"},{"signature":"void FromMetaData(MetaData md)","summary":"Copy data from MetaData to PreviewAppearance","since":"6.0"},{"signature":"PreviewGeometry Geometry()","summary":"Geometry","since":"6.0"},{"signature":"PreviewLighting Lighting()","summary":"Lighting","since":"6.0"},{"signature":"IRhRdkPreviewSceneServer_eRotationType RotationType()","summary":"RotationType","since":"6.0"},{"signature":"double RotationX()","summary":"RotationX","since":"6.0"},{"signature":"double RotationY()","summary":"RotationY","since":"6.0"},{"signature":"void SetRotationType(IRhRdkPreviewSceneServer_eRotationType type)","summary":"SetRotationType","since":"6.0"},{"signature":"void SetRotationX(double d)","summary":"SetRotationX","since":"6.0"},{"signature":"void SetRotationY(double d)","summary":"SetRotationY","since":"6.0"},{"signature":"void SetSize(double d)","summary":"SetSize","since":"6.0","deprecated":"7.0"},{"signature":"double Size()","summary":"Size - used in the UI.  Always meters.","since":"6.0","deprecated":"7.0"},{"signature":"void ToMetaData()","summary":"Copy PreviewAppearance to MetaData","since":"6.0"},{"signature":"void ToMetaData(MetaDataProxy mdp)","summary":"Copy PreviewAppearance to MetaData","since":"6.8"}]},{"namespace":"Rhino.Render","name":"PreviewBackground","dataType":"class","summary":"PreviewBackGround takes care of constucting and desctrutction of PreviewLight","constructors":[{"signature":"PreviewBackground(IntPtr pPreviewBackground)","summary":"Constructor for PreivewLighting","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","summary":"CppPointer for PreivewLighting","since":"6.0","property":["get"]}],"methods":[{"signature":"string ElementKind()","summary":"ElementKind","since":"6.0"},{"signature":"Guid EnvironmentInstanceId()","summary":"EnvironmentInstanceId","since":"6.0"},{"signature":"void SetEnvironmentInstanceId(Guid guid)","summary":"SetEnvironmentInstanceId","since":"6.0"},{"signature":"void SetUpPreview(IntPtr sceneServerPointer, Guid guid)","summary":"SetUpPreview","since":"6.0"}]},{"namespace":"Rhino.Render","name":"PreviewGeometry","dataType":"class","summary":"PreviewAppearance takes care of constucting and desctrutction of PreivewGeometry","constructors":[{"signature":"PreviewGeometry(IntPtr pPreviewGeometry)","summary":"Constructor for PreviewGeometry","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","summary":"CppPointer for PreviewGeometry","since":"6.0","property":["get"]}],"methods":[{"signature":"string ElementKind()","summary":"ElementKind","since":"6.0"},{"signature":"void SetUpPreview(IntPtr sceneServerPointer, IntPtr pRenderContent, bool bCopy)","summary":"SetUpPreview","since":"6.0"}]},{"namespace":"Rhino.Render","name":"PreviewLighting","dataType":"class","summary":"PreviewAppearance takes care of constucting and desctrutction of PreviewLight","constructors":[{"signature":"PreviewLighting(IntPtr pPreviewLighting)","summary":"Constructor for PreivewLighting","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","summary":"CppPointer for PreivewLighting","since":"6.0","property":["get"]}],"methods":[{"signature":"string ElementKind()","summary":"ElementKind","since":"6.0"},{"signature":"void SetUpPreview(IntPtr sceneServerPointer)","summary":"SetUpPreview","since":"6.0"}]},{"namespace":"Rhino.Render","name":"PreviewSceneQuality","dataType":"enum","summary":"Quality levels when creating preview images","since":"5.1","values":[{"signature":"    RealtimeQuick = Low","summary":"Very fast preview. Typically using the internal OpenGL preview generator."},{"signature":"    RefineFirstPass = Low","summary":"Low quality rendering for quick preview."},{"signature":"    RefineSecondPass = Medium","summary":"Medium quality rendering for intermediate preview."},{"signature":"    RefineThirdPass = Full","summary":"Full quality rendering (quality comes from user settings)"},{"signature":"None = 0","summary":"No quality set."},{"signature":"Low = 1","summary":"Low quality rendering for quick preview."},{"signature":"Medium = 2","summary":"Medium quality rendering for intermediate preview."},{"signature":"IntermediateProgressive = 3","summary":"Intermediate update, always considered better quality than the previous IntermediateProgressive, but not as high as Full."},{"signature":"Full = 4","summary":"Full quality rendering (quality comes from user settings)."}]},{"namespace":"Rhino.Render","name":"PreviewSceneServer","dataType":"class","summary":"PreviewSceneServer","constructors":[{"signature":"PreviewSceneServer(IntPtr pPreviewSceneServer)","summary":"Constructor for PreviewSceneServer","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","summary":"The CppPointer of PreviewSceneServer","since":"6.0","property":["get"]}],"methods":[{"signature":"void ApplyRotation(double X, double Y, IRhRdkPreviewSceneServer_eRotationType type)","summary":"Set Scene Server Rotation","since":"6.0"},{"signature":"void Dispose()","summary":"Dispose for PreviewSceneServer","since":"6.0"},{"signature":"void SetSceneScale(double scale)","summary":"Set Scene Server Scale","since":"7.0"}]},{"namespace":"Rhino.Render","name":"ProxyTypes","dataType":"enum","summary":"Defines the proxy type of the render content","since":"6.0","values":[{"signature":"None"},{"signature":"Single"},{"signature":"Multi"},{"signature":"Texture"}]},{"namespace":"Rhino.Render","name":"RdkUndo","dataType":"class","summary":"RdkUndo class, which is used to get the RdkUndoRecord","interfaces":["IDisposable"],"constructors":[{"signature":"RdkUndo(IntPtr pUndoRecord)","summary":"Constructor for RdkUndo","since":"6.11"}],"methods":[{"signature":"void Dispose()","summary":"Dispose for RdkUndo","since":"6.11"},{"signature":"RdkUndoRecord NewUndoRecord()","summary":"Get a new UndoRecord","since":"6.11"}]},{"namespace":"Rhino.Render","name":"RdkUndoRecord","dataType":"class","summary":"RdkUndoRecord class","interfaces":["IDisposable"],"constructors":[{"signature":"RdkUndoRecord(IntPtr pUndoRecord)","summary":"Constructor for RdkUndoRecord","since":"6.0"}],"methods":[{"signature":"void Dispose()","summary":"Dispose for RdkUndoRecord","since":"6.0"},{"signature":"void SetDescription(String description)","summary":"Set description for RdkUndoRecord","since":"6.0"}]},{"namespace":"Rhino.Render","name":"RealtimeDisplayMode","dataType":"class","summary":"Base class for implementing real-time display modes in .NET.  Pay special attention that in StartRenderer the RenderWindow.SetSize() function is called if the implementation relies on the RenderWindow to do the drawing to the viewport. If i.e. OpenGL is used to draw render results to the viewport then SetSize() doesn\'t have to be called, nor should the implementation then access channels on the RenderWindow, as those then don\'t exist. For OpenGL-based drawing the RenderWindow is used as a container for ViewInfo management, nothing else.","properties":[{"signature":"LinearWorkflow LinearWorkflow","summary":"Returns the LinearWorkflow data for this realitime display mode.","since":"6.0","property":["get"]},{"signature":"bool Locked","since":"6.6","property":["get","set"]},{"signature":"int MaxPasses","since":"6.6","property":["get","set"]},{"signature":"bool Paused","since":"6.6","property":["get","set"]},{"signature":"bool PostEffectsOn","property":["get","set"]}],"methods":[{"signature":"static RealtimeDisplayMode GetRealtimeViewport(IntPtr realtimeViewport)","summary":"Retrieve RealtimeDisplayMode instance that the IntPtr refers to.","since":"6.0","parameters":[{"name":"realtimeViewport","summary":"IntPtr of the instance searched for. If the instance doesn\'t exist, a new one is created."}]},{"signature":"static RealtimeDisplayMode GetRealtimeViewport(IntPtr realtimeViewport, bool create)","summary":"Retrieve RealtimeDisplayMode instance. If create is set to true then a new instance is created if not found, None is returned for false.","since":"6.0","parameters":[{"name":"realtimeViewport","summary":"IntPtr"},{"name":"create","summary":"True to create if not found, False to return None if not found."}]},{"signature":"static RealtimeDisplayModeClassInfo[] RegisterDisplayModes(Assembly assembly, Guid pluginId)","summary":"Find and register classes that derive from RealtimeDisplayMode from the given plug-in. The plug-in is found in the given assembly","since":"6.0"},{"signature":"static RealtimeDisplayModeClassInfo[] RegisterDisplayModes(PlugIn plugin)","summary":"Find and register classes that derive from RealtimeDisplayMode from the given plug-in.","since":"6.0"},{"signature":"static void RemoveRealtimeViewport(IntPtr realtimeViewport)","summary":"Remove RealtimeDisplayMode instance from internal dictionary.","since":"6.0","parameters":[{"name":"realtimeViewport","summary":"IntPtr to the RealtimeDisplayMode instance to remove."}]},{"signature":"static void UnregisterDisplayModes(Assembly assembly, Guid pluginId)","since":"6.0"},{"signature":"static void UnregisterDisplayModes(PlugIn plugin)","since":"6.0"},{"signature":"double CaptureProgress()","summary":"Override to communicate the progress of a capture.","since":"6.0","returns":"A number between 0.0 and 1.0 inclusive. 1.0 means 100%."},{"signature":"uint ComputeViewportCrc(ViewInfo view)","summary":"Compute viewport CRC for the given ViewInfo","since":"6.0","returns":"the CRC for the given view"},{"signature":"void CreateWorld(RhinoDoc doc, ViewInfo viewInfo, DisplayPipelineAttributes displayPipelineAttributes)","summary":"Implement if you need to handle the initial CreateWorld call initiated by the display pipeline system. Note that this is not the same as the CreateWorld call in Rhino.Render.ChangeQueue.ChangeQueue, although related.","since":"6.0","parameters":[{"name":"doc","summary":"Rhino document"},{"name":"viewInfo","summary":"active viewport info"},{"name":"displayPipelineAttributes","summary":"display pipeline attributes"}]},{"signature":"bool DrawOpenGl()","since":"6.0"},{"signature":"void GetRenderSize(out int width, out int height)","summary":"Get the current render resolution for the running render session.","since":"6.0"},{"signature":"ViewInfo GetView()","summary":"Get ViewInfo that has been registered with this RealtimeDisplayMode instance.","since":"6.0"},{"signature":"bool HudAllowEditMaxPasses()","summary":"Override to allow maximum pass editing. By default disabled.","since":"6.0","returns":"Return True to allow users to edit the maximum pass count."},{"signature":"string HudCustomStatusText()","summary":"Override to display status of the render engine.","since":"6.0","returns":"Status text to display"},{"signature":"int HudLastRenderedPass()","summary":"Override to communicate the last completed pass. Can be shown in the HUD","since":"6.0","returns":"Last completed pass"},{"signature":"int HudMaximumPasses()","summary":"Override to communicate the maximum passes count currently in use for the render session. Can be shown in the HUD","since":"6.0","returns":"Maximum passes"},{"signature":"string HudProductName()","summary":"Override to return the name of your product. This will be printed in the HUD.","since":"6.0","returns":"Name of the product."},{"signature":"bool HudRendererLocked()","summary":"Implement to support locking in the viewport","since":"6.0","returns":"Return True if the render engine is locked."},{"signature":"bool HudRendererPaused()","summary":"Implement to support pausing and resuming in the viewport","since":"6.0","returns":"Return True if the render engine is paused."},{"signature":"bool HudShow()","summary":"Override if you want to hide the HUD. Shown by default","since":"6.0","returns":"Return False to hide the HUD."},{"signature":"bool HudShowControls()","summary":"Show control buttons on the realtime display HUD.  By default these are shown, override this function and return False if HUD controls aren\'t needed.","since":"6.0"},{"signature":"bool HudShowCustomStatusText()","summary":"Override to show status text in HUD. By default disabled.","since":"6.0","returns":"Return True to show status text in HUD"},{"signature":"bool HudShowMaxPasses()","summary":"Override to show maximum passes in HUD. By default disabled.","since":"6.0","returns":"Return True to show maximum passes."},{"signature":"bool HudShowPasses()","summary":"Override to show current pass in HUD. By default disabled.","since":"6.0","returns":"Return True to show current pass in HUD."},{"signature":"DateTime HudStartTime()","since":"6.0"},{"signature":"bool IsCompleted()","summary":"Implement to tell if your render engine has completed a frame for drawing into the viewport","since":"6.0"},{"signature":"bool IsFrameBufferAvailable(ViewInfo view)","summary":"Implement to tell the render pipeline that a framebuffer is ready","since":"6.0","returns":"Return True when a framebuffer is ready. This is generally the case when StartRenderer as returned successfully."},{"signature":"bool IsRendererStarted()","summary":"Override to tell the started state of your render engine.","since":"6.0","returns":"True if render engine is ready and rendering"},{"signature":"int LastRenderedPass()","summary":"Implement to communicate last completed pass to the underlying system.","since":"6.0","returns":"the last completed pass"},{"signature":"bool OnRenderSizeChanged(int width, int height)","summary":"Override to restart your render engine","since":"6.0"},{"signature":"int OpenGlVersion()","since":"6.0"},{"signature":"void PostConstruct()","summary":"Override PostConstruct if you need to initialize where the underlying RealtimeDisplayMode is available.  The connection is made right after RealtimeDisplayMode has been instantiated, but just before PostConstruct is called.  For instance finding out OpenGL information can be done in PostConstruct.","since":"6.0"},{"signature":"void SetUseDrawOpenGl(bool use)","summary":"During run-time change whether to use OpenGL drawing of results or not. For instance offline rendering (viewcapture* with different resolution than viewport) could use RenderWindow instead of direct OpenGL drawing.","since":"6.0","parameters":[{"name":"use","summary":"Set to True if OpenGL drawing is wanted, set to False if RenderWindow method is needed."}]},{"signature":"void SetView(ViewInfo view)","summary":"Set ViewInfo for this RealtimeDisplayMode instance.","since":"6.0","parameters":[{"name":"view","summary":"The ViewInfo to set for subsequent tests."}]},{"signature":"bool ShowCaptureProgress()","summary":"Override if you want to i.e. hide the progress dialog for capture progress.","since":"6.0","returns":"Return True to show, False to hide"},{"signature":"void ShutdownRenderer()","summary":"Override to shutdown your render engine","since":"6.0"},{"signature":"void SignalRedraw()","summary":"Use to signal the underlying pipeline a redraw is wanted. This can be used for instance when a renderer has completed a pass which should be updated in the associated viewport.","since":"6.0"},{"signature":"bool StartRenderer(int w, int h, RhinoDoc doc, ViewInfo view, ViewportInfo viewportInfo, bool forCapture, RenderWindow renderWindow)","summary":"Override to start your render engine.  Note that before using the RenderWindow you *must* call SetSize to properly initialize the underlying DIB.","since":"6.0","parameters":[{"name":"w","summary":"Width of resolution"},{"name":"h","summary":"Height of resolution"},{"name":"doc","summary":"Rhino document"},{"name":"view","summary":"active view"},{"name":"viewportInfo","summary":"active viewport info"},{"name":"forCapture","summary":"True if renderer is started for capture purposes (ViewCaptureTo*), False for regular interactive rendering"},{"name":"renderWindow","summary":"RenderWindow to hold render results in."}],"returns":"Return True when your render engine started correctly, False when that failed"},{"signature":"bool UseFastDraw()","summary":"Implement and return True if you want the display pipeline to not wait for IsFramebufferAvailable during the MiddleGround draw phase. This will also tell the pipeline to draw a complete middleground pass in OpenGL.","since":"6.0"}]},{"namespace":"Rhino.Render","name":"RealtimeDisplayMode.DisplayPipelineSettingsChangedEventArgs","dataType":"class","baseclass":"EventArgs","constructors":[{"signature":"RealtimeDisplayMode.DisplayPipelineSettingsChangedEventArgs(DisplayPipelineAttributes dpa)","since":"6.0"}],"properties":[{"signature":"DisplayPipelineAttributes Attributes","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Render","name":"RealtimeDisplayMode.DrawMiddlegroundEventArgs","dataType":"class","baseclass":"EventArgs","constructors":[{"signature":"RealtimeDisplayMode.DrawMiddlegroundEventArgs(DisplayPipeline dp)","since":"6.0"}],"properties":[{"signature":"DisplayPipeline Pipeline","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Render","name":"RealtimeDisplayMode.HudMaxPassesChangedEventArgs","dataType":"class","baseclass":"EventArgs","constructors":[{"signature":"RealtimeDisplayMode.HudMaxPassesChangedEventArgs(int mp)","since":"6.0"}],"properties":[{"signature":"int MaxPasses","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Render","name":"RealtimeDisplayMode.InitFramebufferEventArgs","dataType":"class","baseclass":"EventArgs","constructors":[{"signature":"RealtimeDisplayMode.InitFramebufferEventArgs(DisplayPipeline dp)","since":"6.0"}],"properties":[{"signature":"DisplayPipeline Pipeline","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Render","name":"RealtimeDisplayModeClassInfo","dataType":"class","summary":"Class information obligatory for registering RealtimeDisplayMode implementations.","properties":[{"signature":"bool DontRegisterAttributesOnStart","summary":"Override and return True when you don\'t want your class info to cause display attributes to be registered with the system.","since":"6.0","property":["get"]},{"signature":"bool DrawOpenGl","summary":"Return True if the RealtimeDisplayMode draws its result using OpenGL. RenderWindow usage will then be skipped.","since":"6.0","property":["get"]},{"signature":"Guid GUID","summary":"Get the RealtimeDisplayMode implementation GUID","since":"6.0","property":["get"]},{"signature":"string Name","summary":"Get human-facing class description for RealtimeDisplayMode implementation. This string might show up in the Rhino UI.","since":"6.0","property":["get"]},{"signature":"Type RealtimeDisplayModeType","summary":"Get the type being registered.","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Render","name":"RenderChannels","dataType":"class","summary":"Render Channels. This corresponds to the user\'s settings in the Rendering panel.","baseclass":"Rhino.Render.DocumentOrFreeFloatingBase","properties":[{"signature":"Guid[] CustomList","since":"7.0","property":["get","set"]},{"signature":"Modes Mode","since":"7.0","property":["get","set"]}],"methods":[{"signature":"void CopyFrom(FreeFloatingBase src)","since":"7.0"}],"events":[{"signature":"static Changed","summary":"This event is raised when a Render Channels property value is changed.","since":"7.0"}]},{"namespace":"Rhino.Render","name":"RenderChannels.Modes","dataType":"enum","summary":"Mode.","values":[{"signature":"Automatic","summary":"Render-channels are managed automatically"},{"signature":"Custom","summary":"Render-channels are specified by the user"}]},{"namespace":"Rhino.Render","name":"RenderContent","dataType":"class","interfaces":["IDisposable"],"properties":[{"signature":"bool CanBeEdited","summary":"Determines if the content can be edited.","since":"6.0","property":["get"]},{"signature":"String Category","summary":"Category for this content.","since":"6.7","property":["get"]},{"signature":"String ChildSlotDisplayName","summary":"Returns the localized display name of the child slot name","since":"7.0","property":["get"]},{"signature":"String ChildSlotName","since":"5.1","property":["get","set"]},{"signature":"IntPtr CppPointer","since":"6.0","property":["get"]},{"signature":"RhinoDoc Document","summary":"If this content is in a document content list, the document will be returned.  Otherwise null.","since":"5.10","property":["get"]},{"signature":"RhinoDoc DocumentAssoc","summary":"If this content is associated by a document in any way, the document will be returned.  This includes copies of contents that were initially in the document. Otherwise null.","since":"6.0","property":["get","set"]},{"signature":"RhinoDoc DocumentRegistered","summary":"If this content is used by a document, including not in the content lists (for example, as a decal), the document will be returned.  Otherwise null.","since":"6.0","property":["get"]},{"signature":"FieldDictionary Fields","summary":"Rhino.Render.Fields FieldDictionary which provides access to setting and retrieving field values.","since":"5.1","property":["get"]},{"signature":"IEnumerable<string> FilesToEmbed","summary":"A string array of full paths to files used by the content that may be embedded in .3dm files and library files (.rmtl, .renv, .rtex). The default implementation returns an empty string list. Override this to return the file name or file names used by your content. This is typically used by textures that reference files containing the texture imagery.","since":"5.12","property":["get"]},{"signature":"RenderContent FirstChild","summary":"Return First child of this content or nullptr if none.","since":"6.0","property":["get"]},{"signature":"Guid GroupId","summary":"Group ID of the content","since":"6.26","property":["get","set"]},{"signature":"bool Hidden","summary":"Determines if the content has the hidden flag set.","since":"5.1","property":["get","set"]},{"signature":"Guid Id","summary":"Instance identifier for this content.","since":"5.1","property":["get","set"]},{"signature":"bool IsDefaultInstance","summary":"Checks if render content is default instance.","since":"6.0","property":["get"]},{"signature":"bool IsHiddenByAutoDelete","summary":"Contents can be created as \'auto-delete\' by certain commands such as \'PictureFrame\'. These contents are automatically hidden from the user when the associated Rhino object is deleted. They are later deleted when the document is saved.","since":"6.15","property":["get"]},{"signature":"bool IsLocked","summary":"Set this property to True prior to adding content to the document to lock the content browser editing UI methods.  Setting this to True will keep the browser from allowing things like deleting, renaming or changing content.  This is useful for custom child content that you want to be editable but persistent.  Setting this after adding content to the document will cause an exception to be thrown.","since":"5.12","property":["get","set"]},{"signature":"String Name","summary":"Instance name for this content.","since":"5.1","property":["get","set"]},{"signature":"RenderContent NextSibling","summary":"Return First sibling of this content or nullptr if none.","since":"6.0","property":["get"]},{"signature":"String Notes","summary":"Notes for this content.","since":"5.1","property":["get","set"]},{"signature":"RenderContent Parent","summary":"Returns the top content in this parent/child chain.","since":"5.11","property":["get"]},{"signature":"ProxyTypes ProxyType","summary":"Gets the proxy type of the render content","since":"6.0","property":["get"]},{"signature":"uint RenderHash","summary":"Render hash for the content hierarchy. It iterates children and includes a caching mechanism which means the hash value can be retrieved quickly if it hasn\'t changed. The cache is invalidated when Changed() is called.  You can override the CalculateRenderHashmethod to provide a custom hash value.","since":"6.0","property":["get"]},{"signature":"String Tags","summary":"Tags for this content.","since":"6.4","property":["get","set"]},{"signature":"bool TopLevel","summary":"Returns True if this content has no parent, False if it is the child of another content.","since":"5.1","property":["get"]},{"signature":"RenderContent TopLevelParent","summary":"Returns the top content in this parent/child chain.","since":"5.1","property":["get"]},{"signature":"String TypeDescription","summary":"Description for your content type.  ie.  \\"Procedural checker pattern\\"","since":"5.1","property":["get"]},{"signature":"Guid TypeId","summary":"Type identifier for this content","since":"6.0","property":["get"]},{"signature":"String TypeName","summary":"Name for your content type.  ie. \\"My .net Texture\\"","since":"5.1","property":["get"]},{"signature":"String Xml","since":"6.0","property":["get"]}],"methods":[{"signature":"static bool AddPersistentRenderContent(RenderContent renderContent)","summary":"Add a material, environment or texture to the internal RDK document lists as top level content.  The content must have been returned from RenderContent::MakeCopy, NewContentFromType or a similar function that returns a non-document content.","since":"5.1","deprecated":"6.0","parameters":[{"name":"renderContent","summary":"The render content."}],"returns":"True on success."},{"signature":"static bool AddPersistentRenderContent(RhinoDoc document, RenderContent renderContent)","summary":"Add a material, environment or texture to the internal RDK document lists as top level content.  The content must have been returned from RenderContent::MakeCopy, NewContentFromType or a similar function that returns a non-document content.","since":"6.0","deprecated":"6.0","parameters":[{"name":"document","summary":"The document to attach the render content to."},{"name":"renderContent","summary":"The render content."}],"returns":"True on success."},{"signature":"static RenderContent Create(Guid type, RenderContent parent, String childSlotName, ShowContentChooserFlags flags, RhinoDoc doc)","summary":"Constructs a new content of the specified type and add it to the persistent content list. This function cannot be used to create temporary content that you delete after use. Content created by this function is owned by RDK and appears in the content editor. To create a temporary content which is owned by you, call RenderContentType.NewContentFromType().","since":"5.1","parameters":[{"name":"type","summary":"is the type of the content to add."},{"name":"parent","summary":"Parent is the parent content. If not NULL, this must be an RDK-owned content that is in the persistent content list (either top-level or child). The new content then becomes its child. If NULL, the new content is added to the top-level content list instead."},{"name":"childSlotName","summary":"ChildSlotName is the unique child identifier to use for the new content when creating it as a child of pParent (i.e., when pParent is not NULL)"},{"name":"flags","summary":"Options for the tab."},{"name":"doc","summary":"The current Rhino document."}],"returns":"A new persistent render content."},{"signature":"static RenderContent Create(Guid type, ShowContentChooserFlags flags, RhinoDoc doc)","summary":"Constructs a new content of the specified type and add it to the persistent content list. This function cannot be used to create temporary content that you delete after use. Content created by this function is owned by RDK and appears in the content editor. To create a temporary content which is owned by you, call RenderContentType.NewContentFromType().","since":"5.1","parameters":[{"name":"type","summary":"Is the type of the content to add."},{"name":"flags","summary":"Options for the tab."},{"name":"doc","summary":"The current Rhino document."}],"returns":"A new persistent render content."},{"signature":"static RenderContent Create(Type type, RenderContent parent, String childSlotName, ShowContentChooserFlags flags, RhinoDoc doc)","summary":"Constructs a new content of the specified type and add it to the persistent content list. This function cannot be used to create temporary content that you delete after use. Content created by this function is owned by RDK and appears in the content editor. To create a temporary content which is owned by you, call RenderContentType.NewContentFromType().","since":"5.1","parameters":[{"name":"type","summary":"is the type of the content to add."},{"name":"parent","summary":"Parent is the parent content. If not NULL, this must be an RDK-owned content that is in the persistent content list (either top-level or child). The new content then becomes its child. If NULL, the new content is added to the top-level content list instead."},{"name":"childSlotName","summary":"ChildSlotName is the unique child identifier to use for the new content when creating it as a child of pParent (i.e., when pParent is not NULL)"},{"name":"flags","summary":"Options for the tab."},{"name":"doc","summary":"The current Rhino document."}],"returns":"A new persistent render content."},{"signature":"static RenderContent Create(Type type, ShowContentChooserFlags flags, RhinoDoc doc)","summary":"Constructs a new content of the specified type and add it to the persistent content list. This function cannot be used to create temporary content that you delete after use. Content created by this function is owned by RDK and appears in the content editor. To create a temporary content which is owned by you, call RenderContentType.NewContentFromType().","since":"5.1","parameters":[{"name":"type","summary":"Is the type of the content to add."},{"name":"flags","summary":"Options for the tab."},{"name":"doc","summary":"The current Rhino document."}],"returns":"A new persistent render content."},{"signature":"static RenderContent FromId(RhinoDoc document, Guid id)","summary":"Search for a content object based on its Id","since":"5.7","parameters":[{"name":"document","summary":"The Rhino document containing the content."},{"name":"id","summary":"Id of the content instance to search for."}],"returns":"Returns the content object with the specified Id if it is found otherwise it returns null."},{"signature":"static RenderContent FromXml(String xml)","since":"6.0","deprecated":"6.4"},{"signature":"static RenderContent FromXml(String xml, RhinoDoc doc)","since":"6.4"},{"signature":"static RenderContent LoadFromFile(String filename)","summary":"Loads content from a library file.  Does not add the content to the persistent content list. Use AddPersistantContent to add it to the list.","since":"5.1","parameters":[{"name":"filename","summary":"full path to the file to be loaded."}],"returns":"The loaded content or None if an error occurred."},{"signature":"static Type[] RegisterContent(Assembly assembly, Guid pluginId)","summary":"Call RegisterContent in your plug-in\'s OnLoad function in order to register all of the custom RenderContent classes in your assembly.","since":"5.1","parameters":[{"name":"assembly","summary":"Assembly where custom content is defined, this may be a plug-in assembly or another assembly referenced by the plug-in."},{"name":"pluginId","summary":"Parent plug-in for this assembly."}],"returns":"array of render content types registered on success. None on error."},{"signature":"static Type[] RegisterContent(PlugIn plugin)","summary":"Call RegisterContent in your plug-in\'s OnLoad function in order to register all of the custom RenderContent classes in your assembly.","since":"5.1","returns":"array of render content types registered on success. None on error."},{"signature":"bool AddAutomaticUserInterfaceSection(string caption, int id)","summary":"Add a new automatic user interface section, Field values which include prompts will be automatically added to this section.","since":"5.1","parameters":[{"name":"caption","summary":"Expandable tab caption."},{"name":"id","summary":"Tab id which may be used later on to reference this tab."}],"returns":"Returns True if the automatic tab section was added otherwise; returns False on error."},{"signature":"bool AddChild(RenderContent renderContent)","since":"5.6","deprecated":"6.0"},{"signature":"bool AddChild(RenderContent renderContent, String childSlotName)","since":"6.0","deprecated":"6.0"},{"signature":"bool AddUserInterfaceSection(ICollapsibleSection section)","since":"6.0"},{"signature":"UI.UserInterfaceSection AddUserInterfaceSection(Type classType, string caption, bool createExpanded, bool createVisible)","summary":"Add a new .NET control to an content expandable tab section, the height of the createExpanded tabs client area will be the initial height of the specified control.","since":"5.1","deprecated":"6.0","parameters":[{"name":"classType","summary":"The control class to create and embed as a child window in the expandable tab client area.  This class type must be derived from IWin32Window or this method will throw an ArgumentException.  Implement the IUserInterfaceSection interface in your classType to get UserInterfaceSection notification."},{"name":"caption","summary":"Expandable tab caption."},{"name":"createExpanded","summary":"If this value is True then the new expandable tab section will initially be expanded, if it is False it will be collapsed."},{"name":"createVisible","summary":"If this value is True then the new expandable tab section will initially be visible, if it is False it will be hidden."}],"returns":"Returns the UserInterfaceSection object used to manage the new user control object."},{"signature":"void BeginChange(ChangeContexts changeContext)","summary":"Begins a change or batch of changes. This returns a reference to the content which you should use to make your changes. It may also make a copy of the content state allowing EndChangeto send an event with the old and new contents. Calls to this method are counted; you must call EndChange() once for every call to BeginChange(). Note: If Changed() was called between the calls to BeginChange() and EndChange(), the last call to EndChange() may cause the ContentChanged event to be sent.","since":"6.0","parameters":[{"name":"changeContext","summary":"the change context. If this is kUI, kProgram, kDrop or kTree, the content will be copied. EndChange() will then send the copy as \'old\' in the OnContentChanged event. Note: If you override this method,please be sure to call the base class. EndChange ContentChanged"}]},{"signature":"void BindParameterToField(string parameterName, Field field, ChangeContexts setEvent)","summary":"Use bindings to automatically wire parameters to fields","since":"5.7"},{"signature":"void BindParameterToField(string parameterName, string childSlotName, Field field, ChangeContexts setEvent)","summary":"Use bindings to automatically wire parameters to fields","since":"5.7"},{"signature":"bool ChangeChild(RenderContent oldContent, RenderContent newContent)","since":"5.6","deprecated":"6.0"},{"signature":"double ChildSlotAmount(String childSlotName)","summary":"Gets the amount property for the texture in the specified child slot.  Values are typically from 0.0 - 100.0","since":"5.7","parameters":[{"name":"childSlotName","summary":"Child slot name for the child"}]},{"signature":"string ChildSlotNameFromParamName(String paramName)","summary":"A \\"child slot\\" is the specific \\"slot\\" that a child (usually a texture) occupies. This is generally the \\"use\\" of the child - in other words, the thing the child operates on.  Some examples are \\"color\\", \\"transparency\\".","since":"5.1","parameters":[{"name":"paramName","summary":"The name of a parameter field. Since child textures will usually correspond with some parameter (they generally either replace or modify a parameter over UV space) these functions are used to specify which parameter corresponded with child slot.  If there is no correspondence, return the empty string."}],"returns":"The default behavior for these functions is to return the input string. Sub-classes may (in the future) override these functions to provide different mappings."},{"signature":"bool ChildSlotOn(String childSlotName)","summary":"Gets the on-ness property for the texture in the specified child slot.","since":"5.7","parameters":[{"name":"childSlotName","summary":"Child slot name for the child"}]},{"signature":"void ConvertUnits(UnitSystem from, UnitSystem to)","summary":"Modify your content so that it is converted from meters into the units of the unit system. No need to call the base class when you override this, and no need to recurse into children.","since":"7.0"},{"signature":"void DeleteAllChildren(ChangeContexts changeContexts)","since":"5.10"},{"signature":"bool DeleteChild(string childSlotName, ChangeContexts changeContexts)","since":"5.10"},{"signature":"void Dispose()","since":"5.1"},{"signature":"bool DynamicIcon(Size size, out Bitmap bitmap, DynamicIconUsage usage)","since":"6.0"},{"signature":"RenderContent Edit()","summary":"This method allows a render content hierarchy to be edited using a modal (AKA \'pop-up\') editor. If the original render content is in a document, it will remain there, and the edited one will be \'free-floating\'. Therefore it is the caller\'s responsibility to do any replacement in the document if required. The returned new content will be owned by the caller.","since":"6.13","returns":"Returns an edited version of the content hierarchy if successful, else null. The method always edits the entire hierarchy. It places a copy of the hierarchy in the editor and selects the copied item that corresponds to this one. Therefore, editing a child will return a top-level render content, not a child."},{"signature":"void EndChange()","summary":"Ends a change or batch of changes. Calls to this method are counted; you must call this method once for every call to BeginChange. Note: If BeginChangewas called with ChangeContexts.UI, ChangeContexts.Program, ChangeContexts.Drop or ChangeContexts.UI.Tree and Changed() was called between the calls to BeginChangeand EndChange(), the last call to EndChange() will raise the  ContentChangedevent.","since":"6.0"},{"signature":"DataSources.ContentFactory Factory()","since":"6.10"},{"signature":"RenderContent FindChild(String childSlotName)","since":"5.1"},{"signature":"RenderContent ForDisplay()","summary":"**** This method is for proxies and will be marked obsolete in V7 ****  The only place a single proxy can be displayed is in the New Content Control main thumbnail. All other attempts to use a single proxy in a UI require it to be replaced with the corresponding multi proxy. Single proxies override this to find the corresponding multi proxy.","since":"6.9","returns":"The cotnent."},{"signature":"object GetChildSlotParameter(String parameterName, String childSlotName)","summary":"Extra requirements are a way of specifying extra functionality on parameters in the automatic UI. Implement this function to specify additional functionality for automatic UI sections or the texture summary. See IAutoUIExtraRequirements.h in the C++ RDK for string definitions for the parameter names.","since":"5.7","parameters":[{"name":"parameterName","summary":"The parameter or field internal name to which this query applies"},{"name":"childSlotName","summary":"The extra requirement parameter, as listed in IAutoUIExtraRequirements.h in the C++ RDK"}],"returns":"Call the base class if you do not support the extra requirement parameter. Current supported return values are (int, bool, float, double, string, Guid, Color, Vector3d, Point3d, DateTime)"},{"signature":"string[] GetEmbeddedFilesList()","since":"6.0"},{"signature":"object GetParameter(String parameterName)","summary":"Query the content instance for the value of a given named parameter. If you do not support this parameter, call the base class.","since":"5.7","parameters":[{"name":"parameterName","summary":"Name of the parameter"}],"returns":"IConvertible. Note that you can\'t directly cast from object, instead you have to use the Convert mechanism."},{"signature":"bool GetUnderlyingInstances(ref RenderContentCollection collection)","since":"7.0"},{"signature":"bool Icon(Size size, out Bitmap bitmap)","since":"6.0"},{"signature":"bool Initialize()","since":"6.1"},{"signature":"bool IsCompatible(Guid renderEngineId)","since":"6.0"},{"signature":"bool IsContentTypeAcceptableAsChild(Guid type, String childSlotName)","since":"6.0"},{"signature":"bool IsFactoryProductAcceptableAsChild(ContentFactory factory, String childSlotName)","since":"6.1"},{"signature":"bool IsFactoryProductAcceptableAsChild(Guid kindId, string factoryKind, string childSlotName)","summary":"Override this method to restrict the type of acceptable child content. The default implementation of this method just returns true.","since":"5.11","returns":"Return True only if content with the specified kindId can be  accepted as a child in the specified child slot."},{"signature":"bool IsReference()","summary":"Query whether or not the content or any of its ancestors is a reference content.","since":"6.9","returns":"True if the content is a reference, else false"},{"signature":"bool IsRenderHashCached()","summary":"This method is deprecated and no longer called. For more information see CalculateRenderHash","since":"6.0","deprecated":"6.0","returns":"bool"},{"signature":"RenderContent MakeCopy()","summary":"Create a copy of the render content. All content is the same, except for the instance Id.","since":"6.0","returns":"The new RenderContent"},{"signature":"RenderContent MakeGroupInstance()","summary":"Create an \'instance\' of the content tree and group the new tree with this tree. If the instance is subsequently attached to the same document, the state of all members of the group will be kept synchronized.With the exception of the instance ids, all state is exactly preserved in the new instance tree. \\\\note The grouping will have no effect until the new instance is attached to the same document.","since":"6.26","returns":"A grouped instance of the content tree"},{"signature":"MatchDataResult MatchData(RenderContent oldContent)","summary":"Implement to transfer data from another content to this content during creation.","since":"6.0","parameters":[{"name":"oldContent","summary":"An old content object from which the implementation may harvest data."}],"returns":"Information about how much data was matched."},{"signature":"PreviewSceneServer NewPreviewSceneServer(SceneServerData ssd)","summary":"Gets the PreviewSceneServer of the content","since":"6.0","parameters":[{"name":"ssd","summary":"SceneServerData"}]},{"signature":"bool OpenInEditor()","summary":"Call this method to open the content in the relevant thumbnail editor and select it for editing by the user. The content must be in the document or the call will fail.","since":"5.7","returns":"Returns True on success or False on error."},{"signature":"bool OpenInModalEditor()","summary":"Call this method to open the content in the a modal version of the editor. The content must be in the document or the call will fail.","since":"5.7","deprecated":"6.13","returns":"Returns True on success or False on error."},{"signature":"string ParamNameFromChildSlotName(String childSlotName)","summary":"A \\"child slot\\" is the specific \\"slot\\" that a child (usually a texture) occupies. This is generally the \\"use\\" of the child - in other words, the thing the child operates on.  Some examples are \\"color\\", \\"transparency\\".","since":"5.1","parameters":[{"name":"childSlotName","summary":"The named of the child slot to receive the parameter name for."}],"returns":"The default behavior for these functions is to return the input string.  Sub-classes may (in the future) override these functions to provide different mappings."},{"signature":"uint RenderHashExclude(CrcRenderHashFlags flags, string excludeParameterNames)","summary":"As RenderHash, but ignore parameter names given.","since":"6.2","parameters":[{"name":"flags","summary":"Flags to ignore"},{"name":"excludeParameterNames","summary":"semicolon-delimited string"}],"returns":"Render hash"},{"signature":"uint RenderHashExclude(CrcRenderHashFlags flags, string excludeParameterNames, LinearWorkflow lw)","summary":"As RenderHash, but ignore parameter names given. Use this version of the function to calculate a render hash when you have the linear workflow information and you are not running on the main thread.  Access to LinearWorkflow data requires document access. CrcRenderHashFlags.ExcludeLinearWorkflow must be specified.","since":"6.2","parameters":[{"name":"flags","summary":"Flags to ignore"},{"name":"excludeParameterNames","summary":"semicolon-delimited string"},{"name":"lw","summary":"Linear Workflow to use for CRC"}],"returns":"Render hash"},{"signature":"uint RenderHashExclude(TextureRenderHashFlags flags, string excludeParameterNames)","summary":"As RenderHash, but ignore parameter names given.","since":"6.0","parameters":[{"name":"flags","summary":"Flags to ignore"},{"name":"excludeParameterNames","summary":"semicolon-delimited string"}],"returns":"Render hash"},{"signature":"bool Replace(RenderContent newcontent)","since":"6.13"},{"signature":"bool SetChild(RenderContent renderContent, String childSlotName)","summary":"Set another content as a child of this content. This content may or may not be attached to a document.  If this content already has a child with the specified child slot name, that child will be deleted.  If this content is not attached to a document, the child will be added without sending any events.  If this content is attached to a document, the necessary events will be sent to update the UI. Note: Do not call this method to add children in your constructor. If you want to add default children, you should override Initialize() and add them there.","since":"6.0","parameters":[{"name":"renderContent","summary":"Child content to add to this content. If pChild is NULL, the function will fail.  If pChild is already attached to a document, the function will fail.  If pChild is already a child of this or another content, the function will fail."},{"name":"childSlotName","summary":"The name that will be assigned to this child slot. The child slot name cannot be an empty string. If it is, the function will fail."}],"returns":"Returns True if the content was added or the child slot with this name was modified otherwise; returns false."},{"signature":"bool SetChild(RenderContent renderContent, String childSlotName, ChangeContexts changeContexts)","summary":"Set another content as a child of this content. This content may or may not be attached to a document.  If this content already has a child with the specified child slot name, that child will be deleted.  If this content is not attached to a document, the child will be added without sending any events.  If this content is attached to a document, the necessary events will be sent to update the UI. Note: Do not call this method to add children in your constructor. If you want to add default children, you should override Initialize() and add them there.","since":"5.10","deprecated":"6.0","parameters":[{"name":"renderContent","summary":"Child content to add to this content. If pChild is NULL, the function will fail.  If pChild is already attached to a document, the function will fail.  If pChild is already a child of this or another content, the function will fail."},{"name":"childSlotName","summary":"The name that will be assigned to this child slot. The child slot name cannot be an empty string. If it is, the function will fail."},{"name":"changeContexts","summary":""}],"returns":"Returns True if the content was added or the child slot with this name was modified otherwise; returns false."},{"signature":"void SetChildSlotAmount(String childSlotName, double amount, ChangeContexts cc)","summary":"Sets the amount property for the texture in the specified child slot.  Values are typically from 0.0 - 100.0","since":"5.7","parameters":[{"name":"childSlotName","summary":"Child slot name for the child"},{"name":"amount","summary":"Texture amount. Values are typically from 0.0 - 100.0"},{"name":"cc","summary":"Context of the change."}]},{"signature":"void SetChildSlotOn(String childSlotName, bool bOn, ChangeContexts cc)","summary":"Sets the on-ness property for the texture in the specified child slot.","since":"5.7","parameters":[{"name":"childSlotName","summary":"Child slot name for the child"},{"name":"bOn","summary":"Value for the on-ness property."},{"name":"cc","summary":"Context of the change"}]},{"signature":"bool SetChildSlotParameter(String parameterName, String childSlotName, object value, ExtraRequirementsSetContexts sc)","summary":"Extra requirements are a way of specifying extra functionality on parameters in the automatic UI. Implement this function to support values being set from automatic UI sections or the texture summary. See IAutoUIExtraRequirements.h in the C++ RDK for string definitions for the parameter names.","since":"5.7","parameters":[{"name":"parameterName","summary":"The parameter or field internal name to which this query applies"},{"name":"childSlotName","summary":"The extra requirement parameter, as listed in IAutoUIExtraRequirements.h in the C++ RDK"},{"name":"value","summary":"The value to set this extra requirement parameter. You will typically use System.Convert to convert the value to the type you need"},{"name":"sc","summary":"The context of this operation."}],"returns":"Null variant if not supported.  Call the base class if you do not support the extra requirement paramter."},{"signature":"void SetName(string name, bool renameEvents, bool ensureNameUnique)","summary":"Set instance name for this content","since":"7.0"},{"signature":"bool SetParameter(String parameterName, object value)","summary":"Set the named parameter value for this content instance. If you do not support this parameter, call the base class.","since":"6.0"},{"signature":"bool SetParameter(String parameterName, object value, ChangeContexts changeContext)","summary":"Set the named parameter value for this content instance. If you do not support this parameter, call the base class.","since":"5.7","deprecated":"6.0"},{"signature":"void SetRenderHash(uint hash)","summary":"This method is deprecated and no longer called. For more information see CalculateRenderHash","since":"6.0","deprecated":"6.0"},{"signature":"bool SmartUngroupRecursive()","summary":"Remove this content and all its children from any instance groups they may be a member of. If any content in the same document is left alone in the group, that content is also ungrouped. Records undo and sends events OnContentChanged and OnContentGroupIdChanged. \\\\note This method is designed to be called from a content UI and is intended for RDK internal use but may be used as an expert user override.","since":"6.26","returns":"True if a content was ungrouped, \\\\e False if no content or child was part of a group."},{"signature":"bool Ungroup()","summary":"Remove this content from any instance group it may be a member of. Does not record undo but does send the OnContentGroupIdChanged event.","since":"6.26","returns":"True if content was ungrouped, \\\\e False if it was not part of a group."},{"signature":"bool UngroupRecursive()","summary":"Remove this content and all its children from any instance groups they may be a member of. Does not record undo but does send the OnContentGroupIdChanged event.","since":"6.26","returns":"True if a content was ungrouped, \\\\e False if no content or child was part of a group."},{"signature":"void Uninitialize()","since":"6.1"},{"signature":"int UseCount()","summary":"UseCount returns how many times the content is used","since":"6.9"},{"signature":"bool VirtualIcon(Size size, out Bitmap bitmap)","summary":"Icon to display in the content browser, this bitmap needs to be valid for the life of this content object, the content object that returns the bitmap is responsible for disposing of the bitmap.","since":"6.0","parameters":[{"name":"size","summary":"Requested icon size"},{"name":"bitmap","summary":""}],"returns":"Return Icon to display in the content browser."}],"events":[{"signature":"static ContentAdded","summary":"Used to monitor render content addition to the document.","since":"5.7"},{"signature":"static ContentChanged","summary":"Used to monitor render content modifications.","since":"5.7"},{"signature":"static ContentDeleted","summary":"Used to monitor render content deletion from the document.","since":"6.0"},{"signature":"static ContentDeleting","summary":"Used to monitor render content deletion from the document.","since":"5.7"},{"signature":"static ContentFieldChanged","summary":"This event is raised when a field value is modified.","since":"5.11"},{"signature":"static ContentRenamed","summary":"Used to monitor render content renaming in the document.","since":"5.7"},{"signature":"static ContentReplaced","summary":"Used to monitor render content replacing in the document.","since":"5.7"},{"signature":"static ContentReplacing","summary":"Used to monitor render content replacing in the document.","since":"5.7"},{"signature":"static ContentUpdatePreview","summary":"Used to monitor render content preview updates.","since":"5.7"},{"signature":"static CurrentEnvironmentChanged","summary":"Event fired when changes to current environments have been made. This will be one of Background, ReflectionAndRefraction or Skylighting Since 6.11","since":"6.11"}]},{"namespace":"Rhino.Render","name":"RenderContent.ChangeContexts","dataType":"enum","summary":"Context of a change to content parameters.","since":"5.1","values":[{"signature":"UI = 0","summary":"Change occurred as a result of user activity in the content\'s UI."},{"signature":"Drop = 1","summary":"Change occurred as a result of drag and drop."},{"signature":"Program = 2","summary":"Change occurred as a result of internal program activity."},{"signature":"Ignore = 3","summary":"Change can be disregarded."},{"signature":"Tree = 4","summary":"Change occurred within the content tree (e.g., nodes reordered)."},{"signature":"Undo = 5","summary":"Change occurred as a result of an undo."},{"signature":"FieldInit = 6","summary":"Change occurred as a result of a field initialization."},{"signature":"Serialize = 7","summary":"Change occurred during serialization (loading)."}]},{"namespace":"Rhino.Render","name":"RenderContent.ExtraRequirementsSetContexts","dataType":"enum","since":"5.7","values":[{"signature":"UI = 0","summary":"Setting extra requirement as a result of user activity."},{"signature":"Drop = 1","summary":"Setting extra requirement as a result of drag and drop."},{"signature":"Program = 2","summary":"Setting extra requirement as a result of other (non-user) program activity."}]},{"namespace":"Rhino.Render","name":"RenderContent.MatchDataResult","dataType":"enum","summary":"Return values for MatchData function","since":"5.7","values":[{"signature":"None = 0"},{"signature":"Some = 1"},{"signature":"All = 2"}]},{"namespace":"Rhino.Render","name":"RenderContent.ShowContentChooserFlags","dataType":"enum","since":"5.1","values":[{"signature":"None = 0x0000"},{"signature":"HideNewTab = 0x0001"},{"signature":"HideExistingTab = 0x0002"}]},{"namespace":"Rhino.Render","name":"RenderContentChangedEventArgs","dataType":"class","baseclass":"Rhino.Render.RenderContentEventArgs","properties":[{"signature":"ChangeContexts ChangeContext","since":"5.7","property":["get"]},{"signature":"RenderContent OldContent","since":"6.0","property":["get"]}]},{"namespace":"Rhino.Render","name":"RenderContentChangeReason","dataType":"enum","summary":"Enumeration denoting type of change for attach or detach","since":"6.0","values":[{"signature":"None","summary":"No attach or detach change"},{"signature":"Attach","summary":"Content is being attached by the RhinoDoc.AttachContent() or RenderContent.AttachChild() methods."},{"signature":"Detach","summary":"Content is being detached by the RenderContent.DeleteContent() method."},{"signature":"ChangeAttach","summary":"Content is being attached while changing."},{"signature":"ChangeDetach","summary":"Content is being detached while changing."},{"signature":"AttachUndo","summary":"Content is being attached during undo/redo"},{"signature":"DetachUndo","summary":"Content is being detached during undo/redo."},{"signature":"Open","summary":"Content is being attached during open document"},{"signature":"Delete","summary":"Content is being detached during normal deletion."}]},{"namespace":"Rhino.Render","name":"RenderContentCollection","dataType":"class","interfaces":["IDisposable","IEnumerable"],"constructors":[{"signature":"RenderContentCollection()","since":"6.0"},{"signature":"RenderContentCollection(IntPtr nativePtr)","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.0","property":["get"]}],"methods":[{"signature":"void Add(RenderContentCollection collection)","since":"6.0"},{"signature":"void Append(RenderContent content)","since":"6.0"},{"signature":"void Clear()","since":"6.0"},{"signature":"RenderContent ContentAt(int index)","since":"6.0"},{"signature":"bool ContentNeedsPreviewThumbnail(RenderContent c, bool includeChildren)","since":"7.0"},{"signature":"int Count()","since":"6.0"},{"signature":"void Dispose()","since":"6.0"},{"signature":"RenderContent Find_Sel(Guid uuid)","since":"6.0"},{"signature":"string FirstTag()","since":"6.13"},{"signature":"IEnumerator GetEnumerator()","since":"6.0"},{"signature":"FilterContentByUsage GetFilterContentByUsage()","since":"6.9"},{"signature":"bool GetForcedVaries()","since":"6.9"},{"signature":"string GetSearchPattern()","since":"6.0"},{"signature":"ContentCollectionIterator Iterator()","since":"6.0"},{"signature":"string NextTag()","since":"6.13"},{"signature":"void Remove(RenderContentCollection collection)","since":"6.0"},{"signature":"void Set(RenderContentCollection collection)","since":"6.0"},{"signature":"void SetForcedVaries(bool b)","since":"6.9"},{"signature":"void SetSearchPattern(string pattern)","since":"6.0"}]},{"namespace":"Rhino.Render","name":"RenderContentEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"RenderContent Content","since":"5.7","property":["get"]},{"signature":"RhinoDoc Document","since":"6.0","property":["get","set"]},{"signature":"Usage EnvironmentUsage","summary":"Meaningful for CurrentEnvironmentChanged event. Will be one of Background, ReflectionAndRefraction or Skylighting.  Since 6.11","since":"6.11","property":["get","set"]},{"signature":"RenderContentChangeReason Reason","summary":"Not when used in CurrentEnvironmentChanged (defaults to None).","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Render","name":"RenderContentFieldChangedEventArgs","dataType":"class","baseclass":"Rhino.Render.RenderContentChangedEventArgs","properties":[{"signature":"string FieldName","since":"5.11","property":["get"]}]},{"namespace":"Rhino.Render","name":"RenderContentKind","dataType":"enum","summary":"Defines constant values for all render content kinds, such as material, environment or texture.","since":"5.1","values":[{"signature":"None = UnsafeNativeMethods.CRhRdkContentKindConst.None"},{"signature":"Material = UnsafeNativeMethods.CRhRdkContentKindConst.Material"},{"signature":"Environment = UnsafeNativeMethods.CRhRdkContentKindConst.Environment"},{"signature":"Texture = UnsafeNativeMethods.CRhRdkContentKindConst.Texture"}]},{"namespace":"Rhino.Render","name":"RenderContentKindList","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"RenderContentKindList()","since":"6.7"},{"signature":"RenderContentKindList(IntPtr pRdkRenderContentKindList)","since":"6.1"},{"signature":"RenderContentKindList(RenderContentKindList kind_list)","since":"6.7"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.1","property":["get"]}],"methods":[{"signature":"void Add(RenderContentKind kind)","since":"6.7"},{"signature":"bool Contains(RenderContentKind kind)","since":"6.3"},{"signature":"int Count()","since":"6.1"},{"signature":"void Dispose()","since":"6.1"},{"signature":"RenderContentKind SingleKind()","since":"6.1"}]},{"namespace":"Rhino.Render","name":"RenderContentManager","dataType":"class","summary":"RenderContentManager\'s RestoreRenderContents method unpacks the default render contents from the from the application and places them in the User\'s folder.  Only available on Mac at the moment.","properties":[{"signature":"static string UserRenderContentPath","summary":"Get the path to: Windows: C:\\\\Users\\\\user\\\\AppData\\\\Roaming\\\\McNeel\\\\Rhinoceros\\\\6.0\\\\Localization\\\\en-US\\\\Render Content macOS: ~/Library/Application Support/McNeel/Rhinoceros/6.0/Render Content If a CustomLibraryPath is set, this is returned","since":"6.10","property":["get"]}],"methods":[{"signature":"static bool RestoreRenderContent()","summary":"Unpacks the default render contents from the from the application and places them in the User\'s folder. This will restore the default versions if the version of Rhino that is running is newer than the contents of the last Rhino that wrote the version.txt file.  If the version.txt file is not present, it will automatically restore the default contents.  This does not overwrite files that the user has changed.","since":"6.10"}]},{"namespace":"Rhino.Render","name":"RenderContentSerializer","dataType":"class","summary":"Used to import and export custom render content such as materials, environments and textures.  You must override RenderPlugIn.RenderContentSerializers() and return an array of derived RenderContentSerializer class types to add to the content browsers.","properties":[{"signature":"bool CanRead","summary":"If True then the file type can be imported and will be included in the file open box when importing the specified render content kind.","since":"5.7","property":["get"]},{"signature":"bool CanWrite","summary":"If True then the file type can be exported and will be included in the file save box when exporting the specified render content kind.","since":"5.7","property":["get"]},{"signature":"RenderContentKind ContentKind","summary":"Kind of content created when importing or exporting this file type - ie, Material, Texture or Environment","since":"7.0","property":["get"]},{"signature":"RenderContentKind ContentType","summary":"Kind of content created when importing or exporting this file type.  Obsolete - use ContentKind","since":"5.7","property":["get"]},{"signature":"String EnglishDescription","summary":"English string describing this plug-in","since":"5.7","property":["get"]},{"signature":"string FileExtension","summary":"File extension associated with this serialize object","since":"5.7","property":["get"]},{"signature":"String LocalDescription","summary":"Localized plug-in description","since":"5.7","property":["get"]}],"methods":[{"signature":"bool CanLoadMultiple()","summary":"If True the plug-in is capable of loading multiple contents.","since":"7.0"},{"signature":"bool LoadMultiple(RhinoDoc doc, IEnumerable<string> fileNames, RenderContentKind contentKind, LoadMultipleFlags flags)","summary":"Create any number of new render contents loaded from any number of files.","since":"7.0","parameters":[{"name":"doc","summary":"Rhino document"},{"name":"fileNames","summary":"A list of filenames to load from. Each file can contain any number of render contents."},{"name":"contentKind","summary":"Only used by I/O plug-ins that support multiple kinds. It tells the plug-in which content kind to create. If the plug-in only supports a single content kind, it can ignore this parameter."},{"name":"flags","summary":"A set of flags from the enum above."}]},{"signature":"RenderContent Read(String pathToFile)","summary":"Called to when importing a file, file should be parsed and converted to a valid RenderContent object.","since":"5.7","parameters":[{"name":"pathToFile","summary":"Full path of the file to load."}],"returns":"Returns a valid RenderContent object such as RenderMaterial if the file was successfully parsed otherwise returns null."},{"signature":"bool RegisterSerializer(Guid id)","summary":"Register the RenderContentSerializer","since":"6.0","parameters":[{"name":"id","summary":"Plug-in id"}]},{"signature":"void ReportContentAndFile(RenderContent renderContent, string pathToFile, int flags)","summary":"This is called from your implementation of LoadMultiple() to add a content and the file it was loaded from when the LoadMultipleFlags.Preload flag is NOT set. See LoadMultiple() for an explanation of this method\'s use.","since":"7.0","parameters":[{"name":"renderContent","summary":"Render content that was loaded from the file."},{"name":"pathToFile","summary":"Full path of the file that the render content was loaded from."},{"name":"flags","summary":"Flags for future use; should be passed as zero."}]},{"signature":"void ReportDeferredContentAndFile(RenderContent renderContent, string pathToFile, int flags)","summary":"This is called from your implementation of LoadMultiple() to add a \'deferred\' content and the file it will be loaded from, when the LoadMultipleFlags.Preload flag is set. See LoadMultiple() for an explanation of this method\'s use. \\\\param c is the deferred content. \\\\param wszFullPath is the full path to the file that \'c\' will be loaded from. \\\\param flags is reserved for future use; you should pass zero. \\\\param pReserved is reserved for future use; you should pass nullptr. */","since":"7.0","parameters":[{"name":"renderContent","summary":"Deferred render content - represents all contents that will be loaded from the file."},{"name":"pathToFile","summary":"Full path of the file that render contents will be loaded from."},{"name":"flags","summary":"Flags for future use; should be passed as zero."}]},{"signature":"bool Write(String pathToFile, RenderContent renderContent, CreatePreviewEventArgs previewArgs)","summary":"Called to save a custom RenderContent object as an external file.","since":"5.7","parameters":[{"name":"pathToFile","summary":"Full path of file to write"},{"name":"renderContent","summary":"Render content to save"},{"name":"previewArgs","summary":"Parameters used to generate a preview image which may be embedded in the exported file."}]}]},{"namespace":"Rhino.Render","name":"RenderContentSerializer.LoadMultipleFlags","dataType":"enum","since":"7.0","values":[{"signature":"Normal  = 0x00"},{"signature":"Preload = 0x01"}]},{"namespace":"Rhino.Render","name":"RenderContentStyles","dataType":"enum","since":"5.1","values":[{"signature":"None = 0","summary":"No defined styles"},{"signature":"TextureSummary = 0x0001","summary":"Texture UI includes an auto texture summary section. See AddAutoParameters()."},{"signature":"QuickPreview = 0x0002","summary":"Editor displays an instant preview before preview cycle begins."},{"signature":"PreviewCache = 0x0004","summary":"Content\'s preview imagery can be stored in the preview cache."},{"signature":"ProgressivePreview = 0x0008","summary":"Content\'s preview imagery can be rendered progressively."},{"signature":"LocalTextureMapping = 0x0010","summary":"Texture UI includes an auto local mapping section for textures. See AddAutoParameters()"},{"signature":"GraphDisplay = 0x0020","summary":"Texture UI includes a graph section."},{"signature":"    SharedUI = 0x0040","summary":"Content supports UI sharing between contents of the same type id."},{"signature":"Adjustment = 0x0080","summary":"Texture UI includes an adjustment section."},{"signature":"Fields = 0x0100","summary":"Content uses fields to facilitate data storage and undo support. See Fields()"},{"signature":"ModalEditing = 0x0200","summary":"Content supports editing in a modal editor."},{"signature":"DynamicFields = 0x0400","summary":"The content\'s fields are dynamic. Dynamic fields can be created during loading."}]},{"namespace":"Rhino.Render","name":"RenderContentTableEventForwarder.RenderContentTableEventArgs","dataType":"class","baseclass":"EventArgs"},{"namespace":"Rhino.Render","name":"RenderContentType","dataType":"class","summary":"Represents one of the render content types registered with Rhino.","interfaces":["IDisposable"],"constructors":[{"signature":"RenderContentType(Guid typeId)","since":"6.0"}],"properties":[{"signature":"Guid Id","summary":"Returns the type identifier associated with this type.","since":"6.0","property":["get"]},{"signature":"String InternalName","summary":"Returns the internal name identifier associated with this type.","since":"6.0","property":["get"]},{"signature":"Guid PlugInId","since":"6.0","property":["get"]},{"signature":"Guid RenderEngineId","since":"6.0","property":["get"]}],"methods":[{"signature":"static RenderContentType[] GetAllAvailableTypes()","summary":"Gets an array of all available render content types registered with Rhino.","since":"6.0","returns":"An array with all types."},{"signature":"static RenderContent NewContentFromTypeId(Guid typeId)","summary":"Create a new content specified by the Guid.  This function can be used to create temporary content, as it calls ::RhRdkContentFactories().NewContentFromType().","since":"6.0"},{"signature":"static RenderContent NewContentFromTypeId(Guid typeId, RhinoDoc doc)","since":"6.4"},{"signature":"void Dispose()","since":"6.0"},{"signature":"RenderContent NewRenderContent()","summary":"Returns a new instance of the render content of this type.  This content can be added to a persistant list.","since":"6.0","returns":"A new render content instance."}]},{"namespace":"Rhino.Render","name":"RenderEndEventArgs","dataType":"class","summary":"Contains information about why OnRenderEnd was called","baseclass":"EventArgs"},{"namespace":"Rhino.Render","name":"RenderEnvironment","dataType":"class","baseclass":"Rhino.Render.RenderContent","properties":[{"signature":"static RenderEnvironment CurrentEnvironment","since":"5.1","property":["get","set"]},{"signature":"String TextureChildSlotName","since":"6.0","property":["get"]}],"methods":[{"signature":"static RenderEnvironment NewBasicEnvironment(SimulatedEnvironment environment)","summary":"Constructs a new RenderEnvironmentfrom a SimulatedEnvironment.","since":"5.3","parameters":[{"name":"environment","summary":"The environment to create the basic environment from."}],"returns":"A new basic environment."},{"signature":"static RenderEnvironment NewBasicEnvironment(SimulatedEnvironment environment, RhinoDoc doc)","since":"6.4"},{"signature":"SimulatedEnvironment SimulateEnvironment(bool isForDataOnly)","since":"6.0"},{"signature":"void SimulateEnvironment(ref SimulatedEnvironment simulation, bool isForDataOnly)","since":"5.1"}]},{"namespace":"Rhino.Render","name":"RenderEnvironment.Usage","dataType":"enum","since":"6.0","values":[{"signature":"None                      = 0x00"},{"signature":"Background                = 0x01"},{"signature":"ReflectionAndRefraction   = 0x02"},{"signature":"Skylighting               = 0x04"},{"signature":"AnyUsage                  = Background | ReflectionAndRefraction | Skylighting"}]},{"namespace":"Rhino.Render","name":"RenderEnvironmentTable","dataType":"class","interfaces":["IRenderContentTable<RenderEnvironment>","IEnumerable<RenderEnvironment>","Collections.IRhinoTable<RenderEnvironment>"],"properties":[{"signature":"int Count","since":"5.7","property":["get"]}],"methods":[{"signature":"bool Add(RenderEnvironment c)","since":"6.0"},{"signature":"void BeginChange(ChangeContexts changeContext)","since":"7.0"},{"signature":"void EndChange()","since":"7.0"},{"signature":"IEnumerator<RenderEnvironment> GetEnumerator()","since":"5.7"},{"signature":"bool Remove(RenderEnvironment c)","since":"6.0"}]},{"namespace":"Rhino.Render","name":"Rendering.CommandFilters","dataType":"enum","values":[{"signature":"ToolButton = UnsafeNativeMethods.RdkRendering_CommandFilters.ToolButton"},{"signature":"MenuItem = UnsafeNativeMethods.RdkRendering_CommandFilters.MenuItem"},{"signature":"All = UnsafeNativeMethods.RdkRendering_CommandFilters.All"}]},{"namespace":"Rhino.Render","name":"Rendering.SessionState","dataType":"enum","values":[{"signature":"Quiescent = UnsafeNativeMethods.RdkRenderSession_Status.Quiescent"},{"signature":"Initializing = UnsafeNativeMethods.RdkRenderSession_Status.Initializing"},{"signature":"Rendering = UnsafeNativeMethods.RdkRenderSession_Status.Rendering"},{"signature":"Paused = UnsafeNativeMethods.RdkRenderSession_Status.Paused"},{"signature":"Completed = UnsafeNativeMethods.RdkRenderSession_Status.Completed"},{"signature":"Canceled = UnsafeNativeMethods.RdkRenderSession_Status.Canceled"},{"signature":"Aborted = UnsafeNativeMethods.RdkRenderSession_Status.Aborted"},{"signature":"Failed = UnsafeNativeMethods.RdkRenderSession_Status.Failed"},{"signature":"Reusing = UnsafeNativeMethods.RdkRenderSession_Status.Reusing"},{"signature":"Disposed = UnsafeNativeMethods.RdkRenderSession_Status.Disposed"},{"signature":"Deleted = UnsafeNativeMethods.RdkRenderSession_Status.Deleted"},{"signature":"Waiting = UnsafeNativeMethods.RdkRenderSession_Status.Waiting"}]},{"namespace":"Rhino.Render","name":"Rendering.StatusTexts","dataType":"enum","values":[{"signature":"Image = UnsafeNativeMethods.RdkRendering_StatusTexts.Image"},{"signature":"Zoom = UnsafeNativeMethods.RdkRendering_StatusTexts.Zoom"},{"signature":"Channel = UnsafeNativeMethods.RdkRendering_StatusTexts.Channel"}]},{"namespace":"Rhino.Render","name":"RenderingCommand.MenuCategories","dataType":"enum","values":[{"signature":"File = UnsafeNativeMethods.RdkRenderingCommand_MenuCategories.File"},{"signature":"Edit = UnsafeNativeMethods.RdkRenderingCommand_MenuCategories.Edit"},{"signature":"View = UnsafeNativeMethods.RdkRenderingCommand_MenuCategories.View"},{"signature":"Render = UnsafeNativeMethods.RdkRenderingCommand_MenuCategories.Render"},{"signature":"Help = UnsafeNativeMethods.RdkRenderingCommand_MenuCategories.Help"}]},{"namespace":"Rhino.Render","name":"RenderingCommand.States","dataType":"enum","values":[{"signature":"Off = UnsafeNativeMethods.RdkRenderingCommand_States.Off"},{"signature":"On = UnsafeNativeMethods.RdkRenderingCommand_States.On"},{"signature":"Unknown = UnsafeNativeMethods.RdkRenderingCommand_States.Unknown"}]},{"namespace":"Rhino.Render","name":"RenderingHistogram.HistogramFlags","dataType":"enum","values":[{"signature":"UseAlpha = 0x01"},{"signature":"Photometric = 0x02"},{"signature":"Logarithmic = 0x04"}]},{"namespace":"Rhino.Render","name":"RenderingHistogram.HistogramType","dataType":"enum","values":[{"signature":"Original = UnsafeNativeMethods.RdkRendering_Histogram.Original"},{"signature":"Early = UnsafeNativeMethods.RdkRendering_Histogram.Early"},{"signature":"ToneMapping = UnsafeNativeMethods.RdkRendering_Histogram.ToneMapping"},{"signature":"Late = UnsafeNativeMethods.RdkRendering_Histogram.Late"}]},{"namespace":"Rhino.Render","name":"RenderingPostEffectCommand.States","dataType":"enum","values":[{"signature":"Off = UnsafeNativeMethods.RhRdkRenderingPostEffectCommand_States.Off"},{"signature":"On = UnsafeNativeMethods.RhRdkRenderingPostEffectCommand_States.On"},{"signature":"Unknown = UnsafeNativeMethods.RhRdkRenderingPostEffectCommand_States.Unknown"}]},{"namespace":"Rhino.Render","name":"RenderMaterial","dataType":"class","baseclass":"Rhino.Render.RenderContent","properties":[{"signature":"static Guid GemMaterialGuid","since":"6.0","property":["get"]},{"signature":"static Guid GlassMaterialGuid","since":"6.0","property":["get"]},{"signature":"static Guid MetalMaterialGuid","since":"6.0","property":["get"]},{"signature":"static Guid PaintMaterialGuid","since":"6.0","property":["get"]},{"signature":"static Guid PictureMaterialGuid","since":"6.0","property":["get"]},{"signature":"static Guid PlasterMaterialGuid","since":"6.0","property":["get"]},{"signature":"static Guid PlasticMaterialGuid","since":"6.0","property":["get"]},{"signature":"PreviewBackgroundType DefaultPreviewBackgroundType","summary":"Set or get the default scene background for the image that appears in preview panes","since":"5.11","property":["get","set"]},{"signature":"PreviewGeometryType DefaultPreviewGeometryType","summary":"Set or get the default geometry that appears in preview panes","since":"5.11","property":["get","set"]},{"signature":"double DefaultPreviewSize","summary":"The default preview geometry size","since":"5.11","property":["get","set"]},{"signature":"bool SmellsLikeGem","since":"6.0","property":["get"]},{"signature":"bool SmellsLikeGlass","since":"6.0","property":["get"]},{"signature":"bool SmellsLikeMetal","since":"6.0","property":["get"]},{"signature":"bool SmellsLikePaint","since":"6.0","property":["get"]},{"signature":"bool SmellsLikePlaster","since":"6.0","property":["get"]},{"signature":"bool SmellsLikePlastic","since":"6.0","property":["get"]},{"signature":"bool SmellsLikeTexturedGem","since":"6.0","property":["get"]},{"signature":"bool SmellsLikeTexturedGlass","since":"6.0","property":["get"]},{"signature":"bool SmellsLikeTexturedMetal","since":"6.0","property":["get"]},{"signature":"bool SmellsLikeTexturedPaint","since":"6.0","property":["get"]},{"signature":"bool SmellsLikeTexturedPlaster","since":"6.0","property":["get"]},{"signature":"bool SmellsLikeTexturedPlastic","since":"6.0","property":["get"]}],"methods":[{"signature":"static RenderMaterial CreateBasicMaterial(Material material)","summary":"Constructs a new basic material from a Rhino.DocObjects.Material.","since":"5.1","parameters":[{"name":"material","summary":"(optional)The material to create the basic material from."}],"returns":"A new basic material."},{"signature":"static RenderMaterial CreateBasicMaterial(Material material, RhinoDoc doc)","since":"6.4"},{"signature":"static RenderMaterial CreateImportedMaterial(Material material, RhinoDoc doc, bool reference)","since":"7.0"},{"signature":"DocObjects.PhysicallyBasedMaterial ConvertToPhysicallyBased(TextureGeneration tg)","summary":"Returns a material that is the best approximation of the original, but as a physically based material.","since":"7.0","parameters":[{"name":"tg","summary":"Determines whether simulated textures will be generated as files."}]},{"signature":"double GetTextureAmountFromUsage(StandardChildSlots slot)","since":"6.0"},{"signature":"RenderTexture GetTextureFromUsage(StandardChildSlots slot)","since":"6.0"},{"signature":"bool GetTextureOnFromUsage(StandardChildSlots slot)","since":"6.0"},{"signature":"bool HandleTexturedValue(string slotname, TexturedValue<T> tc)","summary":"Handle a textured content field. Values will be read into an instance of TexturedColor","since":"6.12","returns":"True if reading the base value succeeded"},{"signature":"DocObjects.Material SimulatedMaterial(TextureGeneration tg)","since":"7.0"},{"signature":"DocObjects.Material SimulateMaterial(bool isForDataOnly)","summary":"Call this function to receive the simulation for a RenderMaterial used by the display and other rendering engines.","since":"6.0","deprecated":"7.0","parameters":[{"name":"isForDataOnly","summary":"Called when only asking for a hash - don\'t write any textures to the disk - just provide the filenames they will get."}],"returns":"The simulation of the render material"},{"signature":"void SimulateMaterial(ref Material simulation, bool isForDataOnly)","summary":"Override this function to provide a Rhino.DocObjects.Material definition for this material to be used by other rendering engines including the display.","since":"5.1","parameters":[{"name":"simulation","summary":"Set the properties of the input basic material to provide the simulation for this material."},{"name":"isForDataOnly","summary":"Called when only asking for a hash - don\'t write any textures to the disk - just provide the filenames they will get."}]},{"signature":"void SimulateMaterial(ref Material simulation, TextureGeneration tg)","summary":"Override this function to provide a Rhino.DocObjects.Material definition for this material to be used by other rendering engines including the display.","since":"7.0","parameters":[{"name":"simulation","summary":"Set the properties of the input basic material to provide the simulation for this material."},{"name":"tg","summary":"See RenderTexture.TextureGeneration."}]},{"signature":"string TextureChildSlotName(StandardChildSlots slot)","summary":"Override this function to provide information about which texture is used for the standard (ie - defined in ON_Texture) texture channels.","since":"5.1","parameters":[{"name":"slot","summary":"An valid slot."}],"returns":"The texture used for the channel."}]},{"namespace":"Rhino.Render","name":"RenderMaterial.BasicMaterialParameterNames","dataType":"class","summary":"Parameter names for use in GetNamedParameter and SetNamedParameter with basic materials."},{"namespace":"Rhino.Render","name":"RenderMaterial.PreviewBackgroundType","dataType":"enum","summary":"The default scene background for the image that appears in preview panes","since":"5.11","values":[{"signature":"None = UnsafeNativeMethods.RhCmnMaterialPreviewBackground.None"},{"signature":"Checkered = UnsafeNativeMethods.RhCmnMaterialPreviewBackground.Checkered"},{"signature":"Scene = UnsafeNativeMethods.RhCmnMaterialPreviewBackground.Scene"}]},{"namespace":"Rhino.Render","name":"RenderMaterial.PreviewGeometryType","dataType":"enum","summary":"Geometry that appears in preview panes","since":"5.11","values":[{"signature":"Cone = UnsafeNativeMethods.RhRdkPreviewSceneServerGeometry.Cone"},{"signature":"Cube = UnsafeNativeMethods.RhRdkPreviewSceneServerGeometry.Cuboid"},{"signature":"Plane = UnsafeNativeMethods.RhRdkPreviewSceneServerGeometry.Plane"},{"signature":"Pyramid = UnsafeNativeMethods.RhRdkPreviewSceneServerGeometry.Pyramid"},{"signature":"Sphere = UnsafeNativeMethods.RhRdkPreviewSceneServerGeometry.Sphere"},{"signature":"Torus = UnsafeNativeMethods.RhRdkPreviewSceneServerGeometry.Torus"},{"signature":"Scene = UnsafeNativeMethods.RhRdkPreviewSceneServerGeometry.Mesh"}]},{"namespace":"Rhino.Render","name":"RenderMaterial.StandardChildSlots","dataType":"enum","summary":"Defines enumerated constant values for use in TextureChildSlotNamemethod. NOTE WELL - these values cannot be changed. https://mcneel.myjetbrains.com/youtrack/issue/RH-57752","since":"5.1","values":[{"signature":"None = 0","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::None."},{"signature":"Diffuse = 100","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::Diffuse."},{"signature":"Transparency = 101","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::Transparency"},{"signature":"Bump = 102","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::Bump"},{"signature":"Environment = 103","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::Environment"},{"signature":"PbrBaseColor = 100","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_base_color"},{"signature":"PbrSubsurface = 104","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_subsurface"},{"signature":"PbrSubSurfaceScattering = 105","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_subsurface_scattering"},{"signature":"PbrSubsurfaceScatteringRadius = 106","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_subsurface_scattering_radius"},{"signature":"PbrMetallic = 107","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_metallic"},{"signature":"PbrSpecular = 108","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_specular"},{"signature":"PbrSpecularTint = 109","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_specular_tint"},{"signature":"PbrRoughness = 110","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_roughness"},{"signature":"PbrAnisotropic = 111","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_anisotropic"},{"signature":"PbrAnisotropicRotation = 112","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_anisotropic_rotation"},{"signature":"PbrSheen = 113","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_sheen"},{"signature":"PbrSheenTint = 114","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_sheen_tint"},{"signature":"PbrClearcoat = 115","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_clearcoat"},{"signature":"PbrClearcoatRoughness = 116","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_clearcoat_roughness"},{"signature":"PbrOpacityIor = 117","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_opacity_ior"},{"signature":"PbrOpacity = 101","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_opacity"},{"signature":"PbrOpacityRoughness = 118","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_opacity_roughness"},{"signature":"PbrEmission = 119","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_emission"},{"signature":"PbrAmbientOcclusion = 120","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_ambient_occlusion"},{"signature":"PbrDisplacement = 121","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_smudge"},{"signature":"PbrClearcoatBump = 122","summary":"Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_clearcoat_roughness"}]},{"namespace":"Rhino.Render","name":"RenderMaterialTable","dataType":"class","interfaces":["IRenderContentTable<RenderMaterial>","IEnumerable<RenderMaterial>","Collections.IRhinoTable<RenderMaterial>"],"properties":[{"signature":"int Count","since":"5.7","property":["get"]}],"methods":[{"signature":"bool Add(RenderMaterial c)","since":"6.0"},{"signature":"void BeginChange(ChangeContexts changeContext)","since":"7.0"},{"signature":"void EndChange()","since":"7.0"},{"signature":"IEnumerator<RenderMaterial> GetEnumerator()","since":"5.7"},{"signature":"bool Remove(RenderMaterial c)","since":"6.0"}]},{"namespace":"Rhino.Render","name":"RenderPanels","dataType":"class","summary":"This class is used to extend the standard Render user interface","methods":[{"signature":"static object FromRenderSessionId(PlugIn plugIn, Type panelType, Guid renderSessionId)","summary":"Get the instance of a render panel associated with a specific render session, this is useful when it is necessary to update a control from a  RenderPipeline","since":"5.11","parameters":[{"name":"plugIn","summary":"The plug-in that registered the custom user interface"},{"name":"panelType","summary":"The type of panel to return"},{"name":"renderSessionId","summary":"The RenderPipeline.RenderSessionIdof a specific render session."}],"returns":"Returns the custom panel object if found; otherwise None is returned."},{"signature":"void RegisterPanel(PlugIn plugin, RenderPanelType renderPanelType, Type panelType, Guid renderEngineId, string caption, bool alwaysShow, bool initialShow)","summary":"Register custom render user interface with Rhino.  This should only be done in RenderPlugIn.RegisterRenderPanels.  Panels registered after RenderPlugIn.RegisterRenderPanelsis called will be ignored.","since":"7.0","parameters":[{"name":"plugin","summary":"The plug-in providing the custom user interface"},{"name":"renderPanelType","summary":"See RenderPanelTypefor supported user interface types."},{"name":"panelType","summary":"The type of object to be created and added to the render container."},{"name":"renderEngineId","summary":"The render engine id allowing the UI to be shown"},{"name":"caption","summary":"The caption for the custom user interface."},{"name":"alwaysShow","summary":"If True the custom user interface will always be visible, if False then it may be hidden or shown as requested by the user."},{"name":"initialShow","summary":"Initial visibility state of the custom user interface control."}]},{"signature":"void RegisterPanel(PlugIn plugin, RenderPanelType renderPanelType, Type panelType, string caption, bool alwaysShow, bool initialShow)","summary":"Register custom render user interface with Rhino.  This should only be done in RenderPlugIn.RegisterRenderPanels.  Panels registered after RenderPlugIn.RegisterRenderPanelsis called will be ignored.","since":"5.11","deprecated":"7.0","parameters":[{"name":"plugin","summary":"The plug-in providing the custom user interface"},{"name":"renderPanelType","summary":"See RenderPanelTypefor supported user interface types."},{"name":"panelType","summary":"The type of object to be created and added to the render container."},{"name":"caption","summary":"The caption for the custom user interface."},{"name":"alwaysShow","summary":"If True the custom user interface will always be visible, if False then it may be hidden or shown as requested by the user."},{"name":"initialShow","summary":"Initial visibility state of the custom user interface control."}]}]},{"namespace":"Rhino.Render","name":"RenderPanelType","dataType":"enum","summary":"Contains the custom user interfaces that may be provided","since":"5.11","values":[{"signature":"RenderWindow = UnsafeNativeMethods.RhRdkCustomUiType.RenderWindowCustomDlgInterface","summary":"A custom control panel added to the render output window."}]},{"namespace":"Rhino.Render","name":"RenderPipeline","dataType":"class","summary":"Provides facilities to a render plug-in for integrating with the standard Rhino render window. Also adds helper functions for processing a render scene. This is the suggested class to use when integrating a renderer with Rhino and maintaining a \\"standard\\" user interface that users will expect.","interfaces":["IDisposable"],"properties":[{"signature":"int ConfirmationSeconds","summary":"Sets the number of seconds that need to elapse during rendering before the user is asked if the rendered image should be saved.","since":"5.0","property":["set"]},{"signature":"PlugIn PlugIn","since":"5.0","property":["get"]},{"signature":"Guid RenderSessionId","summary":"Get the Id associated with this render session, this is useful when looking up Rhino.Render.RenderPanels.","since":"5.11","property":["get"]}],"methods":[{"signature":"static Size RenderSize()","since":"5.0","deprecated":"6.4"},{"signature":"static Size RenderSize(RhinoDoc doc)","summary":"Get the render size as specified in the ON_3dmRenderSettings. Will automatically return the correct size based on the ActiveView or custom settings.","since":"6.0","returns":"The render size."},{"signature":"static Size RenderSize(RhinoDoc doc, bool fromRenderSources)","summary":"Get the render size as specified in the ON_3dmRenderSettings, and from RenderSources when fromRenderSources is true.","since":"6.0","returns":"The render size."},{"signature":"bool CloseWindow()","summary":"Closes the render window associated with this render instance.","since":"5.11","returns":"Return True if successful or False if not."},{"signature":"Rhino.Commands.Result CommandResult()","since":"5.0"},{"signature":"void Dispose()","since":"5.0"},{"signature":"RenderWindow GetRenderWindow()","summary":"Get the RenderWindow associated with this RenderPipeline instance.  This is virtual rather than abstract for V5 compat","since":"5.0","returns":"RenderWindow if one exists, None otherwise (i.e. rendering has already completed)."},{"signature":"RenderWindow GetRenderWindow(bool withWireframeChannel)","summary":"As GetRenderWindow(), but if withWireframeChannel is true the returned RenderWindow will have the channel added.","since":"6.0","returns":"RenderWindow with wireframe channel enabled, or null if no RenderWindow can be found (i.e. rendering has completed already)"},{"signature":"RenderWindow GetRenderWindow(bool withWireframeChannel, bool fromRenderViewSource)","summary":"As GetRenderWindow(). The parameter withWireframeChannel controls whether the returned RenderWindow will have the channel added. The parameter fromRenderViewSource controls from where the RenderSize is queried.","since":"6.0","parameters":[{"name":"withWireframeChannel","summary":"True if the RenderWindow needs to have a wireframe channel."},{"name":"fromRenderViewSource","summary":"True if the RenderWindow size needs to be set from RenderViewSource size. False will use the active view."}],"returns":"RenderWindow if one exists, None otherwise (i.e. rendering has already completed)."},{"signature":"RenderWindow GetRenderWindowFromRenderViewSource(bool fromRenderViewSource)","summary":"Like GetRenderWindow(), but with the size for RenderWindow set from RenderViewSources if fromRenderViewSource is set to true","since":"6.0","parameters":[{"name":"fromRenderViewSource","summary":"True if"}],"returns":"RenderWindow if one exists, None otherwise (i.e. rendering has already completed)."},{"signature":"void PauseRendering()","summary":"Implement to pause the current render session","since":"6.0"},{"signature":"RenderReturnCode Render()","summary":"Call this function to render the scene normally. The function returns when rendering is complete (or cancelled).","since":"5.0","returns":"A code that explains how rendering completed."},{"signature":"RenderReturnCode RenderWindow(RhinoView view, Rectangle rect, bool inWindow)","summary":"Call this function to render the scene in a view window. The function returns when rendering is complete (or cancelled).","since":"5.0","parameters":[{"name":"view","summary":"the view that the user selected a rectangle in."},{"name":"rect","summary":"rectangle that the user selected."},{"name":"inWindow","summary":"True to render directly into the view window."}],"returns":"A code that explains how rendering completed."},{"signature":"void ResumeRendering()","summary":"Implement to resume current render session","since":"6.0"},{"signature":"bool SaveImage(string fileName, bool saveAlpha)","summary":"Saves the rendered image to a file. Does not prompt the user in any way.","since":"5.14","parameters":[{"name":"fileName","summary":"Full path to the file name to save to."},{"name":"saveAlpha","summary":"Determines if alpha will be saved in files that support it (e.g., PNG)."}]},{"signature":"void SetAsyncRenderContext(ref AsyncRenderContext aRC)","since":"6.0"},{"signature":"bool SupportsPause()","summary":"Override and return True if the renderer supports pausing","since":"6.0","returns":"True if pausing is supported, False otherwise"}]},{"namespace":"Rhino.Render","name":"RenderPipeline.RenderReturnCode","dataType":"enum","since":"5.0","values":[{"signature":"Ok = 0"},{"signature":"EmptyScene"},{"signature":"Cancel"},{"signature":"NoActiveView"},{"signature":"OnPreCreateWindow"},{"signature":"NoFrameWndPointer"},{"signature":"ErrorCreatingWindow"},{"signature":"ErrorStartingRender"},{"signature":"EnterModalLoop"},{"signature":"ExitModalLoop"},{"signature":"ExitRhino"},{"signature":"InternalError"}]},{"namespace":"Rhino.Render","name":"RenderPlugInInfo","dataType":"class","properties":[{"signature":"string Name","since":"6.0","property":["get","set"]},{"signature":"Guid PlugInId","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Render","name":"RenderPlugInList","dataType":"class","baseclass":"List<RenderPlugInInfo>","constructors":[{"signature":"RenderPlugInList()","since":"6.0"}]},{"namespace":"Rhino.Render","name":"RenderPrimitive","dataType":"class","interfaces":["IDisposable"],"properties":[{"signature":"BoundingBox BoundingBox","summary":"The bounding box for this primitive.","since":"5.7","property":["get"]},{"signature":"Transform InstanceTransform","summary":"Instance reference transform or Identity if not an instance reference.","since":"5.7","property":["get"]},{"signature":"RenderPrimitiveType PrimitiveType","summary":"Call this before extracting meshes if you support render primitives to get the RenderPrimitiveTypeof this mesh then call the associated TryGetSphere, TryGetPlane, TryGetCone, or  TryGetBoxmethod.  Calling the Meshproperty will mesh the primitive and return a mesh always.","since":"5.7","property":["get"]},{"signature":"RenderMaterial RenderMaterial","summary":"The RenderMaterialassociated with this mesh or None if there is not one.","since":"5.7","property":["get"]},{"signature":"RhinoObject RhinoObject","summary":"The Rhino object associated with this render primitive.","since":"5.7","property":["get"]}],"methods":[{"signature":"void Dispose()","since":"5.7"},{"signature":"Mesh Mesh()","summary":"Returns the mesh associated with the object, this will mesh primitives and always return a mesh.","since":"5.7"},{"signature":"bool TryGetBox(out Box box)","summary":"Call this method to get a Boxprimitive for this mesh.  If this meshes PrimitiveTypeis not a Rhino.Render.RenderPrimitiveType.Box then the box parameter is set to Box.Empty.","since":"5.7","parameters":[{"name":"box","summary":"Gets set to the box primitive for this object on success or Box.Emptyon error."}],"returns":"Returns True if PrimitiveTypeis Rhino.Render.RenderPrimitiveType.Boxand the box parameter was initialized otherwise returns false."},{"signature":"bool TryGetCone(out Cone cone, out Plane truncation)","summary":"Call this method to get a Coneprimitive for this mesh.  If this meshes PrimitiveTypeis not a Rhino.Render.RenderPrimitiveType.Cone then the cone parameter is set to Cone.Unsetand the truncation parameter is set to Plane.Unset.","since":"5.7","parameters":[{"name":"cone","summary":"Gets set to the cone primitive for this object on success or Cone.Unseton error."},{"name":"truncation","summary":"Gets set to the truncation plane for this object on success or Plane.Unseton error."}],"returns":"Returns True if PrimitiveTypeis Rhino.Render.RenderPrimitiveType.Coneand the cone and truncation parameters were initialized otherwise returns false."},{"signature":"bool TryGetPlane(out PlaneSurface plane)","summary":"Call this method to get a Planeprimitive for this mesh.  If this meshes PrimitiveTypeis not a Rhino.Render.RenderPrimitiveType.Plane then the plane parameter is set to null.","since":"5.7","parameters":[{"name":"plane","summary":"Gets set to the plane primitive for this object on success or None on error."}],"returns":"Returns True if PrimitiveTypeis Rhino.Render.RenderPrimitiveType.Planeand the plane parameter was initialized otherwise returns false."},{"signature":"bool TryGetSphere(out Sphere sphere)","summary":"Call this method to get a sphere primitive for this mesh.  If this meshes PrimitiveTypeis not a Rhino.Render.RenderPrimitiveType.Sphere then the sphere parameter is set to Sphere.Unset.","since":"5.7","parameters":[{"name":"sphere","summary":"Gets set to the primitive sphere for this object on success."}],"returns":"Returns True if PrimitiveTypeis Rhino.Render.RenderPrimitiveType.Sphereand the sphere parameter was initialized otherwise returns false."}]},{"namespace":"Rhino.Render","name":"RenderPrimitiveList","dataType":"class","interfaces":["IDisposable"],"properties":[{"signature":"int Count","summary":"Number of meshes in this list","since":"5.7","property":["get"]},{"signature":"RhinoObject RhinoObject","summary":"The Rhino object associated with this list","since":"5.7","property":["get"]},{"signature":"bool UseObjectsMappingChannels","summary":"Returns True if the texture mapping will be taken from the Rhino object otherwise; the texture mapping will use the texture coordinates on the mesh only.","since":"5.7","property":["get","set"]}],"methods":[{"signature":"void Add(Box box, RenderMaterial material)","summary":"Add primitive box and material.","since":"5.7","parameters":[{"name":"box","summary":"Box to add."},{"name":"material","summary":"Material to add, may be None if not needed."}]},{"signature":"void Add(Cone cone, Plane truncation, RenderMaterial material)","summary":"Add primitive cone and material.","since":"5.7","parameters":[{"name":"cone","summary":"Cone to add."},{"name":"truncation","summary":"The plane used to cut the cone (the non-apex end is kept). Should be equal to cone.plane if not truncated."},{"name":"material","summary":"Material to add, may be None if not needed."}]},{"signature":"void Add(Mesh mesh, RenderMaterial material)","summary":"Add mesh and material.","since":"5.7","parameters":[{"name":"mesh","summary":"Mesh to add."},{"name":"material","summary":"Material to add, may be None if not needed."}]},{"signature":"void Add(Mesh mesh, RenderMaterial material, Transform t)","summary":"Add mesh and material.","since":"6.12","parameters":[{"name":"mesh","summary":"Mesh to add."},{"name":"material","summary":"Transformation of this mesh. Material to add, may be None if not needed."},{"name":"t","summary":"Transformation of this mesh."}]},{"signature":"void Add(PlaneSurface plane, RenderMaterial material)","summary":"Add primitive plane and material.","since":"5.7","parameters":[{"name":"plane","summary":"Plane to add."},{"name":"material","summary":"Material to add, may be None if not needed."}]},{"signature":"void Add(Sphere sphere, RenderMaterial material)","summary":"Add primitive sphere and material.","since":"5.7","parameters":[{"name":"sphere","summary":"Sphere to add."},{"name":"material","summary":"Material to add, may be None if not needed."}]},{"signature":"bool AutoDeleteMaterialsOn()","since":"6.0"},{"signature":"bool AutoDeleteMeshesOn()","since":"6.0"},{"signature":"void Clear()","summary":"Remove all primitives from this list","since":"5.7"},{"signature":"void ConvertMeshesToTriangles()","summary":"Convert mesh quad faces to triangle faces.","since":"5.7"},{"signature":"void Dispose()","since":"5.7"},{"signature":"Transform GetInstanceTransform(int index)","since":"6.0"},{"signature":"RenderMaterial Material(int index)","summary":"Call this method to get the render material associated with the mesh at the specified index.  Will return None if there is no material associated with the requested mesh.","since":"5.7","parameters":[{"name":"index","summary":"The zero based index of the item in the list.  Valid values are greater than or equal to 0 and less than Count."}],"returns":"If there is a render material associated at the requested index then the material is returned otherwise None is returned."},{"signature":"Mesh Mesh(int index)","summary":"Get the mesh for the primitive at the specified index. If the item at this index is a primitive type other than a mesh then it mesh representation is returned.","since":"5.7","parameters":[{"name":"index","summary":"The zero based index of the item in the list.  Valid values are greater than or equal to 0 and less than Count."}],"returns":"Returns the mesh for the primitive at the specified index. If the item at this index is a primitive type other than a mesh then it mesh representation is returned."},{"signature":"Mesh MeshInstance(int index, out Transform instance_transform)","summary":"Get the mesh for the primitive at the specified index. If the item at this index is a primitive type other than a mesh then it mesh representation is returned.","since":"6.12","parameters":[{"name":"index","summary":"The zero based index of the item in the list.  Valid values are greater than or equal to 0 and less than Count."},{"name":"instance_transform","summary":"Receives the transformation of this mesh."}],"returns":"Returns the mesh for the primitive at the specified index. If the item at this index is a primitive type other than a mesh then it mesh representation is returned."},{"signature":"RenderPrimitiveType PrimitiveType(int index)","summary":"Type of primitive object at this index.","since":"5.7","parameters":[{"name":"index","summary":"The zero based index of the item in the list.  Valid values are greater than or equal to 0 and less than Count."}],"returns":"Primitive type of the item at this index."},{"signature":"void SetInstanceTransform(int index, Transform xform)","since":"6.0"},{"signature":"RenderMaterial[] ToMaterialArray()","summary":"Call this method to see if there are any RenderMaterials associated with the meshes.  Each primitive can optionally have a RenderMaterial associated with it, if the RenderMaterial is None then check for a RhinoObject.RenderMaterial.","since":"5.7","returns":"Return an array that of the same size as the ToMeshArray() containing the RenderMaterial associated with the mesh, may contain None entries if there is no RenderMaterial associated with the custom mesh."},{"signature":"Mesh[] ToMeshArray()","summary":"Call this method to get a array of meshes, all primitives will get meshed and the meshes will get included in the returned array.","since":"5.7","returns":"Return an array of meshes from this list, this will convert all primitives to meshes."},{"signature":"bool TryGetBox(int index, out Box box)","summary":"Call this method to get a box at the specified index.","since":"5.7","parameters":[{"name":"index","summary":"The zero based index of the item in the list.  Valid values are greater than or equal to 0 and less than Count."},{"name":"box","summary":"Will contain the box at the requested index if the index is in range and the primitive at the requested index is a box."}],"returns":"Return True if the index is in range and the primitive at the requested index is a box otherwise returns false."},{"signature":"bool TryGetCone(int index, out Cone cone, out Plane truncation)","summary":"Call this method to get a box at the specified index.","since":"5.7","parameters":[{"name":"index","summary":"The zero based index of the item in the list.  Valid values are greater than or equal to 0 and less than Count."},{"name":"cone","summary":"Will contain the cone at the requested index if the index is in range and the primitive at the requested index is a box."},{"name":"truncation","summary":""}],"returns":"Return True if the index is in range and the primitive at the requested index is a box otherwise returns false."},{"signature":"bool TryGetPlane(int index, out PlaneSurface plane)","summary":"Call this method to get a box at the specified index.","since":"5.7","parameters":[{"name":"index","summary":"The zero based index of the item in the list.  Valid values are greater than or equal to 0 and less than Count."},{"name":"plane","summary":"Will contain the plane at the requested index if the index is in range and the primitive at the requested index is a plane."}],"returns":"Return True if the index is in range and the primitive at the requested index is a plane otherwise returns false."},{"signature":"bool TryGetSphere(int index, out Sphere sphere)","summary":"Call this method to get a box at the specified index.","since":"5.7","parameters":[{"name":"index","summary":"The zero based index of the item in the list.  Valid values are greater than or equal to 0 and less than Count."},{"name":"sphere","summary":"Will contain the sphere at the requested index if the index is in range and the primitive at the requested index is a box."}],"returns":"Return True if the index is in range and the primitive at the requested index is a box otherwise returns false."}]},{"namespace":"Rhino.Render","name":"RenderPrimitiveType","dataType":"enum","since":"5.7","values":[{"signature":"None = 0"},{"signature":"Mesh = 1"},{"signature":"Sphere = 2"},{"signature":"Plane = 3"},{"signature":"Box = 4"},{"signature":"Cone = 5"}]},{"namespace":"Rhino.Render","name":"RenderPropertyChangedEvent","dataType":"class","summary":"Used by Rhino.Render object property value has changed events.","baseclass":"EventArgs","properties":[{"signature":"int Context","summary":"Optional argument which may specify the property being modified.","since":"5.10","property":["get"]},{"signature":"RhinoDoc Document","summary":"The document triggering the event.","since":"5.10","property":["get"]}]},{"namespace":"Rhino.Render","name":"RenderSettings","dataType":"class","summary":"Contains settings used in rendering.","baseclass":"Rhino.Runtime.CommonObject","constructors":[{"signature":"RenderSettings()","summary":"Initialize a new instance of the RenderSettings class.","since":"5.0"},{"signature":"RenderSettings(RenderSettings source)","summary":"Initialize new instance of the RenderSettings class.","since":"6.0","parameters":[{"name":"source","summary":"If not null, settings are copied from source"}]}],"properties":[{"signature":"Color AmbientLight","summary":"Gets or sets the ambient light color used in rendering.","since":"5.0","property":["get","set"]},{"signature":"AntialiasLevel AntialiasLevel","summary":"Gets or sets anti-alias level, used for render quality","since":"5.0","property":["get","set"]},{"signature":"Color BackgroundColorBottom","summary":"Gets or sets the background bottom color used in rendering.","since":"5.0","property":["get","set"]},{"signature":"Color BackgroundColorTop","summary":"Gets or sets the background top color used in rendering.  \\nSets also the background color if a solid background color is set.","since":"5.0","property":["get","set"]},{"signature":"BackgroundStyle BackgroundStyle","summary":"How the viewport\'s background should be filled.","since":"5.0","property":["get","set"]},{"signature":"bool DepthCue","summary":"Gets or sets a value indicating whether to render using depth cues.  \\nThese are clues to help the perception of position and orientation of objects in the image.","since":"5.0","property":["get","set"]},{"signature":"Dithering Dithering","summary":"Get the document dithering interface","since":"6.0","property":["get"]},{"signature":"bool FlatShade","summary":"Gets or sets a value indicating whether to render using flat shading.","since":"5.0","property":["get","set"]},{"signature":"double ImageDpi","summary":"Number of dots/inch (dots=pixels) to use when printing and saving bitmaps. The default is 72.0 dots/inch.","since":"5.11","property":["get","set"]},{"signature":"Size ImageSize","summary":"Gets or sets a value indicating the size of the rendering result if UseViewportSize is set to false.  If UseViewportSize is set to true, then this value is ignored.","since":"5.0","property":["get","set"]},{"signature":"UnitSystem ImageUnitSystem","summary":"unit system to use when converting image pixel size and DPI information into a print size.  Default = inches","since":"5.11","property":["get","set"]},{"signature":"LinearWorkflow LinearWorkflow","summary":"Get the document linear workflow interface","since":"6.0","property":["get"]},{"signature":"string NamedView","summary":"Get or set the given named view","since":"6.1","property":["get","set"]},{"signature":"bool RenderAnnotations","summary":"Gets or sets a value indicating whether to instruct the rendering engine to show annotations, such as linear dimensions or angular dimensions.","since":"5.0","property":["get","set"]},{"signature":"bool RenderBackfaces","summary":"Gets or sets a value indicating whether to render back faces.","since":"5.0","property":["get","set"]},{"signature":"RenderChannels RenderChannels","summary":"Get the document render channels interface","since":"7.0","property":["get"]},{"signature":"bool RenderCurves","summary":"Gets or sets a value indicating whether to instruct the rendering engine to show curves.","since":"5.0","property":["get","set"]},{"signature":"bool RenderIsoparams","summary":"Gets or sets a value indicating whether to instruct the rendering engine to show isocurves.","since":"5.0","property":["get","set"]},{"signature":"bool RenderMeshEdges","summary":"Gets or sets a value indicating whether to instruct the rendering engine to show mesh edges.","since":"5.0","property":["get","set"]},{"signature":"bool RenderPoints","summary":"Gets or sets a value indicating whether to instruct the rendering engine to show points.","since":"5.0","property":["get","set"]},{"signature":"RenderingSources RenderSource","summary":"Gets or sets the render source RenderingSourcesenumeration.","since":"6.1","property":["get","set"]},{"signature":"bool ScaleBackgroundToFit","summary":"Gets or sets a value indicating whether to scale the wallpaper in the background or not. This is meaningful only if the viewport has a wallpaper and render settings are set to render Wallpaper into the background.","since":"6.0","property":["get","set"]},{"signature":"int ShadowmapLevel","summary":"0=none, 1=normal, 2=best.","since":"5.0","property":["get","set"]},{"signature":"string Snapshot","summary":"Set or get the given snapshot view","since":"6.1","property":["get","set"]},{"signature":"string SpecificViewport","summary":"Set or get the given specific viewport","since":"6.1","property":["get","set"]},{"signature":"bool TransparentBackground","summary":"Gets or sets whether rendering should be done with transparent background.","since":"6.0","property":["get","set"]},{"signature":"bool UseHiddenLights","summary":"Gets or sets a value indicating whether to render using lights that are on layers that are off.","since":"5.0","property":["get","set"]},{"signature":"bool UseViewportSize","summary":"Gets or sets a value indicating whether to use the resolution of the viewport being rendered or ImageSize when rendering","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.Render","name":"RenderSettings.RenderingSources","dataType":"enum","summary":"Rendering source (render directly from a NamedView or Snapshot)","since":"6.1","values":[{"signature":"ActiveViewport","summary":"Get the rendering view from the currently active viewport (as in all previous versions of Rhino)"},{"signature":"SpecificViewport","summary":"Get the rendering view from the named viewport (see NamedViewport below)"},{"signature":"NamedView","summary":"Get the rendering view from a specific named view (see NamedView below)"},{"signature":"SnapShot","summary":"Before rendering, restore the Snapshot specified in Snapshot below, then render."}]},{"namespace":"Rhino.Render","name":"RenderSourceView","dataType":"class","summary":"Helper class to get the correct view from the Render View Source settings.  An instance of this class is supposed to be used with the using() {} construct.","interfaces":["IDisposable"],"constructors":[{"signature":"RenderSourceView(RhinoDoc doc)","summary":"Create a new RenderSourceView for the given doc.  Note that this should be done with using(var rsv = new RenderSourceView(doc)) {}  If the RenderSettings have the source view set to for instance a SnapShot this construct will ensure that the (active) view is set to the correct snapshot, and reverted back to the original once this instance goes out of scope.","since":"6.0","parameters":[{"name":"doc","summary":"Rhino document"}]}],"methods":[{"signature":"void Dispose()","since":"6.0"},{"signature":"Rhino.DocObjects.ViewInfo GetViewInfo()","summary":"Get the ViewInfo as specified by the render source view settings.","since":"6.0","returns":"ViewInfo if view was found, None otherwise"}]},{"namespace":"Rhino.Render","name":"RenderTabs","dataType":"class","methods":[{"signature":"static object FromRenderSessionId(PlugIn plugIn, Type tabType, Guid renderSessionId)","summary":"Get the instance of a render tab associated with a specific render session, this is useful when it is necessary to update a control from a  RenderPipeline","since":"5.11","parameters":[{"name":"plugIn","summary":"The plug-in that registered the custom user interface"},{"name":"tabType","summary":"The type of tab to return"},{"name":"renderSessionId","summary":"The RenderPipeline.RenderSessionIdof a specific render session."}],"returns":"Returns the custom tab object if found; otherwise None is returned."},{"signature":"static Guid SessionIdFromTab(object tab)","summary":"Get the session Id that created the specified tab object.","since":"5.11"},{"signature":"void RegisterTab(PlugIn plugin, Type tabType, Guid renderEngineId, string caption, Icon icon)","since":"7.0"},{"signature":"void RegisterTab(PlugIn plugin, Type tabType, string caption, Icon icon)","summary":"Register custom render user interface with Rhino.  This should only be done in RenderPlugIn.RegisterRenderTabs.  Panels registered after RenderPlugIn.RegisterRenderTabsis called will be ignored.  If the class includes a public method \\"void DoHelp()\\" the method will get called when F1 is pressed and the custom tab is active.","since":"5.11","deprecated":"7.0","parameters":[{"name":"plugin","summary":"The plug-in providing the custom user interface"},{"name":"tabType","summary":"The type of object to be created and added to the render container."},{"name":"caption","summary":"The caption for the custom user interface."},{"name":"icon","summary":""}]}]},{"namespace":"Rhino.Render","name":"RenderTexture","dataType":"class","baseclass":"Rhino.Render.RenderContent","properties":[{"signature":"Transform LocalMappingTransform","summary":"Gets the transformation that can be applied to the UVW vector to convert it from normalized texture space into locally mapped space (ie - with repeat, offset and rotation applied.)","since":"5.1","property":["get"]},{"signature":"uint RenderHashWithoutLocalMapping","summary":"Render hash for texture excluding local mapping.","since":"6.0","property":["get"]}],"methods":[{"signature":"static bool GetEnvironmentMappingProjection(TextureEnvironmentMappingMode mode, Vector3d reflectionVector, out float u, out float v)","since":"5.7"},{"signature":"static Point3d GetWcsBoxMapping(Point3d worldXyz, Vector3d normal)","since":"5.7"},{"signature":"static RenderTexture NewBitmapTexture(Bitmap bitmap, RhinoDoc doc)","summary":"Constructs a new basic texture from a Bitmap.","since":"7.0","parameters":[{"name":"bitmap","summary":"The bitmap to create the basic texture from."},{"name":"doc","summary":"The document to associate the texture with."}],"returns":"A new render texture."},{"signature":"static RenderTexture NewBitmapTexture(SimulatedTexture texture)","summary":"Constructs a new basic texture from a SimulatedTexture.","since":"5.3","deprecated":"6.4","parameters":[{"name":"texture","summary":"The texture to create the basic texture from."}],"returns":"A new render texture."},{"signature":"static RenderTexture NewBitmapTexture(SimulatedTexture texture, RhinoDoc doc)","summary":"Constructs a new basic texture from a SimulatedTexture.","since":"6.4","parameters":[{"name":"texture","summary":"The texture to create the basic texture from."},{"name":"doc","summary":"The document to associate the texture with."}],"returns":"A new render texture."},{"signature":"TextureEvaluator CreateEvaluator()","summary":"Constructs a texture evaluator. This is an independent lightweight object capable of evaluating texture color throughout uvw space. May be called from within a rendering shade pipeline.","since":"5.1","deprecated":"6.0","returns":"A texture evaluator instance."},{"signature":"TextureEvaluator CreateEvaluator(TextureEvaluatorFlags evaluatorFlags)","summary":"Constructs a texture evaluator. This is an independent lightweight object capable of evaluating texture color throughout uvw space. May be called from within a rendering shade pipeline.","since":"6.0","returns":"A texture evaluator instance."},{"signature":"bool GetDisplayInViewport()","since":"5.7"},{"signature":"TextureEnvironmentMappingMode GetEnvironmentMappingMode()","since":"5.7"},{"signature":"TextureEnvironmentMappingMode GetInternalEnvironmentMappingMode()","since":"5.7"},{"signature":"eLocalMappingType GetLocalMappingType()","since":"6.3"},{"signature":"int GetMappingChannel()","since":"5.7"},{"signature":"Vector3d GetOffset()","summary":"Get offset value across UVW space. If the projection type is WCS or other type specified in model units, then this is the offset in meters.","since":"5.7"},{"signature":"bool GetOffsetLocked()","since":"5.7"},{"signature":"bool GetPreviewIn3D()","since":"5.7"},{"signature":"bool GetPreviewLocalMapping()","since":"5.7"},{"signature":"TextureProjectionMode GetProjectionMode()","since":"5.7"},{"signature":"Vector3d GetRepeat()","summary":"Get repeat value across UVW space. If the projection type is WCS or other type specified in model units, then this is the repeat across 1 meter of the model.","since":"5.7"},{"signature":"bool GetRepeatLocked()","since":"5.7"},{"signature":"Vector3d GetRotation()","since":"5.7"},{"signature":"TextureWrapType GetWrapType()","since":"5.7"},{"signature":"void GraphInfo(ref TextureGraphInfo tgi)","since":"6.3"},{"signature":"bool IsHdrCapable()","summary":"Return True if the texture is HDR capable.  When creating a custom RenderTexture implementation that is HDR capable set the appropriate property on the CustomRenderContentAttribute decorator on that clas.","since":"5.7"},{"signature":"bool IsImageBased()","summary":"Query if the texture is image based.  When creating a custom RenderTexture implementation of an image-based texture set the appropriate property on the CustomRenderContentAttribute decorator on that class.  Do not override this function","since":"6.0","returns":"True if the texture is image-based."},{"signature":"bool IsLinear()","summary":"Return True if the texture color data is linear.  NOTE: this function is marked as virtual, but the correct way to make a custom RenderTexture linear is by setting the correct property for the CustomRenderContentAttribute decorator on the class.","since":"6.0"},{"signature":"bool IsNormalMap()","summary":"Return True if the texture is a normalmap.  When creating a custom RenderTexture implementation of a normal map set the appropriate property on the CustomRenderContentAttribute decorator on that clas.","since":"6.16"},{"signature":"void PixelSize(out int u, out int v, out int w)","summary":"Get the texture dimensions for the RenderTexture.","since":"6.0","parameters":[{"name":"u","summary":"width"},{"name":"v","summary":"height"},{"name":"w","summary":"depth, used for 3D textures"}]},{"signature":"bool SaveAsImage(string FullPath, int width, int height, int depth)","summary":"Save texture as image","since":"6.15","parameters":[{"name":"FullPath","summary":"The full path of the file"},{"name":"width","summary":"Image width"},{"name":"height","summary":"Image height"},{"name":"depth","summary":"Image depth"}],"returns":"returns True if file was saved, otherwise false"},{"signature":"void SetDisplayInViewport(bool value)","since":"6.0"},{"signature":"void SetDisplayInViewport(bool value, ChangeContexts changeContext)","since":"5.7"},{"signature":"void SetEnvironmentMappingMode(TextureEnvironmentMappingMode value)","since":"6.0"},{"signature":"void SetEnvironmentMappingMode(TextureEnvironmentMappingMode value, ChangeContexts changeContext)","since":"5.7"},{"signature":"void SetGraphInfo(TextureGraphInfo tgi)","since":"6.3"},{"signature":"void SetMappingChannel(int value, ChangeContexts changeContext)","since":"5.7"},{"signature":"void SetOffset(Vector3d value, ChangeContexts changeContext)","summary":"Set offset value across UVW space. If the projection type is WCS or other type specified in model units, then this is the offset in meters.","since":"5.7"},{"signature":"void SetOffsetLocked(bool value, ChangeContexts changeContext)","since":"5.7"},{"signature":"void SetPreviewIn3D(bool value, ChangeContexts changeContext)","since":"5.7"},{"signature":"void SetPreviewLocalMapping(bool value)","since":"6.0"},{"signature":"void SetPreviewLocalMapping(bool value, ChangeContexts changeContext)","since":"5.7"},{"signature":"void SetProjectionMode(TextureProjectionMode value, ChangeContexts changeContext)","since":"5.7"},{"signature":"void SetRepeat(Vector3d value, ChangeContexts changeContext)","summary":"Set repeat value across UVW space. If the projection type is WCS or other type specified in model units, then this is the repeat across 1 meter of the model.","since":"5.7"},{"signature":"void SetRepeatLocked(bool value, ChangeContexts changeContext)","since":"5.7"},{"signature":"void SetRotation(Vector3d value, ChangeContexts changeContext)","since":"5.7"},{"signature":"void SetWrapType(TextureWrapType value, ChangeContexts changeContext)","since":"5.7"},{"signature":"SimulatedTexture SimulatedTexture(TextureGeneration tg, int size, RhinoObject obj)","since":"6.0"},{"signature":"void SimulateTexture(ref SimulatedTexture simulation, bool isForDataOnly)","since":"5.1","deprecated":"6.0"},{"signature":"void SimulateTexture(ref SimulatedTexture simulation, TextureGeneration tg, int size, RhinoObject obj)","since":"6.0"}]},{"namespace":"Rhino.Render","name":"RenderTexture.eLocalMappingType","dataType":"enum","since":"6.3","values":[{"signature":"lmt_none"},{"signature":"lmt_2D"},{"signature":"lmt_3D"},{"signature":"lmt_force32bit = 0xFFFFFFFF"}]},{"namespace":"Rhino.Render","name":"RenderTexture.TextureEvaluatorFlags","dataType":"enum","since":"6.0","values":[{"signature":"Normal                  = 0x0000"},{"signature":"DisableFiltering        = 0x0001"},{"signature":"DisableLocalMapping     = 0x0002"},{"signature":"DisableAdjustment       = 0x0004"},{"signature":"DisableProjectionChange = 0x0008"}]},{"namespace":"Rhino.Render","name":"RenderTexture.TextureGeneration","dataType":"enum","since":"6.0","values":[{"signature":"Allow = UnsafeNativeMethods.CRhRdkTextureGenConsts.Allow"},{"signature":"Disallow = UnsafeNativeMethods.CRhRdkTextureGenConsts.Disallow"},{"signature":"Skip = UnsafeNativeMethods.CRhRdkTextureGenConsts.Skip"}]},{"namespace":"Rhino.Render","name":"RenderTextureTable","dataType":"class","interfaces":["IRenderContentTable<RenderTexture>","IEnumerable<RenderTexture>","Collections.IRhinoTable<RenderTexture>"],"properties":[{"signature":"int Count","since":"5.7","property":["get"]}],"methods":[{"signature":"bool Add(RenderTexture c)","since":"6.0"},{"signature":"void BeginChange(ChangeContexts changeContext)","since":"7.0"},{"signature":"void EndChange()","since":"7.0"},{"signature":"IEnumerator<RenderTexture> GetEnumerator()","since":"5.7"},{"signature":"bool Remove(RenderTexture c)","since":"6.0"}]},{"namespace":"Rhino.Render","name":"RenderWindow","dataType":"class","interfaces":["IDisposable"],"properties":[{"signature":"Guid SessionId","since":"5.11","property":["get"]}],"methods":[{"signature":"static Guid ChannelId(StandardChannels ch)","since":"5.0"},{"signature":"static RenderWindow Create(Size szSize)","since":"6.0"},{"signature":"static RenderWindow FromSessionId(Guid sessionId)","since":"5.11"},{"signature":"static StandardChannels StandardChannelForGuid(Guid id)","summary":"Get the StandardChannels for the given Guid","since":"7.0"},{"signature":"bool AddChannel(StandardChannels channel)","summary":"Add a channel to the frame buffer in addition to the fixed Red, Green, Blue and Alpha channels.","since":"5.0","parameters":[{"name":"channel","summary":"Channel to add"}],"returns":"If the channel existed then True is returned otherwise; returns True if the channel was added or False if not."},{"signature":"bool AddWireframeChannel(RhinoDoc doc, ViewportInfo viewport, Size size, Rectangle region)","summary":"This method sets the frame buffer size and adds all the necessary wireframe channels automatically. It also creates the wireframe channel data automatically so that your renderer doesn\'t have to. You typically call this method only when your renderer does not support wireframe rendering itself. If you call this method, then you should not add any wireframe channels returned by GetRenderChannels(). If your renderer is capable of rendering the wireframe channels itself, you should not call this method. Instead, you must make sure you add the wireframe channels if GetRenderChannels() requests them. See IRhRdkRenderWindow::GetRenderChannels(). After the wires are rendered, the wireframe post effects will composite them into the final rendered image. Note: This method should really be called AddWireframeChannels(). [SDK_UNFREEZE] */","since":"5.0","parameters":[{"name":"doc","summary":"The document to display"},{"name":"viewport","summary":"The view to display"},{"name":"size","summary":"The size of the image without clipping (i.e., if you have a region, it is the size of the image before you cut the region out."},{"name":"region","summary":"The area of the rendering you want to display.  This should match the size of the render window itself (i.e, - the one set using SetSize)"}],"returns":"Returns True if all of the wireframe channels were added successfully."},{"signature":"void Dispose()","since":"6.0"},{"signature":"void EndAsyncRender(RenderSuccessCode successCode)","summary":"Must be called when an asynchronous render has finished or ended for any reason.","since":"6.0","parameters":[{"name":"successCode","summary":"Completed for a correct or canceled render, Failed for errors."}]},{"signature":"ImageAdjust GetAdjust()","summary":"Get an ImageAdjust instance containing current image adjusting settings for this RenderWindow","since":"6.0","deprecated":"7.0","returns":"ImageAdjust"},{"signature":"Bitmap GetBitmap()","since":"6.0"},{"signature":"Guid[] GetRequestedRenderChannels()","summary":"Get array of Guids representing the channels requested by the post effect pipeline for this RenderWindow.","since":"7.0","returns":"Array of Guid"},{"signature":"StandardChannels[] GetRequestedRenderChannelsAsStandardChannels()","summary":"Get array of StandardChannels enum values representing the channels requested by the post effect pipeline for this RenderWindow.","since":"7.0","returns":"Array of StandardChannels"},{"signature":"void Invalidate()","summary":"Invalidate the entire view window so that the pixels get painted.","since":"5.0"},{"signature":"void InvalidateArea(Rectangle rect)","since":"5.0"},{"signature":"bool IsChannelAvailable(Guid id)","summary":"Query if a channel is available.","since":"7.0","returns":"Returns True if the channel is available."},{"signature":"bool IsChannelShown(Guid id)","summary":"Query if a channel is being shown.","since":"7.0","returns":"Returns True if the channel is being shown."},{"signature":"Channel OpenChannel(StandardChannels id)","since":"5.0"},{"signature":"void SaveDibAsBitmap(string filename)","summary":"Save current Dib of RenderWindow as file Helper function for debugging purposes.","since":"6.0"},{"signature":"void SaveRenderImageAs(string filename, bool saveAlpha)","summary":"Like RenderWindow.SaveRenderImageAs(string,Guid,bool), but with Guid set to Guid.Empty.","since":"6.0","parameters":[{"name":"filename","summary":"Filename of image file to be created"},{"name":"saveAlpha","summary":"True if alpha channel should be saved."}]},{"signature":"void SaveRenderImageAs(string filename, Guid renderEngineGuid, bool saveAlpha)","summary":"Save current RenderWindow contents as an image file with the given name. The filetype will be determine.  Pass in render engine Guid if an engine implements saving to a format that is not supported by Rhino. Guid.Empty if there is no need for that.","since":"6.0","parameters":[{"name":"filename","summary":"Filename of image file to be created"},{"name":"renderEngineGuid","summary":"render engine ID"},{"name":"saveAlpha","summary":"True if alpha channel should be saved."}]},{"signature":"void SetAdjust(ImageAdjust imageAdjust)","summary":"Set new ImageAdjust to use. An ImageAdjust instance can be obtained by first querying for one using GetAdjust()","since":"6.0","deprecated":"7.0","parameters":[{"name":"imageAdjust","summary":"ImageAdjust"}]},{"signature":"void SetProgress(string text, float progress)","summary":"Accepts a rendering progress value to inform the user of the rendering advances.","since":"5.0","parameters":[{"name":"text","summary":"The progress text."},{"name":"progress","summary":"A progress value in the domain [0.0f; 1.0f]."}]},{"signature":"void SetRGBAChannelColors(Rectangle rectangle, Color4f[] colors)","summary":"Call this method to open the RenderWindow.StandardChannels.RGBA channel and set a block of color values","since":"5.0","parameters":[{"name":"rectangle","summary":"rectangle.X is the horizontal pixel position of the left edge. No validation is done on this value. The caller is responsible for ensuring that it is within the frame buffer. rectangle.Y is the vertical pixel position of the top edge. No validation is done on this value. The caller is responsible for ensuring that it is within the frame buffer. rectangle.Width is the width of the rectangle in pixels. No validation is done on this value. rectangle.Height is the height of the rectangle in pixels. No validation is done on this value."},{"name":"colors","summary":"Array of Color4f values used to set the RenderWindow.StandardChannels.RGBA"}]},{"signature":"void SetRGBAChannelColors(Size size, Color4f[] colors)","summary":"Call this method to open the RenderWindow.StandardChannels.RGBA channel and set a block of color values","since":"5.0","parameters":[{"name":"size","summary":"Size of the area to set. No validation is done on this value"},{"name":"colors","summary":"Array of Color4f values used to set the RenderWindow.StandardChannels.RGBA"}]},{"signature":"void SetSize(Size size)","since":"5.0"},{"signature":"void SetView(ViewInfo view)","since":"6.0"},{"signature":"System.Drawing.Size Size()","since":"5.0"}],"events":[{"signature":"static Cloned","since":"5.11"}]},{"namespace":"Rhino.Render","name":"RenderWindow.Channel","dataType":"class","interfaces":["IDisposable"],"properties":[{"signature":"int Height","summary":"Return the channel height.","since":"7.0","property":["get"]},{"signature":"Guid Id","summary":"Return the channel id.","since":"7.0","property":["get"]},{"signature":"int Width","summary":"Return the channel width.","since":"7.0","property":["get"]}],"methods":[{"signature":"void AddValue(int x, int y, Color4f value)","summary":"Add value to existing values at point x, y. If x or y are out of range, the function will fail and may crash Rhino.","since":"6.0","parameters":[{"name":"x","summary":"The horizontal pixel position. No validation is done on this value. The caller is responsible for ensuring that it is within the frame buffer."},{"name":"y","summary":"The vertical pixel position. No validation is done on this value. The caller is responsible for ensuring that it is within the frame buffer."},{"name":"value","summary":"The color to store in the channel at the specified position."}]},{"signature":"Channel Clone()","summary":"Return a clone of the channel.","since":"7.0"},{"signature":"void Dispose()","since":"5.0"},{"signature":"void GetMinMaxValues(out float min, out float max)","summary":"Get the minimum and maximum values in the channel. The channel\'s minimum value. The channel\'s maximum value.","since":"7.0"},{"signature":"void GetValue(int x, int y, ComponentOrders componentOrder, ref float[] values)","summary":"Get values from the channel.","since":"7.0"},{"signature":"void GetValues(Rectangle rectangle, int stride, ComponentOrders componentOrder, ref float[] values)","summary":"Get a rectangle of values from the channel. The input parameters are checked for validity. If the rectangle is not fully inside the frame buffer, the function will fail.","since":"7.0"},{"signature":"int PixelSize()","summary":"Returns the size of the data in one pixel in the channel. For RDK standard channels, this value is always sizeof(float). For the special chanRGBA collective channel, this value is 4 * sizeof(float).","since":"5.0","returns":"The size of a pixel."},{"signature":"void SetValue(int x, int y, Color4f value)","summary":"If x or y are out of range, the function will fail and may crash Rhino.","since":"5.0","parameters":[{"name":"x","summary":"The horizontal pixel position. No validation is done on this value. The caller is responsible for ensuring that it is within the frame buffer."},{"name":"y","summary":"The vertical pixel position. No validation is done on this value. The caller is responsible for ensuring that it is within the frame buffer."},{"name":"value","summary":"The color to store in the channel at the specified position."}]},{"signature":"void SetValue(int x, int y, float value)","summary":"Assignto a pixel at coordinate (,).","since":"5.0","parameters":[{"name":"x","summary":"The horizontal pixel position. No validation is done on this value. The caller is responsible for ensuring that it is within the frame buffer."},{"name":"y","summary":"the vertical pixel position. No validation is done on this value. The caller is responsible for ensuring that it is within the frame buffer."},{"name":"value","summary":"The value to store in the channel at the specified position."}]},{"signature":"void SetValues(Rectangle rectangle, Size bufferResolution, PixelBuffer colorBuffer)","summary":"Set a pixel buffer","since":"6.0","parameters":[{"name":"rectangle","summary":""},{"name":"bufferResolution","summary":""},{"name":"colorBuffer","summary":"PixelBuffer to a color buffer of floats in RGBA format."}]}]},{"namespace":"Rhino.Render","name":"RenderWindow.ChannelGPU","dataType":"class","interfaces":["IDisposable"],"properties":[{"signature":"DisplayTechnology DisplayTechnology","summary":"Return the type of API used for this channel\'s texture handle.","since":"7.0","property":["get"]}],"methods":[{"signature":"ChannelGPU Clone()","summary":"Return a clone of the channel.","since":"7.0"},{"signature":"void Close()","summary":"Close the channel.","since":"7.0"},{"signature":"void CopyTo(Channel channel)","summary":"Copy the channel to a \'CPU\' channel.","since":"7.0","parameters":[{"name":"channel","summary":"The channel to copy to."}]},{"signature":"void Dispose()","summary":"Dispose of the channel.","since":"7.0"},{"signature":"int Height()","summary":"Return the channel height.","since":"7.0"},{"signature":"Guid Id()","summary":"Return the channel id.","since":"7.0"},{"signature":"uint PixelSize()","summary":"Return the size of one pixel\'s data in the channel.","since":"7.0"},{"signature":"uint TextureHandle()","summary":"Return the channel\'s texture handle.","since":"7.0"},{"signature":"int Width()","summary":"Return the channel width.","since":"7.0"}]},{"namespace":"Rhino.Render","name":"RenderWindow.ImageAdjust","dataType":"class","summary":"Class to set image adjusting settings to a RenderWindow. This can\'t be directly created. Instead, one should use RenderWindow.GetAdjust() to get an ImageAdjust instance that can be modified, then passed into RenderWindow.SetAdjust() to update image adjusting settings.1","properties":[{"signature":"Methods Dither","summary":"Set the Dithering method to use when adjusting the RenderWindow content.","since":"6.0","property":["get","set"]},{"signature":"float Gamma","summary":"Set the gamma value. The inverse of this will be used to apply gamma correction to the RenderWindow RGBA channel when necessary.","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Render","name":"RenderWindow.RenderSuccessCode","dataType":"enum","since":"6.0","values":[{"signature":"Completed = 0"},{"signature":"Failed"}]},{"namespace":"Rhino.Render","name":"RenderWindow.StandardChannels","dataType":"enum","since":"5.0","values":[{"signature":"None = 0x00000000"},{"signature":"Red = 0x00000001"},{"signature":"Green = 0x00000002"},{"signature":"Blue = 0x00000004"},{"signature":"Alpha = 0x00000008"},{"signature":"RGBA = 0x0000000E"},{"signature":"RGB = 0x0000000F"},{"signature":"DistanceFromCamera = 0x00000010"},{"signature":"NormalX = 0x00000020"},{"signature":"NormalY = 0x00000040"},{"signature":"NormalZ = 0x00000080"},{"signature":"NormalXYZ = 0x000000F0"},{"signature":"LuminanceRed = 0x00000100"},{"signature":"LuminanceGreen = 0x00000200"},{"signature":"LuminanceBlue = 0x00000400"},{"signature":"BackgroundLuminanceRed = 0x00001000"},{"signature":"BackgroundLuminanceGreen = 0x00002000"},{"signature":"BackgroundLuminanceBlue = 0x00004000"},{"signature":"MaterialIds = 0x00010000"},{"signature":"ObjectIds = 0x00020000"},{"signature":"Wireframe = 0x00040000"},{"signature":"AlbedoRed                = 0x00100000"},{"signature":"AlbedoGreen              = 0x00200000"},{"signature":"AlbedoBlue               = 0x00400000"},{"signature":"AlbedoRGB                = 0x00700000"},{"signature":"WireframePointsRGBA      = 0x00800000"},{"signature":"WireframeIsocurvesRGBA   = 0x01000000"},{"signature":"WireframeCurvesRGBA      = 0x02000000"},{"signature":"WireframeAnnotationsRGBA = 0x04000000"}]},{"namespace":"Rhino.Render","name":"RenderWindowClonedEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"RenderWindow NewRenderWindow","since":"5.11","property":["get"]},{"signature":"Guid NewSessionId","since":"5.11","property":["get","set"]},{"signature":"RenderWindow OldRenderWindow","since":"5.11","property":["get"]},{"signature":"Guid OldSessionId","since":"5.11","property":["get","set"]}]},{"namespace":"Rhino.Render","name":"SceneServerData","dataType":"class","summary":"The Scene Server Data used by the PreviewSceneServer","constructors":[{"signature":"SceneServerData(PreviewGeometry geo, PreviewBackground back, PreviewLighting light, SceneServerDataUsage usage)","summary":"Constructor for SceneServerData","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","summary":"The CppPointer of SceneServerData","since":"6.0","property":["get"]}],"methods":[{"signature":"void Dispose()","summary":"Dispose for SceneServerData","since":"6.0"}]},{"namespace":"Rhino.Render","name":"SceneServerDataUsage","dataType":"enum","summary":"SceneServerData Usage (Synchronous or Asynchronous)","since":"6.0","values":[{"signature":"Synchronous"},{"signature":"Asynchronous"}]},{"namespace":"Rhino.Render","name":"SimulatedEnvironment","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"SimulatedEnvironment()","since":"5.1"}],"properties":[{"signature":"Color BackgroundColor","since":"5.1","property":["get","set"]},{"signature":"SimulatedTexture BackgroundImage","since":"5.1","property":["get","set"]},{"signature":"BackgroundProjections BackgroundProjection","since":"5.1","property":["get","set"]}],"methods":[{"signature":"static BackgroundProjections ProjectionFromString(String projection)","since":"5.1"},{"signature":"static string StringFromProjection(BackgroundProjections projection)","since":"5.1"},{"signature":"IntPtr ConstPointer()","since":"5.1"},{"signature":"void Dispose()","since":"5.1"}]},{"namespace":"Rhino.Render","name":"SimulatedEnvironment.BackgroundProjections","dataType":"enum","since":"5.1","values":[{"signature":"Planar = 0"},{"signature":"Spherical = 1"},{"signature":"Emap = 2"},{"signature":"Box = 3"},{"signature":"Automatic = 4"},{"signature":"Lightprobe = 5"},{"signature":"Cubemap = 6"},{"signature":"VerticalCrossCubemap = 7"},{"signature":"HorizontalCrossCubemap = 8"}]},{"namespace":"Rhino.Render","name":"SimulatedTexture","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"SimulatedTexture()","since":"5.1"}],"properties":[{"signature":"static int BitmapSize","since":"5.1","property":["get","set"]},{"signature":"String Filename","since":"5.1","property":["get","set"]},{"signature":"bool Filtered","since":"5.1","property":["get","set"]},{"signature":"bool HasTransparentColor","since":"5.1","property":["get","set"]},{"signature":"Transform LocalMappingTransform","since":"5.1","property":["get"]},{"signature":"int MappingChannel","since":"5.1","property":["get","set"]},{"signature":"Vector2d Offset","since":"5.1","property":["get","set"]},{"signature":"String OriginalFilename","since":"5.1","property":["get"]},{"signature":"ProjectionModes ProjectionMode","since":"5.1","property":["get","set"]},{"signature":"Vector2d Repeat","since":"5.1","property":["get","set"]},{"signature":"bool Repeating","since":"5.1","property":["get","set"]},{"signature":"double Rotation","since":"5.1","property":["get","set"]},{"signature":"Color4f TransparentColor","since":"5.1","property":["get","set"]},{"signature":"double TransparentColorSensitivity","since":"5.1","property":["get","set"]}],"methods":[{"signature":"IntPtr ConstPointer()","since":"5.1"},{"signature":"void Dispose()","since":"5.1"},{"signature":"double MetersToUnits(double units)","since":"5.1","deprecated":"6.0"},{"signature":"double MetersToUnits(RhinoDoc doc, double units)","since":"6.0"},{"signature":"void SetMappingChannelAndProjectionMode(ProjectionModes pm, int mappingChannel, EnvironmentMappingModes emm)","since":"6.0"},{"signature":"Rhino.DocObjects.Texture Texture()","since":"5.1"},{"signature":"double UnitsToMeters(double units)","since":"5.1","deprecated":"6.0"},{"signature":"double UnitsToMeters(RhinoDoc doc, double units)","since":"6.0"}]},{"namespace":"Rhino.Render","name":"SimulatedTexture.EnvironmentMappingModes","dataType":"enum","since":"6.0","values":[{"signature":"Automatic = 0"},{"signature":"Spherical = 1"},{"signature":"Emap = 2"},{"signature":"Box = 3"},{"signature":"Lightprobe = 5"},{"signature":"Cubemap = 6"},{"signature":"VerticalCrossCubemap = 7"},{"signature":"HorizontalCrossCubemap = 8"},{"signature":"Hemispherical = 9"}]},{"namespace":"Rhino.Render","name":"SimulatedTexture.ProjectionModes","dataType":"enum","since":"5.1","values":[{"signature":"MappingChannel = 0"},{"signature":"View = 1"},{"signature":"Wcs = 2"},{"signature":"Emap = 3"},{"signature":"WcsBox = 4"},{"signature":"Screen = 5"}]},{"namespace":"Rhino.Render","name":"Skylight","dataType":"class","baseclass":"Rhino.Render.DocumentOrFreeFloatingBase","constructors":[{"signature":"Skylight()","summary":"Create an utility object not associated with any document","since":"6.0"},{"signature":"Skylight(Skylight src)","summary":"Create an utility object not associated with any document from another object","since":"6.0"}],"properties":[{"signature":"Guid CustomEnvironment","since":"6.0","property":["get","set"]},{"signature":"bool CustomEnvironmentOn","since":"6.0","property":["get","set"]},{"signature":"bool Enabled","since":"6.0","property":["get","set"]},{"signature":"double ShadowIntensity","since":"6.0","property":["get","set"]}],"methods":[{"signature":"void CopyFrom(FreeFloatingBase src)","since":"6.0"}],"events":[{"signature":"static Changed","summary":"This event is raised when a Skylight property value is changed.","since":"6.0"}]},{"namespace":"Rhino.Render","name":"Sun","dataType":"class","summary":"Represents the Sun on a little portion of Earth.","baseclass":"Rhino.Render.DocumentOrFreeFloatingBase","interfaces":["IDisposable"],"constructors":[{"signature":"Sun()","summary":"Create a non-document controlled Sun","since":"5.0"}],"properties":[{"signature":"double Altitude","summary":"Get the altitude for the sun. To set use SetPosition(azimuth, altitude)","since":"5.0","property":["get"]},{"signature":"double Azimuth","summary":"Get the azimuth for the sun. To set use SetPosition(azimuth, altitude)","since":"5.0","property":["get"]},{"signature":"bool DaylightSaving","summary":"Daylight savings time","since":"5.10","property":["get","set"]},{"signature":"int DaylightSavingMinutes","summary":"Daylight saving minutes","since":"6.0","property":["get","set"]},{"signature":"bool Enabled","summary":"Turn the sun on/off in this document.","since":"5.0","property":["get","set"]},{"signature":"double Intensity","summary":"Sun intensity.","since":"7.0","property":["get","set"]},{"signature":"double Latitude","since":"5.0","property":["get"]},{"signature":"Light Light","summary":"Get a Light which represents the sun. If manual control is in effect, no sun calculation is performed; the function uses the values last used in calls to Azimuth, Altitude or Vector. If manual control is not in effect, the observer\'s position, date, time, time zone and daylight saving values are used to calculate the position of the sun.","since":"6.0","property":["get"]},{"signature":"double Longitude","since":"5.0","property":["get"]},{"signature":"bool ManualControl","summary":"Set angles directly or use place/date/time","since":"5.10","property":["get","set"]},{"signature":"double North","summary":"Angle in degrees on world X-Y plane that should be considered north in the model. Angle is measured starting at X-Axis and travels counterclockwise. Y-Axis would be a north angle of 90 degrees.","since":"5.0","property":["get","set"]},{"signature":"bool SkylightOn","summary":"Turn skylight on or off.","since":"5.10","property":["get","set"]},{"signature":"double TimeZone","summary":"Measured in hours += UTC","since":"5.10","property":["get","set"]},{"signature":"Vector3d Vector","since":"5.0","property":["get"]}],"methods":[{"signature":"static double AltitudeFromValues(double latitude, double longitude, double timezoneHours, int daylightMinutes, DateTime when, double hours, bool fast)","since":"6.0"},{"signature":"static System.Drawing.Color ColorFromAltitude(double altitudeDegrees)","summary":"Get sun color based on altitude.","since":"6.0","parameters":[{"name":"altitudeDegrees","summary":"The altitude sun angle in degrees."}],"returns":"Returns color for altitude."},{"signature":"static bool Here(out double latitude, out double longitude)","since":"6.0"},{"signature":"static double JulianDay(double timezoneHours, int daylightMinutes, DateTime when, double hours)","since":"6.0"},{"signature":"static Geometry.Vector3d SunDirection(double latitude, double longitude, DateTime when)","since":"5.0"},{"signature":"static double TwilightZone()","since":"6.0"},{"signature":"void CopyFrom(FreeFloatingBase src)","since":"6.0"},{"signature":"void Dispose()","since":"5.0"},{"signature":"DateTime GetDateTime(DateTimeKind kind)","since":"5.0"},{"signature":"void SetDateTime(DateTime time, DateTimeKind kind)","since":"6.0"},{"signature":"void SetPosition(DateTime when, double latitudeDegrees, double longitudeDegrees)","summary":"Sets position of the sun based on physical location and time.","since":"5.0","parameters":[{"name":"when","summary":"A DateTimeinstance.  \\nIf the date Kind is DateTimeKind.Local, or DateTimeKind.Unspecified, the date is considered local."},{"name":"latitudeDegrees","summary":"The latitude, in degrees, of the location on Earth."},{"name":"longitudeDegrees","summary":"The longitude, in degrees, of the location on Earth."}]},{"signature":"void SetPosition(double azimuthDegrees, double altitudeDegrees)","summary":"Sets position of the Sun based on azimuth and altitude values. Using this function will also set sun to manual.","since":"5.0","parameters":[{"name":"azimuthDegrees","summary":"The azimuth sun angle in degrees."},{"name":"altitudeDegrees","summary":"The altitude sun angle in degrees."}]},{"signature":"void ShowDialog()","summary":"Show the tabbed sun dialog.","since":"5.0","deprecated":"6.0"}],"events":[{"signature":"static Changed","summary":"This event is raised when a Sun property value is changed.","since":"5.10"}]},{"namespace":"Rhino.Render","name":"SupportOptions","dataType":"class","methods":[{"signature":"static bool AlwaysShowSunPreview()","since":"6.0"},{"signature":"static int AutoSaveKeepAmount()","since":"6.0"},{"signature":"static bool AutoSaveRenderings()","since":"6.0"},{"signature":"static bool CheckSupportFilesBeforeRendering()","since":"6.0"},{"signature":"static bool CombineEditors()","since":"6.0"},{"signature":"static string CustomLibraryPath()","since":"6.0"},{"signature":"static string CustomPaths()","since":"6.0"},{"signature":"static int DarkPreviewCheckerColor()","since":"6.0"},{"signature":"static bool EnablePreviewJobLog()","since":"6.0"},{"signature":"static bool HarvestContentParameters()","since":"6.0"},{"signature":"static int LabelFormatLoc()","since":"6.0"},{"signature":"static int LabelFormatUtc()","since":"6.0"},{"signature":"static string LastNavigatedLocation()","since":"6.10"},{"signature":"static RdkInitialLocation LibrariesInitialLocation()","since":"6.0"},{"signature":"static string LibrariesInitialLocationCustomFolder()","since":"6.0"},{"signature":"static int LightPreviewCheckerColor()","since":"6.0"},{"signature":"static int MaxPreviewCacheMB()","since":"6.0"},{"signature":"static int MaxPreviewSeconds()","since":"6.0"},{"signature":"static bool MultithreadedTextureEvaluation()","since":"6.0"},{"signature":"static bool PreferNativeRenderer()","since":"6.0"},{"signature":"static string PreferredUnpackFolder()","since":"6.0"},{"signature":"static bool PreviewCustomRenderMeshes()","since":"6.0"},{"signature":"static void SetAlwaysShowSunPreview(bool b)","since":"6.0"},{"signature":"static void SetAutoSaveKeepAmount(int value)","since":"6.0"},{"signature":"static void SetAutoSaveRenderings(bool b)","since":"6.0"},{"signature":"static void SetCheckSupportFilesBeforeRendering(bool b)","since":"6.0"},{"signature":"static void SetCombineEditors(bool b)","since":"6.0"},{"signature":"static void SetCustomLibraryPath(string path)","since":"6.0"},{"signature":"static void SetCustomPaths(string path)","since":"6.0"},{"signature":"static void SetHarvestContentParameters(bool b)","since":"6.0"},{"signature":"static void SetLabelFormatLoc(int value)","since":"6.0"},{"signature":"static void SetLabelFormatUtc(int value)","since":"6.0"},{"signature":"static void SetLastNavigatedLocation(string folder)","since":"6.10"},{"signature":"static void SetLibrariesInitialLocation(RdkInitialLocation l)","since":"6.0"},{"signature":"static void SetLibrariesInitialLocationCustomFolder(string path)","since":"6.0"},{"signature":"static void SetMultithreadedTextureEvaluation(bool b)","since":"6.0"},{"signature":"static void SetPreferNativeRenderer(bool b)","since":"6.0"},{"signature":"static void SetPreferredUnpackFolder(string path)","since":"6.0"},{"signature":"static void SetPreviewCustomRenderMeshes(bool b)","since":"6.0"},{"signature":"static void SetShowCustom(bool b)","since":"6.0"},{"signature":"static void SetShowDetailsPanel(bool b)","since":"6.0"},{"signature":"static void SetShowDocuments(bool b)","since":"6.0"},{"signature":"static void SetShowRenderContent(bool b)","since":"6.0"},{"signature":"static void SetSupportSharedUIs(bool b)","since":"6.0"},{"signature":"static void SetTextureSize(RdkTextureSize size, bool bSendEvent)","since":"6.0","deprecated":"6.0"},{"signature":"static void SetUseDefaultLibraryPath(bool b)","since":"6.0"},{"signature":"static void SetUsePreviewCache(bool b)","since":"6.0"},{"signature":"static void SetUseQuickInitialPreview(bool b)","since":"6.0"},{"signature":"static bool ShowCustom()","since":"6.0"},{"signature":"static bool ShowDetailsPanel()","since":"6.0"},{"signature":"static bool ShowDocuments()","since":"6.0"},{"signature":"static bool ShowRenderContent()","since":"6.0"},{"signature":"static bool SupportSharedUIs()","since":"6.0"},{"signature":"static bool SupportSharedUIsNoCache()","since":"6.0"},{"signature":"static int TextureSize()","since":"6.0"},{"signature":"static bool UseDefaultLibraryPath()","since":"6.0"},{"signature":"static bool UsePreview()","since":"6.0"},{"signature":"static bool UsePreviewCache()","since":"6.0"},{"signature":"static bool UseQuickInitialPreview()","since":"6.0"},{"signature":"static bool UseRenderedPreview()","since":"6.0"}]},{"namespace":"Rhino.Render","name":"SupportOptions.RdkInitialLocation","dataType":"enum","since":"6.0","values":[{"signature":"RenderContent = UnsafeNativeMethods.RdkInitialLocation.RenderContent"},{"signature":"LastOpenedFolder = UnsafeNativeMethods.RdkInitialLocation.LastOpenedFolder"},{"signature":"CustomFolder = UnsafeNativeMethods.RdkInitialLocation.CustomFolder"}]},{"namespace":"Rhino.Render","name":"SupportOptions.RdkTextureSize","dataType":"enum","since":"6.0","values":[{"signature":"Size1 = UnsafeNativeMethods.RdkTextureSize.Size1"},{"signature":"Size2 = UnsafeNativeMethods.RdkTextureSize.Size2"},{"signature":"Size3 = UnsafeNativeMethods.RdkTextureSize.Size3"},{"signature":"Size4 = UnsafeNativeMethods.RdkTextureSize.Size4"},{"signature":"Size5 = UnsafeNativeMethods.RdkTextureSize.Size5"}]},{"namespace":"Rhino.Render","name":"TexturedColor","dataType":"class","summary":"Color4f specialization of TexturedValue.","baseclass":"TexturedValue<Display.Color4f>","since":"6.12","constructors":[{"signature":"TexturedColor(string name, Color4f value, bool on, float amount)","since":"6.12"}]},{"namespace":"Rhino.Render","name":"TexturedFloat","dataType":"class","summary":"float specialization of TexturedValue.","baseclass":"TexturedValue<float>","since":"6.12","constructors":[{"signature":"TexturedFloat(string name, float value, bool on, float amount)","since":"6.12"}]},{"namespace":"Rhino.Render","name":"TexturedValue<T>","dataType":"class","summary":"Generic class to help holding on to related values. This can be used to get data from textured content fields with the HandleTexturedValuefunction.","since":"6.12","constructors":[{"signature":"TexturedValue<T>(string name, T value, bool on, float amount)"}]},{"namespace":"Rhino.Render","name":"TextureEnvironmentMappingMode","dataType":"enum","since":"5.7","values":[{"signature":"Automatic   = 0"},{"signature":"Spherical   = 1"},{"signature":"EnvironmentMap    = 2"},{"signature":"Box         = 3"},{"signature":"LightProbe = 5"},{"signature":"Cube  = 6"},{"signature":"VerticalCrossCube = 7"},{"signature":"HorizontalCrossCube = 8"},{"signature":"Hemispherical = 9"}]},{"namespace":"Rhino.Render","name":"TextureEvaluator","dataType":"class","summary":"This is the interface to a lightweight object capable of evaluating texture color throughout uvw space.  Derive from this class to create your own texture evaluator to return from a custom RenderTexture.","interfaces":["IDisposable"],"methods":[{"signature":"void Dispose()","summary":"For Dispose pattern","since":"5.1"},{"signature":"Display.Color4f GetColor(Point3d uvw, Vector3d duvwdx, Vector3d duvwdy)","summary":"Get the color of the texture at a particular point in uvw space. May be called from within a rendering shade pipeline. note For ray differentials see Pharr Humphreys, \\"Physically Based Rendering\\", chapter 11.","since":"5.1","parameters":[{"name":"uvw","summary":"is the point for which to evaluate the texture."},{"name":"duvwdx","summary":"duvwdx is a ray differential."},{"name":"duvwdy","summary":"duvwdy is a ray differential."}],"returns":"The texture color at this point in UV space."},{"signature":"bool GetColor(Point3d uvw, Vector3d duvwdx, Vector3d duvwdy, ref Color4f color)","summary":"Optimized version of GetColor for callers.  Much faster in the case of a native (C++) evaluator.","since":"7.0","parameters":[{"name":"uvw","summary":"is the point for which to evaluate the texture."},{"name":"duvwdx","summary":"duvwdx is a ray differential."},{"name":"duvwdy","summary":"duvwdy is a ray differential."},{"name":"color","summary":"The texture color at this point in UV space."}],"returns":"True if the evaluator returned a valid color.  Otherwise false."},{"signature":"bool Initialize()","summary":"Call this function before calling GetColor for the first time. Ideally, this should be on the main thread, but you can also call it on a worker thread as long as you are sure that Initialize() or GetColor() cannot be called at the same time on another thread.","since":"6.0"},{"signature":"SimpleArrayByte WriteToByteArray(int width, int height)","summary":"Fast access to bitmap evaluator - supply size (which you will probably have received from CRhRdkTexture::PixelSize) to see if the data can be extracted direct to a width*height*4 array of unsigned chars.","since":"7.0","parameters":[{"name":"width","summary":"is the point for which to evaluate the texture."},{"name":"height","summary":"duvwdx is a ray differential."}],"returns":"A ByteArray full of the byte values in RGBA order, or None if the function did not succeed"},{"signature":"SimpleArrayFloat WriteToFloatArray(int width, int height)","summary":"Fast access to bitmap evaluator - supply size (which you will probably have received from CRhRdkTexture::PixelSize) to see if the data can be extracted direct to a width*height*4 array of unsigned chars.","since":"7.0","parameters":[{"name":"width","summary":"is the point for which to evaluate the texture."},{"name":"height","summary":"duvwdx is a ray differential."}],"returns":"A FloatArray full of the float values in RGBA order, or None if the function did not succeed."}]},{"namespace":"Rhino.Render","name":"TextureGeneration","dataType":"enum","since":"6.0","values":[{"signature":"Allow = UnsafeNativeMethods.CRhRdkTextureGenConsts.Allow"},{"signature":"Disallow = UnsafeNativeMethods.CRhRdkTextureGenConsts.Disallow"}]},{"namespace":"Rhino.Render","name":"TextureGraphInfo","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"TextureGraphInfo()","since":"6.3"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.3","property":["get"]}],"methods":[{"signature":"Axis ActiveAxis()","since":"6.3"},{"signature":"Channel ActiveChannel()","since":"6.3"},{"signature":"double AmountU()","since":"6.3"},{"signature":"double AmountV()","since":"6.3"},{"signature":"double AmountW()","since":"6.3"},{"signature":"void Dispose()","since":"6.3"},{"signature":"void SetActiveAxis(Axis axis)","since":"6.3"},{"signature":"void SetActiveChannel(Channel channel)","since":"6.3"},{"signature":"void SetAmountU(double d)","since":"6.3"},{"signature":"void SetAmountV(double d)","since":"6.3"},{"signature":"void SetAmountW(double d)","since":"6.3"}]},{"namespace":"Rhino.Render","name":"TextureGraphInfo.Axis","dataType":"enum","since":"6.3","values":[{"signature":"kU = 0"},{"signature":"kV = 1"},{"signature":"kW = 2"}]},{"namespace":"Rhino.Render","name":"TextureGraphInfo.Channel","dataType":"enum","since":"6.3","values":[{"signature":"kRed = 0"},{"signature":"kGrn = 1"},{"signature":"kBlu = 2"},{"signature":"kAlp = 3"},{"signature":"kLum = 4"}]},{"namespace":"Rhino.Render","name":"TextureMapping","dataType":"class","summary":"Represents a texture mapping.","baseclass":"Rhino.DocObjects.ModelComponent","properties":[{"signature":"ModelComponentType ComponentType","summary":"Returns ModelComponentType.TextureMapping.","since":"6.0","property":["get"]},{"signature":"Guid Id","summary":"The unique Id for this texture mapping object.","since":"5.10","property":["get"]},{"signature":"TextureMappingType MappingType","summary":"Texture mapping type associated with this Mapping object.","since":"5.10","property":["get"]},{"signature":"Transform NormalTransform","summary":"For primitive based mappings, these transformations are used to map the world coordinate (x,y,z) point P and  surface normal N before it is projected to the normalized mapping primitive. The surface normal transformation, m_Nxyz, is always calculated from m_Pxyz.  It is a runtime setting that is not saved in 3dm files. If m_type is srfp_mapping, then m_Pxyz and m_Nxyz are ignored.","since":"5.10","property":["get","set"]},{"signature":"Transform PrimativeTransform","summary":"For primitive based mappings, these transformations are used to map the world coordinate (x,y,z) point P and  surface normal N before it is projected to the normalized mapping primitive. The surface normal transformation, m_Nxyz, is always calculated from m_Pxyz.  It is a runtime setting that is not saved in 3dm files. If m_type is srfp_mapping, then m_Pxyz and m_Nxyz are ignored.","since":"5.10","property":["get","set"]},{"signature":"Transform UvwTransform","summary":"Transform applied to mapping coordinate (u,v,w) to convert it into a texture coordinate.","since":"5.10","property":["get","set"]}],"methods":[{"signature":"static TextureMapping CreateBoxMapping(Plane plane, Interval dx, Interval dy, Interval dz, bool capped)","summary":"Create a box projection texture mapping.","since":"5.0","parameters":[{"name":"plane","summary":"The sides of the box the box are parallel to the plane\'s coordinate planes.  The dx, dy, dz intervals determine the location of the sides."},{"name":"dx","summary":"Determines the location of the front and back planes. The vector plane.xaxis is perpendicular to these planes and they pass through plane.PointAt(dx[0],0,0) and plane.PointAt(dx[1],0,0), respectively."},{"name":"dy","summary":"Determines the location of the left and right planes. The vector plane.yaxis is perpendicular to these planes and they pass through plane.PointAt(0,dy[0],0) and plane.PointAt(0,dy[1],0), respectively."},{"name":"dz","summary":"Determines the location of the top and bottom planes. The vector plane.zaxis is perpendicular to these planes and they pass through plane.PointAt(0,0,dz[0]) and plane.PointAt(0,0,dz[1]), respectively."},{"name":"capped","summary":"If true, the box is treated as a finite capped box."}],"returns":"TextureMapping instance if input is valid"},{"signature":"static TextureMapping CreateCustomMeshMapping(Mesh mesh)","summary":"Create custom mesh mapping","since":"6.15","parameters":[{"name":"mesh","summary":"Mesh with texture coordinates"}],"returns":"TextureMapping instance"},{"signature":"static TextureMapping CreateCylinderMapping(Cylinder cylinder, bool capped)","summary":"Create a cylindrical projection texture mapping.","since":"5.0","parameters":[{"name":"cylinder","summary":"cylinder in world space used to define a cylindrical coordinate system. The angular parameter maps (0,2pi) to texture \\"u\\" (0,1), The height parameter maps (height[0],height[1]) to texture \\"v\\" (0,1), and the radial parameter maps (0,r) to texture \\"w\\" (0,1)."},{"name":"capped","summary":"If true, the cylinder is treated as a finite capped cylinder"}],"returns":"TextureMapping instance if input is valid"},{"signature":"static TextureMapping CreatePlaneMapping(Plane plane, Interval dx, Interval dy, Interval dz)","summary":"Create a planar UV projection texture mapping","since":"5.0","parameters":[{"name":"plane","summary":"A plane to use for mapping."},{"name":"dx","summary":"portion of the plane\'s x axis that is mapped to [0,1] (can be a decreasing interval)"},{"name":"dy","summary":"portion of the plane\'s y axis that is mapped to [0,1] (can be a decreasing interval)"},{"name":"dz","summary":"portion of the plane\'s z axis that is mapped to [0,1] (can be a decreasing interval)"}],"returns":"TextureMapping instance if input is valid"},{"signature":"static TextureMapping CreatePlaneMapping(Plane plane, Interval dx, Interval dy, Interval dz, bool capped)","summary":"Create a planar projection texture mapping","since":"6.7","parameters":[{"name":"plane","summary":"A plane to use for mapping."},{"name":"dx","summary":"portion of the plane\'s x axis that is mapped to [0,1] (can be a decreasing interval)"},{"name":"dy","summary":"portion of the plane\'s y axis that is mapped to [0,1] (can be a decreasing interval)"},{"name":"dz","summary":"portion of the plane\'s z axis that is mapped to [0,1] (can be a decreasing interval)"},{"name":"capped","summary":"set to True if planar UVW is meant, False for planar UV"}],"returns":"TextureMapping instance if input is valid"},{"signature":"static TextureMapping CreateSphereMapping(Sphere sphere)","summary":"Create a spherical projection texture mapping.","since":"5.0","parameters":[{"name":"sphere","summary":"sphere in world space used to define a spherical coordinate system. The longitude parameter maps (0,2pi) to texture \\"u\\" (0,1). The latitude parameter maps (-pi/2,+pi/2) to texture \\"v\\" (0,1). The radial parameter maps (0,r) to texture \\"w\\" (0,1)."}],"returns":"TextureMapping instance if input is valid"},{"signature":"int Evaluate(Point3d p, Vector3d n, out Point3d t)","summary":"Evaluate the mapping to get a texture coordinate","since":"6.17","parameters":[{"name":"p","summary":"Vertex location"},{"name":"n","summary":"If the mapping projection is ray_projection, then this is the vertex unit normal.  Otherwise n is ignored."},{"name":"t","summary":"Texture coordinate (u,v,w)"}],"returns":"Nonzero if evaluation is successful.  When the mapping is a box or capped cylinder mapping, the value indicates which side was evaluated. Cylinder mapping: 1 = cylinder wall, 2 = bottom cap, 3 = top cap Box mapping: 1 = front, 2 = right, 3 = back, 4 = left, 5 = bottom, 6 = top"},{"signature":"int Evaluate(Point3d p, Vector3d n, out Point3d t, Transform pXform, Transform nXform)","summary":"Evaluate the mapping to get a texture coordinate","since":"6.17","parameters":[{"name":"p","summary":"Vertex location"},{"name":"n","summary":"If the mapping projection is ray_projection, then this is the vertex unit normal.  Otherwise n is ignored."},{"name":"t","summary":"Texture coordinate (u,v,w)"},{"name":"pXform","summary":"Transformation to be applied to P before performing the mapping calculation."},{"name":"nXform","summary":"Transformation to be applied to N before performing the mapping calculation. One way to calculate nXxform is to use the call pXform::GetVectorTransform(nXform)."}],"returns":"Nonzero if evaluation is successful.  When the mapping is a box or capped cylinder mapping, the value indicates which side was evaluated. Cylinder mapping: 1 = cylinder wall, 2 = bottom cap, 3 = top cap Box mapping: 1 = front, 2 = right, 3 = back, 4 = left, 5 = bottom, 6 = top"},{"signature":"bool TryGetMappingBox(out Plane plane, out Interval dx, out Interval dy, out Interval dz)","summary":"Get a box projection from the texture mapping.","since":"5.10","parameters":[{"name":"plane","summary":"The center of the box is at plane.origin and the sides of the box are parallel to the plane\'s coordinate planes."},{"name":"dx","summary":"The \\"front\\" and \\"back\\" sides of the box are in spanned by the vectors plane.yaxis and plane.zaxis.  The back plane contains the point plane.PointAt(dx[0],0,0) and the front plane contains the point plane.PointAt(dx[1],0,0)."},{"name":"dy","summary":"The \\"left\\" and \\"right\\" sides of the box are in spanned by the vectors plane.zaxis and plane.xaxis.  The left plane contains the point plane.PointAt(0,dx[0],0) and the back plane contains the point plane.PointAt(0,dy[1],0)."},{"name":"dz","summary":"The \\"top\\" and \\"bottom\\" sides of the box are in spanned by the vectors plane.xaxis and plane.yaxis.  The bottom plane contains the point plane.PointAt(0,0,dz[0]) and the top plane contains the point plane.PointAt(0,0,dz[1])."}],"returns":"Returns True if a valid box is returned."},{"signature":"bool TryGetMappingBox(out Plane plane, out Interval dx, out Interval dy, out Interval dz, out bool capped)","summary":"Get a box projection from the texture mapping, including capped information","since":"6.7","parameters":[{"name":"plane","summary":"The center of the box is at plane.origin and the sides of the box are parallel to the plane\'s coordinate planes."},{"name":"dx","summary":"The \\"front\\" and \\"back\\" sides of the box are in spanned by the vectors plane.yaxis and plane.zaxis.  The back plane contains the point plane.PointAt(dx[0],0,0) and the front plane contains the point plane.PointAt(dx[1],0,0)."},{"name":"dy","summary":"The \\"left\\" and \\"right\\" sides of the box are in spanned by the vectors plane.zaxis and plane.xaxis.  The left plane contains the point plane.PointAt(0,dx[0],0) and the back plane contains the point plane.PointAt(0,dy[1],0)."},{"name":"dz","summary":"The \\"top\\" and \\"bottom\\" sides of the box are in spanned by the vectors plane.xaxis and plane.yaxis.  The bottom plane contains the point plane.PointAt(0,0,dz[0]) and the top plane contains the point plane.PointAt(0,0,dz[1])."},{"name":"capped","summary":"True if box mapping is capped."}],"returns":"Returns True if a valid box is returned."},{"signature":"bool TryGetMappingCylinder(out Cylinder cylinder)","summary":"Get a cylindrical projection parameters from this texture mapping.","since":"5.10","returns":"Returns True if a valid cylinder is returned."},{"signature":"bool TryGetMappingCylinder(out Cylinder cylinder, out bool capped)","summary":"Get a cylindrical projection parameters from this texture mapping.","since":"6.7","parameters":[{"name":"cylinder","summary":""},{"name":"capped","summary":"will be True if capped"}],"returns":"Returns True if a valid cylinder is returned."},{"signature":"bool TryGetMappingMesh(out Mesh mesh)","summary":"Get custom mapping mesh from this texture mapping.","since":"6.18","returns":"True if custom mapping mesh was returned."},{"signature":"bool TryGetMappingPlane(out Plane plane, out Interval dx, out Interval dy, out Interval dz)","summary":"Get plane mapping parameters from this texture mapping.","since":"5.10","parameters":[{"name":"plane","summary":""},{"name":"dx","summary":"Portion of the plane\'s x axis that is mapped to [0,1]"},{"name":"dy","summary":"Portion of the plane\'s y axis that is mapped to [0,1]"},{"name":"dz","summary":"Portion of the plane\'s z axis that is mapped to [0,1]"}],"returns":"Return True if valid plane mapping parameters were returned."},{"signature":"bool TryGetMappingPlane(out Plane plane, out Interval dx, out Interval dy, out Interval dz, out bool capped)","summary":"Get plane mapping parameters from this texture mapping, including capping information","since":"6.7","parameters":[{"name":"plane","summary":""},{"name":"dx","summary":"Portion of the plane\'s x axis that is mapped to [0,1]"},{"name":"dy","summary":"Portion of the plane\'s y axis that is mapped to [0,1]"},{"name":"dz","summary":"Portion of the plane\'s z axis that is mapped to [0,1]"},{"name":"capped","summary":""}],"returns":"Return True if valid plane mapping parameters were returned."},{"signature":"bool TryGetMappingSphere(out Sphere sphere)","summary":"Get a spherical projection parameters from this texture mapping.","since":"5.10","returns":"Returns True if a valid sphere is returned."}]},{"namespace":"Rhino.Render","name":"TextureMappingType","dataType":"enum","summary":"Defines enumerated constants for mapping types such as planar, cylindrical or spherical.","since":"5.0","values":[{"signature":"None = UnsafeNativeMethods.TextureMappingType.NoMapping","summary":"No mapping is selected."},{"signature":"SurfaceParameters = UnsafeNativeMethods.TextureMappingType.SrfpMapping","summary":"(u, v) = linear transform of surface params, w = 0."},{"signature":"PlaneMapping = UnsafeNativeMethods.TextureMappingType.PlaneMapping","summary":"(u, v, w) = 3d coordinates wrt frame."},{"signature":"CylinderMapping = UnsafeNativeMethods.TextureMappingType.CylinderMapping","summary":"(u, v, w) = longitude, height, radius."},{"signature":"SphereMapping = UnsafeNativeMethods.TextureMappingType.SphereMapping","summary":"(u, v, w) = longitude,latitude,radius."},{"signature":"BoxMapping = UnsafeNativeMethods.TextureMappingType.BoxMapping","summary":"Box mapping type."},{"signature":"MeshMappingPrimitive = UnsafeNativeMethods.TextureMappingType.MeshMappingPrimitive","summary":"Mapping primitive is a mesh."},{"signature":"SurfaceMappingPrimitive = UnsafeNativeMethods.TextureMappingType.SrfMappingPrimitive","summary":"Mapping primitive is a surface."},{"signature":"BrepMappingPrimitive = UnsafeNativeMethods.TextureMappingType.BrepMappingPrimitive","summary":"Mapping primitive is a brep."},{"signature":"OcsMapping = UnsafeNativeMethods.TextureMappingType.OcsMapping","summary":"OCS mapping type (WCS/WCS Box with object frame)."}]},{"namespace":"Rhino.Render","name":"TextureMode","dataType":"enum","since":"6.0","values":[{"signature":"PROJECTION_MODE = 0"},{"signature":"MAPPING_CHANNEL_MODE"},{"signature":"WRAP_TYPE_MODE"},{"signature":"REPEAT_LOCKED_MODE"},{"signature":"OFFSET_LOCKED_MODE"},{"signature":"PREVIEW_IN_3D_MODE"},{"signature":"REPEAT_MODE"},{"signature":"OFFSET_MODE"},{"signature":"ROTATION_MODE"},{"signature":"ENVIRONMENT_MAPPING_MODE"},{"signature":"INTERNAL_ENVIRONMENT_MAPPING_MODE"},{"signature":"PREVIEW_LOCAL_MAPPING_MODE"},{"signature":"DISPLAY_IN_VIEWPORT_MODE"},{"signature":"IS_HDR_CAPABLE_MODE"},{"signature":"IS_LINEAR_MODE"},{"signature":"IS_IMAGE_BASED"},{"signature":"IS_NORMALMAP"}]},{"namespace":"Rhino.Render","name":"TextureProjectionMode","dataType":"enum","since":"5.7","values":[{"signature":"MappingChannel = 0"},{"signature":"View = 1"},{"signature":"Wcs = 2"},{"signature":"EnvironmentMap = 3"},{"signature":"WcsBox = 4"},{"signature":"Screen = 5"}]},{"namespace":"Rhino.Render","name":"TextureRenderHashFlags","dataType":"enum","since":"6.0","values":[{"signature":"ExcludeLocalMapping = (1 << 32)"}]},{"namespace":"Rhino.Render","name":"TextureWrapType","dataType":"enum","since":"5.7","values":[{"signature":"Clamped = 0"},{"signature":"Repeating = 1"}]},{"namespace":"Rhino.Render","name":"TimeZone","dataType":"class","summary":"TimeZone","properties":[{"signature":"double Hours","summary":"Gets hours of a time zone.","since":"6.0","property":["get"]},{"signature":"double Latitude","summary":"Returns the latitude of a major city nearby","since":"6.15","property":["get"]},{"signature":"double Longitude","summary":"Returns the Longitude of a major city nearby","since":"6.15","property":["get"]},{"signature":"String Name","summary":"Gets name of a time zone.","since":"6.0","property":["get"]}],"methods":[{"signature":"static TimeZone TimeZoneAt(int index)","summary":"Returns a time zone at given index.","since":"6.0","parameters":[{"name":"index","summary":"index."}],"returns":"Time zone at index."},{"signature":"static int TimeZones()","summary":"Returns number of available time zones.","since":"6.0","returns":"Time zone count."}]},{"namespace":"Rhino.Render","name":"TwoColorRenderTexture","dataType":"class","baseclass":"Rhino.Render.RenderTexture","properties":[{"signature":"Color4f Color1","since":"5.1","property":["get","set"]},{"signature":"Color4f Color2","since":"5.1","property":["get","set"]},{"signature":"bool SuperSample","since":"5.1","property":["get","set"]},{"signature":"bool SwapColors","since":"5.1","property":["get","set"]},{"signature":"double Texture1Amount","since":"5.1","property":["get","set"]},{"signature":"bool Texture1On","since":"5.1","property":["get","set"]},{"signature":"double Texture2Amount","since":"5.1","property":["get","set"]},{"signature":"bool Texture2On","since":"5.1","property":["get","set"]}]},{"namespace":"Rhino.Render.UI","name":"IUserInterfaceSection","dataType":"interface","summary":"Implement this interface in your user control to get UserInterfaceSection event notification.","properties":[{"signature":"bool Hidden","summary":"Return True if the section should be hidden, else return false.","since":"6.0","deprecated":"6.0","property":["get"]}],"methods":[{"signature":"void OnUserInterfaceSectionExpanding(UserInterfaceSection userInterfaceSection, bool expanding)","summary":"The UserInterfaceSection object that called this interface method.","since":"5.1","deprecated":"6.0","parameters":[{"name":"userInterfaceSection","summary":"The UserInterfaceSection object that called this interface method."},{"name":"expanding","summary":"Will be True if the control has been createExpanded or False if it was collapsed."}]},{"signature":"void UserInterfaceDisplayData(UserInterfaceSection userInterfaceSection, RenderContent[] renderContentList)","summary":"Called by UserInterfaceSection when the selected content changes or a content field property value changes.","since":"5.1","deprecated":"6.0","parameters":[{"name":"userInterfaceSection","summary":"The UserInterfaceSection object that called this interface method."},{"name":"renderContentList","summary":"The currently selected list of content items to edit."}]}]},{"namespace":"Rhino.Render.UI","name":"UserInterfaceSection","dataType":"class","summary":"Custom user interface section manager","properties":[{"signature":"RenderContent RenderContent","summary":"The RenderContent object that created this user interface object.","since":"5.1","deprecated":"6.0","property":["get"]},{"signature":"object Window","summary":"The user control associated with this user interface object.","since":"5.1","deprecated":"6.0","property":["get"]}],"methods":[{"signature":"static UserInterfaceSection FromWindow(object window)","summary":"Find the UserInterfaceSection that created the specified instance of a window.","since":"6.0","deprecated":"6.0","parameters":[{"name":"window","summary":"If window is not None then look for the UserInterfaceSection that created the window."}],"returns":"If a UserInterfaceSection object is found containing a reference to the requested window then return the object otherwise return null."},{"signature":"void Expand(bool expand)","summary":"Expand or collapse this content section.","since":"5.1","deprecated":"6.0","parameters":[{"name":"expand","summary":"If True then expand the content section otherwise collapse it."}]},{"signature":"RenderContent[] GetContentList()","summary":"Returns a list of currently selected content items to be edited.","since":"5.1","deprecated":"6.0","returns":"Returns a list of currently selected content items to be edited."},{"signature":"void Show(bool visible)","summary":"Show or hide this content section.","since":"5.1","deprecated":"6.0","parameters":[{"name":"visible","summary":"If True then show the content section otherwise hide it."}]}]},{"namespace":"Rhino.Render.UI","name":"WorldMapDayNight","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"WorldMapDayNight()","since":"6.0"}],"methods":[{"signature":"void Dispose()","since":"6.0"},{"signature":"bool HasMapForCurrentSettings()","since":"6.0"},{"signature":"System.Drawing.Point LocationToMap(Point2d latlong)","since":"6.0"},{"signature":"void MakeMapBitmap()","since":"6.0"},{"signature":"System.Drawing.Image Map()","since":"6.0"},{"signature":"Rhino.Geometry.Point2d MapToLocation(Point mapPoint)","since":"6.0"},{"signature":"void SetDayNightDisplay(bool bOn)","since":"6.0"},{"signature":"void SetEnabled(bool bEnabled)","since":"6.0"},{"signature":"void SetTimeInfo(DateTime dt, double timezone, int daylightSavingMinutes, bool bDaylightSavingsOn)","since":"6.0"}]},{"namespace":"Rhino.Render","name":"UndoRedo","dataType":"class","summary":"This class contains the event for UndoRedoChanged that is fired from RDK .","events":[{"signature":"static UndoRedoChanged","summary":"Called after undo or redo has occurred for document settings.","since":"6.0"},{"signature":"static UndoRedoEndedChanged","summary":"This event is raised when undo/redo ends in rdk.","since":"7.0"}]},{"namespace":"Rhino.Render","name":"Utilities","dataType":"class","properties":[{"signature":"static Guid DefaultRenderPlugInId","summary":"Get the plug-in Id for the default render plug-in","since":"5.3","property":["get"]},{"signature":"static bool ShowIncompatibleEnvironments","summary":"Specifies whether incompatible content should be shown in the corresponding editor.","since":"5.3","property":["get","set"]},{"signature":"static bool ShowIncompatibleMaterials","summary":"Specifies whether incompatible content should be shown in the corresponding editor.","since":"5.3","property":["get","set"]},{"signature":"static bool ShowIncompatibleTextures","summary":"Specifies whether incompatible content should be shown in the corresponding editor.","since":"5.3","property":["get","set"]}],"methods":[{"signature":"static RenderContent ChangeContentType(RenderContent oldContent, Guid newType, bool harvestParameters)","summary":"Changes the type of a content. This deletes the content and creates a replacement of the specified type allowing the caller to decide about harvesting.","since":"6.0","parameters":[{"name":"oldContent","summary":"oldContent is the old content which is deleted."},{"name":"newType","summary":"The type of content to replace pOldContent with."},{"name":"harvestParameters","summary":"Determines whether or not parameter harvesting will be performed."}],"returns":"A new persistent render content."},{"signature":"static string FindFile(RhinoDoc doc, string fullPathToFile)","summary":"Finds a file and also handles network shares. This is a replacement for CRhinoFileUtilities::FindFile().","since":"6.0","parameters":[{"name":"doc","summary":"Document to use for locating .3dm file\'s folder."},{"name":"fullPathToFile","summary":"The file to be found."}],"returns":"The found file."},{"signature":"static string FindFile(RhinoDoc doc, string fullPathToFile, bool unpackFromBitmapTableIfNecessary)","summary":"Finds a file and also handles network shares. This is a replacement for CRhinoFileUtilities::FindFile().","since":"6.0","parameters":[{"name":"doc","summary":"Document to use for locating .3dm file\'s folder."},{"name":"fullPathToFile","summary":"The file to be found."},{"name":"unpackFromBitmapTableIfNecessary","summary":"True to seasch for the file in the bitmap table and unpack it into the temp folder if not found in the initial search."}],"returns":"The found file."},{"signature":"static bool IsCachedTextureFileInUse(string textureFileName)","summary":"Determines if any texture in any persistent content list is using the specified file name for caching.","since":"6.0","parameters":[{"name":"textureFileName","summary":"The file name to check for. The extension is ignored."}],"returns":"True if the texture is present."},{"signature":"static RenderContent LoadPersistentRenderContentFromFile(uint docSerialNumber, String filename)","summary":"Loads a content from a library file and adds it to the persistent content list of a particular document.","since":"6.0","parameters":[{"name":"docSerialNumber","summary":"identifies the document into which the content should be loaded."},{"name":"filename","summary":"is the full path to the file to be loaded."}],"returns":"The loaded content or None if an error occurred."},{"signature":"static void MoveWindow(IntPtr hwnd, Rectangle rect, bool bRepaint, bool bRepaintNC)","since":"6.0"},{"signature":"static string PromptForSaveImageFileParameters(string filename, ref int width, ref int height, ref int colorDepth)","summary":"Prompts the user for a save file name and the width, height and depth of an image to be saved.","since":"6.0","parameters":[{"name":"filename","summary":"The original file path."},{"name":"width","summary":"A width."},{"name":"height","summary":"An height."},{"name":"colorDepth","summary":"A color depth."}],"returns":"The new file name."},{"signature":"static bool SafeFrameEnabled(RhinoDoc doc)","summary":"Queries whether or not the Safe Frame is visible.","since":"6.0"},{"signature":"static bool SetDefaultRenderPlugIn(Guid pluginId)","summary":"Set default render application","since":"5.3","parameters":[{"name":"pluginId","summary":"ID of render plug-in"}],"returns":"True if plug-in found and loaded successfully.  False if pluginId is invalid or was unable to load plug-in"},{"signature":"static ShowContentChooserResults ShowContentChooser(Guid defaultType, Guid defaultInstanceId, RenderContentKind kinds, ref Guid instanceIdOut, ShowContentChooserFlags flags, RhinoDoc doc)","summary":"Shows the content chooser to allow the user to select a new or existing content.","since":"6.25","parameters":[{"name":"defaultType","summary":"The content type that will be initially selected in the \'New\' tab."},{"name":"defaultInstanceId","summary":"The content instance that will be initially selected in the \'Existing\' tab."},{"name":"kinds","summary":"Which content kinds will be displayed."},{"name":"instanceIdOut","summary":"The UUID of the chosen item. Depending on eRhRdkSccResult, this can be the type id of a content type or the instance id of an existing content."},{"name":"flags","summary":"Tabs specifications."},{"name":"doc","summary":"A Rhino document."}],"returns":"The result."},{"signature":"static bool ShowIORMenu(IntPtr hwnd, Point pt, ref double outIOR, ref string outString)","summary":"Display and track the context menu.","since":"6.0","parameters":[{"name":"hwnd","summary":"The window that displays the menu, for example an edit box."},{"name":"pt","summary":"The position to display the menu at inside the window"},{"name":"outIOR","summary":"Accepts the IOR value of the user\'s chosen substance"},{"name":"outString","summary":"Accepts the name of the user\'s chosen substance. Can be None if not required."}],"returns":"True if the function showed the IOR menu and something was picked."}]},{"namespace":"Rhino.Render","name":"Utilities.ShowContentChooserResults","dataType":"enum","since":"6.0","values":[{"signature":"None","summary":"No choice (user cancelled)."},{"signature":"New","summary":"User chose from \'New\' tab. uuidOut is the type id."},{"signature":"Copy","summary":"User chose from \'Existing\' tab with \'copy\' radio button checked. uuidOut is the instance id."},{"signature":"Instance","summary":"User chose from \'Existing\' tab with \'instance\' radio button checked. uuidOut is the instance id."}]},{"namespace":"Rhino.Render","name":"Variant.VariantTypes","dataType":"enum","values":[{"signature":"Null = 0"},{"signature":"Bool = 1"},{"signature":"Integer = 2"},{"signature":"Float = 3"},{"signature":"Double = 4"},{"signature":"Color = 5"},{"signature":"Vector2d = 6"},{"signature":"Vector3d = 7"},{"signature":"String = 8"},{"signature":"Pointer = 9"},{"signature":"Uuid = 10"},{"signature":"Matrix = 11"},{"signature":"Time = 12"},{"signature":"Buffer = 13"},{"signature":"Point4d = 14"}]},{"namespace":"Rhino","name":"RhinoApp","dataType":"class","summary":".NET RhinoApp is parallel to C++ CRhinoApp.","properties":[{"signature":"static DateTime BuildDate","summary":"Gets the build date.","since":"5.0","property":["get"]},{"signature":"static bool CanSave","summary":"Returns True when Rhino is allowed to save, False otherwise Conditions where Rhino is not allowed to save are: when evaluation licenses are expired; when a Cloud Zoo lease is expired; when a license is shared by a single user on multiple computers, and the current computer is not active.","since":"7.0","property":["get"]},{"signature":"static string CommandHistoryWindowText","summary":"Text in Rhino\'s command history window.","since":"5.0","property":["get"]},{"signature":"static CommandLineTextWriter CommandLineOut","summary":"Provides a TextWriter that can write to the command line.","since":"6.0","property":["get"]},{"signature":"static string CommandPrompt","summary":"Rhino command prompt.","since":"5.0","property":["get","set"]},{"signature":"static bool CommandWindowCaptureEnabled","summary":"Enable or disable capturing of the strings sent to the CommandWindow through Write and WriteLine calls","since":"7.0","property":["get","set"]},{"signature":"static Guid CurrentRhinoId","summary":"Gets the current ID of Rhino.","since":"5.0","property":["get"]},{"signature":"static int DaysUntilExpiration","summary":"Returns number of days until license expires. Zero when license is expired. Raises InvalidLicenseTypeException if LicenseExpires would return false.","since":"5.6","property":["get"]},{"signature":"static Font DefaultUiFont","summary":"Default font used to render user interface","since":"6.0","property":["get"]},{"signature":"static int ExeServiceRelease","summary":"Service release version of Rhino executable (0, 1, 2, ...) The integer is the service release number of Rhino.  For example, this function returns \\"0\\" if Rhino V4SR0 is running and returns \\"1\\" if Rhino V4SR1 is running.","since":"5.0","property":["get"]},{"signature":"static int ExeVersion","summary":"Major version of Rhino executable 4, 5, ...","since":"5.0","property":["get"]},{"signature":"static Installation InstallationType","summary":"Gets the product installation type, as seen in Rhino\'s ABOUT dialog box.","since":"5.0","property":["get"]},{"signature":"static string InstallationTypeString","summary":"Gets the type of installation (product edition) of the license or lease.","since":"6.0","property":["get"]},{"signature":"static bool InvokeRequired","summary":"Returns True if we are currently not running on the main user interface thread","since":"6.0","property":["get"]},{"signature":"static bool IsClosing","summary":"Returns True if Rhino is in the process of closing, False otherwise. This can be True even before the Closing event fires, such as when RhinoDoc.CloseDocument event is called.","since":"6.26","property":["get"]},{"signature":"static bool IsCloudZooNode","summary":"Returns True if rhino is currently using the Cloud Zoo False otherwise","since":"6.0","property":["get"]},{"signature":"static bool IsExiting","summary":"Returns True if Rhino is in the process of exiting, False otherwise. This can be True even before the Closing event fires, such as when RhinoDoc.CloseDocument event is called.","since":"6.26","property":["get"]},{"signature":"static bool IsInternetAccessAllowed","summary":"Returns True when Rhino is allowed to access the Internet, False otherwise","since":"6.15","property":["get"]},{"signature":"static bool IsLicenseValidated","summary":"Returns True if the license is validated False otherwise","since":"5.6","property":["get"]},{"signature":"static bool IsPreRelease","summary":"Returns True if Rhino is compiled a s pre-release build (Beta, WIP) False otherwise","since":"6.0","property":["get"]},{"signature":"static bool IsRunningAutomated","summary":"Is Rhino currently being executed through automation","since":"5.0","property":["get"]},{"signature":"static bool IsRunningHeadless","summary":"Is Rhino currently being executed in headless mode","since":"6.1","property":["get"]},{"signature":"static bool IsSkinned","summary":"Is Rhino currently using custom, user-interface Skin.","since":"6.2","property":["get"]},{"signature":"static bool LicenseExpires","summary":"Returns True if the license will expire False otherwise","since":"5.6","property":["get"]},{"signature":"static string LicenseUserName","summary":"Gets the name of the user that owns the license or lease.","since":"6.0","property":["get"]},{"signature":"static string LicenseUserOrganization","summary":"Gets the name of the organization of the user that owns the license or lease.","since":"6.0","property":["get"]},{"signature":"static Image LoggedInUserAvatar","summary":"Returns the logged in user\'s avatar picture. Returns a default avatar if the user does not have an avatar or if the avatar could not be fetched.","since":"6.0","property":["get"]},{"signature":"static string LoggedInUserName","summary":"Returns the name of the logged in user, or None if the user is not logged in.","since":"6.0","property":["get"]},{"signature":"static RhinoWindow MainApplicationWindow","summary":"Same as MainWindow function, but provides the concrete class instead of an interface","since":"5.0","property":["get"]},{"signature":"static string Name","summary":"Gets the application name.","since":"5.0","property":["get"]},{"signature":"static LicenseNode NodeType","summary":"Gets license the node type.","since":"5.0","property":["get"]},{"signature":"static Guid Rhino2Id","summary":"Gets the ID of Rhino 2.","since":"5.0","property":["get"]},{"signature":"static Guid Rhino3Id","summary":"Gets the ID of Rhino 3.","since":"5.0","property":["get"]},{"signature":"static Guid Rhino4Id","summary":"Gets the ID of Rhino 4.","since":"5.0","property":["get"]},{"signature":"static Guid Rhino5Id","summary":"Gets the ID of Rhino 5.","since":"5.0","property":["get"]},{"signature":"static Guid Rhino6Id","summary":"Gets the ID of Rhino 6.","since":"7.0","property":["get"]},{"signature":"static string SchemeName","summary":"Gets the current Registry scheme name.","since":"6.0","property":["get"]},{"signature":"static int SdkServiceRelease","summary":"Rhino SDK 9 digit SDK service release number in the form YYYYMMDDn  Service release of the Rhino SDK supported by this executable. Rhino will only load plug-ins that require a service release of <= this release number. For example, SR1 will load all plug-ins made with any SDK released up through and including the SR1 SDK. But, SR1 will not load a plug-in built using the SR2 SDK. If an \\"old\\" Rhino tries to load a \\"new\\" plug-in, the user is told that they have to get a free Rhino.exe update in order for the plug-in to load. Rhino.exe updates are available from http://www.rhino3d.com.","since":"5.0","property":["get"]},{"signature":"static int SdkVersion","summary":"Rhino SDK 9 digit SDK version number in the form YYYYMMDDn  Rhino will only load plug-ins that were build with exactly the same version of the SDK.","since":"5.0","property":["get"]},{"signature":"static string SerialNumber","summary":"Gets the product serial number, as seen in Rhino\'s ABOUT dialog box.","since":"5.0","property":["get"]},{"signature":"static ToolbarFileCollection ToolbarFiles","summary":"Collection of currently open toolbar files in the application","since":"5.0","property":["get"]},{"signature":"static int UpdatesAndStatisticsStatus","summary":"Returns True when Rhino is allowed to access the Internet, False otherwise","since":"6.15","property":["get"]},{"signature":"static bool UserIsLoggedIn","summary":"Returns True if the user is logged in; else returns false. A logged in user does not guarantee that the auth tokens managed by the CloudZooManager instance are valid.","since":"6.0","property":["get"]},{"signature":"static int ValidationGracePeriodDaysLeft","summary":"Returns number of days within which validation must occur. Zero when validation grace period has expired. Raises InvalidLicenseTypeException if LicenseType is one of: EvaluationSaveLimited EvaluationTimeLimited Viewer Unknown","since":"5.6","property":["get"]},{"signature":"static Version Version","summary":"File version of the main Rhino process","since":"5.9","property":["get"]},{"signature":"static string VersionControlRevision","summary":"McNeel version control revision identifier at the time this version of Rhino was built.","since":"5.0","property":["get"]}],"methods":[{"signature":"static bool AskUserForRhinoLicense(bool standAlone, object parentWindow)","summary":"Display UI asking the user to enter a license for Rhino or use one from the Zoo.","since":"6.0","parameters":[{"name":"standAlone","summary":"True to ask for a stand-alone license, False to ask the user for a license from the Zoo"},{"name":"parentWindow","summary":"Parent window for the user interface dialog."}]},{"signature":"static string[] CapturedCommandWindowStrings(bool clearBuffer)","summary":"Get list of strings sent to the command window through calls to Write or WriteLine when capturing has been enabled","since":"7.0","parameters":[{"name":"clearBuffer","summary":"Clear the captured buffer after this call"}],"returns":"array of captured strings"},{"signature":"static bool ChangeLicenseKey(Guid pluginId)","summary":"Display UI asking the user to enter a license for the product specified by licenseId.","since":"6.0","parameters":[{"name":"pluginId","summary":"Guid identifying the plug-in that is requesting a change of license key"}],"returns":"True on success, False otherwise"},{"signature":"static void ClearCommandHistoryWindow()","summary":"Clear the text in Rhino\'s command history window.","since":"5.0"},{"signature":"static Commands.Result ExecuteCommand(RhinoDoc document, string commandName)","summary":"Execute a Rhino command.","since":"6.0","parameters":[{"name":"document","summary":"Document to execute the command for"},{"name":"commandName","summary":"Name of command to run.  Use command\'s localized name or preface with an underscore."}],"returns":"Returns the result of the command."},{"signature":"static void Exit()","summary":"Exits, or closes, Rhino.","since":"5.0"},{"signature":"static string GetDataDirectory(bool localUser, bool forceDirectoryCreation)","summary":"Gets the data directory.","since":"6.0","parameters":[{"name":"localUser","summary":"If set totruelocal user."},{"name":"forceDirectoryCreation","summary":"If set totrueforce directory creation."}],"returns":"The data directory."},{"signature":"static string GetDataDirectory(bool localUser, bool forceDirectoryCreation, string subDirectory)","summary":"Gets the data directory.","since":"6.0","parameters":[{"name":"localUser","summary":"If set totruelocal user."},{"name":"forceDirectoryCreation","summary":"If set totrueforce directory creation."},{"name":"subDirectory","summary":"Sub directory, will get appended to the end of the data directory.  if forceDirectoryCreation is True then this directory will get created and writable."}],"returns":"The data directory."},{"signature":"static System.IO.DirectoryInfo GetExecutableDirectory()","summary":"directory","since":"6.7"},{"signature":"static object GetPlugInObject(Guid pluginId)","summary":"Gets the object that is returned by PlugIn.GetPlugInObject for a given plug-in. This function attempts to find and load a plug-in with a given Id. When a plug-in is found, it\'s GetPlugInObject function is called and the result is returned here. Note the plug-in must have already been installed in Rhino or the plug-in manager will not know where to look for a plug-in with a matching id.","since":"5.0","parameters":[{"name":"pluginId","summary":"Guid for a given plug-in."}],"returns":"Result of PlugIn.GetPlugInObject for a given plug-in on success."},{"signature":"static object GetPlugInObject(string plugin)","summary":"Gets the object that is returned by PlugIn.GetPlugInObject for a given plug-in. This function attempts to find and load a plug-in with a given name. When a plug-in is found, it\'s GetPlugInObject function is called and the result is returned here. Note the plug-in must have already been installed in Rhino or the plug-in manager will not know where to look for a plug-in with a matching name.","since":"5.0","parameters":[{"name":"plugin","summary":"Name of a plug-in."}],"returns":"Result of PlugIn.GetPlugInObject for a given plug-in on success."},{"signature":"static bool InFullScreen()","summary":"Verifies that Rhino is running in full screen mode.","since":"6.0","returns":"True if Rhino is running full screen, False otherwise."},{"signature":"static void InvokeAndWait(Action action)","summary":"Work-In-Progress. Testing this with our unit test framework","since":"6.0"},{"signature":"static void InvokeOnUiThread(Delegate method, params object[] args)","summary":"Execute a function on the main UI thread.","since":"6.0","parameters":[{"name":"method","summary":"function to execute"},{"name":"args","summary":"parameters to pass to the function"}]},{"signature":"static bool IsInstallationBeta(Installation licenseType)","summary":"If licenseType is a beta license, returns true. A beta license grants full use of the product during the pre-release development period.","since":"5.6","returns":"True if licenseType is a beta license. False otherwise"},{"signature":"static bool IsInstallationCommercial(Installation licenseType)","summary":"If licenseType is a commercial license, returns true. A commercial license grants full use of the product.","since":"5.6","returns":"True if licenseType is a commercial license. False otherwise"},{"signature":"static bool IsInstallationEvaluation(Installation licenseType)","summary":"If licenseType is an evaluation license, returns true. An evaluation license limits the ability of Rhino to save based on either the number of saves or a fixed period of time.","since":"5.6","returns":"True if licenseType is an evaluation license. False otherwise"},{"signature":"static bool LoginToCloudZoo()","summary":"Logs in to the cloud zoo.","since":"6.0"},{"signature":"static System.Windows.Forms.IWin32Window MainWindow()","summary":"Main Rhino Window","since":"5.0","deprecated":"6.0"},{"signature":"static IntPtr MainWindowHandle()","summary":"Gets the HWND of the Rhino main window.","since":"5.0"},{"signature":"static void OutputDebugString(string str)","summary":"Print a string to the Visual Studio Output window, if a debugger is attached.  Note that the developer needs to add a newline manually if the next output should come on a separate line.","since":"6.0","parameters":[{"name":"str","summary":"The string to print to the Output window."}]},{"signature":"static string ParseTextField(string formula, RhinoObject obj, RhinoObject topParentObject)","since":"6.0"},{"signature":"static bool RefreshRhinoLicense()","summary":"Refresh the license used by Rhino. This allows any part of Rhino to ensure that the most current version of the license file on disk is in use.","since":"6.0"},{"signature":"static bool ReleaseMouseCapture()","summary":"Releases the mouse capture.","since":"5.0"},{"signature":"static bool RunMenuScript(string script)","summary":"Run a Rhino menu item script.  Will add the selected menu string to the MRU command menu.","since":"6.0","parameters":[{"name":"script","summary":"[in] script to run."}]},{"signature":"static bool RunningInRdp()","summary":"Find out if Rhino is running in a remote session","since":"6.0","returns":"True if Rhino is running in a RDP session, False otherwise"},{"signature":"static bool RunningOnVMWare()","summary":"Verifies that Rhino is running on VMWare","since":"6.0","returns":"True if Rhino is running in Windows on VMWare, False otherwise"},{"signature":"static bool RunScript(string script, bool echo)","summary":"Runs a Rhino command script.","since":"5.0","parameters":[{"name":"script","summary":"[in] script to run."},{"name":"echo","summary":"Controls how the script is echoed in the command output window. False = silent - nothing is echoed. True = verbatim - the script is echoed literally."}]},{"signature":"static bool RunScript(string script, string mruDisplayString, bool echo)","summary":"Runs a Rhino command script.","since":"5.0","parameters":[{"name":"script","summary":"[in] script to run."},{"name":"mruDisplayString","summary":"[in] String to display in the most recent command list."},{"name":"echo","summary":"Controls how the script is echoed in the command output window. False = silent - nothing is echoed. True = verbatim - the script is echoed literally."}]},{"signature":"static void SendKeystrokes(string characters, bool appendReturn)","summary":"Sends a string of printable characters, including spaces, to Rhino\'s command line.","since":"5.0","parameters":[{"name":"characters","summary":"[in] A string to characters to send to the command line. This can be null."},{"name":"appendReturn","summary":"[in] Append a return character to the end of the string."}]},{"signature":"static void SetCommandPrompt(string prompt)","summary":"Set Rhino command prompt.","since":"5.0","parameters":[{"name":"prompt","summary":"The new prompt text."}]},{"signature":"static void SetCommandPrompt(string prompt, string promptDefault)","summary":"Sets the command prompt in Rhino.","since":"5.0","parameters":[{"name":"prompt","summary":"The new prompt text."},{"name":"promptDefault","summary":"Text that appears in angle brackets and indicates what will happen if the user pressed ENTER."}]},{"signature":"static void SetCommandPromptMessage(string prompt)","summary":"Set the text that appears in the Rhino command prompt. In general, you should use the SetCommandPrompt functions. In rare cases, like worker thread messages, the message that appears in the prompt has non-standard formatting. In these rare cases, SetCommandPromptMessage can be used to literally specify the text that appears in the command prompt window.","since":"6.0","parameters":[{"name":"prompt","summary":"A literal text for the command prompt window."}]},{"signature":"static void SetFocusToMainWindow()","summary":"Sets the focus to the main window. This function attempts to use the ActiveDoc on Mac to figure out which window to set focus to.","since":"5.0"},{"signature":"static void SetFocusToMainWindow(RhinoDoc doc)","summary":"Sets the focus to the main windows for a given document","since":"6.16","parameters":[{"name":"doc","summary":"the document to use for determining a \\"main window\\""}]},{"signature":"static void Wait()","summary":"Pauses to keep Windows message pump alive so views will update and windows will repaint.","since":"5.0"},{"signature":"static void Write(string message)","summary":"Print formatted text in the command window.","since":"5.0"},{"signature":"static void Write(string format, object arg0)","summary":"Print formatted text in the command window.","since":"5.0"},{"signature":"static void Write(string format, object arg0, object arg1)","summary":"Print formatted text in the command window.","since":"5.0"},{"signature":"static void Write(string format, object arg0, object arg1, object arg2)","summary":"Print formatted text in the command window.","since":"5.0"},{"signature":"static void WriteLine()","summary":"Print a newline in the command window.","since":"5.0"},{"signature":"static void WriteLine(string message)","summary":"Print text in the command window.","since":"5.0"},{"signature":"static void WriteLine(string format, object arg0)","summary":"Print formatted text with a newline in the command window.","since":"5.0"},{"signature":"static void WriteLine(string format, object arg0, object arg1)","summary":"Print formatted text with a newline in the command window.","since":"5.0"},{"signature":"static void WriteLine(string format, object arg0, object arg1, object arg2)","summary":"Print formatted text with a newline in the command window.","since":"5.0"}],"events":[{"signature":"static AppSettingsChanged","summary":"Is raised when settings are changed.","since":"5.0"},{"signature":"static Closing","summary":"Is raised when the application is about to close.","since":"5.0"},{"signature":"static EscapeKeyPressed","summary":"Can add or removed delegates that are raised when the escape key is clicked.","since":"5.0"},{"signature":"static Idle","summary":"Occurs when the application finishes processing and is about to enter the idle state","since":"5.1"},{"signature":"static Initialized","summary":"Is raised when the application is fully initialized.","since":"5.0"},{"signature":"static KeyboardEvent","summary":"Can add or removed delegates that are raised by a keyboard event.","since":"5.2"},{"signature":"static MainLoop","summary":"Gets called every loop iteration inside Rhino\'s main message loop.","since":"7.0"},{"signature":"static RdkCacheImageChanged","summary":"Monitors when the RDK thumbnail cache images are changed.","since":"5.1"},{"signature":"static RdkGlobalSettingsChanged","summary":"Monitors when RDK global settings are modified.","since":"5.1"},{"signature":"static RdkNewDocument","summary":"Monitors when RDK document information is rebuilt.","since":"5.1"},{"signature":"static RdkPlugInUnloading","summary":"Monitors when RDK client plug-ins are unloaded.","since":"5.1"},{"signature":"static RdkUpdateAllPreviews","summary":"Monitors when RDK thumbnails are updated.","since":"5.1"},{"signature":"static RendererChanged","summary":"Monitors when Rhino\'s current renderer changes.","since":"5.1"}]},{"namespace":"Rhino","name":"RhinoApp.CommandLineTextWriter","dataType":"class","summary":"Provides a text writer that writes to the command line.","baseclass":"System.IO.TextWriter","properties":[{"signature":"Encoding Encoding","summary":"Returns Encoding Unicode.","since":"6.0","property":["get"]}],"methods":[{"signature":"void Write(char value)","summary":"Writes a char to the command line.","since":"6.0"},{"signature":"void Write(char[] buffer, int index, int count)","summary":"Writes a char buffer to the command line.","since":"6.0"},{"signature":"void write(string str)","summary":"Provided to give a simple way to IronPython to call this class.","since":"6.0","parameters":[{"name":"str","summary":"The text."}]},{"signature":"void Write(string value)","summary":"Writes a string to the command line.","since":"6.0"}]},{"namespace":"Rhino","name":"RhinoDoc","dataType":"class","summary":"Represents an active model.","interfaces":["IDisposable"],"properties":[{"signature":"static RhinoDoc ActiveDoc","summary":"WARNING!! Do not use the ActiveDoc if you don\'t have to. Under Mac Rhino the ActiveDoc can change while a command is running. Use the doc that is passed to you in your RunCommand function or continue to use the same doc after the first call to ActiveDoc.","since":"5.0","property":["get","set"]},{"signature":"AnimationProperties AnimationProperties","since":"6.11","property":["get","set"]},{"signature":"BitmapTable Bitmaps","summary":"bitmaps used in textures, backgrounds, wallpapers, ...","since":"5.0","property":["get"]},{"signature":"ICurrentEnvironment CurrentEnvironment","summary":"Access to the current environment for various uses","since":"6.0","property":["get"]},{"signature":"uint CurrentUndoRecordSerialNumber","summary":">0: undo recording is active and being saved on the undo record with the specified serial number. 0: undo recording is not active. (Disabled or nothing is being recorded.)","since":"6.0","property":["get"]},{"signature":"Size> CustomRenderSizes","since":"6.0","property":["get"]},{"signature":"DateTime DateCreated","since":"5.0","property":["get"]},{"signature":"DateTime DateLastEdited","since":"5.0","property":["get"]},{"signature":"DimStyleTable DimStyles","since":"5.0","property":["get"]},{"signature":"int DistanceDisplayPrecision","since":"5.0","property":["get"]},{"signature":"int DocumentId","summary":"Gets the Document Id.","since":"5.0","property":["get"]},{"signature":"EarthAnchorPoint EarthAnchorPoint","since":"5.0","property":["get","set"]},{"signature":"FontTable Fonts","since":"5.0","property":["get"]},{"signature":"GroundPlane GroundPlane","summary":"Gets the ground plane of this document.","since":"5.0","property":["get"]},{"signature":"GroupTable Groups","since":"5.0","property":["get"]},{"signature":"HatchPatternTable HatchPatterns","since":"5.0","property":["get"]},{"signature":"InstanceDefinitionTable InstanceDefinitions","since":"5.0","property":["get"]},{"signature":"bool IsAvailable","since":"6.0","property":["get"]},{"signature":"bool IsClosing","since":"6.0","property":["get"]},{"signature":"bool IsCommandRunning","summary":"Returns True if Rhino is currently running a command.","since":"7.0","property":["get"]},{"signature":"bool IsCreating","since":"6.0","property":["get"]},{"signature":"bool IsHeadless","since":"7.0","property":["get"]},{"signature":"bool IsInitializing","since":"6.0","property":["get"]},{"signature":"bool IsLocked","summary":"Check to see if the file associated with this document is locked.  If it is locked then this is the only document that will be able to write the file.  Other instances of Rhino will fail to write this document.","since":"5.0","property":["get"]},{"signature":"bool IsOpening","since":"6.0","property":["get"]},{"signature":"bool IsReadOnly","summary":"Current read-only mode for this document. True if the document can be viewed but NOT saved. False if document can be viewed and saved.","since":"5.0","property":["get"]},{"signature":"bool IsSendingMail","summary":"True if Rhino is in the process of sending this document as an email attachment.","since":"5.0","property":["get"]},{"signature":"LayerTable Layers","summary":"Layers in the document.","since":"5.0","property":["get"]},{"signature":"bool LayoutSpaceAnnotationScalingEnabled","summary":"If LayoutSpaceAnnotationScaling is on, sizes in dimstyles are multiplied by dimscale when the annotation is displayed in a detail viewport not in a detail","since":"6.0","property":["get","set"]},{"signature":"LightTable Lights","since":"5.0","property":["get"]},{"signature":"LinetypeTable Linetypes","summary":"Linetypes in the document.","since":"5.0","property":["get"]},{"signature":"ManifestTable Manifest","since":"6.0","property":["get"]},{"signature":"MaterialTable Materials","summary":"Materials in the document.","since":"5.0","property":["get"]},{"signature":"MeshingParameterStyle MeshingParameterStyle","summary":"Type of MeshingParameters currently used by the document to mesh objects","since":"5.1","property":["get","set"]},{"signature":"double ModelAbsoluteTolerance","summary":"Model space absolute tolerance.","since":"5.0","property":["get","set"]},{"signature":"double ModelAngleToleranceDegrees","summary":"Model space angle tolerance.","since":"5.0","property":["get","set"]},{"signature":"double ModelAngleToleranceRadians","summary":"Model space angle tolerance.","since":"5.0","property":["get","set"]},{"signature":"Point3d ModelBasepoint","summary":"The base point in the model that is used when inserting the model into another as a block definition. By default the base point in any model is 0,0,0.","since":"6.10","property":["get","set"]},{"signature":"int ModelDistanceDisplayPrecision","since":"5.8","property":["get","set"]},{"signature":"double ModelRelativeTolerance","summary":"Model space relative tolerance.","since":"5.0","property":["get","set"]},{"signature":"bool ModelSpaceAnnotationScalingEnabled","summary":"If ModelSpaceAnnotationScaling is on, sizes in dimstyles are multiplied by dimscale when the annotation is displayed in a model space viewport not in a detail","since":"6.0","property":["get","set"]},{"signature":"double ModelSpaceHatchScale","summary":"The scale factor for hatches in model space when Hatch Scaling is enabled","since":"6.1","property":["get","set"]},{"signature":"bool ModelSpaceHatchScalingEnabled","summary":"True if hatch scaling is enabled, False if not.","since":"6.16","property":["get","set"]},{"signature":"double ModelSpaceTextScale","summary":"The scale factor for text in model space when Annotation Scaling is enabled","since":"6.1","property":["get","set"]},{"signature":"UnitSystem ModelUnitSystem","since":"5.0","property":["get","set"]},{"signature":"bool Modified","summary":"Returns or sets the document\'s modified flag.","since":"5.0","property":["get","set"]},{"signature":"string Name","summary":"Returns the name of the currently loaded Rhino document (3DM file).","since":"5.0","property":["get"]},{"signature":"NamedConstructionPlaneTable NamedConstructionPlanes","summary":"Collection of named construction planes.","since":"5.0","property":["get"]},{"signature":"NamedLayerStateTable NamedLayerStates","summary":"Collection of named layer states.","since":"6.14","property":["get"]},{"signature":"NamedPositionTable NamedPositions","summary":"Collection of named positions.","since":"6.0","property":["get"]},{"signature":"NamedViewTable NamedViews","summary":"Collection of named views.","since":"5.0","property":["get"]},{"signature":"uint NextUndoRecordSerialNumber","summary":"The serial number that will be assigned to the next undo record that is constructed.","since":"6.0","property":["get"]},{"signature":"string Notes","summary":"Returns or sets the document\'s notes.","since":"5.0","property":["get","set"]},{"signature":"ObjectTable Objects","since":"5.0","property":["get"]},{"signature":"double PageAbsoluteTolerance","summary":"Page space absolute tolerance.","since":"5.0","property":["get","set"]},{"signature":"double PageAngleToleranceDegrees","summary":"Page space angle tolerance.","since":"5.0","property":["get","set"]},{"signature":"double PageAngleToleranceRadians","summary":"Page space angle tolerance.","since":"5.0","property":["get","set"]},{"signature":"int PageDistanceDisplayPrecision","since":"5.8","property":["get","set"]},{"signature":"double PageRelativeTolerance","summary":"Page space relative tolerance.","since":"5.0","property":["get","set"]},{"signature":"UnitSystem PageUnitSystem","since":"5.0","property":["get","set"]},{"signature":"string Path","summary":"Returns the path of the currently loaded Rhino document (3DM file).","since":"5.0","property":["get"]},{"signature":"IPostEffects PostEffects","summary":"Access to the post effects","since":"7.0","property":["get"]},{"signature":"bool RedoActive","summary":"Returns True if Redo is currently active.","since":"6.0","property":["get"]},{"signature":"RenderEnvironmentTable RenderEnvironments","since":"5.7","property":["get"]},{"signature":"RenderMaterialTable RenderMaterials","since":"5.7","property":["get"]},{"signature":"RenderSettings RenderSettings","since":"5.0","property":["get","set"]},{"signature":"RenderTextureTable RenderTextures","since":"5.7","property":["get"]},{"signature":"RuntimeDocumentDataTable RuntimeData","summary":"Collection of document runtime data. This is a good place to put non-serializable, per document data, such as panel view models. Note well: This data will be dispose with the document and does not get serialized.","since":"6.3","property":["get"]},{"signature":"uint RuntimeSerialNumber","summary":"Unique serialNumber for the document while the application is running. This is not a persistent value.","since":"6.0","property":["get","set"]},{"signature":"SnapshotTable Snapshots","summary":"Collection of snapshots.","since":"6.7","property":["get"]},{"signature":"StringTable Strings","summary":"Collection of document user data strings in this document","since":"5.0","property":["get"]},{"signature":"string TemplateFileUsed","summary":"name of the template file used to create this document. This is a runtime value only present if the document was newly created.","since":"5.0","property":["get"]},{"signature":"bool UndoActive","summary":"Returns True if Undo is currently active.","since":"6.0","property":["get"]},{"signature":"bool UndoRecordingEnabled","since":"5.0","property":["get","set"]},{"signature":"bool UndoRecordingIsActive","summary":"True if undo recording is actually happening now.","since":"5.0","property":["get"]},{"signature":"ViewTable Views","since":"5.0","property":["get"]},{"signature":"Worksession Worksession","summary":"Provides access to the document\'s worksession.","since":"6.0","property":["get"]}],"methods":[{"signature":"static RhinoDoc Create(string modelTemplateFileName)","summary":"Creates a new RhinoDoc","since":"6.4","parameters":[{"name":"modelTemplateFileName","summary":"Name of a Rhino model to use as a template to initialize the document. If the template contains views, those views are created. If null, an empty document with no views is created"}]},{"signature":"static RhinoDoc CreateHeadless(string file3dmTemplatePath)","summary":"Create a new headless RhinoDoc from a template file","since":"7.0","parameters":[{"name":"file3dmTemplatePath","summary":"Name of a Rhino model to use as a template to initialize the document. If null, an empty document is created"}],"returns":"New RhinoDoc on success. Note that this is a \\"headless\\" RhinoDoc and it\'s lifetime is under your control."},{"signature":"static System.Drawing.Bitmap ExtractPreviewImage(string path)","summary":"Extracts the bitmap preview image from the specified model (3DM).","since":"5.0","parameters":[{"name":"path","summary":"The model (3DM) from which to extract the preview image. If null, the currently loaded model is used."}],"returns":"True on success."},{"signature":"static RhinoDoc FromFilePath(string filePath)","summary":"Search the open document list for a document with a Path equal to the specified file path.","since":"6.0","parameters":[{"name":"filePath","summary":"The full path to the file to search for."}],"returns":"The file name to search for"},{"signature":"static RhinoDoc FromId(int docId)","since":"5.0","deprecated":"6.0"},{"signature":"static RhinoDoc FromRuntimeSerialNumber(uint serialNumber)","since":"6.0"},{"signature":"static RhinoDoc Open(string filePath, out bool wasAlreadyOpen)","summary":"Opens a 3dm file and makes it the active document. If called on windows the active document will be saved and closed and the new document will be opened and become the active document.  If called on the Mac the file will be opened in a new document window.","since":"6.0","parameters":[{"name":"filePath","summary":"Full path to the 3dm file to open"},{"name":"wasAlreadyOpen","summary":"Will get set to True if there is a currently open document with the specified path; otherwise it will get set to false."}],"returns":"Returns the newly opened document on success or None on error."},{"signature":"static RhinoDoc[] OpenDocuments()","summary":"Returns a list of currently open Rhino documents","since":"6.0"},{"signature":"static bool OpenFile(string path)","since":"5.0","deprecated":"6.0"},{"signature":"static RhinoDoc OpenHeadless(string file3dmPath)","summary":"Opens a 3DM file into a new headless RhinoDoc.","since":"7.0","parameters":[{"name":"file3dmPath","summary":"Path of a Rhino model to load."}]},{"signature":"static bool ReadFile(string path, FileReadOptions options)","since":"5.0"},{"signature":"bool AddCustomUndoEvent(string description, EventHandler<CustomUndoEventArgs> handler)","since":"5.0"},{"signature":"bool AddCustomUndoEvent(string description, EventHandler<CustomUndoEventArgs> handler, object tag)","summary":"Add a custom undo event so you can undo private plug-in data when the user performs an undo or redo","since":"5.0"},{"signature":"void AdjustModelUnitSystem(UnitSystem newUnitSystem, bool scale)","since":"5.0"},{"signature":"void AdjustPageUnitSystem(UnitSystem newUnitSystem, bool scale)","since":"5.0"},{"signature":"uint BeginUndoRecord(string description)","summary":"Instructs Rhino to begin recording undo information when the document is changed outside of a command. We use this, e.g., to save changes caused by the modeless layer or object properties dialogs when commands are not running.","since":"5.0","parameters":[{"name":"description","summary":"A text describing the record."}],"returns":"Serial number of record.  Returns 0 if record is not started because undo information is already being recorded or undo is disabled."},{"signature":"void ClearRedoRecords()","since":"5.0"},{"signature":"void ClearUndoRecords(bool purgeDeletedObjects)","since":"5.0"},{"signature":"void ClearUndoRecords(uint undoSerialNumber, bool purgeDeletedObjects)","since":"6.0"},{"signature":"DocObjects.ObjectAttributes CreateDefaultAttributes()","summary":"Gets the default object attributes for this document. The attributes will be linked to the currently active layer and they will inherit the Document WireDensity setting.","since":"5.0"},{"signature":"void Dispose()","since":"7.0"},{"signature":"bool EndUndoRecord(uint undoRecordSerialNumber)","summary":"Ends the undo record.","since":"5.0","parameters":[{"name":"undoRecordSerialNumber","summary":"The serial number of the undo record."}],"returns":"True if successful, False otherwise."},{"signature":"bool Equals(object obj)"},{"signature":"bool Export(string filePath)","summary":"Export the entire document to a file. All file formats that Rhino can export to are supported by this function.","since":"7.0","returns":"True on success"},{"signature":"bool ExportSelected(string filePath)","summary":"Export selected geometry to a file. All file formats that Rhino can export to are supported by this function.","since":"7.0","returns":"True on success"},{"signature":"string FindFile(string filename)","summary":"Search for a file using Rhino\'s search path.  Rhino will look in the following places: 1. Current model folder 2. Path specified in options dialog/File tab 3. Rhino system folders 4. Rhino executable folder","since":"5.0","returns":"Path to existing file if found, an empty string if no file was found"},{"signature":"MeshingParameters GetAnalysisMeshingParameters()","summary":"Get analysis meshing parameters currently used by the document","since":"6.0"},{"signature":"MeshingParameters GetCurrentMeshingParameters()","summary":"Get the custom meshing parameters that this document will use.","since":"6.0"},{"signature":"string[] GetEmbeddedFilesList(bool missingOnly)","since":"6.0"},{"signature":"bool GetGumballPlane(out Plane plane)","summary":"Returns the active plane of Rhino\'s auto-gumball widget. Note, when calling from a Rhino command, make sure the command class has the Rhino.Commands.Style.Transparent command style attribute.","since":"6.0","parameters":[{"name":"plane","summary":"The active plane."}],"returns":"True if the auto-gumball widget is enabled and visible. False otherwise."},{"signature":"int GetHashCode()"},{"signature":"MeshingParameters GetMeshingParameters(MeshingParameterStyle style)","summary":"Get MeshingParameters currently used by the document","since":"5.1"},{"signature":"RenderPrimitiveList GetRenderPrimitiveList(ViewportInfo viewport, DisplayPipelineAttributes attrs)","summary":"Build custom render mesh(es) for this document (i.e. - GH meshes).","since":"6.9","parameters":[{"name":"viewport","summary":"The viewport being rendered."},{"name":"attrs","summary":"Attributes for the view mode you are supplying meshes for.  Will be None if this is a modal rendering."}],"returns":"Returns a RenderPrimitiveList if successful otherwise returns null."},{"signature":"IEnumerable<RenderPrimitive> GetRenderPrimitives(bool forceTriangleMeshes, bool quietly)","summary":"Get a enumerable list of custom mesh primitives","since":"6.0","parameters":[{"name":"forceTriangleMeshes","summary":"If True all mesh faces will be triangulated"},{"name":"quietly","summary":"Iterate quietly, if True then no user interface will be displayed"}]},{"signature":"IEnumerable<RenderPrimitive> GetRenderPrimitives(Guid plugInId, ViewportInfo viewport, bool forceTriangleMeshes, bool quietly)","summary":"Get a enumerable list of custom mesh primitives","since":"6.0","parameters":[{"name":"plugInId","summary":"The Id of the plug-in creating the iterator."},{"name":"viewport","summary":"The rendering view camera."},{"name":"forceTriangleMeshes","summary":"If True all mesh faces will be triangulated"},{"name":"quietly","summary":"Iterate quietly, if True then no user interface will be displayed"}]},{"signature":"IEnumerable<RenderPrimitive> GetRenderPrimitives(ViewportInfo viewport, bool forceTriangleMeshes, bool quietly)","summary":"Get a enumerable list of custom mesh primitives","since":"6.0","parameters":[{"name":"viewport","summary":"The rendering view camera."},{"name":"forceTriangleMeshes","summary":"If True all mesh faces will be triangulated"},{"name":"quietly","summary":"Iterate quietly, if True then no user interface will be displayed"}]},{"signature":"string GetUnitSystemName(bool modelUnits, bool capitalize, bool singular, bool abbreviate)","since":"5.0"},{"signature":"bool Import(string filePath)","summary":"Import geometry into a RhinoDoc from a file. This can be any file format that Rhino can import","since":"7.0","returns":"True on success"},{"signature":"int ReadFileVersion()","summary":"Returns the file version of the current document. Use this function to determine which version of Rhino last saved the document.","since":"5.0","returns":"The file version (e.g. 1, 2, 3, 4, etc.) or -1 if the document has not been read from disk."},{"signature":"bool Redo()","summary":"Redo the last action that was \\"undone\\"","since":"6.16","returns":"True on success"},{"signature":"bool Save()","summary":"Save doc to disk using the document\'s Path","since":"7.0"},{"signature":"bool SaveAs(string file3dmPath)","summary":"Save doc as a 3dm to a specified path using the current Rhino file version","since":"7.0","returns":"True on success"},{"signature":"bool SaveAs(string file3dmPath, int version)","summary":"Save doc as a 3dm to a specified path","since":"7.0","parameters":[{"name":"file3dmPath","summary":""},{"name":"version","summary":"Rhino file version"}],"returns":"True on success"},{"signature":"bool SaveAsTemplate(string file3dmTemplatePath)","summary":"Save this document as a template","since":"7.0","returns":"True on success"},{"signature":"bool SaveAsTemplate(string file3dmTemplatePath, int version)","summary":"Save this document as a template to a specific Rhino file version","since":"7.0","returns":"True on success"},{"signature":"void SetCustomMeshingParameters(MeshingParameters mp)","summary":"Set the custom meshing parameters that this document will use. You must also modify the MeshingParameterStyle property on the document to Custom if you want these meshing parameters to be used","since":"5.1"},{"signature":"bool SupportsRenderPrimitiveList(ViewportInfo viewport, DisplayPipelineAttributes attrs)","summary":"Determines if custom render meshes will be built for this document (i.e. - GH meshes).","since":"6.9","parameters":[{"name":"viewport","summary":"The viewport being rendered."},{"name":"attrs","summary":"Type of mesh to build. If attrs is non-None then a smaller mesh may be generated in less time, False is meant when actually rendering."}],"returns":"Returns True if custom render mesh(es) will get built for this document."},{"signature":"bool TryGetRenderPrimitiveBoundingBox(ViewportInfo viewport, DisplayPipelineAttributes attrs, out BoundingBox boundingBox)","summary":"Get the bounding box for the custom render meshes associated with this document (i.e. - GH meshes).","since":"6.9","parameters":[{"name":"viewport","summary":"The viewport being rendered."},{"name":"attrs","summary":"Attributes for the view mode you are supplying meshes for.  Will be None if this is a modal rendering."},{"name":"boundingBox","summary":"This will be set to BoundingBox.Unset on failure otherwise it will be the bounding box for the custom render meshes associated with this object."}],"returns":"Returns True if the bounding box was successfully calculated otherwise returns False on error."},{"signature":"bool Undo()","summary":"Undo the last action","since":"6.16","returns":"True on success"},{"signature":"bool Write3dmFile(string path, FileWriteOptions options)","summary":"Write information in this document to a .3dm file. Note, the active document\'s name will not be changed.","since":"6.5","parameters":[{"name":"path","summary":"The name of the .3dm file to write."},{"name":"options","summary":"The file writing options."}],"returns":"True if successful, False on failure."},{"signature":"bool WriteFile(string path, FileWriteOptions options)","summary":"Write information in this document to a file. Note, the active document\'s name will be changed to that of the path provided.","since":"5.0","parameters":[{"name":"path","summary":"The name of the file to write."},{"name":"options","summary":"The file writing options."}],"returns":"True if successful, False on failure."}],"events":[{"signature":"static ActiveDocumentChanged","summary":"This event is raised when the active document used by modeless user interface changes.  On Mac Rhino this will get raised before the  NewDocument, BeginOpenDocumentand  EndOpenDocumentevents.  Mac Rhino will also raise this event with 0 for the document Id and a None document pointer when the last document is closed.  Windows Rhino will raise this event after the  NewDocument, BeginOpenDocumentand  EndOpenDocumentevents when a new or existing model is opened.","since":"6.0"},{"signature":"static AddRhinoObject","summary":"Called if a new object is added to the document.","since":"5.0"},{"signature":"static BeforeTransformObjects","summary":"Called before objects are being transformed","since":"5.10"},{"signature":"static BeginOpenDocument","summary":"This event is raised when the document open operation begins. NOTE: On Windows, this event will be fired when a clipboard paste operation occurs, as Rhino opens a .tmp file in the User\'s Local folder with the contents of the pasted document.","since":"5.0"},{"signature":"static BeginSaveDocument","since":"5.0"},{"signature":"static CloseDocument","since":"5.0"},{"signature":"static DeleteRhinoObject","summary":"Called if an object is deleted. At some later point the object can be un-deleted.","since":"5.0"},{"signature":"static DeselectAllObjects","summary":"Called when all objects are deselected.","since":"5.0"},{"signature":"static DeselectObjects","summary":"Called when object(s) are deselected.","since":"5.0"},{"signature":"static DimensionStyleTableEvent","summary":"Called when any modification happens to a document\'s dimension style table.","since":"6.0"},{"signature":"static DocumentPropertiesChanged","since":"5.0"},{"signature":"static EndOpenDocument","since":"5.0"},{"signature":"static EndOpenDocumentInitialiViewUpdate","summary":"This event is raised after EndOpenDocumentwhen the documents initial views have been created and initialized.","since":"5.11"},{"signature":"static EndOpenDocumentInitialViewUpdate","summary":"This event is raised after EndOpenDocumentwhen the documents initial views have been created and initialized.","since":"6.18"},{"signature":"static EndSaveDocument","since":"5.0"},{"signature":"static GroupTableEvent","summary":"Called when any modification happens to a document\'s group table.","since":"5.0"},{"signature":"static InstanceDefinitionTableEvent","summary":"Called when any modification happens to a document\'s light table.","since":"5.3"},{"signature":"static LayerTableEvent","summary":"Called when any modification happens to a document\'s layer table.","since":"5.0"},{"signature":"static LightTableEvent","summary":"Called when any modification happens to a document\'s light table.","since":"5.3"},{"signature":"static MaterialTableEvent","summary":"Called when any modification happens to a document\'s material table.","since":"5.0"},{"signature":"static ModifyObjectAttributes","summary":"Called when all object attributes are changed.","since":"5.0"},{"signature":"static NewDocument","since":"5.0"},{"signature":"static PurgeRhinoObject","summary":"Called if an object is being purged from a document. The object will cease to exist forever.","since":"5.0"},{"signature":"static RenderEnvironmentTableEvent","since":"5.7"},{"signature":"static RenderMaterialsTableEvent","since":"5.7"},{"signature":"static RenderTextureTableEvent","summary":"Called when the RenderTextureTablehas been loaded, is about to be cleared or has been cleared.  See RenderContentTableEventTypefor more information.","since":"5.7"},{"signature":"static ReplaceRhinoObject","summary":"Called if an object is about to be replaced. If both RhinoDoc.UndoActive() and RhinoDoc.RedoActive() return false, then immediately after the ReplaceObject event, there will be a DeleteObject event followed by an AddObject event.  If either RhinoDoc.UndoActive() or RhinoDoc::RedoActive() return true, then immediately after the ReplaceObject event, there will be a DeleteObject event followed by an UndeleteObject event.","since":"5.0"},{"signature":"static SelectObjects","summary":"Called when object(s) are selected.","since":"5.0"},{"signature":"static TextureMappingEvent","summary":"Called when any modification happens to a document objects texture mapping.","since":"5.8"},{"signature":"static UndeleteRhinoObject","summary":"Called if an object is un-deleted.","since":"5.0"}]},{"namespace":"Rhino","name":"RhinoDoc.RenderContentTableEventArgs","dataType":"class","summary":"Passed to the RenderMaterialsTableEvent, RenderEnvironmentTableEventand the  RenderTextureTableEventevents.","baseclass":"EventArgs","properties":[{"signature":"RhinoDoc Document","summary":"Document the table belongs to","since":"5.7","property":["get"]},{"signature":"RenderContentTableEventType EventType","summary":"Event type","since":"5.7","property":["get"]}]},{"namespace":"Rhino","name":"RhinoDoc.RenderContentTableEventType","dataType":"enum","summary":"Type of content table event","since":"5.7","values":[{"signature":"Loaded","summary":"The document has been read and the table has been loaded"},{"signature":"Clearing","summary":"The table is about to be cleared"},{"signature":"Cleared","summary":"The table has been cleared"},{"signature":"MaterialAssignmentChanged","summary":"Object or layer material assignment changed"}]},{"namespace":"Rhino","name":"RhinoDoc.RenderMaterialAssignmentChangedEventArgs","dataType":"class","baseclass":"RenderContentTableEventArgs","properties":[{"signature":"bool IsLayer","since":"5.10","property":["get"]},{"signature":"bool IsObject","since":"5.10","property":["get"]},{"signature":"Guid LayerId","since":"5.10","property":["get"]},{"signature":"Guid NewRenderMaterial","since":"5.10","property":["get"]},{"signature":"Guid ObjectId","since":"5.10","property":["get"]},{"signature":"Guid OldRenderMaterial","since":"5.10","property":["get"]}]},{"namespace":"Rhino","name":"RhinoDoc.TextureMappingEventArgs","dataType":"class","summary":"Event arguments passed to the RhinoDoc.TextureMappingEvent.","baseclass":"EventArgs","properties":[{"signature":"RhinoDoc Document","since":"5.8","property":["get"]},{"signature":"TextureMappingEventType EventType","since":"5.8","property":["get"]},{"signature":"TextureMapping NewMapping","since":"5.8","property":["get"]},{"signature":"TextureMapping OldMapping","since":"5.8","property":["get"]}]},{"namespace":"Rhino","name":"RhinoDoc.TextureMappingEventType","dataType":"enum","since":"5.8","values":[{"signature":"Added = UnsafeNativeMethods.RhinoEventWatcherTextureMappingEventConsts.Added","summary":"Adding texture mapping to a document"},{"signature":"Deleted = UnsafeNativeMethods.RhinoEventWatcherTextureMappingEventConsts.Deleted","summary":"A texture mapping was deleted from a document"},{"signature":"Undeleted = UnsafeNativeMethods.RhinoEventWatcherTextureMappingEventConsts.Undeleted","summary":"A texture mapping was undeleted in a document"},{"signature":"Modified = UnsafeNativeMethods.RhinoEventWatcherTextureMappingEventConsts.Modified","summary":"A texture mapping was modified in a document"}]},{"namespace":"Rhino","name":"RhinoDocObserverArgs","dataType":"class","summary":"Arguments passed to IRhinoDocObservermethods.","constructors":[{"signature":"RhinoDocObserverArgs(RhinoDoc doc)","since":"6.0"}],"properties":[{"signature":"RhinoDoc Doc","summary":"Document","since":"6.0","property":["get"]},{"signature":"uint RuntimeSerialNumber","summary":"Document runtime serial number, will be different across Rhino sessions.","since":"6.0","property":["get"]}]},{"namespace":"Rhino","name":"RhinoFileWatcherChangeReason","dataType":"enum","summary":"Passed to IRhinoFileEventWatcher::Changed when a change event is raised.","values":[{"signature":"Created = 1","summary":"The creation of a file or folder."},{"signature":"Deleted = 2","summary":"The deletion of a file or folder."},{"signature":"Changed = 4","summary":"The change of a file or folder. The types of changes include: changes to size, attributes, security settings, last write, and last access time."},{"signature":"Renamed","summary":"The renaming of a file or folder."}]},{"namespace":"Rhino","name":"RhinoMath","dataType":"class","summary":"Provides constants and static methods that are additional to  System.Math.","methods":[{"signature":"static double Clamp(double value, double bound1, double bound2)","summary":"Restricts a doubleto be specified within an interval of two numbers.","since":"5.0","parameters":[{"name":"value","summary":"A number."},{"name":"bound1","summary":"A first bound."},{"name":"bound2","summary":"A second bound. This does not necessarily need to be larger or smaller than bound1."}],"returns":"The clamped value."},{"signature":"static int Clamp(int value, int bound1, int bound2)","summary":"Restricts a intto be specified within an interval of two integers.","since":"5.0","parameters":[{"name":"value","summary":"An integer."},{"name":"bound1","summary":"A first bound."},{"name":"bound2","summary":"A second bound. This does not necessarily need to be larger or smaller than bound1."}],"returns":"The clamped value."},{"signature":"static uint CRC32(uint currentRemainder, byte[] buffer)","summary":"Advances the cyclic redundancy check value remainder given a byte array. http://en.wikipedia.org/wiki/Cyclic_redundancy_check.","since":"5.0","parameters":[{"name":"currentRemainder","summary":"The remainder from which to start."},{"name":"buffer","summary":"The value to add to the current remainder."}],"returns":"The new current remainder."},{"signature":"static uint CRC32(uint currentRemainder, double value)","summary":"Advances the cyclic redundancy check value remainder given a double. http://en.wikipedia.org/wiki/Cyclic_redundancy_check.","since":"5.0","parameters":[{"name":"currentRemainder","summary":"The remainder from which to start."},{"name":"value","summary":"The value to add to the current remainder."}],"returns":"The new current remainder."},{"signature":"static uint CRC32(uint currentRemainder, int value)","summary":"Advances the cyclic redundancy check value remainder given a int. http://en.wikipedia.org/wiki/Cyclic_redundancy_check.","since":"5.0","parameters":[{"name":"currentRemainder","summary":"The remainder from which to start."},{"name":"value","summary":"The value to add to the current remainder."}],"returns":"The new current remainder."},{"signature":"static bool EpsilonEquals(double x, double y, double epsilon)","summary":"Compare two doubles for equality within some \\"epsilon\\" range","since":"5.4"},{"signature":"static bool EpsilonEquals(float x, float y, float epsilon)","summary":"Compare to floats for equality within some \\"epsilon\\" range","since":"5.4"},{"signature":"static bool EvaluateNormal(int limitDirection, Vector3d ds, Vector3d dt, Vector3d dss, Vector3d dst, Vector3d dtt, out Vector3d n)","summary":"Expert tool to evaluate surface unit normal.","since":"7.0","parameters":[{"name":"limitDirection","summary":"Determines which direction is used to compute the limit, where: 0 = default, 1 = from quadrant I, 2 = from quadrant II, etc."},{"name":"ds","summary":"First partial derivative."},{"name":"dt","summary":"First partial derivative."},{"name":"dss","summary":"Second partial derivative."},{"name":"dst","summary":"Second partial derivative."},{"name":"dtt","summary":"Second partial derivative."},{"name":"n","summary":"Unit normal."}],"returns":"True if successful, False otherwise."},{"signature":"static bool EvaluateNormalPartials(Vector3d ds, Vector3d dt, Vector3d dss, Vector3d dst, Vector3d dtt, out Vector3d ns, out Vector3d nt)","summary":"Expert tool to evaluate partial derivatives of surface unit normal.","since":"7.0","parameters":[{"name":"ds","summary":"First partial derivative."},{"name":"dt","summary":"First partial derivative."},{"name":"dss","summary":"Second partial derivative."},{"name":"dst","summary":"Second partial derivative."},{"name":"dtt","summary":"Second partial derivative."},{"name":"ns","summary":"First partial derivative of unit normal. If the Jacobian is degenerate, ns is set to zero."},{"name":"nt","summary":"First partial derivative of unit normal. If the Jacobian is degenerate, nt is set to zero."}],"returns":"True if Jacobian is non-degenerate, False if Jacobian is degenerate."},{"signature":"static string IntIndexToString(int index)","summary":"Portrays an intindex in text.","since":"6.0","parameters":[{"name":"index","summary":"intnumber express as string."}],"returns":"The text representation of the int index."},{"signature":"static bool IsValidDouble(double x)","summary":"Determines whether a doublevalue is valid within the RhinoCommon context.  \\nRhino does not use Double.NaN by convention, so this test evaluates to True if:  \\nx is not equal to RhinoMath.UnsetValue  \\nSystem.Double.IsNaN(x) evaluates to false  \\nSystem.Double.IsInfinity(x) evaluates to false","since":"5.0","parameters":[{"name":"x","summary":"doublenumber to test for validity."}],"returns":"True if the number if valid, False if the number is NaN, Infinity or Unset."},{"signature":"static bool IsValidSingle(float x)","summary":"Determines whether a floatvalue is valid within the RhinoCommon context.  \\nRhino does not use Single.NaN by convention, so this test evaluates to True if:  \\nx is not equal to RhinoMath.UnsetValue,  \\nSystem.Single.IsNaN(x) evaluates to false  \\nSystem.Single.IsInfinity(x) evaluates to false","since":"5.0","parameters":[{"name":"x","summary":"floatnumber to test for validity."}],"returns":"True if the number if valid, False if the number is NaN, Infinity or Unset."},{"signature":"static double ParseNumber(string expression)","summary":"Evaluates command line math expression.","since":"6.0","returns":"result"},{"signature":"static double ToDegrees(double radians)","summary":"Convert an angle from radians to degrees.","since":"5.0","parameters":[{"name":"radians","summary":"Radians to convert (180 degrees equals pi radians)."}]},{"signature":"static double ToRadians(double degrees)","summary":"Convert an angle from degrees to radians.","since":"5.0","parameters":[{"name":"degrees","summary":"Degrees to convert (180 degrees equals pi radians)."}]},{"signature":"static bool TryParseNumber(string expression, out double result)","summary":"Evaluates command line math expression.","since":"6.0","returns":"True if successful otherwise false"},{"signature":"static double UnitScale(UnitSystem from, UnitSystem to)","summary":"Computes the scale factor for changing the measurements unit systems.","since":"5.0","parameters":[{"name":"from","summary":"The system to convert from."},{"name":"to","summary":"The system to convert measurements into."}],"returns":"A scale multiplier."}]},{"namespace":"Rhino","name":"RhinoWindow","dataType":"class","summary":"Represents the top level window in Rhino","baseclass":"System.Windows.Forms.IWin32Window","properties":[{"signature":"IntPtr Handle","since":"5.0","property":["get"]},{"signature":"bool InvokeRequired","summary":"See Control.InvokeRequired","since":"5.0","property":["get"]}],"methods":[{"signature":"void Invoke(Delegate method)","since":"5.0"}]},{"namespace":"Rhino.Runtime","name":"AdvancedSetting","dataType":"enum","summary":"Advanced setting Id","values":[{"signature":"UseNewDraftAngleAnalysisUi","summary":"UseNewDraftAngleAnalysisUi bool Value, defaults to true"},{"signature":"UseCompressionWhenSaving","summary":"Use compressed buffers when saving 3dm files. bool Value, defults to true"},{"signature":"TestAdvancedString","summary":"String value, defaults to \\"test string\\""},{"signature":"TestAdvancedInt","summary":"Integer value, defaults 123"},{"signature":"PdfOptionalContentGroups","summary":"How optional content should be included when exporting PDF files"},{"signature":"LeaveFloatingPanelsHiddenOnMac","summary":"Bool value used on Mac to satisfy a user request to hide floating stuff when a command starts and leave it hidden when the command ends.  This is False by default. https://mcneel.myjetbrains.com/youtrack/issue/RH-57945"},{"signature":"DisableFileWatchers","summary":"Disable file watchers, using to diagnose Mac Rhino mystery crashes https://mcneel.myjetbrains.com/youtrack/issue/RH-52805"}]},{"namespace":"Rhino.Runtime","name":"Analytics","dataType":"class","summary":"Provides tools for sending Google Analytics events using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details.","constructors":[{"signature":"Analytics(string TrackingID, string Name)","summary":"Construct Analytics class","since":"6.0","parameters":[{"name":"TrackingID","summary":"Google Analytics Tracking ID"},{"name":"Name","summary":"Name of Application. For example, \\"Ocelot\\". Do not include version numbers. Maps to Google Analytics parameter \'an\'"}]},{"signature":"Analytics(string TrackingID, string Name, string Platform, string InstallerId, string Version)","summary":"Construct Analytics class","since":"6.0","parameters":[{"name":"TrackingID","summary":"Google Analytics Tracking ID"},{"name":"Name","summary":"Name of Application. For example, \\"Ocelot\\". Do not include version numbers. Maps to Google Analytics parameter \'an\'"},{"name":"Platform","summary":"Platform application is running on. For example \\"Mac\\", \\"Windows\\". Again, don\'t include version numbers. Maps to Google Analytics parameter \'ai\'"},{"name":"InstallerId","summary":"App Installer Id. In Rhino, we use this to differentiate between different builds such as \\"WIP\\" and \\"Commercial\\". Maps to Google Analytics parameter \'aiid\'"},{"name":"Version","summary":"Application version string. Maps to Google Analytics parameter \'av\'"}]}],"properties":[{"signature":"static bool UsageStatisticsEnabled","summary":"Determine if user allows automatic data collection from Rhino","since":"6.0","property":["get"]},{"signature":"static Guid UserId","summary":"Returns a GUID that allows events to be aggregated by user. There is no way to determine who the end user is based on this GUID, unless the user tells you their ID.  On Windows, this uses the registry to store the ID.  On Mac, the Hardware UUID is used as the ID.","since":"6.0","property":["get"]},{"signature":"string AppInstallerId","summary":"App Installer Id. In Rhino, we use this to differentiate between different builds such as \\"WIP\\" and \\"Commercial\\". Maps to Google Analytics parameter \'aiid\'","since":"6.0","property":["get","set"]},{"signature":"string AppName","summary":"Name of Application. For example, \\"Ocelot\\". Do not include version numbers. Maps to Google Analytics parameter \'an\'","since":"6.0","property":["get","set"]},{"signature":"string AppPlatform","summary":"Platform application is running on. For example \\"Mac\\", \\"Windows\\". Again, don\'t include version numbers. Maps to Google Analytics parameter \'ai\'","since":"6.0","property":["get","set"]},{"signature":"string AppVersion","summary":"Application version string. Maps to Google Analytics parameter \'av\'","since":"6.0","property":["get","set"]},{"signature":"string GoogleAnalyticsTrackingID","summary":"Google Analytics Tracking ID","since":"6.0","property":["get","set"]}],"methods":[{"signature":"void Send(NameValueCollection data)","summary":"Advanced method for sending Google Analytics data. It is the caller\'s responsibility to make sure that all parameters passed will result in a valid Google Analytics hit. Failure to do so will result in Google Analytics ignoring your hit, and the caller will get no data. The Analytics class will populate data from the Application, the GoogleAnalyticsTrackingID, the User ID, and set the hit type \\"t\\" to \\"event\\". It also sets other information about the system.","since":"6.0","parameters":[{"name":"data","summary":"Name-Value pairs of data to send. Any valid Google Analytics Measurement Protocol parameter is allowed. No input validation is performed."}]},{"signature":"void Send(string Category)","summary":"Sends a Google Analytics event using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details.","since":"6.0","parameters":[{"name":"Category","summary":"Event category. We use the feature or subsystem, such as \\"installer\\" or \\"app\\" or \\"document\\" or \\"loft\\". Maps to the Google Analytics parameter \\"ec\\"."}]},{"signature":"void Send(string Category, string Action)","summary":"Sends a Google Analytics event using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details.","since":"6.0","parameters":[{"name":"Category","summary":"Event category. We use the feature or subsystem, such as \\"installer\\" or \\"app\\" or \\"document\\" or \\"loft\\". Maps to the Google Analytics parameter \\"ec\\"."},{"name":"Action","summary":"Event action. A verb: \\"open\\" or \\"start\\" or \\"option\\" Maps to the Google Analytics parameter \\"ea\\"."}]},{"signature":"void Send(string Category, string Action, string Label)","summary":"Sends a Google Analytics event using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details.","since":"6.0","parameters":[{"name":"Category","summary":"Event category. We use the feature or subsystem, such as \\"installer\\" or \\"app\\" or \\"document\\" or \\"loft\\". Maps to the Google Analytics parameter \\"ec\\"."},{"name":"Action","summary":"Event action. A verb: \\"open\\" or \\"start\\" or \\"option\\" Maps to the Google Analytics parameter \\"ea\\"."},{"name":"Label","summary":"Event label. Maps to the Google Analytics parameter \\"el\\"."}]},{"signature":"void Send(string Category, string Action, string Label, uint Value)","summary":"Sends a Google Analytics event using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details. This method is asyncrhonous and the return code is completely ignored. Validate the data you send","since":"6.0","parameters":[{"name":"Category","summary":"Event category. We use the feature or subsystem, such as \\"installer\\" or \\"app\\" or \\"document\\" or \\"loft\\". Maps to the Google Analytics parameter \\"ec\\"."},{"name":"Action","summary":"Event action. A verb: \\"open\\" or \\"start\\" or \\"option\\" Maps to the Google Analytics parameter \\"ea\\"."},{"name":"Label","summary":"Event label. Maps to the Google Analytics parameter \\"el\\"."},{"name":"Value","summary":"Event value. Maps to the Google Analytics parameter \\"ev\\"."}]}]},{"namespace":"Rhino.Runtime","name":"AssemblyResolver","dataType":"class","summary":"Assembly Resolver for the Rhino App Domain.","methods":[{"signature":"static void AddSearchFile(string file)","summary":"Register another file with the Assembly Resolver. File must be a .NET assembly, so it should probably be a dll, rhp or exe.","since":"5.0","parameters":[{"name":"file","summary":"Path of file to include during Assembly Resolver events."}]},{"signature":"static void AddSearchFolder(string folder)","summary":"Register a custom folder with the Assembly Resolver. Folders will be searched recursively, so this could potentially be a very expensive operation. If at all possible, you should consider only registering individual files.","since":"5.0","parameters":[{"name":"folder","summary":"Path of folder to include during Assembly Resolver events."}]}]},{"namespace":"Rhino.Runtime","name":"CommonObject","dataType":"class","summary":"Base class for .NET classes that wrap C++ unmanaged Rhino classes.","interfaces":["IDisposable","ISerializable"],"properties":[{"signature":"static bool PerformCorruptionTesting","summary":"Used to test ON_Object* pointers to see if they are a brep or mesh that is corrupt enough to crash Rhino.","since":"6.10","property":["get","set"]},{"signature":"bool Disposed","summary":"Indicates if this object has been disposed or the document it originally belonged to has been disposed.","since":"6.0","property":["get"]},{"signature":"bool HasUserData","summary":"Gets True if this class has any custom information attached to it through UserData.","since":"5.0","property":["get"]},{"signature":"bool IsDocumentControlled","summary":"If True this object may not be modified. Any properties or functions that attempt to modify this object when it is set to \\"IsReadOnly\\" will throw a NotSupportedException.","since":"5.0","property":["get"]},{"signature":"bool IsValid","summary":"Tests an object to see if it is valid.","since":"5.0","property":["get"]},{"signature":"UserDataList UserData","summary":"List of custom information that is attached to this class.","since":"5.0","property":["get"]},{"signature":"ArchivableDictionary UserDictionary","summary":"Dictionary of custom information attached to this class. The dictionary is actually user data provided as an easy to use sharable set of information.","since":"5.0","property":["get"]}],"methods":[{"signature":"static CommonObject FromBase64String(int archive3dm, int opennurbs, string base64Data)","summary":"Create a CommonObject instance from a Base64 encoded string. This is typically the values used when passing common objects around as JSON data","since":"7.0"},{"signature":"static CommonObject FromJSON(Dictionary<string,string> jsonDictionary)","summary":"Create a CommonObject instance from a JSON dictionary","since":"7.0"},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"void EnsurePrivateCopy()","summary":"If you want to keep a copy of this class around by holding onto it in a variable after a command completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can call this function as many times as you want.","since":"5.0"},{"signature":"void GetObjectData(SerializationInfo info, StreamingContext context)","summary":"Populates a System.Runtime.Serialization.SerializationInfo with the data needed to serialize the target object.","since":"5.0","parameters":[{"name":"info","summary":"The System.Runtime.Serialization.SerializationInfo to populate with data."},{"name":"context","summary":"The destination (see System.Runtime.Serialization.StreamingContext) for this serialization."}]},{"signature":"bool IsValidWithLog(out string log)","summary":"Determines if an object is valid. Also provides a report on errors if this object happens not to be valid.","since":"5.0","parameters":[{"name":"log","summary":"A textual log. This out parameter is assigned during this call."}],"returns":"True if this object is valid; False otherwise."},{"signature":"string ToJSON(SerializationOptions options)","summary":"Create a JSON string representation of this object","since":"7.0"}]},{"namespace":"Rhino.Runtime","name":"CorruptGeometryException","dataType":"class","summary":"Thrown when Rhino finds a brep or mesh that will cause a crash if used for calculations.","baseclass":"Exception","properties":[{"signature":"CommonObject CommonObject","summary":"Corrupt geometry .NET class","since":"6.10","property":["get","set"]},{"signature":"IntPtr Pointer","summary":"pointer to base geometry (ON_Object*)","since":"6.10","property":["get","set"]}]},{"namespace":"Rhino.Runtime","name":"DocumentCollectedException","dataType":"class","summary":"Represents the error that happen when a class user attempts to execute a modifying operation on an object that has been added to a document.","baseclass":"Exception","constructors":[{"signature":"DocumentCollectedException()","summary":"Initializes a new instance of the document controlled exception class.","since":"5.0"},{"signature":"DocumentCollectedException(string message)","summary":"Initializes a new instance of the document collected exception class.","since":"6.0","parameters":[{"name":"message","summary":"A more specific message."}]}]},{"namespace":"Rhino.Runtime","name":"HostUtils","dataType":"class","summary":"Contains static methods to deal with teh runtime environment.","properties":[{"signature":"static string ComputerSerialNumber","summary":"Gets the serial number of the computer running Rhino.","since":"6.0","property":["get"]},{"signature":"static uint CurrentOSLanguage","summary":"Get the current operating system language.","since":"6.8","property":["get"]},{"signature":"static Guid DeviceId","summary":"The DeviceId is a unique, stable ID that anonymously identifies the device that Rhino is running on. It is computed based on hardware information that should not change when the OS is upgraded, or if commonly modified hardware are added or removed from the computer. The machine-specific information is hashed using a cryptographic hash to make it anonymous.","since":"6.0","property":["get"]},{"signature":"static string DeviceName","summary":"Name of the computer running Rhino. If the computer is part of a Windows Domain, the computer name has \\"@[DOMAIN]\\" appended.","since":"6.0","property":["get"]},{"signature":"static string OperatingSystemBuildNumber","summary":"Returns Operating System Build Number \\"11763\\" | \\"7601\\" | ... | \\"Unknown\\"","since":"6.15","property":["get"]},{"signature":"static string OperatingSystemEdition","summary":"Returns Operating System Edition: \\"Professional\\" | \\"ServerDatacenter\\" | ... | \\"Unknown\\"","since":"6.15","property":["get"]},{"signature":"static string OperatingSystemInstallationType","summary":"Returns Operating System Installation Type: \\"Client\\" | \\"Server\\" | \\"Unknown\\"","since":"6.15","property":["get"]},{"signature":"static string OperatingSystemProductName","summary":"Returns Operating System Edition: \\"Professional\\" | \\"ServerDatacenter\\" | ... | \\"Unknown\\"","since":"6.15","property":["get"]},{"signature":"static string OperatingSystemVersion","summary":"Returns Operating System Version \\"6.1\\" | \\"6.3\\" | ... | \\"Unknown\\"","since":"6.15","property":["get"]},{"signature":"static bool RunningAsRhinoInside","summary":"Indicates whether Rhino is running inside another application. returns False if Rhino.exe is the top-level application. returns True if some other application is the top-level application.","since":"7.0","property":["get"]},{"signature":"static bool RunningInDarkMode","summary":"Returns True if the host operating system is in dark mode and Rhino supports dark mode.","since":"6.19","property":["get"]},{"signature":"static bool RunningInMono","summary":"Tests if this process is currently executing under the Mono runtime.","since":"5.0","property":["get"]},{"signature":"static bool RunningInRhino","summary":"Tests if RhinoCommon is currently executing inside of the Rhino.exe process. There are other cases where RhinoCommon could be running; specifically inside of Visual Studio when something like a windows form is being worked on in the resource editor or running stand-alone when compiled to be used as a version of OpenNURBS.","since":"5.0","property":["get"]},{"signature":"static bool RunningOnOSX","summary":"Tests if this process is currently executing on the Mac OSX platform.","since":"5.0","property":["get"]},{"signature":"static bool RunningOnWindows","summary":"Tests if this process is currently executing on the Windows platform.","since":"5.0","property":["get"]},{"signature":"static bool SendDebugToCommandLine","summary":"Gets or sets whether debug messages are printed to the command line.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static string AutoInstallPlugInFolder(bool currentUser)","summary":"Gets the auto install plug-in folder for machine or current user.","since":"6.0","parameters":[{"name":"currentUser","summary":"True if the query relates to the current user."}],"returns":"The full path to the revelant auto install plug-in directory."},{"signature":"static int CallFromCoreRhino(string task)","summary":"Don\'t change this function in ANY way unless you chat with Steve first! This function is called by Rhino on initial startup and the signature must be exact","since":"6.0"},{"signature":"static bool CheckForRdk(bool throwOnFalse, bool usePreviousResult)","summary":"Determines if the RDK is loaded.","since":"5.0","parameters":[{"name":"throwOnFalse","summary":"if the RDK is not loaded, then throws a  RdkNotLoadedException."},{"name":"usePreviousResult","summary":"if true, then the last result can be used instaed of performing a full check."}],"returns":"True if the RDK is loaded; False if the RDK is not loaded. Note that the  RdkNotLoadedExceptionwill hinder the retrieval of any return value."},{"signature":"static void ClearFpuExceptionStatus()","summary":"Clear FPU exception and busy flags (Intel assembly fnclex)","since":"6.0"},{"signature":"static int CreateCommands(IntPtr pPlugIn, Assembly pluginAssembly)","summary":"Parses a plugin and create all the commands defined therein.","since":"5.0","parameters":[{"name":"pPlugIn","summary":"Plugin to harvest for commands."},{"name":"pluginAssembly","summary":"Assembly associated with the plugin."}],"returns":"The number of newly created commands."},{"signature":"static void CreateCommands(PlugIn plugin)","summary":"Parses a plugin and create all the commands defined therein.","since":"5.0","parameters":[{"name":"plugin","summary":"Plugin to harvest for commands."}]},{"signature":"static PlugIn CreatePlugIn(Type pluginType, bool printDebugMessages)","summary":"Instantiates a plug-in type and registers the associated commands and classes.","since":"5.0","parameters":[{"name":"pluginType","summary":"A plug-in type. This type must derive from PlugIn."},{"name":"printDebugMessages","summary":"True if debug messages should be printed."}],"returns":"A new plug-in instance."},{"signature":"static string DebugDumpToString(BezierCurve bezierCurve)","summary":"Gets the debug dumps. This is a text description of the geometric contents. DebugDump() is intended for debugging and is not suitable for creating high quality text descriptions of an object.","since":"5.0","parameters":[{"name":"bezierCurve","summary":"curve to evaluate"}],"returns":"A debug dump text."},{"signature":"static string DebugDumpToString(GeometryBase geometry)","summary":"Gets the debug dumps. This is a text description of the geometric contents. DebugDump() is intended for debugging and is not suitable for creating high quality text descriptions of an object.","since":"5.0","parameters":[{"name":"geometry","summary":"Some geometry."}],"returns":"A debug dump text."},{"signature":"static void DebugString(string msg)","summary":"Prints a debug message to the Rhino Command Line. The message will only appear if the SendDebugToCommandLine property is set to true.","since":"5.0","parameters":[{"name":"msg","summary":"Message to print."}]},{"signature":"static void DebugString(string format, params object[] args)","summary":"Prints a debug message to the Rhino Command Line. The message will only appear if the SendDebugToCommandLine property is set to true.","since":"5.0","parameters":[{"name":"format","summary":"Message to format and print."},{"name":"args","summary":"An Object array containing zero or more objects to format."}]},{"signature":"static void DisplayOleAlerts(bool display)","summary":"Defines if Ole alerts (\\"Server busy\\") alerts should be visualized.  \\nThis function makes no sense on Mono.","since":"5.0","parameters":[{"name":"display","summary":"Whether alerts should be visible."}]},{"signature":"static void ExceptionReport(Exception ex)","summary":"Informs RhinoCommon of an exception that has been handled but that the developer wants to screen.","since":"5.0","parameters":[{"name":"ex","summary":"An exception."}]},{"signature":"static void ExceptionReport(string source, Exception ex)","summary":"Informs RhinoCommon of an exception that has been handled but that the developer wants to screen.","since":"5.0","parameters":[{"name":"source","summary":"An exception source text."},{"name":"ex","summary":"An exception."}]},{"signature":"static bool ExecuteNamedCallback(string name, NamedParametersEventArgs args)","summary":"Execute a named callback","since":"7.0"},{"signature":"static bool FileNameEndsWithRhinoBackupExtension(string fileName)","summary":"Strip file extension from file name and check to see if it is a valid Rhino backup file extension.","since":"6.0","parameters":[{"name":"fileName","summary":"File name to check."}],"returns":"Returns True if the file name has an extension like 3dmbak."},{"signature":"static bool FileNameEndsWithRhinoExtension(string fileName)","summary":"Strip file extension from file name and check to see if it is a valid Rhino file extension.","since":"6.0","parameters":[{"name":"fileName","summary":"File name to check."}],"returns":"Returns True if the file name has an extension like 3dm."},{"signature":"static bool GetAbsolutePath(string relativePath, bool bRelativePathisFileName, string relativeTo, bool bRelativeToIsFileName, out string pathOut)","summary":"Call this method to convert a relative path to an absolute path relative to the specified path.","since":"6.0","parameters":[{"name":"relativePath","summary":"Relative path to convert to an absolute path"},{"name":"bRelativePathisFileName","summary":"If True then lpsFrom is treated as a file name otherwise it is treated as a directory name"},{"name":"relativeTo","summary":"File or folder the path is relative to"},{"name":"bRelativeToIsFileName","summary":"If True then lpsFrom is treated as a file name otherwise it is treated as a directory name"},{"name":"pathOut","summary":"Reference to string which will receive the computed absolute path"}],"returns":"Returns True if parameters are valid and lpsRelativePath is indeed relative to lpsRelativeTo otherwise returns false"},{"signature":"static IEnumerable<System.IO.DirectoryInfo> GetActivePlugInVersionFolders(bool currentUser)","summary":"Recurses through the auto install plug-in folders and returns the directories containing \\"active\\" versions of plug-ins.","since":"6.0","parameters":[{"name":"currentUser","summary":"Current user (true) or machine (false)."}]},{"signature":"static string[] GetAssemblySearchPaths()","summary":"Returns list of directory names where additional assemblies (plug-ins, DLLs, Grasshopper components) may be located","since":"5.0"},{"signature":"static void GetCurrentProcessInfo(out string processName, out Version processVersion)","summary":"Returns information about the current process. If Rhino is the top level process, processName is \\"Rhino\\". Otherwise, processName is the name, without extension, of the main module that is executing. For example, \\"compute.backend\\" or \\"Revit\\".  processVersion is the System.Version of the running process. It is the FileVersion of the executable.","since":"6.15"},{"signature":"static Tuple<string, Type>[] GetCustomComputeEndpoints()","summary":"Used by compute to define custom endpoints","since":"7.0"},{"signature":"static T GetPlatformService(string assemblyPath, string typeFullName)","summary":"For internal use only. Loads an assembly for dependency injection via IPlatformServiceLocator.","since":"6.0","parameters":[{"name":"assemblyPath","summary":"The relative path of the assembly, relative to the position of RhinoCommon.dll"},{"name":"typeFullName","summary":"The full name of the type that is IPlatformServiceLocator. This is optional."}],"returns":"An instance, or null."},{"signature":"static System.Reflection.Assembly GetRhinoDotNetAssembly()","summary":"Only works on Windows. Returns None on Mac.","since":"5.0","returns":"An assembly."},{"signature":"static void InitializeRhinoCommon()","summary":"Makes sure all static RhinoCommon components is set up correctly. This happens automatically when a plug-in is loaded, so you probably won\'t have to call this method.","since":"5.0"},{"signature":"static void InitializeRhinoCommon_RDK()","summary":"Makes sure all static RhinoCommon RDK components are set up correctly. This happens automatically when the RDK is loaded, so you probably won\'t have to call this method.","since":"6.0"},{"signature":"static void InitializeZooClient()","summary":"Initializes the ZooClient and Rhino license manager, this should get called automatically when RhinoCommon is loaded so you probably won\'t have to call this method.","since":"5.6"},{"signature":"static void InPlaceConstCast(GeometryBase geometry, bool makeNonConst)","summary":"DO NOT USE UNLESS YOU ARE CERTAIN ABOUT THE IMPLICATIONS.  \\nThis is an expert user function which should not be needed in most cases. This function is similar to a const_cast in C++ to allow an object to be made temporarily modifiable without causing RhinoCommon to convert the class from const to non-const by creating a duplicate.  \\nYou must call this function with a True parameter, make your modifications, and then restore the const flag by calling this function again with a False parameter. If you have any questions, please contact McNeel developer support before using!","since":"5.0","parameters":[{"name":"geometry","summary":"Some geometry."},{"name":"makeNonConst","summary":"A boolean value."}]},{"signature":"static bool IsManagedDll(string path)","summary":"Inspects a dll to see if it is compiled as native code or as a .NET assembly","since":"6.0"},{"signature":"static bool IsRhinoBackupFileExtension(string fileExtension)","summary":"Check to see if the file extension is a valid Rhino file extension.","since":"6.0","returns":"Return True if fileExtension is \\".3dmbak\\", \\"3dmbak\\", \\".3dm.bak\\", \\"3dm.bak\\", \\".3dx.bak\\" or \\"3dx.bak\\", ignoring case."},{"signature":"static bool IsRhinoFileExtension(string fileExtension)","summary":"Check to see if the file extension is a valid Rhino file extension.","since":"6.0","returns":"Returns True if fileExtension is \\".3dm\\", \\"3dm\\", \\".3dx\\" or \\"3dx\\", ignoring case."},{"signature":"static void RecordInitInstanceTime(string description)","summary":"Used to help record times at startup with the -stopwatch flag to help determine bottlenecks in start up speed","since":"6.0"},{"signature":"static void RegisterComputeEndpoint(string endpointPath, Type t)","summary":"Register a class that can participate as a compute endpoint","since":"7.0"},{"signature":"static bool RegisterDynamicCommand(PlugIn plugin, Command cmd)","summary":"Adds a new dynamic command to Rhino.","since":"5.0","parameters":[{"name":"plugin","summary":"Plugin that owns the command."},{"name":"cmd","summary":"Command to add."}],"returns":"True on success, False on failure."},{"signature":"static void RegisterNamedCallback(string name, EventHandler<NamedParametersEventArgs> callback)","summary":"Register a named callback","since":"6.15"},{"signature":"static void RhinoCommonExceptionHandler(string title, object sender, Exception ex)","summary":"For internal use only!!! Unhanded exception handler, writes stack trace to RhinoDotNet.txt file","since":"6.0","parameters":[{"name":"title","summary":"Exception title to write to text file"},{"name":"sender","summary":""},{"name":"ex","summary":""}]},{"signature":"static void SendLogMessageToCloudCallbackProc(LogMessageType msg_type, IntPtr pwStringClass, IntPtr pwStringDesc, IntPtr pwStringMessage)","summary":"Informs RhinoCommon of an message that has been handled but that the developer wants to screen.","since":"6.4","parameters":[{"name":"msg_type","summary":"The messag type"},{"name":"pwStringClass","summary":"The top level message type."},{"name":"pwStringDesc","summary":"Finer grained description of the message."},{"name":"pwStringMessage","summary":"The message."}]},{"signature":"static void SetInShutDown()","summary":"Informs the runtime that the application is shutting down.","since":"5.0"},{"signature":"static void ShutDownRhinoCommon_RDK()","summary":"Makes sure all static RhinoCommon RDK components are de-initialized so they aren\'t calling into space when the RDK is unloaded.","since":"6.0"},{"signature":"static void UnhandledThreadException(object sender, ThreadExceptionEventArgs e)","summary":"Exception handler for exceptions occurring on the UI thread","since":"6.0"}]},{"namespace":"Rhino.Runtime","name":"HostUtils.LogMessageType","dataType":"enum","summary":"Represents the type of message that is being sent to the OnSendLogMessageToCloud event","since":"6.4","values":[{"signature":"unknown = 0","summary":"Unknown message type"},{"signature":"information = 1","summary":"Message is informational only"},{"signature":"warning = 2","summary":"Message is a warning"},{"signature":"error = 3","summary":"Message is an error"},{"signature":"assert = 4","summary":"Message is a debug ASSERT"}]},{"namespace":"Rhino.Runtime","name":"ImportOptionsSections","dataType":"enum","summary":"Standard CRhImportOptions sections to import","values":[{"signature":"AdvancedDisplay = 0"},{"signature":"Alias"},{"signature":"Appearance"},{"signature":"ChooseOneObject"},{"signature":"ControlPointContextMenu"},{"signature":"CursorToolTip"},{"signature":"Display"},{"signature":"File"},{"signature":"General"},{"signature":"Grid"},{"signature":"ModelAid"},{"signature":"Mouse"},{"signature":"NeverRepeatCommands"},{"signature":"ObjectContextMenu"},{"signature":"SearchPath"},{"signature":"ShortcutKey"},{"signature":"Smarttrack"},{"signature":"View"},{"signature":"ViewportContextMenu"},{"signature":"ToolPaletteSettings","summary":"Tool palette settings for Mac, ignored for Windows"},{"signature":"Count","summary":"Must always be the last item"}]},{"namespace":"Rhino.Runtime.InProcess","name":"RhinoCore","dataType":"class","summary":"Represents an instance of RhinoCore.DLL.","interfaces":["IDisposable"],"constructors":[{"signature":"RhinoCore()","summary":"Initializes a new instance of the RhinoCoreclass.","since":"7.0"},{"signature":"RhinoCore(string[] args)","summary":"Initializes a new instance of the RhinoCoreclass.","since":"7.0","parameters":[{"name":"args","summary":"Rhino command line parameters"}]},{"signature":"RhinoCore(string[] args, WindowStyle windowStyle)","summary":"Initializes a new instance of the RhinoCoreclass.","since":"7.0","parameters":[{"name":"args","summary":"Rhino command line parameters"},{"name":"windowStyle","summary":"Rhino main window initial style"}]},{"signature":"RhinoCore(string[] args, WindowStyle windowStyle, IntPtr hostWnd)","summary":"Initializes a new instance of the RhinoCoreclass.","since":"7.0","parameters":[{"name":"args","summary":"Rhino command line parameters"},{"name":"windowStyle","summary":"Rhino main window initial style"},{"name":"hostWnd","summary":"Host main window OS native handle"}]}],"methods":[{"signature":"void Dispose()","summary":"IDisposable implementation","since":"7.0"},{"signature":"bool DoEvents()","summary":"If a Rhino owned window is active processes all Windows messages currently in the message queue.","since":"7.0","returns":"Returns True if a Rhino owned window is still active or Idle tasks are pending."},{"signature":"bool DoIdle()","summary":"Processes all Rhino Idle tasks.","since":"7.0","returns":"True if Idle tasks are still pending."},{"signature":"void InvokeInHostContext(Action action)","summary":"Invokes action in Host context","since":"7.0"},{"signature":"T InvokeInHostContext(Func<T> func)","summary":"Invokes function in Host context","since":"7.0","returns":"Returns argument function return value."},{"signature":"void RaiseIdle()","summary":"Raises the Idle event.","since":"7.0"},{"signature":"int Run()","summary":"Runs RhinoApp Message loop","since":"7.0"}]},{"namespace":"Rhino.Runtime.InProcess","name":"WindowStyle","dataType":"enum","summary":"Specified how a new window should appear when Rhino starts.","since":"7.0","values":[{"signature":"NoWindow = -1","summary":"The no window style."},{"signature":"Normal = 0","summary":"The normal, visible window style."},{"signature":"Hidden = 1","summary":"The hidden window style."},{"signature":"Minimized = 2","summary":"The minimized window style."},{"signature":"Maximized = 3","summary":"The maximized window style."}]},{"namespace":"Rhino.Runtime","name":"Interop","dataType":"class","summary":"Contains static methods to marshal objects between RhinoCommon and legacy Rhino_DotNet or C++.","methods":[{"signature":"static Geometry.GeometryBase CreateFromNativePointer(IntPtr pGeometry)","summary":"Constructs a RhinoCommon Geometry class from a given ON_Geomety*. The ON_Geometry* must be declared on the heap and its lifetime becomes controlled by RhinoCommon.","since":"5.0","parameters":[{"name":"pGeometry","summary":"ON_Geometry*"}],"returns":"The appropriate geometry class in RhinoCommon on success."},{"signature":"static IntPtr FileReadOptionsConstPointer(FileReadOptions options)","summary":"Returns the underlying const CRhinoFileReadOptions* for a Rhino.FileIO.FileReadOptions object. You should only be interested in using this function if you are writing C++ code.","since":"6.0","parameters":[{"name":"options","summary":"A FileReadOptions object."}],"returns":"A pointer to the Rhino const object."},{"signature":"static IntPtr FileWriteOptionsConstPointer(FileWriteOptions options)","summary":"Returns the underlying const CRhinoFileWriteOptions* for a Rhino.FileIO.FileWriteOptions object. You should only be interested in using this function if you are writing C++ code.","since":"6.0","parameters":[{"name":"options","summary":"A FileWriteOptions object."}],"returns":"A pointer to the Rhino const object."},{"signature":"static DocObjects.Font FontFromPointer(IntPtr ptrManagedFont)","summary":"Create managed Font from native ON_Font*","since":"6.0"},{"signature":"static Geometry.Brep FromOnBrep(object source)","summary":"Copies a Rhino_DotNet brep to a RhinoCommon brep class.","since":"5.0","parameters":[{"name":"source","summary":"RMA.OpenNURBS.IOnBrep or RMA.OpenNURBS.OnBrep."}],"returns":"RhinoCommon object on success. This will be an independent copy."},{"signature":"static Geometry.Curve FromOnCurve(object source)","summary":"Copies a Rhino_DotNet curve to a RhinoCommon curve class.","since":"5.0","parameters":[{"name":"source","summary":"RMA.OpenNURBS.IOnCurve or RMA.OpenNURBS.OnCurve."}],"returns":"RhinoCommon object on success. This will be an independent copy."},{"signature":"static Geometry.Mesh FromOnMesh(object source)","summary":"Copies a Rhino_DotNet mesh to a RhinoCommon mesh class.","since":"5.0","parameters":[{"name":"source","summary":"RMA.OpenNURBS.IOnMesh or RMA.OpenNURBS.OnMesh."}],"returns":"RhinoCommon object on success. This will be an independent copy."},{"signature":"static Geometry.Surface FromOnSurface(object source)","summary":"Copies a Rhino_DotNet surface to a RhinoCommon Surface class.","since":"5.0","parameters":[{"name":"source","summary":"Any of the following in the RMA.OpenNURBS namespace are acceptable. IOnSurface, OnSurface, IOnPlaneSurface, OnPlaneSurface, IOnClippingPlaneSurface, OnClippingPlaneSurface, IOnNurbsSurface, OnNurbsSurfac, IOnRevSurface, OnRevSurface, IOnSumSurface, OnSumSurface."}],"returns":"RhinoCommon object on success. This will be an independent copy."},{"signature":"static IntPtr NativeGeometryConstPointer(GeometryBase geometry)","summary":"Returns the underlying const ON_Geometry* for a RhinoCommon class. You should only be interested in using this function if you are writing C++ code.","since":"5.0","parameters":[{"name":"geometry","summary":"A geometry object. This can be None and in such a case IntPtr.Zerois returned."}],"returns":"A pointer to the const geometry."},{"signature":"static IntPtr NativeGeometryNonConstPointer(GeometryBase geometry)","summary":"Returns the underlying non-const ON_Geometry* for a RhinoCommon class. You should only be interested in using this function if you are writing C++ code.","since":"5.0","parameters":[{"name":"geometry","summary":"A geometry object. This can be None and in such a case IntPtr.Zerois returned."}],"returns":"A pointer to the non-const geometry."},{"signature":"static IntPtr NativeNonConstPointer(DisplayPipeline pipeline)","summary":"Get CRhinoDisplayPipeline* for a DisplayPipeline instance","since":"6.0"},{"signature":"static IntPtr NativeNonConstPointer(GetPoint getPoint)","summary":"Get CRhinoGetPoint* from a GetPoint instance","since":"6.0"},{"signature":"static IntPtr NativeNonConstPointer(RhinoViewport viewport)","summary":"Get CRhinoViewport* from a RhinoViewport instance","since":"6.0"},{"signature":"static IntPtr NativeNonConstPointer(ViewCaptureSettings settings)","summary":"Get a CRhinoPrintInfo* for a given ViewCaptureSettings class","since":"6.0"},{"signature":"static IntPtr NativeNonConstPointer(ViewportInfo viewport)","summary":"Get ON_Viewport* from a ViewportInfo instance","since":"5.1"},{"signature":"static IntPtr NativeRhinoDocPointer(RhinoDoc doc)","summary":"Gets the C++ CRhinoDoc* for a given RhinoCommon RhinoDoc class.","since":"5.0","parameters":[{"name":"doc","summary":"A document."}],"returns":"A pointer value."},{"signature":"static IntPtr NSFontFromFont(Font font)","summary":"Get native NSFont* from a Rhino Font. Only works on Mac","since":"6.9","returns":"NSFont* on success. IntPtr.Zero on failure"},{"signature":"static IntPtr NSFontFromFont(Font font, double pointSize)","summary":"Get native NSFont* from a Rhino Font. Only works on Mac","since":"6.9","parameters":[{"name":"font","summary":""},{"name":"pointSize","summary":"Point size"}],"returns":"NSFont* on success. IntPtr.Zero on failure"},{"signature":"static IntPtr PlugInPointer(PlugIn plugin)","summary":"Gets a C++ plug-in pointer for a given RhinoCommon plug-in.  \\nThis is a Rhino SDK function.","since":"5.0","parameters":[{"name":"plugin","summary":"A plug-in."}],"returns":"A pointer."},{"signature":"static IntPtr RhinoObjectConstPointer(RhinoObject rhinoObject)","summary":"Returns the underlying const CRhinoObject* for a RhinoCommon class. You should only be interested in using this function if you are writing C++ code.","since":"5.0","parameters":[{"name":"rhinoObject","summary":"A Rhino object."}],"returns":"A pointer to the Rhino const object."},{"signature":"static DocObjects.RhinoObject RhinoObjectFromPointer(IntPtr pRhinoObject)","summary":"Constructs a RhinoCommon Rhino object from an unmanaged C++ RhinoObject pointer.","since":"5.0","parameters":[{"name":"pRhinoObject","summary":"The original pointer."}],"returns":"A new Rhino object, or None if the pointer was invalid or IntPtr.Zero."},{"signature":"static object ToIRhinoViewport(RhinoViewport source)","summary":"Convert a Rhino.Display.Viewport to an RMA.Rhino.IRhinoViewport.","since":"5.0","parameters":[{"name":"source","summary":"A RhinoCommon viewport."}],"returns":"Rhino_DotNet IRhinoViewport object on success. This will be an independent copy."},{"signature":"static object ToOnBrep(Brep source)","summary":"Constructs a Rhino_DotNet OnBrep that is a copy of a given brep.","since":"5.0","parameters":[{"name":"source","summary":"A source brep."}],"returns":"Rhino_DotNet object on success. This will be an independent copy."},{"signature":"static object ToOnCurve(Curve source)","summary":"Constructs a Rhino_DotNet OnCurve that is a copy of a given curve.","since":"5.0","parameters":[{"name":"source","summary":"A RhinoCommon source curve."}],"returns":"Rhino_DotNet object on success. This will be an independent copy."},{"signature":"static object ToOnMesh(Mesh source)","summary":"Constructs a Rhino_DotNet OnMesh that is a copy of a given mesh.","since":"5.0","parameters":[{"name":"source","summary":"A source brep."}],"returns":"Rhino_DotNet object on success. This will be an independent copy."},{"signature":"static object ToOnSurface(Surface source)","summary":"Constructs a Rhino_DotNet OnSurface that is a copy of a given curve.","since":"5.0","parameters":[{"name":"source","summary":"A source brep."}],"returns":"Rhino_DotNet object on success. This will be an independent copy."},{"signature":"static object ToOnXform(Transform source)","summary":"Constructs a Rhino_DotNet OnXform from a given RhinoCommon Transform.","since":"5.0","parameters":[{"name":"source","summary":"A RhinoCommon source transform."}],"returns":"Rhino_DotNet object on success. This will be an independent copy."},{"signature":"static bool TryCopyFromOnArc(object source, out Arc destination)","summary":"Attempts to copy the contents of a RMA.OpenNURBS.OnArc to a Rhino.Geometry.Arc.","since":"5.0","parameters":[{"name":"source","summary":"A source OnArc."},{"name":"destination","summary":"A destination arc."}],"returns":"True if the operation succeeded; False otherwise."},{"signature":"static bool TryCopyToOnArc(Arc source, object destination)","summary":"Attempts to copy the contents of a Rhino.Geometry.Arc to a RMA.OpenNURBS.OnArc.","since":"5.0","parameters":[{"name":"source","summary":"A source arc."},{"name":"destination","summary":"A destination OnArc."}],"returns":"True if the operation succeeded; False otherwise."},{"signature":"static Display.ViewCaptureSettings ViewCaptureFromPointer(IntPtr ptrViewCapture)","summary":"Create a ViewCaptureSettings class from a native const CRhinoPrintInfo* The pointer values are copied","since":"6.0"}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"ClassArrayObjRef","dataType":"class","summary":"Represents a wrapper to an unmanaged \\"array\\" (list) of CRhinoObjRef instances.  \\nWrapper for a C++ ON_ClassArray of CRhinoObjRef","interfaces":["IDisposable"],"constructors":[{"signature":"ClassArrayObjRef()","summary":"Initializes a new ClassArrayObjRefinstance.","since":"5.0"},{"signature":"ClassArrayObjRef(IEnumerable<ObjRef> objrefs)","summary":"Initializes a new instances from a set of ObjRefs","since":"5.0","parameters":[{"name":"objrefs","summary":"An array, a list or any enumerable set of Rhino object references."}]}],"properties":[{"signature":"int Count","summary":"Gets the number of CRhinoObjRef instances in this array.","since":"5.0","property":["get"]}],"methods":[{"signature":"void Add(ObjRef objref)","summary":"Adds an ObjRef to the list.","since":"5.0","parameters":[{"name":"objref","summary":"An ObjRef to add."}]},{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"5.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"5.0","returns":"The non-constant pointer."},{"signature":"Rhino.DocObjects.ObjRef[] ToNonConstArray()","summary":"Copies the unmanaged array to a managed counterpart.","since":"5.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"ClassArrayOnObjRef","dataType":"class","summary":"Represents a wrapper to an unmanaged \\"array\\" (list) of ON_ObjRef instances.  \\nWrapper for a C++ ON_ClassArray of ON_ObjRef","interfaces":["IDisposable"],"constructors":[{"signature":"ClassArrayOnObjRef()","summary":"Initializes a new ClassArrayOnObjRefinstance.","since":"5.8"},{"signature":"ClassArrayOnObjRef(IEnumerable<ObjRef> objrefs)","summary":"Initializes a new instances from a set of ObjRefs","since":"5.8","parameters":[{"name":"objrefs","summary":"An array, a list or any enumerable set of Rhino object references."}]}],"properties":[{"signature":"int Count","summary":"Gets the number of ObjRef instances in this array.","since":"5.8","property":["get"]}],"methods":[{"signature":"void Add(ObjRef objref)","summary":"Adds an ObjRef to the list.","since":"5.8","parameters":[{"name":"objref","summary":"An ObjRef to add."}]},{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"5.8","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.8"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"5.8","returns":"The non-constant pointer."},{"signature":"DocObjects.ObjRef[] ToNonConstArray()","summary":"Copies the unmanaged array to a managed counterpart.","since":"5.8","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"ClassArrayString","dataType":"class","summary":"Wrapper for a C++ ON_ClassArray<ON_wString> If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"ClassArrayString()","summary":"Initializes a new ClassArrayStringinstance.","since":"6.0"}],"properties":[{"signature":"int Count","summary":"Gets the number of strings in this array.","since":"6.0","property":["get"]}],"methods":[{"signature":"void Add(string s)","summary":"Adds a string to the list.","since":"6.0","parameters":[{"name":"s","summary":"A string to add."}]},{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"6.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"6.0","returns":"The non-constant pointer."},{"signature":"string[] ToArray()","summary":"Copies the unmanaged array to a managed counterpart.","since":"6.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"CurveSegment","dataType":"struct","summary":"For internal use only.","properties":[{"signature":"int Index","summary":"The index of the curve used by this boundary element.","since":"7.0","property":["get"]},{"signature":"bool Reversed","summary":"True if this piece of the curve should be reversed.","since":"7.0","property":["get"]},{"signature":"Interval SubDomain","summary":"The sub-domain of the curve used by this boundary element.","since":"7.0","property":["get"]}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"MeshPointDataStruct","dataType":"struct","summary":"This is only needed when passing values to the Rhino C++ core, ignore for .NET plug-ins."},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArray2dex","dataType":"class","summary":"Wrapper for ON_SimpleArray<ON_2dex>. If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArray2dex()","summary":"Initializes a new SimpleArray2dexclass.","since":"6.0"},{"signature":"SimpleArray2dex(IEnumerable<IndexPair> values)","summary":"Initializes a new SimpleArray2dexclass","since":"6.0","parameters":[{"name":"values","summary":"initial set of integer pairs to add to the array"}]}],"properties":[{"signature":"int Count","summary":"Gets the amount of elements in this array.","since":"6.0","property":["get"]}],"methods":[{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"6.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"6.0","returns":"The non-constant pointer."},{"signature":"IndexPair[] ToArray()","summary":"Returns the managed counterpart of the unmanaged array.","since":"6.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayArrayPoint3d","dataType":"class","summary":"Wrapper for ON_SimpleArray<ON_PolyLine*>, ON_SimpleArray<ON_3dPointArray*> If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayArrayPoint3d()","summary":"Initializes a new empty SimpleArrayArrayPoint3dinstance.","since":"7.0"}],"properties":[{"signature":"int Count","summary":"Gets the amount of polylines in this array.","since":"7.0","property":["get"]}],"methods":[{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"7.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"7.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"7.0","returns":"The non-constant pointer."},{"signature":"int PointCountAt(int index)","summary":"Gets the amount of points in a polyline.","since":"7.0"}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayBinaryArchiveReader","dataType":"class","summary":"Wrapper for ON_SimpleArray<ON_BinaryArchive>. If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayBinaryArchiveReader()","summary":"Initializes a new SimpleArrayBinaryArchiveReaderclass.","since":"6.0"},{"signature":"SimpleArrayBinaryArchiveReader(IntPtr p)","summary":"Initializes a new SimpleArrayBinaryArchiveReaderclass.","since":"6.0"}],"properties":[{"signature":"int Count","summary":"Gets the amount of elements in this array.","since":"6.0","property":["get"]}],"methods":[{"signature":"void Add(BinaryArchiveReader reader)","summary":"Adds a new Intervalat the end of this array.","since":"6.0"},{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"6.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"},{"signature":"BinaryArchiveReader Get(int index)","summary":"Get the Guid at index","since":"6.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"6.0","returns":"The non-constant pointer."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayBrepPointer","dataType":"class","summary":"Wrapper for a C++ ON_SimpleArray<ON_Brep*> or ON_SimpleArray<constant ON_Brep*> If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayBrepPointer()","summary":"Initializes a new SimpleArrayBrepPointerinstance.","since":"5.0"}],"properties":[{"signature":"int Count","summary":"Gets the amount of breps in this array.","since":"5.0","property":["get"]}],"methods":[{"signature":"void Add(Brep brep, bool asConst)","summary":"Adds a brep to the list.","since":"5.0","parameters":[{"name":"brep","summary":"A brep to add."},{"name":"asConst","summary":"Whether this brep should be treated as non-modifiable."}]},{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"5.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"5.0","returns":"The non-constant pointer."},{"signature":"Geometry.Brep[] ToNonConstArray()","summary":"Copies the unmanaged array to a managed counterpart.","since":"5.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayByte","dataType":"class","summary":"Wrapper for ON_SimpleArray<unsigned char>. If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayByte()","summary":"Initializes a new SimpleArrayByteclass.","since":"7.0"},{"signature":"SimpleArrayByte(IEnumerable<byte> values)","summary":"Initializes a new SimpleArrayByteclass","since":"7.0","parameters":[{"name":"values","summary":"initial set of integers to add to the array"}]},{"signature":"SimpleArrayByte(int initialSize)","summary":"Initializes a new SimpleArrayByteclass. Initial size of the array - all values are set to zero.","since":"7.0","parameters":[{"name":"initialSize","summary":"Initial size of the array - all values are set to zero."}]},{"signature":"SimpleArrayByte(SimpleArrayByte other)","summary":"Initializes a new SimpleArrayBytewith the contents of another SimpleArrayByte.","since":"7.0"}],"properties":[{"signature":"int Count","summary":"Gets the amount of elements in this array.","since":"7.0","property":["get"]}],"methods":[{"signature":"IntPtr Array()","summary":"Return the raw data.","since":"7.0"},{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"7.0","returns":"The constant pointer."},{"signature":"void CopyTo(SimpleArrayByte other)","summary":"Copies the contents of a SimpleArrayByteinto another SimpleArrayByte.","since":"7.0"},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"7.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"7.0","returns":"The non-constant pointer."},{"signature":"byte[] ToArray()","summary":"Returns the managed counterpart of the unmanaged array.","since":"7.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayClippingPlaneObjectPointer","dataType":"class","summary":"ON_SimpleArray of CRhinoClippingPlaneObject*","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayClippingPlaneObjectPointer()","summary":"Initializes a new SimpleArrayClippingPlaneObjectPointerinstance.","since":"6.7"}],"properties":[{"signature":"int Count","summary":"Gets the amount of clipping planes in this array.","since":"6.7","property":["get"]}],"methods":[{"signature":"void Add(ClippingPlaneObject clippingplane, bool asConst)","summary":"Adds a clipping plane to the list.","since":"6.7","parameters":[{"name":"clippingplane","summary":"A clipping plane to add."},{"name":"asConst","summary":"Whether this clipping plane should be treated as non-modifiable."}]},{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"6.7","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.7"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"6.7","returns":"The non-constant pointer."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayCurvePointer","dataType":"class","summary":"Wrapper for a C++ ON_SimpleArray of ON_Curve* or constant ON_Curve*.  If you are not writing C++ code, then you can ignore this class.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayCurvePointer()","summary":"Initializes a new SimpleArrayCurvePointerinstance.","since":"5.0"},{"signature":"SimpleArrayCurvePointer(IEnumerable<Curve> curves)","summary":"Initializes a new SimpleArrayCurvePointerinstance, from a set of input curves.","since":"5.0","parameters":[{"name":"curves","summary":"A list, an array or any collection of curves that implements the enumerable interface."}]}],"methods":[{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"5.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"5.0","returns":"The non-constant pointer."},{"signature":"Curve[] ToNonConstArray()","summary":"Copies the unmanaged array to a managed counterpart.","since":"5.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayDouble","dataType":"class","summary":"Wrapper for ON_SimpleArray<double>. If you are not writing C++ code, then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayDouble()","summary":"Initializes a new SimpleArrayDoubleinstance.","since":"5.0"},{"signature":"SimpleArrayDouble(IEnumerable<double> items)","summary":"Initializes a new SimpleArrayDoubleinstance, with items.","since":"5.0"}],"properties":[{"signature":"int Count","summary":"Gets the amount of elements in this array.","since":"5.0","property":["get"]}],"methods":[{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"5.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"5.0","returns":"The non-constant pointer."},{"signature":"double[] ToArray()","summary":"Returns the managed counterpart of the unmanaged array.","since":"5.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayExtrusionPointer","dataType":"class","summary":"Wrapper for a C++ ON_SimpleArray<ON_Extrusion*> or ON_SimpleArray<constant ON_Extrusion*> If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayExtrusionPointer()","summary":"Initializes a new SimpleArrayExtrusionPointerinstance.","since":"6.0"}],"properties":[{"signature":"int Count","summary":"Gets the amount of Extrusions in this array.","since":"6.0","property":["get"]}],"methods":[{"signature":"void Add(Extrusion extrusion, bool asConst)","summary":"Adds a extrusion to the list.","since":"6.0","parameters":[{"name":"extrusion","summary":"A extrusion to add."},{"name":"asConst","summary":"Whether this extrusion should be treated as non-modifiable."}]},{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"6.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"6.0","returns":"The non-constant pointer."},{"signature":"Geometry.Extrusion[] ToNonConstArray()","summary":"Copies the unmanaged array to a managed counterpart.","since":"6.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayFloat","dataType":"class","summary":"Wrapper for ON_SimpleArray<float>. If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayFloat()","summary":"Initializes a new SimpleArrayFloatclass.","since":"7.0"},{"signature":"SimpleArrayFloat(IEnumerable<float> values)","summary":"Initializes a new SimpleArrayFloatclass","since":"7.0","parameters":[{"name":"values","summary":"initial set of integers to add to the array"}]},{"signature":"SimpleArrayFloat(int initialSize)","summary":"Initializes a new SimpleArrayFloatclass. Initial size of the array - all values are set to zero.","since":"7.0","parameters":[{"name":"initialSize","summary":"Initial size of the array - all values are set to zero."}]},{"signature":"SimpleArrayFloat(SimpleArrayFloat other)","summary":"Initializes a new SimpleArrayFloatwith the contents of another SimpleArrayFloat.","since":"7.0"}],"properties":[{"signature":"int Count","summary":"Gets the amount of elements in this array.","since":"7.0","property":["get"]}],"methods":[{"signature":"IntPtr Array()","summary":"Return the raw data.","since":"7.0"},{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"7.0","returns":"The constant pointer."},{"signature":"void CopyTo(SimpleArrayFloat other)","summary":"Copies the contents of a SimpleArrayFloatinto another SimpleArrayFloat.","since":"7.0"},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"7.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"7.0","returns":"The non-constant pointer."},{"signature":"float[] ToArray()","summary":"Returns the managed counterpart of the unmanaged array.","since":"7.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayGeometryPointer","dataType":"class","summary":"Wrapper for a C++ ON_SimpleArray<ON_Geometry*>* or ON_SimpleArray<constant ON_Geometry*>. If you are not writing C++ code, then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayGeometryPointer()","summary":"Initializes a new SimpleArrayGeometryPointerinstance.","since":"5.0"},{"signature":"SimpleArrayGeometryPointer(IEnumerable geometry)","summary":"Expects all of the items in the IEnumerable to be GeometryBase types","since":"5.0"},{"signature":"SimpleArrayGeometryPointer(IEnumerable<GeometryBase> geometry)","summary":"Create an ON_SimpleArray<ON_Geometry*> filled with items in geometry","since":"5.0"}],"methods":[{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"5.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"5.0","returns":"The non-constant pointer."},{"signature":"GeometryBase[] ToNonConstArray()","summary":"Copies the unmanaged array to a managed counterpart.","since":"5.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayGuid","dataType":"class","summary":"Wrapper for ON_SimpleArray<ON_UUID>. If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayGuid()","summary":"Initializes a new SimpleArrayGuidclass.","since":"5.0"},{"signature":"SimpleArrayGuid(IEnumerable<Guid> values)","summary":"Initializes a new SimpleArrayGuidclass","since":"7.0","parameters":[{"name":"values","summary":"initial set of Guids to add to the array"}]}],"properties":[{"signature":"int Count","summary":"Gets the amount of elements in this array.","since":"5.0","property":["get"]}],"methods":[{"signature":"void Append(Guid uuid)","summary":"Appends a new Guidat the end of this array.","since":"6.0"},{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"5.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"5.0","returns":"The non-constant pointer."},{"signature":"Guid[] ToArray()","summary":"Returns the managed counterpart of the unmanaged array.","since":"5.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayGuidPointer","dataType":"class","summary":"Wrapper for ON_SimpleArray<ON_UUID>. If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayGuidPointer()","summary":"Initializes a new SimpleArrayGuidPointerclass.","since":"6.0"}],"properties":[{"signature":"int Count","summary":"Gets the amount of elements in this array.","since":"6.0","property":["get"]}],"methods":[{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"6.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"6.0","returns":"The non-constant pointer."},{"signature":"Guid[] ToArray()","summary":"Returns the managed counterpart of the unmanaged array.","since":"6.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayInt","dataType":"class","summary":"Wrapper for ON_SimpleArray<int>. If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayInt()","summary":"Initializes a new SimpleArrayIntclass.","since":"5.0"},{"signature":"SimpleArrayInt(IEnumerable<int> values)","summary":"Initializes a new SimpleArrayIntclass","since":"5.9","parameters":[{"name":"values","summary":"initial set of integers to add to the array"}]}],"properties":[{"signature":"int Count","summary":"Gets the amount of elements in this array.","since":"5.0","property":["get"]}],"methods":[{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"5.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"5.0","returns":"The non-constant pointer."},{"signature":"int[] ToArray()","summary":"Returns the managed counterpart of the unmanaged array.","since":"5.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayInterval","dataType":"class","summary":"Wrapper for ON_SimpleArray<ON_Interval>. If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayInterval()","summary":"Initializes a new SimpleArrayIntervalclass.","since":"5.0"}],"properties":[{"signature":"int Count","summary":"Gets the amount of elements in this array.","since":"5.0","property":["get"]}],"methods":[{"signature":"void Add(Interval interval)","summary":"Adds a new Intervalat the end of this array.","since":"6.0"},{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"5.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"5.0","returns":"The non-constant pointer."},{"signature":"Interval[] ToArray()","summary":"Returns the managed counterpart of the unmanaged array.","since":"5.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayLine","dataType":"class","summary":"Wrapper for ON_SimpleArray<ON_Line>. If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayLine()","summary":"Initializes a new SimpleArrayLineinstance.","since":"5.0"}],"properties":[{"signature":"int Count","summary":"Gets the amount of lines in this array.","since":"5.0","property":["get"]}],"methods":[{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"5.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"5.0","returns":"The non-constant pointer."},{"signature":"Line[] ToArray()","summary":"Copies the unmanaged array to a managed counterpart.","since":"5.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayLinetypePointer","dataType":"class","summary":"Wrapper for a C++ ON_SimpleArray<ON_Linetype*> If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayLinetypePointer()","summary":"Initializes a new SimpleArrayLinetypePointerinstance.","since":"6.6"}],"properties":[{"signature":"int Count","summary":"Gets the amount of linetypes in this array.","since":"6.6","property":["get"]}],"methods":[{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"6.6","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.6"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"6.6","returns":"The non-constant pointer."},{"signature":"DocObjects.Linetype[] ToNonConstArray()","summary":"Copies the unmanaged array to a managed counterpart.","since":"6.6","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayMeshPointer","dataType":"class","summary":"Represents a wrapper to an unmanaged array of mesh pointers.  \\nWrapper for a C++ ON_SimpleArray of ON_Mesh* or constant ON_Mesh*. If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayMeshPointer()","summary":"Initializes a new SimpleArrayMeshPointerinstance.","since":"5.0"}],"properties":[{"signature":"int Count","summary":"Gets the amount of meshes in this array.","since":"5.0","property":["get"]}],"methods":[{"signature":"void Add(Mesh mesh, bool asConst)","summary":"Adds a mesh to the list.","since":"5.0","parameters":[{"name":"mesh","summary":"A mesh to add."},{"name":"asConst","summary":"Whether this mesh should be treated as non-modifiable."}]},{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"5.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"5.0","returns":"The non-constant pointer."},{"signature":"Geometry.Mesh[] ToNonConstArray()","summary":"Copies the unmanaged array to a managed counterpart.","since":"5.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayPlane","dataType":"class","summary":"Wrapper for ON_SimpleArray<ON_Plane>. If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayPlane()","summary":"Initializes a new SimpleArrayLineinstance.","since":"6.0"}],"properties":[{"signature":"int Count","summary":"Gets the amount of lines in this array.","since":"6.0","property":["get"]}],"methods":[{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"6.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"6.0","returns":"The non-constant pointer."},{"signature":"Plane[] ToArray()","summary":"Copies the unmanaged array to a managed counterpart.","since":"6.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayPoint2d","dataType":"class","summary":"ON_SimpleArray<ON_2dPoint> class wrapper.  If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayPoint2d()","summary":"Initializes a new empty SimpleArrayPoint3dinstance.","since":"5.6"}],"properties":[{"signature":"int Count","summary":"Gets the amount of points in this array.","since":"5.6","property":["get"]}],"methods":[{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"5.6","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.6"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"5.6","returns":"The non-constant pointer."},{"signature":"Point2d[] ToArray()","summary":"Copies the unmanaged array to a managed counterpart.","since":"5.6","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayPoint3d","dataType":"class","summary":"ON_SimpleArray<ON_3dPoint>, ON_3dPointArray, ON_PolyLine all have the same size This class wraps all of these C++ versions.  If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayPoint3d()","summary":"Initializes a new empty SimpleArrayPoint3dinstance.","since":"5.0"}],"properties":[{"signature":"int Count","summary":"Gets the amount of points in this array.","since":"5.0","property":["get"]}],"methods":[{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"5.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"5.0","returns":"The non-constant pointer."},{"signature":"Point3d[] ToArray()","summary":"Copies the unmanaged array to a managed counterpart.","since":"5.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArraySurfacePointer","dataType":"class","summary":"Wrapper for a C++ ON_SimpleArray of ON_Surface* or constant ON_Surface*.  If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArraySurfacePointer()","summary":"Initializes a new SimpleArraySurfacePointerinstance.","since":"5.0"}],"methods":[{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"5.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"5.0","returns":"The non-constant pointer."},{"signature":"Surface[] ToNonConstArray()","summary":"Copies the unmanaged array to a managed counterpart. Elements are made non-constant.","since":"5.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"SimpleArrayUint","dataType":"class","summary":"Wrapper for ON_SimpleArray<unsigned int>. If you are not writing C++ code then this class is not for you.","interfaces":["IDisposable"],"constructors":[{"signature":"SimpleArrayUint()","summary":"Initializes a new SimpleArrayIntclass.","since":"6.0"},{"signature":"SimpleArrayUint(IEnumerable<uint> values)","summary":"Initializes a new SimpleArrayIntclass.","since":"6.0","parameters":[{"name":"values","summary":"A list, an array or any collection of unsigned integers that implements the enumerable interface."}]}],"properties":[{"signature":"int Count","summary":"Gets the number of elements in this array.","since":"6.0","property":["get"]},{"signature":"uint UnsignedCount","summary":"Gets the number of elements in this array.","since":"6.0","property":["get"]}],"methods":[{"signature":"IntPtr ConstPointer()","summary":"Gets the constant (immutable) pointer of this array.","since":"6.0","returns":"The constant pointer."},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"6.0"},{"signature":"IntPtr NonConstPointer()","summary":"Gets the non-constant pointer (for modification) of this array.","since":"6.0","returns":"The non-constant pointer."},{"signature":"uint[] ToArray()","summary":"Returns the managed counterpart of the unmanaged array.","since":"6.0","returns":"The managed array."}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"StringHolder","dataType":"class","summary":"This class is used to pass strings back and forth between managed and unmanaged code.  This should not be needed by plug-ins.  \\nIf you are just dealing with an ON_wString*, use","interfaces":["IDisposable"],"constructors":[{"signature":"StringHolder()","summary":"Constructor","since":"5.8"}],"methods":[{"signature":"static string GetString(IntPtr pStringHolder)","summary":"Gets managed string from unmanaged ON_wString pointer.","since":"5.8","returns":"Null if pStringHolder has no reference, otherwise, the string. This may be an empty string, if setting an empty string is possible."},{"signature":"IntPtr ConstPointer()","summary":"C++ pointer used to access the ON_wString, managed plug-ins should never need this.","since":"5.8"},{"signature":"void Dispose()","summary":"IDispose implementation","since":"5.8"},{"signature":"IntPtr NonConstPointer()","summary":"C++ pointer used to access the ON_wString, managed plug-ins should never need this.","since":"5.8"},{"signature":"string ToString()","summary":"Marshals unmanaged ON_wString to a managed .NET string"}]},{"namespace":"Rhino.Runtime.InteropWrappers","name":"StringWrapper","dataType":"class","summary":"Represents a wrapper to an unmanaged OpenNurbs string.  \\nWraps a C++ ON_wString*.","interfaces":["IDisposable"],"constructors":[{"signature":"StringWrapper()","summary":"Initializes a new empty unmanaged string (ON_wString*).","since":"5.0"},{"signature":"StringWrapper(string s)","summary":"Initializes a new unmanaged string with an initial value. The string s can be null.","since":"5.0","parameters":[{"name":"s","summary":"The initial value, or null."}]}],"properties":[{"signature":"IntPtr ConstPointer","summary":"Gets the constant pointer (constant ON_wString*).","since":"5.0","property":["get"]},{"signature":"IntPtr NonConstPointer","summary":"Gets the non-constant pointer (ON_wString*).","since":"5.0","property":["get"]}],"methods":[{"signature":"static string GetStringFromPointer(IntPtr pConstON_wString)","summary":"Get string from an ON_wString*","since":"5.0"},{"signature":"static void SetStringOnPointer(IntPtr pON_wString, string s)","summary":"Set contents of an ON_wString*","since":"5.0"},{"signature":"void Dispose()","summary":"Actively reclaims unmanaged resources that this instance uses.","since":"5.0"},{"signature":"void SetString(string s)","summary":"Set contents of this string.","since":"5.0","parameters":[{"name":"s","summary":"The new string."}]},{"signature":"string ToString()","summary":"Returns the string contents of this wrapper.","returns":"A managed string."}]},{"namespace":"Rhino.Runtime","name":"IPlatformServiceLocator","dataType":"interface","summary":"Get platform specific services that are used internally for general cross platform funtions in RhinoCommon. This includes services like localization and GUI components that have concrete implementations in the RhinoWindows or RhinoMac assemblies","methods":[{"signature":"T GetService()","summary":"Used to get service of a specific type","since":"6.0"}]},{"namespace":"Rhino.Runtime","name":"IZooClientUtilities","dataType":"interface","summary":"Interface implemented in ZooClient and added to Rhino via dependency injection","properties":[{"signature":"Image LoggedInUserAvatar","summary":"Returns the logged in user\'s avatar picture. Returns a default avatar if the user does not have an avatar or if the avatar could not be fetched.","since":"6.0","property":["get"]},{"signature":"string LoggedInUserName","summary":"Returns the name of the logged in user, or None if the user is not logged in.","since":"6.0","property":["get"]},{"signature":"bool UserIsLoggedIn","summary":"Returns True if the user is logged in; else returns false. A logged in user does not guarantee that the auth tokens managed by the CloudZooManager instance are valid.","since":"6.0","property":["get"]}],"methods":[{"signature":"bool AskUserForLicense(object verify, ZooClientParameters parameters)","since":"6.0"},{"signature":"bool CheckInLicense(object verify, Guid productId)","summary":"Checks in a checked out license to the owning Zoo.","since":"6.0"},{"signature":"bool CheckOutLicense(object verify, Guid productId)","summary":"Checks out a loaned out license from the owning Zoo.","since":"6.0"},{"signature":"bool ConvertLicense(object verify, Guid productId)","summary":"Converts a standalone license to a network license.","since":"6.0"},{"signature":"bool DeleteLicense(object verify, Guid productId)","summary":"31-Mar-2015 Dale Fugier, http://mcneel.myjetbrains.com/youtrack/issue/MR-1725 Deletes a license along with its license file.","since":"6.0"},{"signature":"string Echo(object verify, string message)","since":"6.0"},{"signature":"DateTime GetCurrentTime()","summary":"Gets the current time, trying to access an NTP server before using local time.","since":"6.0"},{"signature":"bool GetLicense(object verify, ZooClientParameters parameters)","since":"6.0"},{"signature":"LicenseStatus[] GetLicenseStatus(object verify)","summary":"Returns the current status of every license for ui purposes","since":"6.0"},{"signature":"int GetLicenseType(object verify, Guid productId)","summary":"Returns the type of a specified product license","since":"6.0"},{"signature":"LicenseStatus GetOneLicenseStatus(object verify, Guid productId)","summary":"Returns the current status of a license for ui purposes","since":"6.0"},{"signature":"bool GetRegisteredOwnerInfo(object verify, Guid productId, ref string registeredOwner, ref string registeredOrganization)","summary":"Returns the registered owner and organization of a license 4-Sept-2014 Dale Fugier, http://mcneel.myjetbrains.com/youtrack/issue/RH-28623","since":"6.0"},{"signature":"bool Initialize(object verify)","since":"6.0"},{"signature":"bool IsCheckOutEnabled(object verify)","summary":"Returns whether or not license checkout is enabled","since":"6.0"},{"signature":"bool LicenseOptionsHandler(object verify, ZooClientParameters parameters)","since":"6.0"},{"signature":"bool LoginToCloudZoo()","summary":"Logs the user in to the cloud zoo. This logs out the current user and voids any existing leases.","since":"6.0"},{"signature":"bool LogoutOfCloudZoo()","summary":"Logs the user out of the cloud zoo. This logs out the current user and voids any existing leases.","since":"6.0"},{"signature":"bool ReturnLicense(object verify, Guid productId)","since":"6.0"},{"signature":"bool ReturnLicense(object verify, string productPath, Guid productId)","since":"6.0"},{"signature":"void ShowBuyLicenseUi(object verify, Guid productId)","since":"6.0"},{"signature":"bool ShowLicenseValidationUi(object verify, string cdkey)","summary":"Shows user interface to validate and register a license. Returns True if the license is successfully validated; False otherwise","since":"6.0"},{"signature":"bool ShowRhinoExpiredMessage(Mode mode, ref int result)","since":"6.0"}]},{"namespace":"Rhino.Runtime","name":"LicenseStateChangedEventArgs","dataType":"class","summary":"Passed to LicenseStateChanged event on RhinoApp","baseclass":"EventArgs","constructors":[{"signature":"LicenseStateChangedEventArgs(bool callingRhinoCommonAllowed)","summary":"LicenseStateChangedEventArgs constructor","since":"7.0","parameters":[{"name":"callingRhinoCommonAllowed","summary":"True when calling RhinoCommon will never raise Rhino.Runtime.NotLicesnedException; False otherwise."}]}],"properties":[{"signature":"bool CallingRhinoCommonAllowed","summary":"True if RhinoCommon calls will never raise Rhino.Runtime.NotLicensedException. False otherwise","since":"7.0","property":["get","set"]}]},{"namespace":"Rhino.Runtime","name":"LicenseTypes","dataType":"enum","summary":"Different licensing modes that Rhino can run in","since":"6.0","values":[{"signature":"Undefined = 0","summary":"Licensing mode not define"},{"signature":"Standalone","summary":"Standalone license installed on this computer."},{"signature":"ZooAutoDetect","summary":"Classic Zoo license with the Zoo server automatically detected at runtime."},{"signature":"ZooManualDetect","summary":"Classic Zoo license with the Zoo server specified by hostname or IP"},{"signature":"CloudZoo","summary":"Cloud Zoo licenese"}]},{"namespace":"Rhino.Runtime","name":"Mode","dataType":"enum","summary":"Contains enumerated constant values to represent Rhino\'s Runtime Mode.","values":[{"signature":"NormalMode = 0","summary":"Running with a commercial, educational, or evaluation license ke"},{"signature":"ViewerMode","summary":"Running as a viewer"},{"signature":"BetaMode","summary":"Running as a Beta product"},{"signature":"InvalidMode = 100","summary":"Invalid mode; this is an error condition"}]},{"namespace":"Rhino.Runtime","name":"NamedParametersEventArgs","dataType":"class","summary":"Dictionary style class used for named callbacks from C++ -> .NET","baseclass":"EventArgs","interfaces":["IDisposable"],"constructors":[{"signature":"NamedParametersEventArgs()","summary":"Construct a new named parameter even args. You should dispose this class when you are done with it","since":"7.0"}],"methods":[{"signature":"void Dispose()","summary":"Dispose native resources","since":"7.0"},{"signature":"void Set(string name, bool value)","summary":"Set a bool value for a given key name","since":"7.0"},{"signature":"void Set(string name, Color value)","summary":"Set a Color value for a given key name","since":"7.0"},{"signature":"void Set(string name, double value)","summary":"Set a double value for a given key name","since":"7.0"},{"signature":"void Set(string name, GeometryBase value)","summary":"Set geometry for a given key name","since":"7.0"},{"signature":"void Set(string name, IEnumerable<GeometryBase> values)","summary":"Set a list of geometry for a given key name","since":"7.0"},{"signature":"void Set(string name, IEnumerable<string> strings)","summary":"Set a list of strings as a value for a given key name","since":"7.0"},{"signature":"void Set(string name, int value)","summary":"Set an int value for a given key name","since":"7.0"},{"signature":"void Set(string name, Point3d value)","summary":"Set a Point3d value for a given key name","since":"7.0"},{"signature":"void Set(string name, string value)","summary":"Set a string value for a given key name","since":"7.0"},{"signature":"void Set(string name, uint value)","summary":"Set an unsigned int for a given key name","since":"7.0"},{"signature":"void Set(string name, Vector3d value)","summary":"Set a Vector3d value for a given key name","since":"7.0"},{"signature":"void SetWindowHandle(string name, IntPtr value)","summary":"Set a HWND on Windows or NSView* on Mac","since":"7.0"},{"signature":"bool TryGetBool(string name, out bool value)","summary":"Try to get a bool value for a given key name","since":"6.15"},{"signature":"bool TryGetColor(string name, out Color value)","summary":"Try to get a Color value for a given key name","since":"7.0"},{"signature":"bool TryGetDouble(string name, out double value)","summary":"Try to get a double value for a given key name","since":"6.15"},{"signature":"bool TryGetGeometry(string name, out GeometryBase[] values)","since":"7.0"},{"signature":"bool TryGetInt(string name, out int value)","summary":"Try to get an int value for a given key name","since":"6.15"},{"signature":"bool TryGetPoint(string name, out Point3d value)","summary":"Try to get a Point3d value for a given key name","since":"7.0"},{"signature":"bool TryGetRhinoObjects(string key, out RhinoObject[] values)","summary":"Get array of RhinoObject for the specified key","since":"7.0"},{"signature":"bool TryGetString(string name, out string value)","summary":"Try to get a string value for a given key name","since":"6.15"},{"signature":"bool TryGetStrings(string name, out string[] value)","summary":"Try to get a string value for a given key name","since":"7.0"},{"signature":"bool TryGetUnsignedInt(string name, out uint value)","summary":"Try to get an unsigned int for a given key name","since":"7.0"},{"signature":"bool TryGetVector(string name, out Vector3d value)","summary":"Try to get a Vector3d value for a given key name","since":"7.0"},{"signature":"bool TryGetViewport(string name, out ViewportInfo viewport)","summary":"Try to get a viewport for a given key name","since":"7.0"},{"signature":"bool TryGetWindowHandle(string name, out IntPtr value)","summary":"Gets a HWND on Windows or NSVIew* on Mac","since":"7.0"}]},{"namespace":"Rhino.Runtime.Notifications","name":"ButtonType","dataType":"enum","summary":"The type of button in a notification.","since":"6.0","values":[{"signature":"CancelOrClose","summary":"Denotes either the Cancel button as well as, on some platforms, the close button if present."},{"signature":"Confirm","summary":"The Confirm buttton."},{"signature":"Alternate","summary":"The Alternate button."}]},{"namespace":"Rhino.Runtime.Notifications","name":"IAssemblyRestrictedObject","dataType":"interface","summary":"A class that implements this interface signals its clients that its instances can only be modified by certain assemblies. This is useful in cases where only certain assemblies should be able to modify an object. The actual members of an instance that are restricted are left to the discretion of the instance\'s class, and should be documented.","methods":[{"signature":"bool Editable()","summary":"Determines whether an assembly can modify the instance.","since":"6.3","returns":"True if the instance can be edited by the assembly, otherwise returns false."}]},{"namespace":"Rhino.Runtime.Notifications","name":"Notification","dataType":"class","summary":"A Notification instance can be used to inform the user about various events. For a Notification instance to be displayed in Rhino, it must be added to the  NotificationCenter. When added, it will be displayed in the Notifications panel in Rhino. A Notification contains 1 to 3 buttons that are automatically wired to its ButtonClickedAction if it is not null. The buttons are displayed when the Notification is shown modally by either the user clicking on a particular notification in the Notifications panel, or by programatically showing it using ShowModal.  Currently, only process-wide notifications are supported; document specific notifications are not possible.  Notification instances contain metadata that can be added, modified, or removed during its life. The metadata is important for LINQ queries and other patterns. For example, a particular action may require that multiple notifications be modified. Thus, a LINQ query can be performed on the NotificationCenterusing metadata to retrieve related Notification objects and modify them as a batch.  Notification objects implement IAssemblyRestrictedObject. By default, a Notification can be editedby any assembly, but explicitly specifing allowed assemblies in the constructor changes this behavior.  Notification objects are not thread-safe and should only be manipulated in UI thread.","interfaces":["INotifyPropertyChanged","Rhino.Runtime.Notifications.IAssemblyRestrictedObject"],"constructors":[{"signature":"Notification()","summary":"Creates a new instance that can be edited by any assembly.","since":"6.0"},{"signature":"Notification(IEnumerable<Assembly> allowedAssemblies)","summary":"Creates a new instance that can be edited by the given assemblies.","since":"6.0","parameters":[{"name":"allowedAssemblies","summary":"The assemblies that will be allowed to edit the instance. If None or empty, any assembly will be able to edit this notification."}]}],"properties":[{"signature":"ICollection<Assembly> AllowedAssemblies","summary":"The assemblies that can modify this instance.","since":"6.0","property":["get","set"]},{"signature":"string AlternateButtonTitle","summary":"The localized title of the Alternate button.","since":"6.0","property":["get","set"]},{"signature":"Action<ButtonType> ButtonClicked","summary":"An Action that will be invoked whenever a button for the notification is clicked or the notification is closed.","since":"6.0","property":["get","set"]},{"signature":"string CancelButtonTitle","summary":"The localized title of the Cancel button.","since":"6.0","property":["get","set"]},{"signature":"string ConfirmButtonTitle","summary":"The localized title of the Confirm button.","since":"6.0","property":["get","set"]},{"signature":"DateTime DateUpdated","summary":"The date the notification was last modified.","since":"6.0","property":["get","set"]},{"signature":"string Description","summary":"The description of the notification. The description is displayed in the Notifications panel in Rhino.","since":"6.0","property":["get","set"]},{"signature":"string Message","summary":"The message of the notification. The message is shown only when the instance is displayed modally. It should contain details about the notification.","since":"6.0","property":["get","set"]},{"signature":"IDictionary<string, string> MetadataCopy","summary":"A copy of all the metadata for this class.","since":"6.0","property":["get"]},{"signature":"Severity SeverityLevel","summary":"The severity of the notification. Changing the severity of the notification may change the way Rhino chooses to display the Notifications panel.","since":"6.0","property":["get","set"]},{"signature":"Guid? ShowEventId","summary":"A field used by Rhino for displaying notifications. Not intended for public use.","since":"6.0","property":["get"]},{"signature":"string Title","summary":"The title of the notification. The title is displayed when the notification is displayed modally in Rhino.","since":"6.0","property":["get","set"]}],"methods":[{"signature":"static void ExecuteAssemblyProtectedCode(Action action)","summary":"If a Notificationobject is only allowed to be modified by certain assemblies, then any code that interacts with it must be wrapped around this method, or a InvalidOperationExceptionwill be thrown. For performance reasons, the code wrapped by this method should be kept as simple as possible.","since":"6.3","parameters":[{"name":"action","summary":"The code to run that modifies one or more notification objects"}]},{"signature":"static TResult ExecuteAssemblyProtectedCode(Func<TResult> func)","summary":"If a Notificationobject is only allowed to be modified by certain assemblies, then any code that interacts with it must be wrapped around this method, or a InvalidOperationExceptionwill be thrown. For performance reasons, the code wrapped by this method should be kept as simple as possible.","since":"6.3","parameters":[{"name":"func","summary":"The code to run that modifies one or more notification objects"}]},{"signature":"bool Editable()","summary":"Determines whether an assembly can modify the instance. Any code that modifies an assembly protected notification must be wrapped in a ExecuteAssemblyProtectedCode(Action)method.","since":"6.3"},{"signature":"void HideModal()","summary":"Tells Rhino to hide the notification if it is being currently shown as a modal.","since":"6.0"},{"signature":"bool RemoveMetadata(string key)","summary":"Removes metadata from this instance.","since":"6.0","parameters":[{"name":"key","summary":"The key of the metadata to remove."}],"returns":"True if the metada was removed; otherwise false."},{"signature":"void ShowModal()","summary":"Tells Rhino to display the notification modally.","since":"6.0"},{"signature":"string ToString()","summary":"Returns a readable string representation of the instance."}]},{"namespace":"Rhino.Runtime.Notifications","name":"Notification.Severity","dataType":"enum","summary":"Determines the severity of a notification.","since":"6.0","values":[{"signature":"Debug","summary":"Least serious."},{"signature":"Info","summary":"Not serious."},{"signature":"Warning","summary":"Important."},{"signature":"Serious","summary":"Very important."},{"signature":"Critical","summary":"Extremely important."}]},{"namespace":"Rhino.Runtime.Notifications","name":"NotificationButtonClickedArgs","dataType":"class","summary":"Used when a button is clicked for a notification.","baseclass":"EventArgs","constructors":[{"signature":"NotificationButtonClickedArgs(Notification notification, ButtonType buttonClicked)","summary":"Creates a new instance.","since":"6.0","parameters":[{"name":"notification","summary":"The notification whose button was clicked."},{"name":"buttonClicked","summary":"The button that was clicked."}]}],"properties":[{"signature":"ButtonType ButtonClicked","summary":"The button that was clicked.","since":"6.0","property":["get","set"]},{"signature":"Notification Notification","summary":"The notification whose button was clicked.","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Runtime.Notifications","name":"NotificationCenter","dataType":"class","summary":"The NotificationCenter holds all Notificationobjects that are displayed in the Notifications panel by Rhino.  The NotificationCenter is not thread-safe and should only be used in the UI thread."},{"namespace":"Rhino.Runtime.Notifications","name":"TrulyObservableOrderedSet<T>","dataType":"class","summary":"An ordered set that notifies its subscribers whenever one of its INotifyPropertyChanged elements raises its PropertyChanged event.","remarks":"This class prevents the removal of elements by assemblies they cannot be edited by. At the time of removal, each element\'s IAssemblyRestrictedObject.Editablemethod will be invoked, and if false, an InvalidOperationException will be thrown.","interfaces":["IList<T>","INotifyCollectionChanged"],"constructors":[{"signature":"TrulyObservableOrderedSet<T>()","summary":"Creates an empty instance."},{"signature":"TrulyObservableOrderedSet<T>(IEnumerable<T> items)","summary":"Creates an instance with the given items.","parameters":[{"name":"items","summary":"Items that the instance will contain. If there are duplicate items, they will be removed."}]}],"properties":[{"signature":"int Count","summary":"Returns the total number of items in the set.","property":["get"]},{"signature":"bool IsReadOnly","summary":"Always returns false.","property":["get"]}],"methods":[{"signature":"void Add(T item)","summary":"Adds an object to the end of the ordered set if the set does not already contain the item.","parameters":[{"name":"item","summary":"The item to add."}]},{"signature":"void Clear()","summary":"Clears the ordered set."},{"signature":"bool Contains(T item)","summary":"Determines whether an element is in the set.","parameters":[{"name":"item","summary":"The item to check for inclusion."}],"returns":"True if the item is in the set; otherwise false."},{"signature":"void CopyTo(T[] array, int arrayIndex)","summary":"Copies the values of the set to an array.","parameters":[{"name":"array","summary":"The array to copy the values to."},{"name":"arrayIndex","summary":"The index of the array to start the copy."}]},{"signature":"IEnumerator<T> GetEnumerator()","summary":"Returns an enumerator that iterates through the set."},{"signature":"int IndexOf(T item)","summary":"Searches for the specified object and returns the zero-based index of the first occurrence.","parameters":[{"name":"item","summary":"The item to locate."}],"returns":"The zero-based index of the first occurrence of item if found; otherwise -1."},{"signature":"void Insert(int index, T item)","summary":"Inserts an element at the specified index.","parameters":[{"name":"index","summary":"The index to insert the element at."},{"name":"item","summary":"The item to insert."}]},{"signature":"bool Remove(T item)","summary":"Removes an element from the set.","parameters":[{"name":"item","summary":"The element to remove."}],"returns":"Returns True if the element was removed; otherwise returns false."},{"signature":"void RemoveAt(int index)","summary":"Removes an element at the specified index from the set.","parameters":[{"name":"index","summary":"The index of the element to remove."}]},{"signature":"void Sort(Func<T, TKey> keySelector, bool descending)","summary":"Sorts the set.","parameters":[{"name":"keySelector","summary":""},{"name":"descending","summary":"If true, the sort will happen in descending other; if false, it will happen in ascending order."}]}]},{"namespace":"Rhino.Runtime","name":"NotLicensedException","dataType":"class","summary":"Exception thrown when calling functions in RhinoCommon and the application is executing without a license","baseclass":"Exception","constructors":[{"signature":"NotLicensedException()","summary":"Default constructor","since":"7.0"},{"signature":"NotLicensedException(string message)","summary":"Create a new instance with a custom message","since":"7.0"},{"signature":"NotLicensedException(string message, Exception inner)","summary":"Create a new instance with a custom message and an inner exception","since":"7.0"}]},{"namespace":"Rhino.Runtime","name":"PythonCompiledCode","dataType":"class","summary":"Represents scripting compiled code.","methods":[{"signature":"void Execute(PythonScript scope)","summary":"Executes the script in a specific scope.","since":"5.0","parameters":[{"name":"scope","summary":"The scope where the script should be executed."}]}]},{"namespace":"Rhino.Runtime","name":"PythonScript","dataType":"class","summary":"Represents a Python script.","properties":[{"signature":"int ContextId","summary":"Gets or sets a context unique identified.","since":"5.0","property":["get","set"]},{"signature":"Action<string> Output","summary":"Gets or sets the Python script \\"print()\\" target.  \\nBy default string output goes to the Rhino.RhinoApp.Write function. Set Output if you want to redirect the output from python to a different function while this script executes.","since":"5.0","property":["get","set"]},{"signature":"Command ScriptContextCommand","summary":"Command associated with this script. Used for localiation","since":"6.0","property":["get","set"]},{"signature":"object ScriptContextDoc","summary":"object set to variable held in scriptcontext.doc.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"static void AddRuntimeAssembly(Assembly assembly)","summary":"Add assembly to list of assemblies used by python","since":"7.0"},{"signature":"static PythonScript Create()","summary":"Constructs a new Python script context.","since":"5.0","returns":"A new Python script, or None if none could be created. Rhino 4 always returns null."},{"signature":"static System.Reflection.Assembly[] RuntimeAssemblies()","summary":"Get list of assemblies used by python for library browser and inclusion into the runtime","since":"7.0"},{"signature":"PythonCompiledCode Compile(string script)","summary":"Compiles a class in a quick-to-execute proxy.","since":"5.0","parameters":[{"name":"script","summary":"A string text."}],"returns":"A Python compiled code instance."},{"signature":"bool ContainsVariable(string name)","summary":"Determines if the main scripting context has a variable with a name.","since":"5.0","parameters":[{"name":"name","summary":"The variable name."}],"returns":"True if the variable is present."},{"signature":"object CreateTextEditorControl(string script, Action<string> helpcallback)","summary":"Creates a control where the user is able to type Python code.","since":"5.0","parameters":[{"name":"script","summary":"A starting script."},{"name":"helpcallback","summary":"A method that is called when help is shown for a function, a class or a method."}],"returns":"A Windows Forms control."},{"signature":"object EvaluateExpression(string statements, string expression)","summary":"Evaluates statements and an expression in the main scripting context.","since":"5.0","parameters":[{"name":"statements","summary":"One or several statements."},{"name":"expression","summary":"An expression."}],"returns":"The expression result."},{"signature":"bool ExecuteFile(string path)","summary":"Executes a Python file. The file is executed in a new, __main__ scope.","since":"5.0","parameters":[{"name":"path","summary":"The path to the file."}],"returns":"True if the file executed. This method can throw scripting-runtime based exceptions."},{"signature":"bool ExecuteFileInScope(string path)","summary":"Executes a Python file in the calling script scope. All old variables are kept.","since":"7.0","parameters":[{"name":"path","summary":"The path to the file."}],"returns":"True if the file executed. This method can throw scripting-runtime based exceptions."},{"signature":"bool ExecuteScript(string script)","summary":"Executes a Python string.","since":"5.0","parameters":[{"name":"script","summary":"A Python text."}],"returns":"True if the file executed. This method can throw scripting-runtime based exceptions."},{"signature":"string GetStackTraceFromException(Exception ex)","summary":"Retrieves a meaningful representation of the call stack.","since":"5.0","parameters":[{"name":"ex","summary":"An exception that was thrown by some of the methods in this class."}],"returns":"A string that represents the Python exception."},{"signature":"object GetVariable(string name)","summary":"Gets the object associated with a variable name in the main scripting context.","since":"5.0","parameters":[{"name":"name","summary":"A variable name."}],"returns":"The variable object."},{"signature":"System.Collections.Generic.IEnumerable<string> GetVariableNames()","summary":"Retrieves all variable names in the script.","since":"5.0","returns":"An enumerable set with all names of the variables."},{"signature":"void RemoveVariable(string name)","summary":"Removes a defined variable from the main scripting context.","since":"5.0","parameters":[{"name":"name","summary":"The variable name."}]},{"signature":"void SetIntellisenseVariable(string name, object value)","summary":"Sets a variable for runtime introspection.","since":"5.0","parameters":[{"name":"name","summary":"A variable name."},{"name":"value","summary":"A variable value."}]},{"signature":"void SetupScriptContext(object doc)","summary":"Setups the script context. Use a RhinoDoc instance unless unsure.","since":"6.0","parameters":[{"name":"doc","summary":"Document."}]},{"signature":"void SetVariable(string name, object value)","summary":"Sets a variable with a name and an object. Object can be None (Nothing in Visual Basic).","since":"5.0","parameters":[{"name":"name","summary":"A valid variable name in Python."},{"name":"value","summary":"A valid value for that variable name."}]}]},{"namespace":"Rhino.Runtime","name":"RdkNotLoadedException","dataType":"class","summary":"Is thrown when the RDK is not loaded.","baseclass":"Exception","constructors":[{"signature":"RdkNotLoadedException()","summary":"Initializes a new instance of the RDK not loaded exception with a standard message.","since":"5.0"}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"IOAuth2Token","dataType":"interface","summary":"Represents an OAuth2 Token that can be used for authorization purposes.","properties":[{"signature":"DateTime? Exp","summary":"The expiration of the token. Expired tokens will be considered invalid by the Rhino Accounts server.","since":"7.0","property":["get"]},{"signature":"bool IsExpired","summary":"True if the token is expired; False otherwise.","since":"7.0","property":["get"]},{"signature":"string RawToken","summary":"The raw token that can be passed to various servers for authorization.","since":"7.0","property":["get"]},{"signature":"IReadOnlyCollection<string> Scope","summary":"The scope of the token.","since":"7.0","property":["get"]}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"IOpenIDConnectToken","dataType":"interface","summary":"This class represents an OpenIDConnect token issued from an OpenID provider. The token is immutable.","properties":[{"signature":"IReadOnlyDictionary<string, RhinoAccountsGroup> AdminGroups","summary":"Returns all the groups the user is an admin of.","since":"7.0","property":["get"]},{"signature":"IReadOnlyDictionary<string, RhinoAccountsGroup> AllGroups","summary":"Returns all the groups the user is a member of.","since":"7.0","property":["get"]},{"signature":"string AtHash","summary":"Access Token hash value. Its value is the base64url encoding of the left-most half of the hash of the octets of the ASCII representation of the access_token value, where the hash algorithm used is the hash algorithm used in the alg Header Parameter of the ID Token\'s JOSE Header. For instance, if the alg is RS256, hash the access_token value with SHA-256, then take the left-most 128 bits and base64url encode them. The at_hash value is a case sensitive string.","since":"7.0","property":["get"]},{"signature":"string Aud","summary":"The id of the client (the audience) this token is intended for.","since":"7.0","property":["get"]},{"signature":"DateTime? AuthTime","summary":"Time when the End-User authentication occurred","since":"7.0","property":["get"]},{"signature":"IReadOnlyCollection<string> Emails","summary":"All the emails belonging to the account the token represents.","since":"7.0","property":["get"]},{"signature":"bool? EmailVerified","summary":"True if all the emails in the account have been verified; False otherwise.","since":"7.0","property":["get"]},{"signature":"DateTime? Exp","summary":"The date the token expires.","since":"7.0","property":["get"]},{"signature":"DateTime? Iat","summary":"The date the token was issued.","since":"7.0","property":["get"]},{"signature":"bool IsExpired","summary":"True if the token is expired; False otherwise.","since":"7.0","property":["get"]},{"signature":"string Iss","summary":"The id of the entity that issued the token.","since":"7.0","property":["get"]},{"signature":"bool IsUpdated","summary":"True if the token has been updated; False otherwise.","since":"7.0","property":["get"]},{"signature":"string Locale","summary":"The local of the user this token represents.  ISO 639-1 Alpha-2 [ISO6391] language code and an ISO 3166-1 Alpha-2 [ISO31661] country code in, separated by a dash.","since":"7.0","property":["get"]},{"signature":"IReadOnlyDictionary<string, RhinoAccountsGroup> MemberGroups","summary":"Returns all the groups the user is a member of, but not an admin or an owner.","since":"7.0","property":["get"]},{"signature":"string Name","summary":"The name of the user this token represents.","since":"7.0","property":["get"]},{"signature":"string Nonce","summary":"String value used to associate a Client session with an ID Token, and to mitigate replay attacks","since":"7.0","property":["get"]},{"signature":"IReadOnlyDictionary<string, RhinoAccountsGroup> OwnerGroups","summary":"Returns all the groups the user is an owner of.","since":"7.0","property":["get"]},{"signature":"string Phone","summary":"The phone of the user this token represents.","since":"7.0","property":["get"]},{"signature":"string Picture","summary":"The url of a picture/avatar/icon of the user this token represents.","since":"7.0","property":["get"]},{"signature":"string RawToken","summary":"The raw OpenIDConnect token.","since":"7.0","property":["get"]},{"signature":"string Sub","summary":"The unique id for the subject this token represents.","since":"7.0","property":["get"]},{"signature":"DateTime? UpdatedAt","summary":"The last time the token was updated.","since":"7.0","property":["get"]}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"IRhinoAccountsManager","dataType":"interface","summary":"Performs various Rhino Accounts-related tasks.","methods":[{"signature":"void ExecuteProtectedCode(Action<SecretKey> protectedCode)","summary":"Any synchronous method in the IRhinoAccountsManagerclass must be executed within the function passed to this method, or an InvalidOperationExceptionwill be thrown.","since":"7.0","parameters":[{"name":"protectedCode","summary":"A function returning an awaitable task that has a SecretKeypassed to it. You will need to pass this secret key to any method you wish to call within IRhinoAccountsManager."}]},{"signature":"Task ExecuteProtectedCodeAsync(Func<SecretKey, Task> protectedCode)","summary":"Any asynchronous method in the IRhinoAccountsManagerclass must be executed within the function passed to this method, or an InvalidOperationExceptionwill be thrown.","parameters":[{"name":"protectedCode","summary":"A function returning an awaitable task that has a SecretKeypassed to it. You will need to pass this secret key to any method you wish to call within IRhinoAccountsManager."}]},{"signature":"Task<Tuple<IOpenIDConnectToken, IOAuth2Token>> GetAuthTokensAsync(string clientId, string clientSecret, IEnumerable<string> scope, string prompt, int? maxAge, bool showUI, IProgress<RhinoAccoountsProgressInfo> progress, SecretKey secretKey, CancellationToken cancellationToken)","summary":"Asynchronously retrieves auth tokens with the given criteria from the Rhino Accounts server.","parameters":[{"name":"clientId","summary":"The unique id of the client registered in Rhino Accounts."},{"name":"clientSecret","summary":"The secret of the client registered in Rhino Accounts"},{"name":"scope","summary":"The scope desired for the tokens. Valid scope values can be found in the Rhino Accounts documentation."},{"name":"prompt","summary":"The prompt of the request. See Rhino Accounts documentation for details. You may pass None if no prompt is desired."},{"name":"maxAge","summary":"The maxAge of the request. See Rhino Accounts documentation for details. You may pass None if no maxAge should be enforced."},{"name":"showUI","summary":"True if the user should see a UI showing the progress of the operation and a way to cancel it, or False if the UI should not be displayed. If false, it is strongly recommended that you pass aobject and display your own UI to the user."},{"name":"progress","summary":"An object that will report the progress of the operation to the caller. If no progress is needed, you may pass null."},{"name":"secretKey","summary":"A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})"},{"name":"cancellationToken","summary":"A token that can be used to signal that the operation should be cancelled."}],"returns":"The auth tokens requested."},{"signature":"Task<Tuple<IOpenIDConnectToken, IOAuth2Token>> GetAuthTokensAsync(string clientId, string clientSecret, SecretKey secretKey, CancellationToken cancellationToken)","summary":"Asynchronously retrieves auth tokens with the given criteria from the Rhino Accounts server.","since":"7.0","parameters":[{"name":"clientId","summary":"The unique id of the client registered in Rhino Accounts."},{"name":"clientSecret","summary":"The secret of the client registered in Rhino Accounts"},{"name":"secretKey","summary":"A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})"},{"name":"cancellationToken","summary":"A token that can be used to signal that the operation should be cancelled."}],"returns":"The auth tokens requested."},{"signature":"Task RevokeAuthTokenAsync(IOAuth2Token oauth2Token, SecretKey secretKey, CancellationToken cancellationToken)","summary":"Invalidates/revokes an IOAuth2Tokenobject from the Rhino Accounts server.","since":"7.0","parameters":[{"name":"oauth2Token","summary":"The token to revoke."},{"name":"secretKey","summary":"A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})"},{"name":"cancellationToken","summary":"A token that can be used to signal that the operation should be cancelled."}]},{"signature":"Tuple<IOpenIDConnectToken, IOAuth2Token> TryGetAuthTokens(string clientId, IEnumerable<string> scope, SecretKey secretKey)","summary":"Attempts to return cached auth tokens that match the given criteria if any have been stored in cache.","since":"7.0","parameters":[{"name":"clientId","summary":"The unique id of the client registered in Rhino Accounts."},{"name":"scope","summary":"The scope desired for the tokens. Valid scope values can be found in the Rhino Accounts documentation."},{"name":"secretKey","summary":"A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})"}],"returns":"Cached tokens matching the exact criteria passed, or None if none can be found matching the criteria."},{"signature":"Tuple<IOpenIDConnectToken, IOAuth2Token> TryGetAuthTokens(string clientId, SecretKey secretKey)","summary":"Attempts to return cached auth tokens that match the given criteria if any have been stored in cache.","since":"7.0","parameters":[{"name":"clientId","summary":"The unique id of the client registered in Rhino Accounts."},{"name":"secretKey","summary":"A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})"}],"returns":"Cached tokens matching the exact criteria passed, or None if none can be found matching the criteria."},{"signature":"Task<IOpenIDConnectToken> UpdateOpenIDConnectTokenAsync(IOpenIDConnectToken currentToken, IOAuth2Token oauth2Token, SecretKey secretKey, CancellationToken cancellationToken)","summary":"Updates an OpenID Connect token so that it contains the latest user information by contacting the Rhino Account\'s server userinfo endpoint using a compatible O","since":"7.0","parameters":[{"name":"currentToken","summary":"The existing OpenID Connect token that you wish to updated with the latest user information."},{"name":"oauth2Token","summary":"A valid OAuth2 token used for authorization. The OAuth2 token must have been issued together with the OpenID Connect token passed or a RhinoAccountsAuthTokenMismatchExceptionwill be thrown."},{"name":"secretKey","summary":"A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})"},{"name":"cancellationToken","summary":"A token that can be used to signal that the operation should be cancelled."}],"returns":"The updated OpenIDConnectToken based on the original token passed to this method."}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"ProgressState","dataType":"enum","summary":"Describes the state of progress.","since":"7.0","values":[{"signature":"AwaitingLogin","summary":"The task is awaiting for the user to login."},{"signature":"RetrievingTokens","summary":"The task is now nogotiating with the remote server for auth tokens."},{"signature":"Other","summary":"Other"}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"RhinoAccoountsProgressInfo","dataType":"class","summary":"This class is designed to convey the progress of an asynchronous operation through .NET\'s IProgress{T}interface. It can be used by callers of such tasks to relay the tasks\' progress, as well as useful metadata information that may be of interest.","constructors":[{"signature":"RhinoAccoountsProgressInfo(ProgressState state, Dictionary<object, object> metadata, string customDescription)","summary":"Creates a new instance.","parameters":[{"name":"state","summary":"The state to report."},{"name":"metadata","summary":"Optional. Any metadata of interest that may be used by the caller of a task."},{"name":"customDescription","summary":"Optional. If a non-None value is passed, it will override the default description of the instance."}]}],"properties":[{"signature":"string Description","summary":"A localized description of the state that may be shown to the user of the application.","since":"7.0","property":["get","set"]},{"signature":"Dictionary<object, object> Metadata","summary":"Any metadata of interest that may be used by the caller of a task.","since":"7.0","property":["get"]},{"signature":"ProgressState State","summary":"The state to report.","since":"7.0","property":["get","set"]}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"RhinoAccountsAuthTokenMismatchException","dataType":"class","summary":"Exception thrown when the currently logged in user is different from the newly logged in user.","baseclass":"Rhino.Runtime.RhinoAccounts.RhinoAccountsException","constructors":[{"signature":"RhinoAccountsAuthTokenMismatchException(Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"innerException","summary":"The inner exception."}]},{"signature":"RhinoAccountsAuthTokenMismatchException(string message, Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"message","summary":"The message of the exception."},{"name":"innerException","summary":"The inner exception."}]},{"signature":"RhinoAccountsAuthTokenMismatchException(string currentUsername, string newUsername, Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"currentUsername","summary":"The name of the currently logged in user."},{"name":"newUsername","summary":"The name of the newly logged in user."},{"name":"innerException","summary":"The inner exception."}]}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"RhinoAccountsCannotListenException","dataType":"class","summary":"Exception thrown when there is no port available on the machine for Rhino to listen for Rhino Accounts\' response.","baseclass":"Rhino.Runtime.RhinoAccounts.RhinoAccountsException","constructors":[{"signature":"RhinoAccountsCannotListenException(Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"innerException","summary":"The inner exception."}]},{"signature":"RhinoAccountsCannotListenException(string message, Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"message","summary":"The message of the exception."},{"name":"innerException","summary":"The inner exception."}]}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"RhinoAccountsException","dataType":"class","summary":"Base exception for all Rhino Accounts operations.","baseclass":"Exception","constructors":[{"signature":"RhinoAccountsException(Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"innerException","summary":"The inner exception."}]},{"signature":"RhinoAccountsException(string message, Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"message","summary":"The message of the exception."},{"name":"innerException","summary":"The inner exception."}]}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"RhinoAccountsGroup","dataType":"class","summary":"Represents a Rhino Accounts group.","constructors":[{"signature":"RhinoAccountsGroup(string id, string name)","summary":"Represents a group in Rhino Accounts. Groups are a collection of individual members that can share resources.","since":"7.0"}],"properties":[{"signature":"string Id","summary":"The id of the group. The id is unique to a group within Rhino Accounts.","since":"7.0","property":["get"]},{"signature":"string Name","summary":"The name of the group. The name can be changed at anytime by group members.","since":"7.0","property":["get"]}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"RhinoAccountsInvalidResponseException","dataType":"class","summary":"Exception thrown when the response returned by Rhino Accounts is not valid.","baseclass":"Rhino.Runtime.RhinoAccounts.RhinoAccountsException","constructors":[{"signature":"RhinoAccountsInvalidResponseException(Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"innerException","summary":"The inner exception."}]},{"signature":"RhinoAccountsInvalidResponseException(string message, Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"message","summary":"The message of the exception."},{"name":"innerException","summary":"The inner exception."}]}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"RhinoAccountsInvalidStateException","dataType":"class","summary":"Occurs when the state returned by the Rhino Accounts server is not the same as the one sent to the server. It usually indicates the request has been tampered with.","baseclass":"Rhino.Runtime.RhinoAccounts.RhinoAccountsException","constructors":[{"signature":"RhinoAccountsInvalidStateException(Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"innerException","summary":"The inner exception."}]},{"signature":"RhinoAccountsInvalidStateException(string message, Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"message","summary":"The message of the exception."},{"name":"innerException","summary":"The inner exception."}]}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"RhinoAccountsInvalidTokenException","dataType":"class","summary":"Exception thrown when the token returned by Rhino Accounts is not valid.","baseclass":"Rhino.Runtime.RhinoAccounts.RhinoAccountsException","constructors":[{"signature":"RhinoAccountsInvalidTokenException(Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"innerException","summary":"The inner exception."}]},{"signature":"RhinoAccountsInvalidTokenException(string message, Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"message","summary":"The message of the exception."},{"name":"innerException","summary":"The inner exception."}]}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"RhinoAccountsManager","dataType":"class","summary":"Performs various Rhino Accounts-related tasks.","methods":[{"signature":"static void ExecuteProtectedCode(Action<SecretKey> protectedCode)","summary":"Any synchronous method in the IRhinoAccountsManagerclass must be executed within the function passed to this method, or an InvalidOperationExceptionwill be thrown.","since":"7.0","parameters":[{"name":"protectedCode","summary":"A function returning an awaitable task that has a SecretKeypassed to it. You will need to pass this secret key to any method you wish to call within IRhinoAccountsManager."}]},{"signature":"static Task ExecuteProtectedCodeAsync(Func<SecretKey, Task> protectedCode)","summary":"Any asynchronous method in the IRhinoAccountsManagerclass must be executed within the function passed to this method, or an InvalidOperationExceptionwill be thrown.","parameters":[{"name":"protectedCode","summary":"A function returning an awaitable task that has a SecretKeypassed to it. You will need to pass this secret key to any method you wish to call within IRhinoAccountsManager."}]},{"signature":"static Task<Tuple<IOpenIDConnectToken, IOAuth2Token>> GetAuthTokensAsync(string clientId, string clientSecret, IEnumerable<string> scope, string prompt, int? maxAge, bool showUI, IProgress<RhinoAccoountsProgressInfo> progress, SecretKey secretKey, CancellationToken cancellationToken)","summary":"Asynchronously retrieves auth tokens with the given criteria from the Rhino Accounts server.","parameters":[{"name":"clientId","summary":"The unique id of the client registered in Rhino Accounts."},{"name":"clientSecret","summary":"The secret of the client registered in Rhino Accounts"},{"name":"scope","summary":"The scope desired for the tokens. Valid scope values can be found in the Rhino Accounts documentation."},{"name":"prompt","summary":"The prompt of the request. See Rhino Accounts documentation for details. You may pass None if no prompt is desired."},{"name":"maxAge","summary":"The maxAge of the request. See Rhino Accounts documentation for details. You may pass None if no maxAge should be enforced."},{"name":"showUI","summary":"True if the user should see a UI showing the progress of the operation and a way to cancel it, or False if the UI should not be displayed. If false, it is strongly recommended that you pass aobject and display your own UI to the user."},{"name":"progress","summary":"An object that will report the progress of the operation to the caller. If no progress is needed, you may pass null."},{"name":"secretKey","summary":"A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})"},{"name":"cancellationToken","summary":"A token that can be used to signal that the operation should be cancelled."}],"returns":"The auth tokens requested."},{"signature":"static Task<Tuple<IOpenIDConnectToken, IOAuth2Token>> GetAuthTokensAsync(string clientId, string clientSecret, SecretKey secretKey, CancellationToken cancellationToken)","summary":"Asynchronously retrieves auth tokens with the given criteria from the Rhino Accounts server.","since":"7.0","parameters":[{"name":"clientId","summary":"The unique id of the client registered in Rhino Accounts."},{"name":"clientSecret","summary":"The secret of the client registered in Rhino Accounts"},{"name":"secretKey","summary":"A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})"},{"name":"cancellationToken","summary":"A token that can be used to signal that the operation should be cancelled."}],"returns":"The auth tokens requested."},{"signature":"static Task RevokeAuthTokenAsync(IOAuth2Token oauth2Token, SecretKey secretKey, CancellationToken cancellationToken)","summary":"Invalidates/revokes an IOAuth2Tokenobject from the Rhino Accounts server.","since":"7.0","parameters":[{"name":"oauth2Token","summary":"The token to revoke."},{"name":"secretKey","summary":"A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})"},{"name":"cancellationToken","summary":"A token that can be used to signal that the operation should be cancelled."}]},{"signature":"static Tuple<IOpenIDConnectToken, IOAuth2Token> TryGetAuthTokens(string clientId, IEnumerable<string> scope, SecretKey secretKey)","summary":"Attempts to return cached auth tokens that match the given criteria if any have been stored in cache.","since":"7.0","parameters":[{"name":"clientId","summary":"The unique id of the client registered in Rhino Accounts."},{"name":"scope","summary":"The scope desired for the tokens. Valid scope values can be found in the Rhino Accounts documentation."},{"name":"secretKey","summary":"A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})"}],"returns":"Cached tokens matching the exact criteria passed, or None if none can be found matching the criteria."},{"signature":"static Tuple<IOpenIDConnectToken, IOAuth2Token> TryGetAuthTokens(string clientId, SecretKey secretKey)","summary":"Attempts to return cached auth tokens that match the given criteria if any have been stored in cache.","since":"7.0","parameters":[{"name":"clientId","summary":"The unique id of the client registered in Rhino Accounts."},{"name":"secretKey","summary":"A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})"}],"returns":"Cached tokens matching the exact criteria passed, or None if none can be found matching the criteria."},{"signature":"static Task<IOpenIDConnectToken> UpdateOpenIDConnectTokenAsync(IOpenIDConnectToken currentToken, IOAuth2Token oauth2Token, SecretKey secretKey, CancellationToken cancellationToken)","summary":"Updates an OpenID Connect token so that it contains the latest user information by contacting the Rhino Account\'s server userinfo endpoint using a compatible O","since":"7.0","parameters":[{"name":"currentToken","summary":"The existing OpenID Connect token that you wish to updated with the latest user information."},{"name":"oauth2Token","summary":"A valid OAuth2 token used for authorization. The OAuth2 token must have been issued together with the OpenID Connect token passed or a RhinoAccountsAuthTokenMismatchExceptionwill be thrown."},{"name":"secretKey","summary":"A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})"},{"name":"cancellationToken","summary":"A token that can be used to signal that the operation should be cancelled."}],"returns":"The updated OpenIDConnectToken based on the original token passed to this method."}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"RhinoAccountsOperationInProgressException","dataType":"class","summary":"Exception thrown when there is already a Rhino Accounts operation taking place.","baseclass":"Rhino.Runtime.RhinoAccounts.RhinoAccountsException","constructors":[{"signature":"RhinoAccountsOperationInProgressException(Assembly assembly, Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"assembly","summary":"The assembly that is currently performing an operation."},{"name":"innerException","summary":"The inner exception."}]},{"signature":"RhinoAccountsOperationInProgressException(string message, Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"message","summary":"The message of the exception."},{"name":"innerException","summary":"The inner exception."}]}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"RhinoAccountsProxyException","dataType":"class","summary":"Exception thrown when there is a problem with a proxy setting during a Rhino Accounts operation.","baseclass":"Rhino.Runtime.RhinoAccounts.RhinoAccountsException","constructors":[{"signature":"RhinoAccountsProxyException(Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"innerException","summary":"The inner exception."}]},{"signature":"RhinoAccountsProxyException(string message, Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"message","summary":"The message of the exception."},{"name":"innerException","summary":"The inner exception."}]}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"RhinoAccountsServerException","dataType":"class","summary":"Exception thrown when the Rhino Accounts server returned an unsuccessful HTTP response with a code of 400 or greater.","baseclass":"Rhino.Runtime.RhinoAccounts.RhinoAccountsException","constructors":[{"signature":"RhinoAccountsServerException(Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"innerException","summary":"The inner exception."}]},{"signature":"RhinoAccountsServerException(string message, Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"message","summary":"The message of the exception."},{"name":"innerException","summary":"The inner exception."}]}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"RhinoAccountsServerNotReachableException","dataType":"class","summary":"Exception thrown when the Rhino Accounts server cannot be reached due to a network problem.","baseclass":"Rhino.Runtime.RhinoAccounts.RhinoAccountsException","constructors":[{"signature":"RhinoAccountsServerNotReachableException(Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"innerException","summary":"The inner exception."}]},{"signature":"RhinoAccountsServerNotReachableException(string message, Exception innerException)","summary":"Generates a new instance of the exception.","since":"7.0","parameters":[{"name":"message","summary":"The message of the exception."},{"name":"innerException","summary":"The inner exception."}]}]},{"namespace":"Rhino.Runtime.RhinoAccounts","name":"SecretKey","dataType":"class","summary":"An instance of this of this class is given to the function you pass to ExceuteProtectedCodeAsync and must be passed to any method of the RhinoAccountsManager that requires it. Failure to do so will throw an InvalidOperationException."},{"namespace":"Rhino.Runtime","name":"RiskyAction","dataType":"class","summary":"Defines risky actions that need to be reported in crash exceptions","interfaces":["IDisposable"],"constructors":[{"signature":"RiskyAction(string description, string file, string member, int line)","summary":"Always create this in a using block","since":"6.0"}],"methods":[{"signature":"void Dispose()","summary":"IDisposable implementation","since":"6.0"}]},{"namespace":"Rhino.Runtime","name":"Skin","dataType":"class","summary":"Represents a customized environment that changes the appearance of Rhino.  \\nSkin DLLs must contain a single class that derives from the Skin class.","properties":[{"signature":"static Skin ActiveSkin","summary":"Any time Rhino is running there is at most one skin being used (and possibly no skin).  If a RhinoCommon based Skin class is being used, use ActiveSkin to get at the instance of this Skin class. May return null if no Skin is being used or if the skin is not a RhinoCommon based skin.","since":"5.0","property":["get"]},{"signature":"PersistentSettings Settings","summary":"Gets access to the skin persistent settings.","since":"5.0","property":["get"]}]},{"namespace":"Rhino.Runtime","name":"TextFields","dataType":"class","summary":"This Class Processes Text Field Functions","methods":[{"signature":"static double Area(string id)","summary":"Returns the area value for a selected object id","since":"7.0"},{"signature":"static double Area(string id, string unitSystem)","summary":"Returns the area value for a selected object id in a specified unit system","since":"7.0"},{"signature":"static string BlockAttributeText(string key, string prompt, string defaultValue)","summary":"User text associated with a block","since":"7.0"},{"signature":"static int BlockInstanceCount(string instanceDefinitionNameOrId)","summary":"Returns the number of block instances found in the document with the specified block definition name or the instance reference id.","since":"7.0"},{"signature":"static string BlockInstanceName(string blockId)","summary":"Returns the block definition name of a block instance","since":"7.0"},{"signature":"static double CurveLength(string id)","summary":"Get length of a curve given a string id","since":"7.0"},{"signature":"static double CurveLength(string id, string unitSystem)","summary":"Get length of a curve given a string id in a specified unit system. UnitSystem enumeration as string","since":"7.0"},{"signature":"static string Date()","summary":"Current date","since":"7.0"},{"signature":"static string Date(string dateFormat)","summary":"Current date in a specified format","since":"7.0"},{"signature":"static string Date(string dateFormat, string languageId)","summary":"Current Date in a specific format and language","since":"7.0"},{"signature":"static string DateModified()","summary":"Date the document was last edited","since":"7.0"},{"signature":"static string DateModified(string dateFormat)","summary":"Date the document was last edited in a specified format","since":"7.0"},{"signature":"static string DateModified(string dateFormat, string languageId)","summary":"Date the document was last edited in a specific format and language","since":"7.0"},{"signature":"static string DetailScale(string detailId, string scaleFormat)","summary":"Returns a detail views scale","since":"7.0"},{"signature":"static string DocumentText(string key)","summary":"Return document user string for a given key","since":"7.0"},{"signature":"static string FileName()","summary":"Return full path to the document","since":"7.0"},{"signature":"static string FileName(string options)","summary":"Return path to the document","since":"7.0"},{"signature":"static InstanceAttributeField[] GetInstanceAttributeFields(InstanceDefinition idef)","since":"7.0"},{"signature":"static InstanceAttributeField[] GetInstanceAttributeFields(string str)","summary":"Gets an array of block attribute definitions associated with a TextObject.","since":"7.0","parameters":[{"name":"str","summary":"TextObject to check for block attribute definitions"}],"returns":"Will return a empty array if text is None or there is no attributes otherwise; returns a list of one or more attribute definitions embedded in the text string."},{"signature":"static InstanceAttributeField[] GetInstanceAttributeFields(TextObject text)","summary":"Gets an array of block attribute definitions associated with a TextObject.","since":"7.0","parameters":[{"name":"text","summary":"TextObject to check for block attribute definitions"}],"returns":"Will return a empty array if text is None or there is no attributes otherwise; returns a list of one or more attribute definitions embedded in the text string."},{"signature":"static string LayerName(string layerId)","summary":"Returns the name of a layer based on the layers guid","since":"7.0"},{"signature":"static string LayoutUserText(string key)","summary":"Returns a value from the active layouts user text strings for the specified key.","since":"7.0"},{"signature":"static string LayoutUserText(string layoutId, string key)","summary":"Returns user text value from a layout id Key","since":"7.0"},{"signature":"static string ModelUnits()","since":"7.0"},{"signature":"static string Notes()","summary":"Notes for a RhinoDoc","since":"7.0"},{"signature":"static int NumPages()","summary":"Number of layout pages in a document","since":"7.0"},{"signature":"static string ObjectLayer(string id)","summary":"Return an object\'s layer name","since":"7.0"},{"signature":"static string ObjectName(string id)","summary":"Return an object\'s name","since":"7.0"},{"signature":"static double PageHeight()","summary":"Return the current layout page height in the layout units","since":"7.0"},{"signature":"static string PageName()","summary":"Return the current layout page name","since":"7.0"},{"signature":"static string PageName(string id)","summary":"Return the page name for the specified View ID","since":"7.0"},{"signature":"static int PageNumber()","summary":"Returns the current layouts page number","since":"7.0"},{"signature":"static double PageWidth()","summary":"Return the current layout page width in the layout units","since":"7.0"},{"signature":"static string PaperName()","summary":"Returns the layouts selected paper name example Letter / A4 / A6","since":"7.0"},{"signature":"static string PointCoordinate(string pointId, string axis)","summary":"returns the location of a 3d point","since":"7.0"},{"signature":"static string UserText(string id, string key)","summary":"User text associated with an object, block or layout","since":"7.0"},{"signature":"static string UserText(string id, string key, string prompt)","summary":"User text associated with an object, block or layout","since":"7.0"},{"signature":"static string UserText(string id, string key, string prompt, string defaultValue)","summary":"User text associated with an object, block or layout","since":"7.0"},{"signature":"static double Volume(string id)","summary":"Returns the volume for the selected object id","since":"7.0"},{"signature":"static double Volume(string id, string unitSystem)","summary":"Returns volume for selected object id in the specified unit system","since":"7.0"}]},{"namespace":"Rhino.Runtime","name":"TextFields.InstanceAttributeField","dataType":"class","constructors":[{"signature":"TextFields.InstanceAttributeField(string key, string prompt, string defaultValue)","summary":"Block attribute definition.","since":"7.0","parameters":[{"name":"key","summary":"Attribute key"},{"name":"prompt","summary":"Prompt displayed by the UI when inserting a block"},{"name":"defaultValue","summary":"Default value used when inserting a block"}]}],"properties":[{"signature":"string DefaultValue","summary":"Default value used when inserting a block","since":"7.0","property":["get"]},{"signature":"string Key","summary":"Attribute key","since":"7.0","property":["get"]},{"signature":"string Prompt","summary":"Prompt displayed by the UI when inserting a block","since":"7.0","property":["get"]}]},{"namespace":"Rhino.Runtime","name":"ViewCaptureWriter","dataType":"class","summary":"Callback system used by SVG and PDF exporter to generate documents","constructors":[{"signature":"ViewCaptureWriter(double dpi, Size pageSize)","since":"6.0"}],"methods":[{"signature":"void Draw(IntPtr constPtrPrintInfo, RhinoDoc doc)","since":"6.15"}]},{"namespace":"Rhino.Runtime","name":"ViewCaptureWriter.PathPoint","dataType":"struct","properties":[{"signature":"PointF Location","since":"6.0","property":["get","set"]},{"signature":"PointType PointType","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Runtime","name":"ViewCaptureWriter.Pen","dataType":"class","properties":[{"signature":"Color Color","since":"6.0","property":["get","set"]},{"signature":"float Width","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.Runtime","name":"ViewCaptureWriter.PointType","dataType":"enum","since":"6.0","values":[{"signature":"Move"},{"signature":"Line"},{"signature":"CubicBezier"},{"signature":"Close"}]},{"namespace":"Rhino.Runtime","name":"ZooClientParameters","dataType":"class","summary":"ZooClientParameters is a read-only set of parameters that control the flow of licensing inside ZooClient. Because this class flows through a number of other classes, functions, and UI, it is read-only so that inadvertent changes are not made to the data as it propagates from the caller.","constructors":[{"signature":"ZooClientParameters(Guid productGuid, Guid licenseGuid, string productTitle, int productBuildType, LicenseCapabilities capabilities, string licenseEntryTextMask, string productPath, object parentWindow, LicenseTypes selectedLicenseType, ValidateProductKeyDelegate validateProductKey, OnLeaseChangedDelegate onLeaseChangedDelegate, VerifyLicenseKeyDelegate verifyLicenseKeyDelegate, VerifyPreviousVersionLicenseDelegate verifyPreviousVersionLicenseKeyDelegate)","summary":"ZooClientParameters Constructor","since":"6.0","parameters":[{"name":"productGuid","summary":"Guid used by ZooClient to identify the plug-in requesting a license from ZooClient. This Guid may be used by different versions of the plug-in. If different licenses are used by different versions of the plug-in, the plug-in must also specify a LicenseGuid."},{"name":"licenseGuid","summary":"Guid used by ZooClient to identify the license saved by ZooClient. This differs from ProductGuid because different versions of a plug-in with the same Plug-in ID may need different licenses."},{"name":"productTitle","summary":"Title of product displayed in user interface"},{"name":"productBuildType","summary":""},{"name":"capabilities","summary":"Enum that declares whether this product supports evalation, licensing, purchasing, and cloud zoo"},{"name":"licenseEntryTextMask","summary":"Text mask used to limit input. EG: RH50-AAAA-AAAA-AAAA-AAAA-AAAA"},{"name":"productPath","summary":"Full path to DLL implementing product"},{"name":"parentWindow","summary":"Object used to parent UI DLLs"},{"name":"selectedLicenseType","summary":"Type of license currently used by this product"},{"name":"validateProductKey","summary":"Delegate called to validate the structure of a license key"},{"name":"onLeaseChangedDelegate","summary":"Delegate called when a cloud zoo lease changes"},{"name":"verifyLicenseKeyDelegate","summary":"Delegate called to verify the structure of a license key"},{"name":"verifyPreviousVersionLicenseKeyDelegate","summary":"Delegate called to verify the structure of an upgrade license key"}]}],"properties":[{"signature":"LicenseCapabilities Capabilities","summary":"LicenseCapabilities flags that set options for how licenses can be obtained for this product","since":"6.0","property":["get","set"]},{"signature":"string LicenseEntryTextMask","summary":"Text mask in the form @\\"RH4A-AAAA-AAAA-AAAA-AAAA-AAAA\\" that informs the user what numbers they are looking for","since":"6.0","property":["get"]},{"signature":"Guid LicenseGuid","summary":"Guid used by ZooClient to identify the license saved by ZooClient. This differs from ProductGuid because different versions of a plug-in with the same Plug-in ID may need different licenses.","since":"6.0","property":["get"]},{"signature":"OnLeaseChangedDelegate OnLeaseChanged","summary":"Delegate called by ZooClient when a cloud zoo lease is changed","since":"6.0","property":["get"]},{"signature":"object ParentWindow","summary":"Parent window assigned to any licensing dialogs that appear. If null, the Rhino main window is used.","since":"6.0","property":["get"]},{"signature":"int ProductBuildType","summary":"Product build type. Must be one of LicenseBuildType values.","since":"6.0","property":["get"]},{"signature":"Guid ProductGuid","summary":"Guid used by ZooClient to identify the plug-in requesting a license from ZooClient. This Guid may be used by different versions of the plug-in. If different licenses are used by different versions of the plug-in, the plug-in must also specify a LicenseGuid.","since":"6.0","property":["get"]},{"signature":"string ProductPath","summary":"Path to the application calling ZooClient","since":"6.0","property":["get"]},{"signature":"string ProductTitle","summary":"Title of the product, \\"Rhinoceros 6\\" for example.","since":"6.0","property":["get"]},{"signature":"LicenseTypes SelectedLicenseType","summary":"License type selected by default when user is prompted to enter a license key","since":"6.0","property":["get","set"]}],"methods":[{"signature":"ValidateResult VerifyLicenseKey(string licenseKey, string validationCode, DateTime validationCodeInstallDate, bool gracePeriodExpired, out LicenseData licenseData)","summary":"Called by GetLicense to ensure that the license key entered by the user is legitimate and can be used.","since":"6.0","parameters":[{"name":"licenseKey","summary":"License key string entered by user"},{"name":"validationCode","summary":"Validation code entered by user (only if a previous call to VerifyLicenseKey set LicenseData.RequiresOnlineValidation to true)."},{"name":"validationCodeInstallDate","summary":"Date that validation code was entered by user (only if a previous call to VerifyLicenseKey set LicenseData.RequiresOnlineValidation to true)."},{"name":"gracePeriodExpired","summary":"Date by which license validation must complete successfully."},{"name":"licenseData","summary":"Output parameter where return data about the license is set."}]},{"signature":"bool VerifyPreviousVersionLicense(string license, string previousVersionLicense, out string errorMessage)","summary":"When a caller calls GetLicense, ZooClient may call VerifyPreviousVersionLicense to ensure previousVersionLicense is legitimate and can be used to upgrade license.","since":"6.0","parameters":[{"name":"license","summary":"License key for current product. This was returned by a previous call to VerifyLicenseKey or ValidateProductKey."},{"name":"previousVersionLicense","summary":"License key entered by user to show upgrade eligibility for license."},{"name":"errorMessage","summary":"Error message to be displayed to user if something isn\'t correct."}]}]},{"namespace":"Rhino","name":"RuntimeEnvironment","dataType":"enum","summary":"ON::RuntimeEnvironment identifies a runtime environment (operating system). This value is saved in binary archives so appropriate adjustments to resources provided by runtime environments, like fonts, can be made when an archive created in one runtime environment is used in another.","values":[{"signature":"Unset =  0","summary":"ON::RuntimeEnvironment::Unset indicates no runtime is set."},{"signature":"None = 1","summary":"ON::RuntimeEnvironment::None indicates no runtime. This is a different condition from ON::Runtime::Unset."},{"signature":"Windows = 2","summary":"ON::RuntimeEnvironment::Windows indicates some version of Microsoft Windows."},{"signature":"Apple = 3","summary":"ON::RuntimeEnvironment::Apple indicates some version of Apple OS X or iOS."},{"signature":"Android =  4","summary":"ON::RuntimeEnvironment::Android indicates some version of Google Android."},{"signature":"Linux = 5","summary":"ON::RuntimeEnvironment::Linux indicates some version of Linux."}]},{"namespace":"Rhino","name":"ScaleValue","dataType":"class","summary":"Represents a scale with associated LengthValues and string representations of the scale. This allows for going back and forth from numerical representations of a scale and a string representation without \\"guessing\\" at the initial scale.","interfaces":["IDisposable"],"constructors":[{"signature":"ScaleValue()","summary":"Default constructor","since":"6.0"}],"properties":[{"signature":"double LeftToRightScale","summary":"LeftLengthValue / RightLengthValue","since":"6.0","property":["get"]},{"signature":"double RightToLeftScale","summary":"RightLengthValue / LeftLengthValue","since":"6.0","property":["get"]}],"methods":[{"signature":"static ScaleValue Create(LengthValue left, LengthValue right, ScaleStringFormat format)","summary":"Create from 2 length values","since":"6.0"},{"signature":"static ScaleValue Create(string s, StringParserSettings ps)","summary":"Create from string","since":"6.0"},{"signature":"static ScaleValue OneToOne()","summary":"Make a new ScaleValue set to OneToOne","since":"6.0"},{"signature":"void Dispose()","summary":"actively reclaim native allocated ON_SacleValue*","since":"6.0"},{"signature":"bool IsUnset()","summary":"Test IsUnset","since":"6.0"},{"signature":"LengthValue LeftLengthValue()","summary":"Get the Left LengthValue from Scale","since":"6.0"},{"signature":"LengthValue RightLengthValue()","summary":"Get the Right LengthValue from Scale","since":"6.0"}]},{"namespace":"Rhino","name":"ScaleValue.ScaleStringFormat","dataType":"enum","summary":"Specifies prefered formats for automatically created string descriptions of a scale value.","values":[{"signature":"None = 0","summary":"No preference for automatically created string descriptions of a scale value."},{"signature":"RatioFormat = 1","summary":"Prefer the ratio format using a colon, like \\"1:4\\" or \\"4:1\\"."},{"signature":"EquationFormat = 2","summary":"Prefer the equation format using an equal sign, like \\"1 = 4\\" or \\"4 = 1\\"."},{"signature":"FractionFormat = 3","summary":"Prefer the fraction format using a slash, like \\"1/4\\" or \\"4/1\\"."},{"signature":"Unset = 0xFF","summary":"ON_ScaleValue::ScaleStringFormat::Unset is used to indicate no preference is set. This condition is different from ON_ScaleValue::ScaleStringFormat::None."}]},{"namespace":"Rhino","name":"Symbols","dataType":"class","summary":"Characters used for different \'drafting style\' symbols","properties":[{"signature":"static char DegreeSymbol","summary":"Degree symbol used for angles","since":"6.0","property":["get"]},{"signature":"static char DiameterSymbol","summary":"Diameter symbol","since":"6.0","property":["get"]},{"signature":"static char PlusMinusSymbol","summary":"Plus-Minus tolerance symbol","since":"6.0","property":["get"]},{"signature":"static char RadiusSymbol","summary":"Radius symbol","since":"6.0","property":["get"]}]},{"namespace":"Rhino.UI.Controls","name":"CollapsibleSectionHolderImpl","dataType":"class","interfaces":["IMPL_CALLBACKS","IDisposable"],"constructors":[{"signature":"CollapsibleSectionHolderImpl(ICollapsibleSectionHolder client)","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.0","property":["get"]}],"methods":[{"signature":"static ICollapsibleSectionHolder Find(IntPtr cpp)","since":"6.0"},{"signature":"static ICollapsibleSectionHolder NewNativeWrapper(IntPtr cpp)","since":"6.0"},{"signature":"void Dispose()","since":"6.0"},{"signature":"bool IsSameObject(IntPtr cpp)","since":"6.0"}]},{"namespace":"Rhino.UI.Controls","name":"CollapsibleSectionImpl","dataType":"class","interfaces":["IMPL_CALLBACKS","IDisposable"],"constructors":[{"signature":"CollapsibleSectionImpl(ICollapsibleSection section)","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.0","property":["get"]},{"signature":"IRdkViewModel ViewModel","since":"6.0","property":["get","set"]}],"methods":[{"signature":"static void CreateHostedSection(ICollapsibleSection section)","since":"6.0"},{"signature":"static ICollapsibleSection Find(IntPtr cpp)","since":"6.0"},{"signature":"static ICollapsibleSection GetSibling(ICollapsibleSection section, Guid siblingSectionId)","since":"6.0"},{"signature":"static ICollapsibleSection[] GetSiblings(ICollapsibleSection section)","since":"6.0"},{"signature":"static ICollapsibleSection NewNativeWrapper(IntPtr cpp)","since":"6.0"},{"signature":"void __InternalSetParent(IntPtr parent)","since":"6.0"},{"signature":"void Dispose()","since":"6.0"},{"signature":"bool IsSameObject(IntPtr cpp)","since":"6.0"},{"signature":"void ReplaceClient(ICollapsibleSection client)","since":"6.0"}],"events":[{"signature":"DataChanged","since":"6.0"},{"signature":"ViewModelActivated","since":"6.0"}]},{"namespace":"Rhino.UI.Controls","name":"CollapsibleSectionImpl.Factory","dataType":"class","baseclass":"Rhino.UI.Controls.FactoryBase"},{"namespace":"Rhino.UI.Controls","name":"CollapsibleSectionViewModel","dataType":"class","summary":"Derive from this class to implement your own view model that wraps around a built in implementation of IRdkViewModel.  Use GetData etc to implement your properties.","baseclass":"Rhino.UI.Controls.IRdkViewModel","constructors":[{"signature":"CollapsibleSectionViewModel(ICollapsibleSection section)","summary":"Construct from your section - the view model should be a member of the section","since":"6.0"}],"properties":[{"signature":"IntPtr CppPointer","since":"6.0","property":["get"]}],"methods":[{"signature":"void Commit(Guid uuidDataType)","since":"6.0"},{"signature":"void Discard(Guid uuidDataType)","since":"6.0"},{"signature":"object GetData(Guid uuidDataType, bool bForWrite, bool bAutoChangeBracket)","summary":"Call for an interface to data","since":"6.0"},{"signature":"UndoRecord UndoHelper(string description)","summary":"Helper function to ease the use of undo records","since":"6.0","returns":"Return the undo record"}]},{"namespace":"Rhino.UI.Controls.DataSource","name":"EventArgs","dataType":"class","baseclass":"System.EventArgs","properties":[{"signature":"Guid DataType","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.UI.Controls.DataSource","name":"EventInfoArgs","dataType":"class","baseclass":"System.EventArgs","properties":[{"signature":"Guid DataType","since":"6.0","property":["get","set"]},{"signature":"IntPtr EventInfoPtr","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.UI.Controls.DataSource","name":"ProviderIds","dataType":"class","properties":[{"signature":"static Guid ContentChildSlot","since":"6.1","property":["get"]},{"signature":"static Guid ContentDatabase","since":"6.0","property":["get"]},{"signature":"static Guid ContentDisplayCollection","since":"6.0","property":["get"]},{"signature":"static Guid ContentEditorSettings","since":"6.0","property":["get"]},{"signature":"static Guid ContentLookup","since":"6.0","property":["get"]},{"signature":"static Guid ContentParam","since":"6.0","property":["get"]},{"signature":"static Guid ContentPreviewRendered","since":"6.0","property":["get"]},{"signature":"static Guid ContentSelection","since":"6.0","property":["get"]},{"signature":"static Guid ContentUIs","since":"6.0","property":["get"]},{"signature":"static Guid ContentUpdatePreviewMarkersEventInfo","since":"6.0","property":["get"]},{"signature":"static Guid CurrentEnvironment","since":"6.0","property":["get"]},{"signature":"static Guid Decals","since":"6.5","property":["get"]},{"signature":"static Guid Dithering","since":"6.0","property":["get"]},{"signature":"static Guid GroundPlane","since":"6.0","property":["get"]},{"signature":"static Guid ImageFileInfo","since":"6.2","property":["get"]},{"signature":"static Guid LinearWorkflow","since":"6.0","property":["get"]},{"signature":"static Guid NamedItem","since":"6.10","property":["get"]},{"signature":"static Guid NewContentControlAssignBy","since":"6.0","property":["get"]},{"signature":"static Guid NullGuid","since":"6.0","property":["get"]},{"signature":"static Guid PreviewSettings","since":"6.0","property":["get"]},{"signature":"static Guid RdkEdit","since":"6.5","property":["get"]},{"signature":"static Guid RdkRendering","since":"6.8","property":["get"]},{"signature":"static Guid RdkRenderingGamma","since":"6.8","property":["get"]},{"signature":"static Guid RdkRenderingPostEffectBloom","since":"7.0","property":["get"]},{"signature":"static Guid RdkRenderingPostEffectDOF","since":"6.10","property":["get"]},{"signature":"static Guid RdkRenderingPostEffectFog","since":"6.10","property":["get"]},{"signature":"static Guid RdkRenderingPostEffectGlare","since":"6.10","property":["get"]},{"signature":"static Guid RdkRenderingPostEffectGlow","since":"6.10","property":["get"]},{"signature":"static Guid RdkRenderingPostEffects","since":"6.8","property":["get"]},{"signature":"static Guid RdkRenderingProgress","since":"6.8","property":["get"]},{"signature":"static Guid RdkRenderingToneMapping","since":"6.8","property":["get"]},{"signature":"static Guid RenderChannels","since":"7.0","property":["get"]},{"signature":"static Guid RhinoSettings","since":"6.0","property":["get"]},{"signature":"static Guid SelectionNavigator","since":"6.0","property":["get"]},{"signature":"static Guid Skylight","since":"6.0","property":["get"]},{"signature":"static Guid Sun","since":"6.0","property":["get"]},{"signature":"static Guid Undo","since":"6.11","property":["get"]},{"signature":"static Guid UndoRecord","since":"6.0","property":["get"]}]},{"namespace":"Rhino.UI.Controls","name":"Delegates","dataType":"class"},{"namespace":"Rhino.UI.Controls","name":"FactoryBase","dataType":"class","summary":"Base class for CollapsibleSection and ViewModel factories used by the RDK UI","methods":[{"signature":"static Type[] Register()","summary":"Call this function during startup of current assembly to load classes with factory creation support are registed","since":"6.0"},{"signature":"static Type[] Register(PlugIn plugin)","summary":"Call this function during the startup of your plug-in to ensure that all classes that support factory creation are registed","since":"6.0"},{"signature":"IntPtr Get(Guid id)","summary":"Override this method to return a new instance of your class for the given ID","since":"6.0"}]},{"namespace":"Rhino.UI.Controls","name":"ICollapsibleSection","dataType":"interface","properties":[{"signature":"Color BackgroundColor","since":"6.0","property":["get","set"]},{"signature":"bool Collapsible","since":"6.0","property":["get"]},{"signature":"LocalizeStringPair CommandOptionName","since":"6.0","property":["get"]},{"signature":"int Height","since":"6.0","property":["get"]},{"signature":"bool Hidden","since":"6.0","property":["get"]},{"signature":"Guid Id","since":"6.0","property":["get"]},{"signature":"bool InitiallyExpanded","since":"6.0","property":["get"]},{"signature":"Guid PlugInId","since":"6.0","property":["get"]},{"signature":"string SettingsTag","since":"6.0","property":["get"]},{"signature":"IRdkViewModel ViewModel","since":"6.0","property":["get"]},{"signature":"Guid ViewModelId","since":"6.0","property":["get"]}],"methods":[{"signature":"int RunScript(IRdkViewModel vm)","since":"6.0"}]},{"namespace":"Rhino.UI.Controls","name":"ICollapsibleSectionHolder","dataType":"interface","properties":[{"signature":"Color BackgroundColor","since":"6.0","property":["set"]},{"signature":"int BottomMargin","since":"6.0","property":["get","set"]},{"signature":"string EmptyText","since":"6.0","property":["set"]},{"signature":"int LeftMargin","since":"6.0","property":["get","set"]},{"signature":"int RightMargin","since":"6.0","property":["get","set"]},{"signature":"int ScrollPosition","since":"6.0","property":["get","set"]},{"signature":"int SectionCount","since":"6.0","property":["get"]},{"signature":"IEnumerable<ICollapsibleSection> Sections","since":"6.0","property":["get"]},{"signature":"string SettingsPathSubKey","since":"6.0","property":["set"]},{"signature":"int TopMargin","since":"6.0","property":["get","set"]}],"methods":[{"signature":"void Add(ICollapsibleSection section)","since":"6.0"},{"signature":"void ExpandSection(ICollapsibleSection section, bool expand, bool ensureVisible)","since":"6.0"},{"signature":"bool IsSectionExpanded(ICollapsibleSection section)","since":"6.0"},{"signature":"void Remove(ICollapsibleSection section)","since":"6.0"},{"signature":"ICollapsibleSection SectionAt(int index)","since":"6.0"},{"signature":"void UpdateAllViews(int flags)","since":"6.0"}]},{"namespace":"Rhino.UI.Controls","name":"IHasCppImplementation","dataType":"interface","properties":[{"signature":"IntPtr CppPointer","since":"6.0","property":["get"]}]},{"namespace":"Rhino.UI.Controls","name":"InternalRdkViewModel.EventPriority","dataType":"enum","values":[{"signature":"Low"},{"signature":"Normal"},{"signature":"High"},{"signature":"RealTime"}]},{"namespace":"Rhino.UI.Controls","name":"InternalRdkViewModel.NewUndoRecord","dataType":"class","interfaces":["IDisposable"]},{"namespace":"Rhino.UI.Controls","name":"InternalRdkViewModel.UndoHelper","dataType":"class","interfaces":["IDisposable"]},{"namespace":"Rhino.UI.Controls","name":"InternalRdkViewModelFactory","dataType":"class","baseclass":"Rhino.UI.Controls.FactoryBase"},{"namespace":"Rhino.UI.Controls","name":"IRdkViewModel","dataType":"interface","methods":[{"signature":"void Commit(Guid uuidDataType)","since":"6.0"},{"signature":"void Discard(Guid uuidDataType)","since":"6.0"},{"signature":"object GetData(Guid uuidDataType, bool bForWrite, bool bAutoChangeBracket)","since":"6.0"}]},{"namespace":"Rhino.UI.Controls","name":"IWindow","dataType":"interface","properties":[{"signature":"LocalizeStringPair Caption","since":"6.0","property":["get"]},{"signature":"bool Created","since":"6.0","property":["get"]},{"signature":"bool Enabled","since":"6.0","property":["get","set"]},{"signature":"IntPtr Parent","since":"6.0","property":["get","set"]},{"signature":"bool Shown","since":"6.0","property":["get","set"]},{"signature":"IntPtr Window","since":"6.0","property":["get"]}],"methods":[{"signature":"void Move(Rectangle pos, bool bRepaint, bool bRepaintBorder)","since":"6.0"}]},{"namespace":"Rhino.UI.Controls.Thumbnaillist","name":"ThumbnailList","dataType":"class","baseclass":"Eto.Forms.Panel","interfaces":["IThumbnailList"],"constructors":[{"signature":"ThumbnailList()"}],"properties":[{"signature":"ContentEditingContext CEC","property":["get","set"]},{"signature":"bool Created","property":["get"]},{"signature":"bool Enabled","property":["get","set"]},{"signature":"string EnglishCaption","property":["get"]},{"signature":"bool Hidden","property":["get","set"]},{"signature":"IntPtr HolderParent","property":["set"]},{"signature":"string LocalCaption","property":["get"]},{"signature":"bool Shown","property":["get","set"]},{"signature":"RdkThumbnaillistViewModel ViewModel","property":["get"]}],"methods":[{"signature":"void Add(ref IRhRdkThumbnail t)"},{"signature":"void Clear()"},{"signature":"Rhino.Render.RenderContent ContentFromThumbId(ref Guid uuidThumb)"},{"signature":"IRhRdkThumbnail Get(ref Guid u)"},{"signature":"void GetGridMetrics(ref int w, ref int h, ref int ox, ref int oy)"},{"signature":"IRhRdkContentThumbnailList_Sizes GetSize()"},{"signature":"void GetStatisticsHeaderHeight()"},{"signature":"IRhRdkThumbnailList_Modes Mode()"},{"signature":"void Move(Rectangle rect, bool bRepaint, bool bRepaintNC)"},{"signature":"bool PropagateSelectedAppearance()"},{"signature":"void SaveMetaDataToDocument()"},{"signature":"Rhino.Render.PreviewAppearance SelectedAppearance()"},{"signature":"void SetClientText(string w)"},{"signature":"void SetCustomBitmapSize(int w, int h)"},{"signature":"void SetMode(IRhRdkThumbnailList_Modes m, bool b)"},{"signature":"void SetSearchPattern(string w)"},{"signature":"void SetSettingsPath(string w)"},{"signature":"void SetShowLabels(bool b)"},{"signature":"IRhRdkThumbnailList_Shapes Shape()"},{"signature":"bool ShowLabels()"},{"signature":"Guid UUID()"},{"signature":"void ViewModelActivated()"}]},{"namespace":"Rhino.UI.Controls.Thumbnaillist","name":"ThumbnailList.IHandler","dataType":"interface"},{"namespace":"Rhino.UI.Controls.ThumbnailUI","name":"IRhRdkContentThumbnail","dataType":"interface","methods":[{"signature":"Rhino.Render.RenderContent ChildContent()","since":"6.0","deprecated":"6.6"},{"signature":"Guid GroupId()","since":"6.0","deprecated":"6.6"},{"signature":"Rhino.Render.RenderContent TopLevelContent()","since":"6.0","deprecated":"6.6"}]},{"namespace":"Rhino.UI.Controls.ThumbnailUI","name":"IRhRdkContentThumbnailList_Sizes","dataType":"enum","since":"6.0","deprecated":"6.6","values":[{"signature":"Tiny","summary":"Tiny thumbnails."},{"signature":"Small","summary":"Small thumbnails."},{"signature":"Medium","summary":"Medium thumbnails."},{"signature":"Large","summary":"Large thumbnails."},{"signature":"Custom","summary":"Custom-sized thumbnails."}]},{"namespace":"Rhino.UI.Controls.ThumbnailUI","name":"IRhRdkThumbnail","dataType":"interface","methods":[{"signature":"void Dib(ref Bitmap dibOut)","since":"6.0","deprecated":"6.6"},{"signature":"System.Drawing.Bitmap GetDib()","since":"6.0","deprecated":"6.6"},{"signature":"void GetDisplayRect(ref RectangleF rectOut)","since":"6.0","deprecated":"6.6"},{"signature":"Guid Id()","since":"6.0","deprecated":"6.6"},{"signature":"bool IsHot()","since":"6.0","deprecated":"6.6"},{"signature":"bool IsSelected()","since":"6.0","deprecated":"6.6"},{"signature":"string Label()","since":"6.0","deprecated":"6.6"}]},{"namespace":"Rhino.UI.Controls.ThumbnailUI","name":"IRhRdkThumbnailList","dataType":"interface","methods":[{"signature":"void Add(Thumbnail t)","since":"6.0","deprecated":"6.6"},{"signature":"void Clear()","since":"6.0","deprecated":"6.6"},{"signature":"IRhRdkThumbnail Get(ref Guid u)","since":"6.0","deprecated":"6.6"},{"signature":"void GetGridMetrics(ref int w, ref int h, ref int ox, ref int oy)","since":"6.0","deprecated":"6.6"},{"signature":"IRhRdkContentThumbnailList_Sizes GetSize()","since":"6.0","deprecated":"6.6"},{"signature":"void GetStatisticsHeaderHeight()","since":"6.0","deprecated":"6.6"},{"signature":"IRhRdkThumbnailList_Modes Mode()","since":"6.0","deprecated":"6.6"},{"signature":"void SetClientText(string w)","since":"6.0","deprecated":"6.6"},{"signature":"void SetCustomBitmapSize(int w, int h)","since":"6.0","deprecated":"6.6"},{"signature":"void SetMode(IRhRdkThumbnailList_Modes m, bool b)","since":"6.0","deprecated":"6.6"},{"signature":"void SetShowLabels(bool b)","since":"6.0","deprecated":"6.6"},{"signature":"IRhRdkThumbnailList_Shapes Shape()","since":"6.0","deprecated":"6.6"},{"signature":"bool ShowLabels()","since":"6.0","deprecated":"6.6"},{"signature":"Guid UUID()","since":"6.0","deprecated":"6.6"}]},{"namespace":"Rhino.UI.Controls.ThumbnailUI","name":"IRhRdkThumbnailList_Modes","dataType":"enum","since":"6.0","deprecated":"6.6","values":[{"signature":"Grid","summary":"Big thumbnails like Explorer icon mode (default)."},{"signature":"List","summary":"Small thumbnails and info on right like Explorer report mode."},{"signature":"Tree","summary":"Tree view mode."}]},{"namespace":"Rhino.UI.Controls.ThumbnailUI","name":"IRhRdkThumbnailList_Shapes","dataType":"enum","since":"6.0","deprecated":"6.6","values":[{"signature":"Square","summary":"Square thumbnails."},{"signature":"Wide","summary":"Wide thumbnails."}]},{"namespace":"Rhino.UI.Controls.ThumbnailUI","name":"ThumbData","dataType":"class","properties":[{"signature":"List<ThumbData> Children","since":"6.0","deprecated":"6.6","property":["get","set"]},{"signature":"RenderContent Content","since":"6.0","deprecated":"6.6","property":["get","set"]},{"signature":"Guid Id","since":"6.0","deprecated":"6.6","property":["get","set"]},{"signature":"Bitmap Image","since":"6.0","deprecated":"6.6","property":["get","set"]},{"signature":"string Intensity","since":"6.0","deprecated":"6.6","property":["get","set"]},{"signature":"bool InUse","since":"6.0","deprecated":"6.6","property":["get","set"]},{"signature":"Color4f> InUseColor","since":"6.0","deprecated":"6.6","property":["get","set"]},{"signature":"string Name","since":"6.0","deprecated":"6.6","property":["get","set"]},{"signature":"ThumbData Parent","since":"6.0","deprecated":"6.6","property":["get","set"]},{"signature":"PreviewAppearance PreviewAppearance","since":"6.0","deprecated":"6.6","property":["get","set"]},{"signature":"bool Selected","since":"6.0","deprecated":"6.6","property":["get","set"]},{"signature":"List<string> Tags","since":"6.0","deprecated":"6.6","property":["get","set"]},{"signature":"bool TopLevel","since":"6.0","deprecated":"6.6","property":["get"]},{"signature":"string Type","since":"6.0","deprecated":"6.6","property":["get","set"]}],"methods":[{"signature":"static int GetPreviewHeigth(Sizes thumb_size, Shapes shape)","since":"6.0","deprecated":"6.6"},{"signature":"static int GetPreviewWidth(Sizes thumb_size, Shapes shape)","since":"6.0","deprecated":"6.6"}]},{"namespace":"Rhino.UI.Controls.ThumbnailUI","name":"Thumbnail","dataType":"class","baseclass":"Rhino.UI.Controls.ThumbnailUI.IRhRdkThumbnail","interfaces":["IDisposable"],"constructors":[{"signature":"Thumbnail(IntPtr pRdkThumbnail)","summary":"Constructor for Thumbnail","since":"6.0","deprecated":"6.6"}],"properties":[{"signature":"IntPtr CppPointer","summary":"Thumbnail c++ pointer","since":"6.0","deprecated":"6.6","property":["get"]}],"methods":[{"signature":"void Dib(ref Bitmap dibOut)","since":"6.0","deprecated":"6.6"},{"signature":"void Dispose()","summary":"Dispose for Thumbnail","since":"6.0","deprecated":"6.6"},{"signature":"System.Drawing.Bitmap GetDib()","since":"6.0","deprecated":"6.6"},{"signature":"void GetDisplayRect(ref RectangleF rectOut)","since":"6.0","deprecated":"6.6"},{"signature":"Guid Id()","since":"6.0","deprecated":"6.6"},{"signature":"bool IsHot()","since":"6.0","deprecated":"6.6"},{"signature":"bool IsSelected()","since":"6.0","deprecated":"6.6"},{"signature":"string Label()","since":"6.0","deprecated":"6.6"}]},{"namespace":"Rhino.UI.Controls.ThumbnailUI","name":"ThumbnailViewModelFactory","dataType":"class","baseclass":"Rhino.UI.Controls.InternalRdkViewModelFactory","constructors":[{"signature":"ThumbnailViewModelFactory()","since":"6.0","deprecated":"6.6"}],"methods":[{"signature":"IntPtr Get(Guid id)","since":"6.0","deprecated":"6.6"}]},{"namespace":"Rhino.UI.Controls","name":"UndoRecord","dataType":"class","summary":"Undo Record","interfaces":["IDisposable"],"constructors":[{"signature":"UndoRecord(string description, IRdkViewModel viewModel)","summary":"UndoRecord Constructor","since":"6.0"}],"methods":[{"signature":"void Dispose()","summary":"UndoRecord Dispose","since":"6.0"}]},{"namespace":"Rhino.UI","name":"CursorStyle","dataType":"enum","summary":"Standard mouse cursors in Rhino","values":[{"signature":"Default = 0"},{"signature":"Wait = 1","summary":"Wait"},{"signature":"CrossHair = 2"},{"signature":"Hand = 3"},{"signature":"Rotate = 4"},{"signature":"Magnify = 5"},{"signature":"ArrowCopy = 6","summary":"arrow with +"},{"signature":"CrosshairCopy = 7"}]},{"namespace":"Rhino.UI","name":"Dialogs","dataType":"class","methods":[{"signature":"static void KillSplash()","summary":"Destroy the splash screen if it is being displayed.","since":"5.0"},{"signature":"static void SetCustomColorDialog(EventHandler<GetColorEventArgs> handler)","since":"5.0"},{"signature":"static void ShowAboutDialog(bool forceSimpleDialog)","since":"6.0"},{"signature":"static bool[] ShowCheckListBox(string title, string message, IList items, IList<bool> checkState)","summary":"Displays Rhino\'s check list box.","since":"5.0","parameters":[{"name":"title","summary":"The dialog title."},{"name":"message","summary":"The dialog message."},{"name":"items","summary":"A list of items to show."},{"name":"checkState","summary":"A list of true/False boolean values."}],"returns":"An array or boolean values determining if the user checked the corresponding box. On error, null."},{"signature":"static bool ShowColorDialog(IWin32Window parent, ref Color4f color, bool allowAlpha)","summary":"Displays the standard modal color picker dialog for floating point colors.","since":"5.0","deprecated":"6.0","parameters":[{"name":"parent","summary":"Parent window for this dialog, should always pass this if calling from a form or user control."},{"name":"color","summary":"The initial color to set the picker to and also accepts the user\'s choice."},{"name":"allowAlpha","summary":"Specifies if the color picker should allow changes to the alpha channel or not."}],"returns":"True if a color was picked, False if the user canceled the picker dialog."},{"signature":"static bool ShowColorDialog(object parent, ref Color4f color, bool allowAlpha)","summary":"Displays the standard modal color picker dialog for floating point colors.","since":"6.0","parameters":[{"name":"parent","summary":"Parent window for this dialog, should always pass this if calling from a form or user control."},{"name":"color","summary":"The initial color to set the picker to and also accepts the user\'s choice."},{"name":"allowAlpha","summary":"Specifies if the color picker should allow changes to the alpha channel or not."}],"returns":"True if a color was picked, False if the user canceled the picker dialog."},{"signature":"static bool ShowColorDialog(object parent, ref Color4f color, bool allowAlpha, NamedColorList namedColorList, OnColorChangedEvent colorCallback)","summary":"Displays the standard modal color picker dialog for floating point colors.","since":"6.0","parameters":[{"name":"parent","summary":"Parent window for this dialog, should always pass this if calling from a form or user control."},{"name":"color","summary":"The initial color to set the picker to and also accepts the user\'s choice."},{"name":"allowAlpha","summary":"Specifies if the color picker should allow changes to the alpha channel or not."},{"name":"namedColorList","summary":"If not None and contains at least one named color this list will replace the standard Rhino Color list displayed by the rhino color dialog."},{"name":"colorCallback","summary":"May be optionally passed to ShowColorDialog and will get called when the color value changes in the color dialog."}],"returns":"True if a color was picked, False if the user canceled the picker dialog."},{"signature":"static bool ShowColorDialog(object parent, ref Color4f color, bool allowAlpha, OnColorChangedEvent colorCallback)","summary":"Displays the standard modal color picker dialog for floating point colors.","since":"6.0","parameters":[{"name":"parent","summary":"Parent window for this dialog, should always pass this if calling from a form or user control."},{"name":"color","summary":"The initial color to set the picker to and also accepts the user\'s choice."},{"name":"allowAlpha","summary":"Specifies if the color picker should allow changes to the alpha channel or not."},{"name":"colorCallback","summary":"May be optionally passed to ShowColorDialog and will get called when the color value changes in the color dialog."}],"returns":"True if a color was picked, False if the user canceled the picker dialog."},{"signature":"static bool ShowColorDialog(ref Color color)","summary":"Display Rhino\'s color selection dialog.","since":"5.0","parameters":[{"name":"color","summary":"[in/out] Default color for dialog, and will receive new color if function returns true."}],"returns":"True if the color changed. False if the color has not changed or the user pressed cancel."},{"signature":"static bool ShowColorDialog(ref Color color, bool includeButtonColors, string dialogTitle)","summary":"Display Rhino\'s color selection dialog.","since":"5.0","parameters":[{"name":"color","summary":"[in/out] Default color for dialog, and will receive new color if function returns true."},{"name":"includeButtonColors","summary":"Display button face and text options at top of named color list."},{"name":"dialogTitle","summary":"The title of the dialog."}],"returns":"True if the color changed. False if the color has not changed or the user pressed cancel."},{"signature":"static bool ShowColorDialog(ref Color color, bool includeButtonColors, string dialogTitle, NamedColorList namedColorList)","summary":"Display Rhino\'s color selection dialog.","since":"5.0","parameters":[{"name":"color","summary":"[in/out] Default color for dialog, and will receive new color if function returns true."},{"name":"includeButtonColors","summary":"Display button face and text options at top of named color list."},{"name":"dialogTitle","summary":"The title of the dialog."},{"name":"namedColorList","summary":"If not None and contains one or more named colors the Rhino color dialog named color list will be replaces with this list."}],"returns":"True if the color changed. False if the color has not changed or the user pressed cancel."},{"signature":"static bool ShowColorDialog(ref Color4f color, bool allowAlpha)","summary":"Displays the standard modal color picker dialog for floating point colors.","since":"5.0","parameters":[{"name":"color","summary":"The initial color to set the picker to and also accepts the user\'s choice."},{"name":"allowAlpha","summary":"Specifies if the color picker should allow changes to the alpha channel or not."}],"returns":"True if a color was picked, False if the user canceled the picker dialog."},{"signature":"static object ShowComboListBox(string title, string message, IList items)","summary":"Displays Rhino\'s combo list box.","since":"5.0","parameters":[{"name":"title","summary":"The dialog title."},{"name":"message","summary":"The dialog message."},{"name":"items","summary":"A list of items to show."}],"returns":"selected item.  \\nNone if the user canceled."},{"signature":"static int ShowContextMenu(IEnumerable<string> items, Point screenPoint, IEnumerable<int> modes)","summary":"Creates an ETO ContextMenu from an array of strings. Use the modes array to enable/disable menu items","since":"5.0"},{"signature":"static bool ShowEditBox(string title, string message, string defaultText, bool multiline, out string text)","summary":"Displays Rhino\'s string edit box.","since":"5.0","parameters":[{"name":"title","summary":"The dialog title."},{"name":"message","summary":"The dialog message."},{"name":"defaultText","summary":"The default text."},{"name":"multiline","summary":"Set True for multi line editing."},{"name":"text","summary":"The modified text."}],"returns":"True of OK was clicked, False otherwise."},{"signature":"static object ShowLineTypes(string title, string message, RhinoDoc doc)","summary":"Displays Rhino\'s LineType list box.","since":"6.7","parameters":[{"name":"title","summary":"The dialog title."},{"name":"message","summary":"The dialog message."},{"name":"doc","summary":"The active document."}],"returns":"The id of the selected item if successful, None on cancel."},{"signature":"static object ShowListBox(string title, string message, IList items)","summary":"Displays Rhino\'s list box.","since":"5.0","parameters":[{"name":"title","summary":"The dialog title."},{"name":"message","summary":"The dialog message."},{"name":"items","summary":"A list of items to show."}],"returns":"The selected item if successful, None on cancel."},{"signature":"static object ShowListBox(string title, string message, IList items, object selectedItem)","summary":"Displays Rhino\'s list box.","since":"5.0","parameters":[{"name":"title","summary":"The dialog title."},{"name":"message","summary":"The dialog message."},{"name":"items","summary":"A list of items to show."},{"name":"selectedItem","summary":"The item to preselect."}],"returns":"The selected item if successful, None on cancel."},{"signature":"static ShowMessageResult ShowMessage(object parent, string message, string title, ShowMessageButton buttons, ShowMessageIcon icon, ShowMessageDefaultButton defaultButton, ShowMessageOptions options, ShowMessageMode mode)","summary":"Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.","since":"6.0","parameters":[{"name":"parent","summary":"Parent window"},{"name":"message","summary":"Message box text content."},{"name":"title","summary":"Message box title text."},{"name":"buttons","summary":"Which buttons to display in the message box."},{"name":"icon","summary":"Which icon to display in the message box."},{"name":"defaultButton","summary":"Which button is the default button."},{"name":"options","summary":"Additional message box options."},{"name":"mode","summary":"The modality of the message box."}],"returns":"One of the ShowMessageBoxResult values."},{"signature":"static ShowMessageResult ShowMessage(string message, string title)","summary":"Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.","since":"6.0","parameters":[{"name":"message","summary":"Message box text content."},{"name":"title","summary":"Message box title text."}],"returns":"One of the ShowMessageBoxResult values."},{"signature":"static ShowMessageResult ShowMessage(string message, string title, ShowMessageButton buttons, ShowMessageIcon icon)","summary":"Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.","since":"6.0","parameters":[{"name":"message","summary":"Message box text content."},{"name":"title","summary":"Message box title text."},{"name":"buttons","summary":"Which buttons to display in the message box."},{"name":"icon","summary":"Which icon to display in the message box."}],"returns":"One of the ShowMessageBoxResult values."},{"signature":"static System.Windows.Forms.DialogResult ShowMessageBox(string message, string title)","summary":"Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.","since":"5.0","deprecated":"6.0"},{"signature":"static System.Windows.Forms.DialogResult ShowMessageBox(string message, string title, MessageBoxButtons buttons, MessageBoxIcon icon)","summary":"Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.","since":"5.0","deprecated":"6.0"},{"signature":"static string[] ShowMultiListBox(string title, string message, IList<string> items, IList<string> defaults)","summary":"Displays Rhino\'s multiple selection list box.","since":"5.12","parameters":[{"name":"title","summary":"The dialog title."},{"name":"message","summary":"The dialog message."},{"name":"items","summary":"A list of items to show."},{"name":"defaults","summary":"The items to preselect."}],"returns":"The selected items if successful, None on cancel."},{"signature":"static bool ShowNumberBox(string title, string message, ref double number)","summary":"Displays Rhino\'s number edit box.","since":"5.0","parameters":[{"name":"title","summary":"The dialog title."},{"name":"message","summary":"The dialog message."},{"name":"number","summary":"The default and return value."}],"returns":"True of OK was clicked, False otherwise."},{"signature":"static bool ShowNumberBox(string title, string message, ref double number, double minimum, double maximum)","summary":"Displays Rhino\'s number edit box.","since":"5.0","parameters":[{"name":"title","summary":"The dialog title."},{"name":"message","summary":"The dialog message."},{"name":"number","summary":"The default and return value."},{"name":"minimum","summary":"The minimum allowable value."},{"name":"maximum","summary":"The maximum allowable value."}],"returns":"True of OK was clicked, False otherwise."},{"signature":"static string[] ShowPropertyListBox(string title, string message, IList items, IList<string> values)","summary":"Displays Rhino\'s property list box.","since":"5.0","parameters":[{"name":"title","summary":"The dialog title."},{"name":"message","summary":"The dialog message."},{"name":"items","summary":"A list of property names."},{"name":"values","summary":"A list of property values."}],"returns":"A list of property values if successful, None otherwise."},{"signature":"static bool ShowSelectLayerDialog(ref int layerIndex, string dialogTitle, bool showNewLayerButton, bool showSetCurrentButton, ref bool initialSetCurrentState)","summary":"Displays Rhino\'s single layer selection dialog.","since":"5.0","parameters":[{"name":"layerIndex","summary":"Initial layer for the dialog, and will receive selected layer if function returns DialogResult.OK."},{"name":"dialogTitle","summary":"The dialog title."},{"name":"showNewLayerButton","summary":"True if the new layer button will be visible."},{"name":"showSetCurrentButton","summary":"True if the set current button will be visible."},{"name":"initialSetCurrentState","summary":"True if the current state will be initially set."}],"returns":"True if the dialog was closed with the OK button. False if the dialog was closed with escape."},{"signature":"static bool ShowSelectLinetypeDialog(ref int linetypeIndex, bool displayByLayer)","summary":"Displays Rhino\'s single linetype selection dialog.","since":"6.0","parameters":[{"name":"linetypeIndex","summary":"Initial linetype for the dialog, and will receive selected linetype if function returns true."},{"name":"displayByLayer","summary":"Displays the \\"ByLayer\\" linetype in the list. Defaults to false."}],"returns":"True if the dialog was closed with the OK button. False if the dialog was closed with escape."},{"signature":"static bool ShowSelectMultipleLayersDialog(IEnumerable<int> defaultLayerIndices, string dialogTitle, bool showNewLayerButton, out int[] layerIndices)","since":"5.9","returns":"True if the dialog was closed with the OK button. False if the dialog was closed with escape."},{"signature":"static System.Windows.Forms.DialogResult ShowSemiModal(Form form)","summary":"Show a windows form that is modal in the sense that this function does not return until the form is closed, but also allows for interaction with other elements of the Rhino user interface.","since":"5.0","deprecated":"6.0","parameters":[{"name":"form","summary":"The form must have buttons that are assigned to the \\"AcceptButton\\" and \\"CancelButton\\"."}],"returns":"One of the System.Windows.Forms.DialogResult values."},{"signature":"static bool ShowSunDialog(Sun sun)","summary":"Show the tabbed sun dialog.","since":"6.0","returns":"Returns True if the user clicked OK, or False if the user canceled."},{"signature":"static void ShowTextDialog(string message, string title)","summary":"Display a text dialog similar to the dialog used for the \\"What\\" command.","since":"5.0","parameters":[{"name":"message","summary":"Text to display as the message content."},{"name":"title","summary":"Test to display as the form title."}]}]},{"namespace":"Rhino.UI","name":"DistanceDisplayMode","dataType":"enum","since":"5.0","values":[{"signature":"Decimal = 0"},{"signature":"Fractional = 1"},{"signature":"FeetInches = 2"}]},{"namespace":"Rhino.UI","name":"DrawingUtilities","dataType":"class","summary":"RhinoCommon Drawing Utilities","methods":[{"signature":"static Bitmap BitmapFromIconResource(string resourceName, Assembly assembly)","summary":"Load a Icon from an embedded resource and convert it to a bitmap of the specified size.  Will look for a icon image that is greater than or equal to the requested size, if all images are less than the requested size the largest image will be used.","since":"6.12","parameters":[{"name":"resourceName","summary":""},{"name":"assembly","summary":"The assembly containing the manifest resource, will use the calling assembly if null."}]},{"signature":"static Bitmap BitmapFromIconResource(string resourceName, Size bitmapSize, Assembly assembly)","summary":"Load a Icon from an embedded resource and convert it to a bitmap of the specified size.  Will look for a icon image that is greater than or equal to the requested size, if all images are less than the requested size the largest image will be used.","since":"6.0","parameters":[{"name":"resourceName","summary":""},{"name":"bitmapSize","summary":"Desired bitmap size"},{"name":"assembly","summary":"The assembly containing the manifest resource, will use the calling assembly if null."}]},{"signature":"static Bitmap CreateMeshPreviewImage(IEnumerable<Mesh> meshes, IEnumerable<Color> colors, Size size)","summary":"Creates a preview image of one or more meshes.","since":"6.0","parameters":[{"name":"meshes","summary":"The meshes."},{"name":"colors","summary":"The draw colors, one for each mesh."},{"name":"size","summary":"The size of the preview image."}],"returns":"A bitmap if successful, None otherwise."},{"signature":"static Bitmap CreateMeshPreviewImage(Mesh mesh, Color color, Size size)","summary":"Creates a preview image of a mesh.","since":"6.0","parameters":[{"name":"mesh","summary":"The mesh."},{"name":"color","summary":"The draw color."},{"name":"size","summary":"The size of the preview image."}],"returns":"A bitmap if successful, None otherwise."},{"signature":"static Bitmap CreateMeshPreviewImage(RhinoDoc doc, IEnumerable<Mesh> meshes, IEnumerable<Color> colors, Size size)","summary":"Creates a preview image of one or more meshes.","since":"7.0","parameters":[{"name":"doc","summary":"The active document."},{"name":"meshes","summary":"The meshes."},{"name":"colors","summary":"The draw colors, one for each mesh."},{"name":"size","summary":"The size of the preview image."}],"returns":"A bitmap if successful, None otherwise."},{"signature":"static Icon IconFromResource(string resourceName, Assembly assembly)","summary":"Load a Icon from an embedded resource.","since":"6.0","parameters":[{"name":"resourceName","summary":"The case-sensitive name of the icon manifest resource being requested."},{"name":"assembly","summary":"The assembly containing the manifest resource, will use the calling assembly if null."}],"returns":"The Icon resource if found and loaded otherwise null."},{"signature":"static Icon IconFromResource(string resourceName, Size size, Assembly assembly)","summary":"Load a Icon from an embedded resource.","since":"6.0","parameters":[{"name":"resourceName","summary":"The case-sensitive name of the icon manifest resource being requested."},{"name":"size","summary":"The desired size of the icon."},{"name":"assembly","summary":"The assembly containing the manifest resource, will use the calling assembly if null."}],"returns":"The Icon resource if found and loaded otherwise null."},{"signature":"static Image ImageFromResource(string resourceName, Assembly assembly)","summary":"Load a Image from an embedded resource.","since":"6.0","parameters":[{"name":"resourceName","summary":"The case-sensitive name of the image manifest resource being requested."},{"name":"assembly","summary":"The assembly containing the manifest resource, will use the calling assembly if null."}],"returns":"The Image resource if found and loaded otherwise null."},{"signature":"static Bitmap LoadBitmapWithScaleDown(string iconName, int sizeDesired, Assembly assembly)","summary":"Loads an icon from an embedded resource and converts it to a bitmap. If the icon is not a standard size, this function scales down a larger image.","since":"6.0","parameters":[{"name":"iconName","summary":"The case-sensitive name of the icon manifest resource being requested."},{"name":"sizeDesired","summary":"The desired size, in pixels, of the icon."},{"name":"assembly","summary":"The assembly containing the manifest resource."}],"returns":"The icon converted to a bitmap if successful, None otherwise."},{"signature":"static Icon LoadIconWithScaleDown(string iconName, int sizeDesired, Assembly assembly)","summary":"Loads an icon from an embedded resource. If the icon is not a standard size, this function scales down a larger image.","since":"6.0","parameters":[{"name":"iconName","summary":"The case-sensitive name of the icon manifest resource being requested."},{"name":"sizeDesired","summary":"The desired size, in pixels, of the icon."},{"name":"assembly","summary":"The assembly containing the manifest resource."}],"returns":"The icon if successful, None otherwise."}]},{"namespace":"Rhino.UI","name":"Fonts","dataType":"class","summary":"Rhino.Rumtime.UI","properties":[{"signature":"static Font BoldHeadingFont","summary":"Returns a font that is 1.2x NormalFont and Bold","since":"6.0","property":["get"]},{"signature":"static Font HeadingFont","summary":"Returns a font used for dialog headings. 1.2x the size of NormalFont.","since":"6.0","property":["get"]},{"signature":"static Font NormalFont","summary":"Returns the normal font used for dialog boxes and buttons.","since":"6.0","property":["get"]},{"signature":"static Font SmallFont","summary":"Returns a font use for small text in dialog boxes. 0.8x the size of NormalFont.","since":"6.0","property":["get"]},{"signature":"static Font TitleFont","summary":"Returns a font used for dialog titles. 2x the size of NormalFont, and bold.","since":"6.0","property":["get"]}],"methods":[{"signature":"static Font GetUiFont(Style style, Size size)","summary":"GetUiFont provides access to a set of unmanaged fonts used by Rhino.","since":"6.0","parameters":[{"name":"style","summary":"Normal, Bold, Italic"},{"name":"size","summary":"One of several preset enumerable sizes"}]}]},{"namespace":"Rhino.UI","name":"Fonts.Size","dataType":"enum","summary":"Size for UI font.","values":[{"signature":"Small","summary":"0.8 x Normal"},{"signature":"Normal","summary":"1.0 x Normal"},{"signature":"Large","summary":"1.2 x Normal"},{"signature":"Title","summary":"2.0 x Normal"}]},{"namespace":"Rhino.UI","name":"Fonts.Style","dataType":"enum","summary":"Style for UI font.","values":[{"signature":"Regular = 0","summary":"Normal"},{"signature":"Bold = 1","summary":"Bold"},{"signature":"Italic = 2","summary":"Italic"},{"signature":"Underline = 4","summary":"Underline"},{"signature":"Strikeout = 8","summary":"Strikeout"}]},{"namespace":"Rhino.UI","name":"GetColorEventArgs","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"bool IncludeButtonColors","since":"5.0","property":["get"]},{"signature":"Color InputColor","since":"5.0","property":["get"]},{"signature":"Color SelectedColor","since":"5.0","property":["get","set"]},{"signature":"string Title","since":"5.0","property":["get"]}]},{"namespace":"Rhino.UI.Gumball","name":"GumballAppearanceSettings","dataType":"class","constructors":[{"signature":"GumballAppearanceSettings()","since":"5.0"}],"properties":[{"signature":"int ArcThickness","summary":"in pixels.","since":"5.0","property":["get","set"]},{"signature":"int ArrowHeadLength","summary":"in pixels.","since":"5.0","property":["get","set"]},{"signature":"int ArrowHeadWidth","summary":"in pixels.","since":"5.0","property":["get","set"]},{"signature":"int AxisThickness","summary":"in pixels.","since":"5.0","property":["get","set"]},{"signature":"Color ColorMenuButton","since":"5.0","property":["get","set"]},{"signature":"Color ColorX","summary":"Default is Red.","since":"5.0","property":["get","set"]},{"signature":"Color ColorY","summary":"Default is Green.","since":"5.0","property":["get","set"]},{"signature":"Color ColorZ","summary":"Default is Blue.","since":"5.0","property":["get","set"]},{"signature":"int FreeTranslate","summary":"When FreeTranslate is 1, the center translation control can be dragged in any direction and moves the object the gumball controls. When FreeTranslate is 2, the center translation control can be dragged in any direction and moves the object the gumball itself. The default value is 2.","since":"5.0","property":["get","set"]},{"signature":"int MenuDistance","summary":"Distance of menu ball from center.","since":"5.0","property":["get","set"]},{"signature":"bool MenuEnabled","summary":"When MenuEnabled is true, the menu \\"button\\" is drawn on the gumball. The default setting is true.","since":"5.0","property":["get","set"]},{"signature":"int MenuSize","summary":"Radius of menu circle.","since":"5.0","property":["get","set"]},{"signature":"int PlanarTranslationGripCorner","summary":"in pixels.","since":"5.0","property":["get","set"]},{"signature":"int PlanarTranslationGripSize","summary":"in pixels.","since":"5.0","property":["get","set"]},{"signature":"int Radius","summary":"in pixels.","since":"5.0","property":["get","set"]},{"signature":"bool RelocateEnabled","summary":"When RelocateEnabled is true, the user can reposition the gumball by tapping the control key while dragging.  Once the repostion drag is terminated by releasing the/ mouse button, ordinary editing resumes. The default setting is true.","since":"5.0","property":["get","set"]},{"signature":"bool RotateXEnabled","summary":"When RotateX is true, the X rotation control is available. The default setting is true.","since":"5.0","property":["get","set"]},{"signature":"bool RotateYEnabled","summary":"When RotateY is true, the Y rotation control is available. The default setting is true.","since":"5.0","property":["get","set"]},{"signature":"bool RotateZEnabled","summary":"When RotateZ is true, the Z rotation control is available. The default setting is true.","since":"5.0","property":["get","set"]},{"signature":"int ScaleGripSize","summary":"in pixels.","since":"5.0","property":["get","set"]},{"signature":"bool ScaleXEnabled","summary":"When ScaleXEnabled is true, the X scale control is available. The default setting is true.","since":"5.0","property":["get","set"]},{"signature":"bool ScaleYEnabled","summary":"When ScaleYEnabled is true, the Y scale control is available. The default setting is true.","since":"5.0","property":["get","set"]},{"signature":"bool ScaleZEnabled","summary":"When ScaleZEnabled is true, the Z scale control is available. The default setting is true.","since":"5.0","property":["get","set"]},{"signature":"bool TranslateXEnabled","summary":"TranslateXEnabled is true, the X axis translation control is available. The default setting is true.","since":"5.0","property":["get","set"]},{"signature":"bool TranslateXYEnabled","summary":"When TranslateXY is true, the XY plane translation control is available in appropriate views. The default setting is true.","since":"5.0","property":["get","set"]},{"signature":"bool TranslateYEnabled","summary":"TranslateYEnabled is true, the Y axis translation control is available. The default setting is true.","since":"5.0","property":["get","set"]},{"signature":"bool TranslateYZEnabled","summary":"When TranslateYZ is true, the YZ plane translation control is available in appropriate views. The default setting is true.","since":"5.0","property":["get","set"]},{"signature":"bool TranslateZEnabled","summary":"TranslateZEnabled is true, the Z axis translation control is available. The default setting is true.","since":"5.0","property":["get","set"]},{"signature":"bool TranslateZXEnabled","summary":"When TranslateZX is true, the ZX plane translation control is available in appropriate views. The default setting is true.","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.UI.Gumball","name":"GumballDisplayConduit","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"GumballDisplayConduit()","since":"5.0"}],"properties":[{"signature":"GumballObject BaseGumball","summary":"Starting location.","since":"5.0","property":["get"]},{"signature":"bool Enabled","since":"5.0","property":["get","set"]},{"signature":"GumballObject Gumball","since":"5.0","property":["get"]},{"signature":"Transform GumballTransform","summary":"The gumball transformation is the transformation calculated by comparing the current gumball to the starting BaseGumball.","since":"5.0","property":["get"]},{"signature":"bool InRelocate","since":"5.0","property":["get"]},{"signature":"GumballPickResult PickResult","summary":"The inital mouse down event sets PickResult.","since":"5.0","property":["get"]},{"signature":"Transform PreTransform","summary":"The pre-transform is a transformation that needs to be applied before the gumball transformation.","since":"5.0","property":["get","set"]},{"signature":"Transform TotalTransform","summary":"The total transformation is GumballTransform * PreTransform.","since":"5.0","property":["get"]}],"methods":[{"signature":"void CheckShiftAndControlKeys()","since":"5.0"},{"signature":"void Dispose()","since":"5.0"},{"signature":"bool PickGumball(PickContext pickContext, GetPoint getPoint)","since":"5.0"},{"signature":"void SetBaseGumball(GumballObject gumball)","summary":"Contents of the gumball are copied to the base gumball of this class.","since":"5.0","parameters":[{"name":"gumball","summary":"The gumball source."}]},{"signature":"void SetBaseGumball(GumballObject gumball, GumballAppearanceSettings appearanceSettings)","summary":"Contents of the gumball are copied to the base gumball of this class.","since":"5.0","parameters":[{"name":"gumball","summary":"The gumball source."},{"name":"appearanceSettings","summary":"The gumball appearance and behavior settings."}]},{"signature":"bool UpdateGumball(Point3d point, Line worldLine)","since":"5.0"}]},{"namespace":"Rhino.UI.Gumball","name":"GumballFrame","dataType":"struct","properties":[{"signature":"Plane Plane","since":"5.0","property":["get","set"]},{"signature":"Vector3d ScaleGripDistance","since":"5.0","property":["get","set"]},{"signature":"GumballScaleMode ScaleMode","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.UI.Gumball","name":"GumballMode","dataType":"enum","summary":"Transformation modes for gumballs.","since":"5.0","values":[{"signature":"None = 0"},{"signature":"Menu  = 1","summary":"Gumball menu button was picked."},{"signature":"TranslateFree = 2","summary":"Unconstrained translation."},{"signature":"TranslateX = 3","summary":"Translation along a single axis."},{"signature":"TranslateY = 4","summary":"Translation along a single axis."},{"signature":"TranslateZ = 5","summary":"Translation along a single axis."},{"signature":"TranslateXY = 6","summary":"Translation in a plane."},{"signature":"TranslateYZ = 7","summary":"Translation in a plane."},{"signature":"TranslateZX = 8","summary":"Translation in a plane."},{"signature":"ScaleX = 9","summary":"Scale along a single axis."},{"signature":"ScaleY = 10","summary":"Scale along a single axis."},{"signature":"ScaleZ = 11","summary":"Scale along a single axis."},{"signature":"ScaleXY = 12","summary":"Scale in a plane."},{"signature":"ScaleYZ = 13","summary":"Scale in a plane."},{"signature":"ScaleZX = 14","summary":"Scale in a plane."},{"signature":"RotateX = 15","summary":"Rotation around a single axis."},{"signature":"RotateY = 16","summary":"Rotation around a single axis."},{"signature":"RotateZ = 17","summary":"Rotation around a single axis."},{"signature":"ExtrudeX = 18","summary":"Extrusion along a single axis."},{"signature":"ExtrudeY = 19","summary":"Extrusion along a single axis."},{"signature":"ExtrudeZ = 20","summary":"Extrusion along a single axis."}]},{"namespace":"Rhino.UI.Gumball","name":"GumballObject","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"GumballObject()","since":"5.0"}],"properties":[{"signature":"GumballFrame Frame","since":"5.0","property":["get","set"]}],"methods":[{"signature":"void Dispose()","since":"5.0"},{"signature":"bool SetFromArc(Arc arc)","since":"5.0"},{"signature":"bool SetFromBoundingBox(BoundingBox boundingBox)","since":"5.0"},{"signature":"bool SetFromBoundingBox(Plane frame, BoundingBox frameBoundingBox)","summary":"Sets the gumball bounding box with respect to a frame.","since":"5.0","parameters":[{"name":"frame","summary":"The frame."},{"name":"frameBoundingBox","summary":"Bounding box with respect to frame."}],"returns":"True if input is valid and gumball is set. False if input is not valid. In this case, gumball is set to the default."},{"signature":"bool SetFromCircle(Circle circle)","since":"5.0"},{"signature":"bool SetFromCurve(Curve curve)","since":"5.0"},{"signature":"bool SetFromEllipse(Ellipse ellipse)","since":"5.0"},{"signature":"bool SetFromExtrusion(Extrusion extrusion)","since":"5.0"},{"signature":"bool SetFromHatch(Hatch hatch)","since":"5.0"},{"signature":"bool SetFromLight(Light light)","since":"5.0"},{"signature":"bool SetFromLine(Line line)","since":"5.0"},{"signature":"bool SetFromPlane(Plane plane)","since":"5.0"}]},{"namespace":"Rhino.UI.Gumball","name":"GumballPickResult","dataType":"class","properties":[{"signature":"GumballMode Mode","since":"5.0","property":["get"]}],"methods":[{"signature":"void SetToDefault()","since":"5.0"}]},{"namespace":"Rhino.UI.Gumball","name":"GumballScaleMode","dataType":"enum","since":"5.0","values":[{"signature":"Independent = 0"},{"signature":"XY = 1"},{"signature":"YZ = 2"},{"signature":"ZX = 3"},{"signature":"XYZ = 4"}]},{"namespace":"Rhino.UI","name":"IDialogService","dataType":"interface","methods":[{"signature":"IntPtr ObjectToWindowHandle(object window, bool useMainRhinoWindowWhenNull)","since":"6.0"},{"signature":"bool ShowColorDialog(object parent, ref Color4f color, bool allowAlpha, OnColorChangedEvent colorCallback)","since":"7.0"},{"signature":"string[] ShowMultiListBox(string title, string message, IList<string> items, IList<string> defaults)","since":"6.0"},{"signature":"object WrapAsIWin32Window(IntPtr handle)","since":"6.0"}]},{"namespace":"Rhino.UI","name":"IHelp","dataType":"interface","summary":"Implement this class to add help to a modeless UI panel.","properties":[{"signature":"string HelpUrl","summary":"Help topic URL which gets passed to RhinoHelp.Show","since":"6.0","property":["get"]}]},{"namespace":"Rhino.UI","name":"ILocalizationService","dataType":"interface","methods":[{"signature":"string LocalizeCommandName(Assembly assembly, int languageId, string english)","since":"6.0"},{"signature":"string LocalizeDialogItem(Assembly assembly, int languageId, string key, string english)","since":"6.0"},{"signature":"void LocalizeForm(Assembly assembly, int languageId, object formOrUserControl)","since":"6.0"},{"signature":"string LocalizeString(Assembly assembly, int languageId, string english, int contextId)","since":"6.0"}]},{"namespace":"Rhino.UI","name":"IPanel","dataType":"interface","methods":[{"signature":"void PanelClosing(uint documentSerialNumber, bool onCloseDocument)","since":"6.0"},{"signature":"void PanelHidden(uint documentSerialNumber, ShowPanelReason reason)","since":"6.0"},{"signature":"void PanelShown(uint documentSerialNumber, ShowPanelReason reason)","since":"6.0"}]},{"namespace":"Rhino.UI","name":"IPanelsService","dataType":"interface","summary":"For internal use, the IPanels service is implemented in RhinoWindows or RhinoMac as appropriate and handles the communication with core Rhino","methods":[{"signature":"void DestroyNativeWindow(object host, object nativeObject, bool disposeOfNativeObject)","since":"6.1"},{"signature":"void SetF1Hook(object nativeObject, EventHandler hook)","since":"6.1"},{"signature":"bool SupportedType(Type type, out string exceptionMessage)","since":"6.1"}]},{"namespace":"Rhino.UI","name":"IRhinoUiDialogService","dataType":"interface","summary":"Used by Rhino.UI.Dialogs to access generic Eto dialogs from Rhino Common","methods":[{"signature":"bool[] ShowCheckListBox(string title, string message, IList items, IList<bool> checkState)","since":"6.0"},{"signature":"object ShowComboListBox(string title, string message, IList items)","since":"6.0"},{"signature":"bool ShowEditBox(string title, string message, string defaultText, bool multiline, out string text)","since":"6.0"},{"signature":"object ShowLineTypes(string title, string message, RhinoDoc doc)","since":"6.7"},{"signature":"object ShowListBox(string title, string message, IList items, object selectedItem)","since":"6.0"},{"signature":"string[] ShowMultiListBox(IList<string> items, string message, string title, IList<string> defaults)","since":"6.10"},{"signature":"bool ShowNumberBox(string title, string message, ref double number, double minimum, double maximum)","since":"6.0"},{"signature":"int ShowPopupMenu(string[] arrItems, int[] arrModes, int? screenPointX, int? screenPointY)"}]},{"namespace":"Rhino.UI","name":"IStackedDialogPageService","dataType":"interface","summary":"For internal use, the IStackedDialogPageService service is implemented in RhinoWindows or RhinoMac as appropriate and handles the communication with core Rhino","methods":[{"signature":"IntPtr GetImageHandle(Icon icon, bool canBeNull)","summary":"Convert image to platform specific unmanaged pointer","since":"6.1"},{"signature":"IntPtr GetImageHandle(Image image, bool canBeNull)","summary":"Convert image to platform specific unmanaged pointer","since":"6.0"},{"signature":"IntPtr GetNativePageWindow(object nativeWindowObject, bool isRhinoPanel, out object host)","summary":"Get the unmanaged pointer associated with the pages content control","since":"6.0"},{"signature":"IntPtr GetNativePageWindow(object pageObject, bool isRhinoPanel, out object nativeWindowObject, out object host)","summary":"Get the unmanaged pointer associated with the pages content control","since":"6.1"},{"signature":"void RedrawPageControl(object pageControl)","summary":"Redraw the specified control.","since":"6.0","parameters":[{"name":"pageControl","summary":"Control to redraw"}]},{"signature":"bool TryGetControlMinimumSize(object controlObject, out SizeF size)","summary":"Get the minimum size associated with a control object","since":"6.5","parameters":[{"name":"controlObject","summary":"The control object to check for minimum size."},{"name":"size","summary":"The minimum size of the control if provided."}],"returns":"Returns True if get control minimum size found, False otherwise."}]},{"namespace":"Rhino.UI","name":"LOC","dataType":"class","summary":"Used a placeholder which is used by LocalizationProcessor application to create contextId mapped localized strings.","methods":[{"signature":"static string COMMANDNAME(string english)","summary":"Command names that need to be localized should call this function. The COMMANDNAME function doesn\'t actually do anything but return the original string. The LocalizationProcessor application walks through the source code of a project and looks for LOC.COMMANDNAME and builds a record for each command name for the translators that can be used by developers in a commands overridden Rhino.Commands.Command.LocalName which should call Rhino.UI.Localization.LocalizeCommandName(EnglishName)","since":"5.0","parameters":[{"name":"english","summary":"[in] The English string to localize."}]},{"signature":"static LocalizeStringPair CON(string english)","summary":"Command option name strings that need to be localized should call this function. The CON function doesn\'t actually do anything but return the original string. The LocalizationProcessor application walks through the source code of a project and looks for LOC.CON. The function is then replaced with a call to Localization.LocalizeCommandOptionName using a unique context ID.","since":"5.0","parameters":[{"name":"english","summary":"[in] The English string to localize."}],"returns":"Returns localized string pair with both the English and local names set to the English value."},{"signature":"static LocalizeStringPair CON(string english, object assemblyFromObject)","summary":"Command option name strings that need to be localized should call this function. The CON function doesn\'t actually do anything but return the original string. The LocalizationProcessor application walks through the source code of a project and looks for LOC.CON. The function is then replaced with a call to Localization.LocalizeCommandOptionName using a unique context ID.","since":"5.0","parameters":[{"name":"english","summary":"[in] The English string to localize."},{"name":"assemblyFromObject","summary":"[in] The object that identifies the assembly that owns the command option name."}],"returns":"Returns localized string pair with both the English and local names set to the English value."},{"signature":"static LocalizeStringPair COV(string english)","summary":"Command option name strings that need to be localized should call this function. The COV function doesn\'t actually do anything but return the original string. The LocalizationProcessor application walks through the source code of a project and looks for LOC.COV. The function is then replaced with a call to Localization.LocalizeCommandOptionValue using a unique context ID.","since":"5.0","parameters":[{"name":"english","summary":"[in] The English string to localize."}],"returns":"Returns localized string pair with both the English and local names set to the English value."},{"signature":"static LocalizeStringPair COV(string english, object assemblyFromObject)","summary":"Command option name strings that need to be localized should call this function. The COV function doesn\'t actually do anything but return the original string. The LocalizationProcessor application walks through the source code of a project and looks for LOC.COV. The function is then replaced with a call to Localization.LocalizeCommandOptionValue using a unique context ID.","since":"5.0","parameters":[{"name":"english","summary":"[in] The English string to localize."},{"name":"assemblyFromObject","summary":"[in] The object that identifies the assembly that owns the command option value."}],"returns":"Returns localized string pair with both the English and local names set to the English value."},{"signature":"static string STR(string english)","summary":"Strings that need to be localized should call this function. The STR function doesn\'t actually do anything but return the original string. The LocalizationProcessor application walks through the source code of a project and looks for LOC.STR. The function is then replaced with a call to Localization.LocalizeString using a unique context ID.","since":"5.0","parameters":[{"name":"english","summary":"[in] The English string to localize."}]},{"signature":"static string STR(string english, object assemblyOrObject)","summary":"Similar to string.Format(string, object)function.","since":"5.0","parameters":[{"name":"english","summary":"The English name."},{"name":"assemblyOrObject","summary":"Unused."}],"returns":"English name."}]},{"namespace":"Rhino.UI","name":"Localization","dataType":"class","properties":[{"signature":"static int CurrentLanguageId","since":"6.0","property":["get"]},{"signature":"static bool RunningAsEnglish","since":"6.0","property":["get"]}],"methods":[{"signature":"static string FormatArea(double area, UnitSystem units, DimensionStyle dimStyle, bool alternate)","summary":"Format an Area string from a number","since":"7.0"},{"signature":"static string FormatDistanceAndTolerance(double distance, UnitSystem units, DimensionStyle dimStyle, bool alternate)","since":"7.0","parameters":[{"name":"distance","summary":""},{"name":"units","summary":""},{"name":"dimStyle","summary":""},{"name":"alternate","summary":"primary or alternate"}]},{"signature":"static string FormatNumber(double x, UnitSystem units, DistanceDisplayMode mode, int precision, bool appendUnitSystemName)","summary":"Get a string version of a number in a given unit system / display mode.","since":"5.0","parameters":[{"name":"x","summary":"The number to format into a string."},{"name":"units","summary":"The unit system for the number."},{"name":"mode","summary":"How the number should be formatted."},{"name":"precision","summary":"The precision of the number."},{"name":"appendUnitSystemName","summary":"Adds unit system name to the end of the number."}],"returns":"The formatted number."},{"signature":"static string FormatVolume(double volume, UnitSystem units, DimensionStyle dimStyle, bool alternate)","summary":"Format a Volume string from a number","since":"7.0"},{"signature":"static string LocalizeCommandName(string english)","summary":"Commands that need to be localized should call this function.","since":"5.0","parameters":[{"name":"english","summary":"The localized command name."}]},{"signature":"static string LocalizeCommandName(string english, object assemblyOrObject)","since":"5.0"},{"signature":"static LocalizeStringPair LocalizeCommandOptionName(string english, int contextId)","since":"5.0"},{"signature":"static LocalizeStringPair LocalizeCommandOptionName(string english, object assemblyOrObject, int contextId)","since":"5.0"},{"signature":"static LocalizeStringPair LocalizeCommandOptionValue(string english, int contextId)","since":"5.0"},{"signature":"static LocalizeStringPair LocalizeCommandOptionValue(string english, object assemblyOrObject, int contextId)","since":"5.0"},{"signature":"static string LocalizeDialogItem(object assemblyOrObject, string key, string english)","summary":"Look in the dialog item list for the specified key and return the translated localized string if the key is found otherwise return the English string.","since":"5.5","parameters":[{"name":"assemblyOrObject","summary":"An assembly or an object from an assembly."},{"name":"key","summary":""},{"name":"english","summary":"The text in English."}],"returns":"Look in the dialog item list for the specified key and return the translated localized string if the key is found otherwise return the English string."},{"signature":"static void LocalizeForm(object formOrUserControl)","summary":"Look in the dialog item list for the specified key and return the translated localized string if the key is found otherwise return the English string.","since":"6.0"},{"signature":"static string LocalizeString(string english, int contextId)","summary":"Returns localized version of a given English string. This function should be auto-generated by the RmaLDotNetLocalizationProcessor application for every function that uses RMASTR.","since":"5.0","parameters":[{"name":"english","summary":"The text in English."},{"name":"contextId","summary":"The context ID."}],"returns":"The localized string."},{"signature":"static string LocalizeString(string english, object assemblyOrObject, int contextId)","summary":"Returns localized version of a given English string. This function should be auto-generated by the RmaLDotNetLocalizationProcessor application for every function that uses RMASTR.","since":"5.0","parameters":[{"name":"english","summary":"The text in English."},{"name":"assemblyOrObject","summary":"An assembly or an object from an assembly."},{"name":"contextId","summary":"The context ID."}],"returns":"The localized string."},{"signature":"static bool SetLanguageId(int id)","summary":"Sets the Id used for Localization in RhinoCommon.  Only useful for when using RhinoCommon outside of the Rhino process","since":"5.0","returns":"True if the language id could be set"},{"signature":"static string UnitSystemName(UnitSystem units, bool capitalize, bool singular, bool abbreviate)","summary":"Gets localized unit system name.  Uses current application locale id.","since":"5.0","parameters":[{"name":"units","summary":"The unit system."},{"name":"capitalize","summary":"True if the name should be capitalized."},{"name":"singular","summary":"True if the name is expressed for a singular element."},{"name":"abbreviate","summary":"True if name should be the abbreviation."}],"returns":"The unit system name."}]},{"namespace":"Rhino.UI","name":"LocalizeStringPair","dataType":"class","summary":"Pair of strings used for localization.","constructors":[{"signature":"LocalizeStringPair(string english, string local)","since":"5.0"}],"properties":[{"signature":"string English","since":"5.0","property":["get","set"]},{"signature":"string Local","since":"5.0","property":["get","set"]}],"methods":[{"signature":"string ToString()"}]},{"namespace":"Rhino.UI","name":"ModifierKey","dataType":"enum","since":"6.0","values":[{"signature":"None = 0"},{"signature":"Control = 1"},{"signature":"Shift = 2"}]},{"namespace":"Rhino.UI","name":"MouseButton","dataType":"enum","since":"6.0","values":[{"signature":"None = 0"},{"signature":"Left = 1"},{"signature":"Right = 2"},{"signature":"Middle = 4"}]},{"namespace":"Rhino.UI","name":"MouseCallback","dataType":"class","summary":"Used for intercepting mouse events in the Rhino views.","properties":[{"signature":"bool Enabled","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.UI","name":"MouseCallbackEventArgs","dataType":"class","baseclass":"System.ComponentModel.CancelEventArgs","properties":[{"signature":"MouseButtons Button","since":"5.0","property":["get"]},{"signature":"bool CtrlKeyDown","since":"6.0","property":["get"]},{"signature":"MouseButton MouseButton","since":"6.0","property":["get"]},{"signature":"bool ShiftKeyDown","since":"6.0","property":["get"]},{"signature":"RhinoView View","since":"5.0","property":["get"]},{"signature":"Point ViewportPoint","since":"5.0","property":["get"]}]},{"namespace":"Rhino.UI","name":"MouseCursor","dataType":"class","summary":"Contains static methods to control the mouse icon.","properties":[{"signature":"static Point2d Location","summary":"Retrieves the position of the mouse cursor, in screen coordinates","since":"5.8","property":["get"]}],"methods":[{"signature":"static void SetToolTip(string tooltip)","summary":"Sets a cursor tooltip string shown next to the mouse cursor. Overrides all cursor tooltip panes.","since":"5.0","parameters":[{"name":"tooltip","summary":"The text to show."}]}]},{"namespace":"Rhino.UI","name":"NamedColor","dataType":"class","summary":"An entry with name and color for the NamedColorList","constructors":[{"signature":"NamedColor(string name, Color color)","summary":"Initializes a new instance of the ColorListEntry with the specified name and color.","since":"7.0","parameters":[{"name":"name","summary":"Name of this color"},{"name":"color","summary":"Color value"}]}],"properties":[{"signature":"Color Color","summary":"Gets the color for this entry.","since":"7.0","property":["get"]},{"signature":"string Name","summary":"Gets the name of this color to show to the user.","since":"7.0","property":["get"]}]},{"namespace":"Rhino.UI","name":"NamedColorList","dataType":"class","summary":"A list of color name/value pairs.","baseclass":"List<NamedColor>","constructors":[{"signature":"NamedColorList(string name)","summary":"Initializes a new instance of the ColorList with the specified name.","since":"7.0","parameters":[{"name":"name","summary":"Name of the list (required)"}]},{"signature":"NamedColorList(string name, IEnumerable<NamedColor> entries)","summary":"Initializes a new instance of the ColorList with the specified name and entries.","since":"7.0","parameters":[{"name":"name","summary":"Name of the list (required)"},{"name":"entries","summary":"Initial set of color entries for the list"}]}],"properties":[{"signature":"static NamedColorList Default","summary":"Get the Rhino applications named color list.","since":"7.0","property":["get"]},{"signature":"string Name","summary":"The name of the color list, which may be displayed to the user.","since":"7.0","property":["get","set"]}]},{"namespace":"Rhino.UI","name":"ObjectPropertiesPage","dataType":"class","summary":"Base class used to add object property user interface panels","properties":[{"signature":"bool AllObjectsMustBeSupported","summary":"Returns True when running on Mac which requires only objects of SupportedTypes.  Returns False when running on Windows which only requires a single item of SupportedTypes to be selected.  Override if you wish to change the above behavior.","since":"6.7","property":["get"]},{"signature":"string EnglishPageTitle","summary":"English string used to describe this page","since":"5.0","property":["get"]},{"signature":"Icon Icon","summary":"(OBSOLETE - Override PageIcon instead) Icon to display in the object properties tab control","since":"5.0","property":["get"]},{"signature":"int Index","summary":"The page navigation control adds buttons in the order the pages are processed, override this method and return a sort index to move the button to the beginning of the list.  By default this returns -1 which puts the button at the end of the list.","since":"7.0","property":["get"]},{"signature":"string LocalPageTitle","summary":"Localized page description string, returns the EnglishPageTitle by default.","since":"5.0","property":["get"]},{"signature":"object PageControl","summary":"The control that represents this page. Rhino Windows supports classes that implement the IWin32Windows interface, are derived from System.Windows.FrameworkElement or Eto.Forms.Control.  Mac Rhino supports controls that are derived from NSview or Eto.Forms.Control.","since":"5.0","property":["get"]},{"signature":"string PageIconEmbeddedResourceString","summary":"Resource string for a embedded icon resource in the assembly containing the page instance.  If this returns a valid resource and Rhino can load the icon the loaded icon will get used directly otherwise; the PageIcon method will get called.","since":"6.4","property":["get"]},{"signature":"PropertyPageType PageType","summary":"Override this and return the page you want to replace a specific object properties page.","since":"5.11","property":["get"]},{"signature":"RhinoObject[] SelectedObjects","summary":"Return a list of Rhino objects to be processed by this object properties page","since":"5.11","property":["get"]},{"signature":"ObjectType SupportedTypes","summary":"Override to specify which objects this page supports","since":"6.0","property":["get"]},{"signature":"bool SupportsSubObjects","summary":"If your object properties page supports sub-object selection, you should override this method and return true.  This is ignored for view pages.  The default implementation returns false.","since":"6.0","property":["get"]}],"methods":[{"signature":"bool AnySelectedObject()","summary":"Return True if any of the selected objects match the given type","since":"6.0"},{"signature":"bool AnySelectedObject(bool allMustMatch)","summary":"Return True if any of the selected objects match the given type","since":"6.7","parameters":[{"name":"allMustMatch","summary":"If True then every selected object must match the object type otherwise; only a single object has to be of the specified type"}]},{"signature":"T[] GetSelectedObjects()","summary":"Get selected objects of a given type","since":"6.0"},{"signature":"RhinoObject[] GetSelectedObjects(ObjectType filter)","summary":"Get selected objects that match a given filter","since":"6.0"},{"signature":"void InitializeControls(RhinoObject rhObj)","summary":"Called on the active page after the selected objects list has changed to notify the page to initialize its content to reflect the new object list.","since":"5.0","deprecated":"6.0"},{"signature":"void ModifyPage(Action<ObjectPropertiesPageEventArgs> callbackAction)","summary":"Call this method when the page is ready to modify the selected objects list.  Rhino will suspend UpdatePageNotfictaion, call the passed action then restore UpdatePageNotfictaion.","since":"6.0","parameters":[{"name":"callbackAction","summary":"Called when it is safe to modify objects."}]},{"signature":"bool OnActivate(bool active)","summary":"Called when this page is activated/deactivated.","since":"5.0","parameters":[{"name":"active","summary":"If True then this page is on top otherwise it is about to be hidden."}],"returns":"If True then the page is hidden and the requested page is not activated otherwise will not allow you to change the current page. Default returns true.  The return value is currently ignored."},{"signature":"void OnCreateParent(IntPtr hwndParent)","summary":"Called when the parent container is initially created.","since":"5.0"},{"signature":"void OnHelp()","summary":"Called when the F1 key or help button is pressed, override to display plug-in specific help for this page.","since":"5.0"},{"signature":"void OnSizeParent(int width, int height)","summary":"Called when the parent containers client rectangle size has changed and the PageControl has been resized.","since":"5.0"},{"signature":"System.Drawing.Icon PageIcon(Size sizeInPixels)","summary":"Icon to display in the object properties tab control.  Will not get called if PageIconEmbeddedResourceString is overridden and provides a string for a successfully loaded icon resource.","since":"6.0","parameters":[{"name":"sizeInPixels","summary":"The requested icon size in pixels, DPI scaling has been applied.  The default value is 24 X DPI scale."}]},{"signature":"Commands.Result RunScript(ObjectPropertiesPageEventArgs e)","summary":"This method is called when scripting the Rhino Properties command and choosing this page.","since":"6.0","parameters":[{"name":"e","summary":"Provides access to the selected object list and document."}]},{"signature":"Commands.Result RunScript(RhinoDoc doc, RhinoObject[] objectList)","summary":"This method is called when scripting the Rhino Properties command and choosing this page.","since":"6.0","deprecated":"6.0","parameters":[{"name":"doc","summary":"Active RhinoDoc"},{"name":"objectList","summary":"List of objects selected by the Properties command."}]},{"signature":"bool ShouldDisplay(ObjectPropertiesPageEventArgs e)","summary":"Called when the selected objects list changes, return True if the object list contains one or more object the page can modify.","since":"6.0"},{"signature":"bool ShouldDisplay(RhinoObject rhObj)","summary":"Called when the selected objects list changes, return True if the object list contains one or more object the page can modify.","since":"5.0","deprecated":"6.0"},{"signature":"void UpdatePage(ObjectPropertiesPageEventArgs e)","summary":"Called on the active page after the selected objects list has changed to notify the page to initialize its content to reflect the new object list.","since":"6.0"}]},{"namespace":"Rhino.UI","name":"ObjectPropertiesPageCollection","dataType":"class","summary":"Passed to Rhino.PlugIns.PlugIn.ObjectPropertiesPages to allow a plug-in to add custom ObjectPropertiesPage pages to the Rhino properties panel.","properties":[{"signature":"RhinoDoc Document","summary":"Document associated with the Rhino properties panel.","since":"7.0","property":["get"]},{"signature":"uint DocumentRuntimeSerialNumber","summary":"Document associated with the Rhino properties panel.","since":"7.0","property":["get"]}],"methods":[{"signature":"void Add(ObjectPropertiesPage page)","summary":"Custom page to add","since":"7.0"}]},{"namespace":"Rhino.UI","name":"ObjectPropertiesPageEventArgs","dataType":"class","constructors":[{"signature":"ObjectPropertiesPageEventArgs(ObjectPropertiesPage page)","summary":"Used by ObjectPropertiesPageto notify the page when updating, modifying or determining if the page should be included in the navigation bar","since":"6.0","parameters":[{"name":"page","summary":"Page sending the message"}]}],"properties":[{"signature":"uint DocRuntimeSerialNumber","summary":"Document containing the objects and views","since":"6.0","property":["get"]},{"signature":"RhinoDoc Document","summary":"Document containing the objects and views","since":"6.0","property":["get"]},{"signature":"uint EventRuntimeSerialNumber","summary":"Gets the runtime serial number.","since":"6.14","property":["get"]},{"signature":"int ObjectCount","since":"6.0","property":["get"]},{"signature":"RhinoObject[] Objects","summary":"Return a list of Rhino objects to be processed by this object properties page","since":"6.0","property":["get"]},{"signature":"uint ObjectTypes","since":"6.0","property":["get"]},{"signature":"ObjectPropertiesPage Page","summary":"The page sending these arguments","since":"6.0","property":["get"]},{"signature":"RhinoView View","summary":"Active view","since":"6.0","property":["get"]},{"signature":"RhinoViewport Viewport","summary":"Active viewport","since":"6.0","property":["get"]}],"methods":[{"signature":"T[] GetObjects()","summary":"Get selected objects of a given type","since":"6.0"},{"signature":"RhinoObject[] GetObjects(ObjectType filter)","summary":"Get selected objects that match a given filter","since":"6.0"},{"signature":"bool IncludesObjectsType()","summary":"Return True if any of the selected objects match the given type","since":"6.0"},{"signature":"bool IncludesObjectsType(bool allMustMatch)","summary":"Return True if any of the selected objects match the given type","since":"6.7","parameters":[{"name":"allMustMatch","summary":"If True then every selected object must match the object type otherwise; only a single object has to be of the specified type"}]},{"signature":"bool IncludesObjectsType(ObjectType objectTypes)","since":"6.0"},{"signature":"bool IncludesObjectsType(ObjectType objectTypes, bool allMustMatch)","since":"6.7","parameters":[{"name":"objectTypes","summary":""},{"name":"allMustMatch","summary":"If True then every selected object must match the object type otherwise; only a single object has to be of the specified type"}]}]},{"namespace":"Rhino.UI","name":"OpenFileDialog","dataType":"class","summary":"Similar to the System.Windows.Forms.OpenFileDialog, but with customized Rhino user interface.","constructors":[{"signature":"OpenFileDialog()","summary":"Create a new open file dialog.","since":"5.0"}],"properties":[{"signature":"string DefaultExt","summary":"The default file name extension. The returned string does not include the period.","since":"5.0","property":["get","set"]},{"signature":"string FileName","summary":"Gets or sets a string containing the file name selected in the file dialog box.","since":"5.0","property":["get","set"]},{"signature":"string[] FileNames","summary":"Gets the names of all of the selected files in the dialog box","since":"5.0","property":["get","set"]},{"signature":"string Filter","summary":"Gets or sets the current file name filter string, which determines the choices that appear in the \\"Save as file type\\" or \\"Files of type\\" box in the dialog box. See System.Windows.Forms.FileDialog for details.","since":"5.0","property":["get","set"]},{"signature":"string InitialDirectory","summary":"Gets or sets the initial directory displayed by the file dialog box.","since":"5.0","property":["get","set"]},{"signature":"bool MultiSelect","summary":"Gets or sets a value indicating whether the dialog box allows multiple files to be selected","since":"5.0","property":["get","set"]},{"signature":"string Title","summary":"Gets or sets the file dialog box title.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"System.Windows.Forms.DialogResult ShowDialog()","since":"5.0","deprecated":"6.0"},{"signature":"bool ShowOpenDialog()","summary":"Show the actual dialog to allow the user to select a file.","since":"5.10","returns":"True if a file was selected. False if the dialog was canceled"}]},{"namespace":"Rhino.UI","name":"OptionPageButtons","dataType":"enum","summary":"Standard IRhinoOptionsPageButton","values":[{"signature":"None = 0x00000000","summary":"Don\'t display any of the standard buttons."},{"signature":"DefaultButton = 0x00000001","summary":"The \\"Restore Defaults\\" button located at the bottom of the host."},{"signature":"ApplyButton   = 0x00000002","summary":"The \\"Apply\\" button located at the bottom of the host."}]},{"namespace":"Rhino.UI","name":"OptionsDialogPage","dataType":"class","baseclass":"Rhino.UI.StackedDialogPage","methods":[{"signature":"Commands.Result RunScript(RhinoDoc doc, RunMode mode)","since":"5.0"}]},{"namespace":"Rhino.UI","name":"PanelEventArgs","dataType":"class","summary":"Panels.Show event arguments","baseclass":"EventArgs","constructors":[{"signature":"PanelEventArgs(Guid panelId, uint documentSerialNumber)","since":"6.0"}],"properties":[{"signature":"RhinoDoc Document","since":"6.0","property":["get"]},{"signature":"uint DocumentSerialNumber","since":"6.0","property":["get","set"]},{"signature":"Guid PanelId","summary":"Class Id for panel being shown or hidden","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.UI","name":"PanelIds","dataType":"class","summary":"Standard Rhino panel Id\'s","properties":[{"signature":"static Guid ContextHelp","summary":"Rhino context sensitive help panel.","since":"5.0","property":["get"]},{"signature":"static Guid Display","since":"5.0","property":["get"]},{"signature":"static Guid Environment","summary":"Rhino environment panel","since":"5.0","property":["get"]},{"signature":"static Guid GroundPlane","summary":"Rhino ground plane panel","since":"5.0","property":["get"]},{"signature":"static Guid Layers","summary":"Rhino Layer panel","since":"5.0","property":["get"]},{"signature":"static Guid Libraries","summary":"Rhino render properties panel","since":"5.9","property":["get"]},{"signature":"static Guid LightManager","summary":"Rhino light manager panel","since":"5.0","property":["get"]},{"signature":"static Guid Materials","summary":"Rhino material browser","since":"5.0","property":["get"]},{"signature":"static Guid Notes","summary":"Rhino notes panel","since":"5.9","property":["get"]},{"signature":"static Guid ObjectProperties","summary":"Rhino object properties panel","since":"5.0","property":["get"]},{"signature":"static Guid Rendering","summary":"Rhino rendering properties panel","since":"6.0","property":["get"]},{"signature":"static Guid Sun","summary":"Rhino sun panel","since":"5.0","property":["get"]},{"signature":"static Guid Texture","summary":"Rhino texture panel","since":"5.3","property":["get"]}]},{"namespace":"Rhino.UI","name":"Panels","dataType":"class","summary":"Access to Rhino panels and register custom panels","properties":[{"signature":"static string EtoPanelStyleName","summary":"Style applied to Eto controls hosted by the Rhino.UI.Panels and Rhino.UI.ObjectProperties systems.","since":"6.15","property":["get"]},{"signature":"static Size IconSize","summary":"Gets the panel icon size in logical units.","since":"6.12","property":["get"]},{"signature":"static Size ScaledIconSize","summary":"Gets the panel icon size in pixels with DPI scaling applied.","since":"6.12","property":["get"]}],"methods":[{"signature":"static void ChangePanelIcon(Type panelType, Icon icon)","summary":"Update the icon used for a panel tab.","since":"6.0","parameters":[{"name":"panelType","summary":""},{"name":"icon","summary":"New icon to use"}]},{"signature":"static void ClosePanel(Guid panelId)","summary":"Will close or hide the specified panel type, in Windows Rhino, if it is the only visible tab the tab dock bar will be closed as well.  In Mac Rhino it will always close the modeless dialog hosting the panel.","since":"5.0","parameters":[{"name":"panelId","summary":"Class type Id of the panel to close."}]},{"signature":"static void ClosePanel(Type panelType)","summary":"Will close or hide the specified panel type, in Windows Rhino, if it is the only visible tab the tab dock bar will be closed as well.  In Mac Rhino it will always close the modeless dialog hosting the panel.","since":"5.0","parameters":[{"name":"panelType","summary":"Class type of the panel to close."}]},{"signature":"static bool FloatPanel(Guid panelTypeId, FloatPanelMode mode)","summary":"Mac support: Display the specified panel in a floating window on Mac, the floating window will only contain the specified panel.  Windows support: On Windows this will show or hide the floating container containing the specified panel.  If the tab is docked with other tabs it will be floated in a new container.","since":"6.2","parameters":[{"name":"panelTypeId","summary":"Guid for the panel type to show/hide."},{"name":"mode","summary":"Show, hide or toggle the visibility state of the specified panel"}],"returns":"Returntrueif the panel visibility state was changed,falseotherwise."},{"signature":"static bool FloatPanel(Type panelType, FloatPanelMode mode)","summary":"Mac support: Display the specified panel in a floating window on Mac, the floating window will only contain the specified panel.  Windows support: On Windows this will show or hide the floating container containing the specified panel.  If the tab is docked with other tabs it will be floated in a new container.","since":"6.2","parameters":[{"name":"panelType","summary":"Panel type to show/hide."},{"name":"mode","summary":"Show, hide or toggle the visibility state of the specified panel"}],"returns":"Returntrueif the panel visibility state was changed,falseotherwise."},{"signature":"static Guid[] GetOpenPanelIds()","summary":"Get a list of the currently open panel tabs in Windows Rhino, on Mac Rhino it will be a list of the currently visible modeless panel dialogs.","since":"5.0","returns":"Returns an array of panel class Id\'s for the currently open panels, if there are no open panels it will be an empty array."},{"signature":"static T GetPanel()","summary":"Return an instance of a .Net panel","since":"6.0","deprecated":"6.0"},{"signature":"static object GetPanel(Guid panelId)","summary":"Will return an instance of a .Net panel if the panel has been displayed at least once.  Panel instances are not created until a panel is displayed.","since":"5.0","deprecated":"6.0","parameters":[{"name":"panelId","summary":"Class Id of the panel to search for."}],"returns":"Returns the one and only instance of a panel if it has been properly registered and displayed at least once.  If the panel has never been displayed then None will be returned even if the panel is properly registered."},{"signature":"static object GetPanel(Guid panelId, RhinoDoc rhinoDoc)","summary":"Will return an instance of a .Net panel if the panel has been displayed at least once.  Panel instances are not created until a panel is displayed.","since":"6.0","parameters":[{"name":"panelId","summary":"Class Id of the panel to search for."},{"name":"rhinoDoc","summary":"Runtime document Id associated with the requested panel."}],"returns":"Returns the one and only instance of a panel if it has been properly registered and displayed at least once.  If the panel has never been displayed then None will be returned even if the panel is properly registered."},{"signature":"static object GetPanel(Guid panelId, uint documentSerialNumber)","summary":"Will return an instance of a .Net panel if the panel has been displayed at least once.  Panel instances are not created until a panel is displayed.","since":"6.0","parameters":[{"name":"panelId","summary":"Class Id of the panel to search for."},{"name":"documentSerialNumber","summary":"Runtime document Id associated with the requested panel."}],"returns":"Returns the one and only instance of a panel if it has been properly registered and displayed at least once.  If the panel has never been displayed then None will be returned even if the panel is properly registered."},{"signature":"static T GetPanel(RhinoDoc rhinoDoc)","summary":"Return an instance of a .Net panel","since":"6.0","parameters":[{"name":"rhinoDoc","summary":"Runtime document Id associated with the requested panel."}]},{"signature":"static T GetPanel(uint documentSerialNumber)","summary":"Return an instance of a .Net panel","since":"6.0","parameters":[{"name":"documentSerialNumber","summary":"Runtime document Id associated with the requested panel."}]},{"signature":"static object [] GetPanels(Guid panelId, RhinoDoc doc)","summary":"Gets the panels.","since":"6.3","parameters":[{"name":"panelId","summary":"Panel identifier."},{"name":"doc","summary":"Document."}],"returns":"The panels."},{"signature":"static object[] GetPanels(Guid panelId, uint documentRuntimeSerialNumber)","summary":"Gets the panels.","since":"6.3","parameters":[{"name":"panelId","summary":"Panel identifier."},{"name":"documentRuntimeSerialNumber","summary":"Document runtime serial number."}],"returns":"The panels."},{"signature":"static T[] GetPanels(RhinoDoc doc)","since":"6.3"},{"signature":"static T [] GetPanels(uint documentRuntimeSerialNumber)","summary":"Gets the panels.","since":"6.3","parameters":[{"name":"documentRuntimeSerialNumber","summary":"Document runtime serial number."}],"returns":"The panels."},{"signature":"static bool IsHiding(ShowPanelReason reason)","summary":"Check to see if reason is equal to any of the show events","since":"6.0"},{"signature":"static bool IsPanelVisible(Guid panelId)","summary":"Check to see if a panel is currently visible, on Windows this means you can see the tab, it does not necessarily mean it is the current tab.","since":"5.0","parameters":[{"name":"panelId","summary":"Class Id for the panel to check."}],"returns":"Returns True if the tab is visible otherwise it returns false."},{"signature":"static bool IsPanelVisible(Guid panelId, bool isSelectedTab)","summary":"Check to see if a panel is currently visible, if isSelectedTab is True then the tab must be the active tab as well.","since":"6.0","parameters":[{"name":"panelId","summary":"Class Id for the panel to check."},{"name":"isSelectedTab","summary":"This parameter is ignored on Mac.  If Windows and True the panel must be visible in a container and if it is a tabbed container it must be the active tab to be true."}],"returns":"On Windows: The return value is dependent on the isSelectedTab value.  If isSelectedTab is True then the panel must be included in a visible tabbed container and must also be the active tab to be true.  If isSelectedTab is False then the panel only has to be included in a visible tabbed container to be true. On Mac: isSelected is ignored and True is returned if the panel appears in any inspector panel."},{"signature":"static bool IsPanelVisible(Type panelType)","summary":"Check to see if a panel is currently visible, on Windows this means you can see the tab, it does not necessarily mean it is the current tab.","since":"5.0","parameters":[{"name":"panelType","summary":"Type of panel to check for, this type must include a GUID attribute."}],"returns":"Returns True if panelType is non None and the tab is visible otherwise it returns false."},{"signature":"static bool IsPanelVisible(Type panelType, bool isSelectedTab)","summary":"Check to see if a panel is currently visible, if isSelectedTab is True then the tab must be the active tab as well.","since":"6.0","parameters":[{"name":"panelType","summary":"Type of panel to check for, this type must include a GUID attribute."},{"name":"isSelectedTab","summary":"This parameter is ignored on Mac.  If Windows and True the panel must be visible in a container and if it is a tabbed container it must be the active tab to be true."}],"returns":"On Windows: The return value is dependent on the isSelectedTab value.  If isSelectedTab is True then the panel must be included in a visible tabbed container and must also be the active tab to be true.  If isSelectedTab is False then the panel only has to be included in a visible tabbed container to be true. On Mac: isSelected is ignored and True is returned if the panel appears in any inspector panel."},{"signature":"static bool IsShowing(ShowPanelReason reason)","summary":"Check to see if reason is equal to any of the hide events","since":"6.0"},{"signature":"static void OnClosePanel(Guid panelId, uint documentSerialNumber)","summary":"Call this method to raise the Closed event","since":"6.0","parameters":[{"name":"panelId","summary":"Panel identifier."},{"name":"documentSerialNumber","summary":"The document associated with the closed panel."}]},{"signature":"static void OnShowPanel(Guid panelId, uint documentSerialNumber, bool show)","summary":"Call this method to raise the Show event","since":"6.0","parameters":[{"name":"panelId","summary":""},{"name":"documentSerialNumber","summary":"The document associated with the shown/hidden panel."},{"name":"show","summary":""}]},{"signature":"static void OpenPanel(Guid panelId)","summary":"Open the specified panel in its current or default location and if it is in a dock bar containing more than one tab, make it the current tab.","since":"5.0","parameters":[{"name":"panelId","summary":"Class type Id for the panel to open."}]},{"signature":"static void OpenPanel(Guid panelId, bool makeSelectedPanel)","summary":"Open the specified panel in its current or default location and if it is in a dock bar containing more than one tab, make it the current tab.","since":"6.0","parameters":[{"name":"panelId","summary":"Class type Id for the panel to open."},{"name":"makeSelectedPanel","summary":"If True then the panel is set as the active tab after opening it otherwise; the panel is opened but not set as the active tab."}]},{"signature":"static Guid OpenPanel(Guid dockBarId, Guid panelId)","summary":"In Mac Rhino this will just call the version of OpenPanel that takes a class type Id.  In Windows Rhino this will look for a dock bar with the specified Id and open or move the specified panel to that dock bar.","since":"5.12","parameters":[{"name":"dockBarId","summary":"Id of the dock bar hosting one or more panels."},{"name":"panelId","summary":"Class type Id for the panel to open."}],"returns":"Returns True if the"},{"signature":"static Guid OpenPanel(Guid dockBarId, Guid panelId, bool makeSelectedPanel)","summary":"In Mac Rhino this will just call the version of OpenPanel that takes a class type Id.  In Windows Rhino this will look for a dock bar with the specified Id and open or move the specified panel to that dock bar.","since":"6.0","parameters":[{"name":"dockBarId","summary":"Id of the dock bar hosting one or more panels."},{"name":"panelId","summary":"Class type Id for the panel to open."},{"name":"makeSelectedPanel","summary":"If True then the panel is set as the active tab after opening it otherwise; the panel is opened but not set as the active tab."}],"returns":"Returns True if the"},{"signature":"static Guid OpenPanel(Guid dockBarId, Type panelType)","summary":"In Mac Rhino this will just call the version of OpenPanel that takes a class type Id.  In Windows Rhino this will look for a dock bar with the specified Id and open or move the specified panel to that dock bar.","since":"5.12","parameters":[{"name":"dockBarId","summary":"Id of the dock bar hosting one or more panels."},{"name":"panelType","summary":"Class type for the panel to open."}],"returns":"Returns True if the"},{"signature":"static Guid OpenPanel(Guid dockBarId, Type panelType, bool makeSelectedPanel)","summary":"In Mac Rhino this will just call the version of OpenPanel that takes a class type Id.  In Windows Rhino this will look for a dock bar with the specified Id and open or move the specified panel to that dock bar.","since":"6.0","parameters":[{"name":"dockBarId","summary":"Id of the dock bar hosting one or more panels."},{"name":"panelType","summary":"Class type for the panel to open."},{"name":"makeSelectedPanel","summary":"If True then the panel is set as the active tab after opening it otherwise; the panel is opened but not set as the active tab."}],"returns":"Returns True if the"},{"signature":"static void OpenPanel(Type panelType)","summary":"Open the specified panel in its current or default location and if it is in a dock bar containing more than one tab, make it the current tab.","since":"5.0","parameters":[{"name":"panelType","summary":"Class type of the panel to open."}]},{"signature":"static void OpenPanel(Type panelType, bool makeSelectedPanel)","summary":"Open the specified panel in its current or default location and if it is in a dock bar containing more than one tab, make it the current tab.","since":"6.0","parameters":[{"name":"panelType","summary":"Class type of the panel to open."},{"name":"makeSelectedPanel","summary":"If True then the panel is set as the active tab after opening it otherwise; the panel is opened but not set as the active tab."}]},{"signature":"static bool OpenPanelAsSibling(Guid panelId, Guid siblingPanelId)","summary":"In Mac Rhino this will currently just call OpenPanel, in Windows Rhino this will look for a dock bar which contains the sibling panel and add this panel to that dock bar as necessary, if the panel was in another dock bar it will be moved to this dock bar.","since":"5.0","parameters":[{"name":"panelId","summary":"The class Id of the panel type to open."},{"name":"siblingPanelId","summary":"The class Id of the sibling panel."}],"returns":"Returns True if the panel was successfully opened."},{"signature":"static bool OpenPanelAsSibling(Guid panelId, Guid siblingPanelId, bool makeSelectedPanel)","summary":"In Mac Rhino this will currently just call OpenPanel, in Windows Rhino this will look for a dock bar which contains the sibling panel and add this panel to that dock bar as necessary, if the panel was in another dock bar it will be moved to this dock bar.","since":"6.0","parameters":[{"name":"panelId","summary":"The class Id of the panel type to open."},{"name":"siblingPanelId","summary":"The class Id of the sibling panel."},{"name":"makeSelectedPanel","summary":"If True then the panel is set as the active tab after opening it otherwise; the panel is opened but not set as the active tab."}],"returns":"Returns True if the panel was successfully opened."},{"signature":"static Guid PanelDockBar(Guid panelId)","summary":"Will always return Guid.Emty in Mac Rhino.  In Windows Rhino it will look for the dock bar which contains the specified panel class Id and return the dock bar Id.","since":"5.12","parameters":[{"name":"panelId","summary":"Panel class Id for of the panel to look for."}],"returns":"Always returns Guid.Empty on Mac Rhino.  On Windows Rhino it will return the Id for the dock bar which host the specified panel or Guid.Empty if the panel is not currently visible."},{"signature":"static Guid PanelDockBar(Type panelType)","summary":"Will always return Guid.Emty in Mac Rhino.  In Windows Rhino it will look for the dock bar which contains the specified panel class Id and return the dock bar Id.","since":"5.12","parameters":[{"name":"panelType","summary":"Panel class for of the panel to look for."}],"returns":"Always returns Guid.Empty on Mac Rhino.  On Windows Rhino it will return the Id for the dock bar which host the specified panel or Guid.Empty if the panel is not currently visible."},{"signature":"static Guid[] PanelDockBars(Guid panelId)","summary":"Will always return a empty array in Mac Rhino.  In Windows Rhino it will look for any panel dock bars that contain the specified panel class Id and return the dock bar Id\'s.","since":"6.1","parameters":[{"name":"panelId","summary":"Panel class Id for of the panel to look for."}],"returns":"Always returns Guid.Empty on Mac Rhino.  On Windows Rhino it will return the Id for the dock bar which host the specified panel or Guid.Empty if the panel is not currently visible."},{"signature":"static void RegisterPanel(PlugIn plugin, Type panelType, string caption, Icon icon)","summary":"You typically register your panel class in your plug-in\'s OnLoad function.  This will register your custom call with Rhino, Rhino will create an instance of your class the first time your panel is created and embed this instance of your class in a panel container.","since":"5.0","parameters":[{"name":"plugin","summary":"Plug-in this panel is associated with"},{"name":"panelType","summary":"Class type to construct when a panel is shown.  If your class is derived from Eto.Forms.Control it will work on both the Mac and Windows version of Rhino.  In addition Windows Rhino will support any class types that implement the IWin32Window interface or that are derived from System.Windows.FrameworkElement.  Mac Rhino will also support classes that are derived from NsView.  In addition to the type requirements the class must have a public constructor with no parameters or a constructor with a single uint that represents the document serial number and have a GuidAttribute applied with a unique Id.  n Windows there is only one panel created which gets recycled for each new document.  On the Mac a panel will be created for each open document and destroyed when the document closes.  In certain situations in Mac Rhino a a panel may get created and destroyed multiple times when opening/closing a panel while editing a document."},{"name":"caption","summary":"Displays in the panel tab on Windows or at the top of the modeless window on Mac."},{"name":"icon","summary":"Currently only used in Windows, use a 32bit depth icon in order to get proper transparency."}]},{"signature":"static void RegisterPanel(PlugIn plugIn, Type type, string caption, Icon icon, PanelType panelType)","summary":"Call once to register a panel type which will get dynamically created and embedded in a Rhino docking/floating location.","since":"6.1","parameters":[{"name":"plugIn","summary":"Plug-in restringing the panel"},{"name":"type","summary":"Type of the control object to be displayed in the panel"},{"name":"caption","summary":"Panel caption also used as a tool-tip.  On Windows the panel may be displayed using the icon, caption or both.  On Mac the icon will be used and the caption will be the tool-tip."},{"name":"icon","summary":"The panel icon.  On Windows the panel may be displayed using the icon, caption or both.  On Mac the icon will be used and the caption will be the tool-tip."},{"name":"panelType","summary":"See PanelType"}]}]},{"namespace":"Rhino.UI","name":"Panels.FloatPanelMode","dataType":"enum","summary":"Used by the FloatPanel method to determine if the floating panel should be shown or hidden.","since":"6.2","values":[{"signature":"Show","summary":"Show the floating panel"},{"signature":"Hide","summary":"Hide the floating panel"},{"signature":"Toggle","summary":"Toggle the visibility state"}]},{"namespace":"Rhino.UI","name":"PanelType","dataType":"enum","summary":"Panel type","since":"6.1","values":[{"signature":"PerDoc","summary":"Default panel type, creates a panel instance per document"},{"signature":"System","summary":"A System panel may appear in one or more container but the panel will be used for all open documents"}]},{"namespace":"Rhino.UI","name":"PropertyPageType","dataType":"enum","summary":"IRhinoProperties page type","values":[{"signature":"Material = 0","summary":"Replace the material page with this page; only works for the current render plug - in."},{"signature":"Light","summary":"Replace the light page with this page; only works for the current render plug-in."},{"signature":"Custom","summary":"User-defined custom object page."},{"signature":"ObjectProperties","summary":"For internal use only."},{"signature":"Dimension","summary":"If page is provided by Rhino and only dimensions are selected, activate this page."},{"signature":"Leader","summary":"If page is provided by Rhino and leaders are selected, activate this page."},{"signature":"Text","summary":"If page is provided by Rhino and only text objects are selected, activate this page."},{"signature":"Hatch","summary":"If page is provided by Rhino and only hatch objects are selected, activate this page."},{"signature":"Dot","summary":"If page is provided by Rhino and only dot objects are selected, activate this page."},{"signature":"TextureMapping","summary":"Replace the texture mapping page with this page; only works for the current render plug-in."},{"signature":"Detail","summary":"If page is provided by Rhino and only detail objects are selected, activate this page."},{"signature":"ClippingPlane","summary":"If page is provided by Rhino and only clipping plane objects are selected, activate this page."},{"signature":"NamedView","summary":"If page is provided by Rhino and only named view widget objects are selected, activate this page."},{"signature":"Decal","summary":"Decals user interface"},{"signature":"View","summary":"Page is a view properties page and uses view properties methods. Does not use object properties methods."},{"signature":"PageCount","summary":"Reserved, do not use."}]},{"namespace":"Rhino.UI","name":"RhinoGetPlotWidthArgs","dataType":"enum","summary":"Argument flags passed to methods used to get Rhino plot width lists","values":[{"signature":"NoArgs = 0","summary":"Just get the standard or default width list"},{"signature":"ByLayer = 1","summary":"Include a By Layer option"},{"signature":"ByParent = 2","summary":"Include a By Parent option"},{"signature":"HairLine = 4","summary":"Include a hairline width option"},{"signature":"Default = 8","summary":"Include a default width option"},{"signature":"None = 0x20","summary":"Include a no print option"},{"signature":"All = 0xFFFFFFF","summary":"Include everything"}]},{"namespace":"Rhino.UI","name":"RhinoHelp","dataType":"class","summary":"Provides access to the built in Rhino help system","methods":[{"signature":"static bool Show(string helpLink)","summary":"Call this method to display standard Rhino help","since":"6.0","parameters":[{"name":"helpLink","summary":"Rhino help links are formatted like this: http://docs.mcneel.com/rhino/6/help/en-us/index.htm#commands/line.htm This parameter would be equal to \\"#commands/line.htm\\" in the link above.  Rhino will calculate the string up to and including the index.html and append this value to the end."}]}]},{"namespace":"Rhino.UI","name":"RhinoPageInterop","dataType":"class","summary":"For internal use only, provides access to unmanaged core Rhino.","methods":[{"signature":"static IntPtr NewPropertiesPanelPagePointer(ObjectPropertiesPage page, uint rhinoDocRuntimeSn)","summary":"For internal use only, provides access to unmanaged core","since":"6.0"},{"signature":"static StackedDialogPage StackedDialogPageFromUnmanagedPointer(IntPtr pointer)","summary":"For internal use only, provides access to unmanaged core","since":"6.4"}]},{"namespace":"Rhino.UI","name":"RhinoPlotWidthType","dataType":"enum","summary":"Supported plot width special types","values":[{"signature":"ByLayer","summary":"Plot width from layer"},{"signature":"ByParent","summary":"Plot width from parent object"},{"signature":"Hairline","summary":"System hairline plot width"},{"signature":"Default","summary":"Use default plot width"},{"signature":"None","summary":"Don\'t print"},{"signature":"Varies","summary":"Multiple objects selected with different types/widths"},{"signature":"Width","summary":"Standard or custom width"}]},{"namespace":"Rhino.UI","name":"RhinoPlotWidthValue","dataType":"enum","summary":"Default width values used by UI objects to represent different states","values":[{"signature":"Default  =   0","summary":"Use default plot width"},{"signature":"None     =  -1","summary":"Don\'t print"},{"signature":"ByLayer  = -10","summary":"Plot width from layer"},{"signature":"ByParent = -15","summary":"Plot width from parent object"},{"signature":"Varies   = -20","summary":"Multiple objects selected with different types/widths"}]},{"namespace":"Rhino.UI","name":"RuiUpdateUi","dataType":"class","baseclass":"EventArgs","properties":[{"signature":"bool Checked","summary":"Set to True to enable menu item or False to check menu item","since":"5.11","property":["get","set"]},{"signature":"bool Enabled","summary":"Set to True to enable menu item or False to disable menu item","since":"5.11","property":["get","set"]},{"signature":"Guid FileId","summary":"Id of the RUI file that owns this menu item","since":"5.11","property":["get"]},{"signature":"IntPtr MenuHandle","summary":"Windows menu handle of menu that contains this item","since":"5.11","property":["get"]},{"signature":"Guid MenuId","summary":"Id of the menu that owns this menu item","since":"5.11","property":["get"]},{"signature":"int MenuIndex","summary":"Zero based index of item in the Windows menu","since":"5.11","property":["get"]},{"signature":"Guid MenuItemId","summary":"Id of the menu item that owns this menu item","since":"5.11","property":["get"]},{"signature":"bool RadioChecked","summary":"Set to True to enable menu item or False to check menu item","since":"5.11","property":["get","set"]},{"signature":"string Text","summary":"Menu item text","since":"5.11","property":["get","set"]},{"signature":"uint WindowsMenuItemId","summary":"Windows menu item ID","since":"5.11","property":["get"]}],"methods":[{"signature":"static bool RegisterMenuItem(Guid file, Guid menu, Guid item, UpdateMenuItemEventHandler callBack)","summary":"Register menu item update delegate","since":"5.11","parameters":[{"name":"file","summary":"Menu file Id"},{"name":"menu","summary":"Menu Id"},{"name":"item","summary":"Menu item Id"},{"name":"callBack","summary":""}],"returns":"True if Registered otherwise false"},{"signature":"static bool RegisterMenuItem(string fileId, string menuId, string itemId, UpdateMenuItemEventHandler callBack)","summary":"Register menu item update delegate","since":"5.11","parameters":[{"name":"fileId","summary":"Menu file Id"},{"name":"menuId","summary":"Menu Id"},{"name":"itemId","summary":"Menu item Id"},{"name":"callBack","summary":""}],"returns":"True if Registered otherwise false"}]},{"namespace":"Rhino.UI","name":"SaveFileDialog","dataType":"class","summary":"Similar to the System.Windows.Forms.SaveFileDialog, but with customized Rhino user interface.","constructors":[{"signature":"SaveFileDialog()","since":"5.0"}],"properties":[{"signature":"string DefaultExt","summary":"The default file name extension. The returned string does not include the period.","since":"5.0","property":["get","set"]},{"signature":"string FileName","summary":"Gets or sets a string containing the file name selected in the file dialog box.","since":"5.0","property":["get","set"]},{"signature":"string Filter","summary":"Gets or sets the current file name filter string, which determines the choices that appear in the \\"Save as file type\\" or \\"Files of type\\" box in the dialog box. See System.Windows.Forms.FileDialog for details.","since":"5.0","property":["get","set"]},{"signature":"string InitialDirectory","summary":"Gets or sets the initial directory displayed by the file dialog box.","since":"5.0","property":["get","set"]},{"signature":"string Title","summary":"Gets or sets the file dialog box title.","since":"5.0","property":["get","set"]}],"methods":[{"signature":"System.Windows.Forms.DialogResult ShowDialog()","since":"5.0","deprecated":"6.0"},{"signature":"bool ShowSaveDialog()","since":"5.10","returns":"True if a file was selected. False if the dialog was canceled"}]},{"namespace":"Rhino.UI","name":"ShowMessageButton","dataType":"enum","since":"6.0","values":[{"signature":"OK = 0"},{"signature":"OKCancel = 1"},{"signature":"AbortRetryIgnore = 2"},{"signature":"YesNoCancel = 3"},{"signature":"YesNo = 4"},{"signature":"RetryCancel = 5"}]},{"namespace":"Rhino.UI","name":"ShowMessageDefaultButton","dataType":"enum","since":"6.0","values":[{"signature":"Button1 = 0"},{"signature":"Button2 = 256"},{"signature":"Button3 = 512"}]},{"namespace":"Rhino.UI","name":"ShowMessageIcon","dataType":"enum","since":"6.0","values":[{"signature":"None = 0"},{"signature":"Error = 16"},{"signature":"Hand = 16"},{"signature":"Stop = 16"},{"signature":"Question = 32"},{"signature":"Exclamation = 48"},{"signature":"Warning = 48"},{"signature":"Information = 64"},{"signature":"Asterisk = 64"}]},{"namespace":"Rhino.UI","name":"ShowMessageMode","dataType":"enum","since":"6.0","values":[{"signature":"ApplicationModal = 0"},{"signature":"SystemModal = 4096"},{"signature":"TaskModal = 8192"}]},{"namespace":"Rhino.UI","name":"ShowMessageOptions","dataType":"enum","since":"6.0","values":[{"signature":"None = 0"},{"signature":"SetForeground = 65536"},{"signature":"DefaultDesktopOnly = 131072"},{"signature":"TopMost = 262144"},{"signature":"RightAlign = 524288"},{"signature":"RtlReading = 1048576"},{"signature":"ServiceNotification = 2097152"}]},{"namespace":"Rhino.UI","name":"ShowMessageResult","dataType":"enum","since":"6.0","values":[{"signature":"None = 0"},{"signature":"OK = 1"},{"signature":"Cancel = 2"},{"signature":"Abort = 3"},{"signature":"Retry = 4"},{"signature":"Ignore = 5"},{"signature":"Yes = 6"},{"signature":"No = 7"}]},{"namespace":"Rhino.UI","name":"ShowPanelEventArgs","dataType":"class","summary":"Panels.Show event arguments","baseclass":"Rhino.UI.PanelEventArgs","constructors":[{"signature":"ShowPanelEventArgs(Guid panelId, uint documentSerialNumber, bool show)","since":"6.0"}],"properties":[{"signature":"bool Show","summary":"Will be True if showing or False if hiding","since":"6.0","property":["get","set"]}]},{"namespace":"Rhino.UI","name":"ShowPanelReason","dataType":"enum","summary":"OnShowDockbar event type","values":[{"signature":"Show","summary":"Dock bar shown or made visible"},{"signature":"Hide","summary":"Dock bar hidden, no longer visible"},{"signature":"HideOnDeactivate","summary":"Dock bar temporarily hidden because the main Rhino application is no longer active."},{"signature":"ShowOnDeactivate","summary":"Dock bar that was temporarily hidden when the main Rhino application was deactivated is now being shown."}]},{"namespace":"Rhino.UI","name":"StackedDialogPage","dataType":"class","summary":"Base class to inherit from for the addition of stacked dialog pages.","properties":[{"signature":"List<StackedDialogPage> Children","summary":"List of child (sub) pages of this page","since":"5.0","property":["get"]},{"signature":"string EnglishPageTitle","summary":"English string used when scripting this page and a user prefixes a command option with \\"_\\"","since":"5.0","property":["get","set"]},{"signature":"IntPtr Handle","summary":"When running on Windows return the window handle for the parent of this page otherwise; return IntPtr.Zero.","since":"6.0","property":["get"]},{"signature":"bool HasChildren","summary":"Will be True if this page contains sub pages.","since":"5.0","property":["get"]},{"signature":"string LocalPageTitle","summary":"Localized page title that will appear on a tab or other page navigation control.  This is also uses as a command line option when scripting this page.","since":"5.0","property":["get"]},{"signature":"bool Modified","summary":"Check to see if the page has been marked as modified or not.  Marking the page as modified will cause the Apply button to get enabled if this is currently the visible page and the page includes the Apply button.","since":"6.0","property":["get","set"]},{"signature":"Color NavigationTextColor","summary":"Currently only used by Windows Rhino.  If this is set to True then the tree control item text be drawn using this color.  Set the color to System.Drawing.Color.Empty to use the default color.","since":"6.0","property":["get","set"]},{"signature":"bool NavigationTextIsBold","summary":"Currently only used by Windows Rhino.  If this is set to True then the tree control item text will be bold.","since":"6.0","property":["get","set"]},{"signature":"object PageControl","summary":"Return the control that represents this page. Rhino Windows supports classes that implement the IWin32Windows interface or are derived from some form of System.Windows.FrameworkElement or Eto.Forms.Control.  Mac Rhino supports controls that are derived from NSview or Eto.Forms.Control.","since":"5.0","property":["get"]},{"signature":"Image PageImage","summary":"Optionally override to provide a image to display in the Mac Rhino UI","since":"6.0","property":["get"]},{"signature":"bool ShowApplyButton","summary":"Called when this page is activated","since":"6.0","property":["get"]},{"signature":"bool ShowDefaultsButton","summary":"Called when this page is activated.","since":"5.0","property":["get"]}],"methods":[{"signature":"void AddChildPage(StackedDialogPage pageToAdd)","summary":"Currently only supported on Windows.  Call this method to add a child page to a page after the parent dialog has been created.","since":"6.0"},{"signature":"void MakeActivePage()","summary":"Make this page the active, visible page","since":"6.0"},{"signature":"bool OnActivate(bool active)","summary":"Called when this page is activated/deactivated.","since":"5.0","parameters":[{"name":"active","summary":"If True then this page is on top otherwise it is about to be hidden."}],"returns":"If True then the page is hidden and the requested page is not activated otherwise will not allow you to change the current page. Default returns true"},{"signature":"bool OnApply()","summary":"Called when stacked dialog OK button is pressed.","since":"5.0","returns":"If return value is True then the dialog will be closed. A return of False means there was an error and dialog remains open so page can be properly updated."},{"signature":"void OnCancel()","summary":"Called when stacked dialog Cancel button is pressed.","since":"5.0"},{"signature":"void OnCreateParent(IntPtr hwndParent)","summary":"Called when the parent window has been created on Windows platforms only.","since":"5.0"},{"signature":"void OnDefaults()","summary":"Called when stacked dialog Defaults button is pressed (see ShowDefaultsButton).","since":"5.0"},{"signature":"void OnHelp()","summary":"Called when the parent dialog requests help for this page.","since":"5.0"},{"signature":"void OnSizeParent(int width, int height)","summary":"Called when the parent window has been resized","since":"5.0"},{"signature":"void RemovePage()","summary":"Remove this page from the dialog box","since":"6.0"},{"signature":"void SetEnglishPageTitle(string newPageTile)","summary":"Change the title passed to the constructor and, this will cause LocalPageTitle to get called also.","since":"6.0"}]},{"namespace":"Rhino.UI","name":"StatusBar","dataType":"class","summary":"Contains static methods to control the application status bar.","methods":[{"signature":"static void ClearMessagePane()","summary":"Removes the message from the message pane.","since":"5.0"},{"signature":"static void HideProgressMeter()","summary":"Ends, or hides, Rhino\'s status bar progress meter.","since":"5.0"},{"signature":"static void HideProgressMeter(uint docSerialNumber)","summary":"Ends, or hides, Rhino\'s status bar progress meter.","since":"6.12","parameters":[{"name":"docSerialNumber","summary":"The document runtime serial number."}]},{"signature":"static void SetDistancePane(double distance)","summary":"Sets the distance pane to a distance value.","since":"5.0","parameters":[{"name":"distance","summary":"The distance value."}]},{"signature":"static void SetMessagePane(string message)","summary":"Sets the message pane to a message.","since":"5.0","parameters":[{"name":"message","summary":"The message value."}]},{"signature":"static void SetNumberPane(double number)","summary":"Sets the number pane to a number value","since":"6.0"},{"signature":"static void SetPointPane(Point3d point)","summary":"Sets the point pane to a point value.","since":"5.0","parameters":[{"name":"point","summary":"The point value."}]},{"signature":"static int ShowProgressMeter(int lowerLimit, int upperLimit, string label, bool embedLabel, bool showPercentComplete)","summary":"Starts, or shows, Rhino\'s status bar progress meter.","since":"5.0","parameters":[{"name":"lowerLimit","summary":"The lower limit of the progress meter\'s range."},{"name":"upperLimit","summary":"The upper limit of the progress meter\'s range."},{"name":"label","summary":"The short description of the progress (e.g. \\"Calculating\\", \\"Meshing\\", etc)"},{"name":"embedLabel","summary":"If true, then the label will be embedded in the progress meter. If false, then the label will appear to the left of the progress meter."},{"name":"showPercentComplete","summary":"If true, then the percent complete will appear in the progress meter."}],"returns":"1 - The progress meter was created successfully. 0 - The progress meter was not created. -1 - The progress meter was not created because some other process has already created it."},{"signature":"static int ShowProgressMeter(uint docSerialNumber, int lowerLimit, int upperLimit, string label, bool embedLabel, bool showPercentComplete)","summary":"Starts, or shows, Rhino\'s status bar progress meter.","since":"6.12","parameters":[{"name":"docSerialNumber","summary":"The document runtime serial number."},{"name":"lowerLimit","summary":"The lower limit of the progress meter\'s range."},{"name":"upperLimit","summary":"The upper limit of the progress meter\'s range."},{"name":"label","summary":"The short description of the progress (e.g. \\"Calculating\\", \\"Meshing\\", etc)"},{"name":"embedLabel","summary":"If true, then the label will be embedded in the progress meter. If false, then the label will appear to the left of the progress meter."},{"name":"showPercentComplete","summary":"If true, then the percent complete will appear in the progress meter."}],"returns":"1 - The progress meter was created successfully. 0 - The progress meter was not created. -1 - The progress meter was not created because some other process has already created it."},{"signature":"static int UpdateProgressMeter(int position, bool absolute)","summary":"Sets the current position of Rhino\'s status bar progress meter.","since":"5.0","parameters":[{"name":"position","summary":"The new value. This can be stated in absolute terms, or relative compared to the current position.  \\nThe interval bounds are specified when you first show the bar."},{"name":"absolute","summary":"If true, then the progress meter is moved to position. If false, then the progress meter is moved position from the current position (relative)."}],"returns":"The previous position if successful."},{"signature":"static int UpdateProgressMeter(uint docSerialNumber, int position, bool absolute)","summary":"Sets the current position of Rhino\'s status bar progress meter.","since":"6.12","parameters":[{"name":"docSerialNumber","summary":"The document runtime serial number."},{"name":"position","summary":"The new value. This can be stated in absolute terms, or relative compared to the current position.  \\nThe interval bounds are specified when you first show the bar."},{"name":"absolute","summary":"If true, then the progress meter is moved to position. If false, then the progress meter is moved position from the current position (relative)."}],"returns":"The previous position if successful."}]},{"namespace":"Rhino.UI","name":"Toolbar","dataType":"class","properties":[{"signature":"static Size BitmapSize","since":"6.0","property":["get","set"]},{"signature":"static Size TabSize","since":"6.0","property":["get","set"]},{"signature":"Guid Id","since":"5.0","property":["get"]},{"signature":"string Name","since":"5.0","property":["get"]}]},{"namespace":"Rhino.UI","name":"ToolbarFile","dataType":"class","properties":[{"signature":"int GroupCount","since":"5.0","property":["get"]},{"signature":"Guid Id","since":"5.0","property":["get"]},{"signature":"string Name","since":"5.0","property":["get"]},{"signature":"string Path","summary":"Full path to this file on disk","since":"5.0","property":["get"]},{"signature":"int ToolbarCount","since":"5.0","property":["get"]}],"methods":[{"signature":"bool Close(bool prompt)","since":"5.0"},{"signature":"ToolbarGroup GetGroup(int index)","since":"5.0"},{"signature":"ToolbarGroup GetGroup(string name)","since":"5.0"},{"signature":"Toolbar GetToolbar(int index)","since":"5.0"},{"signature":"bool Save()","since":"5.0"},{"signature":"bool SaveAs(string path)","since":"5.0"}]},{"namespace":"Rhino.UI","name":"ToolbarFileCollection","dataType":"class","interfaces":["IEnumerable<ToolbarFile>"],"properties":[{"signature":"static bool MruSidebarIsVisible","since":"5.0","property":["get","set"]},{"signature":"static bool SidebarIsVisible","since":"5.0","property":["get","set"]},{"signature":"int Count","summary":"Number of open toolbar files","since":"5.0","property":["get"]}],"methods":[{"signature":"ToolbarFile FindByName(string name, bool ignoreCase)","since":"5.0"},{"signature":"ToolbarFile FindByPath(string path)","since":"5.0"},{"signature":"IEnumerator<ToolbarFile> GetEnumerator()","since":"5.0"},{"signature":"ToolbarFile Open(string path)","since":"5.0"}]},{"namespace":"Rhino.UI","name":"ToolbarGroup","dataType":"class","properties":[{"signature":"Guid Id","since":"5.0","property":["get"]},{"signature":"bool IsDocked","since":"5.0","property":["get"]},{"signature":"string Name","since":"5.0","property":["get"]},{"signature":"bool Visible","since":"5.0","property":["get","set"]}]},{"namespace":"Rhino.UI","name":"WaitCursor","dataType":"class","interfaces":["IDisposable"],"constructors":[{"signature":"WaitCursor()","since":"5.1"}],"methods":[{"signature":"void Clear()","since":"5.1"},{"signature":"void Dispose()","since":"5.1"},{"signature":"void Set()","since":"5.1"}]},{"namespace":"Rhino","name":"UnitSystem","dataType":"enum","summary":"ON::LengthUnitSystem identifies a length unit system United States customary length units references: http://www.nist.gov/pml/wmd/metric/upload/frn-59-5442-1959.pdf http://en.wikipedia.org/wiki/United_States_customary_units http://en.wikipedia.org/wiki/International_yard_and_pound","values":[{"signature":"None =  0","summary":"ON::LengthUnitSystem::None indicates no length unit system. The scale factor when converting between a specified unit system and None is always 1.0. ON::LengthUnitSystem::None is used as a unit system for models and instance defitions that should be imported or referenced with no scaling applied."},{"signature":"Angstroms = 12","summary":"1 angstroms = 1.0e-10 meters"},{"signature":"Nanometers = 13","summary":"1 nanometer = 1.0e-9 meters"},{"signature":"Microns =  1","summary":"1 micron = 1.0e-6 meters"},{"signature":"Millimeters =  2","summary":"1 millimeter = 1.0e-3 meters"},{"signature":"Centimeters =  3","summary":"1 centimeter = 1.0e-2 meters"},{"signature":"Decimeters = 14","summary":"1 decimeter = 1.0e-1 meters"},{"signature":"Meters =  4","summary":"SI meter length unit"},{"signature":"Dekameters = 15","summary":"1 dekameter = 1.0e+1 meters"},{"signature":"Hectometers = 16","summary":"1 hectometer = 1.0e+2 meters"},{"signature":"Kilometers =  5","summary":"1 kilometer = 1.0e+3 meters"},{"signature":"Megameters = 17","summary":"1 megameter = 1.0e+6 meters"},{"signature":"Gigameters = 18","summary":"1 gigameter = 1.0e+9 meters"},{"signature":"Microinches =  6","summary":"1 microinches = 2.54e-8 meters = 1.0e-6 inches"},{"signature":"Mils =  7","summary":"1 mil = 2.54e-5 meters = 0.001 inches"},{"signature":"Inches =  8","summary":"1 inch = 0.0254 meters = 1/12 foot"},{"signature":"Feet =  9","summary":"1 foot = 0.3048  meters (12 inches)"},{"signature":"Yards = 19","summary":"1 foot = 0.3048 meters = 12 inches"},{"signature":"Miles = 10","summary":"1 US statute mile = 1609.344 meters = 5280 feet"},{"signature":"PrinterPoints = 20","summary":"1 printer point = 1/72 inch"},{"signature":"PrinterPicas = 21","summary":"1 printer pica = 1/6 inch"},{"signature":"NauticalMiles = 22","summary":"1 nautical mile = 1852 meters Approximately 1 minute of arc on a terrestrial great circle. Reference: http://en.wikipedia.org/wiki/Nautical_mile"},{"signature":"AstronomicalUnits = 23","summary":"1 astronomical unit = 1.4959787e+11 meters An astronomical unit (au) is the mean distance from the center of the earth to the center of the sun. References: http://en.wikipedia.org/wiki/Astronomical_unit (1.4959787e+11 meters) http://units.nist.gov/Pubs/SP811/appenB9.htm (1.495979e+11 meters)"},{"signature":"LightYears = 24","summary":"1 light year = 9.4607304725808e+15 meters A light year is the distance light travels in one Julian year. The speed of light is exactly 299792458 meters/second. A Julian year is exactly 365.25 * 86400 seconds and is approximately the time it takes for one earth orbit. References: http://en.wikipedia.org/wiki/Light_year (9.4607304725808e+15 meters) http://units.nist.gov/Pubs/SP811/appenB9.htm (9.46073e+15 meters)"},{"signature":"Parsecs = 25","summary":"1 parsec = 3.08567758e+16 meters References: http://en.wikipedia.org/wiki/Parsec (3.08567758e+16 meters) http://units.nist.gov/Pubs/SP811/appenB9.htm (3.085678e+16)"},{"signature":"CustomUnits = 11","summary":"The name of a custom unit and the conversion to meters are saved in the ON_UnitSystem class."},{"signature":"Unset = 255","summary":"The ON::LengthUnitSystem::Unset is used to indicate no unit system is set. This is a differnt condition from ON::LengthUnitSystem::None."}]}]')}}]);