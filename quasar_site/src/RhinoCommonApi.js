// auto-generated from api_docify
const DataTypes = {
  NONE: 0,
  CLASS: 1,
  STRUCT: 2,
  ENUM: 3,
  INTERFACE: 4,
  NAMESPACE: 5
}
var RhinoCommonApi = [
  {
    name: 'Rhino',
    dataType: 5,
    summary: `The Rhino namespace contains fundamental types that
   define commonly-used value types and classes used in Rhino.`
  },
  {
    name: 'Rhino.ApplicationSettings',
    dataType: 5
  },
  {
    name: 'Rhino.Collections',
    dataType: 5
  },
  {
    name: 'Rhino.Commands',
    dataType: 5
  },
  {
    name: 'Rhino.Display',
    dataType: 5
  },
  {
    name: 'Rhino.DocObjects',
    dataType: 5,
    summary: `The DocObjects namespace contains types that correspond to geometry
   that is found in a document.
   Generally, these types reference an attribute and have a
   distinctive ID.`
  },
  {
    name: 'Rhino.DocObjects.Custom',
    dataType: 5
  },
  {
    name: 'Rhino.DocObjects.SnapShots',
    dataType: 5
  },
  {
    name: 'Rhino.DocObjects.Tables',
    dataType: 5
  },
  {
    name: 'Rhino.FileIO',
    dataType: 5
  },
  {
    name: 'Rhino.Geometry',
    dataType: 5,
    summary: `The Geometry namespace contains geometric types used in Rhino.
   Examples are lines, curves, meshes and boundary representations.`
  },
  {
    name: 'Rhino.Geometry.Collections',
    dataType: 5
  },
  {
    name: 'Rhino.Geometry.Intersect',
    dataType: 5
  },
  {
    name: 'Rhino.Geometry.MeshRefinements',
    dataType: 5
  },
  {
    name: 'Rhino.Geometry.Morphs',
    dataType: 5
  },
  {
    name: 'Rhino.Input',
    dataType: 5
  },
  {
    name: 'Rhino.Input.Custom',
    dataType: 5
  },
  {
    name: 'Rhino.NodeInCode',
    dataType: 5
  },
  {
    name: 'Rhino.PlugIns',
    dataType: 5
  },
  {
    name: 'Rhino.Render',
    dataType: 5
  },
  {
    name: 'Rhino.Render.ChangeQueue',
    dataType: 5
  },
  {
    name: 'Rhino.Render.DataSources',
    dataType: 5
  },
  {
    name: 'Rhino.Render.Fields',
    dataType: 5
  },
  {
    name: 'Rhino.Render.UI',
    dataType: 5
  },
  {
    name: 'Rhino.Runtime',
    dataType: 5
  },
  {
    name: 'Rhino.Runtime.InProcess',
    dataType: 5
  },
  {
    name: 'Rhino.Runtime.InteropWrappers',
    dataType: 5
  },
  {
    name: 'Rhino.Runtime.Notifications',
    dataType: 5
  },
  {
    name: 'Rhino.Runtime.RhinoAccounts',
    dataType: 5
  },
  {
    name: 'Rhino.UI',
    dataType: 5
  },
  {
    name: 'Rhino.UI.Controls',
    dataType: 5
  },
  {
    name: 'Rhino.UI.Controls.Thumbnaillist',
    dataType: 5
  },
  {
    name: 'Rhino.UI.Controls.ThumbnailUI',
    dataType: 5
  },
  {
    name: 'Rhino.UI.Gumball',
    dataType: 5
  },
  {
    namespace: 'Rhino',
    name: 'AngleUnitSystem',
    dataType: 3,
    summary: 'ON::AngleUnitSystem identifies an angle unit system',
    values: [
      {
        signature: 'None = 0',
        summary: `ON::AngleUnitSystem::None indicates no angle unit system
     is specified and model angle unit system should be used.`
      },
      {
        signature: 'Turns = 1',
        summary: '1 turn = 2pi radians.'
      },
      {
        signature: 'Radians = 2',
        summary: '1 turn = 2pi radians.'
      },
      {
        signature: 'Degrees = 3',
        summary: '360 arc degrees  = 1 turn = 2pi radians'
      },
      {
        signature: 'Minutes = 4',
        summary: '60 arc minutes = 1 arc degree'
      },
      {
        signature: 'Seconds = 5',
        summary: '60 arc seconds = 1 arc minute'
      },
      {
        signature: 'Gradians = 6',
        summary: '400 gradians = 2pi radians.'
      },
      {
        signature: 'Unset = 255',
        summary: `The ON::AngleUnitSystem::Unset is used to indicates no angle unit system 
     has been specified in user interface code.`
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'AntialiasLevel',
    dataType: 3,
    summary: 'Provides the antialias levels used for render quality',
    values: [
      {
        signature: 'None = 0',
        summary: 'Low quality'
      },
      {
        signature: 'Draft = 1',
        summary: 'Draft quality'
      },
      {
        signature: 'Good = 2',
        summary: 'Good quality'
      },
      {
        signature: 'High = 3',
        summary: 'High quality'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'AppearanceSettings',
    dataType: 1,
    summary: 'Provides static methods and properties to deal with the appearance of the application.',
    properties: [
      {
        signature: 'static Color CommandPromptBackgroundColor',
        summary: 'Gets or sets the color of the command prompt background.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color CommandPromptHypertextColor',
        summary: 'Gets or sets the color of the command prompt hypertext.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static CommandPromptPosition CommandPromptPosition',
        summary: 'Gets or sets the command prompt position.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color CommandPromptTextColor',
        summary: 'Gets or sets the color of the command prompt text.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color CrosshairColor',
        summary: 'Gets or sets the color of the crosshair icon.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color CurrentLayerBackgroundColor',
        summary: 'Gets or sets the color used by the layer manager dialog as the background color for the current layer.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static string DefaultFontFaceName',
        summary: 'Gets or sets the default font face name used in Rhino.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Color DefaultLayerColor',
        summary: 'Gets or sets the default layer color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color DefaultObjectColor',
        summary: 'Gets or sets the default color for new objects.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool EchoCommandsToHistoryWindow',
        summary: 'Gets or sets a value that determines if command names are written to the history window.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool EchoPromptsToHistoryWindow',
        summary: 'Gets or sets a value that determines if prompt messages are written to the history window.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color EditCandidateColor',
        summary: 'Gets or sets the color of objects that are eligible to be edited.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'static Color FeedbackColor',
        summary: 'Gets or sets the feedback color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color FrameBackgroundColor',
        summary: 'Gets or sets the background color of the frame.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color GridThickLineColor',
        summary: 'Gets or sets the color of the thick line of the grid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color GridThinLineColor',
        summary: 'Gets or sets the color of the thin line of the grid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color GridXAxisLineColor',
        summary: 'Gets or sets the color of the X axis of the grid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color GridYAxisLineColor',
        summary: 'Gets or sets the color of the Y axis of the grid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color GridZAxisLineColor',
        summary: 'Gets or sets the color of the Z axis of the grid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static int LanguageIdentifier',
        summary: 'Gets or sets the language identifier.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color LockedObjectColor',
        summary: 'color used to draw locked objects.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool MenuVisible',
        summary: 'Gets or sets a value that determines if the File menu is visible.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color PageviewPaperColor',
        summary: `Gets or sets the paper background. A rectangle is drawn into the background
     of page views to represent the printed area. The alpha portion of the color
     is used to draw the paper blended into the background`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static int PreviousLanguageIdentifier',
        summary: 'Gets or sets the previous language identifier.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color SelectedObjectColor',
        summary: `The color used to draw selected objects.
    The default is yellow, but this can be customized by the user.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool ShowCrosshairs',
        summary: 'Gets or sets a value that determines if cross hairs are visible.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool ShowFullPathInTitleBar',
        summary: 'Gets or sets a value that determines if the full path of the document is shown in the Rhino title bar.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool ShowSideBar',
        summary: 'Should the side bar be displayed',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'static Color TrackingColor',
        summary: 'Gets or sets the tracking color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool UsePaintColors',
        summary: 'Gets or sets a value indicating if logical paint colors should be used.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Color ViewportBackgroundColor',
        summary: 'Gets or sets the viewport background color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color WorldCoordIconXAxisColor',
        summary: 'Gets or sets the color of the world coordinate X axis.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color WorldCoordIconYAxisColor',
        summary: 'Gets or sets the color of the world coordinate Y axis.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color WorldCoordIconZAxisColor',
        summary: 'Gets or sets the color of the world coordinate Z axis.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static AppearanceSettingsState GetCurrentState()',
        summary: 'Gets the current settings of the application.',
        since: 5,
        returns: `An instance of a class that represents all the settings as they appear in the Rhino _Options dialog,
     joined in a single class.`
      },
      {
        signature: 'static AppearanceSettingsState GetDefaultState()',
        summary: 'Gets the factory settings of the application.',
        since: 5,
        returns: 'An instance of a class that represents all the default settings joined together.'
      },
      {
        signature: 'static Color GetPaintColor(PaintColor whichColor)',
        summary: 'Gets the .Net library color that is currently associated with a paint color.',
        since: 5,
        parameters: [
          {
            name: 'whichColor',
            summary: 'A color association.'
          }
        ],
        returns: 'A .Net library color.'
      },
      {
        signature: 'static Color GetWidgetColor(WidgetColor whichColor)',
        summary: 'Gets the .Net library color that is currently associated with a widget color.',
        since: 6,
        parameters: [
          {
            name: 'whichColor',
            summary: 'A color association.'
          }
        ],
        returns: 'A .Net library color.'
      },
      {
        signature: 'static bool InitialMainWindowPosition(Rectangle bounds)',
        summary: `Location where the Main Rhino window attempts to show when the application is first
     started.`,
        since: 6,
        parameters: [
          {
            name: 'bounds',
            summary: 'The rectangle in which the main window attempts to shows is assigned to this out parameter during the call.'
          }
        ],
        returns: 'False if the information could not be retrieved.'
      },
      {
        signature: 'static void RestoreDefaults()',
        summary: 'Commits the default settings as the current settings.',
        since: 5
      },
      {
        signature: 'static void SetPaintColor(PaintColor whichColor,Color c)',
        summary: 'Sets the logical paint color association to a spacific .Net library color, without forced UI update.',
        since: 5,
        parameters: [
          {
            name: 'whichColor',
            summary: 'A logical color association.'
          },
          {
            name: 'c',
            summary: 'A .Net library color.'
          }
        ]
      },
      {
        signature: 'static void SetPaintColor(PaintColor whichColor,Color c,bool forceUiUpdate)',
        summary: 'Sets the logical paint color association to a spacific .Net library color.',
        since: 5,
        parameters: [
          {
            name: 'whichColor',
            summary: 'A logical color association.'
          },
          {
            name: 'c',
            summary: 'A .Net library color.'
          },
          {
            name: 'forceUiUpdate',
            summary: 'True if the UI should be forced to update.'
          }
        ]
      },
      {
        signature: 'static void SetWidgetColor(WidgetColor whichColor,Color c)',
        summary: 'Sets the logical widget color association to a spacific .Net library color, without forced UI update.',
        since: 6,
        parameters: [
          {
            name: 'whichColor',
            summary: 'A logical color association.'
          },
          {
            name: 'c',
            summary: 'A .Net library color.'
          }
        ]
      },
      {
        signature: 'static void SetWidgetColor(WidgetColor whichColor,Color c,bool forceUiUpdate)',
        summary: 'Sets the logical widget color association to a spacific .Net library color.',
        since: 6,
        parameters: [
          {
            name: 'whichColor',
            summary: 'A logical color association.'
          },
          {
            name: 'c',
            summary: 'A .Net library color.'
          },
          {
            name: 'forceUiUpdate',
            summary: 'True if the UI should be forced to update.'
          }
        ]
      },
      {
        signature: 'static void UpdateFromState(AppearanceSettingsState state)',
        summary: 'Sets all settings to a particular defined joined state.',
        since: 5,
        parameters: [
          {
            name: 'state',
            summary: 'A joined settings object.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'AppearanceSettingsState',
    dataType: 1,
    summary: 'Represents a snapshot of the values in AppearanceSettings.',
    properties: [
      {
        signature: 'Color CommandPromptBackgroundColor',
        summary: 'Gets or sets the comand prompt background color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color CommandPromptHypertextColor',
        summary: 'Gets or sets the comand prompt hypertext color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color CommandPromptTextColor',
        summary: 'Gets or sets the command prompt text color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color CrosshairColor',
        summary: 'Gets or sets the crosshair color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color CurrentLayerBackgroundColor',
        summary: 'Gets or sets the color used by the layer manager dialog as the background color for the current layer.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string DefaultFontFaceName',
        summary: 'Gets or sets the name of the default font face.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color DefaultLayerColor',
        summary: 'Gets or sets the default layer color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color DefaultObjectColor',
        summary: 'Gets or sets the default object color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool EchoCommandsToHistoryWindow',
        summary: 'Gets or sets a value that determines if command names are written to the history window.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool EchoPromptsToHistoryWindow',
        summary: 'Gets or sets a value that determines if prompt messages are written to the history window.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color FeedbackColor',
        summary: 'Gets or sets the feedback color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color FrameBackgroundColor',
        summary: 'Gets or sets the frame background color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color GridThickLineColor',
        summary: 'Gets or sets the color of the thick line in the grid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color GridThinLineColor',
        summary: 'Gets or sets the color of the thin line in the grid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color GridXAxisLineColor',
        summary: 'Gets or sets the color of X axis line in the grid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color GridYAxisLineColor',
        summary: 'Gets or sets the color of Y axis line in the grid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color GridZAxisLineColor',
        summary: 'Gets or sets the color of Z axis line in the grid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color LockedObjectColor',
        summary: 'Gets or sets the color used to draw locked objects.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color PageviewPaperColor',
        summary: `CRhinoPageView paper background. A rectangle is drawn into the background
    of page views to represent the printed area. The alpha portion of the color
    is used to draw the paper blended into the background`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color SelectedObjectColor',
        summary: `The color used to draw selected objects.
    The default is yellow, but this can be customized by the user.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowCrosshairs',
        summary: 'Gets or sets a value that determines if cross hairs are visible.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowFullPathInTitleBar',
        summary: 'Gets or sets a value that determines if the full path of the document is shown in the Rhino title bar.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color TrackingColor',
        summary: 'Gets or sets the tracking color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color ViewportBackgroundColor',
        summary: 'Gets or sets the viewport background color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color WorldCoordIconXAxisColor',
        summary: `Gets or sets the color of the world X axis of the world coordinates icon,
     appearing usually bottom left in viewports.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color WorldCoordIconYAxisColor',
        summary: `Gets or sets the color of the world Y axis of the world coordinate icon,
     appearing usually bottom left in viewports.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color WorldCoordIconZAxisColor',
        summary: `Gets or sets the color of the world Z axis of the world coordinate icon,
     appearing usually bottom left in viewports.`,
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'ClipboardState',
    dataType: 3,
    summary: 'Defines enumerated constant values for diferent behaviour that is related to clipboard data.',
    values: [
      {
        signature: 'KeepData = 0',
        summary: 'Always keep clipboard data, regardless of size and never prompt the user.'
      },
      {
        signature: 'DeleteData',
        summary: 'Always delete clipboard data, regardless of size and never prompt the user.'
      },
      {
        signature: 'PromptWhenBig',
        summary: 'Prompt user when clipboard memory is large.'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'CommandAliasList',
    dataType: 1,
    summary: 'Contains static methods and properties to access command aliases.',
    properties: [
      {
        signature: 'static int Count',
        summary: 'Returns the number of command alias in Rhino.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static bool Add(string alias,string macro)',
        summary: 'Adds a new command alias to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'alias',
            summary: '[in] The name of the command alias.'
          },
          {
            name: 'macro',
            summary: '[in] The command macro to run when the alias is executed.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'static void Clear()',
        summary: 'Removes all aliases from the list.',
        since: 5
      },
      {
        signature: 'static bool Delete(string alias)',
        summary: 'Deletes an existing command alias from Rhino.',
        since: 5,
        parameters: [
          {
            name: 'alias',
            summary: '[in] The name of the command alias.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'static System.Collections.Generic.Dictionary<string, string> GetDefaults()',
        summary: `Constructs a dictionary containing as keys the default names and as value the default macro.
     The returned dicionary contains a copy of the settings.`,
        since: 5,
        returns: 'A new dictionary with the default name/macro combinantions.'
      },
      {
        signature: 'static string GetMacro(string alias)',
        summary: 'Returns the macro of a command alias.',
        since: 5,
        parameters: [
          {
            name: 'alias',
            summary: '[in] The name of the command alias.'
          }
        ]
      },
      {
        signature: 'static string[] GetNames()',
        summary: 'Returns a list of command alias names.',
        since: 5,
        returns: 'An array of strings. This can be empty.'
      },
      {
        signature: 'static bool IsAlias(string alias)',
        summary: 'Verifies that a command alias exists in Rhino.',
        since: 5,
        parameters: [
          {
            name: 'alias',
            summary: '[in] The name of the command alias.'
          }
        ],
        returns: 'True if the alias exists.'
      },
      {
        signature: 'static bool IsDefault()',
        summary: 'Computes a value indicating if the current alias list is the same as the default alias list.',
        since: 5,
        returns: 'True if the current alias list is exactly equal to the default alias list; False otherwise.'
      },
      {
        signature: 'static bool SetMacro(string alias,string macro)',
        summary: 'Modifies the macro of a command alias.',
        since: 5,
        parameters: [
          {
            name: 'alias',
            summary: '[in] The name of the command alias.'
          },
          {
            name: 'macro',
            summary: '[in] The new command macro to run when the alias is executed.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'static System.Collections.Generic.Dictionary<string,string> ToDictionary()',
        summary: `Constructs a new dictionary that contains: as keys all names and as values all macros.
     Modifications to this dictionary do not affect any Rhino command alias.`,
        since: 5,
        returns: 'The new dictionary.'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'CommandPromptPosition',
    dataType: 3,
    summary: 'Defines enumerated constant values for default positions of the command prompt inside the frame of the full editor window.',
    values: [
      {
        signature: 'Top = 0',
        summary: 'The command prompt is shown on top.'
      },
      {
        signature: 'Bottom = 1',
        summary: 'The command prompt is shown at the bottom.'
      },
      {
        signature: 'Floating = 2',
        summary: 'The command prompt is shown floating.'
      },
      {
        signature: 'Hidden = 3',
        summary: 'The command prompt is shown hidden.'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'CursorMode',
    dataType: 3,
    summary: 'Defines enumerated constant values for particular OSnap cursor colors.',
    values: [
      {
        signature: 'None = 0',
        summary: 'No OSnap cursor.'
      },
      {
        signature: 'BlackOnWhite',
        summary: 'Black on white OSnap cursor.'
      },
      {
        signature: 'WhiteOnBlack',
        summary: 'White on black OSnap cursor.'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'CursorTooltipSettings',
    dataType: 1,
    summary: `Cursor tooltips place information at the cursor location.
   Note: Turning on cursor tooltips turns off object snap cursors.`,
    properties: [
      {
        signature: 'static bool AutoSuppress',
        summary: 'Attempts to display only the most useful tooltip.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color BackgroundColor',
        summary: 'Tooltip background color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool CommandPromptPane',
        summary: 'Displays the current command prompt.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool DistancePane',
        summary: 'Displays the distance from the last picked point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Point Offset',
        summary: 'The x and y distances in pixels from the cursor location to the tooltip.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool OsnapPane',
        summary: 'Displays the current object snap selection.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool PointPane',
        summary: 'Displays the current construction plane coordinates.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool RelativePointPane',
        summary: 'Displays the relative construction plane coordinates and angle from the last picked point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color TextColor',
        summary: 'Tooltip text color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool TooltipsEnabled',
        summary: 'Turns on/off cursor tooltips.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static CursorTooltipSettingsState GetCurrentState()',
        summary: 'Gets the current settings.',
        since: 5,
        returns: 'A new cursor tooltip state with current settings.'
      },
      {
        signature: 'static CursorTooltipSettingsState GetDefaultState()',
        summary: 'Gets the cursor tooltip factory settings.',
        since: 5,
        returns: 'A new cursor tooltip state with factory settings.'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'CursorTooltipSettingsState',
    dataType: 1,
    summary: 'Represents a snapshot of CursorTooltipSettings.',
    properties: [
      {
        signature: 'bool AutoSuppress',
        summary: 'Attempts to display only the most useful tooltip.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color BackgroundColor',
        summary: 'Tooltip background color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool CommandPromptPane',
        summary: 'Displays the current command prompt.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DistancePane',
        summary: 'Displays the distance from the last picked point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point Offset',
        summary: 'The x and y distances in pixels from the cursor location to the tooltip.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool OsnapPane',
        summary: 'Displays the current object snap selection.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool PointPane',
        summary: 'Displays the current construction plane coordinates.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool RelativePointPane',
        summary: 'Displays the relative construction plane coordinates and angle from the last picked point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color TextColor',
        summary: 'Tooltip text color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool TooltipsEnabled',
        summary: 'Turns on/off cursor tooltips.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'CurvatureAnalysisSettings',
    dataType: 1,
    summary: 'Contains static methods and properties to modify curvature analysis-related commands.',
    properties: [
      {
        signature: 'static Interval GaussRange',
        summary: 'Gets or sets the Gaussian curvature range.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'static Interval MaxRadiusRange',
        summary: 'Gets or sets the Maximum Radius curvature range.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'static Interval MeanRange',
        summary: 'Gets or sets the Mean curvature range.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'static Interval MinRadiusRange',
        summary: 'Gets or sets the Minimum Radius curvature range.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'static CurvatureStyle Style',
        summary: 'Gets or sets the curvature analysis style.',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static bool CalculateCurvatureAutoRange(IEnumerable<Mesh> meshes,CurvatureAnalysisSettingsState settings)',
        since: 6
      },
      {
        signature: 'static CurvatureAnalysisSettingsState GetCurrentState()',
        summary: 'Gets the current settings of the application.',
        since: 6
      },
      {
        signature: 'static CurvatureAnalysisSettingsState GetDefaultState()',
        summary: 'Gets the factory settings of the application.',
        since: 6
      },
      {
        signature: 'static void RestoreDefaults()',
        summary: 'Commits the default settings as the current settings.',
        since: 6
      },
      {
        signature: 'static void UpdateFromState(CurvatureAnalysisSettingsState state)',
        summary: 'Sets all settings to a particular defined joined state.',
        since: 6,
        parameters: [
          {
            name: 'state',
            summary: 'The particular state.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'CurvatureAnalysisSettings.CurvatureStyle',
    dataType: 3,
    summary: 'Curvature analysis styles',
    values: [
      {
        signature: 'Gaussian = 0',
        summary: 'Gaussian curvature'
      },
      {
        signature: 'Mean = 1',
        summary: 'Mean curvature'
      },
      {
        signature: 'MinRadius = 2',
        summary: 'Minimum radius curvature'
      },
      {
        signature: 'MaxRadius = 3',
        summary: 'Maximum radius curvature'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'CurvatureAnalysisSettingsState',
    dataType: 1,
    summary: 'Represents a snapshot of CurvatureAnalysisSettings.',
    properties: [
      {
        signature: 'Interval GaussRange',
        summary: 'Gets or sets the Gaussian curvature range.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Interval MaxRadiusRange',
        summary: 'Gets or sets the Maximum Radius curvature range.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Interval MeanRange',
        summary: 'Gets or sets the Mean curvature range.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Interval MinRadiusRange',
        summary: 'Gets or sets the Minimum Radius curvature range.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'CurvatureStyle Style',
        summary: 'Gets or sets the curvature analysis style.',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'DraftAngleAnalysisSettings',
    dataType: 1,
    properties: [
      {
        signature: 'static Interval AngleRange',
        summary: 'The angle range.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'static bool ShowIsoCurves',
        summary: 'Show isoparametric curves.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'static Vector3d UpDirection',
        summary: 'The up direction.',
        since: 7,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static DraftAngleAnalysisSettingsState GetCurrentState()',
        summary: 'Gets the current settings of the application.',
        since: 7
      },
      {
        signature: 'static DraftAngleAnalysisSettingsState GetDefaultState()',
        summary: 'Gets the factory settings of the application.',
        since: 7
      },
      {
        signature: 'static void RestoreDefaults()',
        summary: 'Commits the default settings as the current settings.',
        since: 7
      },
      {
        signature: 'static void UpdateFromState(DraftAngleAnalysisSettingsState state)',
        summary: 'Sets all settings to a particular defined joined state.',
        since: 7,
        parameters: [
          {
            name: 'state',
            summary: 'The particular state.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'DraftAngleAnalysisSettingsState',
    dataType: 1,
    summary: 'Represents a snapshot of DraftAngleAnalysisSettings',
    properties: [
      {
        signature: 'Interval AngleRange',
        summary: 'The angle range.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowIsoCurves',
        summary: 'Show isoparametric curves.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d UpDirection',
        summary: 'The up direction.',
        since: 7,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'EdgeAnalysisSettings',
    dataType: 1,
    summary: 'Contains static methods and properties to modify the visibility of edges in edge-related commands.',
    properties: [
      {
        signature: 'static Color ShowEdgeColor',
        summary: `Gets or sets a color used to enhance display
    edges in commands like _ShowEdges and _ShowNakedEdges.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static int ShowEdges',
        summary: `Gets or sets a value referring to the group of edges that are targeted.
     0 = all.1 = naked.2 = non-manifold.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static EdgeAnalysisSettingsState GetCurrentState()',
        summary: 'Gets the current settings of the application.',
        since: 5
      },
      {
        signature: 'static EdgeAnalysisSettingsState GetDefaultState()',
        summary: 'Gets the factory settings of the application.',
        since: 5
      },
      {
        signature: 'static void RestoreDefaults()',
        summary: 'Commits the default settings as the current settings.',
        since: 5
      },
      {
        signature: 'static void UpdateFromState(EdgeAnalysisSettingsState state)',
        summary: 'Sets all settings to a particular defined joined state.',
        since: 5,
        parameters: [
          {
            name: 'state',
            summary: 'The particular state.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'EdgeAnalysisSettingsState',
    dataType: 1,
    summary: 'Represents a snapshot of EdgeAnalysisSettings.',
    properties: [
      {
        signature: 'Color ShowEdgeColor',
        summary: 'Gets or sets a color used to enhance display edges in commands like _ShowEdges and _ShowNakedEdges.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int ShowEdges',
        summary: `Gets or sets a value referring to the group of edges that are targeted.
     0 = all.1 = naked.2 = non-manifold.`,
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'FileSettings',
    dataType: 1,
    summary: 'Contains static methods and properties relating Rhino files.',
    properties: [
      {
        signature: 'static bool AutoSaveEnabled',
        summary: 'Enables or disables Rhino\'s automatic file saving mechanism.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static string AutoSaveFile',
        summary: 'the file name used by Rhino\'s automatic file saving mechanism.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static TimeSpan AutoSaveInterval',
        summary: 'how often the document will be saved when Rhino\'s automatic file saving mechanism is enabled.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool AutoSaveMeshes',
        summary: 'save render and display meshes in autosave file.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool ClipboardCopyToPreviousRhinoVersion',
        summary: `Gets or sets a value that decides if copies to the clipboard are performed in both the current
     and previous Rhino clipboard formats.  This means you will double the size of what is saved in
     the clipboard but will be able to copy from the current to the previous version using the
     clipboard.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static ClipboardState ClipboardOnExit',
        summary: 'Gets or sets a value that determines what to do with clipboad data on exit.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool CreateBackupFiles',
        summary: 'Gets or sets a value that controls the creation of backup files.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static string DefaultRuiFile',
        summary: 'Gets the path to the default RUI file.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static string ExecutableFolder',
        summary: 'Returns the directory where the main Rhino executable is located.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static bool FileLockingEnabled',
        summary: 'Ensure that only one person at a time can have a file open for saving.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool FileLockingOpenWarning',
        summary: 'Gets or sets whether to display the information dialog which identifies computer files.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static string HelpFilePath',
        summary: 'Gets the Rhino help file path.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static DirectoryInfo InstallFolder',
        summary: 'Returns Rhino\'s installation folder.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static string LocalProfileDataFolder',
        summary: `Get full path to a Rhino specific sub-folder under the per-user Local
     (non-roaming) Profile folder.  This is the folder where user-specific
     data is stored.
     
     On Windows 7, 8, usually someplace like:
       "C:\\Users\\[USERNAME]\\AppData\\Local\\McNeel\\Rhinoceros\\[VERSION_NUMBER]\\"`,
        since: 5.8,
        property: ['get']
      },
      {
        signature: 'static bool SaveViewChanges',
        summary: 'True for users who consider view changes a document change.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static int SearchPathCount',
        summary: 'Gets the amount of search paths that are currently defined.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static string TemplateFile',
        summary: 'Returns or sets the location of Rhino\'s template file.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static string TemplateFolder',
        summary: 'Returns or sets the location of Rhino\'s template files.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static string WorkingFolder',
        summary: `Returns or sets Rhino's working directory, or folder.
     The working folder is the default folder for all file operations.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static int AddSearchPath(string folder,int index)',
        summary: `Adds a new imagePath to Rhino's search imagePath list.
     See "Options Files settings" in the Rhino help file for more details.`,
        since: 5,
        parameters: [
          {
            name: 'folder',
            summary: '[in] The valid folder, or imagePath, to add.'
          },
          {
            name: 'index',
            summary: `[in] A zero-based position index in the search imagePath list to insert the string.
     If -1, the imagePath will be appended to the end of the list.`
          }
        ],
        returns: `The index where the item was inserted if success.
     -1 on failure.`
      },
      {
        signature: 'static string[] AutoSaveBeforeCommands()',
        summary: 'Input list of commands that force AutoSave prior to running.',
        since: 5
      },
      {
        signature: 'static bool DeleteSearchPath(string folder)',
        summary: `Removes an existing imagePath from Rhino's search imagePath list.
     See "Options Files settings" in the Rhino help file for more details.`,
        since: 5,
        parameters: [
          {
            name: 'folder',
            summary: '[in] The valid folder, or imagePath, to remove.'
          }
        ],
        returns: 'True or False indicating success or failure.'
      },
      {
        signature: 'static string FindFile(string fileName)',
        summary: `Searches for a file using Rhino's search imagePath. Rhino will look for a file in the following locations:
     1. The current document's folder.
     2. Folder's specified in Options dialog, File tab.
     3. Rhino's System folders.`,
        since: 5,
        parameters: [
          {
            name: 'fileName',
            summary: 'short file name to search for.'
          }
        ],
        returns: 'full imagePath on success; None on error.'
      },
      {
        signature: 'static FileSettingsState GetCurrentState()',
        summary: 'Returns the current state.',
        since: 5,
        returns: 'A new instance containing the current state.'
      },
      {
        signature: 'static string GetDataFolder(bool currentUser)',
        summary: 'Gets the data folder for machine or current user.',
        since: 5,
        parameters: [
          {
            name: 'currentUser',
            summary: 'True if the query relates to the current user.'
          }
        ],
        returns: 'A directory to user or machine data.'
      },
      {
        signature: 'static FileSettingsState GetDefaultState()',
        summary: 'Returns the default state.',
        since: 5,
        returns: 'A new instance containing the default state.'
      },
      {
        signature: 'static string[] GetSearchPaths()',
        summary: 'Returns all of the imagePath items in Rhino\'s search imagePath list. See "Options Files settings" in the Rhino help file for more details.',
        since: 5
      },
      {
        signature: 'static string[] RecentlyOpenedFiles()',
        summary: `Returns a list of recently opened files. Note that this function does not
     check to make sure that these files still exist.`,
        since: 5,
        returns: 'An array of strings with the paths to the recently opened files.'
      },
      {
        signature: 'static void SetAutoSaveBeforeCommands(string[] commands)',
        summary: 'Set list of commands that force AutoSave prior to running.',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'FileSettingsState',
    dataType: 1,
    summary: 'Represents a snapshot of FileSettings.',
    properties: [
      {
        signature: 'bool AutoSaveEnabled',
        summary: 'Enables or disables Rhino\'s automatic file saving mechanism.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'TimeSpan AutoSaveInterval',
        summary: 'How often the document will be saved when Rhino\'s automatic file saving mechanism is enabled.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool AutoSaveMeshes',
        summary: 'Saves render and display meshes in autosave file.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ClipboardCopyToPreviousRhinoVersion',
        summary: `Gets or sets a value that decides if copies to the clipboard are performed in both the current
     and previous Rhino clipboard formats.  This means you will double the size of what is saved in
     the clipboard but will be able to copy from the current to the previous version using the
     clipboard.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ClipboardState ClipboardOnExit',
        summary: 'Gets or sets a value that determines what to do with clipboad data on exit.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool CreateBackupFiles',
        summary: 'Gets or sets a value indicating whether to create backup files.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool FileLockingEnabled',
        summary: 'Ensures that only one person at a time can have a file open for saving.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool FileLockingOpenWarning',
        summary: 'Displays an information dialog which identifies computer file is open on.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool SaveViewChanges',
        summary: 'True for users who consider view changes a document change.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'GeneralSettings',
    dataType: 1,
    summary: 'Contains static methods and properties to give access to Rhinoceros settings.',
    properties: [
      {
        signature: 'static bool AutoUpdateCommandHelp',
        summary: 'Command help dialog auto-update feature.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static TimeSpan ContextMenuDelay',
        summary: 'Time to wait before permitting context menu display.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool EnableContextMenu',
        summary: 'True if right mouse down + delay will pop up context menu on a mouse up if no move happens.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static int MaximumPopupMenuLines',
        summary: 'Gets or sets the maximum number of popup menu lines.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static int MaximumUndoMemoryMb',
        summary: `Gets or sets the minimum undo memory Mb.
     Undo records will be purged if there are more than MinimumUndoSteps and
     they use more than MaximumUndoMemoryMb.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static string MiddleMouseMacro',
        summary: `Gets or sets the toolbar to popup when the middle mouse is clicked on
     a view, this value is only used when MiddleMouseMode is set to
     PopupToolbar.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static MiddleMouseMode MiddleMouseMode',
        summary: 'Gets or sets what happens when the user clicks the middle mouse.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static string MiddleMousePopupToolbar',
        summary: `Gets or sets the toolbar to popup when the middle mouse is clicked on
     a view, this value is only used when MiddleMouseMode is set to
     PopupToolbar.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static int MinimumUndoSteps',
        summary: `Gets or sets the minimum undo steps.
     Undo records will be purged if there are more than MinimumUndoSteps and
     they use more than MaximumUndoMemoryMb.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static MouseSelectMode MouseSelectMode',
        summary: 'Gets or sets the current selection mode.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static int NewObjectIsoparmCount',
        summary: 'Gets or sets the number of isoparm curves to show on new objects.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool UseExtrusions',
        summary: 'Should extrusion objects be created for things like cylinders',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static GeneralSettingsState GetCurrentState()',
        summary: 'Gets the current settings.',
        since: 5,
        returns: 'A new general state with current settings.'
      },
      {
        signature: 'static GeneralSettingsState GetDefaultState()',
        summary: 'Gets the factory settings.',
        since: 5,
        returns: 'A new general state with factory settings.'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'GeneralSettingsState',
    dataType: 1,
    summary: 'Represents a snapshot of GeneralSettings.',
    properties: [
      {
        signature: 'bool AutoUpdateCommandHelp',
        summary: 'Gets or sets the command help dialog auto-update feature.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'TimeSpan ContextMenuDelay',
        summary: 'Gets or sets the time to wait before permitting context menu display.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool EnableContextMenu',
        summary: 'True if right mouse down + delay will pop up context menu on a mouse up if no move happens.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int MaximumPopupMenuLines',
        summary: 'Gets or sets the maximum number of popup menu lines.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int MaximumUndoMemoryMb',
        summary: `Gets or sets the minimum undo memory Mb.
     Undo records will be purged if there are more than MinimumUndoSteps and
     they use more than MaximumUndoMemoryMb.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string MiddleMouseMacro',
        summary: `Gets or sets the toolbar to popup when the middle mouse is clicked on
     a view, this value is only used when MiddleMouseMode is set to
     PopupToolbar.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'MiddleMouseMode MiddleMouseMode',
        summary: 'Gets or sets what happens when the user clicks the middle mouse.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string MiddleMousePopupToolbar',
        summary: `Gets or sets the toolbar to popup when the middle mouse is clicked on
     a view, this value is only used when MiddleMouseMode is set to
     PopupToolbar.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int MinimumUndoSteps',
        summary: `Gets or sets the minimum undo steps.
     Undo records will be purged if there are more than MinimumUndoSteps and
     they use more than MaximumUndoMemoryMb.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'MouseSelectMode MouseSelectMode',
        summary: 'Gets or sets the current selection mode.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int NewObjectIsoparmCount',
        summary: 'Gets or sets the number of isoparm curves to show on new objects.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'HistorySettings',
    dataType: 1,
    summary: 'Provides static (Shared in Vb.Net) properties to modify Rhino History settings.',
    properties: [
      {
        signature: 'static bool BrokenRecordWarningEnabled',
        summary: 'Displays a warning dialog when an action is taken that breaks the link between the output and input objects.',
        since: 6.1,
        property: ['get', 'set']
      },
      {
        signature: 'static bool ObjectLockingEnabled',
        summary: `When history object locking is enabled, objects with history on them act as if
     they were locked and the only way to modify these objects is to edit their inputs.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool RecordingEnabled',
        summary: `When history recording is enabled, new objects keep a record of how they
     were constructed so that they can be updated if an input object changes.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool UpdateEnabled',
        summary: `When history update is enabled, dependant objects are automatically updated
     when an antecedent is modified.`,
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'Installation',
    dataType: 3,
    summary: 'The type of Rhino executable that is executing',
    values: [
      {
        signature: 'Undefined = 0',
        summary: 'Unknown'
      },
      {
        signature: 'Commercial'
      },
      {
        signature: 'Educational'
      },
      {
        signature: 'EducationalLab'
      },
      {
        signature: 'NotForResale'
      },
      {
        signature: 'NotForResaleLab'
      },
      {
        signature: 'Beta'
      },
      {
        signature: 'BetaLab'
      },
      {
        signature: 'Evaluation',
        summary: '25 Save limit evaluation version of Rhino'
      },
      {
        signature: 'Corporate'
      },
      {
        signature: 'EvaluationTimed',
        summary: '90 day time limit evaluation version of Rhino'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'LicenseNode',
    dataType: 3,
    summary: 'License node types.',
    values: [
      {
        signature: 'Standalone = 0',
        summary: 'An independent node.'
      },
      {
        signature: 'Network = 1',
        summary: 'Network (obtains license from Zoo server)'
      },
      {
        signature: 'NetworkCheckedOut = 2',
        summary: 'Network (has license checked out from Zoo server)'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'MiddleMouseMode',
    dataType: 3,
    summary: `Defines enumerated constant values to define what happens when
   either the middle mouse button on a three-button mouse is clicked or after pressing the wheel on a wheeled mouse.`,
    values: [
      {
        signature: 'PopupMenu = 0',
        summary: `Pops up two-part menu at the cursor location.
     You can list your favorite commands in the top section.
     The bottom section is the list of most recent commands used.`
      },
      {
        signature: 'PopupToolbar = 1',
        summary: `Choose a toolbar to pop up at the cursor location.
     Create a toolbar containing your favorite commands or object snaps to use as a pop-up toolbar.`
      },
      {
        signature: 'RunMacro = 2',
        summary: 'Lists a series of commands that run when you click the middle mouse button.'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'ModelAidSettings',
    dataType: 1,
    summary: 'Contains static methods and properties to modify model aid settings.',
    properties: [
      {
        signature: 'static bool AltPlusArrow',
        summary: 'True means Alt+arrow is used for nudging.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool AutoGumballEnabled',
        summary: `When AutoGumball is on, a gumball automatically appears
     when objects are prepicked.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static int ControlPolygonDisplayDensity',
        summary: 'Gets or sets the control polygon display density.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static double CtrlNudgeKeyStep',
        summary: 'Gets or sets the Ctrl-key based nudge step amount.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool DisplayControlPolygon',
        summary: 'Gets or sets the enabled state of Rhino\'s display control polygon.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool ExtendToApparentIntersection',
        summary: 'Gets or sets the enabled state of Rhino\'s extend to apparent intersections.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool ExtendTrimLines',
        summary: 'Gets or sets the enabled state of Rhino\'s extend trim lines.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool GridSnap',
        summary: 'Gets or sets the enabled state of Rhino\'s grid snap modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool HighlightControlPolygon',
        summary: 'Gets or sets the enabled state of Rhino\'s highlight dialog modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static int MousePickboxRadius',
        summary: 'radius of mouse pick box in pixels.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static double NudgeKeyStep',
        summary: 'Gets or sets the nudge step amount.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static int NudgeMode',
        summary: '0 = world, 1 = cplane, 2 = view, 3 = uvn, -1 = not set.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool Ortho',
        summary: 'Gets or sets the enabled state of Rhino\'s ortho modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static double OrthoAngle',
        summary: 'Gets or sets the base orthogonal angle.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool Osnap',
        summary: 'Enables or disables Rhino\'s object snap modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static CursorMode OsnapCursorMode',
        summary: 'Gets or sets the OSnap cursor mode.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static OsnapModes OsnapModes',
        summary: `Returns or sets Rhino's current object snap mode.
    The mode is a bitwise value based on the OsnapModes enumeration.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static int OsnapPickboxRadius',
        summary: 'Enables or disables Rhino\'s planar modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool Planar',
        summary: 'Gets or sets the enabled state of Rhino\'s Planar modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static PointDisplayMode PointDisplay',
        summary: 'Gets or sets the point display mode.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool ProjectSnapToCPlane',
        summary: 'Gets or sets the enabled state of Rhino\'s Project modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static double ShiftNudgeKeyStep',
        summary: 'Gets or sets the Shift-key based nudge step amount.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool SnappyGumballEnabled',
        summary: `When SnappyGumball is on, a dragging a gumball moves the center point.
     When snappy gumball is off, dragging a gumball moves the mouse down point.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool SnapToLocked',
        summary: 'Gets or sets the locked state of the snap modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool UniversalConstructionPlaneMode',
        summary: 'Gets or sets the locked state of the snap modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool UseHorizontalDialog',
        summary: 'Gets or sets the enabled state of Rhino\'s use horizontal dialog modeling aid.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static ModelAidSettingsState GetCurrentState()',
        summary: 'Gets the current settings.',
        since: 5,
        returns: 'A new model aid state with current settings.'
      },
      {
        signature: 'static ModelAidSettingsState GetDefaultState()',
        summary: 'Gets the factory settings.',
        since: 5,
        returns: 'A new model aid state with factory settings.'
      },
      {
        signature: 'static void UpdateFromState(ModelAidSettingsState state)',
        summary: 'Updates from a particular setting state.',
        since: 5,
        parameters: [
          {
            name: 'state',
            summary: 'The new states that will be set.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'ModelAidSettingsState',
    dataType: 1,
    summary: 'Represents a snapshot of ModelAidSettings.',
    properties: [
      {
        signature: 'bool AltPlusArrow',
        summary: 'True mean Alt+arrow is used for nudging.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int ControlPolygonDisplayDensity',
        summary: 'Gets or sets the control polygon display density.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double CtrlNudgeKeyStep',
        summary: 'Gets or sets the Ctrl-key based nudge step amount.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DisplayControlPolygon',
        summary: 'Gets or sets the enabled state of Rhino\'s display control polygon.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ExtendToApparentIntersection',
        summary: 'Gets or sets the enabled state of Rhino\'s extend to apparent intersections.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ExtendTrimLines',
        summary: 'Gets or sets the enabled state of Rhino\'s extend trim lines.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool GridSnap',
        summary: 'Gets or sets the enabled state of Rhino\'s grid snap modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool HighlightControlPolygon',
        summary: 'Gets or sets the enabled state of Rhino\'s highlight dialog modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int MousePickboxRadius',
        summary: 'Gets or sets the radius of the mouse pick box in pixels.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double NudgeKeyStep',
        summary: 'Gets or sets the nudge step amount.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int NudgeMode',
        summary: '0 = world, 1 = cplane, 2 = view, 3 = uvn, -1 = not set.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool Ortho',
        summary: 'Gets or sets the enabled state of Rhino\'s ortho modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double OrthoAngle',
        summary: 'Gets or sets the base orthogonal angle.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool Osnap',
        summary: 'Gets or sets the enabled state of Rhino\'s object snap modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'CursorMode OsnapCursorMode',
        summary: 'Gets or sets the OSnap cursor mode.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'OsnapModes OsnapModes',
        summary: `Returns or sets Rhino's current object snap mode.
     The mode is a bitwise value based on the OsnapModes enumeration.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int OsnapPickboxRadius',
        summary: 'Enables or disables Rhino\'s planar modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool Planar',
        summary: 'Gets or sets the enabled state of Rhino\'s Planar modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'PointDisplayMode PointDisplay',
        summary: 'Gets or sets the point display mode.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ProjectSnapToCPlane',
        summary: 'Gets or sets the enabled state of Rhino\'s Project modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double ShiftNudgeKeyStep',
        summary: 'Gets or sets the Shift-key based nudge step amount.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool SnapToLocked',
        summary: 'Gets or sets the locked state of the snap modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool UniversalConstructionPlaneMode',
        summary: 'Gets or sets the locked state of the snap modeling aid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool UseHorizontalDialog',
        summary: 'Gets or sets the enabled state of Rhino\'s use horizontal dialog modeling aid.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'MouseSelectMode',
    dataType: 3,
    summary: 'Defines enumerated constant values to indicate a particular window selection mode.',
    values: [
      {
        signature: 'Crossing = 0',
        summary: 'Anything that crosses this window will be selected.'
      },
      {
        signature: 'Window = 1',
        summary: 'Anything that is inside this window will be selected.'
      },
      {
        signature: 'Combo = 2',
        summary: 'Drag a rectangle from left to right for window select. Drag a rectangle from right to left for crossing select.'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'NeverRepeatList',
    dataType: 1,
    summary: 'Contains static methods and properties relating to the list of commands that are never repeated.',
    properties: [
      {
        signature: 'static bool UseNeverRepeatList',
        summary: `Only use the list if somebody modifies it via CRhinoAppSettings::SetDontRepeatCommands().
     Return value of True means CRhinoCommand don't repeat flags will be ignored and the m_dont_repeat_list
     will be used instead.  False means the individual CRhinoCommands will determine if they are repeatable.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static string[] CommandNames()',
        summary: 'The list of commands to not repeat.',
        since: 5
      },
      {
        signature: 'static int SetList(string[] commandNames)',
        summary: 'Puts the command name tokens in m_dont_repeat_list.',
        since: 5,
        returns: 'Number of items added to m_dont_repeat_list.'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'OpenGLSettings',
    dataType: 1,
    summary: 'Static methods and properties to control OpenGL settings',
    properties: [
      {
        signature: 'static AntialiasLevel AntialiasLevel',
        summary: 'Gets or sets the antialias level used by OpenGL viewports',
        since: 6.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static OpenGLSettingsState GetCurrentState()',
        summary: 'Gets the current settings.',
        since: 6.1,
        returns: 'A new OpenGL state with current settings.'
      },
      {
        signature: 'static OpenGLSettingsState GetDefaultState()',
        summary: 'Gets the OpenGL factory settings.',
        since: 6.1,
        returns: 'A new OpenGL state with factory settings.'
      },
      {
        signature: 'static void RestoreDefaults()',
        summary: 'Updates from the default setting state.',
        since: 6.1
      },
      {
        signature: 'static void UpdateFromState(OpenGLSettingsState state)',
        summary: 'Updates from a particular setting state.',
        since: 6.1,
        parameters: [
          {
            name: 'state',
            summary: 'The new state that will be set.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'OpenGLSettingsState',
    dataType: 1,
    summary: 'Represents a sapshot of OpenGLSettings',
    properties: [
      {
        signature: 'AntialiasLevel AntialiasLevel',
        summary: 'AA level used in OpenGL viewports',
        since: 6.1,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'OsnapModes',
    dataType: 3,
    summary: `Defines several bit masks for each of the OSnap that are defined.
   Refer to the Rhino Help file for further information.`,
    values: [
      {
        signature: 'None = 0',
        summary: 'No OSnap.'
      },
      {
        signature: 'Near = 2',
        summary: 'Near OSnap.'
      },
      {
        signature: 'Focus = 8',
        summary: 'Focus OSnap.'
      },
      {
        signature: 'Center = 0x20',
        summary: 'Center OSnap.'
      },
      {
        signature: 'Vertex = 0x40',
        summary: 'Vertex OSnap.'
      },
      {
        signature: 'Knot = 0x80',
        summary: 'Knot OSnap.'
      },
      {
        signature: 'Quadrant = 0x200',
        summary: 'Quadrant OSnap.'
      },
      {
        signature: 'Midpoint = 0x800',
        summary: 'Midpoint OSnap.'
      },
      {
        signature: 'Intersection = 0x2000',
        summary: 'Intersection OSnap.'
      },
      {
        signature: 'End = 0x20000',
        summary: 'End OSnap.'
      },
      {
        signature: 'Perpendicular = 0x80000',
        summary: 'Perpendicular OSnap.'
      },
      {
        signature: 'Tangent = 0x200000',
        summary: 'Tangent OSnap.'
      },
      {
        signature: 'Point =  0x8000000',
        summary: 'Point OSnap.'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'PaintColor',
    dataType: 3,
    summary: 'Contains enumerated constant values to represent logical colors associated with elements of the user interface.',
    values: [
      {
        signature: 'NormalStart = 0',
        summary: 'Gradient start for active toolbar tab and non-client area of Rhino.'
      },
      {
        signature: 'NormalEnd = 1',
        summary: 'Gradient end for active toolbar tab and non-client area of Rhino.'
      },
      {
        signature: 'NormalBorder = 2',
        summary: 'Edge color used for grippers, toolbar border, resize bars, status bar pane borders.'
      },
      {
        signature: 'HotStart = 3',
        summary: 'Gradient start for inactive toolbar tab.'
      },
      {
        signature: 'HotEnd = 4',
        summary: 'Gradient end for inactive toolbar tab.'
      },
      {
        signature: 'HotBorder = 5',
        summary: 'Inactive toolbar tab border.'
      },
      {
        signature: 'PressedStart = 6',
        summary: 'Pressed gradient start.'
      },
      {
        signature: 'PressedEnd = 7',
        summary: 'Pressed gradient end.'
      },
      {
        signature: 'PressedBorder = 8',
        summary: 'Pressed border.'
      },
      {
        signature: 'TextEnabled = 9',
        summary: 'Toolbar tab text and status bar text.'
      },
      {
        signature: 'TextDisabled = 10',
        summary: 'Disabled text color.'
      },
      {
        signature: 'MouseOverControlStart = 11',
        summary: 'Color for hovering gradient start.'
      },
      {
        signature: 'MouseOverControlEnd = 12',
        summary: 'Color for hovering gradient end.'
      },
      {
        signature: 'MouseOverControlBorder = 13',
        summary: 'Color for hovering border.'
      },
      {
        signature: 'ActiveCaption = 14',
        summary: 'Active floating window non-client area'
      },
      {
        signature: 'InactiveCaption = 15',
        summary: 'Inactive floating window non-client area'
      },
      {
        signature: 'PanelBackground = 16',
        summary: 'Background color of panels'
      },
      {
        signature: 'ActiveViewportTitle = 17',
        summary: 'Active viewport title.'
      },
      {
        signature: 'InactiveViewportTitle = 18',
        summary: 'Inactive viewport title.'
      },
      {
        signature: 'ModifiedValueControlColor = 19',
        summary: 'Modified property value label text color'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'PointDisplayMode',
    dataType: 3,
    summary: 'Defines enumerated constant values for world coordinates and CPlane point display modes.',
    values: [
      {
        signature: 'WorldPoint = 0',
        summary: 'Points are displayed in world coordinates.'
      },
      {
        signature: 'CplanePoint',
        summary: 'Points are displayed in CPlane coordinates.'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'SelectionFilterSettings',
    dataType: 1,
    summary: `Selection filter settings restrict any selection mode (SelWindow, SelCrossing, SelAll, etc.) to specified object types.
   Note, selection filter settings are not persistent.`,
    properties: [
      {
        signature: 'static bool Enabled',
        summary: 'Enables or disables the global object selection filter.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'static ObjectType GlobalGeometryFilter',
        summary: `The global geometry type filter controls which types of geometry will be be filtered.
     Note, the filter can be a bitwise combination of multiple object types.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'static ObjectType OneShotGeometryFilter',
        summary: `The one-shot geometry type filter controls which types of geometry will be be filtered for one selection.
     Note, the filter can be a bitwise combination of multiple object types.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'static bool SubObjectSelect',
        summary: 'Enables or disabled sub-object selection.',
        since: 7,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static SelectionFilterSettingsState GetCurrentState()',
        summary: 'Gets the current settings of the application.',
        since: 7
      },
      {
        signature: 'static SelectionFilterSettingsState GetDefaultState()',
        summary: 'Gets the factory settings of the application.',
        since: 7
      },
      {
        signature: 'static void RestoreDefaults()',
        summary: 'Commits the default settings as the current settings.',
        since: 7
      },
      {
        signature: 'static void UpdateFromState(SelectionFilterSettingsState state)',
        summary: 'Sets all settings to a particular defined joined state.',
        since: 7,
        parameters: [
          {
            name: 'state',
            summary: 'The particular state.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'SelectionFilterSettingsState',
    dataType: 1,
    summary: 'Represents a snapshot of SelectionFilterSettings.',
    properties: [
      {
        signature: 'bool Enabled',
        summary: 'Enables or disables the global object selection filter.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'ObjectType GlobalGeometryFilter',
        summary: `The global geometry type filter controls which types of geometry will be be filtered.
     Note, the filter can be a bitwise combination of multiple object types.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'ObjectType OneShotGeometryFilter',
        summary: `The one-shot geometry type filter controls which types of geometry will be be filtered for one selection.
     Note, the filter can be a bitwise combination of multiple object types.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool SubObjectSelect',
        summary: 'Enables or disabled sub-object selection.',
        since: 7,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'ShortcutKey',
    dataType: 3,
    summary: 'Shortcut key combinations',
    values: [
      {
        signature: 'F1 = 0',
        summary: 'F1'
      },
      {
        signature: 'F2',
        summary: 'F2'
      },
      {
        signature: 'F3',
        summary: 'F3'
      },
      {
        signature: 'F4',
        summary: 'F4'
      },
      {
        signature: 'F5',
        summary: 'F5'
      },
      {
        signature: 'F6',
        summary: 'F6'
      },
      {
        signature: 'F7',
        summary: 'F7'
      },
      {
        signature: 'F8',
        summary: 'F8'
      },
      {
        signature: 'F9',
        summary: 'F9'
      },
      {
        signature: 'F10',
        summary: 'F10'
      },
      {
        signature: 'F11',
        summary: 'F11'
      },
      {
        signature: 'F12',
        summary: 'F12'
      },
      {
        signature: 'CtrlF1',
        summary: 'Ctrl + F1'
      },
      {
        signature: 'CtrlF2',
        summary: 'Ctrl + F2'
      },
      {
        signature: 'CtrlF3',
        summary: 'Ctrl + F3'
      },
      {
        signature: 'CtrlF4',
        summary: 'Ctrl + F4'
      },
      {
        signature: 'CtrlF5',
        summary: 'Ctrl + F5'
      },
      {
        signature: 'CtrlF6',
        summary: 'Ctrl + F6'
      },
      {
        signature: 'CtrlF7',
        summary: 'Ctrl + F7'
      },
      {
        signature: 'CtrlF8',
        summary: 'Ctrl + F8'
      },
      {
        signature: 'CtrlF9',
        summary: 'Ctrl + F9'
      },
      {
        signature: 'CtrlF10',
        summary: 'Ctrl + F10'
      },
      {
        signature: 'CtrlF11',
        summary: 'Ctrl + F11'
      },
      {
        signature: 'CtrlF12',
        summary: 'Ctrl + F12'
      },
      {
        signature: 'ShiftCtrlF1',
        summary: 'Shift + Ctrl + F1'
      },
      {
        signature: 'ShiftCtrlF2',
        summary: 'Shift + Ctrl + F2'
      },
      {
        signature: 'ShiftCtrlF3',
        summary: 'Shift + Ctrl + F3'
      },
      {
        signature: 'ShiftCtrlF4',
        summary: 'Shift + Ctrl + F4'
      },
      {
        signature: 'ShiftCtrlF5',
        summary: 'Shift + Ctrl + F5'
      },
      {
        signature: 'ShiftCtrlF6',
        summary: 'Shift + Ctrl + F6'
      },
      {
        signature: 'ShiftCtrlF7',
        summary: 'Shift + Ctrl + F7'
      },
      {
        signature: 'ShiftCtrlF8',
        summary: 'Shift + Ctrl + F8'
      },
      {
        signature: 'ShiftCtrlF9',
        summary: 'Shift + Ctrl + F9'
      },
      {
        signature: 'ShiftCtrlF10',
        summary: 'Shift + Ctrl + F10'
      },
      {
        signature: 'ShiftCtrlF11',
        summary: 'Shift + Ctrl + F11'
      },
      {
        signature: 'ShiftCtrlF12',
        summary: 'Shift + Ctrl + F12'
      },
      {
        signature: 'AltCtrlF1',
        summary: 'Alt + Ctrl + F1'
      },
      {
        signature: 'AltCtrlF2',
        summary: 'Alt + Ctrl + F2'
      },
      {
        signature: 'AltCtrlF3',
        summary: 'Alt + Ctrl + F3'
      },
      {
        signature: 'AltCtrlF4',
        summary: 'Alt + Ctrl + F4'
      },
      {
        signature: 'AltCtrlF5',
        summary: 'Alt + Ctrl + F5'
      },
      {
        signature: 'AltCtrlF6',
        summary: 'Alt + Ctrl + F6'
      },
      {
        signature: 'AltCtrlF7',
        summary: 'Alt + Ctrl + F7'
      },
      {
        signature: 'AltCtrlF8',
        summary: 'Alt + Ctrl + F8'
      },
      {
        signature: 'AltCtrlF9',
        summary: 'Alt + Ctrl + F9'
      },
      {
        signature: 'AltCtrlF10',
        summary: 'Alt + Ctrl + F10'
      },
      {
        signature: 'AltCtrlF11',
        summary: 'Alt + Ctrl + F11'
      },
      {
        signature: 'AltCtrlF12',
        summary: 'Alt + Ctrl + F12'
      },
      {
        signature: 'CtrlA',
        summary: 'Ctrl + A'
      },
      {
        signature: 'CtrlB',
        summary: 'Ctrl + B'
      },
      {
        signature: 'CtrlC',
        summary: 'Ctrl + C'
      },
      {
        signature: 'CtrlD',
        summary: 'Ctrl + D'
      },
      {
        signature: 'CtrlE',
        summary: 'Ctrl + E'
      },
      {
        signature: 'CtrlF',
        summary: 'Ctrl + F'
      },
      {
        signature: 'CtrlG',
        summary: 'Ctrl + G'
      },
      {
        signature: 'CtrlH',
        summary: 'Ctrl + H'
      },
      {
        signature: 'CtrlI',
        summary: 'Ctrl + I'
      },
      {
        signature: 'CtrlJ',
        summary: 'Ctrl + J'
      },
      {
        signature: 'CtrlK',
        summary: 'Ctrl + K'
      },
      {
        signature: 'CtrlL',
        summary: 'Ctrl + L'
      },
      {
        signature: 'CtrlM',
        summary: 'Ctrl + M'
      },
      {
        signature: 'CtrlN',
        summary: 'Ctrl + N'
      },
      {
        signature: 'CtrlO',
        summary: 'Ctrl + O'
      },
      {
        signature: 'CtrlP',
        summary: 'Ctrl + P'
      },
      {
        signature: 'CtrlQ',
        summary: 'Ctrl + Q'
      },
      {
        signature: 'CtrlR',
        summary: 'Ctrl + R'
      },
      {
        signature: 'CtrlS',
        summary: 'Ctrl + S'
      },
      {
        signature: 'CtrlT',
        summary: 'Ctrl + T'
      },
      {
        signature: 'CtrlU',
        summary: 'Ctrl + U'
      },
      {
        signature: 'CtrlV',
        summary: 'Ctrl + V'
      },
      {
        signature: 'CtrlW',
        summary: 'Ctrl + W'
      },
      {
        signature: 'CtrlX',
        summary: 'Ctrl + X'
      },
      {
        signature: 'CtrlY',
        summary: 'Ctrl + Y'
      },
      {
        signature: 'CtrlZ',
        summary: 'Ctrl + Z'
      },
      {
        signature: 'ShiftCtrlA',
        summary: 'Shift + Ctrl + A'
      },
      {
        signature: 'ShiftCtrlB',
        summary: 'Shift + Ctrl + B'
      },
      {
        signature: 'ShiftCtrlC',
        summary: 'Shift + Ctrl + C'
      },
      {
        signature: 'ShiftCtrlD',
        summary: 'Shift + Ctrl + D'
      },
      {
        signature: 'ShiftCtrlE',
        summary: 'Shift + Ctrl + E'
      },
      {
        signature: 'ShiftCtrlF',
        summary: 'Shift + Ctrl + F'
      },
      {
        signature: 'ShiftCtrlG',
        summary: 'Shift + Ctrl + G'
      },
      {
        signature: 'ShiftCtrlH',
        summary: 'Shift + Ctrl + H'
      },
      {
        signature: 'ShiftCtrlI',
        summary: 'Shift + Ctrl + I'
      },
      {
        signature: 'ShiftCtrlJ',
        summary: 'Shift + Ctrl + J'
      },
      {
        signature: 'ShiftCtrlK',
        summary: 'Shift + Ctrl + K'
      },
      {
        signature: 'ShiftCtrlL',
        summary: 'Shift + Ctrl + L'
      },
      {
        signature: 'ShiftCtrlM',
        summary: 'Shift + Ctrl + M'
      },
      {
        signature: 'ShiftCtrlN',
        summary: 'Shift + Ctrl + N'
      },
      {
        signature: 'ShiftCtrlO',
        summary: 'Shift + Ctrl + O'
      },
      {
        signature: 'ShiftCtrlP',
        summary: 'Shift + Ctrl + P'
      },
      {
        signature: 'ShiftCtrlQ',
        summary: 'Shift + Ctrl + Q'
      },
      {
        signature: 'ShiftCtrlR',
        summary: 'Shift + Ctrl + R'
      },
      {
        signature: 'ShiftCtrlS',
        summary: 'Shift + Ctrl + S'
      },
      {
        signature: 'ShiftCtrlT',
        summary: 'Shift + Ctrl + T'
      },
      {
        signature: 'ShiftCtrlU',
        summary: 'Shift + Ctrl + U'
      },
      {
        signature: 'ShiftCtrlV',
        summary: 'Shift + Ctrl + V'
      },
      {
        signature: 'ShiftCtrlW',
        summary: 'Shift + Ctrl + W'
      },
      {
        signature: 'ShiftCtrlX',
        summary: 'Shift + Ctrl + X'
      },
      {
        signature: 'ShiftCtrlY',
        summary: 'Shift + Ctrl + Y'
      },
      {
        signature: 'ShiftCtrlZ',
        summary: 'Shift + Ctrl + Z'
      },
      {
        signature: 'AltCtrlA',
        summary: 'Alt + Ctrl + A'
      },
      {
        signature: 'AltCtrlB',
        summary: 'Alt + Ctrl + B'
      },
      {
        signature: 'AltCtrlC',
        summary: 'Alt + Ctrl + C'
      },
      {
        signature: 'AltCtrlD',
        summary: 'Alt + Ctrl + D'
      },
      {
        signature: 'AltCtrlE',
        summary: 'Alt + Ctrl + E'
      },
      {
        signature: 'AltCtrlF',
        summary: 'Alt + Ctrl + F'
      },
      {
        signature: 'AltCtrlG',
        summary: 'Alt + Ctrl + G'
      },
      {
        signature: 'AltCtrlH',
        summary: 'Alt + Ctrl + H'
      },
      {
        signature: 'AltCtrlI',
        summary: 'Alt + Ctrl + I'
      },
      {
        signature: 'AltCtrlJ',
        summary: 'Alt + Ctrl + J'
      },
      {
        signature: 'AltCtrlK',
        summary: 'Alt + Ctrl + K'
      },
      {
        signature: 'AltCtrlL',
        summary: 'Alt + Ctrl + L'
      },
      {
        signature: 'AltCtrlM',
        summary: 'Alt + Ctrl + M'
      },
      {
        signature: 'AltCtrlN',
        summary: 'Alt + Ctrl + N'
      },
      {
        signature: 'AltCtrlO',
        summary: 'Alt + Ctrl + O'
      },
      {
        signature: 'AltCtrlP',
        summary: 'Alt + Ctrl + P'
      },
      {
        signature: 'AltCtrlQ',
        summary: 'Alt + Ctrl + Q'
      },
      {
        signature: 'AltCtrlR',
        summary: 'Alt + Ctrl + R'
      },
      {
        signature: 'AltCtrlS',
        summary: 'Alt + Ctrl + S'
      },
      {
        signature: 'AltCtrlT',
        summary: 'Alt + Ctrl + T'
      },
      {
        signature: 'AltCtrlU',
        summary: 'Alt + Ctrl + U'
      },
      {
        signature: 'AltCtrlV',
        summary: 'Alt + Ctrl + V'
      },
      {
        signature: 'AltCtrlW',
        summary: 'Alt + Ctrl + W'
      },
      {
        signature: 'AltCtrlX',
        summary: 'Alt + Ctrl + X'
      },
      {
        signature: 'AltCtrlY',
        summary: 'Alt + Ctrl + Y'
      },
      {
        signature: 'AltCtrlZ',
        summary: 'Alt + Ctrl + Z'
      },
      {
        signature: 'Ctrl0',
        summary: 'Ctrl + 0'
      },
      {
        signature: 'Ctrl1',
        summary: 'Ctrl + 1'
      },
      {
        signature: 'Ctrl2',
        summary: 'Ctrl + 2'
      },
      {
        signature: 'Ctrl3',
        summary: 'Ctrl + 3'
      },
      {
        signature: 'Ctrl4',
        summary: 'Ctrl + 4'
      },
      {
        signature: 'Ctrl5',
        summary: 'Ctrl + 5'
      },
      {
        signature: 'Ctrl6',
        summary: 'Ctrl + 6'
      },
      {
        signature: 'Ctrl7',
        summary: 'Ctrl + 7'
      },
      {
        signature: 'Ctrl8',
        summary: 'Ctrl + 8'
      },
      {
        signature: 'Ctrl9',
        summary: 'Ctrl + 9'
      },
      {
        signature: 'ShiftCtrl0',
        summary: 'Shift + Ctrl + 0'
      },
      {
        signature: 'ShiftCtrl1',
        summary: 'Shift + Ctrl + 1'
      },
      {
        signature: 'ShiftCtrl2',
        summary: 'Shift + Ctrl + 2'
      },
      {
        signature: 'ShiftCtrl3',
        summary: 'Shift + Ctrl + 3'
      },
      {
        signature: 'ShiftCtrl4',
        summary: 'Shift + Ctrl + 4'
      },
      {
        signature: 'ShiftCtrl5',
        summary: 'Shift + Ctrl + 5'
      },
      {
        signature: 'ShiftCtrl6',
        summary: 'Shift + Ctrl + 6'
      },
      {
        signature: 'ShiftCtrl7',
        summary: 'Shift + Ctrl + 7'
      },
      {
        signature: 'ShiftCtrl8',
        summary: 'Shift + Ctrl + 8'
      },
      {
        signature: 'ShiftCtrl9',
        summary: 'Shift + Ctrl + 9'
      },
      {
        signature: 'AltCtrl0',
        summary: 'Alt + Ctrl + 0'
      },
      {
        signature: 'AltCtrl1',
        summary: 'Alt + Ctrl + 1'
      },
      {
        signature: 'AltCtrl2',
        summary: 'Alt + Ctrl + 2'
      },
      {
        signature: 'AltCtrl3',
        summary: 'Alt + Ctrl + 3'
      },
      {
        signature: 'AltCtrl4',
        summary: 'Alt + Ctrl + 4'
      },
      {
        signature: 'AltCtrl5',
        summary: 'Alt + Ctrl + 5'
      },
      {
        signature: 'AltCtrl6',
        summary: 'Alt + Ctrl + 6'
      },
      {
        signature: 'AltCtrl7',
        summary: 'Alt + Ctrl + 7'
      },
      {
        signature: 'AltCtrl8',
        summary: 'Alt + Ctrl + 8'
      },
      {
        signature: 'AltCtrl9',
        summary: 'Alt + Ctrl + 9'
      },
      {
        signature: 'Home',
        summary: 'Home'
      },
      {
        signature: 'End',
        summary: 'End'
      },
      {
        signature: 'CtrlHome',
        summary: 'Ctrl + Home'
      },
      {
        signature: 'CtrlEnd',
        summary: 'Ctrl + End'
      },
      {
        signature: 'ShiftHome',
        summary: 'Shift + Home'
      },
      {
        signature: 'ShiftEnd',
        summary: 'Shift + End'
      },
      {
        signature: 'ShiftCtrlHome',
        summary: 'Shift + Ctrl + Home'
      },
      {
        signature: 'ShiftCtrlEnd',
        summary: 'Shift + Ctrl + End'
      },
      {
        signature: 'AltCtrlHome',
        summary: 'Alt + Ctrl + Home'
      },
      {
        signature: 'AltCtrlEnd',
        summary: 'Alt + Ctrl + End'
      },
      {
        signature: 'PageUp',
        summary: 'Page Up'
      },
      {
        signature: 'PageDown',
        summary: 'Page Down'
      },
      {
        signature: 'ShiftPageUp',
        summary: 'Shift + Page Up'
      },
      {
        signature: 'ShiftPageDown',
        summary: 'Shift + Page Down'
      },
      {
        signature: 'CtrlPageUp',
        summary: 'Ctrl + Page Up'
      },
      {
        signature: 'CtrlPageDown',
        summary: 'Ctrl + Page Down'
      },
      {
        signature: 'ShiftCtrlPageUp',
        summary: 'Shift + Ctrl + Page Up'
      },
      {
        signature: 'ShiftCtrlPageDown',
        summary: 'Shift + Ctrl + Page Down'
      },
      {
        signature: 'AltCtrlPageUp',
        summary: 'Alt + Ctrl + Page Up'
      },
      {
        signature: 'AltCtrlPageDown',
        summary: 'Alt + Ctrl + Page Down'
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'ShortcutKeySettings',
    dataType: 1,
    summary: 'Contains static methods and properties to control keyboard shortcut keys',
    methods: [
      {
        signature: 'static string GetMacro(ShortcutKey key)',
        summary: 'Get macro associated with a given keyboard shortcut',
        since: 5
      },
      {
        signature: 'static void SetMacro(ShortcutKey key,string macro)',
        summary: 'Set macro associated with a keyboard shortcut',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'SmartTrackSettings',
    dataType: 1,
    summary: 'Contains static methods and properties that target the Smart Track feature behavior.',
    properties: [
      {
        signature: 'static int ActivationDelayMilliseconds',
        summary: 'Gets or sets the activation delay in milliseconds.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color ActivePointColor',
        summary: 'Gets or sets the active point color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color LineColor',
        summary: 'Gets or sets the smart track line color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static int MaxSmartPoints',
        summary: 'Gets or sets the maximum number of smart points.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color PointColor',
        summary: 'Gets or sets the point color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool SmartOrtho',
        summary: `Gets or sets a value indicating if the 'Smart Ortho' feature is active.
     Orthogonal lines are then drawn automatically.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool SmartTangents',
        summary: 'Gets or sets a value indicating if the \'Smart Tangents\' feature is active.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static Color TanPerpLineColor',
        summary: 'Gets or sets the tangent and perpendicular line color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool UseDottedLines',
        summary: 'Gets or sets a value indicating if lines are drawn dotted.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool UseSmartTrack',
        summary: 'Gets or sets if the Smart Track feature is active.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static SmartTrackSettingsState GetCurrentState()',
        summary: 'Gets the current settings.',
        since: 5,
        returns: 'A new Smart Track state with current settings.'
      },
      {
        signature: 'static SmartTrackSettingsState GetDefaultState()',
        summary: 'Gets the Smart Track factory settings.',
        since: 5,
        returns: 'A new Smart Track state with factory settings.'
      },
      {
        signature: 'static void UpdateFromState(SmartTrackSettingsState state)',
        summary: 'Updates from a particular setting state.',
        since: 5,
        parameters: [
          {
            name: 'state',
            summary: 'The new state that will be set.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'SmartTrackSettingsState',
    dataType: 1,
    summary: 'Represents a snapshot of SmartTrackSettings.',
    properties: [
      {
        signature: 'static int MaxSmartPoints',
        summary: 'Gets or sets the maximum number of smart points.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int ActivationDelayMilliseconds',
        summary: 'Gets or sets the activation delay in milliseconds.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color ActivePointColor',
        summary: 'Gets or sets the active point color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color LineColor',
        summary: 'Gets or sets the smart track line color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color PointColor',
        summary: 'Gets or sets the point color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool SmartOrtho',
        summary: 'Gets or sets a value indicating if the \'Smart Ortho\' feature is active.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool SmartTangents',
        summary: 'Gets or sets a value indicating if the \'Smart Tangents\' feature is active.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color TanPerpLineColor',
        summary: 'Gets or sets the tangent and perpendicular line color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool UseDottedLines',
        summary: 'Gets or sets a value indicating if lines are drawn dotted.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool UseSmartTrack',
        summary: 'Gets or sets if the \'smart track\' feature is active.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'ViewSettings',
    dataType: 1,
    summary: 'Contains static methods and properties to control view settings.',
    properties: [
      {
        signature: 'static bool AlwaysPanParallelViews',
        summary: `Gets or sets the 'always pan parallel views' value.
     If the view is not looking straight at the construction plane, then
     sets parallel viewports so they will not rotate.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool DefinedViewSetCPlane',
        summary: `Gets or sets the 'named views set CPlane' value.
     When true, restoring a named view causes the construction plane saved with that view to also restore.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool DefinedViewSetProjection',
        summary: `Gets or sets the 'named views set projection' value.
     When true, restoring a named view causes the viewport projection saved with the view to also restore.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool LinkedViewports',
        summary: `Gets or sets the 'linked views' activated setting.
     True enables real-time view synchronization.
     When a standard view is manipulated, the camera lens length of all parallel projection
     viewports are set to match the current viewport.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool PanReverseKeyboardAction',
        summary: `Gets or sets if panning with the keyboard is reversed.
     false, then Rhino pans the camera in the direction of the arrow key you press.
     true, then Rhino pans the scene instead.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static double PanScreenFraction',
        summary: 'Gets or sets the faction used as multiplier to pan the screen.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static int RotateCircleIncrement',
        summary: `Gets or sets the rotation increment.
     When the user rotates a view with the keyboard, Rhino rotates the view in steps.
     The usual step is 1/60th of a circle, which equals six degrees.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool RotateReverseKeyboard',
        summary: `Gets or sets the rotation direction.
     If true, then Rhino rotates the camera around the scene, otherwise, rotates the scene itself.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool RotateToView',
        summary: `Gets or sets the rotation reference.
     If true, then the views rotates relative to the view axes; false, than relative to the world x, y, and z axes.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool SingleClickMaximize',
        summary: `Gets or sets the 'single-click maximize' value.
     When true, maximizing a viewport needs a single click on the viewport title rather than a double-click.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static double ZoomExtentsParallelViewBorder',
        summary: 'Border amount to apply to parallel viewport during zoom extents',
        since: 6.3,
        property: ['get', 'set']
      },
      {
        signature: 'static double ZoomExtentsPerspectiveViewBorder',
        summary: 'Border amount to apply to perspective viewport during zoom extents',
        since: 6.3,
        property: ['get', 'set']
      },
      {
        signature: 'static double ZoomScale',
        summary: 'Gets or sets the step size for zooming with a wheeled mouse or the Page Up and Page Down keys.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static ViewSettingsState GetCurrentState()',
        summary: 'Gets the current settings.',
        since: 5,
        returns: 'A new view state with current settings.'
      },
      {
        signature: 'static ViewSettingsState GetDefaultState()',
        summary: 'Gets the view factory settings.',
        since: 5,
        returns: 'A new view state with factory settings.'
      },
      {
        signature: 'static void RestoreDefaults()',
        summary: 'Updates from the default setting state.',
        since: 5
      },
      {
        signature: 'static void UpdateFromState(ViewSettingsState state)',
        summary: 'Updates from a particular setting state.',
        since: 5,
        parameters: [
          {
            name: 'state',
            summary: 'The new state that will be set.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'ViewSettingsState',
    dataType: 1,
    summary: 'Represents a snapshot of ViewSettings.',
    properties: [
      {
        signature: 'bool AlwaysPanParallelViews',
        summary: `Gets or sets the 'always pan parallel views' value.
     If the view is not looking straight at the construction plane, then
     sets parallel viewports so they will not rotate.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DefinedViewSetCPlane',
        summary: `Gets or sets the 'named views set CPlane' value.
     When true, restoring a named view causes the construction plane saved with that view to also restore.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DefinedViewSetProjection',
        summary: `Gets or sets the 'named views set projection' value.
     When true, restoring a named view causes the viewport projection saved with the view to also restore.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool LinkedViewports',
        summary: `Gets or sets the 'linked views' activated setting.
     True enables real-time view synchronization.
     When a standard view is manipulated, the camera lens length of all parallel projection
     viewports are set to match the current viewport.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool PanReverseKeyboardAction',
        summary: `Gets or sets if panning with the keyboard is reversed.
     false, then Rhino pans the camera in the direction of the arrow key you press.
     true, then Rhino pans the scene instead.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PanScreenFraction',
        summary: 'Gets or sets the faction used as multiplier to pan the screen.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int RotateCircleIncrement',
        summary: `Gets or sets the rotation increment.
     When the user rotates a view with the keyboard, Rhino rotates the view in steps.
     The usual step is 1/60th of a circle, which equals six degrees.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool RotateReverseKeyboard',
        summary: `Gets or sets the rotation direction.
     If true, then Rhino rotates the camera around the scene, otherwise, rotates the scene itself.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool RotateToView',
        summary: `Gets or sets the rotation reference.
     If true, then the views rotates relative to the view axes; false, than relative to the world x, y, and z axes.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool SingleClickMaximize',
        summary: `Gets or sets the 'single-click maximize' value.
     When true, maximizing a viewport needs a single click on the viewport title rather than a double-click.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double ZoomExtentsParallelViewBorder',
        summary: 'Border amount to apply to parallel viewport during zoom extents',
        since: 6.3,
        property: ['get', 'set']
      },
      {
        signature: 'double ZoomExtentsPerspectiveViewBorder',
        summary: 'Border amount to apply to perspective viewport during zoom extents',
        since: 6.3,
        property: ['get', 'set']
      },
      {
        signature: 'double ZoomScale',
        summary: 'Gets or sets the step size for zooming with a wheeled mouse or the Page Up and Page Down keys.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.ApplicationSettings',
    name: 'WidgetColor',
    dataType: 3,
    summary: 'Contains enumerated constant values to represent logical colors associated with elements of the user interface.',
    values: [
      {
        signature: 'UAxisColor = 0',
        summary: 'The color of the mapping widget u-axis.'
      },
      {
        signature: 'VAxisColor = 1',
        summary: 'The color of the mapping widget v-axis..'
      },
      {
        signature: 'WAxisColor = 2',
        summary: 'The color of the mapping widget w-axis.'
      }
    ]
  },
  {
    namespace: 'Rhino.Collections',
    name: 'ArchivableDictionary',
    dataType: 1,
    summary: `Represents a dictionary class that can be attached to objects and
   can be serialized (saved) at necessity.See remarks for layout.`,
    interfaces: ['ICloneable', 'IDictionary<string, object>', 'ISerializable'],
    constructors: [
      {
        signature: 'ArchivableDictionary()',
        summary: 'Initializes an instance of a dictionary for writing to a 3dm archive.',
        since: 5
      },
      {
        signature: 'ArchivableDictionary(int version)',
        summary: 'Initializes an instance of a dictionary for writing to a 3dm archive.',
        since: 5,
        parameters: [
          {
            name: 'version',
            summary: `Custom version used to help the plug-in developer determine which version of
     a dictionary is being written. One good way to write version information is to
     use a date style integer (YYYYMMDD)`
          }
        ]
      },
      {
        signature: 'ArchivableDictionary(int version,string name)',
        summary: 'Initializes an instance of a dictionary for writing to a 3dm archive.',
        since: 5,
        parameters: [
          {
            name: 'version',
            summary: `custom version used to help the plug-in developer determine which version of
     a dictionary is being written. One good way to write version information is to
     use a date style integer (YYYYMMDD)`
          },
          {
            name: 'name',
            summary: `Optional name to associate with this dictionary.
     NOTE: if this dictionary is set as a subdictionary, the name will be changed to
     the subdictionary key entry`
          }
        ]
      },
      {
        signature: 'ArchivableDictionary(UserData parentUserData)',
        summary: 'Initializes an instance of a dictionary for writing to a 3dm archive',
        since: 5,
        parameters: [
          {
            name: 'parentUserData',
            summary: 'parent user data if this dictionary is associated with user data'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of key/value pairs contained in the dictionary.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string[] Keys',
        summary: 'Gets all entry names or keys.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string Name',
        summary: 'Gets or sets the name string of this ArchivableDictionary.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'UserData ParentUserData',
        summary: `If this dictionary is part of userdata (or is a UserDictionary), then
     this is the parent user data. None if this dictionary is not part of
     userdata`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'object[] Values',
        summary: 'Gets all values in this dictionary.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Version',
        summary: 'Gets or sets the version of this ArchivableDictionary.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'bool AddContentsFrom(ArchivableDictionary source)',
        summary: 'Add the contents from the source dictionary.',
        since: 5.4
      },
      {
        signature: 'void Clear()',
        summary: 'Removes all keys and values from the dictionary.',
        since: 5
      },
      {
        signature: 'ArchivableDictionary Clone()',
        summary: 'Constructs a deep copy of this object.',
        since: 5,
        returns: 'The copy of this object.'
      },
      {
        signature: 'bool ContainsKey(string key)',
        summary: 'Determines whether the dictionary contains the specified key.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The key to locate.'
          }
        ],
        returns: 'True if the dictionary contains an element with the specified key; otherwise, false.'
      },
      {
        signature: 'bool GetBool(string key)',
        summary: 'Get value as bool, will only succeed if value was created using Set(string key, bool value)',
        since: 5
      },
      {
        signature: 'bool GetBool(string key,bool defaultValue)',
        summary: 'Get value as bool, will return defaultValue unless value was created using Set(string key, bool value)',
        since: 5
      },
      {
        signature: 'byte[] GetBytes(string key)',
        summary: `Get value as byte[], will only succeed if value was created
     using Set(string key, byte[] value)`,
        since: 5.9
      },
      {
        signature: 'byte[] GetBytes(string key,byte[] defaultValue)',
        summary: `Get value as byte[], will return defaultValue unless
     value was created using Set(string key, byte[] value)`,
        since: 5.9
      },
      {
        signature: 'ArchivableDictionary GetDictionary(string key)',
        summary: `Get value as ArchivableDictionary, will only succeed if value was created
     using Set(string key, ArchivableDictionary value)`,
        since: 5.9
      },
      {
        signature: 'ArchivableDictionary GetDictionary(string key,ArchivableDictionary defaultValue)',
        summary: `Get value as ArchivableDictionary, will return defaultValue unless
     value was created using Set(string key, ArchivableDictionary value)`,
        since: 5.9
      },
      {
        signature: 'double GetDouble(string key)',
        summary: 'Get value as double, will only succeed if value was created using Set(string key, double value)',
        since: 5
      },
      {
        signature: 'double GetDouble(string key,double defaultValue)',
        summary: 'Get value as double, will only succeed if value was created using Set(string key, double value)',
        since: 5.1
      },
      {
        signature: 'IEnumerator<KeyValuePair<string, object>> GetEnumerator()',
        summary: 'Gets the enumerator of this dictionary.',
        since: 5,
        returns: 'A IEnumerator{T}, where T is an instance of KeyValuePair{T0,T1}, with T0 set as string, and T1 as Syste.Object.'
      },
      {
        signature: 'T GetEnumValue()',
        summary: 'Get an enum value',
        since: 5.4
      },
      {
        signature: 'T GetEnumValue(string key)',
        summary: 'Get an enum value from the dictionary using a custom key.',
        since: 5.4
      },
      {
        signature: 'float GetFloat(string key)',
        summary: 'Get value as float, will only succeed if value was created using Set(string key, float value)',
        since: 5
      },
      {
        signature: 'float GetFloat(string key,float defaultValue)',
        summary: 'Get value as float, will return defaultValue unless value was created using Set(string key, float value)',
        since: 5
      },
      {
        signature: 'Guid GetGuid(string key)',
        summary: 'Get value as Guid, will only succeed if value was created using Set(string key, Guid value)',
        since: 5
      },
      {
        signature: 'Guid GetGuid(string key,Guid defaultValue)',
        summary: 'Get value as Guid, will return defaultValue unless value was created using Set(string key, Guid value)',
        since: 5
      },
      {
        signature: 'int Getint(string key,int defaultValue)',
        summary: 'Get value as int, will return defaultValue unless value was created using Set(string key, int value)',
        since: 5
      },
      {
        signature: 'int GetInteger(string key)',
        summary: 'Get value as int, will only succeed if value was created using Set(string key, int value)',
        since: 5
      },
      {
        signature: 'int GetInteger(string key,int defaultValue)',
        summary: 'Get value as int, will return defaultValue unless value was created using Set(string key, int value)',
        since: 5
      },
      {
        signature: 'void GetObjectData(SerializationInfo info,StreamingContext context)',
        summary: 'Populates a System.Runtime.Serialization.SerializationInfo with the data needed to serialize the target object.',
        since: 7,
        parameters: [
          {
            name: 'info',
            summary: 'The System.Runtime.Serialization.SerializationInfo to populate with data.'
          },
          {
            name: 'context',
            summary: 'The destination (see System.Runtime.Serialization.StreamingContext) for this serialization.'
          }
        ]
      },
      {
        signature: 'Geometry.Plane GetPlane(string key)',
        summary: 'Get value as Plane, will return defaultValue unless value was created using Set(string key, Plane value)',
        since: 6.11,
        parameters: [
          {
            name: 'key',
            summary: 'The key.'
          }
        ],
        returns: 'The value as Plane.'
      },
      {
        signature: 'Geometry.Plane GetPlane(string key,Plane defaultValue)',
        summary: 'Get value as Plane, will return defaultValue unless value was created using Set(string key, Plane value)',
        since: 6.11,
        parameters: [
          {
            name: 'key',
            summary: 'The key.'
          },
          {
            name: 'defaultValue',
            summary: 'The default value.'
          }
        ],
        returns: 'The value as Plane.'
      },
      {
        signature: 'Geometry.Point3d GetPoint3d(string key)',
        summary: 'Get value as Point3d, will only succeed if value was created using Set(string key, Point3d value)',
        since: 5
      },
      {
        signature: 'Geometry.Point3d GetPoint3d(string key,Point3d defaultValue)',
        summary: 'Get value as Point3d, will return defaultValue unless value was created using Set(string key, Point3d value)',
        since: 5
      },
      {
        signature: 'Geometry.Point3f GetPoint3f(string key)',
        summary: 'Get value as Point3f, will only succeed if value was created using Set(string key, Point3f value)',
        since: 5
      },
      {
        signature: 'Geometry.Point3f GetPoint3f(string key,Point3f defaultValue)',
        summary: 'Get value as Point3f, will return defaultValue unless value was created using Set(string key, Point3f value)',
        since: 5
      },
      {
        signature: 'string GetString(string key)',
        summary: 'Get value as string, will only succeed if value was created using Set(string key, string value)',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The key which points to the string'
          }
        ],
        returns: 'The string'
      },
      {
        signature: 'string GetString(string key,string defaultValue)',
        summary: 'Get value as string, will return defaultValue unless value was created using Set(string key, string value)',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The key which points to the string'
          },
          {
            name: 'defaultValue',
            summary: 'The string'
          }
        ]
      },
      {
        signature: 'Geometry.Vector3d GetVector3d(string key)',
        summary: 'Get value as Vector3d, will only succeed if value was created using Set(string key, Vector3d value)',
        since: 5
      },
      {
        signature: 'Geometry.Vector3d GetVector3d(string key,Vector3d defaultValue)',
        summary: 'Get value as Vector3d, will return defaultValue unless value was created using Set(string key, Vector3d value)',
        since: 5
      },
      {
        signature: 'bool Remove(string key)',
        summary: 'Removes the value with the specified key from the dictionary.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The key of the element to remove.'
          }
        ],
        returns: `True if the element is successfully found and removed; otherwise, false.
     This method returns False if key is not found.`
      },
      {
        signature: 'bool RemoveEnumValue()',
        summary: 'Remmove an enum value from the dictionary.',
        since: 5.4
      },
      {
        signature: 'bool ReplaceContentsWith(ArchivableDictionary source)',
        summary: 'Replace the contents of the dictionary with that of the given source dictionary.',
        since: 5.4
      },
      {
        signature: 'bool Set(string key,ArchivableDictionary val)',
        summary: 'Sets another ArchivableDictionary as entry in this dictionary.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `An object for that key.
     Because this class is a reference type and is mutable, changes to this object will propagate to the object inside the dictionary.It is up to the user to clone this entry when appropriate.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,bool val)',
        summary: 'Sets a bool.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The text key.'
          },
          {
            name: 'val',
            summary: `A bool value.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,BoundingBox val)',
        summary: 'Sets a Rhino.Geometry.BoundingBox.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,byte val)',
        summary: 'Sets a byte.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The text key.'
          },
          {
            name: 'val',
            summary: `A byte.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,Color val)',
        summary: 'Sets a System.Drawing.Color.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the
     assigning value will leave this entry unchanged.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,double val)',
        summary: 'Sets a double.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The text key.'
          },
          {
            name: 'val',
            summary: `A double.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,float val)',
        summary: 'Sets a float.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The text key.'
          },
          {
            name: 'val',
            summary: `A float.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,Font val)',
        summary: 'Sets a System.Drawing.Font.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  is immutable, it is not possible to modify the object while it is in this dictionary.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,GeometryBase val)',
        summary: 'Sets any class deriving from the Rhino.Geometry.GeometryBase base class.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A geometry object for that key.
     Because this class is a reference type and is mutable, changes to this object will propagate to the object inside the dictionary.It is up to the user to clone this entry when appropriate. You can use  for this.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,Guid val)',
        summary: 'Sets a Guid.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The text key.'
          },
          {
            name: 'val',
            summary: `A Guid.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,IEnumerable<bool> val)',
        summary: 'Sets a list, an array or any enumerable of bool.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.It is up to the user to clone this entry when appropriate.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,IEnumerable<byte> val)',
        summary: 'Sets a list, an array or any enumerable of byte.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key
     Because this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.It is up to the user to clone this entry when appropriate.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,IEnumerable<double> val)',
        summary: 'Sets a list, an array or any enumerable of double.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.It is up to the user to clone this entry when appropriate.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,IEnumerable<float> val)',
        summary: 'Sets a list, an array or any enumerable of float.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.It is up to the user to clone this entry when appropriate.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,IEnumerable<GeometryBase> val)',
        since: 7
      },
      {
        signature: 'bool Set(string key,IEnumerable<Guid> val)',
        summary: 'Sets a list, an array or any enumerable of Guid.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.It is up to the user to clone this entry when appropriate.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,IEnumerable<int> val)',
        summary: 'Sets a list, an array or any enumerable of int.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.It is up to the user to clone this entry when appropriate.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,IEnumerable<ObjRef> val)',
        summary: 'Sets an array of Rhino.DocObjects.ObjRef',
        since: 5.8,
        parameters: [
          {
            name: 'key',
            summary: 'A text key'
          },
          {
            name: 'val',
            summary: `An object for that key
     Because this class is a reference type and is mutable, changes to this object will propagate to the object inside the dictionary.It is up to the user to clone this entry when appropriate.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,IEnumerable<sbyte> val)',
        summary: 'Sets a list, an array or any enumerable of sbyte.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.It is up to the user to clone this entry when appropriate.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,IEnumerable<short> val)',
        summary: 'Sets a list, an array or any enumerable of short.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.It is up to the user to clone this entry when appropriate.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,IEnumerable<string> val)',
        summary: 'Sets a list, an array or any enumerable of string.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because this interface is a reference type, changes to the assigned object will modify this entry inside the dictionary.It is up to the user to clone this entry when appropriate.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,int val)',
        summary: 'Sets a int.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The text key.'
          },
          {
            name: 'val',
            summary: `A int.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,Int64 val)',
        summary: 'Sets a long.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The text key.'
          },
          {
            name: 'val',
            summary: `A long.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,Interval val)',
        summary: 'Sets an Rhino.Geometry.Interval.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,Line val)',
        summary: 'Sets a Rhino.Geometry.Line.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,MeshingParameters val)',
        summary: 'Sets a Rhino.Geometry.MeshingParameters.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `An object for that key.
     Because this class is a reference type and is mutable, changes to this object will propagate to the object inside the dictionary.It is up to the user to clone this entry when appropriate.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,ObjRef val)',
        summary: 'Sets a Rhino.DocObjects.ObjRef',
        since: 5.8,
        parameters: [
          {
            name: 'key',
            summary: 'A text key'
          },
          {
            name: 'val',
            summary: `An object for that key
     Because this class is a reference type and is mutable, changes to this object will propagate to the object inside the dictionary.It is up to the user to clone this entry when appropriate.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,Plane val)',
        summary: 'Sets a Rhino.Geometry.Plane.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A plane for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,Point val)',
        summary: 'Sets a System.Drawing.Point.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,Point2d val)',
        summary: 'Sets a Rhino.Geometry.Point2d.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A point for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,Point3d val)',
        summary: 'Sets a Rhino.Geometry.Point3d.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A point for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,Point3f val)',
        summary: 'Sets a Rhino.Geometry.Point3f.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,Point4d val)',
        summary: 'Sets a Rhino.Geometry.Point4d.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,PointF val)',
        summary: 'Sets a System.Drawing.PointF.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,Ray3d val)',
        summary: 'Sets a Rhino.Geometry.Ray3d.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics and is immutable, no changes to this object are possible.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,Rectangle val)',
        summary: 'Sets a System.Drawing.Rectangle.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,RectangleF val)',
        summary: 'Sets a System.Drawing.RectangleF.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,sbyte val)',
        summary: 'Sets a sbyte.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The text key.'
          },
          {
            name: 'val',
            summary: `A sbyte.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,short val)',
        summary: 'Sets a short.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The text key.'
          },
          {
            name: 'val',
            summary: `A short.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,Size val)',
        summary: 'Sets a System.Drawing.Size.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,SizeF val)',
        summary: 'Sets a System.Drawing.SizeF.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,string val)',
        summary: 'Sets a string.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The text key.'
          },
          {
            name: 'val',
            summary: `A string.
     Because  is immutable, it is not possible to modify the object while it is in this dictionary.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,Transform val)',
        summary: 'Sets a Rhino.Geometry.Transform.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A transform for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,uint val)',
        summary: 'Sets a uint.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The text key.'
          },
          {
            name: 'val',
            summary: `A uint.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,ushort val)',
        summary: 'Sets a ushort.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The text key.'
          },
          {
            name: 'val',
            summary: `A ushort.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ],
        returns: 'True if set operation succeeded, otherwise false.'
      },
      {
        signature: 'bool Set(string key,Vector2d val)',
        summary: 'Sets a Rhino.Geometry.Vector2d.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,Vector3d val)',
        summary: 'Sets a Rhino.Geometry.Vector3d.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool Set(string key,Vector3f val)',
        summary: 'Sets a Rhino.Geometry.Vector3f.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'A text key.'
          },
          {
            name: 'val',
            summary: `A value for that key.
     Because  has value semantics, changes to the assigning value will leave this entry unchanged.`
          }
        ]
      },
      {
        signature: 'bool SetEnumValue(string key,T enumValue)',
        summary: 'Set an enum value in the dictionary with a custom key.',
        since: 5.4
      },
      {
        signature: 'bool SetEnumValue(T enumValue)',
        summary: 'Set an enum value',
        since: 5.4
      },
      {
        signature: 'bool TryGetBool(string key,bool value)',
        summary: 'Get value as bool, will only succeed if value was created using Set(string key, bool value)',
        since: 5
      },
      {
        signature: 'bool TryGetBytes(string key,byte[] value)',
        summary: `Get value as byte[], will only succeed if value was
     created using Set(string key, byte[] value)`,
        since: 5.9
      },
      {
        signature: 'bool TryGetDictionary(string key,ArchivableDictionary value)',
        summary: `Get value as ArchivableDictionary, will only succeed if value was
     created using Set(string key, ArchivableDictionary value)`,
        since: 5.9
      },
      {
        signature: 'bool TryGetDouble(string key,double value)',
        summary: 'Get value as double, will only succeed if value was created using Set(string key, double value)',
        since: 5
      },
      {
        signature: 'bool TryGetEnumValue(string key,T enumValue)',
        summary: 'Attempt to get an enum value from the dictionary using a custom key.',
        since: 5.4
      },
      {
        signature: 'bool TryGetFloat(string key,float value)',
        summary: 'Get value as float, will only succeed if value was created using Set(string key, float value)',
        since: 5
      },
      {
        signature: 'bool TryGetGuid(string key,Guid value)',
        summary: 'Get value as Guid, will only succeed if value was created using Set(string key, Guid value)',
        since: 5
      },
      {
        signature: 'bool TryGetInteger(string key,int value)',
        summary: 'Get value as int, will only succeed if value was created using Set(string key, int value)',
        since: 5
      },
      {
        signature: 'bool TryGetPlane(string key,Plane value)',
        summary: 'Get value as Plane, will only succeed if value was created using Set(string key, Plane value)',
        since: 6.11,
        parameters: [
          {
            name: 'key',
            summary: 'The key.'
          },
          {
            name: 'value',
            summary: 'The value.'
          }
        ],
        returns: 'The value as Plane.'
      },
      {
        signature: 'bool TryGetPoint3d(string key,Point3d value)',
        summary: 'Get value as Point3d, will only succeed if value was created using Set(string key, Point3d value)',
        since: 5
      },
      {
        signature: 'bool TryGetPoint3f(string key,Point3f value)',
        summary: 'Get value as Point3f, will only succeed if value was created using Set(string key, Point3f value)',
        since: 5
      },
      {
        signature: 'bool TryGetString(string key,string value)',
        summary: 'Get value as string, will only succeed if value was created using Set(string key, string value)',
        since: 5
      },
      {
        signature: 'bool TryGetValue(string key,object value)',
        summary: 'Gets the value associated with the specified key.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The key of the value to get.'
          },
          {
            name: 'value',
            summary: `When this method returns and if the key is found,
     contains the value associated with the specified key;
     otherwise, null. This parameter is passed uninitialized.`
          }
        ],
        returns: 'True if the dictionary contains an element with the specified key; otherwise, false.'
      },
      {
        signature: 'bool TryGetVector3d(string key,Vector3d value)',
        summary: 'Get value as Vector3d, will only succeed if value was created using Set(string key, Vector3d value)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Collections',
    name: 'CurveList',
    dataType: 1,
    summary: 'Represents a list of curves.',
    baseclass: 'RhinoList<Curve>',
    constructors: [
      {
        signature: 'CurveList()',
        summary: 'Initializes a new empty list of curves.',
        since: 5
      },
      {
        signature: 'CurveList(IEnumerable<Curve> collection)',
        summary: `Initializes a new list that is filled with all items of the input enumerable.
     Input items are not explicitly duplicated (this is a shallow copy).`,
        since: 5,
        parameters: [
          {
            name: 'collection',
            summary: 'A list, an array or any enumerable set of Curve.'
          }
        ]
      },
      {
        signature: 'CurveList(int initialCapacity)',
        summary: `Initializes a new empty list of curves with a predefined capacity.
     This is the amount of items the list will accept before resizing.`,
        since: 5
      }
    ],
    methods: [
      {
        signature: 'void Add(Arc arc)',
        summary: 'Adds an arc to this list.',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'An arc value that will be the model of the new internal curve.'
          }
        ]
      },
      {
        signature: 'void Add(Circle circle)',
        summary: 'Adds a circle to this list.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'A circle value that will be the model of the new internal curve.'
          }
        ]
      },
      {
        signature: 'void Add(Ellipse ellipse)',
        summary: 'Adds an ellipse to this list.',
        since: 5,
        parameters: [
          {
            name: 'ellipse',
            summary: 'An ellipse that will be the model of the new internal curve.'
          }
        ]
      },
      {
        signature: 'void Add(IEnumerable<Point3d> polyline)',
        summary: 'Adds a polyline to this list.',
        since: 5,
        parameters: [
          {
            name: 'polyline',
            summary: `A polyline value that will be copied in a new polyline.
     This argument can be null, an array, a list or any enumerable set of .`
          }
        ]
      },
      {
        signature: 'void Add(Line line)',
        summary: 'Adds a line to this list.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'A line value that will be the model of the new internal curve.'
          }
        ]
      },
      {
        signature: 'void Insert(int index,Arc arc)',
        summary: 'Inserts an arc at a given index of this list.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'A 0-based position in the list.'
          },
          {
            name: 'arc',
            summary: 'The arc value from which to construct the new curve.'
          }
        ]
      },
      {
        signature: 'void Insert(int index,Circle circle)',
        summary: 'Inserts a line at a given index of this list.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'A 0-based position in the list.'
          },
          {
            name: 'circle',
            summary: 'The circle value from which to construct the new curve.'
          }
        ]
      },
      {
        signature: 'void Insert(int index,Ellipse ellipse)',
        summary: 'Inserts an ellipse at a given index of this list.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'A 0-based position in the list.'
          },
          {
            name: 'ellipse',
            summary: 'The ellipse value from which to construct the new curve.'
          }
        ]
      },
      {
        signature: 'void Insert(int index,IEnumerable<Point3d> polyline)',
        summary: 'Inserts a polyline at a given index of this list.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'A 0-based position in the list.'
          },
          {
            name: 'polyline',
            summary: `The polyline enumerable from which to construct a copy curve.
     This argument can be null, an array, a list or any enumerable set of
     .`
          }
        ]
      },
      {
        signature: 'void Insert(int index,Line line)',
        summary: 'Inserts a line at a given index of this list.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'A 0-based position in the list.'
          },
          {
            name: 'line',
            summary: 'The line value from which to construct the new curve.'
          }
        ]
      },
      {
        signature: 'bool Transform(Transform xform)',
        summary: `Transform all the curves in this list. If at least a single transform failed 
     this function returns false.`,
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation to apply to all curves.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Collections',
    name: 'IResizableList',
    dataType: 4,
    summary: 'Provides the ability to resize a generic list by setting the Count property.'
  },
  {
    namespace: 'Rhino.Collections',
    name: 'Point3dList',
    dataType: 1,
    summary: 'Represents a list of Point3d.',
    baseclass: 'RhinoList<Point3d>',
    interfaces: ['ICloneable'],
    constructors: [
      {
        signature: 'Point3dList()',
        summary: 'Initializes a new empty list with default capacity.',
        since: 5
      },
      {
        signature: 'Point3dList(IEnumerable<Point3d> collection)',
        summary: 'Initializes a new point list by copying the values from another set.',
        since: 5,
        parameters: [
          {
            name: 'collection',
            summary: 'The collection to copy from.'
          }
        ]
      },
      {
        signature: 'Point3dList(int initialCapacity)',
        summary: 'Initializes a new point list with a preallocated initial capacity.',
        since: 5,
        parameters: [
          {
            name: 'initialCapacity',
            summary: 'The number of added items before which the underlying array will be resized.'
          }
        ]
      },
      {
        signature: 'Point3dList(Point3d[] initialPoints)',
        summary: 'Constructs a new point list from values in a point array.',
        since: 5,
        parameters: [
          {
            name: 'initialPoints',
            summary: 'Points to add to the list.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'BoundingBox BoundingBox',
        summary: `Even though this is a property, it is not a "fast" calculation. Every point is
     evaluated in order to get the bounding box of the list.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'XAccess X',
        summary: 'Returns an indexer with all X coordinates in this list.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'YAccess Y',
        summary: 'Returns an indexer with all Y coordinates in this list.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ZAccess Z',
        summary: 'Returns an indexer with all Z coordinates in this list.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static int ClosestIndexInList(IList<Point3d> list,Point3d testPoint)',
        summary: 'Finds the index of the point in a list of points that is closest to a test point.',
        since: 5,
        parameters: [
          {
            name: 'list',
            summary: 'A list of points.'
          },
          {
            name: 'testPoint',
            summary: 'Point to compare against.'
          }
        ],
        returns: 'Index of closest point in the list on success or -1 on error.'
      },
      {
        signature: 'static Point3d ClosestPointInList(IList<Point3d> list,Point3d testPoint)',
        summary: 'Finds the point in a list of points that is closest to a test point.',
        since: 5,
        parameters: [
          {
            name: 'list',
            summary: 'A list of points.'
          },
          {
            name: 'testPoint',
            summary: 'Point to compare against.'
          }
        ],
        returns: 'A point.'
      },
      {
        signature: 'void Add(double x,double y,double z)',
        summary: 'Adds a Point3d to the end of the list with given x,y,z coordinates.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'The X coordinate.'
          },
          {
            name: 'y',
            summary: 'The Y coordinate.'
          },
          {
            name: 'z',
            summary: 'The Z coordinate.'
          }
        ]
      },
      {
        signature: 'int ClosestIndex(Point3d testPoint)',
        summary: 'Finds the index of the point that is closest to a test point in this list.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'point to compare against.'
          }
        ],
        returns: 'index of closest point in the list on success. -1 on error.'
      },
      {
        signature: 'Point3dList Duplicate()',
        summary: 'Returns a deep copy of this point list instance.',
        since: 6,
        returns: 'The duplicated list.'
      },
      {
        signature: 'void SetAllX(double xValue)',
        summary: 'Set all the X values for the points to a single value',
        since: 5.6
      },
      {
        signature: 'void SetAllY(double yValue)',
        summary: 'Set all the Y values for the points to a single value',
        since: 5.6
      },
      {
        signature: 'void SetAllZ(double zValue)',
        summary: 'Set all the Z values for the points to a single value',
        since: 5.6
      },
      {
        signature: 'void Transform(Transform xform)',
        summary: 'Applies a transform to all the points in the list.',
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'Transform to apply.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Collections',
    name: 'Point3dList.XAccess',
    dataType: 1,
    summary: 'Utility class for easy-access of x-components of points inside an ON_3dPointList.'
  },
  {
    namespace: 'Rhino.Collections',
    name: 'Point3dList.YAccess',
    dataType: 1,
    summary: 'Utility class for easy-access of x-components of points inside an ON_3dPointList.'
  },
  {
    namespace: 'Rhino.Collections',
    name: 'Point3dList.ZAccess',
    dataType: 1,
    summary: 'Utility class for easy-access of z-components of points inside an ON_3dPointList.'
  },
  {
    namespace: 'Rhino.Collections',
    name: 'RhinoList',
    dataType: 1,
    summary: 'Provides helper methods to work with RhinoList<T> and other collections.',
    interfaces: ['IList<T>', 'IList', 'ICloneable'],
    constructors: [
      {
        signature: 'RhinoList()',
        summary: 'Initializes a new, empty list.'
      },
      {
        signature: 'RhinoList(IEnumerable<T> collection)',
        summary: 'Initializes this list as a shallow duplicate of another list, array or any other enumerable set of T.',
        parameters: [
          {
            name: 'collection',
            summary: 'Collection of items to duplicate.'
          }
        ]
      },
      {
        signature: 'RhinoList(int initialCapacity)',
        summary: 'Initializes an empty list with a certain capacity.',
        parameters: [
          {
            name: 'initialCapacity',
            summary: 'Number of items this list can store without resizing.'
          }
        ]
      },
      {
        signature: 'RhinoList(int amount,T defaultValue)',
        summary: 'Initializes a new list with a specified amount of values.',
        parameters: [
          {
            name: 'amount',
            summary: 'Number of values to add to this list. Must be equal to or larger than zero.'
          },
          {
            name: 'defaultValue',
            summary: `Value to add, for reference types, 
     the same item will be added over and over again.`
          }
        ]
      },
      {
        signature: 'RhinoList(RhinoList<T> list)',
        summary: 'Initializes an new list by shallow duplicating another list.',
        parameters: [
          {
            name: 'list',
            summary: 'List to mimic.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int Capacity',
        summary: 'Gets or sets the total number of elements the internal data structure can hold without resizing.',
        property: ['get', 'set']
      },
      {
        signature: 'int Count',
        summary: 'Gets the number of elements actually contained in the List.',
        property: ['get']
      },
      {
        signature: 'T First',
        summary: 'Gets or sets the first item in the list. This is synonymous to calling List[0].',
        property: ['get', 'set']
      },
      {
        signature: 'T Last',
        summary: 'Gets or sets the last item in the list. This is synonymous to calling List[Count-1].',
        property: ['get', 'set']
      },
      {
        signature: 'int NullCount',
        summary: `Gets the number of None references (Nothing in Visual Basic) in this list. 
     If T is a ValueType, this property always return zero.`,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static IEnumerable<int[]> Point2dKNeighbors(IEnumerable<Point2d> hayPoints,IEnumerable<Point2d> needlePoints,int amount)',
        summary: `Finds a certain amout of points in a list of single-precision 2D points that are the k-closest to a test point.
     This method searches needlePoints by computing all distances from each pointcloud point and keeping a "short list".`,
        since: 6,
        parameters: [
          {
            name: 'hayPoints',
            summary: 'A point cloud to be searched.'
          },
          {
            name: 'needlePoints',
            summary: 'Points to search for.'
          },
          {
            name: 'amount',
            summary: 'The required amount of closest neighbors to find.'
          }
        ],
        returns: 'An enumerable of arrays of indices; each array contains the indices for each of the needlePts.'
      },
      {
        signature: 'static IEnumerable<int[]> Point2fKNeighbors(IEnumerable<Point2f> hayPoints,IEnumerable<Point2f> needlePoints,int amount)',
        summary: `Finds a certain amout of points in a list of single-precision 2D points that are the k-closest to a test point.
     This method searches needlePoints by computing all distances from each pointcloud point and keeping a "short list".`,
        since: 6,
        parameters: [
          {
            name: 'hayPoints',
            summary: 'A point cloud to be searched.'
          },
          {
            name: 'needlePoints',
            summary: 'Points to search for.'
          },
          {
            name: 'amount',
            summary: 'The required amount of closest neighbors to find.'
          }
        ],
        returns: 'An enumerable of arrays of indices; each array contains the indices for each of the needlePts.'
      },
      {
        signature: 'static IEnumerable<int[]> Point3dKNeighbors(IEnumerable<Point3d> hayPoints,IEnumerable<Point3d> needlePoints,int amount)',
        summary: `Finds a certain amout of points in a list of 3D points that are the k-closest to a test point.
     This method searches needlePoints by computing all distances from each pointcloud point and keeping a "short list".
     See RTree KNeighbors for alternatives.`,
        since: 6,
        parameters: [
          {
            name: 'hayPoints',
            summary: 'A point cloud to be searched.'
          },
          {
            name: 'needlePoints',
            summary: 'Points to search for.'
          },
          {
            name: 'amount',
            summary: 'The required amount of closest neighbors to find.'
          }
        ],
        returns: 'An enumerable of arrays of indices; each array contains the indices for each of the needlePts.'
      },
      {
        signature: 'static IEnumerable<int[]> Point3fKNeighbors(IEnumerable<Point3f> hayPoints,IEnumerable<Point3f> needlePoints,int amount)',
        summary: `Finds a certain amout of points in a list of single-precision 3D points that are the k-closest to a test point.
     This method searches needlePoints by computing all distances from each pointcloud point and keeping a "short list".`,
        since: 6,
        parameters: [
          {
            name: 'hayPoints',
            summary: 'A point cloud to be searched.'
          },
          {
            name: 'needlePoints',
            summary: 'Points to search for.'
          },
          {
            name: 'amount',
            summary: 'The required amount of closest neighbors to find.'
          }
        ],
        returns: 'An enumerable of arrays of indices; each array contains the indices for each of the needlePts.'
      },
      {
        signature: 'static IEnumerable<int[]> PointCloudKNeighbors(PointCloud pointcloud,IEnumerable<Point3d> needlePoints,int amount)',
        summary: `Finds a certain amout of points in a list of 3D points that are the k-closest to a test point.
     This method searches needlePoints by computing all distances from each pointcloud point and keeping a short list.`,
        since: 6,
        parameters: [
          {
            name: 'pointcloud',
            summary: 'A point cloud to be searched.'
          },
          {
            name: 'needlePoints',
            summary: 'Points to search for.'
          },
          {
            name: 'amount',
            summary: 'The required amount of closest neighbors to find.'
          }
        ],
        returns: 'An enumerable of arrays of indices; each array contains the indices for each of the needlePts.'
      },
      {
        signature: 'void Add(T item)',
        summary: 'Adds an object to the end of the List.',
        parameters: [
          {
            name: 'item',
            summary: 'Item to append.'
          }
        ]
      },
      {
        signature: 'void AddRange(IEnumerable collection)',
        summary: 'Adds the elements of the specified collection to the end of the List.',
        parameters: [
          {
            name: 'collection',
            summary: `The collection whose elements should be added to the end of the List. 
     The collection itself cannot be a None reference (Nothing in Visual Basic), 
     but it can contain elements that are a None reference (Nothing in Visual Basic). 
     Objects in collection which cannot be represented as T will throw exceptions.`
          }
        ]
      },
      {
        signature: 'void AddRange(IEnumerable<T> collection)',
        summary: 'Adds the elements of the specified collection to the end of the List.',
        parameters: [
          {
            name: 'collection',
            summary: `The collection whose elements should be added to the end of the List. 
     The collection itself cannot be a None reference (Nothing in Visual Basic), 
     but it can contain elements that are a None reference (Nothing in Visual Basic), 
     if type T is a reference type.`
          }
        ]
      },
      {
        signature: 'ReadOnlyCollection<T> AsReadOnly()',
        summary: 'Constructs a read-only wrapper of this class.',
        returns: 'A wrapper.'
      },
      {
        signature: 'int BinarySearch(int index,int count,T item,IComparer<T> comparer)',
        summary: `Searches the entire sorted List for an element using the specified 
     comparer and returns the zero-based index of the element.`,
        parameters: [
          {
            name: 'index',
            summary: 'The zero-based starting index of the range to search.'
          },
          {
            name: 'count',
            summary: 'The length of the range to search.'
          },
          {
            name: 'item',
            summary: `The object to locate. The value can be a None reference 
     (Nothing in Visual Basic) for reference types.`
          },
          {
            name: 'comparer',
            summary: `The IComparer(T) implementation to use when comparing elements.
     Or a None reference (Nothing in Visual Basic) to use the default comparer 
     Comparer(T)::Default.`
          }
        ],
        returns: `The zero-based index of item in the sorted List, if item is found; 
     otherwise, a negative number that is the bitwise complement of the index 
     of the next element that is larger than item or, if there is no larger element, 
     the bitwise complement of Count.`
      },
      {
        signature: 'int BinarySearch(T item)',
        summary: `Searches the entire sorted List for an element using the default comparer 
     and returns the zero-based index of the element.`,
        parameters: [
          {
            name: 'item',
            summary: `The object to locate. The value can be a None reference 
     (Nothing in Visual Basic) for reference types.`
          }
        ],
        returns: `The zero-based index of item in the sorted List, if item is found; 
     otherwise, a negative number that is the bitwise complement of the index 
     of the next element that is larger than item or, if there is no larger element, 
     the bitwise complement of Count.`
      },
      {
        signature: 'int BinarySearch(T item,IComparer<T> comparer)',
        summary: `Searches the entire sorted List for an element using the specified 
     comparer and returns the zero-based index of the element.`,
        parameters: [
          {
            name: 'item',
            summary: `The object to locate. The value can be a None reference 
     (Nothing in Visual Basic) for reference types.`
          },
          {
            name: 'comparer',
            summary: `The IComparer(T) implementation to use when comparing elements.
     Or a None reference (Nothing in Visual Basic) to use the default comparer 
     Comparer(T)::Default.`
          }
        ],
        returns: `The zero-based index of item in the sorted List, if item is found; 
     otherwise, a negative number that is the bitwise complement of the index 
     of the next element that is larger than item or, if there is no larger element, 
     the bitwise complement of Count.`
      },
      {
        signature: 'void Clear()',
        summary: 'Removes all elements from the List.'
      },
      {
        signature: 'bool Contains(T item)',
        summary: 'Determines whether an element is in the List.',
        parameters: [
          {
            name: 'item',
            summary: `The object to locate in the List. 
     The value can be a None reference (Nothing in Visual Basic) for reference types.`
          }
        ],
        returns: 'True if item is found in the List; otherwise, false.'
      },
      {
        signature: 'RhinoList<TOutput> ConvertAll(Converter<T, TOutput> converter)',
        summary: 'Aggregates all results of a conversion function over this table into a new list.',
        parameters: [
          {
            name: 'converter',
            summary: 'A conversion function that can transform from T to TOutput.'
          }
        ],
        returns: 'The new list.'
      },
      {
        signature: 'void CopyTo(int index,T[] array,int arrayIndex,int count)',
        summary: `Copies a range of elements from the List to a compatible one-dimensional array, 
     starting at the specified index of the target array.`,
        parameters: [
          {
            name: 'index',
            summary: 'The zero-based index in the source List at which copying begins.'
          },
          {
            name: 'array',
            summary: `The one-dimensional Array that is the destination of the elements 
     copied from List. The Array must have zero-based indexing.`
          },
          {
            name: 'arrayIndex',
            summary: 'The zero-based index in array at which copying begins.'
          },
          {
            name: 'count',
            summary: 'The number of elements to copy.'
          }
        ]
      },
      {
        signature: 'void CopyTo(T[] array)',
        summary: `Copies the entire List to a compatible one-dimensional array, 
     starting at the beginning of the target array.`,
        parameters: [
          {
            name: 'array',
            summary: `The one-dimensional Array that is the destination 
     of the elements copied from List. The Array must have zero-based indexing.`
          }
        ]
      },
      {
        signature: 'void CopyTo(T[] array,int arrayIndex)',
        summary: `Copies the entire List to a compatible one-dimensional array, 
     starting at the specified index of the target array.`,
        parameters: [
          {
            name: 'array',
            summary: `The one-dimensional Array that is the destination 
     of the elements copied from List. The Array must have zero-based indexing.`
          },
          {
            name: 'arrayIndex',
            summary: 'The zero-based index in array at which copying begins.'
          }
        ]
      },
      {
        signature: 'RhinoList<T> Duplicate()',
        summary: `Returns a shallow copy of this instance.
     If the generic type is comprised of only value types (struct, enum, ptr), then the result will be a deep copy.`,
        returns: 'The duplicated list.'
      },
      {
        signature: 'bool Exists(Predicate<T> match)',
        summary: `Determines whether the List contains elements that match the 
     conditions defined by the specified predicate.`,
        parameters: [
          {
            name: 'match',
            summary: 'The Predicate(T) delegate that defines the conditions of the elements to search for.'
          }
        ],
        returns: `True if the List contains one or more elements that match the 
     conditions defined by the specified predicate; otherwise, false.`
      },
      {
        signature: 'T Find(Predicate<T> match)',
        summary: `Searches for an element that matches the conditions defined by the 
     specified predicate, and returns the first occurrence within the entire List.`,
        parameters: [
          {
            name: 'match',
            summary: 'The Predicate(T) delegate that defines the conditions of the element to search for.'
          }
        ],
        returns: `The first element that matches the conditions defined by the specified predicate, 
     if found; otherwise, the default value for type T.`
      },
      {
        signature: 'RhinoList<T> FindAll(Predicate<T> match)',
        summary: 'Retrieves all the elements that match the conditions defined by the specified predicate.',
        parameters: [
          {
            name: 'match',
            summary: 'The Predicate(T) delegate that defines the conditions of the elements to search for.'
          }
        ],
        returns: `A ON_List(T) containing all the elements that match the conditions 
     defined by the specified predicate, if found; otherwise, an empty ON_List(T).`
      },
      {
        signature: 'int FindIndex(int startIndex,int count,Predicate<T> match)',
        summary: `Searches for an element that matches the conditions defined by the specified predicate, 
     and returns the zero-based index of the first occurrence within the range of elements 
     in the List that extends from the specified index to the last element.`,
        parameters: [
          {
            name: 'startIndex',
            summary: 'The zero-based starting index of the search.'
          },
          {
            name: 'count',
            summary: 'The number of elements in the section to search.'
          },
          {
            name: 'match',
            summary: 'The Predicate(T) delegate that defines the conditions of the element to search for.'
          }
        ],
        returns: `The zero-based index of the first occurrence of an element that 
     matches the conditions defined by match, if found; otherwise, -1.`
      },
      {
        signature: 'int FindIndex(int startIndex,Predicate<T> match)',
        summary: `Searches for an element that matches the conditions defined by the 
     specified predicate, and returns the zero-based index of the first 
     occurrence within the entire List.`,
        parameters: [
          {
            name: 'startIndex',
            summary: 'The zero-based starting index of the search.'
          },
          {
            name: 'match',
            summary: 'The Predicate(T) delegate that defines the conditions of the element to search for.'
          }
        ],
        returns: `The zero-based index of the first occurrence of an element that 
     matches the conditions defined by match, if found; otherwise, -1.`
      },
      {
        signature: 'int FindIndex(Predicate<T> match)',
        summary: `Searches for an element that matches the conditions defined by the 
     specified predicate, and returns the zero-based index of the first 
     occurrence within the entire List.`,
        parameters: [
          {
            name: 'match',
            summary: 'The Predicate(T) delegate that defines the conditions of the element to search for.'
          }
        ],
        returns: `The zero-based index of the first occurrence of an element that 
     matches the conditions defined by match, if found; otherwise, -1.`
      },
      {
        signature: 'T FindLast(Predicate<T> match)',
        summary: `Searches for an element that matches the conditions defined by the 
     specified predicate, and returns the last occurrence within the entire List.`,
        parameters: [
          {
            name: 'match',
            summary: 'The Predicate(T) delegate that defines the conditions of the element to search for.'
          }
        ],
        returns: `The last element that matches the conditions defined by the specified predicate, 
     if found; otherwise, the default value for type T.`
      },
      {
        signature: 'int FindLastIndex(int startIndex,int count,Predicate<T> match)',
        summary: `Searches for an element that matches the conditions defined by the 
     specified predicate, and returns the zero-based index of the last 
     occurrence within the entire List.`,
        parameters: [
          {
            name: 'startIndex',
            summary: 'The zero-based starting index of the backward search.'
          },
          {
            name: 'count',
            summary: 'The number of elements in the section to search.'
          },
          {
            name: 'match',
            summary: 'The Predicate(T) delegate that defines the conditions of the element to search for.'
          }
        ],
        returns: `The zero-based index of the last occurrence of an element that matches 
     the conditions defined by match, if found; otherwise, -1.`
      },
      {
        signature: 'int FindLastIndex(int startIndex,Predicate<T> match)',
        summary: `Searches for an element that matches the conditions defined by the 
     specified predicate, and returns the zero-based index of the last 
     occurrence within the entire List.`,
        parameters: [
          {
            name: 'startIndex',
            summary: 'The zero-based starting index of the backward search.'
          },
          {
            name: 'match',
            summary: 'The Predicate(T) delegate that defines the conditions of the element to search for.'
          }
        ],
        returns: `The zero-based index of the last occurrence of an element that matches 
     the conditions defined by match, if found; otherwise, -1.`
      },
      {
        signature: 'int FindLastIndex(Predicate<T> match)',
        summary: `Searches for an element that matches the conditions defined by the 
     specified predicate, and returns the zero-based index of the last 
     occurrence within the entire List.`,
        parameters: [
          {
            name: 'match',
            summary: 'The Predicate(T) delegate that defines the conditions of the element to search for.'
          }
        ],
        returns: `The zero-based index of the last occurrence of an element that matches 
     the conditions defined by match, if found; otherwise, -1.`
      },
      {
        signature: 'void ForEach(Action<T> action)',
        summary: 'Performs the specified action on each element of the List.',
        parameters: [
          {
            name: 'action',
            summary: 'The Action(T) delegate to perform on each element of the List.'
          }
        ]
      },
      {
        signature: 'IEnumerator<T> GetEnumerator()',
        summary: 'Constructs an enumerator that is capable of iterating over all items in this list.',
        returns: 'The new enumerator.'
      },
      {
        signature: 'RhinoList<T> GetRange(int index,int count)',
        summary: 'Constructs a shallow copy of a range of elements in the source List.',
        parameters: [
          {
            name: 'index',
            summary: 'The zero-based List index at which the range starts.'
          },
          {
            name: 'count',
            summary: 'The number of elements in the range.'
          }
        ],
        returns: 'A shallow copy of a range of elements in the source List.'
      },
      {
        signature: 'int IndexOf(T item)',
        summary: `Searches for the specified object and returns the zero-based index of the 
     first occurrence within the entire List.`,
        parameters: [
          {
            name: 'item',
            summary: `The object to locate in the List. 
     The value can be a None reference (Nothing in Visual Basic) 
     for reference types.`
          }
        ],
        returns: `The zero-based index of the first occurrence of item within 
     the entire List, if found; otherwise, -1.`
      },
      {
        signature: 'int IndexOf(T item,int index)',
        summary: `Searches for the specified object and returns the zero-based index of 
     the first occurrence within the range of elements in the List that 
     extends from the specified index to the last element.`,
        parameters: [
          {
            name: 'item',
            summary: `The object to locate in the List. 
     The value can be a None reference (Nothing in Visual Basic) 
     for reference types.`
          },
          {
            name: 'index',
            summary: 'The zero-based starting index of the search.'
          }
        ],
        returns: `The zero-based index of the first occurrence of item within 
     the entire List, if found; otherwise, -1.`
      },
      {
        signature: 'int IndexOf(T item,int index,int count)',
        summary: `Searches for the specified object and returns the zero-based index of the first 
     occurrence within the range of elements in the List that starts at the specified 
     index and contains the specified number of elements.`,
        parameters: [
          {
            name: 'item',
            summary: `The object to locate in the List. 
     The value can be a None reference (Nothing in Visual Basic) 
     for reference types.`
          },
          {
            name: 'index',
            summary: 'The zero-based starting index of the search.'
          },
          {
            name: 'count',
            summary: 'The number of elements in the section to search.'
          }
        ],
        returns: `The zero-based index of the first occurrence of item within 
     the entire List, if found; otherwise, -1.`
      },
      {
        signature: 'void Insert(int index,T item)',
        summary: 'Inserts an element into the List at the specified index.',
        parameters: [
          {
            name: 'index',
            summary: 'The zero-based index at which item should be inserted.'
          },
          {
            name: 'item',
            summary: `The object to insert. The value can be a None reference 
     (Nothing in Visual Basic) for reference types.`
          }
        ]
      },
      {
        signature: 'void InsertRange(int index,IEnumerable<T> collection)',
        summary: 'Inserts the elements of a collection into the List at the specified index.',
        parameters: [
          {
            name: 'index',
            summary: 'The zero-based index at which the new elements should be inserted.'
          },
          {
            name: 'collection',
            summary: `The collection whose elements should be inserted into the List. 
     The collection itself cannot be a None reference (Nothing in Visual Basic), 
     but it can contain elements that are a None reference (Nothing in Visual Basic), 
     if type T is a reference type.`
          }
        ]
      },
      {
        signature: 'int LastIndexOf(T item)',
        summary: `Searches for the specified object and returns the zero-based 
     index of the last occurrence within the entire List.`,
        parameters: [
          {
            name: 'item',
            summary: `The object to locate in the List. 
     The value can be a None reference (Nothing in Visual Basic) for reference types.`
          }
        ],
        returns: `The zero-based index of the last occurrence of item within 
     the entire the List, if found; otherwise, -1.`
      },
      {
        signature: 'int LastIndexOf(T item,int index)',
        summary: `Searches for the specified object and returns the zero-based index 
     of the last occurrence within the range of elements in the List 
     that extends from the first element to the specified index.`,
        parameters: [
          {
            name: 'item',
            summary: `The object to locate in the List. 
     The value can be a None reference (Nothing in Visual Basic) for reference types.`
          },
          {
            name: 'index',
            summary: 'The zero-based starting index of the backward search.'
          }
        ],
        returns: `The zero-based index of the last occurrence of item within 
     the entire the List, if found; otherwise, -1.`
      },
      {
        signature: 'int LastIndexOf(T item,int index,int count)',
        summary: `Searches for the specified object and returns the zero-based index of the 
     last occurrence within the range of elements in the List that contains 
     the specified number of elements and ends at the specified index.`,
        parameters: [
          {
            name: 'item',
            summary: `The object to locate in the List. 
     The value can be a None reference (Nothing in Visual Basic) for reference types.`
          },
          {
            name: 'index',
            summary: 'The zero-based starting index of the backward search.'
          },
          {
            name: 'count',
            summary: 'The number of elements in the section to search.'
          }
        ],
        returns: `The zero-based index of the last occurrence of item within 
     the entire the List, if found; otherwise, -1.`
      },
      {
        signature: 'int RemapIndex(int index)',
        summary: 'Remap an index in the infinite range onto the List index range.',
        parameters: [
          {
            name: 'index',
            summary: 'Index to remap.'
          }
        ],
        returns: 'Remapped index.'
      },
      {
        signature: 'bool Remove(T item)',
        summary: 'Removes the first occurrence of a specific object from the List.',
        parameters: [
          {
            name: 'item',
            summary: `The object to remove from the List. 
     The value can be a None reference (Nothing in Visual Basic) for reference types.`
          }
        ],
        returns: `True if item is successfully removed; otherwise, false. 
     This method also returns False if item was not found in the List.`
      },
      {
        signature: 'int RemoveAll(Predicate<T> match)',
        summary: 'Removes the all the elements that match the conditions defined by the specified predicate.',
        parameters: [
          {
            name: 'match',
            summary: 'The Predicate(T) delegate that defines the conditions of the elements to remove.'
          }
        ],
        returns: 'The number of elements removed from the List.'
      },
      {
        signature: 'void RemoveAt(int index)',
        summary: 'Removes the element at the specified index of the List.',
        parameters: [
          {
            name: 'index',
            summary: 'The zero-based index of the element to remove.'
          }
        ]
      },
      {
        signature: 'int RemoveNulls()',
        summary: `Removes all elements from the List that are None references (Nothing in Visual Basic). 
     This function will not do anything if T is not a Reference type.`,
        returns: 'The number of nulls removed from the List.'
      },
      {
        signature: 'void RemoveRange(int index,int count)',
        summary: 'Removes a range of elements from the List.',
        parameters: [
          {
            name: 'index',
            summary: 'The zero-based starting index of the range of elements to remove.'
          },
          {
            name: 'count',
            summary: 'The number of elements to remove.'
          }
        ]
      },
      {
        signature: 'void Reverse()',
        summary: 'Reverses the order of the elements in the entire List.'
      },
      {
        signature: 'void Reverse(int index,int count)',
        summary: 'Reverses the order of the elements in the specified range.',
        parameters: [
          {
            name: 'index',
            summary: 'The zero-based starting index of the range to reverse.'
          },
          {
            name: 'count',
            summary: 'The number of elements in the range to reverse.'
          }
        ]
      },
      {
        signature: 'void Sort()',
        summary: 'Sorts the elements in the entire List using the default comparer.'
      },
      {
        signature: 'void Sort(Comparison<T> comparison)',
        summary: 'Sorts the elements in the entire list using the specified comparer.',
        parameters: [
          {
            name: 'comparison',
            summary: 'The System.Comparison(T) to use when comparing elements.'
          }
        ]
      },
      {
        signature: 'void Sort(double[] keys)',
        summary: `Sort this list based on a list of numeric keys of equal length. 
     The keys array will not be altered.`,
        parameters: [
          {
            name: 'keys',
            summary: 'Numeric keys to sort with.'
          }
        ]
      },
      {
        signature: 'void Sort(IComparer<T> comparer)',
        summary: 'Sorts the elements in the entire list using the specified System.Comparison(T)',
        parameters: [
          {
            name: 'comparer',
            summary: `The IComparer(T) implementation to use when comparing elements, 
     or a None reference (Nothing in Visual Basic) to use the default comparer Comparer(T).Default.`
          }
        ]
      },
      {
        signature: 'void Sort(int index,int count,IComparer<T> comparer)',
        summary: 'Sorts the elements in a range of elements in list using the specified comparer.',
        parameters: [
          {
            name: 'index',
            summary: 'The zero-based starting index of the range to sort.'
          },
          {
            name: 'count',
            summary: 'The length of the range to sort.'
          },
          {
            name: 'comparer',
            summary: `The IComparer(T) implementation to use when comparing 
     elements, or a None reference (Nothing in Visual Basic) to use the default 
     comparer Comparer(T).Default.`
          }
        ]
      },
      {
        signature: 'void Sort(int[] keys)',
        summary: `Sort this list based on a list of numeric keys of equal length. 
     The keys array will not be altered.`,
        parameters: [
          {
            name: 'keys',
            summary: 'Numeric keys to sort with.'
          }
        ]
      },
      {
        signature: 'T[] ToArray()',
        summary: 'Constructs an array that contains all items in this list.',
        returns: 'An array containing all items in this list.'
      },
      {
        signature: 'void TrimExcess()',
        summary: `Sets the capacity to the actual number of elements in the List, 
     if that number is less than a threshold value.`
      },
      {
        signature: 'bool TrueForAll(Predicate<T> match)',
        summary: 'Determines whether every element in the List matches the conditions defined by the specified predicate.',
        parameters: [
          {
            name: 'match',
            summary: 'The Predicate(T) delegate that defines the conditions to check against the elements.'
          }
        ],
        returns: `True if every element in the List matches the conditions defined by 
     the specified predicate; otherwise, false. If the list has no elements, the return value is true.`
      }
    ]
  },
  {
    namespace: 'Rhino.Collections',
    name: 'TransformObjectList',
    dataType: 1,
    summary: 'Used by the TransformCommand and GetTransform classes.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'TransformObjectList()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Number of elements in this list',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'bool DisplayFeedbackEnabled',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int GripCount',
        summary: 'Number of elements in grip list',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int GripOwnerCount',
        summary: 'Number of elements in grip owner list',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(ObjRef objref)',
        summary: 'Add an ObjRef to this list. Use this to add Polyedges so the references are properly counted',
        since: 5.1
      },
      {
        signature: 'void Add(RhinoObject rhinoObject)',
        summary: 'Add a RhinoObject to this list',
        since: 5.1
      },
      {
        signature: 'int AddObjects(GetObject go,bool allowGrips)',
        summary: 'Add objects to list with a GetObject',
        since: 6,
        parameters: [
          {
            name: 'go',
            summary: `Setup the GetObject, ie. prompt, geometry filter, allow pre/post select 
     before passing it as an argument.`
          },
          {
            name: 'allowGrips',
            summary: `Specifically allow grips to be selected.  if true, grips must also be included in geometry filter
     of the GetObject in order to be selected.`
          }
        ],
        returns: 'Number of objects selected.'
      },
      {
        signature: 'void Clear()',
        summary: 'Remove all elements from this list',
        since: 5.1
      },
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'BoundingBox GetBoundingBox(bool regularObjects,bool grips)',
        summary: 'Gets the bounding box of all of the objects that this list contains.',
        since: 5,
        parameters: [
          {
            name: 'regularObjects',
            summary: 'True if any object except grips should be included; otherwise false.'
          },
          {
            name: 'grips',
            summary: 'True if grips should be included; otherwise false.'
          }
        ],
        returns: 'Unset BoundingBox if this list is empty.'
      },
      {
        signature: 'GripObject[] GripArray()',
        summary: 'Gets access to the GripObject array of the TransformObjectList object.',
        since: 6,
        returns: 'An array of GripObjects, empty if there were no GripObjects'
      },
      {
        signature: 'RhinoObject[] GripOwnerArray()',
        summary: 'Gets access to the  GripOwner array of the TransformObjectList object.',
        since: 6,
        returns: 'An array of GripOwner, empty if there were no GripOwners.'
      },
      {
        signature: 'bool UpdateDisplayFeedbackTransform(Transform xform)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Commands',
    name: 'Command',
    dataType: 1,
    summary: 'Defines a base class for all commands. This class is abstract.',
    properties: [
      {
        signature: 'static Guid LastCommandId',
        summary: 'Gets the ID of the last commands.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Result LastCommandResult',
        summary: 'Gets the result code of the last command.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string EnglishName',
        summary: `Gets the name of the command.
     This method is abstract.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid Id',
        summary: `Gets the  unique ID of this command. It is best to use a Guid
     attribute for each custom derived command class since this will
     keep the id consistent between sessions of Rhino
     System.Runtime.InteropServices.GuidAttribute`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'string LocalName',
        summary: 'Gets the local name of the command.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'PlugIn PlugIn',
        summary: 'Gets the plug-in where this commands is placed.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'PersistentSettings Settings',
        summary: 'Gets the settings of the command.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static void DisplayHelp(Guid commandId)',
        summary: 'Displays help for a command.',
        since: 5,
        parameters: [
          {
            name: 'commandId',
            summary: 'A command ID.'
          }
        ]
      },
      {
        signature: 'static string[] GetCommandNames(bool english,bool loaded)',
        summary: 'Gets list of command names in Rhino. This list does not include Test, Alpha, or System commands.',
        since: 5,
        parameters: [
          {
            name: 'english',
            summary: `if true, retrieve the english name for every command.
      if false, retrieve the local name for every command.`
          },
          {
            name: 'loaded',
            summary: `if true, only get names of currently loaded commands.
     if false, get names of all registered (may not be currently loaded) commands.`
          }
        ],
        returns: 'An array instance with command names. This array could be empty, but not null.'
      },
      {
        signature: 'static Guid[] GetCommandStack()',
        summary: `Determines if Rhino is currently running a command. Because Rhino allow for transparent commands
     (commands that can be run from inside of other commands), this method returns the total ids of
     active commands.`,
        since: 5,
        returns: `Ids of running commands or None if no commands are currently running. 
     The "active" command is at the end of this list.`
      },
      {
        signature: 'static MostRecentCommandDescription[] GetMostRecentCommands()',
        summary: 'Gets an array of most recent command descriptions.',
        since: 5,
        returns: 'An array of command descriptions.'
      },
      {
        signature: 'static bool InCommand()',
        summary: 'Determines if Rhino is currently running a command.',
        since: 5,
        returns: 'True if a command is currently running, False if no commands are currently running.'
      },
      {
        signature: 'static bool InScriptRunnerCommand()',
        summary: `This is a low level tool to determine if Rhino is currently running
     a script running command like "ReadCommandFile" or the RhinoScript
     plug-in's "RunScript".`,
        since: 5,
        returns: 'True if a script running command is active.'
      },
      {
        signature: 'static bool IsCommand(string name)',
        summary: 'Determines is a string is a command.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'A string.'
          }
        ],
        returns: 'True if the string is a command.'
      },
      {
        signature: 'static bool IsValidCommandName(string name)',
        summary: 'Determines if a string is a valid command name.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'A string.'
          }
        ],
        returns: 'True if the string is a valid command name.'
      },
      {
        signature: 'static Guid LookupCommandId(string name,bool searchForEnglishName)',
        summary: 'Returns the ID of a command.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the command.'
          },
          {
            name: 'searchForEnglishName',
            summary: 'True if the name is to searched in English. This ensures that a \'_\' is prepended to the name.'
          }
        ],
        returns: 'An of the command, or Guid.Empty on error.'
      },
      {
        signature: 'static string LookupCommandName(Guid commandId,bool englishName)',
        summary: 'Returns the command name given a command ID.',
        since: 5,
        parameters: [
          {
            name: 'commandId',
            summary: 'A command ID.'
          },
          {
            name: 'englishName',
            summary: 'True if the requested command is in English.'
          }
        ],
        returns: 'The command name, or None on error.'
      },
      {
        signature: 'static void RunProxyCommand(RunCommandDelegate commandCallback,RhinoDoc doc,object data)',
        summary: 'Execute some code as if it were running in a command',
        since: 6.13,
        parameters: [
          {
            name: 'commandCallback',
            summary: ''
          },
          {
            name: 'doc',
            summary: ''
          },
          {
            name: 'data',
            summary: 'optional extra data to pass to callback'
          }
        ]
      }
    ],
    events: [
      {
        signature: 'static BeginCommand',
        summary: 'Called just before command.RunCommand().',
        since: 5
      },
      {
        signature: 'static EndCommand',
        summary: 'Called immediately after command.RunCommand().',
        since: 5
      },
      {
        signature: 'static UndoRedo',
        summary: 'Used to monitor Rhino\'s built in undo/redo support.',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Commands',
    name: 'CommandEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'string CommandEnglishName',
        summary: 'Gets the English name of the command that raised this event.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid CommandId',
        summary: 'Gets the ID of the command that raised this event.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string CommandLocalName',
        summary: 'Gets the name of the command that raised this event in the local language.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string CommandPluginName',
        summary: `Gets the name of the plug-in that this command belongs to.  If the command is internal
     to Rhino, then this propert is an empty string.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Result CommandResult',
        summary: `Gets the result of the command that raised this event. 
     This value is only meaningful during EndCommand events.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint DocumentRuntimeSerialNumber',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Commands',
    name: 'CommandStyleAttribute',
    dataType: 1,
    summary: 'Decorates Command to provide styles.',
    baseclass: 'Attribute',
    constructors: [
      {
        signature: 'CommandStyleAttribute(Style styles)',
        summary: 'Initializes a new command style attribute class.',
        since: 5,
        parameters: [
          {
            name: 'styles',
            summary: `Set of values combined using a bitwise OR operation to get the desired combination
     of command styles.`
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'Style Styles',
        summary: 'Gets the associated style.',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Commands',
    name: 'CustomUndoEventArgs',
    dataType: 1,
    summary: 'Argument package that is passed to a custom undo delegate',
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'string ActionDescription',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid CommandId',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool CreatedByRedo',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        since: 5,
        property: ['get']
      },
      {
        signature: 'object Tag',
        since: 5,
        property: ['get']
      },
      {
        signature: 'uint UndoSerialNumber',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Commands',
    name: 'MostRecentCommandDescription',
    dataType: 1,
    summary: 'Stores the macro and display string of the most recent command.',
    properties: [
      {
        signature: 'string DisplayString',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Macro',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Commands',
    name: 'Result',
    dataType: 3,
    summary: 'Defines enumerated constant values for several command result types.',
    values: [
      {
        signature: 'Success = 0',
        summary: 'Command worked.'
      },
      {
        signature: 'Cancel  = 1',
        summary: 'User canceled command.'
      },
      {
        signature: 'Nothing = 2',
        summary: 'Command did nothing but cancel was not pressed.'
      },
      {
        signature: 'Failure',
        summary: 'Command failed (bad input, computational problem, etc.)'
      },
      {
        signature: 'UnknownCommand',
        summary: 'Command not found (user probably had a typo in command name).'
      },
      {
        signature: 'CancelModelessDialog',
        summary: 'Commands canceled and modeless dialog.'
      },
      {
        signature: 'ExitRhino = 0x0FFFFFFF',
        summary: 'exit RhinoCommon.'
      }
    ]
  },
  {
    namespace: 'Rhino.Commands',
    name: 'RunMode',
    dataType: 3,
    summary: 'Provides enumerated constants for a command running mode. This is currently interactive or scripted.',
    values: [
      {
        signature: 'Interactive = 0',
        summary: `Can use dialogs for input. Must use message boxes to
     report serious error conditions.`
      },
      {
        signature: 'Scripted = 1',
        summary: `All input must come from command line, GetPoint, GetObject,
     GetString, etc.  Must use message boxes to report serious
     error conditions.  Script mode gets used when a command is
     run with a hyphen (-) prefix.`
      }
    ]
  },
  {
    namespace: 'Rhino.Commands',
    name: 'SelCommand',
    dataType: 1,
    summary: `For adding nestable selection commands that work like the native Rhino
   SelCrv command, derive your command from SelCommand and override the
   virtual SelFilter function.`,
    baseclass: 'Rhino.Commands.Command',
    properties: [
      {
        signature: 'bool BeQuiet',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool TestGrips',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool TestLights',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Commands',
    name: 'Style',
    dataType: 3,
    summary: `Defines bitwise mask flags for different styles of commands, such as
   Style.Hidden or Style.DoNotRepeat.`,
    values: [
      {
        signature: 'None = 0',
        summary: 'No flag is defined.'
      },
      {
        signature: 'Hidden = 1',
        summary: `Also known as a "test" command. The command name does not auto-complete
     when typed on the command line an is therefore not discoverable. Useful
     for writing commands that users don't normally have access to.`
      },
      {
        signature: 'ScriptRunner = 2',
        summary: `For commands that want to run scripts as if they were typed at the command
     line (like RhinoScript's RunScript command)`
      },
      {
        signature: 'Transparent = 4',
        summary: `Transparent commands can be run inside of other commands.
     The command does not modify the contents of the model's geometry in any way.
     Examples of transparent commands include commands that change views and toggle
     snap states.  Any command that adds or deletes, a view cannot be transparent.`
      },
      {
        signature: 'DoNotRepeat = 8',
        summary: `The command should not be repeated by pressing "ENTER" immediately after
     the command finishes.`
      },
      {
        signature: 'NotUndoable = 16',
        summary: 'By default, all commands are undoable.'
      }
    ]
  },
  {
    namespace: 'Rhino.Commands',
    name: 'TransformCommand',
    dataType: 1,
    baseclass: 'Rhino.Commands.Command'
  },
  {
    namespace: 'Rhino.Commands',
    name: 'UndoRedoEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'Guid CommandId',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsBeginRecording',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsBeginRedo',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsBeginUndo',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsEndRecording',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsEndRedo',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsEndUndo',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsPurgeRecord',
        since: 5,
        property: ['get']
      },
      {
        signature: 'uint UndoSerialNumber',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'BackgroundStyle',
    dataType: 3,
    summary: 'Constants that define how the background of a viewport should be filled.',
    values: [
      {
        signature: 'SolidColor = 0',
        summary: 'Single solid color fill.'
      },
      {
        signature: 'WallpaperImage = 1',
        summary: 'Simple image background wallpaper.'
      },
      {
        signature: 'Gradient = 2',
        summary: 'Two color top/bottom color gradient.'
      },
      {
        signature: 'Environment = 3',
        summary: 'Using a special environment.'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'BlendMode',
    dataType: 3,
    summary: 'Defines enmerated constants for display blend modes.',
    values: [
      {
        signature: 'Zero = 0',
        summary: 'Blends using 0.'
      },
      {
        signature: 'One = 1',
        summary: 'Blends using 1.'
      },
      {
        signature: 'SourceColor = 0x0300',
        summary: 'Blends using source color.'
      },
      {
        signature: 'OneMinusSourceColor = 0x0301',
        summary: 'Blends using 1-source color.'
      },
      {
        signature: 'SourceAlpha = 0x0302',
        summary: 'Blends using the source alpha channel.'
      },
      {
        signature: 'OneMinusSourceAlpha = 0x0303',
        summary: 'Blends using 1-the source alpha channel.'
      },
      {
        signature: 'DestinationAlpha = 0x0304',
        summary: 'Blends using the destination alpha channel.'
      },
      {
        signature: 'OneMinusDestinationAlpha = 0x0305',
        summary: 'Blends using 1-the destination alpha channel.'
      },
      {
        signature: 'DestinationColor = 0x0306',
        summary: 'Blends using the destination color.'
      },
      {
        signature: 'OneMinusDestinationColor = 0x0307',
        summary: 'Blends using 1-the destination color.'
      },
      {
        signature: 'SourceAlphaSaturate = 0x0308',
        summary: 'Blends using the source alpha saturation.'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'CalculateBoundingBoxEventArgs',
    dataType: 1,
    baseclass: 'Rhino.Display.DrawEventArgs',
    properties: [
      {
        signature: 'BoundingBox BoundingBox',
        summary: 'Gets the current bounding box.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void IncludeBoundingBox(BoundingBox box)',
        summary: `Unites a bounding box with the current display bounding box in order to ensure
     dynamic objects in "box" are drawn.`,
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'The box to unite.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'Color4f',
    dataType: 2,
    summary: 'Color defined by 4 floating point values.',
    constructors: [
      {
        signature: 'Color4f(Color color)',
        since: 5
      },
      {
        signature: 'Color4f(Color4f color)',
        since: 5
      },
      {
        signature: 'Color4f(float red,float green,float blue,float alpha)',
        since: 5
      },
      {
        signature: 'Color4f(int argb)',
        since: 7
      }
    ],
    properties: [
      {
        signature: 'static Color4f Black',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Color4f Empty',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Color4f White',
        since: 5,
        property: ['get']
      },
      {
        signature: 'float A',
        since: 5,
        property: ['get']
      },
      {
        signature: 'float B',
        since: 5,
        property: ['get']
      },
      {
        signature: 'float G',
        since: 5,
        property: ['get']
      },
      {
        signature: 'float L',
        since: 6.3,
        property: ['get']
      },
      {
        signature: 'float R',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Color4f ApplyGamma(Color4f col,float gamma)',
        since: 6
      },
      {
        signature: 'static Color4f FromArgb(float a,Color4f color)',
        since: 5.11
      },
      {
        signature: 'static Color4f FromArgb(float a,float r,float g,float b)',
        since: 5.11
      },
      {
        signature: 'System.Drawing.Color AsSystemColor()',
        since: 5
      },
      {
        signature: 'Color4f BlendTo(float t,Color4f col)',
        since: 5
      },
      {
        signature: 'bool Equals(object obj)'
      },
      {
        signature: 'int GetHashCode()'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ColorCMYK',
    dataType: 2,
    summary: `Represents a CMYK (Cyan, Magenta, Yellow, Key) color with double precision floating point channels. 
   CMYK colors are used primarily in printing environments as they provide a good simulation of physical ink.`,
    constructors: [
      {
        signature: 'ColorCMYK(Color rgb)',
        summary: 'Initializes a new instance of ColorCMYK that is equivalent to an RGB color.',
        since: 5,
        parameters: [
          {
            name: 'rgb',
            summary: 'RGB color to mimic.'
          }
        ]
      },
      {
        signature: 'ColorCMYK(double cyan,double magenta,double yellow)',
        summary: `Initializes a new instance of ColorCMYK with custom channel values. 
     The cyan, magenta and yellow values will be adjusted based on their 
     combined darkness.`,
        since: 5,
        parameters: [
          {
            name: 'cyan',
            summary: 'Cyan channel hint.'
          },
          {
            name: 'magenta',
            summary: 'Magenta channel hint.'
          },
          {
            name: 'yellow',
            summary: 'Yellow channel hint.'
          }
        ]
      },
      {
        signature: 'ColorCMYK(double cyan,double magenta,double yellow,double key)',
        summary: 'Initializes a new instance of ColorCMYK with custom channel values.',
        since: 5,
        parameters: [
          {
            name: 'cyan',
            summary: 'Cyan channel value. Cyan channels are limited to the 0.0 and 1.0 range.'
          },
          {
            name: 'magenta',
            summary: 'Magenta channel value. Magenta channels are limited to the 0.0 and 1.0 range.'
          },
          {
            name: 'yellow',
            summary: 'Yellow channel value. Yellow channels are limited to the 0.0 and 1.0 range.'
          },
          {
            name: 'key',
            summary: 'Key channel value. Key channels are limited to the 0.0 and 1.0 range.'
          }
        ]
      },
      {
        signature: 'ColorCMYK(double alpha,double cyan,double magenta,double yellow,double key)',
        summary: 'Initializes a new instance of ColorCMYK with custom channel values.',
        since: 5,
        parameters: [
          {
            name: 'alpha',
            summary: 'Alpha channel value. Alpha channels are limited to the 0.0 and 1.0 range.'
          },
          {
            name: 'cyan',
            summary: 'Cyan channel value. Cyan channels are limited to the 0.0 and 1.0 range.'
          },
          {
            name: 'magenta',
            summary: 'Magenta channel value. Magenta channels are limited to the 0.0 and 1.0 range.'
          },
          {
            name: 'yellow',
            summary: 'Yellow channel value. Yellow channels are limited to the 0.0 and 1.0 range.'
          },
          {
            name: 'key',
            summary: 'Key channel value. Key channels are limited to the 0.0 and 1.0 range.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'double A',
        summary: `Gets or sets the Alpha channel value. 
     Alpha channels are limited to the 0~1 range.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double C',
        summary: `Gets or sets the Cyan channel value. 
     Cyan channels are limited to the 0~1 range.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double K',
        summary: `Gets or sets the Key channel value. 
     Key channels are limited to the 0~1 range.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M',
        summary: `Gets or sets the Magenta channel value. 
     Magenta channels are limited to the 0~1 range.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Y',
        summary: `Gets or sets the Yellow channel value. 
     Yellow channels are limited to the 0~1 range.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static ColorCMYK CreateFromHSL(ColorHSL hsl)',
        summary: 'Constructs the nearest CMYK equivalent of an HSL color.',
        since: 5,
        parameters: [
          {
            name: 'hsl',
            summary: 'Target color in HSL space.'
          }
        ],
        returns: 'The CMYK equivalent of the HSL color.'
      },
      {
        signature: 'static ColorCMYK CreateFromHSV(ColorHSV hsv)',
        summary: 'Constructs the nearest CMYK equivalent of an HSV color.',
        since: 6,
        parameters: [
          {
            name: 'hsv',
            summary: 'Target color in HSV space.'
          }
        ],
        returns: 'The CMYK equivalent of the HSV color.'
      },
      {
        signature: 'static ColorCMYK CreateFromLAB(ColorLAB lab)',
        summary: 'Constructs the nearest CMYK equivalent of a LAB color.',
        since: 5,
        parameters: [
          {
            name: 'lab',
            summary: 'Target color in LAB space.'
          }
        ],
        returns: 'The CMYK equivalent of the LAB color.'
      },
      {
        signature: 'static ColorCMYK CreateFromLCH(ColorLCH lch)',
        summary: 'Constructs the nearest CMYK equivalent of a LCH color.',
        since: 5,
        parameters: [
          {
            name: 'lch',
            summary: 'Target color in LCH space.'
          }
        ],
        returns: 'The CMYK equivalent of the LCH color.'
      },
      {
        signature: 'static ColorCMYK CreateFromXYZ(ColorXYZ xyz)',
        summary: 'Constructs the nearest CMYK equivalent of an XYZ color.',
        since: 5,
        parameters: [
          {
            name: 'xyz',
            summary: 'Target color in XYZ space.'
          }
        ],
        returns: 'The CMYK equivalent of the XYZ color.'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ColorGradient',
    dataType: 1,
    properties: [
      {
        signature: 'Point3d EndPoint',
        summary: 'End point of gradient',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'GradientType GradientType',
        summary: 'Gradient fill type associated with this hatch',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double Repeat',
        summary: `Repeat factor for gradient. Factors greater than 1 define a reflected
     repeat factor while values less than -1 define a wrapped repeat factor.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d StartPoint',
        summary: 'Start point of gradient',
        since: 7,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'ColorStop[] GetColorStops()',
        summary: 'Get sorted list of colors / positions that a gradient is defined over',
        since: 7
      },
      {
        signature: 'void SetColorStops(IEnumerable<ColorStop> stops)',
        summary: 'Set color stops for the gradient',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ColorHSL',
    dataType: 2,
    summary: `Represents an HSL (Hue, Saturation, Luminance) color with double precision floating point channels. 
   HSL colors are used primarily in Graphical User Interface environments as they provide a 
   very natural approach to picking colors.`,
    constructors: [
      {
        signature: 'ColorHSL(Color rgb)',
        summary: 'Constructs a new instance of ColorHSL that is equivalent to an RGB color.',
        since: 5,
        parameters: [
          {
            name: 'rgb',
            summary: 'RGB color to mimic.'
          }
        ]
      },
      {
        signature: 'ColorHSL(double hue,double saturation,double luminance)',
        summary: 'Constructs a new instance of ColorHSL with custom channel values.',
        since: 5,
        parameters: [
          {
            name: 'hue',
            summary: 'Hue channel value. Hue channels rotate between 0.0 and 1.0.'
          },
          {
            name: 'saturation',
            summary: 'Saturation channel value. Channel will be limited to 0~1.'
          },
          {
            name: 'luminance',
            summary: 'Luminance channel value. Channel will be limited to 0~1.'
          }
        ]
      },
      {
        signature: 'ColorHSL(double alpha,double hue,double saturation,double luminance)',
        summary: 'Constructs a new instance of ColorHSL with custom channel values.',
        since: 5,
        parameters: [
          {
            name: 'alpha',
            summary: 'Alpha channel value. Channel will be limited to 0~1.'
          },
          {
            name: 'hue',
            summary: 'Hue channel value. Hue channels rotate between 0.0 and 1.0.'
          },
          {
            name: 'saturation',
            summary: 'Saturation channel value. Channel will be limited to 0~1.'
          },
          {
            name: 'luminance',
            summary: 'Luminance channel value. Channel will be limited to 0~1.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'double A',
        summary: `Gets or sets the alpha channel value. 
     Alpha channels are limited to a 0~1 range.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double H',
        summary: `Gets or sets the hue channel value. 
     Hue channels rotate between 0.0 and 1.0.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double L',
        summary: `Gets or sets the luminance channel value. 
     Luminance channels are limited to a 0~1 range.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double S',
        summary: `Gets or sets the saturation channel value. 
     Saturation channels are limited to a 0~1 range.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static ColorHSL CreateFromCMYK(ColorCMYK cmyk)',
        summary: 'Create the nearest HSL equivalent of a CMYK color.',
        since: 5,
        parameters: [
          {
            name: 'cmyk',
            summary: 'Target color in CMYK space.'
          }
        ],
        returns: 'The HSL equivalent of the CMYK color.'
      },
      {
        signature: 'static ColorHSL CreateFromHSV(ColorHSV hsv)',
        summary: 'Constructs the nearest HSL equivalent of an HSV color.',
        since: 6,
        parameters: [
          {
            name: 'hsv',
            summary: 'Target color in HSV space.'
          }
        ],
        returns: 'The HSL equivalent of the HSV color.'
      },
      {
        signature: 'static ColorHSL CreateFromLAB(ColorLAB lab)',
        summary: 'Create the nearest HSL equivalent of a LAB color.',
        since: 5,
        parameters: [
          {
            name: 'lab',
            summary: 'Target color in LAB space.'
          }
        ],
        returns: 'The HSL equivalent of the LAB color.'
      },
      {
        signature: 'static ColorHSL CreateFromLCH(ColorLCH lch)',
        summary: 'Create the nearest HSL equivalent of a LCH color.',
        since: 5,
        parameters: [
          {
            name: 'lch',
            summary: 'Target color in LCH space.'
          }
        ],
        returns: 'The HSL equivalent of the LCH color.'
      },
      {
        signature: 'static ColorHSL CreateFromXYZ(ColorXYZ xyz)',
        summary: 'Create the nearest HSL equivalent of an XYZ color.',
        since: 5,
        parameters: [
          {
            name: 'xyz',
            summary: 'Target color in XYZ space.'
          }
        ],
        returns: 'The HSL equivalent of the XYZ color.'
      },
      {
        signature: 'System.Drawing.Color ToArgbColor()',
        summary: 'Convert HSL color to an equivalent System.Drawing.Color.',
        since: 5,
        returns: 'A .Net framework library color value.'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ColorHSV',
    dataType: 2,
    summary: `Represents an HSV (Hue, Saturation, Value) color with double precision floating point channels. 
   HSV colors (also sometimes called HSB, where B means Brightness) are similar to HSL colors in that they
   represent colors in a cylindrical color space, and are intended to provide intuitive means to edit the 
   brightness of a particular color over RGB color space where each each color channel would need to be 
   modified to affect the color brightness.`,
    constructors: [
      {
        signature: 'ColorHSV(Color rgb)',
        summary: 'Constructs a new instance of ColorHSV that is equivalent to an RGB color.',
        since: 6,
        parameters: [
          {
            name: 'rgb',
            summary: 'RGB color to mimic.'
          }
        ]
      },
      {
        signature: 'ColorHSV(double hue,double saturation,double value)',
        summary: 'Constructs a new instance of ColorHSV with custom channel values.',
        since: 6,
        parameters: [
          {
            name: 'hue',
            summary: 'Hue channel value. Hue channels rotate between 0.0 and 1.0.'
          },
          {
            name: 'saturation',
            summary: 'Saturation channel value. Channel will be limited to 0~1.'
          },
          {
            name: 'value',
            summary: 'Value (Brightness) channel value. Channel will be limited to 0~1.'
          }
        ]
      },
      {
        signature: 'ColorHSV(double alpha,double hue,double saturation,double value)',
        summary: 'Constructs a new instance of ColorHSV with custom channel values.',
        since: 6,
        parameters: [
          {
            name: 'alpha',
            summary: 'Alpha channel value. Channel will be limited to 0~1.'
          },
          {
            name: 'hue',
            summary: 'Hue channel value. Hue channels rotate between 0.0 and 1.0.'
          },
          {
            name: 'saturation',
            summary: 'Saturation channel value. Channel will be limited to 0~1.'
          },
          {
            name: 'value',
            summary: 'Value (Brightness) channel value. Channel will be limited to 0~1.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'double A',
        summary: `Gets or sets the alpha channel value. 
     Alpha channels are limited to a 0~1 range.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double H',
        summary: `Gets or sets the hue channel value. 
     Hue channels rotate between 0.0 and 1.0.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double S',
        summary: `Gets or sets the saturation channel value. 
     Saturation channels are limited to a 0~1 range.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double V',
        summary: `Gets or sets the value (brightness) channel value. 
     Value channels are limited to a 0~1 range.`,
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static ColorHSV CreateFromCMYK(ColorCMYK cmyk)',
        summary: 'Create the nearest HSV equivalent of a CMYK color.',
        since: 6,
        parameters: [
          {
            name: 'cmyk',
            summary: 'Target color in CMYK space.'
          }
        ],
        returns: 'The HSV equivalent of the CMYK color.'
      },
      {
        signature: 'static ColorHSV CreateFromHSL(ColorHSL hsl)',
        summary: 'Constructs the nearest CMYK equivalent of an HSV color.',
        since: 6,
        parameters: [
          {
            name: 'hsl',
            summary: 'Target color in HSL space.'
          }
        ],
        returns: 'The HSV equivalent of the HSL color.'
      },
      {
        signature: 'static ColorHSV CreateFromLAB(ColorLAB lab)',
        summary: 'Create the nearest HSV equivalent of a LAB color.',
        since: 6,
        parameters: [
          {
            name: 'lab',
            summary: 'Target color in LAB space.'
          }
        ],
        returns: 'The HSV equivalent of the LAB color.'
      },
      {
        signature: 'static ColorHSV CreateFromLCH(ColorLCH lch)',
        summary: 'Create the nearest HSV equivalent of a LCH color.',
        since: 6,
        parameters: [
          {
            name: 'lch',
            summary: 'Target color in LCH space.'
          }
        ],
        returns: 'The HSV equivalent of the LCH color.'
      },
      {
        signature: 'static ColorHSV CreateFromXYZ(ColorXYZ xyz)',
        summary: 'Create the nearest HSV equivalent of an XYZ color.',
        since: 6,
        parameters: [
          {
            name: 'xyz',
            summary: 'Target color in XYZ space.'
          }
        ],
        returns: 'The HSV equivalent of the XYZ color.'
      },
      {
        signature: 'System.Drawing.Color ToArgbColor()',
        summary: 'Convert HSV color to an equivalent System.Drawing.Color.',
        since: 6,
        returns: 'A .Net framework library color value.'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ColorLAB',
    dataType: 2,
    summary: `Represents a LAB (Lightness, A, B) color with double precision floating point channels. 
   LAB colors are based on nonlinearly compressed CIE XYZ color space coordinates.  
   The A and B parameters of a LAB color represent the opponents.`,
    constructors: [
      {
        signature: 'ColorLAB(Color rgb)',
        summary: 'Constructs a new instance of ColorLAB that is equivalent to an RGB color.',
        since: 5,
        parameters: [
          {
            name: 'rgb',
            summary: 'RGB color to mimic.'
          }
        ]
      },
      {
        signature: 'ColorLAB(double lightness,double a,double b)',
        summary: 'Constructs a new instance of ColorLAB with custom channel values.',
        since: 5
      },
      {
        signature: 'ColorLAB(double alpha,double lightness,double a,double b)',
        summary: 'Constructs a new instance of ColorLAB with custom channel values.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'double A',
        summary: 'Gets or sets the Base channel. The channel is limited to 0~1.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Alpha',
        summary: 'Gets or sets the Alpha channel. The channel is limited to 0~1.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double B',
        summary: 'Gets or sets the Opponent channel. The channel is limited to 0~1.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double L',
        summary: 'Gets or sets the lightness channel. The channel is limited to 0~1.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static ColorLAB CreateFromCMYK(ColorCMYK cmyk)',
        summary: 'Create the nearest LAB equivalent of a CMYK color.',
        since: 5,
        parameters: [
          {
            name: 'cmyk',
            summary: 'Target color in CMYK space.'
          }
        ],
        returns: 'The LAB equivalent of the CMYK color.'
      },
      {
        signature: 'static ColorLAB CreateFromHSL(ColorHSL hsl)',
        summary: 'Create the nearest LAB equivalent of an HSL color.',
        since: 5,
        parameters: [
          {
            name: 'hsl',
            summary: 'Target color in HSL space.'
          }
        ],
        returns: 'The LAB equivalent of the HSL color.'
      },
      {
        signature: 'static ColorLAB CreateFromHSV(ColorHSV hsv)',
        summary: 'Constructs the nearest LAB equivalent of an HSV color.',
        since: 6,
        parameters: [
          {
            name: 'hsv',
            summary: 'Target color in HSV space.'
          }
        ],
        returns: 'The LAB equivalent of the HSV color.'
      },
      {
        signature: 'static ColorLAB CreateFromLCH(ColorLCH lch)',
        summary: 'Create the nearest LAB equivalent of an LCH color.',
        since: 5,
        parameters: [
          {
            name: 'lch',
            summary: 'Target color in LCH space.'
          }
        ],
        returns: 'The LAB equivalent of the LCH color.'
      },
      {
        signature: 'static ColorLAB CreateFromXYZ(ColorXYZ xyz)',
        summary: 'Create the nearest LAB equivalent of an XYZ color.',
        since: 5,
        parameters: [
          {
            name: 'xyz',
            summary: 'Target color in XYZ space.'
          }
        ],
        returns: 'The LAB equivalent of the XYZ color.'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ColorLCH',
    dataType: 2,
    summary: `Represents an LCH (Lightness, A, B) color with double precision floating point channels. 
   LCH colors (also sometimes called CIELUV) are transformation of the 1931 CIE XYZ color space, 
   in order to approach perceptual uniformity. They are primarily used in computer graphics which 
   deal with colored lights.`,
    constructors: [
      {
        signature: 'ColorLCH(Color rgb)',
        summary: 'Constructs a new instance of ColorLCH that is equivalent to an RGB color.',
        since: 5,
        parameters: [
          {
            name: 'rgb',
            summary: 'RGB color to mimic.'
          }
        ]
      },
      {
        signature: 'ColorLCH(double lightness,double chroma,double hue)',
        summary: 'Constructs a new instance of ColorLCH with custom channel values.',
        since: 5,
        parameters: [
          {
            name: 'lightness',
            summary: 'Value of lightness channel. This channel is limited to 0~1.'
          },
          {
            name: 'chroma',
            summary: 'Value of chroma channel. This channel is limited to -1~1.'
          },
          {
            name: 'hue',
            summary: 'Value of chroma channel. This channel is limited to 0~360.'
          }
        ]
      },
      {
        signature: 'ColorLCH(double alpha,double lightness,double chroma,double hue)',
        summary: 'Constructs a new instance of ColorLCH with custom channel values.',
        since: 5,
        parameters: [
          {
            name: 'alpha',
            summary: 'Value of Alpha channel. This channel is limited to 0~1.'
          },
          {
            name: 'lightness',
            summary: 'Value of Lightness channel. This channel is limited to 0~1.'
          },
          {
            name: 'chroma',
            summary: 'Value of Chroma channel. This channel is limited to -1~1.'
          },
          {
            name: 'hue',
            summary: 'Value of Hue channel. This channel is limited to 0~360.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'double A',
        summary: 'Gets or sets the Alpha channel. The Alpha channel is limited to the 0~1 range.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double C',
        summary: 'Gets or sets the Chroma channel. Chroma is defined from -1.0 to +1.0.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double H',
        summary: 'Gets or sets the Hue channel. The hue channel is limited to the 0~360 degree range.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double L',
        summary: 'Gets or sets the Lightness channel.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static ColorLCH CreateFromCMYK(ColorCMYK cmyk)',
        summary: 'Create the nearest LCH equivalent of a CMYK color.',
        since: 5,
        parameters: [
          {
            name: 'cmyk',
            summary: 'Target color in CMYK space.'
          }
        ],
        returns: 'The LCH equivalent of the CMYK color.'
      },
      {
        signature: 'static ColorLCH CreateFromHSL(ColorHSL hsl)',
        summary: 'Create the nearest LCH equivalent of an HSL color.',
        since: 5,
        parameters: [
          {
            name: 'hsl',
            summary: 'Target color in HSL space.'
          }
        ],
        returns: 'The LCH equivalent of the HSL color.'
      },
      {
        signature: 'static ColorLCH CreateFromLAB(ColorLAB lab)',
        summary: 'Create the nearest LCH equivalent of a LAB color.',
        since: 5,
        parameters: [
          {
            name: 'lab',
            summary: 'Target color in LAB space.'
          }
        ],
        returns: 'The LCH equivalent of the LAB color.'
      },
      {
        signature: 'static ColorLCH CreateFromXYZ(ColorXYZ xyz)',
        summary: 'Create the nearest LCH equivalent of an XYZ color.',
        since: 5,
        parameters: [
          {
            name: 'xyz',
            summary: 'Target color in XYZ space.'
          }
        ],
        returns: 'The LCH equivalent of the XYZ color.'
      },
      {
        signature: 'void MakePositive()',
        summary: 'Ensure the Chromaticity of this color is positive.',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ColorStop',
    dataType: 2,
    summary: 'Combination of a color and position. Used in defining gradient fills',
    constructors: [
      {
        signature: 'ColorStop(Color color,double t)',
        summary: 'Create color stop from a color and position',
        since: 7
      }
    ],
    properties: [
      {
        signature: 'Color Color',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double Position',
        summary: 'Parameter that Color is defined at',
        since: 7,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ColorXYZ',
    dataType: 2,
    summary: `Represents an XYZ (Hue, Saturation, Luminance) color with double precision floating point channels. 
   XYZ colors are based on the CIE 1931 XYZ color space standard and they mimic the natural 
   sensitivity of cones in the human retina.`,
    constructors: [
      {
        signature: 'ColorXYZ(Color rgb)',
        summary: 'Constructs a new instance of ColorXYZ that is equivalent to an RGB color.',
        since: 5,
        parameters: [
          {
            name: 'rgb',
            summary: 'RGB color to mimic.'
          }
        ]
      },
      {
        signature: 'ColorXYZ(double x,double y,double z)',
        summary: 'Constructs a new instance of ColorXYZ with custom channel values.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X channel value, channel will be limited to 0~1.'
          },
          {
            name: 'y',
            summary: 'Y channel value, channel will be limited to 0~1.'
          },
          {
            name: 'z',
            summary: 'Z channel value, channel will be limited to 0~1.'
          }
        ]
      },
      {
        signature: 'ColorXYZ(double alpha,double x,double y,double z)',
        summary: 'Constructs a new instance of ColorXYZ with custom channel values.',
        since: 5,
        parameters: [
          {
            name: 'alpha',
            summary: 'Alpha channel value, channel will be limited to 0~1.'
          },
          {
            name: 'x',
            summary: 'X channel value, channel will be limited to 0~1.'
          },
          {
            name: 'y',
            summary: 'Y channel value, channel will be limited to 0~1.'
          },
          {
            name: 'z',
            summary: 'Z channel value, channel will be limited to 0~1.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'double A',
        summary: 'Gets or set the Alpha channel value. Channel will be limited to 0~1.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double X',
        summary: 'Gets or set the X channel value. Channel will be limited to 0~1.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Y',
        summary: 'Gets or set the Y channel value. Channel will be limited to 0~1.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Z',
        summary: 'Gets or set the Z channel value. Channel will be limited to 0~1.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static ColorXYZ CreateFromCMYK(ColorCMYK cmyk)',
        summary: 'Create the nearest XYZ equivalent of a CMYK color.',
        since: 5,
        parameters: [
          {
            name: 'cmyk',
            summary: 'Target color in CMYK space.'
          }
        ],
        returns: 'The XYZ equivalent of the CMYK color.'
      },
      {
        signature: 'static ColorXYZ CreateFromHSL(ColorHSL hsl)',
        summary: 'Create the nearest XYZ equivalent of an HSL color.',
        since: 5,
        parameters: [
          {
            name: 'hsl',
            summary: 'Target color in HSL space.'
          }
        ],
        returns: 'The XYZ equivalent of the HSL color.'
      },
      {
        signature: 'static ColorXYZ CreateFromHSV(ColorHSV hsv)',
        summary: 'Constructs the nearest XYZ equivalent of an HSV color.',
        since: 6,
        parameters: [
          {
            name: 'hsv',
            summary: 'Target color in HSV space.'
          }
        ],
        returns: 'The XYZ equivalent of the HSV color.'
      },
      {
        signature: 'static ColorXYZ CreateFromLAB(ColorLAB lab)',
        summary: 'Create the nearest XYZ equivalent of a Lab color.',
        since: 5,
        parameters: [
          {
            name: 'lab',
            summary: 'Target color in LAB space.'
          }
        ],
        returns: 'The XYZ equivalent of the LAB color.'
      },
      {
        signature: 'static ColorXYZ CreateFromLCH(ColorLCH lch)',
        summary: 'Create the nearest XYZ equivalent of an LCH color.',
        since: 5,
        parameters: [
          {
            name: 'lch',
            summary: 'Target color in LCH space.'
          }
        ],
        returns: 'The XYZ equivalent of the LCH color.'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'CullFaceMode',
    dataType: 3,
    values: [
      {
        signature: 'DrawFrontAndBack = 0'
      },
      {
        signature: 'DrawFrontFaces = 1'
      },
      {
        signature: 'DrawBackFaces = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'CullObjectEventArgs',
    dataType: 1,
    baseclass: 'Rhino.Display.DrawEventArgs',
    properties: [
      {
        signature: 'bool CullObject',
        since: 5.3,
        property: ['get', 'set']
      },
      {
        signature: 'RhinoObject RhinoObject',
        since: 5.3,
        property: ['get']
      },
      {
        signature: 'uint RhinoObjectSerialNumber',
        summary: 'Gets the rhino object runtime serial number.',
        since: 6.14,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'CustomDisplay',
    dataType: 1,
    summary: 'Provides some basic (indeed, very basic) mechanisms for drawing custom geometry in viewports.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'CustomDisplay(bool enable)',
        summary: `Constructs a new CustomDisplay instance. You must call
     Dispose() when you are done with this instance, otherwise
     the display methods will never be switched off.`,
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'If true, the display will be enabled immediately.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'BoundingBox ClippingBox',
        summary: 'Gets the clipping box of this CustomDisplay.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool Enabled',
        summary: `Gets or sets the Enabled state of this CustomDisplay instance. 
     If you wish to terminate this CustomDisplay, place a call to Dispose() instead.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsDisposed',
        summary: `Gets a value indicating whether this CustomDisplay instance has been disposed. 
     Once a CustomDisplay has been disposed, you can no longer use it.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void AddArc(Arc arc)',
        summary: 'Adds a new, black arc to the display list.',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'Arc to add.'
          }
        ]
      },
      {
        signature: 'void AddArc(Arc arc,Color color)',
        summary: 'Adds a new, colored arc to the display list.',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'Arc to add.'
          },
          {
            name: 'color',
            summary: 'Color of arc.'
          }
        ]
      },
      {
        signature: 'void AddArc(Arc arc,Color color,int thickness)',
        summary: 'Adds a new, colored arc to the display list.',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'Arc to add.'
          },
          {
            name: 'color',
            summary: 'Color of arc.'
          },
          {
            name: 'thickness',
            summary: 'Thickness of arc.'
          }
        ]
      },
      {
        signature: 'void AddCircle(Circle circle)',
        summary: 'Adds a new, black circle to the display list.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'Circle to add.'
          }
        ]
      },
      {
        signature: 'void AddCircle(Circle circle,Color color)',
        summary: 'Adds a new, colored arc to the display list.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'Circle to add.'
          },
          {
            name: 'color',
            summary: 'Color of circle.'
          }
        ]
      },
      {
        signature: 'void AddCircle(Circle circle,Color color,int thickness)',
        summary: 'Adds a new, colored circle to the display list.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'Circle to add.'
          },
          {
            name: 'color',
            summary: 'Color of circle.'
          },
          {
            name: 'thickness',
            summary: 'Thickness of circle.'
          }
        ]
      },
      {
        signature: 'void AddCurve(Curve curve)',
        summary: `Adds a new, black curve to the display list. 
     The curve will be duplicated so changes to the 
     original will not affect the display.`,
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve to add.'
          }
        ]
      },
      {
        signature: 'void AddCurve(Curve curve,Color color)',
        summary: `Adds a new, colored curve to the display list.
     The curve will be duplicated so changes to the 
     original will not affect the display.`,
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve to add.'
          },
          {
            name: 'color',
            summary: 'Color of curve.'
          }
        ]
      },
      {
        signature: 'void AddCurve(Curve curve,Color color,int thickness)',
        summary: `Adds a new, colored curve to the display list.
     The curve will be duplicated so changes to the 
     original will not affect the display.`,
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve to add.'
          },
          {
            name: 'color',
            summary: 'Color of curve.'
          },
          {
            name: 'thickness',
            summary: 'Thickness of curve.'
          }
        ]
      },
      {
        signature: 'void AddLine(Line line)',
        summary: 'Adds a new, black line to the display list.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line to add.'
          }
        ]
      },
      {
        signature: 'void AddLine(Line line,Color color)',
        summary: 'Adds a new, colored line to the display list.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line to add.'
          },
          {
            name: 'color',
            summary: 'Color of line.'
          }
        ]
      },
      {
        signature: 'void AddLine(Line line,Color color,int thickness)',
        summary: 'Adds a new, colored line to the display list.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line to add.'
          },
          {
            name: 'color',
            summary: 'Color of line.'
          },
          {
            name: 'thickness',
            summary: 'Thickness of line.'
          }
        ]
      },
      {
        signature: 'void AddPoint(Point3d point)',
        summary: 'Adds a new, black point to the display list.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to add.'
          }
        ]
      },
      {
        signature: 'void AddPoint(Point3d point,Color color)',
        summary: 'Adds a new colored point to the display list.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to add.'
          },
          {
            name: 'color',
            summary: 'Color of point.'
          }
        ]
      },
      {
        signature: 'void AddPoint(Point3d point,Color color,PointStyle style,int radius)',
        summary: 'Adds a new stylized point to the display list.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to add.'
          },
          {
            name: 'color',
            summary: 'Color of point.'
          },
          {
            name: 'style',
            summary: 'Display style of point.'
          },
          {
            name: 'radius',
            summary: 'Radius of point widget.'
          }
        ]
      },
      {
        signature: 'void AddPoints(IEnumerable<Point3d> points)',
        summary: 'Adds a collection of black points to the display list.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to add.'
          }
        ]
      },
      {
        signature: 'void AddPoints(IEnumerable<Point3d> points,Color color)',
        summary: 'Adds a collection of colored points to the display list.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to add.'
          },
          {
            name: 'color',
            summary: 'Color of points.'
          }
        ]
      },
      {
        signature: 'void AddPoints(IEnumerable<Point3d> points,Color color,PointStyle style,int radius)',
        summary: 'Adds a collection of stylized points to the display list.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to add.'
          },
          {
            name: 'color',
            summary: 'Color of points.'
          },
          {
            name: 'style',
            summary: 'Display style of points.'
          },
          {
            name: 'radius',
            summary: 'Radius of point widgets.'
          }
        ]
      },
      {
        signature: 'void AddPolygon(IEnumerable<Point3d> polygon,Color fillColor,Color edgeColor,bool drawFill,bool drawEdge)',
        summary: `Adds a polygon to the drawing list. Polygons are not like Hatches, when you supply a concave 
     polygon, the shading probably won't work.`,
        since: 5,
        parameters: [
          {
            name: 'polygon',
            summary: 'Points that define the corners of the polygon.'
          },
          {
            name: 'fillColor',
            summary: 'Fill color of polygon.'
          },
          {
            name: 'edgeColor',
            summary: 'Edge color of polygon.'
          },
          {
            name: 'drawFill',
            summary: 'If true, the polygon contents will be drawn.'
          },
          {
            name: 'drawEdge',
            summary: 'If true, the polygon edge will be drawn.'
          }
        ]
      },
      {
        signature: 'void AddText(string text,Plane plane,double size)',
        summary: 'Adds a new, black 3D text object to the display list.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text to add.'
          },
          {
            name: 'plane',
            summary: 'Plane for text orientation.'
          },
          {
            name: 'size',
            summary: 'Height (in units) of font.'
          }
        ]
      },
      {
        signature: 'void AddText(string text,Plane plane,double size,Color color)',
        summary: 'Adds a new, colored 3D text object to the display list.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text to add.'
          },
          {
            name: 'plane',
            summary: 'Plane for text orientation.'
          },
          {
            name: 'size',
            summary: 'Height (in units) of font.'
          },
          {
            name: 'color',
            summary: 'Color of text.'
          }
        ]
      },
      {
        signature: 'void AddText(Text3d text,Color color)',
        summary: 'Adds a new 3D text object to the display list.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text object to add.'
          },
          {
            name: 'color',
            summary: 'Color of text object.'
          }
        ]
      },
      {
        signature: 'void AddVector(Point3d anchor,Vector3d span)',
        summary: 'Adds a new, black vector to the display list.',
        since: 5,
        parameters: [
          {
            name: 'anchor',
            summary: 'Anchor point of vector.'
          },
          {
            name: 'span',
            summary: 'Direction and magnitude of vector.'
          }
        ]
      },
      {
        signature: 'void AddVector(Point3d anchor,Vector3d span,Color color)',
        summary: 'Adds a new, colored vector to the display list.',
        since: 5,
        parameters: [
          {
            name: 'anchor',
            summary: 'Anchor point of vector.'
          },
          {
            name: 'span',
            summary: 'Direction and magnitude of vector.'
          },
          {
            name: 'color',
            summary: 'Color of vector.'
          }
        ]
      },
      {
        signature: 'void AddVector(Point3d anchor,Vector3d span,Color color,bool drawAnchor)',
        summary: 'Adds a new, colored vector to the display list.',
        since: 5,
        parameters: [
          {
            name: 'anchor',
            summary: 'Anchor point of vector.'
          },
          {
            name: 'span',
            summary: 'Direction and magnitude of vector.'
          },
          {
            name: 'color',
            summary: 'Color of vector.'
          },
          {
            name: 'drawAnchor',
            summary: 'Include a point at the vector anchor.'
          }
        ]
      },
      {
        signature: 'void Clear()',
        summary: 'Clear the drawing lists.',
        since: 5
      },
      {
        signature: 'void Dispose()',
        summary: `Dispose this CustomDisplay instance. You must call this function in order to 
     properly shut down the CustomDisplay.`,
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DefinedViewportProjection',
    dataType: 3,
    summary: 'Parallel and perspective projections that are "standard" in Rhino',
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'Top = 1'
      },
      {
        signature: 'Bottom = 2'
      },
      {
        signature: 'Left = 3'
      },
      {
        signature: 'Right = 4'
      },
      {
        signature: 'Front = 5'
      },
      {
        signature: 'Back = 6'
      },
      {
        signature: 'Perspective = 7'
      },
      {
        signature: 'TwoPointPerspective = 8'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DepthMode',
    dataType: 3,
    values: [
      {
        signature: 'Neutral = 0'
      },
      {
        signature: 'AlwaysInFront = 1'
      },
      {
        signature: 'AlwaysInBack = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayBitmap',
    dataType: 1,
    summary: `A bitmap resource that can be used by the display pipeline (currently only
   in OpenGL display).  Reuse DisplayBitmaps for drawing if possible; it is
   much more expensive to construct new DisplayBitmaps than it is to reuse
   existing DisplayBitmaps.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'DisplayBitmap(Bitmap bitmap)',
        summary: 'Constructs a DisplayBitmap from an existing bitmap.',
        since: 5,
        parameters: [
          {
            name: 'bitmap',
            summary: 'The original bitmap.'
          }
        ]
      }
    ],
    methods: [
      {
        signature: 'static DisplayBitmap Load(string path)',
        summary: 'Load a DisplayBitmap from and image file on disk.',
        since: 5,
        parameters: [
          {
            name: 'path',
            summary: 'A location from which to load the file.'
          }
        ],
        returns: 'The new display bitmap, or None on error.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'void GetBlendModes(BlendMode source,BlendMode destination)',
        summary: 'Gets the source and destination blend modes.',
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'The source blend mode is assigned to this out parameter.'
          },
          {
            name: 'destination',
            summary: 'The destination blend mode is assigned to this out parameter.'
          }
        ]
      },
      {
        signature: 'void SetBlendFunction(BlendMode source,BlendMode destination)',
        summary: `Sets blending function used to determine how this bitmap is blended
     with the current framebuffer color.  The default setting is SourceAlpha
     for source and OneMinusSourceAlpha for destination.  See OpenGL's
     glBlendFunc for details.
     http://www.opengl.org/sdk/docs/man/xhtml/glBlendFunc.xml`,
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'The source blend mode.'
          },
          {
            name: 'destination',
            summary: 'The destination blend mode.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayBitmapDrawList',
    dataType: 1,
    constructors: [
      {
        signature: 'DisplayBitmapDrawList()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'BoundingBox BoundingBox',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int MaximumCachedSortLists',
        summary: `Maximum number of cached sort order index lists stored on this class.
     Default is 10, but depending on the number of points in this list you
     may get better performance by setting this value to a certain percentage
     of the point count.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double SortAngleTolerance',
        summary: `Angle in radians used to determine if an index list is "parallel enough"
     to a viewports camera angle. Default is 0.0873 radians (5 degrees)`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void SetPoints(IEnumerable<Point3d> points)',
        since: 5
      },
      {
        signature: 'void SetPoints(IEnumerable<Point3d> points,Color blendColor)',
        since: 5
      },
      {
        signature: 'void SetPoints(IEnumerable<Point3d> points,IEnumerable<Color> colors)',
        since: 5
      },
      {
        signature: 'int[] Sort(Vector3d cameraDirection)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayConduit',
    dataType: 1,
    properties: [
      {
        signature: 'bool Enabled',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ActiveSpace SpaceFilter',
        summary: `If you want this conduit to only work in a specific space (model or page),
     then set this filter to that specific space. The default is None meaning
     no filter is applied`,
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayEngine',
    dataType: 1,
    interfaces: ['IDisposable'],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayMaterial',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'DisplayMaterial()',
        summary: 'Constructs a default material.',
        since: 5
      },
      {
        signature: 'DisplayMaterial(Color diffuse)',
        summary: 'Constructs a default material with a specific diffuse color.',
        since: 5,
        parameters: [
          {
            name: 'diffuse',
            summary: 'Diffuse color of material. The alpha component of the Diffuse color is ignored.'
          }
        ]
      },
      {
        signature: 'DisplayMaterial(Color diffuse,Color specular,Color ambient,Color emission,double shine,double transparency)',
        summary: 'Constructs a material with custom properties.',
        since: 5,
        parameters: [
          {
            name: 'diffuse',
            summary: 'Diffuse color of material. The alpha component of the Diffuse color is ignored.'
          },
          {
            name: 'specular',
            summary: 'Specular color of material. The alpha component of the Specular color is ignored.'
          },
          {
            name: 'ambient',
            summary: 'Ambient color of material. The alpha component of the Ambient color is ignored.'
          },
          {
            name: 'emission',
            summary: 'Emission color of material. The alpha component of the Emission color is ignored.'
          },
          {
            name: 'shine',
            summary: 'Shine (highlight size) of material.'
          },
          {
            name: 'transparency',
            summary: 'Transparency of material (0.0 = opaque, 1.0 = transparent)'
          }
        ]
      },
      {
        signature: 'DisplayMaterial(Color diffuse,double transparency)',
        summary: 'Constructs a default material with a specific diffuse color and transparency.',
        since: 5,
        parameters: [
          {
            name: 'diffuse',
            summary: 'Diffuse color of material. The alpha component of the Diffuse color is ignored.'
          },
          {
            name: 'transparency',
            summary: 'Transparency factor (0.0 = opaque, 1.0 = transparent)'
          }
        ]
      },
      {
        signature: 'DisplayMaterial(DisplayMaterial other)',
        summary: 'Duplicate another material.',
        since: 5
      },
      {
        signature: 'DisplayMaterial(Material material)',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'Color Ambient',
        summary: `Gets or sets the Ambient color of the Material. 
     The alpha component of the color will be ignored.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color BackAmbient',
        summary: `Gets or sets the Ambient color of the back side of the Material. 
     The alpha component of the color will be ignored.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color BackDiffuse',
        summary: `Gets or sets the Diffuse color of the back side of the Material. 
     The alpha component of the color will be ignored.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color BackEmission',
        summary: `Gets or sets the Emissive color of the back side of the Material. 
     The alpha component of the color will be ignored.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double BackShine',
        summary: 'Gets or sets the shine factor of the back side of the material (0.0 to 1.0)',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color BackSpecular',
        summary: `Gets or sets the Specular color of the back side of the Material. 
     The alpha component of the color will be ignored.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double BackTransparency',
        summary: 'Gets or sets the transparency of the back side material (0.0 = opaque to 1.0 = transparent)',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color Diffuse',
        summary: `Gets or sets the Diffuse color of the Material. 
     The alpha component of the color will be ignored.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color Emission',
        summary: `Gets or sets the Emissive color of the Material. 
     The alpha component of the color will be ignored.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsTwoSided',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Shine',
        summary: 'Gets or sets the shine factor of the material (0.0 to 1.0)',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color Specular',
        summary: `Gets or sets the Specular color of the Material. 
     The alpha component of the color will be ignored.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Transparency',
        summary: 'Gets or sets the transparency of the material (0.0 = opaque to 1.0 = transparent)',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'Rhino.DocObjects.Texture GetBitmapTexture(bool front)',
        since: 5
      },
      {
        signature: 'Rhino.DocObjects.Texture GetBumpTexture(bool front)',
        summary: 'Gets the bump texture for this display material.',
        since: 5,
        returns: 'The texture, or None if no bump texture has been added to this material.'
      },
      {
        signature: 'Rhino.DocObjects.Texture GetEnvironmentTexture(bool front)',
        since: 5
      },
      {
        signature: 'Rhino.DocObjects.Texture GetTransparencyTexture(bool front)',
        since: 5
      },
      {
        signature: 'bool SetBitmapTexture(string filename,bool front)',
        since: 5
      },
      {
        signature: 'bool SetBitmapTexture(Texture texture,bool front)',
        since: 5
      },
      {
        signature: 'bool SetBumpTexture(string filename,bool front)',
        since: 5
      },
      {
        signature: 'bool SetBumpTexture(Texture texture,bool front)',
        since: 5
      },
      {
        signature: 'bool SetEnvironmentTexture(string filename,bool front)',
        since: 5
      },
      {
        signature: 'bool SetEnvironmentTexture(Texture texture,bool front)',
        since: 5
      },
      {
        signature: 'bool SetTransparencyTexture(string filename,bool front)',
        since: 5
      },
      {
        signature: 'bool SetTransparencyTexture(Texture texture,bool front)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayModeChangedEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'Guid ChangedDisplayModeId',
        since: 6.18,
        property: ['get']
      },
      {
        signature: 'Guid OldDisplayModeId',
        since: 6.18,
        property: ['get']
      },
      {
        signature: 'RhinoDoc RhinoDoc',
        since: 6.18,
        property: ['get']
      },
      {
        signature: 'RhinoViewport Viewport',
        since: 6.18,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayModeDescription',
    dataType: 1,
    summary: `Description of a how Rhino will display in a viewport. These are the modes
   that are listed under "Advanced display" in the options dialog.`,
    interfaces: ['IDisposable', 'ISerializable'],
    properties: [
      {
        signature: 'static Guid AmbientOcclusionId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ArtisticId',
        property: ['get']
      },
      {
        signature: 'static Guid GhostedId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid PenId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid RaytracedId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid RenderedId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid RenderedShadowsId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ShadedId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid TechId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid WireframeId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid XRayId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool AllowObjectAssignment',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'DisplayPipelineAttributes DisplayAttributes',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string EnglishName',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Guid Id',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool InMenu',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string LocalName',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool PipelineLocked',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShadedPipelineRequired',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool SupportsShadeCommand',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool SupportsShading',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool WireframePipelineRequired',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Guid AddDisplayMode(DisplayModeDescription displayMode)',
        since: 5
      },
      {
        signature: 'static Guid AddDisplayMode(string name)',
        summary: 'Adds a new display mode.',
        since: 6.7,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the new display mode.'
          }
        ],
        returns: 'The id of the new display mode if successful. Guid.Empty on error.'
      },
      {
        signature: 'static Guid CopyDisplayMode(Guid id,string name)',
        summary: 'Copies an existing display mode.',
        since: 6.7,
        parameters: [
          {
            name: 'id',
            summary: 'The id of the existing display mode to copy.'
          },
          {
            name: 'name',
            summary: 'The name of the new display mode.'
          }
        ],
        returns: 'The id of the new display mode if successful. Guid.Empty on error.'
      },
      {
        signature: 'static bool DeleteDiplayMode(Guid id)',
        summary: 'Deletes an existing display mode.',
        since: 5,
        parameters: [
          {
            name: 'id',
            summary: 'The id of the existing display mode to delete.'
          }
        ],
        returns: 'True if successful, False oteherwise.'
      },
      {
        signature: 'static bool DeleteDisplayMode(Guid id)',
        summary: 'Deletes an existing display mode.',
        since: 7,
        parameters: [
          {
            name: 'id',
            summary: 'The id of the existing display mode to delete.'
          }
        ],
        returns: 'True if successful, False oteherwise.'
      },
      {
        signature: 'static bool ExportToFile(DisplayModeDescription displayMode,string filename)',
        summary: 'Exports a DisplayModeDescription to a Windows-style .ini file.',
        since: 6,
        parameters: [
          {
            name: 'displayMode',
            summary: 'The DisplayModeDescription to export.'
          },
          {
            name: 'filename',
            summary: 'The name of the file to create.'
          }
        ]
      },
      {
        signature: 'static DisplayModeDescription FindByName(string englishName)',
        since: 5
      },
      {
        signature: 'static DisplayModeDescription GetDisplayMode(Guid id)',
        since: 5
      },
      {
        signature: 'static DisplayModeDescription[] GetDisplayModes()',
        summary: 'Gets all display mode descriptions that Rhino currently knows about.',
        since: 5,
        returns: `Copies of all of the display mode descriptions. If you want to modify
     these descriptions, you must call UpdateDisplayMode or AddDisplayMode.`
      },
      {
        signature: 'static Guid ImportFromFile(string filename)',
        summary: 'Imports a DisplayModeDescription from a Windows-style .ini file.',
        since: 6,
        parameters: [
          {
            name: 'filename',
            summary: 'The name of the file to import.'
          }
        ],
        returns: 'The id of the DisplayModeDescription if successsful.'
      },
      {
        signature: 'static bool UpdateDisplayMode(DisplayModeDescription displayMode)',
        since: 5
      },
      {
        signature: 'void Dispose()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayPipeline',
    dataType: 1,
    summary: `The display pipeline calls events during specific phases of drawing
   During the drawing of a single frame the events are called in the following order.
   
   [Begin Drawing of a Frame]
   CalculateBoundingBoxCalculateClippingPanesSetupFrustumSetupLightingInitializeFrameBufferDrawBackgroundIf this is a layout and detail objects exist the channels are called in the
     same order for each detail object (drawn as a nested viewport)PreDrawObjectsFor Each Visible Non Highlighted ObjectSetupObjectDisplayAttributesPreDrawObjectDrawObjectPostDrawObjectPostDrawObjects - depth writing/testing onDrawForeGround - depth writing/testing offFor Each Visible Highlighted ObjectSetupObjectDisplayAttributesPreDrawObjectDrawObjectPostDrawObjectPostProcessFrameBuffer (If a delegate exists that requires this)DrawOverlay (if Rhino is in a feedback mode)
   [End of Drawing of a Frame]
  
   NOTE: There may be multiple DrawObject calls for a single object. An example of when this could
         happen would be with a shaded sphere. The shaded mesh is first drawn and these channels would
         be processed; then at a later time the isocurves for the sphere would be drawn.`,
    properties: [
      {
        signature: 'RhinoObject ActiveObject',
        since: 6.7,
        property: ['get']
      },
      {
        signature: 'int ActiveObjectNestingLevel',
        since: 6.7,
        property: ['get']
      },
      {
        signature: 'RhinoObject[] ActiveObjectNestingStack',
        since: 6.7,
        property: ['get']
      },
      {
        signature: 'RhinoObject ActiveTopLevelObject',
        since: 6.7,
        property: ['get']
      },
      {
        signature: 'int DefaultCurveThickness',
        summary: `Gets the curve thickness as defined by the current display mode. 
     Note: this only applies to curve objects, Brep and Mesh wires may have different settings.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'DepthMode DepthMode',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'DisplayPipelineAttributes DisplayPipelineAttributes',
        since: 5.3,
        property: ['get']
      },
      {
        signature: 'float DpiScale',
        summary: `Scale factor used for high resolution displays. When a monitor that this
     pipeline is drawing to is at a DPI of 96, this value is one. On high
     DPI monitors, this value will commonly be greater than one.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool DrawingGrips',
        summary: 'Gets a value that indicates whether the pipeline is currently in a grip drawing operation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool DrawingSurfaces',
        summary: `Gets a value that indicates whether the pipeline is currently in a surface
     drawing operation.  Surface drawing means draw the shaded triangles of a mesh
     representing the surface (mesh, extrusion, or brep).  This is useful when
     inside of a draw event or display conduit to check and see if the geometry is
     about to be drawn as a shaded set of triangles representing the geometry.
     See DrawingWires to check and see if the wireframe representation of the
     geometry is going to be drawn.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool DrawingWires',
        summary: `Gets a value that indicates whether the pipeline is currently in a curve
     drawing operation. This is useful when inside of a draw event or display
     conduit to check and see if the geometry is about to be drawn is going to
     be drawing the wire representation of the geometry (mesh, extrusion, or
     brep).  See DrawingSurfaces to check and see if the shaded mesh representation
     of the geometry is going to be drawn.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Bitmap FrameBuffer',
        summary: 'Gets the contents of the framebuffer that this pipeline is drawing to.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Size FrameSize',
        summary: 'Gets the size of the framebuffer that this pipeline is drawing to.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsDynamicDisplay',
        summary: `Gets a value that indicates whether the viewport is in Dynamic Display state. 
     Dynamic display is the state a viewport is in when it is rapidly redrawing because of
     an operation like panning or rotating. The pipeline will drop some level of detail
     while inside a dynamic display state to keep the frame rate as high as possible.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsInViewCapture',
        summary: `Gets a value that indicates whether this pipeline is currently drawing
     for ViewCaptureToFile or ViewCaptureToClipboard`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsOpen',
        summary: 'Is True of the pipeline is open, False otherwise.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'bool IsOpenGL',
        summary: 'Gets a value indicating whether or not this pipeline is drawing into an OpenGL context.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsPrinting',
        summary: `Gets a value that indicates whether this pipeline 
     is currently drawing for printing purposes.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsStereoMode',
        summary: `Gets a value that indicates whether this pipeline is currently using an 
     engine that is performing stereo style drawing. Stereo drawing is for 
     providing an "enhanced 3-D" effect through stereo viewing devices.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Transform ModelTransform',
        summary: 'Gets or sets the current model transformation that is applied to vertices when drawing.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ModelTransformIsIdentity',
        summary: 'Gets a value that indicates whether the Model Transform is an Identity transformation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int NestLevel',
        summary: `Gets the current nested viewport drawing level. 
     This is used to know if you are currently inside the drawing of a nested viewport (detail object in Rhino). 
     Nest level = 0 Drawing is occuring in a standard Rhino viewport or on the page viewport.Nest level = 1 Drawing is occuring inside a detail view object.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'int RenderPass',
        summary: `Gets the current pass that the pipeline is in for drawing a frame. 
     Typically drawing a frame requires a single pass through the DrawFrameBuffer 
     function, but some special display effects can be achieved through 
     drawing with multiple passes.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool ShadingRequired',
        summary: `Gets or sets the "ShadingRequired" flag. This flag gets set inside the pipeline when a request is 
     made to draw a shaded mesh but the current render engine doesn't support shaded 
     mesh drawing...at this point the redraw mechanism will make sure everything will 
     work the next time around.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int StereoProjection',
        summary: `Gets the current stereo projection if stereo mode is on.
     0 = left1 = right
     If stereo mode is not enables, this property always returns 0.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool SupportsShading',
        summary: 'Gets whether or not this pipeline supports shaded meshes.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoViewport Viewport',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ZBiasMode ZBiasMode',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static uint AvailableOpenGLVersion(bool coreProfile)',
        summary: `If Rhino is using OpenGL for display, this function will return
     major.minor version of OpenGL available for this instance of Rhino`,
        since: 6.21,
        parameters: [
          {
            name: 'coreProfile',
            summary: 'If true, OpenGL is being used in "core profile" mode'
          }
        ],
        returns: `major version * 10 + minor version
     For example, OpenGL 4.5 returns 45`
      },
      {
        signature: 'static string CrossCompileHLSL(string hlsl,string functionName,ShaderLanguage targetLanguage)',
        summary: 'Convert HLSL code to a different shading language',
        since: 7
      },
      {
        signature: 'static bool CullControlPolygon()',
        summary: `Returns a value indicating if only points on the side of the surface that
     face the camera are displayed.`,
        since: 5,
        returns: `True if backfaces of surface and mesh control polygons are culled.
     This value is determined by the _CullControlPolygon command.`
      },
      {
        signature: 'static System.Drawing.Bitmap DrawToBitmap(RhinoViewport viewport,int width,int height)',
        summary: 'Draw a given viewport to an off-screen bitmap.',
        since: 5,
        parameters: [
          {
            name: 'viewport',
            summary: 'Viewport to draw.'
          },
          {
            name: 'width',
            summary: 'Width of target image.'
          },
          {
            name: 'height',
            summary: 'Height of target image.'
          }
        ],
        returns: 'A bitmap containing the given view, or None on error.'
      },
      {
        signature: 'static void GetDrawListSerialNumbers(uint modelSerialNumber,uint pageSerialNumber)',
        summary: `Gets the current model and page view draw list serial numbers, which can
     be used to determine if a model or page view needs to be redrawn.`,
        since: 7,
        parameters: [
          {
            name: 'modelSerialNumber',
            summary: 'The current model draw list serial number.'
          },
          {
            name: 'pageSerialNumber',
            summary: 'The current page view draw list serial number.'
          }
        ]
      },
      {
        signature: 'static bool MakeDefaultOpenGLContextCurrent()',
        summary: 'Make a "default" OpenGL context current',
        since: 7
      },
      {
        signature: 'int AddClippingPlane(Point3d point,Vector3d normal)',
        summary: 'Add a clipping plane to be used during the drawing of this frame',
        since: 6.3,
        parameters: [
          {
            name: 'point',
            summary: 'point on the plane'
          },
          {
            name: 'normal',
            summary: 'vector perpendicular to the plane'
          }
        ],
        returns: 'index for the added clipping plane'
      },
      {
        signature: 'DisplayPipeline Clone(RhinoViewport viewport)',
        summary: `Clones the pipeline. Creates an identical copy of "this" pipeline.
     Copies all conduits from "this" pipeline to the new pipeline.`,
        since: 7,
        returns: `The newly cloned pipeline if successful, None otherwise.
     or failed to close.`
      },
      {
        signature: 'bool Close()',
        summary: 'Closes the pipeline.',
        since: 7,
        returns: `True if the pipeline was closed, False if it was already closed
     or failed to close.`
      },
      {
        signature: 'void Draw2dLine(Point from,Point to,Color color,float thickness)',
        since: 6
      },
      {
        signature: 'void Draw2dLine(PointF from,PointF to,Color color,float thickness)',
        since: 6
      },
      {
        signature: 'void Draw2dRectangle(Rectangle rectangle,Color strokeColor,int thickness,Color fillColor)',
        since: 5.1
      },
      {
        signature: 'void Draw2dText(string text,Color color,Point2d screenCoordinate,bool middleJustified)',
        summary: 'Draws 2D text on the viewport.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'the string to draw.'
          },
          {
            name: 'color',
            summary: 'text color.'
          },
          {
            name: 'screenCoordinate',
            summary: 'definition point in screen coordinates (0,0 is top-left corner)'
          },
          {
            name: 'middleJustified',
            summary: 'if True text is centered around the definition point, otherwise it is lower-left justified.'
          }
        ]
      },
      {
        signature: 'void Draw2dText(string text,Color color,Point2d screenCoordinate,bool middleJustified,int height)',
        summary: 'Draws 2D text on the viewport.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'the string to draw.'
          },
          {
            name: 'color',
            summary: 'text color.'
          },
          {
            name: 'screenCoordinate',
            summary: 'definition point in screen coordinates (0,0 is top-left corner)'
          },
          {
            name: 'middleJustified',
            summary: 'if True text is centered around the definition point, otherwise it is lower-left justified.'
          },
          {
            name: 'height',
            summary: 'height in pixels (good default is 12)'
          }
        ]
      },
      {
        signature: 'void Draw2dText(string text,Color color,Point2d screenCoordinate,bool middleJustified,int height,string fontface)',
        summary: 'Draws 2D text on the viewport.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'the string to draw.'
          },
          {
            name: 'color',
            summary: 'text color.'
          },
          {
            name: 'screenCoordinate',
            summary: 'definition point in screen coordinates (0,0 is top-left corner)'
          },
          {
            name: 'middleJustified',
            summary: 'if True text is centered around the definition point, otherwise it is lower-left justified.'
          },
          {
            name: 'height',
            summary: 'height in pixels (good default is 12)'
          },
          {
            name: 'fontface',
            summary: 'font name (good default is "Arial")'
          }
        ]
      },
      {
        signature: 'void Draw2dText(string text,Color color,Point3d worldCoordinate,bool middleJustified)',
        summary: 'Draws 2D text on the viewport.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'the string to draw.'
          },
          {
            name: 'color',
            summary: 'text color.'
          },
          {
            name: 'worldCoordinate',
            summary: 'definition point in world coordinates.'
          },
          {
            name: 'middleJustified',
            summary: 'if True text is centered around the definition point, otherwise it is lower-left justified.'
          }
        ]
      },
      {
        signature: 'void Draw2dText(string text,Color color,Point3d worldCoordinate,bool middleJustified,int height)',
        summary: 'Draws 2D text on the viewport.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'the string to draw.'
          },
          {
            name: 'color',
            summary: 'text color.'
          },
          {
            name: 'worldCoordinate',
            summary: 'definition point in world coordinates.'
          },
          {
            name: 'middleJustified',
            summary: 'if True text is centered around the definition point, otherwise it is lower-left justified.'
          },
          {
            name: 'height',
            summary: 'height in pixels (good default is 12)'
          }
        ]
      },
      {
        signature: 'void Draw2dText(string text,Color color,Point3d worldCoordinate,bool middleJustified,int height,string fontface)',
        summary: 'Draws 2D text on the viewport.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'The string to draw.'
          },
          {
            name: 'color',
            summary: 'Text color.'
          },
          {
            name: 'worldCoordinate',
            summary: 'Definition point in world coordinates.'
          },
          {
            name: 'middleJustified',
            summary: 'If True text is centered around the definition point, otherwise it is lower-left justified.'
          },
          {
            name: 'height',
            summary: 'Height in pixels (good default is 12).'
          },
          {
            name: 'fontface',
            summary: 'Font name (good default is "Arial").'
          }
        ]
      },
      {
        signature: 'void Draw3dText(string text,Color color,Plane textPlane,double height,string fontface)',
        since: 5
      },
      {
        signature: 'void Draw3dText(string text,Color color,Plane textPlane,double height,string fontface,bool bold,bool italic)',
        since: 6
      },
      {
        signature: 'void Draw3dText(string text,Color color,Plane textPlane,double height,string fontface,bool bold,bool italic,TextHorizontalAlignment horizontalAlignment,TextVerticalAlignment verticalAlignment)',
        since: 6.4
      },
      {
        signature: 'void Draw3dText(Text3d text,Color color)',
        since: 5
      },
      {
        signature: 'void Draw3dText(Text3d text,Color color,Plane textPlane)',
        summary: 'Draws 3d text with a different plane than what is defined in the Text3d class.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'The string to draw.'
          },
          {
            name: 'color',
            summary: 'Text color.'
          },
          {
            name: 'textPlane',
            summary: 'The plane for the text object.'
          }
        ]
      },
      {
        signature: 'void Draw3dText(Text3d text,Color color,Point3d textPlaneOrigin)',
        summary: 'Draws 3d text using the Text3d plane with an adjusted origin.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'The string to draw.'
          },
          {
            name: 'color',
            summary: 'Text color.'
          },
          {
            name: 'textPlaneOrigin',
            summary: 'The origin of the plane to draw.'
          }
        ]
      },
      {
        signature: 'void DrawActivePoint(Point3d point)',
        summary: 'Draws a point in style used during "GetPoint" operations',
        since: 6,
        parameters: [
          {
            name: 'point',
            summary: 'Location of the point in world coordinates'
          }
        ]
      },
      {
        signature: 'void DrawAnnotation(AnnotationBase annotation,Color color)',
        since: 6
      },
      {
        signature: 'void DrawAnnotationArrowhead(Arrowhead arrowhead,Transform xform,Color color)',
        since: 6
      },
      {
        signature: 'void DrawArc(Arc arc,Color color)',
        summary: 'Draw a single arc object.',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'Arc to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          }
        ]
      },
      {
        signature: 'void DrawArc(Arc arc,Color color,int thickness)',
        summary: 'Draw a single arc object.',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'Arc to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of arc.'
          }
        ]
      },
      {
        signature: 'void DrawArrow(Line line,Color color)',
        summary: 'Draws a single arrow object. An arrow consists of a Shaft and an Arrow head at the end of the shaft.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Arrow shaft.'
          },
          {
            name: 'color',
            summary: 'Color of arrow.'
          }
        ]
      },
      {
        signature: 'void DrawArrow(Line line,Color color,double screenSize,double relativeSize)',
        summary: `Draws a single arrow object. 
     An arrow consists of a Shaft and an Arrow head at the end of the shaft.`,
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Arrow shaft.'
          },
          {
            name: 'color',
            summary: 'Color of arrow.'
          },
          {
            name: 'screenSize',
            summary: 'If screenSize != 0.0 then the size (in screen pixels) of the arrow head will be equal to screenSize.'
          },
          {
            name: 'relativeSize',
            summary: 'If relativeSize != 0.0 and screensize == 0.0 the size of the arrow head will be proportional to the arrow shaft length.'
          }
        ]
      },
      {
        signature: 'void DrawArrowHead(Point3d tip,Vector3d direction,Color color,double screenSize,double worldSize)',
        summary: 'Draws a single arrow head.',
        since: 5,
        parameters: [
          {
            name: 'tip',
            summary: 'Point of arrow head tip.'
          },
          {
            name: 'direction',
            summary: 'Direction in which arrow head is pointing.'
          },
          {
            name: 'color',
            summary: 'Color of arrow head.'
          },
          {
            name: 'screenSize',
            summary: 'If screenSize != 0.0, then the size (in screen pixels) of the arrow head will be equal to the screenSize.'
          },
          {
            name: 'worldSize',
            summary: 'If worldSize != 0.0 and screensize == 0.0 the size of the arrow head will be equal to the number of units in worldSize.'
          }
        ]
      },
      {
        signature: 'void DrawArrows(IEnumerable<Line> lines,Color color)',
        summary: 'Draws a collection of arrow objects. An arrow consists of a Shaft and an Arrow head at the end of the shaft.',
        since: 5,
        parameters: [
          {
            name: 'lines',
            summary: 'Arrow shafts.'
          },
          {
            name: 'color',
            summary: 'Color of arrows.'
          }
        ]
      },
      {
        signature: 'void DrawArrows(Line[] lines,Color color)',
        summary: 'Draws a collection of arrow objects. An arrow consists of a Shaft and an Arrow head at the end of the shaft.',
        since: 5,
        parameters: [
          {
            name: 'lines',
            summary: 'Arrow shafts.'
          },
          {
            name: 'color',
            summary: 'Color of arrows.'
          }
        ]
      },
      {
        signature: 'void DrawBitmap(DisplayBitmap bitmap,int left,int top)',
        summary: 'Draws a bitmap in screen coordinates',
        since: 5.1,
        parameters: [
          {
            name: 'bitmap',
            summary: 'bitmap to draw'
          },
          {
            name: 'left',
            summary: 'where top/left corner of bitmap should appear in screen coordinates'
          },
          {
            name: 'top',
            summary: 'where top/left corner of bitmap should appear in screen coordinates'
          }
        ]
      },
      {
        signature: 'void DrawBox(BoundingBox box,Color color)',
        summary: 'Draws the edges of a BoundingBox.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw in.'
          }
        ]
      },
      {
        signature: 'void DrawBox(BoundingBox box,Color color,int thickness)',
        summary: 'Draws the edges of a BoundingBox.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw in.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of box edges.'
          }
        ]
      },
      {
        signature: 'void DrawBox(Box box,Color color)',
        summary: 'Draws the edges of a Box object.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw in.'
          }
        ]
      },
      {
        signature: 'void DrawBox(Box box,Color color,int thickness)',
        summary: 'Draws the edges of a Box object.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw in.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of box edges.'
          }
        ]
      },
      {
        signature: 'void DrawBoxCorners(BoundingBox box,Color color)',
        summary: `Draws corner widgets of a world aligned boundingbox. 
     Widget size will be 5% of the Box diagonal.`,
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          }
        ]
      },
      {
        signature: 'void DrawBoxCorners(BoundingBox box,Color color,double size)',
        summary: 'Draws corner widgets of a world aligned boundingbox.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          },
          {
            name: 'size',
            summary: 'Size (in model units) of the corner widgets.'
          }
        ]
      },
      {
        signature: 'void DrawBoxCorners(BoundingBox box,Color color,double size,int thickness)',
        summary: 'Draws corner widgets of a world aligned boundingbox.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          },
          {
            name: 'size',
            summary: 'Size (in model units) of the corner widgets.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of the corner widgets.'
          }
        ]
      },
      {
        signature: 'void DrawBrepShaded(Brep brep,DisplayMaterial material)',
        summary: 'Draws a shaded mesh representation of a brep.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'Brep to draw.'
          },
          {
            name: 'material',
            summary: 'Material to draw faces with.'
          }
        ]
      },
      {
        signature: 'void DrawBrepWires(Brep brep,Color color)',
        summary: 'Draws all the wireframe curves of a brep object.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'Brep to draw.'
          },
          {
            name: 'color',
            summary: 'Color of Wireframe curves.'
          }
        ]
      },
      {
        signature: 'void DrawBrepWires(Brep brep,Color color,int wireDensity)',
        summary: 'Draws all the wireframe curves of a brep object.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'Brep to draw.'
          },
          {
            name: 'color',
            summary: 'Color of Wireframe curves.'
          },
          {
            name: 'wireDensity',
            summary: `"Density" of wireframe curves.
     -1 = no internal wires. 0 = default internal wires.>0 = custom high density.`
          }
        ]
      },
      {
        signature: 'void DrawCircle(Circle circle,Color color)',
        summary: 'Draw a single circle object.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'Circle to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          }
        ]
      },
      {
        signature: 'void DrawCircle(Circle circle,Color color,int thickness)',
        summary: 'Draw a single circle object.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'Circle to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of circle.'
          }
        ]
      },
      {
        signature: 'void DrawCone(Cone cone,Color color)',
        summary: 'Draw a wireframe cone.',
        since: 5,
        parameters: [
          {
            name: 'cone',
            summary: 'Cone to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          }
        ]
      },
      {
        signature: 'void DrawCone(Cone cone,Color color,int thickness)',
        summary: 'Draw a wireframe cone.',
        since: 5,
        parameters: [
          {
            name: 'cone',
            summary: 'Cone to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of Cone wires.'
          }
        ]
      },
      {
        signature: 'void DrawConstructionPlane(ConstructionPlane constructionPlane)',
        since: 5
      },
      {
        signature: 'void DrawCurvatureGraph(Curve curve,Color color)',
        summary: 'Draw a typical Rhino Curvature Graph.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Base curve for curvature graph.'
          },
          {
            name: 'color',
            summary: 'Color of curvature graph.'
          }
        ]
      },
      {
        signature: 'void DrawCurvatureGraph(Curve curve,Color color,int hairScale)',
        summary: 'Draw a typical Rhino Curvature Graph.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Base curve for curvature graph.'
          },
          {
            name: 'color',
            summary: 'Color of curvature graph.'
          },
          {
            name: 'hairScale',
            summary: '100 = True length, > 100 magnified, < 100 shortened.'
          }
        ]
      },
      {
        signature: 'void DrawCurvatureGraph(Curve curve,Color color,int hairScale,int hairDensity,int sampleDensity)',
        summary: 'Draw a typical Rhino Curvature Graph.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Base curve for curvature graph.'
          },
          {
            name: 'color',
            summary: 'Color of curvature graph.'
          },
          {
            name: 'hairScale',
            summary: '100 = True length, > 100 magnified, < 100 shortened.'
          },
          {
            name: 'hairDensity',
            summary: '>= 0 larger numbers = more hairs (good default is 1).'
          },
          {
            name: 'sampleDensity',
            summary: 'Between 1 and 10. Higher numbers draw smoother outer curves. (good default is 2).'
          }
        ]
      },
      {
        signature: 'void DrawCurve(Curve curve,Color color)',
        summary: 'Draw a single Curve object.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          }
        ]
      },
      {
        signature: 'void DrawCurve(Curve curve,Color color,int thickness)',
        summary: 'Draw a single Curve object.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of curve.'
          }
        ]
      },
      {
        signature: 'void DrawCylinder(Cylinder cylinder,Color color)',
        summary: 'Draw a wireframe cylinder.',
        since: 5,
        parameters: [
          {
            name: 'cylinder',
            summary: 'Cylinder to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          }
        ]
      },
      {
        signature: 'void DrawCylinder(Cylinder cylinder,Color color,int thickness)',
        summary: 'Draw a wireframe cylinder.',
        since: 5,
        parameters: [
          {
            name: 'cylinder',
            summary: 'Cylinder to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of cylinder wires.'
          }
        ]
      },
      {
        signature: 'void DrawDirectionArrow(Point3d location,Vector3d direction,Color color)',
        since: 5
      },
      {
        signature: 'void DrawDot(float screenX,float screenY,string text)',
        summary: 'Draws a text dot in screen coordinates.',
        since: 6,
        parameters: [
          {
            name: 'screenX',
            summary: 'X coordinate (in pixels) of dot center.'
          },
          {
            name: 'screenY',
            summary: 'Y coordinate (in pixels) of dot center.'
          },
          {
            name: 'text',
            summary: 'Text content of dot.'
          }
        ]
      },
      {
        signature: 'void DrawDot(float screenX,float screenY,string text,Color dotColor,Color textColor)',
        summary: 'Draws a text dot in screen coordinates.',
        since: 6,
        parameters: [
          {
            name: 'screenX',
            summary: 'X coordinate (in pixels) of dot center.'
          },
          {
            name: 'screenY',
            summary: 'Y coordinate (in pixels) of dot center.'
          },
          {
            name: 'text',
            summary: 'Text content of dot.'
          },
          {
            name: 'dotColor',
            summary: 'Dot background color.'
          },
          {
            name: 'textColor',
            summary: 'Dot foreground color.'
          }
        ]
      },
      {
        signature: 'void DrawDot(Point3d worldPosition,string text)',
        summary: 'Draws a text dot in world coordinates.',
        since: 5,
        parameters: [
          {
            name: 'worldPosition',
            summary: 'Location of dot in world coordinates.'
          },
          {
            name: 'text',
            summary: 'Text content of dot.'
          }
        ]
      },
      {
        signature: 'void DrawDot(Point3d worldPosition,string text,Color dotColor,Color textColor)',
        summary: 'Draw a text dot in world coordinates.',
        since: 5,
        parameters: [
          {
            name: 'worldPosition',
            summary: 'Location of dot in world coordinates.'
          },
          {
            name: 'text',
            summary: 'Text content of dot.'
          },
          {
            name: 'dotColor',
            summary: 'Dot background color.'
          },
          {
            name: 'textColor',
            summary: 'Dot foreground color.'
          }
        ]
      },
      {
        signature: 'void DrawDot(TextDot dot,Color fillColor,Color textColor,Color borderColor)',
        summary: 'Draw a text dot as defined by the text dot class',
        since: 6
      },
      {
        signature: 'void DrawDottedLine(Line line,Color color)',
        summary: 'Draws a single dotted line.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line to draw.'
          },
          {
            name: 'color',
            summary: 'Color of line.'
          }
        ]
      },
      {
        signature: 'void DrawDottedLine(Point3d from,Point3d to,Color color)',
        summary: 'Draws a single dotted line.',
        since: 5,
        parameters: [
          {
            name: 'from',
            summary: 'Line start point.'
          },
          {
            name: 'to',
            summary: 'Line end point.'
          },
          {
            name: 'color',
            summary: 'Color of line.'
          }
        ]
      },
      {
        signature: 'void DrawDottedPolyline(IEnumerable<Point3d> points,Color color,bool close)',
        summary: 'Draws a set of connected lines (polyline) in a dotted pattern (0x00001111).',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'End points of each line segment.'
          },
          {
            name: 'color',
            summary: 'Color of polyline.'
          },
          {
            name: 'close',
            summary: 'Draw a line between the first and last points.'
          }
        ]
      },
      {
        signature: 'void DrawExtrusionWires(Extrusion extrusion,Color color)',
        summary: 'Draws all the wireframe curves of an extrusion object.',
        since: 6,
        parameters: [
          {
            name: 'extrusion',
            summary: 'Extrusion to draw.'
          },
          {
            name: 'color',
            summary: 'Color of Wireframe curves.'
          }
        ]
      },
      {
        signature: 'void DrawExtrusionWires(Extrusion extrusion,Color color,int wireDensity)',
        summary: 'Draws all the wireframe curves of an extrusion object.',
        since: 6,
        parameters: [
          {
            name: 'extrusion',
            summary: 'Extrusion to draw.'
          },
          {
            name: 'color',
            summary: 'Color of Wireframe curves.'
          },
          {
            name: 'wireDensity',
            summary: `"Density" of wireframe curves.
     -1 = no internal wires. 0 = default internal wires.>0 = custom high density.`
          }
        ]
      },
      {
        signature: 'void DrawGradientHatch(Hatch hatch,Color color1,Color color2,Point3d point1,Point3d point2,bool linearGradient,float boundaryThickness,Color boundaryColor)',
        summary: 'Draw a two point gradient filled hatch',
        since: 7
      },
      {
        signature: 'void DrawGradientHatch(Hatch hatch,IEnumerable<ColorStop> stops,Point3d point1,Point3d point2,bool linearGradient,float repeat,float boundaryThickness,Color boundaryColor)',
        since: 7
      },
      {
        signature: 'void DrawGradientLines(IEnumerable<Line> lines,float strokeWidth,IEnumerable<ColorStop> stops,Point3d point1,Point3d point2,bool linearGradient,float repeat)',
        since: 7
      },
      {
        signature: 'void DrawGradientMesh(Mesh mesh,IEnumerable<ColorStop> stops,Point3d point1,Point3d point2,bool linearGradient,float repeat)',
        since: 7
      },
      {
        signature: 'void DrawHatch(Hatch hatch,Color hatchColor,Color boundaryColor)',
        since: 6
      },
      {
        signature: 'void DrawLine(Line line,Color color)',
        summary: 'Draws a single line object.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw line in.'
          }
        ]
      },
      {
        signature: 'void DrawLine(Line line,Color color,int thickness)',
        summary: 'Draws a single line object.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw line in.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of line.'
          }
        ]
      },
      {
        signature: 'void DrawLine(Point3d from,Point3d to,Color color)',
        summary: 'Draws a single line object.',
        since: 5,
        parameters: [
          {
            name: 'from',
            summary: 'Line from point.'
          },
          {
            name: 'to',
            summary: 'Line to point.'
          },
          {
            name: 'color',
            summary: 'Color to draw line in.'
          }
        ]
      },
      {
        signature: 'void DrawLine(Point3d from,Point3d to,Color color,int thickness)',
        summary: 'Draws a single line object.',
        since: 5,
        parameters: [
          {
            name: 'from',
            summary: 'Line from point.'
          },
          {
            name: 'to',
            summary: 'Line to point.'
          },
          {
            name: 'color',
            summary: 'Color to draw line in.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of line.'
          }
        ]
      },
      {
        signature: 'void DrawLineArrow(Line line,Color color,int thickness,double size)',
        summary: 'Draws an arrow made up of three line segments.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Base line for arrow.'
          },
          {
            name: 'color',
            summary: 'Color of arrow.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of the arrow line segments.'
          },
          {
            name: 'size',
            summary: 'Size (in world units) of the arrow tip lines.'
          }
        ]
      },
      {
        signature: 'void DrawLines(IEnumerable<Line> lines,Color color)',
        summary: `Draws a set of lines with a given color and thickness. If you want the fastest possible set of lines
     to be drawn, pass a Line[] for lines.`,
        since: 5,
        parameters: [
          {
            name: 'lines',
            summary: 'Lines to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          }
        ]
      },
      {
        signature: 'void DrawLines(IEnumerable<Line> lines,Color color,int thickness)',
        summary: `Draws a set of lines with a given color and thickness. If you want the fastest possible set of lines
     to be drawn, pass a Line[] for lines.`,
        since: 5,
        parameters: [
          {
            name: 'lines',
            summary: 'Lines to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of lines.'
          }
        ]
      },
      {
        signature: 'void DrawMarker(Point3d tip,Vector3d direction,Color color)',
        summary: 'Draws an arrow marker as a view-aligned widget.',
        since: 5,
        parameters: [
          {
            name: 'tip',
            summary: 'Location of arrow tip point.'
          },
          {
            name: 'direction',
            summary: 'Direction of arrow.'
          },
          {
            name: 'color',
            summary: 'Color of arrow widget.'
          }
        ]
      },
      {
        signature: 'void DrawMarker(Point3d tip,Vector3d direction,Color color,int thickness)',
        summary: 'Draws an arrow marker as a view-aligned widget.',
        since: 5,
        parameters: [
          {
            name: 'tip',
            summary: 'Location of arrow tip point.'
          },
          {
            name: 'direction',
            summary: 'Direction of arrow.'
          },
          {
            name: 'color',
            summary: 'Color of arrow widget.'
          },
          {
            name: 'thickness',
            summary: 'Thickness of arrow widget lines.'
          }
        ]
      },
      {
        signature: 'void DrawMarker(Point3d tip,Vector3d direction,Color color,int thickness,double size)',
        summary: 'Draws an arrow marker as a view-aligned widget.',
        since: 5,
        parameters: [
          {
            name: 'tip',
            summary: 'Location of arrow tip point.'
          },
          {
            name: 'direction',
            summary: 'Direction of arrow.'
          },
          {
            name: 'color',
            summary: 'Color of arrow widget.'
          },
          {
            name: 'thickness',
            summary: 'Thickness of arrow widget lines.'
          },
          {
            name: 'size',
            summary: 'Size (in pixels) of the arrow shaft.'
          }
        ]
      },
      {
        signature: 'void DrawMarker(Point3d tip,Vector3d direction,Color color,int thickness,double size,double rotation)',
        summary: 'Draws an arrow marker as a view-aligned widget.',
        since: 5,
        parameters: [
          {
            name: 'tip',
            summary: 'Location of arrow tip point.'
          },
          {
            name: 'direction',
            summary: 'Direction of arrow.'
          },
          {
            name: 'color',
            summary: 'Color of arrow widget.'
          },
          {
            name: 'thickness',
            summary: 'Thickness of arrow widget lines.'
          },
          {
            name: 'size',
            summary: 'Size (in pixels) of the arrow shaft.'
          },
          {
            name: 'rotation',
            summary: 'Rotational angle adjustment (in radians, counter-clockwise of direction.'
          }
        ]
      },
      {
        signature: 'void DrawMeshFalseColors(Mesh mesh)',
        summary: `Draws the mesh faces as False color patches. 
     The mesh must have Vertex Colors defined for this to work.`,
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh to draw.'
          }
        ]
      },
      {
        signature: 'void DrawMeshShaded(Mesh mesh,DisplayMaterial material)',
        summary: 'Draws the shaded faces of a given mesh.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh to draw.'
          },
          {
            name: 'material',
            summary: 'Material to draw faces with.'
          }
        ]
      },
      {
        signature: 'void DrawMeshShaded(Mesh mesh,DisplayMaterial material,int[] faceIndices)',
        summary: 'Draws the shaded faces of a given mesh.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh to draw.'
          },
          {
            name: 'material',
            summary: 'Material to draw faces with.'
          },
          {
            name: 'faceIndices',
            summary: 'Indices of specific faces to draw'
          }
        ]
      },
      {
        signature: 'void DrawMeshVertices(Mesh mesh,Color color)',
        summary: 'Draws all the vertices in a given mesh.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh for vertex drawing.'
          },
          {
            name: 'color',
            summary: 'Color of mesh vertices.'
          }
        ]
      },
      {
        signature: 'void DrawMeshWires(Mesh mesh,Color color)',
        summary: 'Draws all the wires in a given mesh.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh for wire drawing.'
          },
          {
            name: 'color',
            summary: 'Color of mesh wires.'
          }
        ]
      },
      {
        signature: 'void DrawMeshWires(Mesh mesh,Color color,int thickness)',
        summary: 'Draws all the wires in a given mesh.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh for wire drawing.'
          },
          {
            name: 'color',
            summary: 'Color of mesh wires.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of mesh wires.'
          }
        ]
      },
      {
        signature: 'void DrawObject(RhinoObject rhinoObject)',
        since: 5
      },
      {
        signature: 'void DrawObject(RhinoObject rhinoObject,Transform xform)',
        summary: 'Draws a DocObjects.RhinoObject with an applied transformation.',
        since: 5,
        parameters: [
          {
            name: 'rhinoObject',
            summary: 'The Rhino object.'
          },
          {
            name: 'xform',
            summary: 'The transformation.'
          }
        ]
      },
      {
        signature: 'void DrawParticles(ParticleSystem particles)',
        since: 5
      },
      {
        signature: 'void DrawParticles(ParticleSystem particles,DisplayBitmap bitmap)',
        since: 5
      },
      {
        signature: 'void DrawParticles(ParticleSystem particles,DisplayBitmap[] bitmaps)',
        since: 5
      },
      {
        signature: 'void DrawPatternedLine(Line line,Color color,int pattern,int thickness)',
        summary: 'Draws a single line with specified pattern.',
        since: 6,
        parameters: [
          {
            name: 'line',
            summary: 'Line to draw.'
          },
          {
            name: 'color',
            summary: 'Color of line.'
          },
          {
            name: 'pattern',
            summary: 'Pattern of the line (like 0x00001111 for dotted line).'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of lines.'
          }
        ]
      },
      {
        signature: 'void DrawPatternedLine(Point3d from,Point3d to,Color color,int pattern,int thickness)',
        summary: 'Draws a single line with specified pattern.',
        since: 6,
        parameters: [
          {
            name: 'from',
            summary: 'Line start point.'
          },
          {
            name: 'to',
            summary: 'Line end point.'
          },
          {
            name: 'color',
            summary: 'Color of line.'
          },
          {
            name: 'pattern',
            summary: 'Pattern of the line (like 0x00001111 for dotted line).'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of lines.'
          }
        ]
      },
      {
        signature: 'void DrawPatternedPolyline(IEnumerable<Point3d> points,Color color,int pattern,int thickness,bool close)',
        summary: 'Draws a set of connected lines (polyline) with specified pattern.',
        since: 6,
        parameters: [
          {
            name: 'points',
            summary: 'End points of each line segment.'
          },
          {
            name: 'color',
            summary: 'Color of polyline.'
          },
          {
            name: 'pattern',
            summary: 'Pattern to use for the line (like 0x00001111 for dotted).'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of lines.'
          },
          {
            name: 'close',
            summary: 'Draw a line between the first and last points.'
          }
        ]
      },
      {
        signature: 'void DrawPoint(Point3d point)',
        summary: 'Draws a point using the current display attribute size, style and color',
        since: 6,
        parameters: [
          {
            name: 'point',
            summary: 'Location of point in world coordinates.'
          }
        ]
      },
      {
        signature: 'void DrawPoint(Point3d point,Color color)',
        summary: 'Draws a point with a given radius, style and color.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Location of point in world coordinates.'
          },
          {
            name: 'color',
            summary: 'Color of point.'
          }
        ]
      },
      {
        signature: 'void DrawPoint(Point3d point,PointStyle style,Color strokeColor,Color fillColor,float radius,float strokeWidth,float secondarySize,float rotationRadians,bool diameterIsInPixels,bool autoScaleForDpi)',
        since: 6
      },
      {
        signature: 'void DrawPoint(Point3d point,PointStyle style,float radius,Color color)',
        summary: 'Draws a point with a given radius, style and color.',
        since: 6,
        parameters: [
          {
            name: 'point',
            summary: 'Location of point in world coordinates.'
          },
          {
            name: 'style',
            summary: 'Point display style.'
          },
          {
            name: 'radius',
            summary: 'Point size in pixels.'
          },
          {
            name: 'color',
            summary: 'Color of point. If style is ControlPoint, this will be the border color.'
          }
        ]
      },
      {
        signature: 'void DrawPoint(Point3d point,PointStyle style,int radius,Color color)',
        summary: 'Draws a point with a given radius, style and color.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Location of point in world coordinates.'
          },
          {
            name: 'style',
            summary: 'Point display style.'
          },
          {
            name: 'radius',
            summary: 'Point size in pixels.'
          },
          {
            name: 'color',
            summary: 'Color of point. If style is ControlPoint, this will be the border color.'
          }
        ]
      },
      {
        signature: 'void DrawPointCloud(PointCloud cloud,float size)',
        summary: 'Draws a point cloud.',
        since: 6,
        parameters: [
          {
            name: 'cloud',
            summary: 'Point cloud to draw, if the cloud has a color array, it will be used, otherwise the points will be black.'
          },
          {
            name: 'size',
            summary: 'Size of points.'
          }
        ]
      },
      {
        signature: 'void DrawPointCloud(PointCloud cloud,float size,Color color)',
        summary: 'Draws a point cloud.',
        since: 6,
        parameters: [
          {
            name: 'cloud',
            summary: 'Point cloud to draw.'
          },
          {
            name: 'size',
            summary: 'Size of points.'
          },
          {
            name: 'color',
            summary: 'Color of points in the cloud, if the cloud has a color array this setting is ignored.'
          }
        ]
      },
      {
        signature: 'void DrawPointCloud(PointCloud cloud,int size)',
        summary: 'Draws a point cloud.',
        since: 5,
        parameters: [
          {
            name: 'cloud',
            summary: 'Point cloud to draw, if the cloud has a color array, it will be used, otherwise the points will be black.'
          },
          {
            name: 'size',
            summary: 'Size of points.'
          }
        ]
      },
      {
        signature: 'void DrawPointCloud(PointCloud cloud,int size,Color color)',
        summary: 'Draws a point cloud.',
        since: 5,
        parameters: [
          {
            name: 'cloud',
            summary: 'Point cloud to draw.'
          },
          {
            name: 'size',
            summary: 'Size of points.'
          },
          {
            name: 'color',
            summary: 'Color of points in the cloud, if the cloud has a color array this setting is ignored.'
          }
        ]
      },
      {
        signature: 'void DrawPoints(IEnumerable<Point3d> points,PointStyle style,Color strokeColor,Color fillColor,float radius,float strokeWidth,float secondarySize,float rotationRadians,bool diameterIsInPixels,bool autoScaleForDpi)',
        since: 6
      },
      {
        signature: 'void DrawPoints(IEnumerable<Point3d> points,PointStyle style,float radius,Color color)',
        summary: 'Draw a set of points with a given radius, style and color.',
        since: 6,
        parameters: [
          {
            name: 'points',
            summary: 'Location of points in world coordinates.'
          },
          {
            name: 'style',
            summary: 'Point display style.'
          },
          {
            name: 'radius',
            summary: 'Point size in pixels.'
          },
          {
            name: 'color',
            summary: 'Color of points. If style is ControlPoint, this will be the border color.'
          }
        ]
      },
      {
        signature: 'void DrawPoints(IEnumerable<Point3d> points,PointStyle style,int radius,Color color)',
        summary: 'Draw a set of points with a given radius, style and color.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Location of points in world coordinates.'
          },
          {
            name: 'style',
            summary: 'Point display style.'
          },
          {
            name: 'radius',
            summary: 'Point size in pixels.'
          },
          {
            name: 'color',
            summary: 'Color of points. If style is ControlPoint, this will be the border color.'
          }
        ]
      },
      {
        signature: 'void DrawPolygon(IEnumerable<Point3d> points,Color color,bool filled)',
        summary: 'Draws a filled, convex polygon from a collection of points.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: `Collection of world coordinate points that are connected by lines to form a closed shape. 
     Collection must contain at least 3 points.`
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          },
          {
            name: 'filled',
            summary: `True if the closed area should be filled with color. 
     False if you want to draw just the border of the closed shape.`
          }
        ]
      },
      {
        signature: 'void DrawPolyline(IEnumerable<Point3d> polyline,Color color)',
        summary: 'Draws a single Polyline object.',
        since: 5,
        parameters: [
          {
            name: 'polyline',
            summary: 'Polyline to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw in.'
          }
        ]
      },
      {
        signature: 'void DrawPolyline(IEnumerable<Point3d> polyline,Color color,int thickness)',
        summary: 'Draws a single Polyline object.',
        since: 5,
        parameters: [
          {
            name: 'polyline',
            summary: 'Polyline to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw in.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of the Polyline.'
          }
        ]
      },
      {
        signature: 'void DrawRoundedRectangle(PointF center,float pixelWidth,float pixelHeight,float cornerRadius,Color strokeColor,float strokeWidth,Color fillColor)',
        since: 6
      },
      {
        signature: 'void DrawSphere(Sphere sphere,Color color)',
        summary: 'Draw a wireframe sphere.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'Sphere to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          }
        ]
      },
      {
        signature: 'void DrawSphere(Sphere sphere,Color color,int thickness)',
        summary: 'Draw a wireframe sphere.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'Sphere to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of Sphere wires.'
          }
        ]
      },
      {
        signature: 'void DrawSprite(DisplayBitmap bitmap,Point2d screenLocation,float size)',
        since: 5
      },
      {
        signature: 'void DrawSprite(DisplayBitmap bitmap,Point2d screenLocation,float size,Color blendColor)',
        since: 5
      },
      {
        signature: 'void DrawSprite(DisplayBitmap bitmap,Point3d worldLocation,float size,bool sizeInWorldSpace)',
        since: 5
      },
      {
        signature: 'void DrawSprite(DisplayBitmap bitmap,Point3d worldLocation,float size,Color blendColor,bool sizeInWorldSpace)',
        since: 5
      },
      {
        signature: 'void DrawSprites(DisplayBitmap bitmap,DisplayBitmapDrawList items,float size,bool sizeInWorldSpace)',
        since: 5
      },
      {
        signature: 'void DrawSprites(DisplayBitmap bitmap,DisplayBitmapDrawList items,float size,Vector3d translation,bool sizeInWorldSpace)',
        since: 5
      },
      {
        signature: 'bool DrawStereoFrameBuffer(ViewportInfo viewportLeft,ViewportInfo viewportRight,uint handleLeft,uint handleRight)',
        summary: `Draws the viewport as seen from the left and the right eye viewports
     and returns the result as OpenGL texture handles.`,
        since: 6.8,
        parameters: [
          {
            name: 'viewportLeft',
            summary: 'The viewport representing the left eye location and look direction.'
          },
          {
            name: 'viewportRight',
            summary: 'The viewport representing the right eye location and look direction.'
          },
          {
            name: 'handleLeft',
            summary: 'Will contain the OpenGL texture handle which references the left output color buffer.'
          },
          {
            name: 'handleRight',
            summary: 'Will contain the OpenGL texture handle which references the right output color buffer.'
          }
        ],
        returns: 'True if drawing succedded, False otherwise.'
      },
      {
        signature: 'void DrawSubDShaded(SubD subd,DisplayMaterial material)',
        summary: 'Draw a shaded mesh representation of a SubD',
        since: 7,
        parameters: [
          {
            name: 'subd',
            summary: 'SubD to draw'
          },
          {
            name: 'material',
            summary: 'Material to draw faces with'
          }
        ]
      },
      {
        signature: 'void DrawSubDWires(SubD subd,Color color,float thickness)',
        summary: 'Draws all the wireframe curves of a SubD object',
        since: 7,
        parameters: [
          {
            name: 'subd',
            summary: 'SubD to draw'
          },
          {
            name: 'color',
            summary: 'wire color'
          },
          {
            name: 'thickness',
            summary: 'wire thickness'
          }
        ]
      },
      {
        signature: 'void DrawSurface(Surface surface,Color wireColor,int wireDensity)',
        summary: 'Draw wireframe display for a single surface.',
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'Surface to draw.'
          },
          {
            name: 'wireColor',
            summary: 'Color to draw with.'
          },
          {
            name: 'wireDensity',
            summary: 'Thickness (in pixels) or wires to draw.'
          }
        ]
      },
      {
        signature: 'void DrawText(TextEntity text,Color color)',
        since: 6
      },
      {
        signature: 'void DrawText(TextEntity text,Color color,double scale)',
        since: 6
      },
      {
        signature: 'void DrawText(TextEntity text,Color color,Transform xform)',
        since: 6
      },
      {
        signature: 'void DrawTorus(Torus torus,Color color)',
        summary: 'Draw a wireframe torus.',
        since: 5,
        parameters: [
          {
            name: 'torus',
            summary: 'Torus to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          }
        ]
      },
      {
        signature: 'void DrawTorus(Torus torus,Color color,int thickness)',
        summary: 'Draw a wireframe torus.',
        since: 5,
        parameters: [
          {
            name: 'torus',
            summary: 'Torus to draw.'
          },
          {
            name: 'color',
            summary: 'Color to draw with.'
          },
          {
            name: 'thickness',
            summary: 'Thickness (in pixels) of torus wires.'
          }
        ]
      },
      {
        signature: 'void DrawZebraPreview(Brep brep,Color color)',
        summary: 'Draws a shaded Brep with Zebra stripe preview.',
        since: 6.16,
        parameters: [
          {
            name: 'brep',
            summary: 'Brep to draw.'
          },
          {
            name: 'color',
            summary: 'Object color.'
          }
        ]
      },
      {
        signature: 'void EnableClippingPlanes(bool enable)',
        summary: 'Enable or disable the Clipping Plane logic of the engine.',
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'True to enable Clipping Planes, False to disable.'
          }
        ]
      },
      {
        signature: 'void EnableColorWriting(bool enable)',
        summary: 'Enable or disable the ColorWriting behaviour of the engine.',
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'True to enable ColorWriting, False to disable.'
          }
        ]
      },
      {
        signature: 'void EnableDepthTesting(bool enable)',
        summary: `Enable or disable the DepthTesting behaviour of the engine. 
     When DepthTesting is disabled, objects in front will no 
     longer occlude objects behind them.`,
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'True to enable DepthTesting, False to disable.'
          }
        ]
      },
      {
        signature: 'void EnableDepthWriting(bool enable)',
        summary: `Enable or disable the DepthWriting behaviour of the engine. 
     When DepthWriting is disabled, drawn geometry does not affect the Z-Buffer.`,
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'True to enable DepthWriting, False to disable.'
          }
        ]
      },
      {
        signature: 'void EnableLighting(bool enable)',
        summary: 'Enable or disable the Lighting logic of the engine.',
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'True to enable Lighting, False to disable.'
          }
        ]
      },
      {
        signature: 'Light[] GetLights()',
        summary: 'Get lights that this pipeline is current using',
        since: 6.3
      },
      {
        signature: 'float[] GetOpenGLCameraToClip()',
        summary: `Get an array of 16 floats that represents the "camera" to "clip" coordinate
     transformation in OpenGL's right handed coordinate system`,
        since: 6
      },
      {
        signature: 'float[] GetOpenGLWorldToCamera(bool includeModelTransform)',
        summary: `Get an array of 16 floats that represents the "world" to "camera" coordinate
     transformation in OpenGL's right handed coordinate system`,
        since: 6
      },
      {
        signature: 'float[] GetOpenGLWorldToClip(bool includeModelTransform)',
        summary: `Get an array of 16 floats that represents the "world" to "clip" coordinate
     transformation in OpenGL's right handed coordinate system`,
        since: 6
      },
      {
        signature: 'bool InterruptDrawing()',
        summary: `Tests to see if the pipeline should stop drawing more geometry and just show what it has so far. 
     If a drawing operation is taking a long time, this function will return True and tell Rhino it should just 
     finish up and show the frame buffer. This is used in dynamic drawing operations.`,
        since: 5,
        returns: 'True if the pipeline should stop attempting to draw more geometry and just show the frame buffer.'
      },
      {
        signature: 'bool IsActive(RhinoObject rhinoObject)',
        summary: `Determines if an object can be visible in this viewport based on it's object type and display attributes. 
     This test does not check for visibility based on location of the object. 
     NOTE: Use CRhinoDisplayPipeline::IsVisible() to perform "visibility" 
           tests based on location (is some part of the object in the view frustum). 
           Use CRhinoDisplayPipeline::IsActive() to perform "visibility" 
           tests based on object type.`,
        since: 5,
        parameters: [
          {
            name: 'rhinoObject',
            summary: 'Object to test.'
          }
        ],
        returns: 'True if this object can be drawn in the pipeline\'s viewport based on it\'s object type and display attributes.'
      },
      {
        signature: 'bool IsVisible(BoundingBox bbox)',
        summary: `Test a given box for visibility inside the view frustum under the current 
     viewport and model transformation settings.`,
        since: 5,
        parameters: [
          {
            name: 'bbox',
            summary: 'Box to test for visibility.'
          }
        ],
        returns: 'True if at least some portion of the box is visible, False if not.'
      },
      {
        signature: 'bool IsVisible(Point3d worldCoordinate)',
        summary: `Test a given 3d world coordinate point for visibility inside the view 
     frustum under the current viewport and model transformation settings.`,
        since: 5,
        parameters: [
          {
            name: 'worldCoordinate',
            summary: 'Point to test for visibility.'
          }
        ],
        returns: 'True if the point is visible, False if it is not.'
      },
      {
        signature: 'bool IsVisible(RhinoObject rhinoObject)',
        summary: `Test a given object for visibility inside the view frustum under the current viewport and model 
     transformation settings. This function calls a virtual IsVisibleFinal function that 
     subclassed pipelines can add extra tests to. In the base class, this test only tests 
     visibility based on the objects world coordinates location and does not pay attention 
     to the object's attributes.
     
     NOTE: Use CRhinoDisplayPipeline::IsVisible() to perform "visibility" 
           tests based on location (is some part of the object in the view frustum). 
           Use CRhinoDisplayPipeline::IsActive() to perform "visibility" 
           tests based on object type.`,
        since: 5,
        parameters: [
          {
            name: 'rhinoObject',
            summary: 'Object to test.'
          }
        ],
        returns: 'True if the object is visible, False if not.'
      },
      {
        signature: 'System.Drawing.Rectangle Measure2dText(string text,Point2d definitionPoint,bool middleJustified,double rotationRadians,int height,string fontFace)',
        summary: `Determines screen rectangle that would be drawn to using the Draw2dText(..) function
     with the same parameters.`,
        since: 5.1,
        parameters: [
          {
            name: 'text',
            summary: 'text to measure.'
          },
          {
            name: 'definitionPoint',
            summary: 'either lower-left or middle of text.'
          },
          {
            name: 'middleJustified',
            summary: 'true=middle justified. false=lower-left justified.'
          },
          {
            name: 'rotationRadians',
            summary: 'text rotation in radians'
          },
          {
            name: 'height',
            summary: 'height in pixels (good default is 12)'
          },
          {
            name: 'fontFace',
            summary: 'font name (good default is "Arial")'
          }
        ],
        returns: 'rectangle in the viewport\'s screen coordinates on success.'
      },
      {
        signature: 'bool Open()',
        summary: 'Opens the pipeline.',
        since: 7,
        returns: `True if the pipeline was opened, False if it was already open
     or failed to open.`
      },
      {
        signature: 'void PopClipTesting()',
        summary: 'Pop a ClipTesting flag off the engine\'s stack.',
        since: 5
      },
      {
        signature: 'void PopCullFaceMode()',
        summary: 'Pop a FaceCull flag off the engine\'s stack.',
        since: 5
      },
      {
        signature: 'void PopDepthTesting()',
        summary: 'Pop a DepthTesting flag off the engine\'s stack.',
        since: 5
      },
      {
        signature: 'void PopDepthWriting()',
        summary: 'Pop a DepthWriting flag off the engine\'s stack.',
        since: 5
      },
      {
        signature: 'void PopModelTransform()',
        summary: 'Pop a model transformation off the engine\'s model transform stack.',
        since: 5
      },
      {
        signature: 'void PushClipTesting(bool enable)',
        summary: 'Push a ClipTesting flag on the engine\'s stack.',
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'ClipTesting flag.'
          }
        ]
      },
      {
        signature: 'void PushCullFaceMode(CullFaceMode mode)',
        summary: 'Push a FaceCull flag on the engine\'s stack.',
        since: 5,
        parameters: [
          {
            name: 'mode',
            summary: 'FaceCull flag.'
          }
        ]
      },
      {
        signature: 'void PushDepthTesting(bool enable)',
        summary: 'Push a DepthTesting flag on the engine\'s stack.',
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'DepthTesting flag.'
          }
        ]
      },
      {
        signature: 'void PushDepthWriting(bool enable)',
        summary: 'Push a DepthWriting flag on the engine\'s stack.',
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'DepthWriting flag.'
          }
        ]
      },
      {
        signature: 'void PushModelTransform(Transform xform)',
        summary: 'Push a model transformation on the engine\'s model transform stack.',
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation to push.'
          }
        ]
      },
      {
        signature: 'void RemoveClippingPlane(int index)',
        summary: 'Remove a clipping plane from the pipeline for this frame',
        since: 6.3
      }
    ],
    events: [
      {
        signature: 'static CalculateBoundingBox',
        since: 5
      },
      {
        signature: 'static CalculateBoundingBoxZoomExtents',
        summary: 'Calculate a bounding to include in the Zoom Extents command.',
        since: 5
      },
      {
        signature: 'static DisplayModeChanged',
        since: 6.18
      },
      {
        signature: 'static DrawForeground',
        summary: `Called after all non-highlighted objects have been drawn and PostDrawObjects has been called.
     Depth writing and testing are turned OFF. If you want to draw with depth writing/testing,
     see PostDrawObjects.`,
        since: 5
      },
      {
        signature: 'static DrawOverlay',
        summary: `If Rhino is in a feedback mode, the draw overlay call allows for temporary geometry to be drawn on top of
     everything in the scene. This is similar to the dynamic draw routine that occurs with custom get point.`,
        since: 5
      },
      {
        signature: 'static InitFrameBuffer',
        since: 6.18
      },
      {
        signature: 'static ObjectCulling',
        since: 5.3
      },
      {
        signature: 'static PostDrawObjects',
        summary: `Called after all non-highlighted objects have been drawn. Depth writing and testing are
     still turned on. If you want to draw without depth writing/testing, see DrawForeground.`,
        since: 5
      },
      {
        signature: 'static PreDrawObject',
        summary: `Called right before an individual object is being drawn. NOTE: Do not use this event
     unless you absolutely need to.  It is called for every object in the document and can
     slow disply down if a large number of objects exist in the document`,
        since: 5
      },
      {
        signature: 'static PreDrawObjects',
        summary: 'Called before objects are been drawn. Depth writing and testing are on.',
        since: 5
      },
      {
        signature: 'static PreDrawTransparentObjects',
        summary: 'Called before transparent objects have been drawn. Depth writing and testing are on.',
        since: 6.12
      },
      {
        signature: 'static ViewportProjectionChanged',
        summary: 'Called when the projection changes for a viewport being drawn.',
        since: 6.18
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayPipelineAttributes',
    dataType: 1,
    summary: 'Represents display pipeline settings, such as "show transparency" and "show grips".',
    interfaces: ['IDisposable', 'ISerializable'],
    properties: [
      {
        signature: 'Color AmbientLightingColor',
        since: 6.3,
        property: ['get', 'set']
      },
      {
        signature: 'BoundingBoxDisplayMode BoundingBoxMode',
        since: 6.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool CastShadows',
        summary: 'Cast shadows.',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'ContextsForDraw ContextForDraw',
        since: 6.5,
        property: ['get']
      },
      {
        signature: 'Color CurveColor',
        summary: 'Color used for drawing curves',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'int CurveThickness',
        summary: 'Pixel thickness for curves',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool DisableConduits',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DisableTransparency',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string EnglishName',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'FrameBufferFillMode FillMode',
        summary: 'Get or set the frame buffer fill mode.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Guid Id',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IgnoreHighlights',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string LocalName',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool LockedObjectsDrawBehindOthers',
        summary: 'Locked object are drawn behind other objects',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'MeshDisplayAttributes MeshSpecificAttributes',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Color ObjectColor',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'float PointRadius',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'PointStyle PointStyle',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Guid RealtimeDisplayId',
        summary: `Get the ID of the realtime display engine attached to the view. This will be
     Guid.Empty if no realtime display engine is in use. This can be the case for instance
     when starting a _Render session for a realtime viewport integration. That still would
     cause this ID to be Guid.Empty.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'int RealtimeRenderPasses',
        summary: 'Get or set the realtime passes amount',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShadeVertexColors',
        summary: 'Shade using vertex colors.',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShadingEnabled',
        summary: 'Draw shaded meshes and surfaces. Set to False to use Flat Shading.',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Color ShadowColor',
        since: 6.3,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowAnnotations',
        summary: 'Show annotations.',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowClippingPlanes',
        summary: 'Show clipping planes.',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowCurves',
        summary: 'Draw curves',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowGrips',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowIsoCurves',
        summary: 'Draw surface ISO curves.',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowLights',
        summary: 'Show light widgets.',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowPointClouds',
        summary: 'Show point clouds.',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowPoints',
        summary: 'Show points.',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowRealtimeRenderProgressBar',
        summary: 'Get or set whether the display is used for preview rendering or not.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowSurfaceEdges',
        summary: 'Show surface edges.',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowTangentEdges',
        summary: 'Show tangent edges.',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowTangentSeams',
        summary: 'Show tangent seams.',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowText',
        summary: 'Show text.',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'StereoRenderContextEnum StereoRenderContext',
        summary: 'Get or set the stereo render context.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'int SurfaceEdgeThickness',
        summary: 'Thickness for surface edges',
        since: 6.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool UseAssignedObjectMaterial',
        summary: 'Gets whether objects ought to be drawn using their assigned rendering material.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool UseCustomObjectColor',
        summary: 'Gets whether objects ought to be drawn using a custom color.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool UseCustomObjectMaterial',
        summary: 'Gets whether objects ought to be drawn using a custom material.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool UseSingleCurveColor',
        summary: 'Use a single color for drawing curves',
        since: 6.3,
        property: ['get', 'set']
      },
      {
        signature: 'ViewDisplayAttributes ViewSpecificAttributes',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool XrayAllObjects',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'void GetFill(Color topLeft,Color bottomLeft,Color topRight,Color bottomRight)',
        summary: 'Get fill colors used for clearing the frame buffer',
        since: 6.23
      },
      {
        signature: 'void GetObjectData(SerializationInfo info,StreamingContext context)',
        since: 5
      },
      {
        signature: 'void SetFill(Color singleColor)',
        summary: 'Set fill mode to solid color and set the fill color',
        since: 6.23
      },
      {
        signature: 'void SetFill(Color gradientTop,Color gradientBottom)',
        summary: 'Set fill mode to two color and set the colors',
        since: 6.23
      },
      {
        signature: 'void SetFill(Color gradientTopLeft,Color gradientBottomLeft,Color gradientTopRight,Color gradientBottomRight)',
        summary: 'Set the fill mode to four color gradient and set the colors',
        since: 6.23
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayPipelineAttributes.BoundingBoxDisplayMode',
    dataType: 3,
    values: [
      {
        signature: 'None = UnsafeNativeMethods.DisplayPipelineAttributesBBox.BBoxOff'
      },
      {
        signature: 'OnDuringDynamicDisplay = UnsafeNativeMethods.DisplayPipelineAttributesBBox.BBoxOnDynamicDisplay'
      },
      {
        signature: 'OnAlways = UnsafeNativeMethods.DisplayPipelineAttributesBBox.BBoxOnAlways'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayPipelineAttributes.ContextsForDraw',
    dataType: 3,
    values: [
      {
        signature: 'Unset = 0'
      },
      {
        signature: 'FilePreview = 1'
      },
      {
        signature: 'ViewCapture = 2'
      },
      {
        signature: 'Printing = 3'
      },
      {
        signature: 'UIPreview = 4'
      },
      {
        signature: 'Mask = 5'
      },
      {
        signature: 'RenderOverlays = 6'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayPipelineAttributes.FrameBufferFillMode',
    dataType: 3,
    values: [
      {
        signature: 'DefaultColor = UnsafeNativeMethods.FrameBufferFillMode.DEFAULT_COLOR'
      },
      {
        signature: 'SolidColor = UnsafeNativeMethods.FrameBufferFillMode.SOLID_COLOR'
      },
      {
        signature: 'Gradient2Color = UnsafeNativeMethods.FrameBufferFillMode.GRADIENT_2_COLOR'
      },
      {
        signature: 'Gradient4Color = UnsafeNativeMethods.FrameBufferFillMode.GRADIENT_4_COLOR'
      },
      {
        signature: 'Bitmap = UnsafeNativeMethods.FrameBufferFillMode.BITMAP'
      },
      {
        signature: 'Renderer = UnsafeNativeMethods.FrameBufferFillMode.RENDERER'
      },
      {
        signature: 'Transparent = UnsafeNativeMethods.FrameBufferFillMode.TRANSPARENT'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayPipelineAttributes.MeshDisplayAttributes',
    dataType: 1,
    properties: [
      {
        signature: 'Color AllMeshWiresColor',
        summary: 'Color.Empty means that we are NOT using a single color for all mesh wires.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool HighlightMeshes',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int MeshWireThickness',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowMeshVertices',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowMeshWires',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayPipelineAttributes.StereoRenderContextEnum',
    dataType: 3,
    values: [
      {
        signature: 'NotApplicable = 0'
      },
      {
        signature: 'RenderingLeftEye = 1'
      },
      {
        signature: 'RenderingRightEye = 2'
      },
      {
        signature: 'RenderingBothEyes = 3'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DisplayPipelineAttributes.ViewDisplayAttributes',
    dataType: 1,
    properties: [
      {
        signature: 'bool BlendGrid',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawGrid',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawGridAxes',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawTransparentGridPlane',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawWorldAxes',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawZAxis',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double HorizontalViewportScale',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowGridOnTop',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool UseDocumentGrid',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double VerticalViewportScale',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color WorldAxisColorX',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color WorldAxisColorY',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color WorldAxisColorZ',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DrawEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'DisplayPipeline Display',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoDoc RhinoDoc',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoViewport Viewport',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DrawForegroundEventArgs',
    dataType: 1,
    baseclass: 'Rhino.Display.DrawEventArgs',
    properties: [
      {
        signature: 'bool DrawWorldAxes',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool WorldAxesDrawn',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DrawFrameStages',
    dataType: 3,
    values: [
      {
        signature: 'InitializeFrameBuffer = 0x00000001'
      },
      {
        signature: 'SetupFrustum = 0x00000002'
      },
      {
        signature: 'ObjectCulling = 0x00000004'
      },
      {
        signature: 'CalculateBoundingBox = 0x00000008'
      },
      {
        signature: 'CalculateClippingPlanes = 0x00000010'
      },
      {
        signature: 'SetupLighting = 0x00000020'
      },
      {
        signature: 'DrawBackground = 0x00000040'
      },
      {
        signature: 'PreDrawObjects = 0x00000080'
      },
      {
        signature: 'DrawObject = 0x00000100'
      },
      {
        signature: 'PostDrawObjects = 0x00000200'
      },
      {
        signature: 'DrawForeGround = 0x00000400'
      },
      {
        signature: 'DrawOverlay = 0x00000800'
      },
      {
        signature: 'PostProcessFrameBuffer = 0x00001000'
      },
      {
        signature: 'MeshingParameters = 0x00002000'
      },
      {
        signature: 'ObjectDisplayAttributes = 0x00004000'
      },
      {
        signature: 'PreObjectDraw = 0x00008000'
      },
      {
        signature: 'PostObjectDraw = 0x00010000'
      },
      {
        signature: 'ViewExtents = 0x00020000'
      },
      {
        signature: 'DrawMiddleGround = PreDrawObjects | DrawObject | PostDrawObjects'
      },
      {
        signature: 'ObjectBasedChannel = ObjectCulling | DrawObject | ObjectDisplayAttributes | PreObjectDraw | PostObjectDraw'
      },
      {
        signature: 'All = 0xFFFFFFFF & ~ViewExtents'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'DrawObjectEventArgs',
    dataType: 1,
    baseclass: 'Rhino.Display.DrawEventArgs',
    properties: [
      {
        signature: 'bool DrawObject',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'RhinoObject RhinoObject',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'GradientType',
    dataType: 3,
    summary: 'Style of color gradient',
    values: [
      {
        signature: 'None = 0',
        summary: 'No gradient'
      },
      {
        signature: 'Linear = 1',
        summary: 'Linear (or axial) gradient between two points'
      },
      {
        signature: 'Radial = 2',
        summary: 'Radial (or spherical) gradient using a center point and a radius'
      },
      {
        signature: 'LinearDisabled = 3',
        summary: 'Disabled linear gradient. Useful for keeping gradient information around, but not having it displayed'
      },
      {
        signature: 'RadialDisabled = 4',
        summary: 'Disabled radial gradient. Useful for keeping gradient information around, but not having it displayed'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'InitFrameBufferEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    methods: [
      {
        signature: 'void SetFill(Color color)',
        since: 6.18
      },
      {
        signature: 'void SetFill(Color top,Color bottom)',
        since: 6.18
      },
      {
        signature: 'void SetFill(Color topLeft,Color bottomLeft,Color topRight,Color bottomRight)',
        since: 6.18
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'PageViewSpaceChangeEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'Guid NewActiveDetailId',
        summary: `The id of the detail object was set active.  Note, if this id is
     equal to Guid.Empty, then the active detail object is the page
     view itself.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Guid OldActiveDetailId',
        summary: `The id of the previously active detail object. Note, if this id
     is equal to Guid.Empty, then the active detail object was the
     page view itself.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'RhinoPageView PageView',
        summary: 'The page view on which a different detail object was set active.',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'PointStyle',
    dataType: 3,
    summary: 'Defines styles used for drawing points.',
    values: [
      {
        signature: 'Simple = 0',
        summary: 'Square'
      },
      {
        signature: 'ControlPoint = 1',
        summary: 'Square with white center'
      },
      {
        signature: 'ActivePoint = 2',
        summary: 'Like a control point but includes vertical/horizontal crosshair lines.'
      },
      {
        signature: 'X = 3',
        summary: 'X shape'
      },
      {
        signature: 'RoundSimple = 4',
        summary: 'Circular'
      },
      {
        signature: 'RoundControlPoint = 5',
        summary: 'Circular with white center'
      },
      {
        signature: 'RoundActivePoint = 6',
        summary: 'Round control point with crosshair lines'
      },
      {
        signature: 'Circle = RoundSimple',
        summary: 'Circle or ring shape when secondarySize is set'
      },
      {
        signature: 'Square = Simple',
        summary: 'Square or diamond shape when rotated'
      },
      {
        signature: 'Triangle = 7',
        summary: 'Triangular shape'
      },
      {
        signature: 'Heart = 8',
        summary: 'Heart shape'
      },
      {
        signature: 'Chevron = 9',
        summary: 'Chevron shape (two directional arrows)'
      },
      {
        signature: 'Clover = 10',
        summary: 'Three unioned circles'
      },
      {
        signature: 'Tag = 11',
        summary: 'Tag shape'
      },
      {
        signature: 'Asterisk = 12',
        summary: '* shape'
      },
      {
        signature: 'Pin = 13',
        summary: 'Map style pin symbol. secondarySize defines hole zie in pin'
      },
      {
        signature: 'ArrowTail = 14',
        summary: 'Arrow shape with tail as definition point. Shape is offset from tail by secondarySize.'
      },
      {
        signature: 'ArrowTip = 15',
        summary: 'Arrow shape with tip as definition point. Shape is offset from tip by secondarySize.'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'RhinoPageView',
    dataType: 1,
    summary: 'A window that contains a single layout \'page\'',
    baseclass: 'Rhino.Display.RhinoView',
    properties: [
      {
        signature: 'RhinoViewport ActiveViewport',
        summary: `The ActiveViewport is the same as the MainViewport for standard RhinoViews. In
     a RhinoPageView, the active viewport may be the RhinoViewport of a child detail object.
     Most of the time, you will use ActiveViewport unless you explicitly need to work with
     the main viewport.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double PageHeight',
        summary: 'Height of the page in the document\'s PageUnitSystem',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool PageIsActive',
        summary: `True if the page is active instead of any detail views. This occurs
     when the MainViewport.Id == ActiveViewportID.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'string PageName',
        summary: 'Same as the MainViewport.Name.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int PageNumber',
        summary: `Gets or sets the runtime page number and updates the page number for all
     of the other pages. The first page has a value of 0.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PageWidth',
        summary: 'Width of the page in the document\'s PageUnitSystem',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'string PaperName',
        summary: `Returns the name of the layout's media, or paper (e.g. Letter, Legal, A1, etc.),
     used to determine the page width and page height.`,
        since: 6.15,
        property: ['get']
      },
      {
        signature: 'string PrinterName',
        summary: 'Returns the name of the layout\'s destination printer.',
        since: 6.15,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'DetailViewObject AddDetailView(string title,Point2d corner0,Point2d corner1,DefinedViewportProjection initialProjection)',
        summary: 'Creates a detail view object that is displayed on this page and adds it to the doc.',
        since: 5,
        parameters: [
          {
            name: 'title',
            summary: 'The detail view title.'
          },
          {
            name: 'corner0',
            summary: 'Corners of the detail view in world coordinates.'
          },
          {
            name: 'corner1',
            summary: 'Corners of the detail view in world coordinates.'
          },
          {
            name: 'initialProjection',
            summary: 'The defined initial projection type.'
          }
        ],
        returns: 'Newly created detail view on success. None on error.'
      },
      {
        signature: 'RhinoPageView Duplicate(bool duplicatePageGeometry)',
        summary: 'Copy a page view',
        since: 6.3
      },
      {
        signature: 'DetailViewObject[] GetDetailViews()',
        summary: 'Gets a list of the detail view objects associated with this layout.',
        since: 5,
        returns: 'An array of detail view objects if successful, an empty array if the layout has no details.'
      },
      {
        signature: 'System.Drawing.Bitmap GetPreviewImage(Size size,bool grayScale)',
        summary: 'Creates a preview image of the page.',
        since: 7,
        parameters: [
          {
            name: 'size',
            summary: 'The size of the preview image.'
          },
          {
            name: 'grayScale',
            summary: 'Set True to produce a grayscale image, False to produce a color image.'
          }
        ],
        returns: 'A bitmap if successful, None othewise.'
      },
      {
        signature: 'bool SetActiveDetail(Guid detailId)',
        since: 5
      },
      {
        signature: 'bool SetActiveDetail(string detailName,bool compareCase)',
        since: 5
      },
      {
        signature: 'void SetPageAsActive()',
        since: 5
      }
    ],
    events: [
      {
        signature: 'static PageViewSpaceChange',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'RhinoView',
    dataType: 1,
    summary: `A RhinoView represents a single "window" display of a document. A view could
   contain one or many RhinoViewports (many in the case of Layout views with detail viewports).
   Standard Rhino modeling views have one viewport.`,
    properties: [
      {
        signature: 'static bool EnableDrawing',
        summary: `Gets or sets the 'drawing enabled' flag. By default, drawing is enabled.
     There are some rare situations where scipts want to disable drawing for a while.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'RhinoViewport ActiveViewport',
        summary: `The ActiveViewport is the same as the MainViewport for standard RhinoViews. In
     a RhinoPageView, the active viewport may be the RhinoViewport of a child detail object.
     Most of the time, you will use ActiveViewport unless you explicitly need to work with
     the main viewport.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid ActiveViewportID',
        summary: `Returns viewport ID for the active viewport. Faster than ActiveViewport function when
     working with page views.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Rectangle Bounds',
        summary: 'Gets the size and location of the view including its nonclient elements, in pixels, relative to the parent control.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Rectangle ClientRectangle',
        summary: 'Gets the rectangle that represents the client area of the view.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'DisplayPipeline DisplayPipeline',
        summary: 'Gets the display pipeline used for this view.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool Floating',
        summary: `Floating state of RhinoView.
     if true, then the view will be in a floating frame window. Otherwise
     the view will be embeded in the main frame.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'IntPtr Handle',
        summary: 'Gets the window handle that this view is bound to.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsPageView',
        summary: 'Return True if this view is a RhinoPageView.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'RhinoViewport MainViewport',
        summary: `A RhinoView contains a "main viewport" that fills the entire view client window.
     RhinoPageViews may also contain nested child RhinoViewports for implementing
     detail viewports.
     The MainViewport will always return this RhinoView's m_vp.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool Maximized',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'RealtimeDisplayMode RealtimeDisplayMode',
        summary: 'Gets the RealtimeDisplayMode active for this view. None if the view doesn\'t have a RealtimeDisplayMode set.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint RuntimeSerialNumber',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Rectangle ScreenRectangle',
        summary: 'Gets the rectangle that represents the client area of the view in screen coordinates.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Size Size',
        summary: 'Gets or sets the size of the view',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool TitleVisible',
        summary: 'Visibility of the viewport title window.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static RhinoView FromRuntimeSerialNumber(uint serialNumber)',
        summary: 'Get a RhinoView from it\'s unique runtime serial number',
        since: 6,
        returns: 'RhinoView or None if no view exists for a given serial number'
      },
      {
        signature: 'System.Drawing.Bitmap CaptureToBitmap()',
        summary: 'Capture View contents to a bitmap.',
        since: 5,
        returns: 'The bitmap of the complete view.'
      },
      {
        signature: 'System.Drawing.Bitmap CaptureToBitmap(bool grid,bool worldAxes,bool cplaneAxes)',
        summary: 'Captures the view contents to a bitmap allowing for visibility of grid and axes.',
        since: 5,
        parameters: [
          {
            name: 'grid',
            summary: 'True if the construction plane grid should be visible.'
          },
          {
            name: 'worldAxes',
            summary: 'True if the world axis should be visible.'
          },
          {
            name: 'cplaneAxes',
            summary: 'True if the construction plane close the the grid should be visible.'
          }
        ],
        returns: 'A new bitmap.'
      },
      {
        signature: 'System.Drawing.Bitmap CaptureToBitmap(DisplayModeDescription mode)',
        summary: `Capture View contents to a bitmap using a display mode description to define
     how drawing is performed.`,
        since: 5,
        parameters: [
          {
            name: 'mode',
            summary: 'The display mode.'
          }
        ],
        returns: 'A new bitmap.'
      },
      {
        signature: 'System.Drawing.Bitmap CaptureToBitmap(DisplayPipelineAttributes attributes)',
        summary: `Captures view contents to a bitmap using display attributes to define how
     drawing is performed.`,
        since: 5,
        parameters: [
          {
            name: 'attributes',
            summary: 'The specific display mode attributes.'
          }
        ],
        returns: 'A new bitmap.'
      },
      {
        signature: 'System.Drawing.Bitmap CaptureToBitmap(Size size)',
        summary: 'Capture View contents to a bitmap.',
        since: 5,
        parameters: [
          {
            name: 'size',
            summary: 'Size of Bitmap to capture to.'
          }
        ],
        returns: 'The bitmap of the specified part of the view.'
      },
      {
        signature: 'System.Drawing.Bitmap CaptureToBitmap(Size size,bool grid,bool worldAxes,bool cplaneAxes)',
        summary: 'Captures a part of the view contents to a bitmap allowing for visibility of grid and axes.',
        since: 5,
        parameters: [
          {
            name: 'size',
            summary: 'The width and height of the returned bitmap.'
          },
          {
            name: 'grid',
            summary: 'True if the construction plane grid should be visible.'
          },
          {
            name: 'worldAxes',
            summary: 'True if the world axis should be visible.'
          },
          {
            name: 'cplaneAxes',
            summary: 'True if the construction plane close the the grid should be visible.'
          }
        ],
        returns: 'A new bitmap.'
      },
      {
        signature: 'System.Drawing.Bitmap CaptureToBitmap(Size size,DisplayModeDescription mode)',
        summary: `Capture View contents to a bitmap using a display mode description to define
     how drawing is performed.`,
        since: 5,
        parameters: [
          {
            name: 'size',
            summary: 'The width and height of the returned bitmap.'
          },
          {
            name: 'mode',
            summary: 'The display mode.'
          }
        ],
        returns: 'A new bitmap.'
      },
      {
        signature: 'System.Drawing.Bitmap CaptureToBitmap(Size size,DisplayPipelineAttributes attributes)',
        summary: `Capture View contents to a bitmap using display attributes to define how
     drawing is performed.`,
        since: 5,
        parameters: [
          {
            name: 'size',
            summary: 'The width and height of the returned bitmap.'
          },
          {
            name: 'attributes',
            summary: 'The specific display mode attributes.'
          }
        ],
        returns: 'A new bitmap.'
      },
      {
        signature: 'System.Drawing.Point ClientToScreen(Point clientPoint)',
        since: 5
      },
      {
        signature: 'Geometry.Point2d ClientToScreen(Point2d clientPoint)',
        since: 5
      },
      {
        signature: 'bool Close()',
        summary: `Remove this View from Rhino. DO NOT attempt to use this instance of this
     class after calling Close.`,
        since: 5,
        returns: 'True on success'
      },
      {
        signature: 'bool CreateShadedPreviewImage(string imagePath,Size size,bool ignoreHighlights,bool drawConstructionPlane,bool useGhostedShading)',
        summary: 'Creates a bitmap preview image of model.',
        since: 5,
        parameters: [
          {
            name: 'imagePath',
            summary: `[in] The name of the bitmap file to create.  The extension of the imagePath controls
    the format of the bitmap file created (bmp, tga, jpg, pcx, png, tif).`
          },
          {
            name: 'size',
            summary: '[in] The width and height of the bitmap in pixels.'
          },
          {
            name: 'ignoreHighlights',
            summary: 'True if highlighted elements should be drawn normally.'
          },
          {
            name: 'drawConstructionPlane',
            summary: 'True if the CPlane should be drawn.'
          },
          {
            name: 'useGhostedShading',
            summary: 'True if ghosted shading (partially transparent shading) should be used.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool CreateWireframePreviewImage(string imagePath,Size size,bool ignoreHighlights,bool drawConstructionPlane)',
        summary: 'Creates a bitmap preview image of model.',
        since: 5,
        parameters: [
          {
            name: 'imagePath',
            summary: `[in] The name of the bitmap file to create.  The extension of the imagePath controls
    the format of the bitmap file created (bmp, tga, jpg, pcx, png, tif).`
          },
          {
            name: 'size',
            summary: '[in] The width and height of the bitmap in pixels.'
          },
          {
            name: 'ignoreHighlights',
            summary: 'True if highlighted elements should be drawn normally.'
          },
          {
            name: 'drawConstructionPlane',
            summary: 'True if the CPlane should be drawn.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Equals(object obj)'
      },
      {
        signature: 'int GetHashCode()'
      },
      {
        signature: 'bool MouseCaptured(bool bIncludeMovement)',
        summary: 'Returns whether or not the mouse is captured in this view.',
        since: 6,
        parameters: [
          {
            name: 'bIncludeMovement',
            summary: 'If captured, test if the mouse has moved between mouse button down and mouse button up.'
          }
        ],
        returns: 'True if captured, False otherwise.'
      },
      {
        signature: 'void Redraw()',
        summary: 'Redraws this view.',
        since: 5
      },
      {
        signature: 'System.Drawing.Point ScreenToClient(Point screenPoint)',
        summary: 'Converts a point in screen coordinates to client coordinates for this view.',
        since: 5,
        parameters: [
          {
            name: 'screenPoint',
            summary: 'The 2D screen point.'
          }
        ],
        returns: 'A 2D point in client coordinates.'
      },
      {
        signature: 'Geometry.Point2d ScreenToClient(Point2d screenPoint)',
        since: 5.8
      },
      {
        signature: 'double SpeedTest(int frameCount,bool freezeDrawList,int direction,double angleDeltaRadians)',
        since: 5.8
      }
    ],
    events: [
      {
        signature: 'static Create',
        since: 5
      },
      {
        signature: 'static Destroy',
        since: 5
      },
      {
        signature: 'static Modified',
        since: 7
      },
      {
        signature: 'static Rename',
        since: 5
      },
      {
        signature: 'static SetActive',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'RhinoViewport',
    dataType: 1,
    summary: `Displays geometry with a given projection. In standard modeling views there
   is a one to one relationship between RhinoView and RhinoViewports. In a page
   layout, there may be multiple RhinoViewports for a single layout.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'RhinoViewport()',
        since: 5
      },
      {
        signature: 'RhinoViewport(RhinoViewport other)',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'Rectangle Bounds',
        summary: 'Gets the size and location of the viewport, in pixels, relative to the parent view.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Camera35mmLensLength',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d CameraDirection',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d CameraLocation',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d CameraTarget',
        summary: 'Viewport target point.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CameraUp',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d CameraX',
        summary: 'Gets the "unit to the right" vector.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CameraY',
        summary: 'Gets the "unit up" vector.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CameraZ',
        summary: 'Gets the unit vector in CameraDirection.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'uint ChangeCounter',
        summary: `The value of change counter is incremented every time the view projection
     or construction plane changes. The user can the mouse and nestable view 
     manipulation commands to change a view at any time. The value of change
     counter can be used to detect these changes in code that is sensitive to
     the view projection.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool ConstructionAxesVisible',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ConstructionGridVisible',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'DisplayModeDescription DisplayMode',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double FrustumAspect',
        summary: 'Gets the width/height ratio of the frustum.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid Id',
        summary: 'Unique id for this viewport.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsParallelProjection',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsPerspectiveProjection',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsPlanView',
        summary: 'True if construction plane z axis is parallel to camera direction.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsTwoPointPerspectiveProjection',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValidCamera',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValidFrustum',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string Name',
        summary: 'Name associated with this viewport.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'RhinoView ParentView',
        summary: `Gets the parent view, if there is one
     
     Every RhinoView has an associated RhinoViewport that does all the 3d display work.
     Those associated viewports return the RhinoView as their parent view. However,
     RhinoViewports are used in other image creating contexts that do not have a parent
     RhinoView.  If you call ParentView, you MUST check for NULL return values.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double ScreenPortAspect',
        summary: 'screen port\'s width/height.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Size Size',
        summary: 'Gets or sets the height and width of the viewport (in pixels)',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int UserStringCount',
        since: 6.18,
        property: ['get']
      },
      {
        signature: 'ViewportType ViewportType',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string WallpaperFilename',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool WallpaperGrayscale',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool WallpaperVisible',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool WorldAxesVisible',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static RhinoViewport FromId(Guid id)',
        summary: 'Call this method to get the viewport with the specified Id.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'Id to search for.'
          }
        ],
        returns: 'Returns a RhinoViewport if the Id is found otherwise null.'
      },
      {
        signature: 'bool ChangeToParallelProjection(bool symmetricFrustum)',
        summary: `Use this function to change projections of valid viewports from persective to parallel.
     It will make common additional adjustments to the frustum so the resulting views are
     similar. The camera location and direction will not be changed.`,
        since: 5,
        parameters: [
          {
            name: 'symmetricFrustum',
            summary: 'True if you want the resulting frustum to be symmetric.'
          }
        ],
        returns: `If the current projection is parallel and bSymmetricFrustum, FrustumIsLeftRightSymmetric()
     and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned.`
      },
      {
        signature: 'bool ChangeToPerspectiveProjection(bool symmetricFrustum,double lensLength)',
        summary: `Use this function to change projections of valid viewports from parallel to perspective.
     It will make common additional adjustments to the frustum and camera location so the
     resulting views are similar. The camera direction and target point are not be changed.`,
        since: 5,
        parameters: [
          {
            name: 'symmetricFrustum',
            summary: 'True if you want the resulting frustum to be symmetric.'
          },
          {
            name: 'lensLength',
            summary: `(pass 50.0 when in doubt) 35 mm lens length to use when changing from parallel to perspective
     projections. If the current projection is perspective or lens_length is <= 0.0, then
     this parameter is ignored.`
          }
        ],
        returns: `If the current projection is perspective and bSymmetricFrustum, FrustumIsLeftRightSymmetric()
     and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned.`
      },
      {
        signature: 'bool ChangeToPerspectiveProjection(double targetDistance,bool symmetricFrustum,double lensLength)',
        summary: `Use this function to change projections of valid viewports from parallel to perspective.
     It will make common additional adjustments to the frustum and camera location so the
     resulting views are similar. The camera direction and target point are not be changed.`,
        since: 5,
        parameters: [
          {
            name: 'targetDistance',
            summary: `If RhinoMath.UnsetValue this parameter is ignored. Otherwise it must be > 0 and indicates
     which plane in the current view frustum should be perserved.`
          },
          {
            name: 'symmetricFrustum',
            summary: 'True if you want the resulting frustum to be symmetric.'
          },
          {
            name: 'lensLength',
            summary: `(pass 50.0 when in doubt) 35 mm lens length to use when changing from parallel to perspective
     projections. If the current projection is perspective or lens_length is <= 0.0, then
     this parameter is ignored.`
          }
        ],
        returns: `If the current projection is perspective and bSymmetricFrustum, FrustumIsLeftRightSymmetric()
     and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned.`
      },
      {
        signature: 'bool ChangeToTwoPointPerspectiveProjection(double lensLength)',
        summary: `Use this function to change projections of valid viewports
     to a two point perspective.  It will make common additional
     adjustments to the frustum and camera location and direction
     so the resulting views are similar.`,
        since: 6,
        parameters: [
          {
            name: 'lensLength',
            summary: `(pass 50.0 when in doubt) 35 mm lens length to use when changing from parallel to perspective
     projections. If the current projection is perspective or lens_length is <= 0.0, then
     this parameter is ignored.`
          }
        ],
        returns: `If the current projection is perspective and bSymmetricFrustum, FrustumIsLeftRightSymmetric()
     and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned.`
      },
      {
        signature: 'bool ChangeToTwoPointPerspectiveProjection(double targetDistance,Vector3d up,double lensLength)',
        summary: `Use this function to change projections of valid viewports
     to a two point perspective.  It will make common additional
     adjustments to the frustum and camera location and direction
     so the resulting views are similar.`,
        since: 6,
        parameters: [
          {
            name: 'targetDistance',
            summary: `If RhinoMath.UnsetValue this parameter is ignored. Otherwise it must be > 0 and indicates
     which plane in the current view frustum should be perserved.`
          },
          {
            name: 'up',
            summary: `This direction will be the locked up direction.  Pass 
      ON_3dVector::ZeroVector if you want to use the world axis
      direction that is closest to the current up direction.
      Pass CameraY() if you want to preserve the current up direction.`
          },
          {
            name: 'lensLength',
            summary: `(pass 50.0 when in doubt) 35 mm lens length to use when changing from parallel to perspective
     projections. If the current projection is perspective or lens_length is <= 0.0, then
     this parameter is ignored.`
          }
        ],
        returns: `If the current projection is perspective and bSymmetricFrustum, FrustumIsLeftRightSymmetric()
     and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned.`
      },
      {
        signature: 'void ClearTraceImage()',
        summary: 'Remove trace image (background bitmap) for this viewport if one exists.',
        since: 5
      },
      {
        signature: 'System.Drawing.Point ClientToScreen(Point clientPoint)',
        since: 5
      },
      {
        signature: 'System.Drawing.Point ClientToScreen(Point2d clientPoint)',
        since: 5
      },
      {
        signature: 'Line ClientToWorld(Point clientPoint)',
        since: 5
      },
      {
        signature: 'Line ClientToWorld(Point2d clientPoint)',
        since: 5
      },
      {
        signature: 'Plane ConstructionPlane()',
        summary: `Simple plane information for this viewport's construction plane. If you want
     detailed construction lpane information, use GetConstructionPlane.`,
        since: 5
      },
      {
        signature: 'void DeleteAllUserStrings()',
        since: 6.18
      },
      {
        signature: 'bool DeleteUserString(string key)',
        since: 6.18
      },
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'bool GetCameraAngle(double halfDiagonalAngle,double halfVerticalAngle,double halfHorizontalAngle)',
        since: 5
      },
      {
        signature: 'BoundingBox GetCameraExtents(IEnumerable<Point3d> points)',
        since: 5
      },
      {
        signature: 'bool GetCameraFrame(Plane frame)',
        summary: 'Gets the camera plane.',
        since: 5,
        parameters: [
          {
            name: 'frame',
            summary: 'A plane is assigned to this out parameter during the call, if the operation succeeded.'
          }
        ],
        returns: 'True if current camera orientation is valid.'
      },
      {
        signature: 'DocObjects.ConstructionPlane GetConstructionPlane()',
        since: 5
      },
      {
        signature: 'bool GetDepth(BoundingBox bbox,double nearDistance,double farDistance)',
        summary: 'Gets near and far clipping distances of a bounding box.',
        since: 5,
        parameters: [
          {
            name: 'bbox',
            summary: 'The bounding box.'
          },
          {
            name: 'nearDistance',
            summary: 'The near distance is assigned to this out parameter during this call.'
          },
          {
            name: 'farDistance',
            summary: 'The far distance is assigned to this out parameter during this call.'
          }
        ],
        returns: `True if the bounding box intersects the view frustum and near_dist/far_dist were set.
     False if the bounding box does not intesect the view frustum.`
      },
      {
        signature: 'bool GetDepth(Point3d point,double distance)',
        summary: 'Gets clipping distance of a point.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A 3D point.'
          },
          {
            name: 'distance',
            summary: 'A computed distance is assigned to this out parameter if this call succeeds.'
          }
        ],
        returns: `True if the point is ing the view frustum and near_dist/far_dist were set.
     False if the bounding box does not intesect the view frustum.`
      },
      {
        signature: 'bool GetDepth(Sphere sphere,double nearDistance,double farDistance)',
        summary: 'Gets near and far clipping distances of a sphere.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'The sphere.'
          },
          {
            name: 'nearDistance',
            summary: 'The near distance is assigned to this out parameter during this call.'
          },
          {
            name: 'farDistance',
            summary: 'The far distance is assigned to this out parameter during this call.'
          }
        ],
        returns: `True if the sphere intersects the view frustum and near_dist/far_dist were set.
     False if the sphere does not intesect the view frustum.`
      },
      {
        signature: 'Point3d[] GetFarRect()',
        summary: 'Get corners of far clipping plane rectangle.',
        since: 5,
        returns: `[left_bottom, right_bottom, left_top, right_top] points on success
     None on failure.`
      },
      {
        signature: 'bool GetFrustum(double left,double right,double bottom,double top,double nearDistance,double farDistance)',
        summary: 'Gets the view frustum.',
        since: 5,
        parameters: [
          {
            name: 'left',
            summary: 'left < right.'
          },
          {
            name: 'right',
            summary: 'left < right.'
          },
          {
            name: 'bottom',
            summary: 'bottom < top.'
          },
          {
            name: 'top',
            summary: 'bottom < top.'
          },
          {
            name: 'nearDistance',
            summary: '0 < nearDistance < farDistance.'
          },
          {
            name: 'farDistance',
            summary: '0 < nearDistance < farDistance.'
          }
        ],
        returns: 'True if operation succeeded.'
      },
      {
        signature: 'bool GetFrustumBottomPlane(Plane plane)',
        summary: 'Get bottom world frustum clipping plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: `frustum bottom side clipping plane. The normal points into the visible
     region of the frustum. If the projection is perspective, the origin
     is at the camera location, otherwise the origin isthe point on the
     plane that is closest to the camera location.`
          }
        ],
        returns: 'True if camera and frustum are valid and plane was set.'
      },
      {
        signature: 'BoundingBox GetFrustumBoundingBox()',
        since: 5
      },
      {
        signature: 'bool GetFrustumCenter(Point3d center)',
        summary: 'Returns world coordinates of frustum\'s center.',
        since: 5,
        parameters: [
          {
            name: 'center',
            summary: 'The center coordinate is assigned to this out parameter if this call succeeds.'
          }
        ],
        returns: 'True if the center was successfully computed.'
      },
      {
        signature: 'bool GetFrustumFarPlane(Plane plane)',
        summary: 'Get far clipping plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: `far clipping plane if camera and frustum are valid. The plane's
     frame is the same as the camera's frame. The origin is located at
     the intersection of the camera direction ray and the far clipping
     plane.`
          }
        ],
        returns: 'True if camera and frustum are valid.'
      },
      {
        signature: 'bool GetFrustumLeftPlane(Plane plane)',
        summary: 'Get left world frustum clipping plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: `frustum left side clipping plane. The normal points into the visible
     region of the frustum. If the projection is perspective, the origin
     is at the camera location, otherwise the origin isthe point on the
     plane that is closest to the camera location.`
          }
        ],
        returns: 'True if camera and frustum are valid and plane was set.'
      },
      {
        signature: 'bool GetFrustumLine(double screenX,double screenY,Line worldLine)',
        summary: 'Gets the world coordinate line in the view frustum that projects to a point on the screen.',
        since: 5,
        parameters: [
          {
            name: 'screenX',
            summary: '(screenx,screeny) = screen location.'
          },
          {
            name: 'screenY',
            summary: '(screenx,screeny) = screen location.'
          },
          {
            name: 'worldLine',
            summary: `3d world coordinate line segment starting on the near clipping
     plane and ending on the far clipping plane.`
          }
        ],
        returns: `True if successful.
     False if view projection or frustum is invalid.`
      },
      {
        signature: 'bool GetFrustumNearPlane(Plane plane)',
        summary: 'Get near clipping plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: `near clipping plane if camera and frustum are valid. The plane's
     frame is the same as the camera's frame. The origin is located at
     the intersection of the camera direction ray and the near clipping
     plane.`
          }
        ],
        returns: 'True if camera and frustum are valid.'
      },
      {
        signature: 'bool GetFrustumRightPlane(Plane plane)',
        summary: 'Get right world frustum clipping plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: `frustum right side clipping plane. The normal points into the visible
     region of the frustum. If the projection is perspective, the origin
     is at the camera location, otherwise the origin isthe point on the
     plane that is closest to the camera location.`
          }
        ],
        returns: 'True if camera and frustum are valid and plane was set.'
      },
      {
        signature: 'bool GetFrustumTopPlane(Plane plane)',
        summary: 'Get top world frustum clipping plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: `frustum top side clipping plane. The normal points into the visible
     region of the frustum. If the projection is perspective, the origin
     is at the camera location, otherwise the origin isthe point on the
     plane that is closest to the camera location.`
          }
        ],
        returns: 'True if camera and frustum are valid and plane was set.'
      },
      {
        signature: 'Point3d[] GetNearRect()',
        summary: 'Get corners of near clipping plane rectangle.',
        since: 5,
        returns: `[left_bottom, right_bottom, left_top, right_top] points on success
     None on failure.`
      },
      {
        signature: 'Transform GetPickTransform(int clientX,int clientY)',
        summary: `Takes a rectangle in screen coordinates and returns a transformation
     that maps the 3d frustum defined by the rectangle to a -1/+1 clipping
     coordinate box. This takes a single point and inflates it by
     Rhino.ApplicationSettings.ModelAidSettings.MousePickBoxRadius to define
     the screen rectangle.`,
        since: 5,
        parameters: [
          {
            name: 'clientX',
            summary: 'The client point X coordinate.'
          },
          {
            name: 'clientY',
            summary: 'The client point Y coordinate.'
          }
        ],
        returns: 'A transformation matrix.'
      },
      {
        signature: 'Transform GetPickTransform(Point clientPoint)',
        summary: `Takes a rectangle in screen coordinates and returns a transformation
     that maps the 3d frustum defined by the rectangle to a -1/+1 clipping
     coordinate box. This takes a single point and inflates it by
     Rhino.ApplicationSettings.ModelAidSettings.MousePickBoxRadius to define
     the screen rectangle.`,
        since: 5,
        parameters: [
          {
            name: 'clientPoint',
            summary: 'The client point.'
          }
        ],
        returns: 'A transformation matrix.'
      },
      {
        signature: 'Transform GetPickTransform(Rectangle clientRectangle)',
        summary: `Takes a rectangle in screen coordinates and returns a transformation
     that maps the 3d frustum defined by the rectangle to a -1/+1 clipping
     coordinate box.`,
        since: 5,
        parameters: [
          {
            name: 'clientRectangle',
            summary: 'The client rectangle.'
          }
        ],
        returns: 'A transformation matrix.'
      },
      {
        signature: 'bool GetScreenPort(int portLeft,int portRight,int portBottom,int portTop,int portNear,int portFar)',
        summary: `Location of viewport in pixels.  These are provided so you can set the port you are using
     and get the appropriate transformations to and from screen space.`,
        since: 5,
        parameters: [
          {
            name: 'portLeft',
            summary: 'portLeft != portRight.'
          },
          {
            name: 'portRight',
            summary: 'portLeft != portRight.'
          },
          {
            name: 'portBottom',
            summary: 'portTop != portBottom.'
          },
          {
            name: 'portTop',
            summary: 'portTop != portBottom.'
          },
          {
            name: 'portNear',
            summary: 'The viewport near value.'
          },
          {
            name: 'portFar',
            summary: 'The viewport far value.'
          }
        ],
        returns: 'True if the operation is successful.'
      },
      {
        signature: 'Transform GetTransform(CoordinateSystem sourceSystem,CoordinateSystem destinationSystem)',
        summary: 'Gets a transform from origin coordinate system to a target coordinate system.',
        since: 5,
        parameters: [
          {
            name: 'sourceSystem',
            summary: 'The origin coordinate system.'
          },
          {
            name: 'destinationSystem',
            summary: 'The target coordinate system.'
          }
        ],
        returns: `4x4 transformation matrix (acts on the left)
     Identity matrix is returned if this function fails.`
      },
      {
        signature: 'string GetUserString(string key)',
        summary: 'Gets a user string.',
        since: 6.18,
        parameters: [
          {
            name: 'key',
            summary: 'id used to retrieve the string.'
          }
        ],
        returns: 'string associated with the key if successful. None if no key was found.'
      },
      {
        signature: 'System.Collections.Specialized.NameValueCollection GetUserStrings()',
        summary: 'Gets an independent copy of the collection of (user text key, user text value) pairs attached to this object.',
        since: 6.18,
        returns: 'A collection of key strings and values strings. This'
      },
      {
        signature: 'bool GetWorldToScreenScale(Point3d pointInFrustum,double pixelsPerUnit)',
        summary: 'Gets the world to screen size scaling factor at a point in frustum.',
        since: 5,
        parameters: [
          {
            name: 'pointInFrustum',
            summary: 'A point in frustum.'
          },
          {
            name: 'pixelsPerUnit',
            summary: `scale = number of pixels per world unit at the 3d point.
     This out parameter is assigned during this call.`
          }
        ],
        returns: 'True if the operation is successful.'
      },
      {
        signature: 'bool IsVisible(BoundingBox bbox)',
        summary: `Returns True if some portion of a world coordinate bounding box is
     potentially visible in the viewing frustum.`,
        since: 5,
        parameters: [
          {
            name: 'bbox',
            summary: 'A bounding box that is tested for visibility.'
          }
        ],
        returns: 'True if the box is potentially visible; otherwise false.'
      },
      {
        signature: 'bool IsVisible(Point3d point)',
        summary: 'Deterines if a world coordinate point is visible in the viewing frustum.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point that is tested for visibility.'
          }
        ],
        returns: 'True if the point is visible; otherwise false.'
      },
      {
        signature: 'bool KeyboardDolly(bool leftRight,double amount)',
        summary: 'Emulates the keyboard arrow key in terms of interaction.',
        since: 5,
        parameters: [
          {
            name: 'leftRight',
            summary: 'left/right dolly if true, up/down dolly if false.'
          },
          {
            name: 'amount',
            summary: 'The dolly amount.'
          }
        ],
        returns: 'True if operation succeeded; otherwise false.'
      },
      {
        signature: 'bool KeyboardDollyInOut(double amount)',
        summary: 'Emulates the keyboard arrow key in terms of interaction.',
        since: 5,
        parameters: [
          {
            name: 'amount',
            summary: 'The dolly amount.'
          }
        ],
        returns: 'True if operation succeeded; otherwise false.'
      },
      {
        signature: 'bool KeyboardRotate(bool leftRight,double angleRadians)',
        summary: 'Emulates the keyboard arrow key in terms of interaction.',
        since: 5,
        parameters: [
          {
            name: 'leftRight',
            summary: 'left/right rotate if true, up/down rotate if false.'
          },
          {
            name: 'angleRadians',
            summary: `If less than 0, rotation is to left or down.
     If greater than 0, rotation is to right or up.`
          }
        ],
        returns: 'True if operation succeeded; otherwise false.'
      },
      {
        signature: 'bool Magnify(double magnificationFactor,bool mode)',
        summary: 'Zooms or dollies in order to scale the viewport projection of observed objects.',
        since: 5,
        parameters: [
          {
            name: 'magnificationFactor',
            summary: 'The scale factor.'
          },
          {
            name: 'mode',
            summary: `False = perform a "dolly" magnification by moving the camera towards/away from
     the target so that the amount of the screen subtended by an object changes.
     True = perform a "zoom" magnification by adjusting the "lens" angle`
          }
        ],
        returns: 'True if operation succeeded; otherwise false.'
      },
      {
        signature: 'bool Magnify(double magnificationFactor,bool mode,Point fixedScreenPoint)',
        summary: 'Zooms or dollies in order to scale the viewport projection of observed objects.',
        since: 5,
        parameters: [
          {
            name: 'magnificationFactor',
            summary: 'The scale factor.'
          },
          {
            name: 'mode',
            summary: `False = perform a "dolly" magnification by moving the camera towards/away from
     the target so that the amount of the screen subtended by an object changes.
     True = perform a "zoom" magnification by adjusting the "lens" angle`
          },
          {
            name: 'fixedScreenPoint',
            summary: 'A point in the sceen that should remain fixed.'
          }
        ],
        returns: 'True if operation succeeded; otherwise false.'
      },
      {
        signature: 'bool MouseAdjustLensLength(Point mousePreviousPoint,Point mouseCurrentPoint,bool moveTarget)',
        summary: 'Adjusts the camera lens length.',
        since: 6,
        parameters: [
          {
            name: 'mousePreviousPoint',
            summary: 'The mouse previous point.'
          },
          {
            name: 'mouseCurrentPoint',
            summary: 'The mouse current point.'
          },
          {
            name: 'moveTarget',
            summary: 'Should this operation move the target?'
          }
        ]
      },
      {
        signature: 'bool MouseDollyZoom(Point mousePreviousPoint,Point mouseCurrentPoint)',
        summary: 'Zooms lens (thus adjusting the field of view) while moving the camera.',
        since: 5,
        parameters: [
          {
            name: 'mousePreviousPoint',
            summary: 'The mouse previous point.'
          },
          {
            name: 'mouseCurrentPoint',
            summary: 'The mouse current point.'
          }
        ]
      },
      {
        signature: 'bool MouseInOutDolly(Point mousePreviousPoint,Point mouseCurrentPoint)',
        summary: 'Moves the camera towards or away from the view maintaing focus on the view.',
        since: 5,
        parameters: [
          {
            name: 'mousePreviousPoint',
            summary: 'The mouse previous point.'
          },
          {
            name: 'mouseCurrentPoint',
            summary: 'The mouse current point.'
          }
        ]
      },
      {
        signature: 'bool MouseLateralDolly(Point mousePreviousPoint,Point mouseCurrentPoint)',
        summary: 'Pans the camera',
        since: 6,
        parameters: [
          {
            name: 'mousePreviousPoint',
            summary: 'The mouse previous point.'
          },
          {
            name: 'mouseCurrentPoint',
            summary: 'The mouse current point.'
          }
        ]
      },
      {
        signature: 'bool MouseMagnify(Point mousePreviousPoint,Point mouseCurrentPoint)',
        summary: 'Moves the camera towards or away from the view.',
        since: 5,
        parameters: [
          {
            name: 'mousePreviousPoint',
            summary: 'The mouse previous point.'
          },
          {
            name: 'mouseCurrentPoint',
            summary: 'The mouse current point.'
          }
        ]
      },
      {
        signature: 'bool MouseRotateAroundTarget(Point mousePreviousPoint,Point mouseCurrentPoint)',
        summary: 'Rotates the viewport around target.',
        since: 5,
        parameters: [
          {
            name: 'mousePreviousPoint',
            summary: 'The mouse previous point.'
          },
          {
            name: 'mouseCurrentPoint',
            summary: 'The mouse current point.'
          }
        ]
      },
      {
        signature: 'bool MouseRotateCamera(Point mousePreviousPoint,Point mouseCurrentPoint)',
        summary: 'Rotates the view around the camera location.',
        since: 5,
        parameters: [
          {
            name: 'mousePreviousPoint',
            summary: 'The mouse previous point.'
          },
          {
            name: 'mouseCurrentPoint',
            summary: 'The mouse current point.'
          }
        ]
      },
      {
        signature: 'bool MouseTilt(Point mousePreviousPoint,Point mouseCurrentPoint)',
        summary: 'Tilts the camera view.',
        since: 5,
        parameters: [
          {
            name: 'mousePreviousPoint',
            summary: 'The mouse previous point.'
          },
          {
            name: 'mouseCurrentPoint',
            summary: 'The mouse current point.'
          }
        ]
      },
      {
        signature: 'bool NextConstructionPlane()',
        summary: `Sets the construction plane to the plane that was
     active before the last call to PreviousConstructionPlane.`,
        since: 5,
        returns: 'True if successful.'
      },
      {
        signature: 'bool NextViewProjection()',
        summary: `Sets the view projection and target to the settings that 
     were active before the last call to PrevView.`,
        since: 5,
        returns: 'True if the view stack was popped.'
      },
      {
        signature: 'bool PopConstructionPlane()',
        summary: `Sets the construction plane to the plane that was
     active before the last call to PushConstructionPlane.`,
        since: 5,
        returns: 'True if a construction plane was popped.'
      },
      {
        signature: 'bool PopViewProjection()',
        summary: `Sets the view projection and target to the settings at the top of
     the view stack and removes those settings from the view stack.`,
        since: 5,
        returns: 'True if there were settings that could be popped from the stack.'
      },
      {
        signature: 'bool PreviousConstructionPlane()',
        summary: `Sets the construction plane to the plane that was
     active before the last call to NextConstructionPlane
     or SetConstructionPlane.`,
        since: 5,
        returns: 'True if successful.'
      },
      {
        signature: 'bool PreviousViewProjection()',
        summary: `Sets the view projection and target to the settings that
     were active before the last call to NextViewProjection.`,
        since: 5,
        returns: 'True if the view stack was popped.'
      },
      {
        signature: 'void PushConstructionPlane(ConstructionPlane cplane)',
        summary: `Pushes the current construction plane on the viewport's
     construction plane stack and sets the construction plane
     to cplane.`,
        since: 5,
        parameters: [
          {
            name: 'cplane',
            summary: 'The constuction plane to push.'
          }
        ]
      },
      {
        signature: 'bool PushViewInfo(ViewInfo viewinfo,bool includeTraceImage)',
        since: 5
      },
      {
        signature: 'void PushViewProjection()',
        summary: 'Appends the current view projection and target to the viewport\'s view stack.',
        since: 5
      },
      {
        signature: 'bool Rotate(double angleRadians,Vector3d rotationAxis,Point3d rotationCenter)',
        summary: `Rotates about the specified axis. A positive rotation angle results
     in a counter-clockwise rotation about the axis (right hand rule).`,
        since: 5,
        parameters: [
          {
            name: 'angleRadians',
            summary: 'angle of rotation in radians.'
          },
          {
            name: 'rotationAxis',
            summary: 'direction of the axis of rotation.'
          },
          {
            name: 'rotationCenter',
            summary: 'point on the axis of rotation.'
          }
        ],
        returns: 'True if geometry successfully rotated.'
      },
      {
        signature: 'System.Drawing.Point ScreenToClient(Point screenPoint)',
        since: 5
      },
      {
        signature: 'void SetCameraDirection(Vector3d cameraDirection,bool updateTargetLocation)',
        summary: `Set viewport camera direction. By default the target location is changed so that
     the vector from the camera location to the target is parallel to the camera direction.`,
        since: 5,
        parameters: [
          {
            name: 'cameraDirection',
            summary: 'new camera direction.'
          },
          {
            name: 'updateTargetLocation',
            summary: `if true, the target location is changed so that the vector from the camera
     location to the target is parallel to the camera direction.
     If false, the target location is not changed.
     See the remarks section of RhinoViewport.SetTarget for important details.`
          }
        ]
      },
      {
        signature: 'void SetCameraLocation(Point3d cameraLocation,bool updateTargetLocation)',
        summary: `Set viewport camera location. By default the target location is changed so that
      the vector from the camera location to the target is parallel to the camera direction
      vector.`,
        since: 5,
        parameters: [
          {
            name: 'cameraLocation',
            summary: 'new camera location.'
          },
          {
            name: 'updateTargetLocation',
            summary: `if true, the target location is changed so that the vector from the camera
     location to the target is parallel to the camera direction vector.  
     If false, the target location is not changed. See the remarks section of
     RhinoViewport.SetTarget for important details.`
          }
        ]
      },
      {
        signature: 'void SetCameraLocations(Point3d targetLocation,Point3d cameraLocation)',
        summary: `Set viewport camera location and target location. The camera direction vector is
     changed so that it is parallel to the vector from the camera location to
     the target location.`,
        since: 5,
        parameters: [
          {
            name: 'targetLocation',
            summary: 'new target location.'
          },
          {
            name: 'cameraLocation',
            summary: 'new camera location.'
          }
        ]
      },
      {
        signature: 'void SetCameraTarget(Point3d targetLocation,bool updateCameraLocation)',
        summary: `Set viewport target point. By default the camera location
     is translated so that the camera direction vector is parallel
     to the vector from the camera location to the target location.`,
        since: 5,
        parameters: [
          {
            name: 'targetLocation',
            summary: 'new target location.'
          },
          {
            name: 'updateCameraLocation',
            summary: `if true, the camera location is translated so that the camera direction
     vector is parallel to the vector from the camera location to the target
     location.
     If false, the camera location is not changed.`
          }
        ]
      },
      {
        signature: 'void SetClippingPlanes(BoundingBox box)',
        summary: 'Sets optimal clipping planes to view objects in a world coordinate 3d bounding box.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'The bounding box'
          }
        ]
      },
      {
        signature: 'void SetConstructionPlane(ConstructionPlane cplane)',
        summary: 'Sets the construction plane to cplane.',
        since: 5,
        parameters: [
          {
            name: 'cplane',
            summary: 'The constuction plane to set.'
          }
        ]
      },
      {
        signature: 'void SetConstructionPlane(Plane plane)',
        since: 5
      },
      {
        signature: 'bool SetProjection(DefinedViewportProjection projection,string viewName,bool updateConstructionPlane)',
        summary: 'Set viewport to a defined projection.',
        since: 5,
        parameters: [
          {
            name: 'projection',
            summary: 'The "standard" projection type.'
          },
          {
            name: 'viewName',
            summary: 'If not None or empty, the name is set.'
          },
          {
            name: 'updateConstructionPlane',
            summary: 'If true, the construction plane is set to the viewport plane.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool SetToPlanView(Point3d planeOrigin,Vector3d planeXaxis,Vector3d planeYaxis,bool setConstructionPlane)',
        since: 5
      },
      {
        signature: 'bool SetTraceImage(string bitmapFileName,Plane plane,double width,double height,bool grayscale,bool filtered)',
        summary: 'Set trace image (background bitmap) for this viewport.',
        since: 5,
        parameters: [
          {
            name: 'bitmapFileName',
            summary: 'The bitmap file name.'
          },
          {
            name: 'plane',
            summary: 'A picture plane.'
          },
          {
            name: 'width',
            summary: 'The picture width.'
          },
          {
            name: 'height',
            summary: 'The picture height.'
          },
          {
            name: 'grayscale',
            summary: 'True if the picture should be in grayscale.'
          },
          {
            name: 'filtered',
            summary: 'True if image should be filtered (bilinear) before displayed.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool SetUserString(string key,string value)',
        summary: 'Attach a user string (key,value combination) to this geometry.',
        since: 6.18,
        parameters: [
          {
            name: 'key',
            summary: 'id used to retrieve this string.'
          },
          {
            name: 'value',
            summary: 'string associated with key. If null, the key will be removed'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'bool SetViewProjection(ViewportInfo projection,bool updateTargetLocation)',
        summary: 'Sets the viewport camera projection.',
        since: 5,
        parameters: [
          {
            name: 'projection',
            summary: 'The "standard" projection type.'
          },
          {
            name: 'updateTargetLocation',
            summary: `if true, the target location is changed so that the vector from the camera location to the target
     is parallel to the camera direction vector.  If false, the target location is not changed.`
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'bool SetWallpaper(string imageFilename,bool grayscale)',
        since: 5
      },
      {
        signature: 'bool SetWallpaper(string imageFilename,bool grayscale,bool visible)',
        since: 5
      },
      {
        signature: 'Point2d WorldToClient(Point3d worldPoint)',
        summary: `Convert a point from world coordinates in the viewport to a 2d screen
     point in the local coordinates of the viewport (X/Y of point is relative
     to top left corner of viewport on screen)`,
        since: 5,
        parameters: [
          {
            name: 'worldPoint',
            summary: 'The 3D point in world coordinates.'
          }
        ],
        returns: 'The 2D point on the screen.'
      },
      {
        signature: 'bool ZoomBoundingBox(BoundingBox box)',
        summary: 'Zooms the viewport to the given bounding box.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'The bouding box to zoom.'
          }
        ],
        returns: 'True if operation succeeded; otherwise false.'
      },
      {
        signature: 'bool ZoomExtents()',
        summary: `Dollies the camera location and so that the view frustum contains all of the
     selected document objects that can be seen in view. If the projection is
     perspective, the camera angle is not changed.`,
        since: 5,
        returns: 'True if successful.'
      },
      {
        signature: 'bool ZoomExtentsSelected()',
        summary: `Dollies the camera location and so that the view frustum contains all of the
     selected document objects that can be seen in view. If the projection is
     perspective, the camera angle is not changed.`,
        since: 5,
        returns: 'True if successful.'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ShaderLanguage',
    dataType: 3,
    summary: `Graphics Shader Language
https://en.wikipedia.org/wiki/OpenGL_Shading_Language#Versions`,
    values: [
      {
        signature: 'GLSL_ES100 = 1',
        summary: 'Used for OpenGL ES 2.0 and WebGL 1.0'
      },
      {
        signature: 'GLSL_ES300 = 2',
        summary: 'Used for OpenGL ES 3.0 and WebGL 2.0'
      },
      {
        signature: 'GLSL_ES310 = 3'
      },
      {
        signature: 'GLSL_120 = 4',
        summary: 'Used for OpenGL 2.1'
      },
      {
        signature: 'GLSL_130 = 5',
        summary: 'Used for OpenGL 3.0'
      },
      {
        signature: 'GLSL_140 = 6',
        summary: 'Used for OpenGL 3.1'
      },
      {
        signature: 'GLSL_150 = 7',
        summary: 'Used for OpenGL 3.2'
      },
      {
        signature: 'GLSL_330 = 8',
        summary: 'Used for OpenGL 3.3'
      },
      {
        signature: 'GLSL_400 = 9',
        summary: 'Used for OpenGL 4.0'
      },
      {
        signature: 'GLSL_410 = 10',
        summary: 'Used for OpenGL 4.1'
      },
      {
        signature: 'GLSL_420 = 11',
        summary: 'Used for OpenGL 4.2'
      },
      {
        signature: 'GLSL_430 = 12',
        summary: 'Used for OpenGL 4.3'
      },
      {
        signature: 'GLSL_440 = 13',
        summary: 'Used for OpenGL 4.4'
      },
      {
        signature: 'Metal = 14',
        summary: 'Metal for Apple'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'Text3d',
    dataType: 1,
    summary: '3D aligned text with font settings.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'Text3d(string text)',
        summary: 'Constructs a new instance of Text3d.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text string.'
          }
        ]
      },
      {
        signature: 'Text3d(string text,Plane plane,double height)',
        summary: 'Constructs a new instance of Text3d.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text string.'
          },
          {
            name: 'plane',
            summary: '3D Plane for text.'
          },
          {
            name: 'height',
            summary: 'Height (in units) for text.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool Bold',
        summary: 'Gets or sets whether this Text3d object will be drawn in Bold.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'BoundingBox BoundingBox',
        summary: 'Gets the boundingbox for this Text3d object.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string FontFace',
        summary: 'Gets or sets the FontFace name.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Height',
        summary: `Gets or sets the height (in units) of this Text3d object. 
     The height should be a positive number larger than zero.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'TextHorizontalAlignment HorizontalAlignment',
        summary: 'Horizontal alignment that this Text3d is drawn with',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'bool Italic',
        summary: 'Gets or sets whether this Text3d object will be drawn in Italics.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Text',
        summary: 'Gets or sets the text string for this Text3d object.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Plane TextPlane',
        summary: 'Gets or sets the 3D aligned plane for this Text3d object.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'TextVerticalAlignment VerticalAlignment',
        summary: 'Vertical alignment that this Text3d is drawn with',
        since: 6.4,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ViewCapture',
    dataType: 1,
    constructors: [
      {
        signature: 'ViewCapture()',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'bool DrawAxes',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawGrid',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawGridAxes',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int Height',
        summary: 'Height of capture in Pixels',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool Preview',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int RealtimeRenderPasses',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ScaleScreenItems',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool TransparentBackground',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int Width',
        summary: 'Width of capture in Pixels',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Bitmap CaptureToBitmap(ViewCaptureSettings settings)',
        since: 6
      },
      {
        signature: 'static System.Xml.XmlDocument CaptureToSvg(ViewCaptureSettings settings)',
        since: 6
      },
      {
        signature: 'Bitmap CaptureToBitmap(RhinoView sourceView)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ViewCaptureSettings',
    dataType: 1,
    summary: `Used to hold the information required to generate high resolution output
   of a RhinoViewport.  This is used for generating paper prints or image files`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'ViewCaptureSettings()',
        since: 6
      },
      {
        signature: 'ViewCaptureSettings(RhinoPageView sourcePageView,double dpi)',
        since: 6
      },
      {
        signature: 'ViewCaptureSettings(RhinoView sourceView,Size mediaSize,double dpi)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'double ArrowheadSizeMillimeters',
        summary: 'arrowhead size in millimeters',
        since: 6.15,
        property: ['get', 'set']
      },
      {
        signature: 'Rectangle CropRectangle',
        summary: 'Actual area of output rectangle that view capture is sent to.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'double DefaultPrintWidthMillimeters',
        summary: 'Line thickness used to print objects with no defined thickness (in mm)',
        since: 6.15,
        property: ['get', 'set']
      },
      {
        signature: 'RhinoDoc Document',
        since: 6.15,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawAxis',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawBackground',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawBackgroundBitmap',
        since: 6.2,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawClippingPlanes',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawGrid',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawLights',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawLockedObjects',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawMargins',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawSelectedObjectsOnly',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawWallpaper',
        since: 6.2,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsScaleToFit',
        summary: 'Returns True if the model has been scaled to fit.',
        since: 6.21,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Size MediaSize',
        summary: 'Total size of the image or page in dots',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int ModelScaleType',
        since: 6.21,
        property: ['get', 'set']
      },
      {
        signature: 'AnchorLocation OffsetAnchor',
        since: 6.2,
        property: ['get', 'set']
      },
      {
        signature: 'ColorMode OutputColor',
        since: 6.8,
        property: ['get', 'set']
      },
      {
        signature: 'double PointSizeMillimeters',
        summary: `size of point objects in millimeters
     if scale <= 0 the size is minimized so points are always drawn as small as possible`,
        since: 6.15,
        property: ['get', 'set']
      },
      {
        signature: 'bool RasterMode',
        since: 6.17,
        property: ['get', 'set']
      },
      {
        signature: 'double Resolution',
        summary: 'Capture "density" in dots per inch',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool UsePrintWidths',
        since: 6.15,
        property: ['get', 'set']
      },
      {
        signature: 'double WireThicknessScale',
        summary: `scaling factor to apply to object print widths (typically 1.0). This is
     helpful when printing something at 1/2 scale and having all of the curves
     print 1/2 as thick`,
        since: 6.15,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      },
      {
        signature: 'bool GetMargins(UnitSystem lengthUnits,double left,double top,double right,double bottom)',
        summary: `Get distances from the edge of the paper (MediaSize) to the CropRectangle
     in a defined unit system`,
        since: 6.2,
        parameters: [
          {
            name: 'lengthUnits',
            summary: 'Units to get distances in'
          },
          {
            name: 'left',
            summary: 'Distance from left edge of paper to left edge of CropRectangle'
          },
          {
            name: 'top',
            summary: 'Distance from top edge of paper to top edge of CropRectangle'
          },
          {
            name: 'right',
            summary: 'Distance from right edge of paper to right edge of CropRectangle'
          },
          {
            name: 'bottom',
            summary: 'Distance from bottom edge of paper to bottom edge of CropRectangle'
          }
        ],
        returns: `True if successful.
     False if unsuccessful (this could happen if there is no set device_dpi)`
      },
      {
        signature: 'double GetModelScale(UnitSystem pageUnits,UnitSystem modelUnits)',
        summary: 'Returns the model scale factor.',
        since: 6.21,
        parameters: [
          {
            name: 'pageUnits',
            summary: 'The current page units.'
          },
          {
            name: 'modelUnits',
            summary: 'The current model units.'
          }
        ],
        returns: 'The model scale factor.'
      },
      {
        signature: 'void GetOffset(UnitSystem lengthUnits,bool fromMargin,double x,double y)',
        since: 6.2
      },
      {
        signature: 'void SetLayout(Size mediaSize,Rectangle cropRectangle)',
        since: 6
      },
      {
        signature: 'bool SetMargins(UnitSystem lengthUnits,double left,double top,double right,double bottom)',
        summary: `Set distances from the edge of the paper (MediaSize) to the CropRectange
     in a defined unit system`,
        since: 6.2,
        parameters: [
          {
            name: 'lengthUnits',
            summary: 'Units that left, top, right, and bottom are defined in'
          },
          {
            name: 'left',
            summary: 'Distance from left edge of paper to left edge of CropRectangle'
          },
          {
            name: 'top',
            summary: 'Distance from top edge of paper to top edge of CropRectangle'
          },
          {
            name: 'right',
            summary: 'Distance from right edge of paper to right edge of CropRectangle'
          },
          {
            name: 'bottom',
            summary: 'Distance from bottom edge of paper to bottom edge of CropRectangle'
          }
        ],
        returns: `True if successful.
     False if unsuccessful (this could happen if there is no set device_dpi)`
      },
      {
        signature: 'void SetModelScaleToFit(bool promptOnChange)',
        summary: 'Scales the model to fit.',
        since: 6.21,
        parameters: [
          {
            name: 'promptOnChange',
            summary: 'Prompt the user if the model scale will change.'
          }
        ]
      },
      {
        signature: 'void SetModelScaleToValue(double scale)',
        summary: 'Sets the model scale to a value.',
        since: 6.21,
        parameters: [
          {
            name: 'scale',
            summary: 'The scale value.'
          }
        ]
      },
      {
        signature: 'void SetOffset(UnitSystem lengthUnits,bool fromMargin,double x,double y)',
        since: 6.2
      },
      {
        signature: 'void SetViewport(RhinoViewport viewport)',
        since: 6.15
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ViewCaptureSettings.AnchorLocation',
    dataType: 3,
    values: [
      {
        signature: 'LowerLeft = UnsafeNativeMethods.PrintInfoAnchor.LowerLeft'
      },
      {
        signature: 'LowerRight = UnsafeNativeMethods.PrintInfoAnchor.LowerRight'
      },
      {
        signature: 'UpperLeft = UnsafeNativeMethods.PrintInfoAnchor.UpperLeft'
      },
      {
        signature: 'UpperRight = UnsafeNativeMethods.PrintInfoAnchor.UpperRight'
      },
      {
        signature: 'Center = UnsafeNativeMethods.PrintInfoAnchor.Center'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ViewCaptureSettings.ColorMode',
    dataType: 3,
    values: [
      {
        signature: 'DisplayColor'
      },
      {
        signature: 'PrintColor'
      },
      {
        signature: 'BlackAndWhite'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ViewEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RhinoView View',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ViewportType',
    dataType: 3,
    values: [
      {
        signature: 'StandardModelingViewport = 0'
      },
      {
        signature: 'PageViewMainViewport = 1'
      },
      {
        signature: 'DetailViewport = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'VisualAnalysisMode.AnalysisStyle',
    dataType: 3,
    summary: 'Contains enumerated values for analysis styles, such as wireframe, texture or False colors..',
    values: [
      {
        signature: 'Wireframe = 1',
        summary: 'The analysis is showing with wires.'
      },
      {
        signature: 'Texture = 2',
        summary: 'The analysis is showing with textures.'
      },
      {
        signature: 'FalseColor = 4',
        summary: 'The analysis is showing with False colors.'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'VisualAnalysisMode.EdgeContinuityMode',
    dataType: 3,
    summary: 'Continuity mode to report',
    values: [
      {
        signature: 'Distance = 0',
        summary: 'G0 Continuity'
      },
      {
        signature: 'Tangency = 1',
        summary: 'G1 Continuity'
      },
      {
        signature: 'Curvature = 2',
        summary: 'G2 Continuity'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ZBiasMode',
    dataType: 3,
    summary: `Baising applied to geometry to attempt to get coplanar items
   to draw on top of or below other geometry`,
    values: [
      {
        signature: 'Neutral = 0'
      },
      {
        signature: 'TowardsCamera = 1'
      },
      {
        signature: 'AwayFromCamera = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.Display',
    name: 'ZBufferCapture',
    dataType: 1,
    summary: `Provides functionality for getting the zbuffer values from a viewport
   and a given display mode`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'ZBufferCapture(RhinoViewport viewport)',
        since: 5.3
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5.3
      },
      {
        signature: 'System.Drawing.Bitmap GrayscaleDib()',
        since: 5.3
      },
      {
        signature: 'int HitCount()',
        since: 5.3
      },
      {
        signature: 'float MaxZ()',
        since: 5.3
      },
      {
        signature: 'float MinZ()',
        since: 5.3
      },
      {
        signature: 'void SetDisplayMode(Guid modeId)',
        since: 5.3
      },
      {
        signature: 'void ShowAnnotations(bool on)',
        since: 5.3
      },
      {
        signature: 'void ShowCurves(bool on)',
        since: 5.3
      },
      {
        signature: 'void ShowIsocurves(bool on)',
        since: 5.3
      },
      {
        signature: 'void ShowLights(bool on)',
        since: 5.3
      },
      {
        signature: 'void ShowMeshWires(bool on)',
        since: 5.3
      },
      {
        signature: 'void ShowPoints(bool on)',
        since: 5.3
      },
      {
        signature: 'void ShowText(bool on)',
        since: 5.3
      },
      {
        signature: 'Point3d WorldPointAt(int x,int y)',
        since: 5.3
      },
      {
        signature: 'float ZValueAt(int x,int y)',
        since: 5.3
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ActiveSpace',
    dataType: 3,
    summary: 'Defines the current working space.',
    values: [
      {
        signature: 'None = 0',
        summary: 'There is no working space.'
      },
      {
        signature: 'ModelSpace = 1',
        summary: '3d modeling or "world" space.'
      },
      {
        signature: 'PageSpace = 2',
        summary: 'page/layout/paper/printing space.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'AngleDisplayMode',
    dataType: 3,
    summary: 'Defines enumerated values for the display of angles.',
    values: [
      {
        signature: 'Degrees = 0',
        summary: 'Shows angle in decimal degrees'
      },
      {
        signature: 'DMS = 1',
        summary: 'Show angle as degree,minute,second.'
      },
      {
        signature: 'Grads = 2',
        summary: 'Show angle as grads.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'AngularDimensionObject',
    dataType: 1,
    summary: 'Rhino Object that represents an angular dimension geometry and attributes',
    baseclass: 'Rhino.DocObjects.DimensionObject',
    properties: [
      {
        signature: 'AngularDimension AngularDimensionGeometry',
        summary: 'Get the dimension geometry for this object.',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'AnimationProperties',
    dataType: 1,
    summary: `Contains information used by the Animation Tools to create sun, season,
   turntable and fly through animations.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'AnimationProperties()',
        summary: 'Initializes a new instance of the AnimationProperties class.',
        since: 6.11
      },
      {
        signature: 'AnimationProperties(AnimationProperties source)',
        summary: 'Initialize new instance of the AnimationProperties class.',
        since: 6.11,
        parameters: [
          {
            name: 'source',
            summary: 'If not null, settings are copied from source'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'string AnimationName',
        summary: 'Gets or sets the name of the animation sequence.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'Guid CameraPathId',
        summary: 'Gets or sets the object ID of the camera path.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d[] CameraPoints',
        summary: 'Gets or sets points of the camera path.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'string CaptureMethod',
        summary: 'Gets or sets the capture method of the animation which is either preview or full.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'CaptureTypes CaptureType',
        summary: 'Gets or sets the capture type of the animation.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'string[] Dates',
        summary: 'Gets or sets the dates that are calculated for seasonal/one day sun animations.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int DaysBetweenFrames',
        summary: 'Gets or sets the days between captured frames for seasonal sun animation.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'Guid DisplayMode',
        summary: 'Gets or sets the ID of the view display mode (wireframe, shaded...).',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int EndDay',
        summary: 'Gets or sets the end day for seasonal day sun animation in the range 1 to 31.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int EndHour',
        summary: 'Gets or sets the end hour for one day sun animation in the range 0 to 23.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int EndMinutes',
        summary: 'Gets or sets the end minutes for one day sun animation in the range 0 to 59.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int EndMonth',
        summary: 'Gets or sets the end month for seasonal day sun animation in the range 1 to 12.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int EndSeconds',
        summary: 'Gets or sets the end seconds for one day sun animation in the range 0 to 59.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int EndYear',
        summary: 'Gets or sets the end year for seasonal day sun animation in the range 1800 to 2199.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'string FileExtension',
        summary: 'Gets or sets the file extension of the saved frames created by the animation.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'string FolderName',
        summary: 'Gets or sets the location for the saved frames.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int FrameCount',
        summary: 'Gets or sets the number of frames to be captured.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'string[] Images',
        summary: 'Gets or sets the full path to the saved frames of an animation.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'double Latitude',
        summary: 'Gets or sets the latitude for sun animations in the range of -90 to +90.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int LightIndex',
        summary: 'Internal value used while previewing animation.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'double Longitude',
        summary: 'Gets or sets the longitude for sun animations in the range of -180 to +180.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int MinutesBetweenFrames',
        summary: 'Gets or sets the minutes between captured frames for one day sun animation.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'double NorthAngle',
        summary: `Gets or sets the world angle corresponding to North in degrees.
     This angle is zero along the x-axis and increases anticlockwise.`,
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'bool RenderFull',
        summary: 'Gets or sets a value indicating whether to capture a frame in rendered mode.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'bool RenderPreview',
        summary: 'Gets or sets a value indicating whether to capture a frame in preview rendered mode.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int StartDay',
        summary: 'Gets or sets the start day for seasonal/one day sun animation in the range 1 to 31.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int StartHour',
        summary: 'Gets or sets the start hour for seasonal/one day sun animation in the range 0 to 23.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int StartMinutes',
        summary: 'Gets or sets the start minutes for seasonal/one day sun animation in the range 0 to 59.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int StartMonth',
        summary: 'Gets or sets the start month for seasonal/one day sun animation in the range 1 to 12.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int StartSeconds',
        summary: 'Gets or sets the start seconds for seasonal/one day sun animation in the range 0 to 59.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int StartYear',
        summary: 'Gets or sets the start year for seasonal/one day sun animation in the range 1800 to 2199.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'Guid TargetPathId',
        summary: 'Gets or sets the object ID of the target path.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d[] TargetPoints',
        summary: 'Gets or sets points of the target path.',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'string ViewportName',
        summary: 'Gets or sets the viewport that will be captured.',
        since: 6.11,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6.11
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'AnimationProperties.CaptureTypes',
    dataType: 3,
    summary: 'Constants that define the mode of the animation tools.',
    values: [
      {
        signature: 'Path = UnsafeNativeMethods.AnimationPropertiesCaptureTypes.Path',
        summary: 'Camera and target movement along separate path curves'
      },
      {
        signature: 'Turntable = UnsafeNativeMethods.AnimationPropertiesCaptureTypes.Turntable',
        summary: 'Rotate a view around the target.'
      },
      {
        signature: 'Flythrough = UnsafeNativeMethods.AnimationPropertiesCaptureTypes.Flythrough',
        summary: 'Camera and target movement along a path curve'
      },
      {
        signature: 'DaySunStudy = UnsafeNativeMethods.AnimationPropertiesCaptureTypes.DaySunStudy',
        summary: 'Sun movement through a specified calendar day'
      },
      {
        signature: 'SeasonalSunStudy = UnsafeNativeMethods.AnimationPropertiesCaptureTypes.SeasonalSunStudy',
        summary: 'Sun movement through a specified week, month, or year'
      },
      {
        signature: 'None = UnsafeNativeMethods.AnimationPropertiesCaptureTypes.None',
        summary: 'No capture type specified'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'AnnotationObjectBase',
    dataType: 1,
    summary: 'Base class for all annotation objects (text and dimensions)',
    baseclass: 'Rhino.DocObjects.RhinoObject',
    properties: [
      {
        signature: 'AnnotationBase AnnotationGeometry',
        summary: 'Get the annotation base geometry for this object',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string DisplayText',
        summary: 'Gets the text that is displayed to users.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool HasMeasurableTextFields',
        summary: `Test if the text in the annotation object contains fields
     that involve length, area, or volume measurements`,
        since: 7,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'BasepointZero',
    dataType: 3,
    summary: `Specifies enumerated constants used to indicate the zero level convention relating to a location on Earth.
   This is used in conjunction with the  class.`,
    values: [
      {
        signature: 'GroundLevel = 0',
        summary: 'The ground level is the convention for 0.'
      },
      {
        signature: 'MeanSeaLevel = 1',
        summary: 'The mean sea level is the convention for 0.'
      },
      {
        signature: 'CenterOfEarth = 2',
        summary: 'The center of the planet is the convention for 0.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'BitmapEntry',
    dataType: 1,
    summary: 'Rhino.DocObjects.Tables.BitmapTable entry',
    baseclass: 'Rhino.DocObjects.ModelComponent',
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.Image.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string FileName',
        summary: 'The name of this bitmap.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'bool IsReference',
        summary: `Gets a value indicting whether this bitmap is a referenced bitmap. 
     Referenced bitmaps are part of referenced documents.`,
        since: 5.1,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool Save(string fileName)',
        since: 5.1
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'BrepObject',
    dataType: 1,
    summary: 'Represents a Rhino.Geometry.Brep in a document.',
    baseclass: 'Rhino.DocObjects.RhinoObject',
    properties: [
      {
        signature: 'Brep BrepGeometry',
        summary: 'Gets the brep geometry linked with this object.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Brep DuplicateBrepGeometry()',
        summary: 'Constructs a new deep copy of the brep geometry.',
        since: 5,
        returns: 'The copy of the geometry.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'CentermarkObject',
    dataType: 1,
    summary: 'Rhino Object that represents a centermark geometry and attributes',
    baseclass: 'Rhino.DocObjects.DimensionObject',
    properties: [
      {
        signature: 'Centermark CentermarkGeometry',
        summary: 'Get the dimension geometry for this object.',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ClippingPlaneObject',
    dataType: 1,
    summary: `Represents the object of a Rhino.Geometry.ClippingPlaneSurface,
   stored in the Rhino document and with attributes.`,
    baseclass: 'Rhino.DocObjects.RhinoObject',
    properties: [
      {
        signature: 'ClippingPlaneSurface ClippingPlaneGeometry',
        summary: 'Gets the clipping plane surface.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool AddClipViewport(RhinoViewport viewport,bool commit)',
        summary: 'Adds a viewport to the list of viewports that this clipping plane clips.',
        since: 6.1,
        parameters: [
          {
            name: 'viewport',
            summary: 'The viewport to add.'
          },
          {
            name: 'commit',
            summary: 'Commit the change. When in doubt, set this parameter to true.'
          }
        ],
        returns: 'True if the viewport was added, False if the viewport is already in the list.'
      },
      {
        signature: 'bool RemoveClipViewport(RhinoViewport viewport,bool commit)',
        summary: 'Removes a viewport from the list of viewports that this clipping plane clips.',
        since: 6.1,
        parameters: [
          {
            name: 'viewport',
            summary: 'The viewport to remove.'
          },
          {
            name: 'commit',
            summary: 'Commit the change. When in doubt, set this parameter to true.'
          }
        ],
        returns: 'True if the viewport was removed, False if the viewport was not in the list.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ConstructionPlane',
    dataType: 1,
    summary: `Represents a contruction plane inside the document.
   Use Rhino.DocObjects.Tables.NamedConstructionPlaneTable
   methods and indexers to add and access a .`,
    constructors: [
      {
        signature: 'ConstructionPlane()',
        summary: 'Initializes a new instance of ConstructionPlane.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'bool DepthBuffered',
        summary: `Gets or sets whether the grid is drawn on top of geometry.
     false=grid is always drawn behind 3d geometrytrue=grid is drawn at its depth as a 3d plane and grid lines obscure things behind the grid.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int GridLineCount',
        summary: 'Gets or sets the total amount of grid lines in each direction.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double GridSpacing',
        summary: 'Gets or sets the distance between grid lines.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color GridXColor',
        summary: 'Gets or sets the color of the grid X-axis mark.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color GridYColor',
        summary: 'Gets or sets the color of the grid Y-axis mark.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color GridZColor',
        summary: 'Gets or sets the color of the grid Z-axis mark.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Name',
        summary: 'Gets or sets the name of the construction plane.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Plane Plane',
        summary: 'Gets or sets the geometric plane to use for construction.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowAxes',
        summary: 'Gets or sets whether the axes of the grid shuld be visible.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowGrid',
        summary: 'Gets or sets whether the grid itself should be visible.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowZAxis',
        summary: 'Gets or sets whether the Z axis of the grid shuld be visible.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double SnapSpacing',
        summary: `when "grid snap" is enabled, the distance between snap points.
     Typically this is the same distance as grid spacing.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color ThickLineColor',
        summary: 'Gets or sets the color of the thicker, wider line.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int ThickLineFrequency',
        summary: `Gets or sets the recurrence of a wider line on the grid.
     0: No lines are thick, all are drawn thin.1: All lines are thick.2: Every other line is thick.3: One line in three lines is thick (and two are thin).4: ...`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color ThinLineColor',
        summary: 'Gets or sets the color of the thinner, less prominent line.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'CoordinateSystem',
    dataType: 3,
    summary: 'Defines enumerated values for coordinate systems to use as references.',
    values: [
      {
        signature: 'World = 0',
        summary: `The world coordinate system. This has origin (0,0,0),
       X unit axis is (1, 0, 0) and Y unit axis is (0, 1, 0).`
      },
      {
        signature: 'Camera = 1',
        summary: 'The camera coordinate system.'
      },
      {
        signature: 'Clip = 2',
        summary: 'The clip coordinate system.'
      },
      {
        signature: 'Screen = 3',
        summary: 'The screen coordinate system.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'CurveObject',
    dataType: 1,
    summary: 'A Rhino Object that represents curve geometry and attributes',
    baseclass: 'Rhino.DocObjects.RhinoObject',
    properties: [
      {
        signature: 'Curve CurveGeometry',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Curve DuplicateCurveGeometry()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Custom',
    name: 'ClassIdAttribute',
    dataType: 1,
    summary: 'Useful for legacy UserData',
    baseclass: 'Attribute',
    constructors: [
      {
        signature: 'ClassIdAttribute(string id)',
        summary: 'Initializes a class id attrbute.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'String in the form of a Guid.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'Guid Id',
        summary: 'Gets the associated style.',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Custom',
    name: 'CustomBrepObject',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.BrepObject',
    interfaces: ['IDisposable']
  },
  {
    namespace: 'Rhino.DocObjects.Custom',
    name: 'CustomCurveObject',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.CurveObject',
    interfaces: ['IDisposable'],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Custom',
    name: 'CustomGripObject',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.GripObject',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'CustomGripObject()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'int Index',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d OriginalLocation',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Weight',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'void NewLocation()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Custom',
    name: 'CustomMeshObject',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.MeshObject',
    interfaces: ['IDisposable'],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Custom',
    name: 'CustomObjectGrips',
    dataType: 1,
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'int GripCount',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool GripsMoved',
        summary: `If GripsMoved is True if some of the grips have ever been moved
     GripObject.NewLocation() sets GripsMoved=true.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool NewLocation',
        summary: `True if some of the grips have been moved. GripObject.NewLocation() sets
     NewLocation=true.  Derived classes can set NewLocation to False after 
     updating temporary display information.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'RhinoObject OwnerObject',
        summary: 'Owner of the grips.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static bool Dragging()',
        summary: 'Determines if grips are currently being dragged.',
        since: 5,
        returns: 'True if grips are dragged.'
      },
      {
        signature: 'static void RegisterGripsEnabler(TurnOnGripsEventHandler enabler,Type customGripsType)',
        since: 5
      },
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'CustomGripObject Grip(int index)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Custom',
    name: 'CustomPointObject',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.PointObject',
    interfaces: ['IDisposable'],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5.6
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Custom',
    name: 'GripsDrawEventArgs',
    dataType: 1,
    baseclass: 'Rhino.Display.DrawEventArgs',
    properties: [
      {
        signature: 'int ControlPolygonStyle',
        summary: `What kind of line is used to display things like control polygons.
     0 = no control polygon,  1 = solid control polygon,  2 = dotted control polygon.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawDynamicStuff',
        summary: `If true, then draw stuff that does not move when grips are
     dragged, like the control polygon of the "original" curve.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool DrawStaticStuff',
        summary: `If true, then draw stuff that moves when grips are dragged,
     like the curve being bent by a dragged control point.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Color GripColor',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int GripStatusCount',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Color LockedGripColor',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color SelectedGripColor',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void DrawControlPolygonLine(Line line,GripStatus startStatus,GripStatus endStatus)',
        summary: `Draws the lines in a control polygons.
     This is an helper function.`,
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line between two grips.'
          },
          {
            name: 'startStatus',
            summary: 'Grip status at start of line.'
          },
          {
            name: 'endStatus',
            summary: 'Grip status at end of line.'
          }
        ]
      },
      {
        signature: 'void DrawControlPolygonLine(Line line,int startStatus,int endStatus)',
        summary: `Draws the lines in a control polygons.
     This is an helper function.`,
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line between two grips.'
          },
          {
            name: 'startStatus',
            summary: 'Index of Grip status at start of line.'
          },
          {
            name: 'endStatus',
            summary: 'Index if Grip status at end of line.'
          }
        ]
      },
      {
        signature: 'void DrawControlPolygonLine(Point3d start,Point3d end,int startStatus,int endStatus)',
        summary: `Draws the lines in a control polygons.
     This is an helper function.`,
        since: 5,
        parameters: [
          {
            name: 'start',
            summary: 'The point start.'
          },
          {
            name: 'end',
            summary: 'The point end.'
          },
          {
            name: 'startStatus',
            summary: 'Index of Grip status at start of line defined by start and end.'
          },
          {
            name: 'endStatus',
            summary: 'Index if Grip status at end of line defined by start and end.'
          }
        ]
      },
      {
        signature: 'GripStatus GripStatus(int index)',
        since: 5
      },
      {
        signature: 'void RestoreViewportSettings()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Custom',
    name: 'GripStatus',
    dataType: 1,
    properties: [
      {
        signature: 'bool Culled',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool Visible',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Custom',
    name: 'UnknownUserData',
    dataType: 1,
    summary: 'Represents user data with unknown origin.',
    baseclass: 'Rhino.DocObjects.Custom.UserData',
    constructors: [
      {
        signature: 'UnknownUserData(IntPtr pointerNativeUserData)',
        summary: 'Constructs a new unknown data entity.',
        since: 5,
        parameters: [
          {
            name: 'pointerNativeUserData',
            summary: 'A pointer to the entity.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Custom',
    name: 'UserData',
    dataType: 1,
    summary: `Provides a base class for custom classes of information which may be attached to
   geometry or attribute classes.`,
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'string Description',
        summary: 'Descriptive name of the user data.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool ShouldWrite',
        summary: `If you want to save this user data in a 3dm file, override
     ShouldWrite and return true.  If you do support serialization,
     you must also override the Read and Write functions.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Transform Transform',
        summary: `Updated if user data is attached to a piece of geometry that is
     transformed and the virtual OnTransform() is not overridden.  If you
     override OnTransform() and want Transform to be updated, then call the 
     base class OnTransform() in your override.
     The default constructor sets Transform to the identity.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static void Copy(CommonObject source,CommonObject destination)',
        summary: `Expert user tool that copies user data that has a positive 
     CopyCount from the source object to a destination object.
     Generally speaking you don't need to use Copy().
     Simply rely on things like the copy constructors to do the right thing.`,
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'A source object for the data.'
          },
          {
            name: 'destination',
            summary: 'A destination object for the data.'
          }
        ]
      },
      {
        signature: 'static Guid MoveUserDataFrom(CommonObject objectWithUserData)',
        summary: `Moves the user data from objectWithUserData to a temporary data storage
     identifierd by the return Guid.  When MoveUserDataFrom returns, the
     objectWithUserData will not have any user data.`,
        since: 5,
        parameters: [
          {
            name: 'objectWithUserData',
            summary: 'Object with user data attached.'
          }
        ],
        returns: `Guid identifier for storage of UserData that is held in a temporary list
     by this class. This function should be used in conjunction with MoveUserDataTo
     to transfer the user data to a different object.
     Returns Guid.Empty if there was no user data to transfer.`
      },
      {
        signature: 'static void MoveUserDataTo(CommonObject objectToGetUserData,Guid id,bool append)',
        summary: `Moves the user data.
     See  for more information.`,
        since: 5,
        parameters: [
          {
            name: 'objectToGetUserData',
            summary: 'Object data source.'
          },
          {
            name: 'id',
            summary: 'Target.'
          },
          {
            name: 'append',
            summary: 'If the data should be appended or replaced.'
          }
        ]
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Custom',
    name: 'UserDataList',
    dataType: 1,
    summary: 'Represents a collection of user data.',
    interfaces: ['IEnumerable<UserData>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Number of UserData objects in this list.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool Add(UserData userdata)',
        summary: `If the userdata is already in a different UserDataList, it
     will be removed from that list and added to this list.`,
        since: 5,
        parameters: [
          {
            name: 'userdata',
            summary: 'Data element.'
          }
        ],
        returns: 'Whether this operation succeeded.'
      },
      {
        signature: 'bool Contains(Guid userdataId)',
        summary: `Checks for the existence of a specific type of userdata in this list
     Both .NET and native userdata is checked`,
        since: 6.1
      },
      {
        signature: 'UserData Find(Type userdataType)',
        summary: 'Finds a specific data type in this regulated collection.',
        since: 5,
        parameters: [
          {
            name: 'userdataType',
            summary: 'A data type.'
          }
        ],
        returns: 'The found data, or None of nothing was found.'
      },
      {
        signature: 'IEnumerator<UserData> GetEnumerator()',
        summary: 'Get enumerator for UserDataList',
        since: 6
      },
      {
        signature: 'void Purge()',
        summary: 'Removes all user data from this geometry.',
        since: 6
      },
      {
        signature: 'bool Remove(UserData userdata)',
        summary: 'Remove the userdata from this list',
        since: 5.6,
        returns: 'True if the user data was successfully removed'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Custom',
    name: 'UserDataListEnumerator',
    dataType: 1,
    summary: 'Enumerator for UserDataList',
    interfaces: ['IEnumerator<UserData>'],
    constructors: [
      {
        signature: 'UserDataListEnumerator(UserDataList udl)',
        summary: 'Create new UserDataListEnumerator',
        since: 6,
        parameters: [
          {
            name: 'udl',
            summary: 'UserDataList to enumerate'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'UserData Current',
        summary: 'Get current UserData on the enumerator.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Implement Dispose(). NOP.',
        since: 6
      },
      {
        signature: 'bool MoveNext()',
        summary: 'Advance enumerator to next UserData item.',
        since: 6,
        returns: 'True if there is a next item.'
      },
      {
        signature: 'void Reset()',
        summary: 'Reset the enumerator',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Custom',
    name: 'UserDictionary',
    dataType: 1,
    summary: 'Defines the storage data class for a Rhino.Collections.ArchivableDictionary.',
    baseclass: 'Rhino.DocObjects.Custom.UserData',
    properties: [
      {
        signature: 'string Description',
        summary: 'Gets the text "RhinoCommon UserDictionary".',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ArchivableDictionary Dictionary',
        summary: `Gets the dictionary that is associated with this class.
     This dictionary is unique.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool ShouldWrite',
        summary: 'Writes this entity if the count is larger than 0.',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DetailViewObject',
    dataType: 1,
    summary: `A detail view object is a nested Rhino viewport placed on a page view with a 2D closed curve
   boundary. It can be any type of modeling view.`,
    baseclass: 'Rhino.DocObjects.RhinoObject',
    properties: [
      {
        signature: 'string DescriptiveTitle',
        summary: `Detail objects have two strings that can be used to describe the detail:
      1. The name string that is part of the object's attributes
      2. The viewport projection title that is part of the viewport
      This function combines these two strings to create a single "description" string in the form of attribute_name - projection_title.`,
        since: 7,
        property: ['get']
      },
      {
        signature: 'DetailView DetailGeometry',
        summary: 'Returns the detail view geometry.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsActive',
        summary: 'Gets or sets the active state of the detail view.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Transform PageToWorldTransform',
        summary: 'Returns the page coordinate to world coordinate transformation.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RhinoViewport Viewport',
        summary: 'Gets the detail view\'s viewport.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Transform WorldToPageTransform',
        summary: 'Gets the world coordinate to page coordinate transformation.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool CommitViewportChanges()',
        since: 5
      },
      {
        signature: 'bool GetFormattedScale(ScaleFormat format,string value)',
        summary: `Returns the detail view object's scale as a formatted string. 
     The detail view object's viewport must be to parallel projection.`,
        since: 7,
        parameters: [
          {
            name: 'format',
            summary: 'The scale format.'
          },
          {
            name: 'value',
            summary: 'The formatted string'
          }
        ],
        returns: 'True if successful, False otherwise'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DetailViewObject.ScaleFormat',
    dataType: 3,
    summary: 'Detail view object scale formats.',
    values: [
      {
        signature: 'None',
        summary: 'No formatting'
      },
      {
        signature: 'PageLengthToOne',
        summary: '#:1'
      },
      {
        signature: 'OneToModelLength',
        summary: '1:#'
      },
      {
        signature: 'OneInchToModelLengthFeet',
        summary: '1" = #\''
      },
      {
        signature: 'ModelLengthInchToOneFoot',
        summary: '#" = 1\''
      },
      {
        signature: 'ModelLengthInchToOneFootInch',
        summary: '#\' = 1\'-0"'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionObject',
    dataType: 1,
    summary: 'Rhino Object that represents dimension geometry and attributes',
    baseclass: 'Rhino.DocObjects.AnnotationObjectBase',
    properties: [
      {
        signature: 'DimensionStyle DimensionStyle',
        summary: `Gets the DimensionStyle
     associated with this OrdinateDimensionObject.`,
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.AngleDisplayFormat',
    dataType: 3,
    summary: 'Display format for angles',
    values: [
      {
        signature: 'DecimalDegrees   = 0',
        summary: 'Decimal Degrees'
      },
      {
        signature: 'DegMinSec        = 1',
        summary: 'Degrees Minutes Seconds'
      },
      {
        signature: 'Radians          = 2',
        summary: 'Decimal Radians'
      },
      {
        signature: 'Grads            = 3',
        summary: 'Decimal Gradians'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.ArrowFit',
    dataType: 3,
    summary: 'Arrow display position inside or outside extension lines',
    values: [
      {
        signature: 'Auto = 0',
        summary: 'Auto - Display when space permits'
      },
      {
        signature: 'ArrowsInside = 1',
        summary: 'Force arrows inside extensions'
      },
      {
        signature: 'ArrowsOutside = 2',
        summary: 'Force arrows outside extensions'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.ArrowType',
    dataType: 3,
    summary: 'Defines enumerated values for arrowhead shapes.',
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'UserBlock = 1'
      },
      {
        signature: 'SolidTriangle = 2'
      },
      {
        signature: 'Dot = 3'
      },
      {
        signature: 'Tick = 4'
      },
      {
        signature: 'ShortTriangle = 5'
      },
      {
        signature: 'OpenArrow = 6'
      },
      {
        signature: 'Rectangle = 7'
      },
      {
        signature: 'LongTriangle = 8'
      },
      {
        signature: 'LongerTriangle = 9'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.CenterMarkStyle',
    dataType: 3,
    summary: 'Style for drawing centermark for Radial dimensions and Centermark objects',
    values: [
      {
        signature: 'None = 0',
        summary: 'No centermark display'
      },
      {
        signature: 'Mark = 1',
        summary: '+ mark only'
      },
      {
        signature: 'MarkAndLines = 2',
        summary: '+ mark and lines to radius'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.Field',
    dataType: 3,
    summary: 'Field identifiers used for file i/o and getting/setting values',
    values: [
      {
        signature: 'Unset                          = 0'
      },
      {
        signature: 'Name                           = 1',
        summary: 'Dimension style Name property. Cannot be inherited from parent.'
      },
      {
        signature: 'Index                          = 2',
        summary: 'Dimension style runtime model component index property. Cannot be inherited from parent.'
      },
      {
        signature: 'ExtensionLineExtension         = 3'
      },
      {
        signature: 'ExtensionLineOffset            = 4'
      },
      {
        signature: 'Arrowsize                      = 5'
      },
      {
        signature: 'LeaderArrowsize                = 6'
      },
      {
        signature: 'Centermark                     = 7'
      },
      {
        signature: 'TextGap                        = 8'
      },
      {
        signature: 'TextHeight                     = 9'
      },
      {
        signature: 'DimTextLocation                = 10',
        summary: 'Linear, angular, and ordinate dimension text location above/in/below'
      },
      {
        signature: 'MaskFrameType                  = 11',
        summary: 'Text mask frame'
      },
      {
        signature: 'LengthResolution               = 12'
      },
      {
        signature: 'AngleFormat                    = 13'
      },
      {
        signature: 'AngleResolution                = 14'
      },
      {
        signature: 'Font                           = 15'
      },
      {
        signature: 'LengthFactor                   = 16',
        summary: `LengthFactor is a rarely used. It applies when a model is being
     drawn to a scale and the dimension length values should be
     reverse scaled. For example, if a model is drawn at 1/4 scale,
     a line 5 units long indicates the real world line is 20 units
     long. In this case setting LengthFactor to 4 would cause
     a linear dimension applied to that line to display a value of 20.`
      },
      {
        signature: 'Alternate                      = 17'
      },
      {
        signature: 'AlternateLengthFactor          = 18',
        summary: `AlternateLengthFactor is a rarely used. See Length factor for
     a discription of this property.`
      },
      {
        signature: 'AlternateLengthResolution      = 20'
      },
      {
        signature: 'Prefix                         = 21'
      },
      {
        signature: 'Suffix                         = 22'
      },
      {
        signature: 'AlternatePrefix                = 23'
      },
      {
        signature: 'AlternateSuffix                = 24'
      },
      {
        signature: 'DimensionLineExtension         = 25'
      },
      {
        signature: 'SuppressExtension1             = 26'
      },
      {
        signature: 'SuppressExtension2             = 27'
      },
      {
        signature: 'ExtLineColorSource             = 28'
      },
      {
        signature: 'DimLineColorSource             = 29'
      },
      {
        signature: 'ArrowColorSource               = 30'
      },
      {
        signature: 'TextColorSource                = 31'
      },
      {
        signature: 'ExtLineColor                   = 32'
      },
      {
        signature: 'DimLineColor                   = 33'
      },
      {
        signature: 'ArrowColor                     = 34'
      },
      {
        signature: 'TextColor                      = 35'
      },
      {
        signature: 'ExtLinePlotColorSource         = 36'
      },
      {
        signature: 'DimLinePlotColorSource         = 37'
      },
      {
        signature: 'ArrowPlotColorSource           = 38'
      },
      {
        signature: 'TextPlotColorSource            = 39'
      },
      {
        signature: 'ExtLinePlotColor               = 40'
      },
      {
        signature: 'DimLinePlotColor               = 41'
      },
      {
        signature: 'ArrowPlotColor                 = 42'
      },
      {
        signature: 'TextPlotColor                  = 43'
      },
      {
        signature: 'ExtLinePlotWeightSource        = 44'
      },
      {
        signature: 'DimLinePlotWeightSource        = 45'
      },
      {
        signature: 'ExtLinePlotWeight_mm           = 46'
      },
      {
        signature: 'DimLinePlotWeight_mm           = 47'
      },
      {
        signature: 'ToleranceFormat                = 48'
      },
      {
        signature: 'ToleranceResolution            = 49'
      },
      {
        signature: 'ToleranceUpperValue            = 50'
      },
      {
        signature: 'ToleranceLowerValue            = 51'
      },
      {
        signature: 'AltToleranceResolution         = 52'
      },
      {
        signature: 'ToleranceHeightScale           = 53'
      },
      {
        signature: 'BaselineSpacing                = 54'
      },
      {
        signature: 'DrawMask                       = 55'
      },
      {
        signature: 'MaskColorSource                = 56'
      },
      {
        signature: 'MaskColor                      = 57'
      },
      {
        signature: 'MaskBorder                     = 58'
      },
      {
        signature: 'DimensionScale                 = 59'
      },
      {
        signature: 'DimscaleSource                 = 60'
      },
      {
        signature: 'FixedExtensionLength           = 61'
      },
      {
        signature: 'FixedExtensionOn               = 62'
      },
      {
        signature: 'TextRotation                   = 63'
      },
      {
        signature: 'SuppressArrow1                 = 64'
      },
      {
        signature: 'SuppressArrow2                 = 65'
      },
      {
        signature: 'TextmoveLeader                 = 66'
      },
      {
        signature: 'ArclengthSymbol                = 67'
      },
      {
        signature: 'StackTextheightScale           = 68'
      },
      {
        signature: 'StackFormat                    = 69'
      },
      {
        signature: 'AltRound                       = 70'
      },
      {
        signature: 'Round                          = 71'
      },
      {
        signature: 'AngularRound                   = 72'
      },
      {
        signature: 'AltZeroSuppress                = 73'
      },
      {
        signature: 'AngleZeroSuppress              = 75'
      },
      {
        signature: 'ZeroSuppress                   = 76'
      },
      {
        signature: 'AltBelow                       = 77'
      },
      {
        signature: 'ArrowType1                     = 78'
      },
      {
        signature: 'ArrowType2                     = 79'
      },
      {
        signature: 'LeaderArrowType                = 80'
      },
      {
        signature: 'ArrowBlockId1                  = 81'
      },
      {
        signature: 'ArrowBlockId2                  = 82'
      },
      {
        signature: 'LeaderArrowBlock               = 83'
      },
      {
        signature: 'DimRadialTextLocation          = 84',
        summary: 'Radial dimension text location above/in/below'
      },
      {
        signature: 'TextVerticalAlignment          = 85'
      },
      {
        signature: 'LeaderTextVerticalAlignment    = 86'
      },
      {
        signature: 'LeaderContentAngleStyle        = 87'
      },
      {
        signature: 'LeaderCurveType                = 88'
      },
      {
        signature: 'LeaderContentAngle             = 89'
      },
      {
        signature: 'LeaderHasLanding               = 90'
      },
      {
        signature: 'LeaderLandingLength            = 91'
      },
      {
        signature: 'MaskFlags                      = 92'
      },
      {
        signature: 'CentermarkStyle                = 93'
      },
      {
        signature: 'TextHorizontalAlignment        = 94'
      },
      {
        signature: 'LeaderTextHorizontalAlignment  = 95'
      },
      {
        signature: 'DrawForward                    = 96'
      },
      {
        signature: 'SignedOrdinate                 = 97'
      },
      {
        signature: 'UnitSystem                     = 98',
        summary: `Unit system for dimension rendering sizes like  TextHeight, TextGap, ArrowSize, ExtOffset,
     and dozens of other properties that control the appearance and placement of the components
     used to render a dimension.`
      },
      {
        signature: 'TextMask                       = 99'
      },
      {
        signature: 'TextOrientation                = 100'
      },
      {
        signature: 'LeaderTextOrientation          = 101'
      },
      {
        signature: 'DimTextOrientation             = 102'
      },
      {
        signature: 'DimRadialTextOrientation       = 103'
      },
      {
        signature: 'DimTextAngleStyle              = 104'
      },
      {
        signature: 'DimRadialTextAngleStyle        = 105'
      },
      {
        signature: 'TextUnderlined                 = 106'
      },
      {
        signature: 'DimensionLengthDisplay = 109',
        summary: 'Dimension length display. See ON_DimStyle::DimensionLengthDisplay() for a descpription of this parameter.'
      },
      {
        signature: 'AlternateDimensionLengthDisplay = 110',
        summary: 'Alternate dimension length display. See ON_DimStyle::AlternateDimensionLengthDisplay() for a descpription of this parameter.'
      },
      {
        signature: 'ForceDimLine = 111',
        summary: 'Force dimension line to draw when text is moved outside'
      },
      {
        signature: 'ArrowFit = 112',
        summary: 'Arrow position when arrows won\'t fit between extensions'
      },
      {
        signature: 'TextFit = 113',
        summary: 'Text position when text won\'t fit between extensions'
      },
      {
        signature: 'DecimalSeparator = 114',
        summary: 'Character to use for decimal separator in dimension text'
      },
      {
        signature: 'Count = 115',
        summary: 'Every enum UINT value that identifies a valid dimension style property is less than the UINT value of Count.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.LeaderContentAngleStyle',
    dataType: 3,
    summary: 'Angle for text or other leader or dimension content',
    values: [
      {
        signature: 'Horizontal = 0',
        summary: 'Annotation text is horizontal in annotation object\'s plane'
      },
      {
        signature: 'Aligned = 1',
        summary: 'Aligned with last leader direction or dimension line'
      },
      {
        signature: 'Rotated = 2',
        summary: 'Explicit angle'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.LeaderCurveStyle',
    dataType: 3,
    summary: 'Type of leader curve',
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'Polyline = 1'
      },
      {
        signature: 'Spline = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.LengthDisplay',
    dataType: 3,
    summary: 'Dimension display length unit system and style',
    values: [
      {
        signature: 'ModelUnits = 0',
        summary: 'Decimal current model units'
      },
      {
        signature: 'Millmeters = 3',
        summary: 'Decimal Millimeters'
      },
      {
        signature: 'Centimeters = 4',
        summary: 'Decimal Centimeters'
      },
      {
        signature: 'Meters = 5',
        summary: 'Decimal Meters'
      },
      {
        signature: 'Kilometers = 6',
        summary: 'Decimal Kilometers'
      },
      {
        signature: 'InchesDecimal = 7',
        summary: 'Decimal Inches'
      },
      {
        signature: 'InchesFractional = 1',
        summary: 'Fractional Inches ( 1.75 inches displays as 1-3/4 )'
      },
      {
        signature: 'FeetDecimal = 8',
        summary: 'Decimal Feet'
      },
      {
        signature: 'FeetAndInches = 2',
        summary: 'Feet and Inches ( 14.75 inches displays as 1\'-2-3/4" )'
      },
      {
        signature: 'Miles = 9',
        summary: 'Decimal Miles'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.LengthDisplayFormat',
    dataType: 3,
    summary: 'Obsolete format for length display - use ON_DimStyle::DimensionLengthDisplay instead',
    values: [
      {
        signature: 'Decimal       = 0',
        summary: 'Obsolete - use ON_DimStyle::DimensionLengthDisplay::ModelUnits.'
      },
      {
        signature: 'Fractional    = 1',
        summary: 'Obsolete - use ON_DimStyle::DimensionLengthDisplay::InchesFractional'
      },
      {
        signature: 'FeetInches = 2',
        summary: 'Obsolete - use ON_DimStyle::DimensionLengthDisplay::FeetAndInches'
      },
      {
        signature: 'FeetDecimalInches = 3',
        summary: 'Obsolete - use ON_DimStyle::DimensionLengthDisplay::FeetAndInches enum.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.MaskFrame',
    dataType: 3,
    summary: 'Draw a frame stroke around the text mask area',
    values: [
      {
        signature: 'NoFrame = 0',
        summary: 'Text mask frame not drawn'
      },
      {
        signature: 'RectFrame = 1',
        summary: 'Text mask frame outline rectangle drawn'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.MaskType',
    dataType: 3,
    summary: 'Text mask drawn with background color or explicit color',
    values: [
      {
        signature: 'BackgroundColor = 0',
        summary: 'Text mask drawn with background color'
      },
      {
        signature: 'MaskColor = 1',
        summary: 'Text mask drawn with explicit color'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.StackDisplayFormat',
    dataType: 3,
    summary: 'Format of stacked fractions',
    values: [
      {
        signature: 'None               = 0',
        summary: 'No stacking'
      },
      {
        signature: 'StackHorizontal    = 1',
        summary: 'Stack with horizontal line'
      },
      {
        signature: 'StackDiagonal      = 2',
        summary: 'Stack with angled line'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.TextFit',
    dataType: 3,
    summary: 'Text display position inside or outside extension lines',
    values: [
      {
        signature: 'Auto = 0',
        summary: 'Auto - Display inside when space permits'
      },
      {
        signature: 'TextInside = 1',
        summary: 'Force text inside extensions'
      },
      {
        signature: 'TextRight = 2',
        summary: 'Force text outside to the right of extensions'
      },
      {
        signature: 'TextLeft = 3',
        summary: 'Force text outside to the left of extensions'
      },
      {
        signature: 'TextHintRight = 4',
        summary: 'Move text outside to the right of extensions when it won\'t fit inside'
      },
      {
        signature: 'TextHintLeft = 5',
        summary: 'Move text outside to the left of extensions when it won\'t fit inside'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.TextLocation',
    dataType: 3,
    summary: 'The location of text in linear, angular, radial, and ordinate dimensions.',
    values: [
      {
        signature: 'AboveDimLine = 0',
        summary: 'Text is above dimension line.'
      },
      {
        signature: 'InDimLine = 1',
        summary: 'Text is centered in dimension line.'
      },
      {
        signature: 'BelowDimLine = 2',
        summary: 'Text is below dimension line.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.ToleranceDisplayFormat',
    dataType: 3,
    summary: 'Style of tolerance display for dimensions',
    values: [
      {
        signature: 'None = 0',
        summary: 'No tolerance display'
      },
      {
        signature: 'Symmetrical = 1',
        summary: 'Symmetrical +/- tolerance'
      },
      {
        signature: 'Deviation = 2',
        summary: 'Distance +tol, -tol'
      },
      {
        signature: 'Limits = 3',
        summary: 'Distance upper and lower limits'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DimensionStyle.ZeroSuppression',
    dataType: 3,
    summary: 'Marks leading and trailing zeros for removal.',
    values: [
      {
        signature: 'None                          = 0',
        summary: 'No zero suppression.'
      },
      {
        signature: 'SuppressLeading               = 1',
        summary: 'Suppress leading zeros.'
      },
      {
        signature: 'SuppressTrailing              = 2',
        summary: 'Suppress trailing zeros.'
      },
      {
        signature: 'SuppressLeadingAndTrailing    = 3',
        summary: 'Suppress leading and trailing zeros.'
      },
      {
        signature: 'SuppressZeroFeet              = 4',
        summary: 'Suppress zero feet.'
      },
      {
        signature: 'SuppressZeroInches            = 8',
        summary: 'Suppress zero inches.'
      },
      {
        signature: 'SuppressZeroFeetAndZeroInches = 12',
        summary: 'Suppress zero feet and zero inches.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DisplayMode',
    dataType: 3,
    summary: 'Defines enumerated values for display modes, such as wireframe or shaded.',
    values: [
      {
        signature: 'Default = 0',
        summary: 'The default display mode.'
      },
      {
        signature: 'Wireframe = 1',
        summary: `The wireframe display mode.
       Objects are generally only outlined by their corresponding isocurves and edges.`
      },
      {
        signature: 'Shaded = 2',
        summary: `The shaded display mode.
       Objects are generally displayed with their corresponding isocurves and edges,
       and are filled with their diplay colors.`
      },
      {
        signature: 'RenderPreview = 3',
        summary: `The render display mode.
       Objects are generally displayed in a similar way to the one that will be resulting
       from rendering.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'DistanceDisplayMode',
    dataType: 3,
    summary: 'Defines enumerated values for the display of distances in US customary and Imperial units.',
    values: [
      {
        signature: 'Decimal = 0',
        summary: 'Shows distance decimals.'
      },
      {
        signature: 'Feet = 1',
        summary: 'Show feet.'
      },
      {
        signature: 'FeetAndInches = 2',
        summary: 'Show feet and inches.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'EarthAnchorPoint',
    dataType: 1,
    summary: `Contains information about the model's position in latitude, longitude,
   and elevation for GIS mapping applications.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'EarthAnchorPoint()',
        summary: 'Initializes a new instance of the EarthAnchorPoint class.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'string Description',
        summary: 'Gets or sets the long form of the identifying information about this location.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double EarthBasepointElevation',
        summary: 'Gets or sets the point elevation on earth, in meters.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'BasepointZero EarthBasepointElevationZero',
        summary: 'Gets or sets a value indicating the zero level convention relating to a location on Earth.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double EarthBasepointLatitude',
        summary: `Gets or sets a point latitude on earth, in decimal degrees.
     +90 = north pole, 0 = equator, -90 = south pole.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double EarthBasepointLongitude',
        summary: `Gets or sets the point longitude on earth, in decimal degrees.
     0 = prime meridian (Greenwich meridian)Values increase towards West`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d ModelBasePoint',
        summary: 'Corresponding model point in model coordinates.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d ModelEast',
        summary: 'Earth directions in model coordinates.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d ModelNorth',
        summary: 'Earth directions in model coordinates.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Name',
        summary: 'Gets or sets the short form of the identifying information about this location.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'bool EarthLocationIsSet()',
        summary: 'Checks if the earth location is set or not.',
        since: 6,
        returns: 'Bool value, True if set else false'
      },
      {
        signature: 'Plane GetEarthAnchorPlane(Vector3d anchorNorth)',
        summary: 'Returns the earth anchor plane',
        since: 6,
        returns: 'A plane value.'
      },
      {
        signature: 'Plane GetModelCompass()',
        summary: `Returns a plane in model coordinates whose X axis points East,
     Y axis points North and Z axis points Up. The origin
     is set to ModelBasepoint.`,
        since: 5,
        returns: 'A plane value. This might be invalid on error.'
      },
      {
        signature: 'Transform GetModelToEarthTransform(UnitSystem modelUnitSystem)',
        summary: `Gets a transformation from model coordinates to earth coordinates.
     This transformation assumes the model is small enough that
     the curvature of the earth can be ignored.`,
        since: 5,
        parameters: [
          {
            name: 'modelUnitSystem',
            summary: 'The model unit system.'
          }
        ],
        returns: 'Transform on success. Inalid Transform on error.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ExtrusionObject',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.RhinoObject',
    properties: [
      {
        signature: 'Extrusion ExtrusionGeometry',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Extrusion DuplicateExtrusionGeometry()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'Font.FontOrigin',
    dataType: 3,
    summary: `Platform where font originated. This information is useful when 
   searching for appropriate substitues.`,
    values: [
      {
        signature: 'Unset = 0',
        summary: 'Not set.'
      },
      {
        signature: 'Unknown = 1',
        summary: 'Origin unknown. Changing an ON_Font characteristic like weight or sytle sets the origin to unknown.'
      },
      {
        signature: 'WindowsFont = 2',
        summary: `Set from a Windows IDWriteFont by ON_Font::SetFromDWriteFont() 
     or a Windows LOGFONT by ON_Font::SetFromWindowsLogFont() and
     FaceName and WindowLogfontName match a font installed on a Windows device.`
      },
      {
        signature: 'AppleFont = 3',
        summary: `Set from an Apple CTFont. The PostScriptName() and FamilyName() match a
     font installed on device running MacOS or iOS. The FaceName() matches
     the "typeface" name shonw in the MacOS FontBook app.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'Font.FontStretch',
    dataType: 3,
    summary: 'Horizontal expansion or contraction of font',
    values: [
      {
        signature: 'Unset = 0',
        summary: 'Not set.'
      },
      {
        signature: 'Ultracondensed = 1'
      },
      {
        signature: 'Extracondensed = 2'
      },
      {
        signature: 'Condensed = 3'
      },
      {
        signature: 'Semicondensed = 4'
      },
      {
        signature: 'Medium = 5',
        summary: 'Default font stretch.'
      },
      {
        signature: 'Semiexpanded = 6'
      },
      {
        signature: 'Expanded = 7'
      },
      {
        signature: 'Extraexpanded = 8'
      },
      {
        signature: 'Ultraexpanded = 9'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'Font.FontStyle',
    dataType: 3,
    summary: `Vertical angle of font
   Upright, Italic, or Oblique`,
    values: [
      {
        signature: 'Unset = 0',
        summary: 'Not set.'
      },
      {
        signature: 'Upright = 1',
        summary: 'Default font style.'
      },
      {
        signature: 'Italic = 2',
        summary: `The face is sloped so the top is to the right of the base.
     Face names sometimes use the word "oblique" for italic faces.`
      },
      {
        signature: 'Oblique = 3',
        summary: `The face is sloped so the top is to the left of the base.
     This is extremely rare.
     NOTE WELL: Face names sometimes use the word "oblique" for italic faces.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'Font.FontType',
    dataType: 3,
    summary: 'An enum that reports if the font face is avaialable on the current device.',
    values: [
      {
        signature: 'Unset = 0',
        summary: 'Not set.'
      },
      {
        signature: 'ManagedFont = 1',
        summary: 'In the managed font list.'
      },
      {
        signature: 'InstalledFont = 2',
        summary: 'In the installed font list.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'Font.FontWeight',
    dataType: 3,
    summary: `Weight enum values
   Avoid casting these values to int.
   Use ON_Font::WindowsLogfontWeightFromWeight() or
   ON_Font::AppleWeightOfFontFromWeight() or
   add another converter.`,
    values: [
      {
        signature: 'Unset = 0',
        summary: 'Not set.'
      },
      {
        signature: 'Thin = 1',
        summary: 'IsLight = True'
      },
      {
        signature: 'Ultralight = 2',
        summary: 'IsLight = True'
      },
      {
        signature: 'Light = 3',
        summary: 'IsLight = True'
      },
      {
        signature: 'Normal = 4',
        summary: 'Default font weight. IsNormalWeight = True  Also called Regular.'
      },
      {
        signature: 'Medium = 5',
        summary: 'IsNormalWeight = True'
      },
      {
        signature: 'Semibold = 6',
        summary: 'IsBold = True'
      },
      {
        signature: 'Bold = 7',
        summary: 'IsBold = True'
      },
      {
        signature: 'Ultrabold = 8',
        summary: 'IsBold = True'
      },
      {
        signature: 'Heavy      = 9',
        summary: 'IsBold = True Also called Black'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'FontQuartet',
    dataType: 1,
    constructors: [
      {
        signature: 'FontQuartet(string name,bool supportsRegular,bool supportsBold,bool supportsItalic,bool supportsBoldItalic)'
      }
    ],
    properties: [
      {
        signature: 'bool HasBoldFont',
        since: 6.7,
        property: ['get', 'set']
      },
      {
        signature: 'bool HasBoldItalicFont',
        since: 6.7,
        property: ['get', 'set']
      },
      {
        signature: 'bool HasItalicFont',
        since: 6.7,
        property: ['get', 'set']
      },
      {
        signature: 'bool HasRegularFont',
        since: 6.7,
        property: ['get', 'set']
      },
      {
        signature: 'string QuartetName',
        since: 6.7,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'string ToString()'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'GripObject',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.RhinoObject',
    properties: [
      {
        signature: 'Point3d CurrentLocation',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int Index',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool Moved',
        summary: 'True if the grip has moved from OriginalLocation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d OriginalLocation',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid OwnerId',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Weight',
        summary: `The weight of a NURBS control point grip or RhinoMath.UnsetValue
     if the grip is not a NURBS control point grip.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'bool GetCageParameters(double u,double v,double w)',
        summary: 'Retrieves the 2d parameter space values of this GripObject from the cage it\'s associated with.',
        since: 6,
        returns: 'True on success. Output is unreliable if return is false.'
      },
      {
        signature: 'bool GetCurveParameters(double t)',
        summary: 'Retrieves the 2d parameter space values of this GripObject from the curve it\'s associated with.',
        since: 6,
        returns: 'True on success. Output is unreliable if return is false.'
      },
      {
        signature: 'bool GetGripDirections(Vector3d u,Vector3d v,Vector3d normal)',
        summary: `Sometimes grips have directions.  These directions
     can have any length and do not have to be orthoganal.`,
        since: 6,
        parameters: [
          {
            name: 'u',
            summary: 'u direction'
          },
          {
            name: 'v',
            summary: 'v direction'
          },
          {
            name: 'normal',
            summary: 'normal direction'
          }
        ],
        returns: 'True if the grip has directions.'
      },
      {
        signature: 'bool GetSurfaceParameters(double u,double v)',
        summary: 'Retrieves the 2d parameter space values of this GripObject from the surface it\'s associated with.',
        since: 6,
        returns: 'True on success. Output is unreliable if return is false.'
      },
      {
        signature: 'void Move(Point3d newLocation)',
        summary: 'Moves the grip to a new location.',
        since: 5,
        parameters: [
          {
            name: 'newLocation',
            summary: 'New location for grip.'
          }
        ]
      },
      {
        signature: 'void Move(Transform xform)',
        summary: 'Moves the grip to a new location.',
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation appliead to the OriginalLocation point.'
          }
        ]
      },
      {
        signature: 'void Move(Vector3d delta)',
        summary: 'Moves the grip to a new location.',
        since: 5,
        parameters: [
          {
            name: 'delta',
            summary: 'Translation applied to the OriginalLocation point.'
          }
        ]
      },
      {
        signature: 'GripObject NeighborGrip(int directionR,int directionS,int directionT,bool wrap)',
        summary: `Used to get a grip's logical neighbors, like NURBS curve, suface,
     and cage control point grips.`,
        since: 5,
        parameters: [
          {
            name: 'directionR',
            summary: `-1 to go back one grip, +1 to move forward one grip.  For curves, surfaces
     and cages, this is the first parameter direction.`
          },
          {
            name: 'directionS',
            summary: `-1 to go back one grip, +1 to move forward one grip.  For surfaces and
     cages this is the second parameter direction.`
          },
          {
            name: 'directionT',
            summary: 'For cages this is the third parameter direction'
          },
          {
            name: 'wrap',
            summary: ''
          }
        ],
        returns: 'logical neighbor or None if the is no logical neighbor'
      },
      {
        signature: 'void UndoMove()',
        summary: 'Undoes any grip moves made by calling Move.',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'Group',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.ModelComponent',
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.Group.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int UserStringCount',
        summary: 'Gets the amount of user strings.',
        since: 6.4,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'string GetUserString(string key)',
        summary: 'Gets user string from this geometry.',
        since: 6.4,
        parameters: [
          {
            name: 'key',
            summary: 'id used to retrieve the string.'
          }
        ],
        returns: 'string associated with the key if successful. None if no key was found.'
      },
      {
        signature: 'System.Collections.Specialized.NameValueCollection GetUserStrings()',
        summary: 'Gets a copy of all (user key string, user value string) pairs attached to this geometry.',
        since: 6.4,
        returns: 'A new collection.'
      },
      {
        signature: 'bool SetUserString(string key,string value)',
        summary: 'Attach a user string (key,value combination) to this geometry.',
        since: 6.4,
        parameters: [
          {
            name: 'key',
            summary: 'id used to retrieve this string.'
          },
          {
            name: 'value',
            summary: 'string associated with key.'
          }
        ],
        returns: 'True on success.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'HatchObject',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.RhinoObject',
    properties: [
      {
        signature: 'Hatch HatchGeometry',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool SetHatchGeometry(Hatch hatch)',
        summary: 'Replaces a hatch object\'s underlying hatch geometry. This only works for non-document hatch objects.',
        since: 7,
        parameters: [
          {
            name: 'hatch',
            summary: 'The replacement hatch geometry.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'HatchPattern',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.ModelComponent',
    constructors: [
      {
        signature: 'HatchPattern()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.HatchPattern.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Description',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'HatchPatternFillType FillType',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int Index',
        summary: 'Index in the hatch pattern table for this pattern. -1 if not in the table.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsDeleted',
        summary: `Deleted hatch patterns are kept in the runtime hatch pattern table so that undo
     will work with hatch patterns.  Call IsDeleted to determine to determine if
     a hatch pattern is deleted.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsReference',
        summary: `Rhino allows multiple files to be viewed simultaneously. Hatch patterns in the
     document are "normal" or "reference". Reference hatch patterns are not saved.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static HatchPattern[] ReadFromFile(string filename,bool quiet)',
        summary: 'Reads hatch pattern definitions from a file.',
        since: 5,
        parameters: [
          {
            name: 'filename',
            summary: 'Name of an existing file. If filename is None or empty, default hatch pattern filename is used.'
          },
          {
            name: 'quiet',
            summary: 'Ignored.'
          }
        ],
        returns: 'An array of hatch patterns. This can be null, but not empty.'
      },
      {
        signature: 'Rhino.Geometry.Line[] CreatePreviewGeometry(int width,int height,double angle)',
        summary: 'Creates preview line segments of the hatch pattern.',
        since: 6.8,
        parameters: [
          {
            name: 'width',
            summary: 'The width of the preview.'
          },
          {
            name: 'height',
            summary: 'The height of the preview.'
          },
          {
            name: 'angle',
            summary: 'The rotation angle of the pattern display in radians.'
          }
        ],
        returns: 'The preview line segments if successful, an empty array on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'HatchPattern.Defaults',
    dataType: 1,
    properties: [
      {
        signature: 'static HatchPattern Dash',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static HatchPattern Grid',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static HatchPattern Grid60',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static HatchPattern Hatch1',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static HatchPattern Hatch2',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static HatchPattern Hatch3',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static HatchPattern Plus',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static HatchPattern Solid',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static HatchPattern Squares',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'HatchPatternFillType',
    dataType: 3,
    values: [
      {
        signature: 'Solid = 0'
      },
      {
        signature: 'Lines = 1'
      },
      {
        signature: 'Gradient = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'HistoryRecord',
    dataType: 1,
    summary: 'Provides a single bundling of information to be passed to Rhino when setting up history for an object.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'HistoryRecord(Command command,int version)',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'bool CopyOnReplaceObject',
        summary: `When an object is replaced and the old object has a history record with
     this field set, the history record is copied and attached to the new object.
     That allows a descendant object to continue the history linkage after
     it is edited.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'IntPtr Handle',
        summary: 'Wrapped native C++ pointer to CRhinoHistory instance',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'bool SetBool(int id,bool value)',
        since: 5
      },
      {
        signature: 'bool SetBools(int id,IEnumerable<bool> values)',
        since: 5
      },
      {
        signature: 'bool SetBrep(int id,Brep value)',
        since: 5
      },
      {
        signature: 'bool SetColor(int id,Color value)',
        since: 5
      },
      {
        signature: 'bool SetColors(int id,IEnumerable<Color> values)',
        since: 5
      },
      {
        signature: 'bool SetCurve(int id,Curve value)',
        since: 5
      },
      {
        signature: 'bool SetDouble(int id,double value)',
        since: 5
      },
      {
        signature: 'bool SetDoubles(int id,IEnumerable<double> values)',
        since: 5
      },
      {
        signature: 'bool SetGuid(int id,Guid value)',
        since: 5
      },
      {
        signature: 'bool SetGuids(int id,IEnumerable<Guid> values)',
        since: 5
      },
      {
        signature: 'bool SetHistoryVersion(int historyVersion)',
        summary: `Specifies a non-zero integer that identifies the version of
     this history record. The virtual ReplayHistory() functions
     can check this version to avoid replaying history using
     information created by earlier versions of the command.`,
        since: 6,
        parameters: [
          {
            name: 'historyVersion',
            summary: `Any non-zero integer.
     It is strongly suggested that something like YYYYMMDD be used.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool SetInt(int id,int value)',
        since: 5
      },
      {
        signature: 'bool SetInts(int id,IEnumerable<int> values)',
        since: 5
      },
      {
        signature: 'bool SetMesh(int id,Mesh value)',
        since: 5
      },
      {
        signature: 'bool SetObjRef(int id,ObjRef value)',
        since: 5
      },
      {
        signature: 'bool SetPoint3d(int id,Point3d value)',
        since: 5
      },
      {
        signature: 'bool SetPoint3dOnObject(int id,ObjRef objref,Point3d value)',
        since: 5
      },
      {
        signature: 'bool SetPoint3ds(int id,IEnumerable<Point3d> values)',
        since: 5
      },
      {
        signature: 'bool SetString(int id,string value)',
        since: 5
      },
      {
        signature: 'bool SetStrings(int id,IEnumerable<string> values)',
        since: 5
      },
      {
        signature: 'bool SetSurface(int id,Surface value)',
        since: 5
      },
      {
        signature: 'bool SetTransorm(int id,Transform value)',
        since: 5
      },
      {
        signature: 'bool SetVector3d(int id,Vector3d value)',
        since: 5
      },
      {
        signature: 'bool SetVector3ds(int id,IEnumerable<Vector3d> values)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'InstanceDefinition',
    dataType: 1,
    summary: 'This is the same as InstanceDefinitionGeometry, but in a Rhino document.',
    baseclass: 'Rhino.Geometry.InstanceDefinitionGeometry',
    properties: [
      {
        signature: 'InstanceDefinitionArchiveFileStatus ArchiveFileStatus',
        summary: 'Returns the archive file status of a linked instance definition.',
        since: 5.2,
        property: ['get']
      },
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.InstanceDefinition.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Description',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid Id',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Index',
        summary: 'Index of this instance definition in the index definition table.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsDeleted',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsReference',
        summary: `An object from a work session reference model is reference a
     reference object and cannot be modified.  An object is a reference
     object if, and only if, it is on a reference layer.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsTenuous',
        since: 5,
        property: ['get']
      },
      {
        signature: 'InstanceDefinitionLayerStyle LayerStyle',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string Name',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int ObjectCount',
        summary: `Number of objects this definition uses. This counts the objects that are used to define the geometry.
     This does NOT count the number of references to this instance definition.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool SkipNestedLinkedDefinitions',
        summary: 'Controls how much geometry is read when a linked InstanceDefinition is updated.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string SourceArchive',
        since: 5,
        property: ['get']
      },
      {
        signature: 'InstanceDefinitionUpdateType UpdateType',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string Url',
        summary: 'The hyperlink URL that is executed when the UrlDescription hyperlink is clicked on in the Insert and Block UI',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string UrlDescription',
        summary: 'The URL description displayed as a hyperlink in the Insert and Block UI',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'System.Drawing.Bitmap CreatePreviewBitmap(DefinedViewportProjection definedViewportProjection,DisplayMode displayMode,Size bitmapSize)',
        summary: 'Creates a preview bitmap of the instance definition.',
        since: 5,
        parameters: [
          {
            name: 'definedViewportProjection',
            summary: 'The view projection.'
          },
          {
            name: 'displayMode',
            summary: 'The display mode.'
          },
          {
            name: 'bitmapSize',
            summary: 'The bitmap size in pixels.'
          }
        ],
        returns: 'The preview bitmap if successful, None otherwise.'
      },
      {
        signature: 'System.Drawing.Bitmap CreatePreviewBitmap(DefinedViewportProjection definedViewportProjection,DisplayMode displayMode,Size bitmapSize,bool applyDpiScaling)',
        summary: 'Creates a preview bitmap of the instance definition.',
        since: 6,
        parameters: [
          {
            name: 'definedViewportProjection',
            summary: 'The view projection.'
          },
          {
            name: 'displayMode',
            summary: 'The display mode.'
          },
          {
            name: 'bitmapSize',
            summary: 'The bitmap size in pixels.'
          },
          {
            name: 'applyDpiScaling',
            summary: 'Specify True to apply DPI scaling (Windows-only).'
          }
        ],
        returns: 'The preview bitmap if successful, None otherwise.'
      },
      {
        signature: 'System.Drawing.Bitmap CreatePreviewBitmap(DefinedViewportProjection definedViewportProjection,Size bitmapSize)',
        summary: 'Creates a wireframe preview bitmap of the instance definition.',
        since: 5,
        parameters: [
          {
            name: 'definedViewportProjection',
            summary: 'The view projection.'
          },
          {
            name: 'bitmapSize',
            summary: 'The bitmap size in pixels.'
          }
        ],
        returns: 'The preview bitmap if successful, None otherwise.'
      },
      {
        signature: 'System.Drawing.Bitmap CreatePreviewBitmap(DefinedViewportProjection definedViewportProjection,Size bitmapSize,bool applyDpiScaling)',
        summary: 'Creates a wireframe preview bitmap of the instance definition.',
        since: 6,
        parameters: [
          {
            name: 'definedViewportProjection',
            summary: 'The view projection.'
          },
          {
            name: 'bitmapSize',
            summary: 'The bitmap size in pixels.'
          },
          {
            name: 'applyDpiScaling',
            summary: 'Specify True to apply DPI scaling (Windows-only).'
          }
        ],
        returns: 'The preview bitmap if successful, None otherwise.'
      },
      {
        signature: 'System.Drawing.Bitmap CreatePreviewBitmap(Guid definitionObjectId,DefinedViewportProjection definedViewportProjection,DisplayMode displayMode,Size bitmapSize,bool applyDpiScaling)',
        summary: 'Creates a preview bitmap of the instance definition.',
        since: 6.21,
        parameters: [
          {
            name: 'definitionObjectId',
            summary: 'Id of one of this definition\'s objects to draw selected.'
          },
          {
            name: 'definedViewportProjection',
            summary: 'The view projection.'
          },
          {
            name: 'displayMode',
            summary: 'The display mode.'
          },
          {
            name: 'bitmapSize',
            summary: 'The bitmap size in pixels.'
          },
          {
            name: 'applyDpiScaling',
            summary: 'Specify True to apply DPI scaling (Windows-only).'
          }
        ],
        returns: 'The preview bitmap if successful, None otherwise.'
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Equality is checked against InstanceDefinition.Id',
        returns: 'True if obj.Id equals Id'
      },
      {
        signature: 'InstanceDefinition[] GetContainers()',
        summary: 'Gets a list of all the InstanceDefinitions that contain a reference this InstanceDefinition.',
        since: 5,
        returns: 'An array of instance definitions. The returned array can be empty, but not null.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Use Id.GetHashCode()'
      },
      {
        signature: 'RhinoObject[] GetObjects()',
        summary: 'Gets an array with the objects that belong to this instance definition.',
        since: 5,
        returns: 'An array of Rhino objects. The returned array can be empty, but not null.'
      },
      {
        signature: 'InstanceObject[] GetReferences(int wheretoLook)',
        summary: `Gets a list of the CRhinoInstanceObjects (inserts) that contains
     a reference this instance definition.`,
        since: 5,
        parameters: [
          {
            name: 'wheretoLook',
            summary: '0 = get top level references in active document.1 = get top level and nested references in active document.2 = check for references from other instance definitions.'
          }
        ],
        returns: 'An array of instance objects. The returned array can be empty, but not null.'
      },
      {
        signature: 'bool InUse(int wheretoLook)',
        summary: 'Determines whether the instance definition is referenced.',
        since: 5,
        parameters: [
          {
            name: 'wheretoLook',
            summary: '0 = check for top level references in active document.1 = check for top level and nested references in active document.2 = check for references in other instance definitions.'
          }
        ],
        returns: 'True if the instance definition is used; otherwise false.'
      },
      {
        signature: 'RhinoObject Object(int index)',
        summary: 'returns an object used as part of this definition.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: '0 <= index < ObjectCount.'
          }
        ],
        returns: `Returns an object that is used to define the geometry.
     Does NOT return an object that references this definition.count the number of references to this instance.`
      },
      {
        signature: 'int UsesDefinition(int otherIdefIndex)',
        summary: 'Determines if this instance definition contains a reference to another instance definition.',
        since: 5,
        parameters: [
          {
            name: 'otherIdefIndex',
            summary: 'index of another instance definition.'
          }
        ],
        returns: `0      no
       1      other_idef_index is the index of this instance definition
      >1      This InstanceDefinition uses the instance definition
              and the returned value is the nesting depth.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'InstanceDefinitionArchiveFileStatus',
    dataType: 3,
    summary: `The archive file of a linked instance definition can have the following possible states.
   Use InstanceObject.ArchiveFileStatus to query a instance definition's archive file status.`,
    values: [
      {
        signature: 'NotALinkedInstanceDefinition = -3',
        summary: 'The instance definition is not a linked instance definition.'
      },
      {
        signature: 'LinkedFileNotReadable = -2',
        summary: 'The instance definition\'s archive file is not readable.'
      },
      {
        signature: 'LinkedFileNotFound = -1',
        summary: 'The instance definition\'s archive file cannot be found.'
      },
      {
        signature: 'LinkedFileIsUpToDate = 0',
        summary: 'The instance definition\'s archive file is up-to-date.'
      },
      {
        signature: 'LinkedFileIsNewer = 1',
        summary: 'The instance definition\'s archive file is newer.'
      },
      {
        signature: 'LinkedFileIsOlder = 2',
        summary: 'The instance definition\'s archive file is older.'
      },
      {
        signature: 'LinkedFileIsDifferent = 3',
        summary: 'The instance definition\'s archive file is different.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'InstanceDefinitionLayerStyle',
    dataType: 3,
    summary: `A InstanceDefinitionUpdateType.Static or InstanceDefinitionUpdateType.LinkedAndEmbedded idef
   must have LayerStyle = Unset, a InstanceDefinitionUpdateType.Linked InstanceDefnition must
   have LayerStyle = Active or Reference`,
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'Active = 1'
      },
      {
        signature: 'Reference = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'InstanceDefinitionUpdateType',
    dataType: 3,
    summary: `The possible relationships between the instance definition geometry
   and the archive containing the original defition.`,
    values: [
      {
        signature: 'Static = 0',
        summary: `The Rhino user interface uses the term "Embedded" for Static update types.
     This instance definition is never updated. If m_source_archive is set,
     it records the origin of the instance definition geometry, but
     m_source_archive is never used to update the instance definition.`
      },
      {
        signature: '    Embedded = 1',
        summary: `This instance definition geometry was imported from another archive (m_source_archive)
     and is embedded. If m_source_archive changes, the user is asked if they want to update
     the instance definition.`
      },
      {
        signature: 'LinkedAndEmbedded = 2',
        summary: `This instance definition geometry was imported from another archive (m_source_archive)
     and is embedded. If m_source_archive changes, the instance definition is automatically
     updated. If m_source_archive is not available, the instance definition is still valid.`
      },
      {
        signature: 'Linked = 3',
        summary: `This instance definition geometry was imported from another archive (m_source_archive)
     and is not embedded. If m_source_archive changes, the instance definition is automatically
     updated. If m_source_archive is not available, the instance definition is not valid.
     This does not save runtime memory.  It may save a little disk space, but it is a  foolish
     option requested by people who do not understand all the issues.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'InstanceObject',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.RhinoObject',
    properties: [
      {
        signature: 'Point3d InsertionPoint',
        summary: 'Basepoint coordinates of a block.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'InstanceDefinition InstanceDefinition',
        summary: 'instance definition that this object uses.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Transform InstanceXform',
        summary: 'transformation applied to an instance definition for this object.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Explode(bool explodeNestedInstances,RhinoObject[] pieces,ObjectAttributes[] pieceAttributes,Transform[] pieceTransforms)',
        summary: 'Explodes the instance reference into pieces.',
        since: 5,
        parameters: [
          {
            name: 'explodeNestedInstances',
            summary: `If true, then nested instance references are recursively exploded into pieces
     until actual geometry is found. If false, an InstanceObject is added to
     the pieces out parameter when this InstanceObject has nested references.`
          },
          {
            name: 'pieces',
            summary: 'An array of Rhino objects will be assigned to this out parameter during this call.'
          },
          {
            name: 'pieceAttributes',
            summary: 'An array of object attributes will be assigned to this out parameter during this call.'
          },
          {
            name: 'pieceTransforms',
            summary: 'An array of the previously applied transform matrices will be assigned to this out parameter during this call.'
          }
        ]
      },
      {
        signature: 'bool UsesDefinition(int definitionIndex,int nestingLevel)',
        summary: 'Determine if this reference uses an instance definition',
        since: 5.2,
        parameters: [
          {
            name: 'definitionIndex',
            summary: ''
          },
          {
            name: 'nestingLevel',
            summary: 'If the instance definition is used, this is the definition\'s nesting depth'
          }
        ],
        returns: 'True or False depending on if the deifinition is used'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'Layer',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.ModelComponent',
    interfaces: ['IEquatable<Layer>'],
    constructors: [
      {
        signature: 'Layer()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'static string PathSeparator',
        summary: `The string "::" (colon,colon) is used to
     separate parent and child layer names.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'Color Color',
        summary: 'Gets or sets the display color for this layer.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ComponentStatus ComponentStatus',
        summary: 'Gets or sets the status of the layer.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.Layer.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string FullPath',
        summary: 'Gets the full path to this layer. The full path includes nesting information.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid Id',
        summary: `Gets or sets the ID of this layer object. 
     You typically do not need to assign a custom ID.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int IgesLevel',
        summary: 'Gets or sets the IGES level for this layer.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsDeleted',
        summary: `Gets a value indicating whether this layer has been deleted and is 
     currently in the Undo buffer.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsExpanded',
        summary: 'Gets or sets a value indicating whether this layer is expanded in the Rhino Layer dialog.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsLocked',
        summary: 'Gets or sets a value indicating the locked state of this layer.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsReference',
        summary: `Gets a value indicting whether this layer is a referenced layer. 
     Referenced layers are part of referenced documents.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsVisible',
        summary: 'Gets or sets the visibility of this layer.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int LayerIndex',
        summary: 'Gets or sets the index of this layer.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int LinetypeIndex',
        summary: 'Gets or sets the line-type index for this layer.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Name',
        summary: 'Gets or sets the name of this layer.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Guid ParentLayerId',
        summary: `Gets the ID of the parent layer. Layers can be origanized in a hierarchical structure, 
     in which case this returns the parent layer ID. If the layer has no parent, 
     Guid.Empty will be returned.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color PlotColor',
        summary: 'Gets or sets the plot color for this layer.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PlotWeight',
        summary: `Gets or sets the weight of the plotting pen in millimeters. 
     A weight of 0.0 indicates the "default" pen weight should be used.
     A weight of -1.0 indicates the layer should not be printed.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'RenderMaterial RenderMaterial',
        summary: `Gets or sets the Render.RenderMaterial for objects on
     this layer that have MaterialSource() == MaterialFromLayer.
     A None result indicates that no Render.RenderMaterial has
     been assigned  and the material created by the default Material
     constructor or the RenderMaterialIndex should be used.`,
        since: 5.7,
        property: ['get', 'set']
      },
      {
        signature: 'int RenderMaterialIndex',
        summary: `Gets or sets the index of render material for objects on this layer that have
     MaterialSource() == MaterialFromLayer. 
     A material index of -1 indicates no material has been assigned 
     and the material created by the default Material constructor 
     should be used.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int SortIndex',
        summary: 'Runtime index used to sort layers in layer dialog.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int UserStringCount',
        summary: 'Gets the amount of user strings.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Layer GetDefaultLayerProperties()',
        summary: `Constructs a layer with the current default properties.
     The default layer properties are:
     color = Rhino.ApplicationSettings.AppearanceSettings.DefaultLayerColorline style = Rhino.ApplicationSettings.AppearanceSettings.DefaultLayerLineStylematerial index = -1iges level = -1mode = NormalLayername = emptylayer index = 0 (ignored by AddLayer)`,
        since: 5,
        returns: 'A new layer instance.'
      },
      {
        signature: 'static string GetLeafName(Layer layer)',
        summary: 'Get a layer name\'s "leaf" level name',
        since: 6,
        returns: 'leaf name or String.Empty if fullPath does not contain a leaf'
      },
      {
        signature: 'static string GetLeafName(string fullPath)',
        summary: 'Get a layer name\'s "leaf" level name',
        since: 6,
        returns: 'leaf name or String.Empty if fullPath does not contain a leaf'
      },
      {
        signature: 'static string GetParentName(Layer layer)',
        summary: 'Get a layer\'s "parent" path name',
        since: 6,
        returns: 'parent name or String.Empty'
      },
      {
        signature: 'static string GetParentName(string fullPath)',
        summary: 'Get a layer\'s "parent" path name',
        since: 6,
        returns: 'parent name or String.Empty'
      },
      {
        signature: 'static bool IsValidName(string name)',
        summary: 'Determines if a given string is valid for a layer name.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'A name to be validated.'
          }
        ],
        returns: 'True if the name is valid for a layer name; otherwise, false.'
      },
      {
        signature: 'bool CommitChanges()',
        since: 5
      },
      {
        signature: 'void CopyAttributesFrom(Layer otherLayer)',
        summary: 'Copy typical attributes from another layer',
        since: 6
      },
      {
        signature: 'void Default()',
        summary: 'Sets layer to default settings.',
        since: 5
      },
      {
        signature: 'void DeletePerViewportColor(Guid viewportId)',
        summary: 'Remove any per viewport layer color setting so the layer\'s overall setting will be used for all viewports.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: `If not Guid.Empty, then the setting for this viewport will be deleted.
     If Guid.Empty, the all per viewport layer color settings will be removed.`
          }
        ]
      },
      {
        signature: 'void DeletePerViewportPlotColor(Guid viewportId)',
        summary: 'Remove any per viewport layer plot color setting so the layer\'s overall setting will be used for all viewports.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: `If not Guid.Empty, then the setting for this viewport will be deleted.
     If Guid.Empty, the all per viewport layer color settings will be removed.`
          }
        ]
      },
      {
        signature: 'void DeletePerViewportPlotWeight(Guid viewportId)',
        summary: 'Remove any per viewport layer plot weight setting so the layer\'s overall setting will be used for all viewports.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: `If not Guid.Empty, then the setting for this viewport will be deleted.
     If Guid.Empty, the all per viewport layer color settings will be removed.`
          }
        ]
      },
      {
        signature: 'void DeletePerViewportSettings(Guid viewportId)',
        summary: 'Deletes per viewport layer settings.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: `If not Guid.Empty, then the settings for that viewport are deleted.
     If Guid.Empty, then all per viewport settings are deleted.`
          }
        ]
      },
      {
        signature: 'void DeletePerViewportVisible(Guid viewportId)',
        summary: 'Remove any per viewport visibility setting so the layer\'s overall setting will be used for all viewports.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: `If not Guid.Empty, then the setting for this viewport will be deleted.
     If Guid.Empty, the all per viewport visibility settings will be removed.`
          }
        ]
      },
      {
        signature: 'bool Equals(Layer other)',
        since: 6
      },
      {
        signature: 'bool Equals(object obj)'
      },
      {
        signature: 'Layer[] GetChildren()',
        summary: 'Gets immediate children of this layer. Note that child layers may have their own children.',
        since: 5,
        returns: 'Array of child layers. None if this layer does not have any children.'
      },
      {
        signature: 'int GetHashCode()'
      },
      {
        signature: 'bool GetPersistentLocking()',
        summary: `The persistent locking setting is used for layers that can be locked by
     a "parent" object. A common case is when a layer is a child layer
     (Layer.ParentI is not nil). In this case, when a parent layer is locked,
     then child layers are also locked. The persistent locking setting
     determines what happens when the parent is unlocked again.`,
        since: 5.5
      },
      {
        signature: 'bool GetPersistentVisibility()',
        summary: `The persistent visbility setting is used for layers whose visibilty can
     be changed by a "parent" object. A common case is when a layer is a
     child layer (ParentId is not nil). In this case, when a parent layer is
     turned off, then child layers are also turned off. The persistent
     visibility setting determines what happens when the parent is turned on
     again.`,
        since: 5.5
      },
      {
        signature: 'string GetUserString(string key)',
        summary: 'Gets user string from this geometry.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'id used to retrieve the string.'
          }
        ],
        returns: 'string associated with the key if successful. None if no key was found.'
      },
      {
        signature: 'System.Collections.Specialized.NameValueCollection GetUserStrings()',
        summary: 'Gets a copy of all (user key string, user value string) pairs attached to this geometry.',
        since: 5,
        returns: 'A new collection.'
      },
      {
        signature: 'bool HasPerViewportSettings(Guid viewportId)',
        summary: 'Verifies that a layer has per viewport settings.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: `If not Guid.Empty, then checks for settings for that specific viewport. 
     If Guid.Empty, then checks for any viewport settings.`
          }
        ],
        returns: 'True if the layer has per viewport settings, False otherwise.'
      },
      {
        signature: 'bool IsChildOf(Guid otherlayerId)',
        since: 6
      },
      {
        signature: 'bool IsChildOf(int layerIndex)',
        since: 5
      },
      {
        signature: 'bool IsChildOf(Layer otherLayer)',
        since: 5
      },
      {
        signature: 'bool IsParentOf(Guid otherLayer)',
        since: 6
      },
      {
        signature: 'bool IsParentOf(int layerIndex)',
        since: 5
      },
      {
        signature: 'bool IsParentOf(Layer otherLayer)',
        since: 5
      },
      {
        signature: 'System.Drawing.Color PerViewportColor(Guid viewportId)',
        summary: 'Gets the display color for this layer.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: 'If not Guid.Empty, then the setting applies only to the viewport with the specified id.'
          }
        ],
        returns: 'The display color.'
      },
      {
        signature: 'bool PerViewportIsVisible(Guid viewportId)',
        summary: 'Gets the per viewport visibility of this layer.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: `If not Guid.Empty, then the visibility setting for that viewport is returned.
     If Guid.Empty, the IsVisible property is returned.`
          }
        ],
        returns: 'Returns True if objects on layer are visible.'
      },
      {
        signature: 'bool PerViewportPersistentVisibility(Guid viewportId)',
        summary: `Gets the per layer persistent visibility. The persistent visbility setting is used for layers whose visibilty can be changed by a parent layer. 
     In this case, when a parent layer is turned off, then child layers are also turned off.
     The persistent visibility setting determines what happens when the parent is turned on again.`,
        since: 6,
        returns: `Return True if this layer's visibility in the specified viewport is controlled by a parent object and the parent is turned on (after being off), 
     then this layer will also be turned on in the specified viewport.
     Returns False if this layer's visibility in the specified viewport is controlled by a parent object and the parent layer is turned on(after being off),
     then this layer will continue to be off in the specified viewport.`
      },
      {
        signature: 'System.Drawing.Color PerViewportPlotColor(Guid viewportId)',
        summary: 'Gets the plot color for this layer.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: 'If not Guid.Empty, then the setting applies only to the viewport with the specified id.'
          }
        ],
        returns: 'The plot color.'
      },
      {
        signature: 'double PerViewportPlotWeight(Guid viewportId)',
        summary: 'Gets the plot weight, in millimeters, for this layer.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: 'If not Guid.Empty, then the setting applies only to the viewport with the specified id.'
          }
        ],
        returns: 'The plot color.'
      },
      {
        signature: 'void SetPersistentLocking(bool persistentLocking)',
        summary: 'Set the persistent locking setting for this layer',
        since: 5.5
      },
      {
        signature: 'void SetPersistentVisibility(bool persistentVisibility)',
        summary: 'Set the persistent visibility setting for this layer',
        since: 5.5
      },
      {
        signature: 'void SetPerViewportColor(Guid viewportId,Color color)',
        summary: 'Sets the display color for this layer.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: 'If not Guid.Empty, then the setting applies only to the viewport with the specified id.'
          },
          {
            name: 'color',
            summary: 'The display color.'
          }
        ]
      },
      {
        signature: 'void SetPerViewportPersistentVisibility(Guid viewportId,bool persistentVisibility)',
        summary: `Sets the per layer persistent visibility. The persistent visbility setting is used for layers whose visibilty can be changed by a parent layer. 
     In this case, when a parent layer is turned off, then child layers are also turned off.
     The persistent visibility setting determines what happens when the parent is turned on again.`,
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: `If not Guid.Empty, then the setting applies only to the viewport with the specified id.
     If Guid.Empty, then the setting applies to all viewports with per viewport layer settings.`
          },
          {
            name: 'persistentVisibility',
            summary: `If true, this layer's visibility in the specified viewport is controlled by a parent object and the parent is turned on (after being off), 
     then this layer will also be turned on in the specified viewport.
     If false, this layer's visibility in the specified viewport is controlled by a parent object and the parent layer is turned on (after being off),
     then this layer will continue to be off in the specified viewport.`
          }
        ]
      },
      {
        signature: 'void SetPerViewportPlotColor(Guid viewportId,Color color)',
        summary: 'Sets the plot color for this layer.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: 'If not Guid.Empty, then the setting applies only to the viewport with the specified id.'
          },
          {
            name: 'color',
            summary: 'The plot color.'
          }
        ]
      },
      {
        signature: 'void SetPerViewportPlotWeight(Guid viewportId,double plotWeight)',
        summary: 'Sets the plot weight, in millimeters, for this layer.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: 'If not Guid.Empty, then the setting applies only to the viewport with the specified id.'
          },
          {
            name: 'plotWeight',
            summary: `The plot weight in millimeters. 
     A weight of  0.0 indicates the "default" pen weight should be used. 
     A weight of -1.0 indicates the layer should not be printed.`
          }
        ]
      },
      {
        signature: 'void SetPerViewportVisible(Guid viewportId,bool visible)',
        summary: 'Controls layer visibility in specific viewports.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: `If not Guid.Empty, then the setting applies only to the viewport with the specified id.
     If Guid.Empty, then the setting applies to all viewports with per viewport layer settings.`
          },
          {
            name: 'visible',
            summary: 'True to make layer visible, False to make layer invisible.'
          }
        ]
      },
      {
        signature: 'bool SetUserString(string key,string value)',
        summary: 'Attach a user string (key,value combination) to this geometry.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'id used to retrieve this string.'
          },
          {
            name: 'value',
            summary: 'string associated with key.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'string ToString()'
      },
      {
        signature: 'void UnsetPersistentLocking()',
        summary: 'Remove any explicity persistent locking settings from this layer',
        since: 5.5
      },
      {
        signature: 'void UnsetPersistentVisibility()',
        summary: 'Remove any explicit persistent visibility setting from this layer',
        since: 5.5
      },
      {
        signature: 'void UnsetPerViewportPersistentVisibility(Guid viewportId)',
        summary: 'Remove any per viewport persistent visibility setting so the layer\'s overall setting will be used for all viewports.',
        since: 6,
        parameters: [
          {
            name: 'viewportId',
            summary: `If not Guid.Empty, then the setting for this viewport will be deleted.
     If Guid.Empty, the all per viewport visibility settings will be removed.`
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'LeaderObject',
    dataType: 1,
    summary: 'Rhino Object that represents leader geometry and attributes',
    baseclass: 'Rhino.DocObjects.AnnotationObjectBase',
    properties: [
      {
        signature: 'Leader LeaderGeometry',
        summary: 'Get the leader geometry for this object.',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'LightObject',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.RhinoObject',
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Light LightGeometry',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Light DuplicateLightGeometry()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'LinearDimensionObject',
    dataType: 1,
    summary: 'Rhino Object that represents a linear dimension geometry and attributes',
    baseclass: 'Rhino.DocObjects.DimensionObject',
    properties: [
      {
        signature: 'LinearDimension LinearDimensionGeometry',
        summary: 'Get the dimension geometry for this object.',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'Linetype',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.ModelComponent',
    constructors: [
      {
        signature: 'Linetype()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.LinePattern.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsDeleted',
        summary: `Gets a value indicating whether this linetype has been deleted and is 
     currently in the Undo buffer.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsModified',
        summary: `True if this linetype has been modified by LinetypeTable.ModifyLinetype()
     and the modifications can be undone.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsReference',
        summary: `Gets a value indicting whether this linetype is a referenced linetype. 
     Referenced linetypes are part of referenced documents.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'int LinetypeIndex',
        summary: 'The index of this linetype.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Name',
        summary: 'The name of this linetype.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PatternLength',
        summary: 'Total length of one repeat of the pattern.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int SegmentCount',
        summary: 'Number of segments in the pattern.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Linetype[] ReadFromFile(string path)',
        summary: 'Reads linetypes from either a Rhino .3dm file or an AutoCAD .lin file.',
        since: 6.6,
        parameters: [
          {
            name: 'path',
            summary: 'The path to the file to read.'
          }
        ],
        returns: 'An array of linetypes if successful, otherwise an empty array.'
      },
      {
        signature: 'int AppendSegment(double length,bool isSolid)',
        summary: 'Adds a segment to the pattern.',
        since: 5,
        parameters: [
          {
            name: 'length',
            summary: 'The length of the segment to be added.'
          },
          {
            name: 'isSolid',
            summary: `If true, the length is interpreted as a line. If false,
     then the length is interpreted as a space.`
          }
        ],
        returns: 'Index of the added segment.'
      },
      {
        signature: 'bool CommitChanges()',
        since: 5
      },
      {
        signature: 'void Default()',
        summary: 'Set linetype to default settings.',
        since: 5
      },
      {
        signature: 'void GetSegment(int index,double length,bool isSolid)',
        summary: 'Gets the segment information at a index.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Zero based index of the segment.'
          },
          {
            name: 'length',
            summary: 'The length of the segment in millimeters.'
          },
          {
            name: 'isSolid',
            summary: `If the length is interpreted as a line, True is assigned during the call to this out parameter.
     If the length is interpreted as a space, then False is assigned during the call to this out parameter.`
          }
        ]
      },
      {
        signature: 'bool RemoveSegment(int index)',
        summary: 'Removes a segment in the linetype.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Zero based index of the segment to remove.'
          }
        ],
        returns: 'True if the segment index was removed.'
      },
      {
        signature: 'bool SetSegment(int index,double length,bool isSolid)',
        summary: 'Sets the length and type of the segment at index.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Zero based index of the segment.'
          },
          {
            name: 'length',
            summary: 'The length of the segment to be added in millimeters.'
          },
          {
            name: 'isSolid',
            summary: `If true, the length is interpreted as a line. If false,
     then the length is interpreted as a space.`
          }
        ],
        returns: 'True if the operation was successful; otherwise false.'
      },
      {
        signature: 'bool SetSegments(IEnumerable<double> segments)',
        summary: 'Set all segments.',
        since: 6.8,
        parameters: [
          {
            name: 'segments',
            summary: `An array of segments lengths. 
     Lengths >= 0 are interpreted as a line. 
     Lengths < 0 are interpreted as a space.`
          }
        ],
        returns: 'True if the segments were replaced'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'Material',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.ModelComponent',
    constructors: [
      {
        signature: 'Material()',
        since: 5
      },
      {
        signature: 'Material(Material other)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'static Material DefaultMaterial',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static double MaxShine',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool AlphaTransparency',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Color AmbientColor',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.RenderMaterial.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Color DiffuseColor',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DisableLighting',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Color EmissionColor',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double FresnelIndexOfRefraction',
        summary: `Gets or sets the Fresnel index of refraction of the material,
     default is 1.56`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool FresnelReflections',
        summary: 'Gets or sets if fresnel reflections are used.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double IndexOfRefraction',
        summary: `Gets or sets the index of refraction of the material, generally
     >= 1.0 (speed of light in vacuum)/(speed of light in material)`,
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsDefaultMaterial',
        summary: 'By default Rhino layers and objects are assigned the default rendering material.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsDeleted',
        summary: `Deleted materials are kept in the runtime material table so that undo
     will work with materials.  Call IsDeleted to determine to determine if
     a material is deleted.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsDocumentControlled',
        summary: `If True this object may not be modified. Any properties or functions that attempt
     to modify this object when it is set to "IsReadOnly" will throw a NotSupportedException.`,
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'bool IsReference',
        summary: `Rhino allows multiple files to be viewed simultaneously. Materials in the
     document are "normal" or "reference". Reference materials are not saved.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'int MaterialIndex',
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'string Name',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'PhysicallyBasedMaterial PhysicallyBased',
        since: 7,
        property: ['get']
      },
      {
        signature: 'Color PreviewColor',
        summary: 'Very simple preview color function for GUIs.',
        since: 6.6,
        property: ['get']
      },
      {
        signature: 'Color ReflectionColor',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double ReflectionGlossiness',
        summary: 'Gets or sets the reflection glossiness.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double Reflectivity',
        summary: `Gets or sets how reflective a material is, 0f is no reflection
     1f is 100% reflective.`,
        since: 5.7,
        property: ['get', 'set']
      },
      {
        signature: 'double RefractionGlossiness',
        summary: 'Gets or sets the refraction glossiness.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'RenderMaterial RenderMaterial',
        summary: `Get the RenderMaterial related to this Material.
     
     Will create a new RenderMaterial if none exists. This can happen for older
     documents.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid RenderMaterialInstanceId',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Guid RenderPlugInId',
        summary: 'The Id of the RenderPlugIn that is associated with this material.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Shine',
        summary: 'Gets or sets the shine factor of the material.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color SpecularColor',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Transparency',
        summary: 'Gets or sets the transparency of the material (0.0 = opaque to 1.0 = transparent)',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color TransparentColor',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int UseCount',
        summary: 'Number of objects and layers that use this material.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int UserStringCount',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool CommitChanges()',
        since: 5
      },
      {
        signature: 'Rhino.Render.PhysicallyBasedMaterial ConvertToPhysicallyBased()'
      },
      {
        signature: 'void CopyFrom(Material other)',
        since: 6
      },
      {
        signature: 'void Default()',
        summary: 'Set material to default settings.',
        since: 5
      },
      {
        signature: 'Texture GetBitmapTexture()',
        since: 5
      },
      {
        signature: 'Texture GetBumpTexture()',
        summary: 'Gets the bump texture of this material.',
        since: 5,
        returns: 'A texture; or None if no bump texture has been added to this material.'
      },
      {
        signature: 'Texture GetEnvironmentTexture()',
        since: 5
      },
      {
        signature: 'Texture GetTexture(TextureType which)',
        summary: 'Get the texture that corresponds with the specified texture type for this material.',
        since: 7
      },
      {
        signature: 'Texture[] GetTextures()',
        summary: 'Get array of textures that this material uses',
        since: 5.7
      },
      {
        signature: 'Texture GetTransparencyTexture()',
        since: 5
      },
      {
        signature: 'string GetUserString(string key)',
        summary: 'Gets a user string.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'id used to retrieve the string.'
          }
        ],
        returns: 'string associated with the key if successful. None if no key was found.'
      },
      {
        signature: 'System.Collections.Specialized.NameValueCollection GetUserStrings()',
        summary: 'Gets an independent copy of the collection of (user text key, user text value) pairs attached to this object.',
        since: 5,
        returns: 'A collection of key strings and values strings. This'
      },
      {
        signature: 'bool SetBitmapTexture(string filename)',
        since: 5
      },
      {
        signature: 'bool SetBitmapTexture(Texture texture)',
        since: 5
      },
      {
        signature: 'bool SetBumpTexture(string filename)',
        since: 5
      },
      {
        signature: 'bool SetBumpTexture(Texture texture)',
        since: 5
      },
      {
        signature: 'bool SetEnvironmentTexture(string filename)',
        since: 5
      },
      {
        signature: 'bool SetEnvironmentTexture(Texture texture)',
        since: 5
      },
      {
        signature: 'bool SetTexture(Texture texture,TextureType which)',
        summary: 'Set the texture that corresponds with the specified texture type for this material.',
        since: 7,
        parameters: [
          {
            name: 'texture',
            summary: 'An instance of Rhino.DocObjects.Texture'
          },
          {
            name: 'which',
            summary: 'Use Rhino.DocObjects.TextureType'
          }
        ]
      },
      {
        signature: 'bool SetTransparencyTexture(string filename)',
        since: 5
      },
      {
        signature: 'bool SetTransparencyTexture(Texture texture)',
        since: 5
      },
      {
        signature: 'bool SetUserString(string key,string value)',
        summary: 'Attach a user string (key,value combination) to this geometry.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'id used to retrieve this string.'
          },
          {
            name: 'value',
            summary: 'string associated with key.'
          }
        ],
        returns: 'True on success.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'MaterialRef',
    dataType: 1,
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'Guid BackFaceMaterialId',
        summary: 'The Id of the Material used to render the back of an object.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'int BackFaceMaterialIndex',
        summary: 'The index of the material used to render the back of an object',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Guid FrontFaceMaterialId',
        summary: 'The Id of the Material used to render the front of an object.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'int FrontFaceMaterialIndex',
        summary: 'The index of the material used to render the front of an object',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'ObjectMaterialSource MaterialSource',
        summary: `Determines if the simple material should come from the object or from
     it's layer.`,
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Guid PlugInId',
        summary: 'Identifies a rendering plug-in',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5.1
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'MaterialRefCreateParams',
    dataType: 1,
    summary: 'Options passed to MaterialRefs.Create',
    properties: [
      {
        signature: 'Guid BackFaceMaterialId',
        summary: 'The Id of the Material used to render the back of an object.',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'int BackFaceMaterialIndex',
        summary: 'The index of the material used to render the back of an object',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Guid FrontFaceMaterialId',
        summary: 'The Id of the Material used to render the front of an object.',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'int FrontFaceMaterialIndex',
        summary: 'The index of the material used to render the front of an object',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'ObjectMaterialSource MaterialSource',
        summary: `Determines if the simple material should come from the object or from
     it's layer.`,
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Guid PlugInId',
        summary: 'Identifies a rendering plug-in',
        since: 5.1,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'MaterialRefs',
    dataType: 1,
    summary: `If you are developing a high quality plug-in renderer, and a user is
   assigning a custom render material to this object, then add rendering
   material information to the MaterialRefs dictionary.
   
   Note to developers:
    As soon as the MaterialRefs dictionary contains items rendering
    material queries slow down.  Do not populate the MaterialRefs
   dictionary when setting the MaterialIndex will take care of your needs.`,
    interfaces: ['IDictionary<Guid, MaterialRef>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of elements contained in this dictionary',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'bool IsReadOnly',
        summary: 'IDictionary required property, always returns False for this dictionary.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'ICollection<Guid> Keys',
        summary: 'Gets an ICollection containing the plug-in Id\'s in this dictionary.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'ICollection<MaterialRef> Values',
        summary: `Gets an ICollection containing the MaterialRef objects in this
     dictionary.`,
        since: 5.1,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(Guid key,MaterialRef value)',
        summary: 'Add or replace an element with the provided key and value to this dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'The plug-in associated with this MaterialRef'
          },
          {
            name: 'value',
            summary: 'MaterialRef to add to this dictionary'
          }
        ]
      },
      {
        signature: 'void Add(KeyValuePair<Guid, MaterialRef> item)',
        summary: 'Adds an item to this dictionary.',
        parameters: [
          {
            name: 'item',
            summary: 'The object to add to this dictionary'
          }
        ]
      },
      {
        signature: 'void Clear()',
        summary: 'Removes all items from this dictionary.',
        since: 5.1
      },
      {
        signature: 'bool Contains(KeyValuePair<Guid, MaterialRef> item)',
        summary: 'Determines whether this dictionary contains a specific value.',
        parameters: [
          {
            name: 'item',
            summary: 'The object to locate in this dictionary.'
          }
        ],
        returns: 'True if item is found in this dictionary; otherwise, false.'
      },
      {
        signature: 'bool ContainsKey(Guid key)',
        summary: `Determines whether this dictionary contains an MaterialRef with the
     specified plug-in id.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'The plug-in Id used to locate a MaterialRef in this dictionary.'
          }
        ],
        returns: `True if this dictionary contains an element with the specified plug-in
     Id; otherwise, false.`
      },
      {
        signature: 'void CopyTo(KeyValuePair<Guid, MaterialRef>[] array,int arrayIndex)',
        summary: `Copies the elements of this dictionary to an System.Array, starting at
     a particular System.Array index.`,
        parameters: [
          {
            name: 'array',
            summary: `The one-dimensional System.Array that is the destination of the
     elements copied from this dictionary. The System.Array must have
     zero-based indexing.`
          },
          {
            name: 'arrayIndex',
            summary: 'The zero-based index in array at which copying begins.'
          }
        ]
      },
      {
        signature: 'MaterialRef Create(MaterialRefCreateParams createParams)',
        summary: `Call this method to create a MaterialRef which can be used when calling
     one of the Add methods.`,
        since: 5.1,
        parameters: [
          {
            name: 'createParams',
            summary: 'Values used to initialize the MaterialRef'
          }
        ],
        returns: `A temporary MaterialRef object, the caller is responsible for disposing
     of this object.`
      },
      {
        signature: 'IEnumerator<KeyValuePair<Guid, MaterialRef>> GetEnumerator()',
        summary: 'Returns an enumerator that iterates through this dictionary.',
        since: 5.1,
        returns: 'A IEnumerator that can be used to iterate this dictionary.'
      },
      {
        signature: 'bool Remove(Guid key)',
        summary: `Removes the MaterialRef with the specified plug-in Id from this
     dictionary.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'The plug-in Id for the MaterialRef to remove.'
          }
        ],
        returns: `True if the MaterialRef is successfully removed; otherwise, false. This
     method also returns False if key was not found in the original dictionary.`
      },
      {
        signature: 'bool Remove(KeyValuePair<Guid, MaterialRef> item)',
        summary: 'Removes the element with the specified plug-in id from the this dictionary.',
        parameters: [
          {
            name: 'item',
            summary: 'The object to remove from this dictionary'
          }
        ]
      },
      {
        signature: 'bool TryGetValue(Guid key,MaterialRef value)',
        summary: 'Gets the value associated with the specified key.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'The plug-in Id whose MaterialRef to get.'
          },
          {
            name: 'value',
            summary: `When this method returns, the MaterialRef associated with the specified
     key, if the key is found; otherwise, null. This parameter is passed
     uninitialized.`
          }
        ],
        returns: `True if this dictionary contains a MaterialRef with the specified key;
     otherwise, false.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'MeshObject',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.RhinoObject',
    properties: [
      {
        signature: 'bool IsCustomObject',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Mesh MeshGeometry',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static bool CheckMeshes(IEnumerable<MeshObject> meshObjects,TextLog textLog,MeshCheckParameters parameters)',
        summary: `Examines mesh objects and logs a description of what it finds right or wrong.
     The various properties the function checks for are described in MeshCheckParameters.`,
        since: 7,
        parameters: [
          {
            name: 'meshObjects',
            summary: 'A collection of mesh objects.'
          },
          {
            name: 'textLog',
            summary: 'The text log.'
          },
          {
            name: 'parameters',
            summary: 'The mesh checking parameter and results.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'Mesh DuplicateMeshGeometry()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ModelComponent',
    dataType: 1,
    summary: `Base class for all components in a model (document) and manages the
   index, id and other information common to this type of objects.
   This class parallels the C++ ON_ModelComponent.`,
    baseclass: 'Rhino.Runtime.CommonObject',
    properties: [
      {
        signature: 'ComponentStatus ComponentStatus',
        summary: 'Gets or sets the component status of the model component.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ModelComponentType ComponentType',
        summary: `Gets the ModelComponentType for this object.
     Useful in switch statements.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'string DeletedName',
        summary: 'Gets the name of a component that is deleted.',
        since: 6.2,
        property: ['get']
      },
      {
        signature: 'bool HasId',
        summary: 'Returns a value indicating whether the component has an ID.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool HasIndex',
        summary: 'Returns a value indicating whether the component has an Index.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool HasName',
        summary: 'Returns a value indicating whether the component has a Name.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid Id',
        summary: 'Gets or sets the ID of the current instance.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool IdIsLocked',
        summary: 'Returns a value indicating whether the component ID is already locked.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int Index',
        summary: 'Gets or sets the model component index attribute.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool IndexIsLocked',
        summary: 'Returns a value indicating whether the component Index is already locked.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint InstanceDefinitionModelSerialNumber',
        summary: `When a component is in a model as part of the information required for a linked instance definition,
     this value identifies the the linked instance definition reference model.`,
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'bool IsComponentStatusLocked',
        summary: 'The component status itself can be locked. This returns an indication.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsSystemComponent',
        summary: `True if this model component is a system constant.
     An incomplete list of system constant model components is below:ON_ModelComponent::Unset
     ON_InstanceDefinition::Empty
     ON_Linetype::UnsetON_Linetype::ContinuousON_Linetype::ByLayerON_Linetype::ByParent
     ON_Layer::UnsetON_Layer::Default
     ON_TextStyle::UnsetON_TextStyle::DefaultON_TextStyle::ByLayerON_TextStyle::ByParent
     ON_DimStyle::UnsetON_DimStyle::DefaultON_DimStyle::DefaultInchDecimalON_DimStyle::DefaultInchFractionalON_DimStyle::DefaultFootInchArchitectureON_DimStyle::DefaultMillimeterSmallON_DimStyle::DefaultMillimeterLargeON_DimStyle::DefaultMillimeterArchitecture`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint ModelSerialNumber',
        summary: 'A value identifing the model that manages this component.',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'string Name',
        summary: 'Gets or sets the name',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool NameIsLocked',
        summary: 'Returns a value indicating whether the component Name is already locked.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint ReferenceModelSerialNumber',
        summary: 'When a component is in a model for reference, this value identifies the reference model.',
        since: 6.12,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static bool IsValidComponentName(string name)',
        summary: 'Tests for a valid model component name.',
        since: 6.15,
        parameters: [
          {
            name: 'name',
            summary: 'The string to validate.'
          }
        ],
        returns: 'True if the string is a valid model component name, False otherwise.'
      },
      {
        signature: 'static bool ModelComponentTypeIgnoresCase(ModelComponentType type)',
        summary: `Informs the developer if a particular model component type will require case-ignoring searching within a document.
     This is currently True with groups; False otherwise.`,
        since: 6,
        parameters: [
          {
            name: 'type',
            summary: 'True if the component ignores case.'
          }
        ]
      },
      {
        signature: 'static bool ModelComponentTypeIncludesParent(ModelComponentType type)',
        summary: 'Informs the developer if a particular model component type will include the hash of the parent.',
        since: 6,
        parameters: [
          {
            name: 'type',
            summary: 'True if the component includes parent hash.'
          }
        ]
      },
      {
        signature: 'static bool ModelComponentTypeRequiresUniqueName(ModelComponentType type)',
        summary: `Informs the developer if a particular model component type will require uniqueness within a document.
     This is currently True with render materials and model geometry; False otherwise.`,
        since: 6,
        parameters: [
          {
            name: 'type',
            summary: 'The type to check.'
          }
        ],
        returns: 'True with render materials and model geometry; False otherwise.'
      },
      {
        signature: 'void ClearId()',
        summary: 'Resets the HasId property of the model component to false, if possible.',
        since: 6
      },
      {
        signature: 'void ClearIndex()',
        summary: 'Resets the HasIndex property of the model component to false, if possible.',
        since: 6
      },
      {
        signature: 'void ClearName()',
        summary: 'Resets the HasName property of the model component to false, if possible.',
        since: 6
      },
      {
        signature: 'uint DataCRC(uint currentRemainder)',
        summary: 'Increments the Cyclic Redundancy Check value by this instance.',
        since: 6,
        parameters: [
          {
            name: 'currentRemainder',
            summary: 'The current remainder value.'
          }
        ],
        returns: 'The updated remainder value.'
      },
      {
        signature: 'void LockId()',
        summary: 'Locks the component Id property.',
        since: 6
      },
      {
        signature: 'void LockIndex()',
        summary: 'Locks the component Index property.',
        since: 6
      },
      {
        signature: 'void LockName()',
        summary: 'Locks the component Name property.',
        since: 6
      },
      {
        signature: 'string ToString()',
        summary: 'Returns the name of the model component type, and then its name and index.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ModelComponentType',
    dataType: 3,
    summary: `The ON_ModelComponent::Type enum has a value for each explicit component type
  and two special values, Unset and Mixed. Use an ON_ModelComponentTypeIterator
  instance to iterate over the ON_ModelComponent::Type values.`,
    values: [
      {
        signature: 'Unset = 0',
        summary: 'No value set.'
      },
      {
        signature: 'Image = 1',
        summary: 'Embedded image (bitmap) components.'
      },
      {
        signature: 'TextureMapping = 2',
        summary: 'Texture mapping.'
      },
      {
        signature: 'RenderMaterial = 3',
        summary: 'Render material.'
      },
      {
        signature: 'LinePattern = 4',
        summary: 'Line pattern (linetype).'
      },
      {
        signature: 'Layer = 5',
        summary: 'Layer.'
      },
      {
        signature: 'Group = 6',
        summary: 'Group.'
      },
      {
        signature: 'TextStyle = 7',
        summary: 'Text style.'
      },
      {
        signature: 'DimStyle = 8',
        summary: 'AnnotationDimension style.'
      },
      {
        signature: 'RenderLight = 9',
        summary: 'Render light.'
      },
      {
        signature: 'HatchPattern = 10',
        summary: 'Hatch pattern.'
      },
      {
        signature: 'InstanceDefinition = 11',
        summary: 'Instance definition.'
      },
      {
        signature: 'ModelGeometry = 12',
        summary: 'Model objects (points, curves, surfaces, ..., annotation, page details, ...), including objects referenced by instance definitions.'
      },
      {
        signature: 'HistoryRecord = 13',
        summary: 'History record.'
      },
      {
        signature: 'Mixed = 0xFE',
        summary: `Multiple component types.
     Used when a component type filter must include all explicit component types.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'MorphControlObject',
    dataType: 1,
    summary: 'Represents a Rhino.Geometry.MorphControl in a document.',
    baseclass: 'Rhino.DocObjects.RhinoObject'
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ObjectAttributes',
    dataType: 1,
    summary: 'Attributes (color, material, layer,...) associated with a rhino object',
    baseclass: 'Rhino.Runtime.CommonObject',
    constructors: [
      {
        signature: 'ObjectAttributes()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'bool CastsShadows',
        summary: 'Gets or sets an object\'s casts shadows property, or whether or not an object casts shadows on other objects and a ground plane.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ObjectColorSource ColorSource',
        summary: `The color used to display an object is specified in one of three ways.
     If ColorSource is ON::color_from_layer, then the object's layer ON_Layer::Color() is used.
     If ColorSource is ON::color_from_object, then value of m_color is used.
     If ColorSource is ON::color_from_material, then the diffuse color of the object's
     render material is used.  See ON_3dmObjectAttributes::MaterialSource() to
     determine where to get the definition of the object's render material.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Decals Decals',
        summary: 'Gets all object decals associated with this object.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'int DisplayOrder',
        summary: `Display order used to force objects to be drawn on top or behind each other.
     Larger numbers draw on top of smaller numbers.
     0  = draw object in standard depth buffered order<0 = draw object behind "normal" draw order objects>0 = draw object on top of "normal" draw order objects`,
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'int GroupCount',
        summary: 'number of groups object belongs to.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool HasMapping',
        summary: `A mapping from any plugin source is associated with these attributes
     Need to do this here to respond correctly to ModifyObjectAttributes event`,
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'bool IsDocumentControlled',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsInstanceDefinitionObject',
        summary: 'Use this query to determine if an object is part of an instance definition.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int LayerIndex',
        summary: `Gets or sets an associated layer index.
     Layer definitions in an OpenNURBS model are stored in a layer table.
     The layer table is conceptually an array of ON_Layer classes.  Every
     OpenNURBS object in a model is on some layer.  The object's layer
     is specified by zero based indicies into the ON_Layer array.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int LinetypeIndex',
        summary: `Gets or sets the linetype index.
     Linetype definitions in an OpenNURBS model are stored in a linetype table.
     The linetype table is conceptually an array of ON_Linetype classes. Every
     OpenNURBS object in a model references some linetype.  The object's linetype
     is specified by zero based indicies into the ON_Linetype array.Index 0 is reserved for continuous linetype (no pattern).`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ObjectLinetypeSource LinetypeSource',
        summary: `The Linetype used to display an object is specified in one of two ways.
     If LinetypeSource is ON::linetype_from_layer, then the object's layer ON_Layer::Linetype() is used.
     If LinetypeSource is ON::linetype_from_object, then value of m_linetype is used.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int MaterialIndex',
        summary: `Gets or sets the material index.
     If you want something simple and fast, set the index of
     the rendering material.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'MaterialRefs MaterialRefs',
        summary: `If you are developing a high quality plug-in renderer, and a user is
     assigning a custom render material to this object, then add rendering
     material information to the MaterialRefs dictionary.
     
     Note to developers:
      As soon as the MaterialRefs dictionary contains items rendering
      material queries slow down.  Do not populate the MaterialRefs
     dictionary when setting the MaterialIndex will take care of your needs.`,
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'ObjectMaterialSource MaterialSource',
        summary: `Determines if the simple material should come from the object or from it's layer.
     High quality rendering plug-ins should use m_rendering_attributes.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ObjectMode Mode',
        summary: `An object must be in one of three modes: normal, locked or hidden.
     If an object is in normal mode, then the object's layer controls visibility
     and selectability. If an object is locked, then the object's layer controls
     visibility by the object cannot be selected. If the object is hidden, it is
     not visible and it cannot be selected.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Name',
        summary: `Gets or sets an object optional text name.
     More than one object in a model can have the same name and
     some objects may have no name.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color ObjectColor',
        summary: 'If ON::color_from_object == ColorSource, then color is the object\'s display color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ObjectDecoration ObjectDecoration',
        summary: 'Used to indicate an object has a decoration (like an arrowhead on a curve)',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Guid ObjectId',
        summary: `Every object has a Guid (globally unique identifier, also known as UUID, or universally
     unique identifier). The default value is Guid.Empty.
     
     When an object is added to a model, the value is checked.  If the value is Guid.Empty, a
     new Guid is created. If the value is not None but it is already used by another object
     in the model, a new Guid is created. If the value is not Guid.Empty and it is not used by
     another object in the model, then that value persists. When an object is updated, by
     a move for example, the value of ObjectId persists.
     This value is the same as the one returned by object.Id.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color PlotColor',
        summary: 'If plot_color_from_object == PlotColorSource, then PlotColor is the object\'s plotting color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ObjectPlotColorSource PlotColorSource',
        summary: `The color used to plot an object on paper is specified in one of three ways.
     If PlotColorSource is ON::plot_color_from_layer, then the object's layer ON_Layer::PlotColor() is used.
     If PlotColorSource is ON::plot_color_from_object, then value of PlotColor() is used.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PlotWeight',
        summary: `Plot weight in millimeters.
     =0.0 means use the default width
     <0.0 means don't plot (visible for screen display, but does not show on plot)`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ObjectPlotWeightSource PlotWeightSource',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ReceivesShadows',
        summary: 'Gets or sets an object\'s receives shadows property, or whether or not an object receives shadows from other objects.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ActiveSpace Space',
        summary: `Starting with V4, objects can be in either model space or page space.
     If an object is in page space, then ViewportId is not nil and
     identifies the page it is on.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Url',
        summary: `Objects may have an URL. There are no restrictions on what value this
     URL may have. As an example, if the object came from a commercial part
     library, the URL might point to the definition of that part.`,
        since: 6.8,
        property: ['get', 'set']
      },
      {
        signature: 'int UserStringCount',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid ViewportId',
        summary: `If ViewportId is nil, the object is active in all viewports. If ViewportId is not nil, then 
     this object is only active in a specific view. This field is primarily used to assign page
     space objects to a specific page, but it can also be used to restrict model space to a
     specific view.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool Visible',
        summary: 'Gets or sets an object\'s visiblity.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int WireDensity',
        summary: `When a surface object is displayed in wireframe, this controls
     how many isoparametric wires are used.
     value    number of isoparametric wires
     -1       boundary wires (off)
     0        boundary and knot wires 
     1        boundary and knot wires and, if there are no interior knots, a single interior wire.
     N>=2     boundary and knot wires and (N+1) interior wires.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'bool AddHideInDetailOverride(Guid detailId)',
        summary: 'Make this object hidden in a given detail',
        since: 6.1
      },
      {
        signature: 'void AddToGroup(int groupIndex)',
        summary: `Adds object to the group with specified index by appending index to
     group list.
     If the object is already in group, nothing is changed.`,
        since: 5,
        parameters: [
          {
            name: 'groupIndex',
            summary: 'The index that will be added.'
          }
        ]
      },
      {
        signature: 'System.Drawing.Color ComputedPlotColor(RhinoDoc document)',
        since: 5.6
      },
      {
        signature: 'System.Drawing.Color ComputedPlotColor(RhinoDoc document,Guid viewportId)',
        since: 5.6
      },
      {
        signature: 'double ComputedPlotWeight(RhinoDoc document)',
        since: 5.6
      },
      {
        signature: 'double ComputedPlotWeight(RhinoDoc document,Guid viewportId)',
        since: 5.6
      },
      {
        signature: 'void DeleteAllUserStrings()',
        since: 6
      },
      {
        signature: 'bool DeleteUserString(string key)',
        since: 6
      },
      {
        signature: 'System.Drawing.Color DrawColor(RhinoDoc document)',
        since: 5
      },
      {
        signature: 'System.Drawing.Color DrawColor(RhinoDoc document,Guid viewportId)',
        since: 5
      },
      {
        signature: 'ObjectAttributes Duplicate()',
        summary: 'Constructs a copy of this ObjectAttributes instance.',
        since: 5,
        returns: 'A new instance on success, or None on failure.'
      },
      {
        signature: 'Guid GetDisplayModeOverride(Guid viewportId)',
        summary: 'Returns the id of the display mode of an objects. Object display modes are view based. Thus, it is possible to have an object display different in different views.',
        since: 6.18,
        parameters: [
          {
            name: 'viewportId',
            summary: 'Id of a Rhino Viewport.'
          }
        ],
        returns: 'A display node id if the object has a display mode override for the viewport; otherwise Guid.Empty is returned.'
      },
      {
        signature: 'int[] GetGroupList()',
        summary: 'Returns an array of GroupCount group indices.  If GroupCount is zero, then GetGroupList() returns null.',
        since: 5,
        returns: 'An array of group indices. None might be returned in place of an empty array.'
      },
      {
        signature: 'Guid[] GetHideInDetailOverrides()',
        summary: 'Get list of details that this object is supposed to be hidden in',
        since: 6.1
      },
      {
        signature: 'string GetUserString(string key)',
        summary: 'Gets a user string.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'id used to retrieve the string.'
          }
        ],
        returns: 'string associated with the key if successful. None if no key was found.'
      },
      {
        signature: 'System.Collections.Specialized.NameValueCollection GetUserStrings()',
        summary: 'Gets an independent copy of the collection of (user text key, user text value) pairs attached to this object.',
        since: 5,
        returns: 'A collection of key strings and values strings. This'
      },
      {
        signature: 'bool HasDisplayModeOverride(Guid viewportId)',
        summary: 'Determines if an object has a display mode override for a given viewport.',
        since: 5,
        parameters: [
          {
            name: 'viewportId',
            summary: 'Id of a Rhino Viewport.'
          }
        ],
        returns: 'True if the object has a display mode override for the viewport; otherwise, false.'
      },
      {
        signature: 'bool HasHideInDetailOverrideSet(Guid detailId)',
        summary: 'Is this object supposed to be hidden in a given detail',
        since: 6.1
      },
      {
        signature: 'void RemoveDisplayModeOverride()',
        summary: `By default, objects are drawn using the display mode of the viewport that
     the object is being drawn in. Setting a specific display mode, instructs
     Rhino to always use that display mode, regardless of the viewport's mode.
     This function resets an object to use the viewport's display mode for all
     viewports.`,
        since: 5
      },
      {
        signature: 'void RemoveDisplayModeOverride(Guid rhinoViewportId)',
        summary: `By default, objects are drawn using the display mode of the viewport that
     the object is being drawn in. Setting a specific display mode, instructs
     Rhino to always use that display mode, regardless of the viewport's mode.
     This function resets an object to use the viewport's display mode.`,
        since: 5,
        parameters: [
          {
            name: 'rhinoViewportId',
            summary: 'viewport that display mode overrides should be cleared from.'
          }
        ]
      },
      {
        signature: 'void RemoveFromAllGroups()',
        summary: 'Removes object from all groups.',
        since: 5
      },
      {
        signature: 'void RemoveFromGroup(int groupIndex)',
        summary: `removes object from the group with specified index.
     If the object is not in the group, nothing is changed.`,
        since: 5,
        parameters: [
          {
            name: 'groupIndex',
            summary: 'The index that will be removed.'
          }
        ]
      },
      {
        signature: 'bool RemoveHideInDetailOverride(Guid detailId)',
        summary: 'Remove hidden in detail flag for a specific detail',
        since: 6.1
      },
      {
        signature: 'bool SetDisplayModeOverride(DisplayModeDescription mode)',
        summary: `By default, objects are drawn using the display mode of the viewport that
     the object is being drawn in. Setting a specific display mode, instructs
     Rhino to always use that display mode, regardless of the viewport's mode.
     This version affects the object's display mode for all viewports.`,
        since: 5,
        parameters: [
          {
            name: 'mode',
            summary: 'The display mode.'
          }
        ],
        returns: 'True if setting was successful.'
      },
      {
        signature: 'bool SetDisplayModeOverride(DisplayModeDescription mode,Guid rhinoViewportId)',
        summary: `By default, objects are drawn using the display mode of the viewport that
     the object is being drawn in. Setting a specific display mode, instructs
     Rhino to always use that display mode, regardless of the viewport's mode.
     This version sets a display mode for a specific viewport.`,
        since: 5,
        parameters: [
          {
            name: 'mode',
            summary: 'The display mode.'
          },
          {
            name: 'rhinoViewportId',
            summary: 'The Rhino viewport ID.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'bool SetUserString(string key,string value)',
        summary: 'Attach a user string (key,value combination) to this geometry.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'id used to retrieve this string.'
          },
          {
            name: 'value',
            summary: 'string associated with key. If null, the key will be removed'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'bool Transform(Transform xform)',
        summary: 'Apply a transformation.',
        since: 6,
        parameters: [
          {
            name: 'xform',
            summary: 'The transformation.'
          }
        ],
        returns: 'trueif successful, False otherwise.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ObjectColorSource',
    dataType: 3,
    summary: 'Defines enumerated values for the source of display color of single objects.',
    values: [
      {
        signature: 'ColorFromLayer = 0',
        summary: 'use color assigned to layer.'
      },
      {
        signature: 'ColorFromObject = 1',
        summary: 'use color assigned to object.'
      },
      {
        signature: 'ColorFromMaterial = 2',
        summary: 'use diffuse render material color.'
      },
      {
        signature: 'ColorFromParent = 3',
        summary: `for objects with parents (like objects in instance references, use parent linetype)
       if no parent, treat as color_from_layer.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ObjectDecoration',
    dataType: 3,
    summary: 'Defines bit mask values to represent object decorations.',
    values: [
      {
        signature: 'None = 0',
        summary: 'There are no object decorations.'
      },
      {
        signature: 'StartArrowhead = 0x08',
        summary: 'Arrow head at start.'
      },
      {
        signature: 'EndArrowhead = 0x10',
        summary: 'Arrow head at end.'
      },
      {
        signature: 'BothArrowhead = 0x18',
        summary: 'Arrow head at start and end.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ObjectEnumeratorSettings',
    dataType: 1,
    summary: `Settings used for getting an enumerator of objects in a document
   See Rhino.Collections.ObjectTable.GetEnumerator()`,
    constructors: [
      {
        signature: 'ObjectEnumeratorSettings()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'bool ActiveObjects',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Type ClassTypeFilter',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DeletedObjects',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool HiddenObjects',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IdefObjects',
        summary: 'When true, ONLY Instance Definitions will be returned',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IncludeGrips',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IncludeLights',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IncludePhantoms',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int LayerIndexFilter',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool LockedObjects',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string NameFilter',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool NormalObjects',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ObjectType ObjectTypeFilter',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ReferenceObjects',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool SelectedObjectsFilter',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'RhinoViewport ViewportFilter',
        summary: 'Filter on value of object->IsActiveInViewport()',
        since: 5.6,
        property: ['get', 'set']
      },
      {
        signature: 'bool VisibleFilter',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ObjectLinetypeSource',
    dataType: 3,
    summary: 'Defines enumerated values for the source of linetype of single objects.',
    values: [
      {
        signature: 'LinetypeFromLayer = 0',
        summary: 'use line style assigned to layer.'
      },
      {
        signature: 'LinetypeFromObject = 1',
        summary: 'use line style assigned to object.'
      },
      {
        signature: 'LinetypeFromParent = 3',
        summary: `for objects with parents (like objects in instance references, use parent linetype)
       if not parent, treat as linetype_from_layer.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ObjectMaterialSource',
    dataType: 3,
    summary: 'Defines enumerated values for the source of material of single objects.',
    values: [
      {
        signature: 'MaterialFromLayer = 0',
        summary: 'use material assigned to layer.'
      },
      {
        signature: 'MaterialFromObject = 1',
        summary: 'use material assigned to object.'
      },
      {
        signature: 'MaterialFromParent = 3',
        summary: `for objects with parents, like definition geometry in instance
       references and faces in polysurfaces, this value indicates the
       material definition should come from the parent. If the object
       does not have an obvious "parent", then treat it the same as
       material_from_layer.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ObjectMode',
    dataType: 3,
    summary: 'Defines enumerated values for the display and behavior of single objects.',
    values: [
      {
        signature: 'Normal = 0',
        summary: 'Object mode comes from layer.'
      },
      {
        signature: 'Hidden = 1',
        summary: 'Not visible, object cannot be selected or changed.'
      },
      {
        signature: 'Locked = 2',
        summary: 'Visible, object cannot be selected or changed.'
      },
      {
        signature: 'InstanceDefinitionObject = 3',
        summary: `Object is part of an InstanceDefinition. The InstanceDefinition
      m_object_uuid[] array will contain this object attribute's uuid.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ObjectPlotColorSource',
    dataType: 3,
    summary: 'Defines enumerated values for the source of plotting/printing color of single objects.',
    values: [
      {
        signature: 'PlotColorFromLayer = 0',
        summary: 'use plot color assigned to layer.'
      },
      {
        signature: 'PlotColorFromObject = 1',
        summary: 'use plot color assigned to object.'
      },
      {
        signature: 'PlotColorFromDisplay = 2',
        summary: 'use display color.'
      },
      {
        signature: 'PlotColorFromParent = 3',
        summary: `for objects with parents (like objects in instance references, use parent plot color)
       if no parent, treat as plot_color_from_layer.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ObjectPlotWeightSource',
    dataType: 3,
    summary: 'Defines enumerated values for the source of plotting/printing weight of single objects.',
    values: [
      {
        signature: 'PlotWeightFromLayer = 0',
        summary: 'use plot color assigned to layer.'
      },
      {
        signature: 'PlotWeightFromObject = 1',
        summary: 'use plot color assigned to object.'
      },
      {
        signature: 'PlotWeightFromParent = 3',
        summary: `for objects with parents (like objects in instance references, use parent plot color)
       if no parent, treat as plot_color_from_layer.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ObjectType',
    dataType: 3,
    summary: 'Defines binary mask values for each object type that can be found in a document.',
    values: [
      {
        signature: 'None = 0',
        summary: 'Nothing.'
      },
      {
        signature: 'Point = 1',
        summary: 'A point.'
      },
      {
        signature: 'PointSet = 2',
        summary: 'A point set or cloud.'
      },
      {
        signature: 'Curve = 4',
        summary: 'A curve.'
      },
      {
        signature: 'Surface = 8',
        summary: 'A surface.'
      },
      {
        signature: 'Brep = 0x10',
        summary: 'A brep.'
      },
      {
        signature: 'Mesh = 0x20',
        summary: 'A mesh.'
      },
      {
        signature: 'Light = 0x100',
        summary: 'A rendering light.'
      },
      {
        signature: 'Annotation = 0x200',
        summary: 'An annotation.'
      },
      {
        signature: 'InstanceDefinition = 0x800',
        summary: 'A block definition.'
      },
      {
        signature: 'InstanceReference = 0x1000',
        summary: 'A block reference.'
      },
      {
        signature: 'TextDot = 0x2000',
        summary: 'A text dot.'
      },
      {
        signature: 'Grip = 0x4000',
        summary: 'Selection filter value - not a real object type.'
      },
      {
        signature: 'Detail = 0x8000',
        summary: 'A detail.'
      },
      {
        signature: 'Hatch = 0x10000',
        summary: 'A hatch.'
      },
      {
        signature: 'MorphControl = 0x20000',
        summary: 'A morph control.'
      },
      {
        signature: 'SubD = 0x40000',
        summary: 'A SubD object.'
      },
      {
        signature: 'BrepLoop = 0x80000',
        summary: 'A brep loop.'
      },
      {
        signature: 'BrepVertex = 0x100000',
        summary: 'a brep vertex.'
      },
      {
        signature: 'PolysrfFilter = 0x200000',
        summary: 'Selection filter value - not a real object type.'
      },
      {
        signature: 'EdgeFilter = 0x400000',
        summary: 'Selection filter value - not a real object type.'
      },
      {
        signature: 'PolyedgeFilter = 0x800000',
        summary: 'Selection filter value - not a real object type.'
      },
      {
        signature: 'MeshVertex = 0x01000000',
        summary: 'A mesh vertex.'
      },
      {
        signature: 'MeshEdge = 0x02000000',
        summary: 'A mesh edge.'
      },
      {
        signature: 'MeshFace = 0x04000000',
        summary: 'A mesh face.'
      },
      {
        signature: 'Cage = 0x08000000',
        summary: 'A cage.'
      },
      {
        signature: 'Phantom = 0x10000000',
        summary: 'A phantom object.'
      },
      {
        signature: 'ClipPlane = 0x20000000',
        summary: 'A clipping plane.'
      },
      {
        signature: 'Extrusion = 0x40000000',
        summary: 'An extrusion.'
      },
      {
        signature: 'AnyObject = 0xFFFFFFFF',
        summary: 'All bits set.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ObjRef',
    dataType: 1,
    summary: 'Represents a reference to a Rhino object.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'ObjRef(Guid id)',
        summary: 'Initializes a new object reference from a globally unique identifier (Guid).',
        since: 5,
        parameters: [
          {
            name: 'id',
            summary: 'The ID.'
          }
        ]
      },
      {
        signature: 'ObjRef(Guid id,ComponentIndex ci)',
        summary: `Initializes a new object reference from a guid and component index. The
     component index is used to specify a "piece" of the geometry`,
        since: 7,
        parameters: [
          {
            name: 'id',
            summary: 'The object\'s Id'
          },
          {
            name: 'ci',
            summary: 'a portion of the object'
          }
        ]
      },
      {
        signature: 'ObjRef(RhinoObject rhinoObject)',
        summary: 'Initializes a new object reference from a Rhino object.',
        since: 5,
        parameters: [
          {
            name: 'rhinoObject',
            summary: 'The Rhino object.'
          }
        ]
      },
      {
        signature: 'ObjRef(RhinoObject rhinoObject,PickContext pickContext)',
        summary: 'Initialized a new object reference from a Rhino object and pick context',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'ComponentIndex GeometryComponentIndex',
        summary: `Gets the component index of the referenced (sub) geometry.
     Some objects have subobjects that are valid pieces of geometry. For
     example, breps have edges and faces that are valid curves and surfaces.
     Each subobject has a component index that is > 0. The parent
     geometry has a component index = -1.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid ObjectId',
        summary: 'Returns the id of the referenced Rhino object.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'uint RuntimeSerialNumber',
        summary: `If > 0, then this is the value of a Rhino object's serial number field.
     The serial number is used instead of the pointer to prevent crashes in
     cases when the RhinoObject is deleted but an ObjRef continues to reference
     the Rhino object. The value of RuntimeSerialNumber is not saved in archives
     because it generally changes if you save and reload an archive.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Brep Brep()',
        summary: 'Gets the brep if this reference geometry is one.',
        since: 5,
        returns: 'A boundary representation; or None on error.'
      },
      {
        signature: 'ClippingPlaneSurface ClippingPlaneSurface()',
        summary: 'Gets the clipping plane surface if this reference targeted one.',
        since: 5,
        returns: 'A clipping plane surface, or None if this reference targeted something else.'
      },
      {
        signature: 'Curve Curve()',
        summary: 'Gets the curve if this reference targeted one.',
        since: 5,
        returns: 'A curve, or None if this reference targeted something else.'
      },
      {
        signature: 'Curve CurveParameter(double parameter)',
        summary: `If the reference geometry is a curve or edge with a selection
     point, then this gets the parameter of the selection point.`,
        since: 5,
        parameters: [
          {
            name: 'parameter',
            summary: 'The parameter of the selection point.'
          }
        ],
        returns: `If the selection point was on a curve or edge, then the
     curve/edge is returned, otherwise null.`
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'BrepEdge Edge()',
        summary: 'Gets the edge if this reference geometry is one.',
        since: 5,
        returns: 'A boundary representation edge; or None on error.'
      },
      {
        signature: 'BrepFace Face()',
        summary: `If the referenced geometry is a brep face, a brep with one face, or
     a surface, this returns the brep face.`,
        since: 5,
        returns: 'A boundary representation face; or None on error.'
      },
      {
        signature: 'GeometryBase Geometry()',
        summary: 'Gets the geometry linked to the object targeted by this reference.',
        since: 5,
        returns: 'The geometry.'
      },
      {
        signature: 'Hatch Hatch()',
        summary: 'Gets the hatch if the referenced geometry is one.',
        since: 5,
        returns: 'A hatch; or None if the referenced object is not a hatch'
      },
      {
        signature: 'RhinoObject InstanceDefinitionPart()',
        summary: `If subobject selection is enabled and a piece of an instance reference
     is selected, this will return the selected piece.`,
        since: 6
      },
      {
        signature: 'Light Light()',
        summary: 'Gets the light if the referenced geometry is one.',
        since: 5,
        returns: 'A light; or None if the referenced object is not a light, or on error.'
      },
      {
        signature: 'Mesh Mesh()',
        summary: 'Gets the mesh if the referenced geometry is one.',
        since: 5,
        returns: 'A mesh; or None if the referenced object is not a mesh, or on error.'
      },
      {
        signature: 'RhinoObject Object()',
        summary: 'Returns the referenced Rhino object.',
        since: 5
      },
      {
        signature: 'Point Point()',
        summary: 'Gets the point if the referenced geometry is one.',
        since: 5,
        returns: 'A point; or None if the referenced object is not a point, or on error.'
      },
      {
        signature: 'PointCloud PointCloud()',
        summary: 'Gets the point cloud if the referenced geometry is one.',
        since: 5,
        returns: 'A point cloud; or None if the referenced object is not a point cloud, or on error.'
      },
      {
        signature: 'SelectionMethod SelectionMethod()',
        summary: 'Gets the method used to select this object.',
        since: 5,
        returns: 'The method used to select this object.'
      },
      {
        signature: 'Point3d SelectionPoint()',
        summary: `If the object was selected by picking a point on it, then
     SelectionPoint() returns the point where the selection
     occured, otherwise it returns Point3d.Unset.`,
        since: 5,
        returns: 'The point where the selection occured or Point3d.Unset on failure.'
      },
      {
        signature: 'RhinoView SelectionView()',
        summary: `If the object was interactively selected in a particular viewport, then
     SelectionView() returns the view where the object was selected.`,
        since: 6.5
      },
      {
        signature: 'uint SelectionViewDetailSerialNumber()',
        summary: `If the object was interactively selected in a page space detail
     view, then SelectionViewDetailSerialNumber() returns the CRhinoObject
     serial number of the detail view object.  Use SelectionView()
     to get the page view that contains the detail view object.
     If SelectionViewDetailSerialNumber() returns 0, then the selection
     did not happen in a detail view.`,
        since: 6.5
      },
      {
        signature: 'void SetSelectionComponent(ComponentIndex componentIndex)',
        summary: `When an object is selected by picking a sub-object, SetSelectionComponent
     may be used to identify the sub-object.`,
        since: 5
      },
      {
        signature: 'SubD SubD()',
        summary: 'Gets the SubD if the referenced geometry is one.',
        since: 7,
        returns: 'A SubD; or None if the referenced object is not a SubD, or on error.'
      },
      {
        signature: 'Surface Surface()',
        summary: 'Gets the surface if the referenced geometry is one.',
        since: 5,
        returns: 'A surface; or None if the referenced object is not a surface, or on error.'
      },
      {
        signature: 'Surface SurfaceParameter(double u,double v)',
        summary: `If the reference geometry is a surface, brep with one face,
     or surface edge with a selection point, then this gets the 
     surface paramters of the selection point.`,
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'The U value is assigned to this out parameter during the call.'
          },
          {
            name: 'v',
            summary: 'The V value is assigned to this out parameter during the call.'
          }
        ],
        returns: 'If the selection point was on a surface, then the surface is returned.'
      },
      {
        signature: 'TextDot TextDot()',
        summary: 'Gets the text dot if the referenced geometry is one.',
        since: 5,
        returns: 'A text dot; or None if the referenced object is not a text dot, or on error.'
      },
      {
        signature: 'TextEntity TextEntity()',
        summary: 'Gets the text entity if the referenced geometry is one.',
        since: 5,
        returns: 'A text entity; or None if the referenced object is not a text entity, or on error.'
      },
      {
        signature: 'BrepTrim Trim()',
        summary: `If the referenced geometry is an edge of a surface,
     this returns the associated brep trim.`,
        since: 5.8,
        returns: 'A boundary representation trim; or None on error'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'OrdinateDimensionObject',
    dataType: 1,
    summary: 'Rhino Object that represents an ordinate dimension geometry and attributes',
    baseclass: 'Rhino.DocObjects.DimensionObject',
    properties: [
      {
        signature: 'OrdinateDimension OrdinateDimensionGeometry',
        summary: 'Get the dimension geometry for this object.',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'PointCloudObject',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.RhinoObject',
    properties: [
      {
        signature: 'PointCloud PointCloudGeometry',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'PointCloud DuplicatePointCloudGeometry()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'PointObject',
    dataType: 1,
    baseclass: 'Rhino.DocObjects.RhinoObject',
    properties: [
      {
        signature: 'Point PointGeometry',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Point DuplicatePointGeometry()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ProxyObject',
    dataType: 1,
    summary: 'A proxy object (not saved in files)',
    baseclass: 'Rhino.DocObjects.RhinoObject',
    methods: [
      {
        signature: 'int CreateMeshes(MeshType meshType,MeshingParameters parameters,bool ignoreCustomParameters)',
        since: 7
      },
      {
        signature: 'Mesh[] GetMeshes(MeshType meshType)',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'RadialDimensionObject',
    dataType: 1,
    summary: 'Rhino Object that represents a radial dimension geometry and attributes',
    baseclass: 'Rhino.DocObjects.DimensionObject',
    properties: [
      {
        signature: 'RadialDimension RadialDimensionGeometry',
        summary: 'Get the dimension geometry for this object.',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ReplayHistoryData',
    dataType: 1,
    summary: `Provides history information to commands that will repeat history construction.
   Generally, a developer using this class will not construct a new instance, but receive one.`,
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'RhinoDoc Document',
        summary: 'The document this record belongs to',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int HistoryVersion',
        summary: `ReplayHistory overrides check the version number to ensure the information
     saved in the history record is compatible with the current implementation
     of ReplayHistory`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid RecordId',
        summary: `Each history record has a unique id that Rhino assigns when it adds the
     history record to the history record table`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'ReplayHistoryResult[] Results',
        summary: `Provides access to BOTH inputs and outputs of the replay history operation.
     Use this property to then call an appropriate UpdateToX() method and make your
     custom history support work.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'Rhino.DocObjects.ObjRef GetRhinoObjRef(int id)',
        summary: `In ReplayHistory, use GetRhinoObjRef to convert the information
     in a history record into the ObjRef that has up to date
     RhinoObject pointers`,
        since: 5,
        parameters: [
          {
            name: 'id',
            summary: 'HistoryRecord value id'
          }
        ],
        returns: 'ObjRef on success, None if not successful'
      },
      {
        signature: 'bool TryGetBool(int id,bool value)',
        since: 5
      },
      {
        signature: 'bool TryGetColor(int id,Color value)',
        since: 5
      },
      {
        signature: 'bool TryGetDouble(int id,double value)',
        since: 5
      },
      {
        signature: 'bool TryGetDoubles(int id,double[] values)',
        since: 6.1
      },
      {
        signature: 'bool TryGetGuid(int id,Guid value)',
        since: 5
      },
      {
        signature: 'bool TryGetInt(int id,int value)',
        since: 5
      },
      {
        signature: 'bool TryGetPoint3d(int id,Point3d value)',
        since: 5
      },
      {
        signature: 'bool TryGetPoint3dOnObject(int id,Point3d value)',
        since: 6
      },
      {
        signature: 'bool TryGetString(int id,string value)',
        since: 5
      },
      {
        signature: 'bool TryGetTransform(int id,Transform value)',
        since: 5
      },
      {
        signature: 'bool TryGetVector3d(int id,Vector3d value)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ReplayHistoryResult',
    dataType: 1,
    properties: [
      {
        signature: 'RhinoObject ExistingObject',
        summary: `The previously existing object.
     Do not attempt to edit this object. It might have been already deleted by, for example, dragging.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool UpdateToAngularDimension(AngularDimension dimension,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToArc(Arc arc,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToBrep(Brep brep,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToCircle(Circle circle,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToClippingPlane(Plane plane,double uMagnitude,double vMagnitude,Guid clippedViewportId,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToClippingPlane(Plane plane,double uMagnitude,double vMagnitude,IEnumerable<Guid> clippedViewportIds,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToCurve(Curve curve,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToEllipse(Ellipse ellipse,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToExtrusion(Extrusion extrusion,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToHatch(Hatch hatch,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToLeader(Leader leader,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToLine(Point3d from,Point3d to,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToLinearDimension(LinearDimension dimension,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToMesh(Mesh mesh,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToPoint(Point3d point,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToPointCloud(IEnumerable<Point3d> points,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToPointCloud(PointCloud cloud,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToPolyline(IEnumerable<Point3d> points,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToRadialDimension(RadialDimension dimension,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToSphere(Sphere sphere,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToSurface(Surface surface,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToText(string text,Plane plane,double height,string fontName,bool bold,bool italic,TextJustification justification,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToText(TextEntity text,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool UpdateToTextDot(TextDot dot,ObjectAttributes attributes)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'RhinoDeselectAllObjectsEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RhinoDoc Document',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int ObjectCount',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'RhinoModifyObjectAttributesEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RhinoDoc Document',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ObjectAttributes NewAttributes',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ObjectAttributes OldAttributes',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoObject RhinoObject',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'RhinoObject',
    dataType: 1,
    summary: `Represents an object in the document.
   RhinoObjects should only ever be creatable by the RhinoDoc.`,
    baseclass: 'Rhino.DocObjects.ModelComponent',
    properties: [
      {
        signature: 'static uint NextRuntimeSerialNumber',
        summary: `Gets the runtime serial number that will be assigned to
     the next Rhino Object that is created.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'ObjectAttributes Attributes',
        summary: 'Gets or sets the object attributes.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.ModelGeometry.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'Gets the document that owns this object.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'GeometryBase Geometry',
        summary: `Gets the underlying geometry for this object.
     All rhino objects are composed of geometry and attributes.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool GripsOn',
        summary: 'Gets or sets the activation state of object default editing grips.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool GripsSelected',
        summary: 'True if grips are turned on and at least one is selected.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int GroupCount',
        summary: 'Number of groups object belongs to.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool HasDynamicTransform',
        summary: 'True if the object has a dynamic transformation',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool HasSubobjectMaterials',
        summary: `Will be True if the object contains sub object meshes with materials
     that are different than the top level object.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid Id',
        summary: `Every object has a Guid (globally unique identifier, also known as UUID, or universally
     unique identifier). The default value is Guid.Empty.
     
     When an object is added to a model, the value is checked.  If the value is Guid.Empty, a
     new Guid is created. If the value is not None but it is already used by another object
     in the model, a new Guid is created. If the value is not Guid.Empty and it is not used by
     another object in the model, then that value persists. When an object is updated, by
     a move for example, the value of ObjectId persists.
     This value is the same as the one returned by this.Attributes.ObjectId.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'uint InstanceDefinitionModelSerialNumber',
        summary: `When a component is in a model as part of the information required for a linked instance definition,
     this value identifies the the linked instance definition reference model.`,
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'bool IsDeletable',
        summary: 'Some objects cannot be deleted, like grips on lights and annotation objects.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsDeleted',
        summary: `True if the object is deleted. Deleted objects are kept by the document
     for undo purposes. Call RhinoDoc.UndeleteObject to undelete an object.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsHidden',
        summary: `An object must be in one of three modes: normal, locked or hidden.
     If an object is in normal mode, then the object's layer controls visibility
     and selectability. If an object is locked, then the object's layer controls
     visibility by the object cannot be selected. If the object is hidden, it is
     not visible and it cannot be selected.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsInstanceDefinitionGeometry',
        summary: 'True if the object is used as part of an instance definition.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsLocked',
        summary: `An object must be in one of three modes: normal, locked or hidden.
     If an object is in normal mode, then the object's layer controls visibility
     and selectability. If an object is locked, then the object's layer controls
     visibility by the object cannot be selected. If the object is hidden, it is
     not visible and it cannot be selected.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsNormal',
        summary: `An object must be in one of three modes: normal, locked or hidden.
     If an object is in normal mode, then the object's layer controls visibility
     and selectability. If an object is locked, then the object's layer controls
     visibility by the object cannot be selected. If the object is hidden, it is
     not visible and it cannot be selected.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsReference',
        summary: `Gets a value indicating if an object is a reference object. An object from a work session
     reference model is a reference object and cannot be modified. An object is
     a reference object if, and only if, it is on a reference layer.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'string Name',
        summary: `Rhino objects have optional text names.  More than one object in
     a model can have the same name and some objects may have no name.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ObjectType ObjectType',
        summary: 'Gets the Rhino-based object type.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'uint ReferenceModelSerialNumber',
        summary: 'When a component is in a model for reference, this value identifies the reference model.',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'RenderMaterial RenderMaterial',
        summary: `Gets the render material associated with this object or None if there
     is none.  This does not pay attention to the material source and will
     not check parent objects or layers for a RenderMaterial.`,
        since: 5.7,
        property: ['get', 'set']
      },
      {
        signature: 'uint RuntimeSerialNumber',
        summary: 'Gets the objects runtime serial number.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ComponentIndex[] SubobjectMaterialComponents',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool Visible',
        summary: 'Gets the object visibility.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'uint WorksessionReferenceSerialNumber',
        summary: 'Obsolete - use ReferenceModelSerialNumber',
        since: 6.3,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static RhinoObject FromRuntimeSerialNumber(uint serialNumber)',
        summary: 'Get a Rhino object for a unique runtime serial number',
        since: 6
      },
      {
        signature: 'static Brep[] GetFillSurfaces(RhinoObject rhinoObject,ClippingPlaneObject clippingPlaneObject)',
        summary: 'Return list of fill surfaces if any for object and clipping plane.',
        since: 6.7,
        parameters: [
          {
            name: 'rhinoObject',
            summary: 'Object to clip'
          },
          {
            name: 'clippingPlaneObject',
            summary: 'Clipping plane to use'
          }
        ]
      },
      {
        signature: 'static Brep[] GetFillSurfaces(RhinoObject rhinoObject,IEnumerable<ClippingPlaneObject> clippingPlaneObjects)',
        summary: `Return list of fill surfaces if any for object and clipping plane. Fills are trimmed by
     clipping planes that did not generate them.`,
        since: 6.7,
        parameters: [
          {
            name: 'rhinoObject',
            summary: 'Object to clip'
          },
          {
            name: 'clippingPlaneObjects',
            summary: 'Enumeration of clipping plane objects'
          }
        ],
        returns: 'Array of Brep containing fully trimmed fills if there were any generated.'
      },
      {
        signature: 'static Brep[] GetFillSurfaces(RhinoObject rhinoObject,IEnumerable<ClippingPlaneObject> clippingPlaneObjects,bool unclippedFills)',
        summary: 'Return list of fill surfaces if any for object and clipping plane.',
        since: 6.7,
        parameters: [
          {
            name: 'rhinoObject',
            summary: 'Object to clip'
          },
          {
            name: 'clippingPlaneObjects',
            summary: 'Enumeration of clipping plane objects'
          },
          {
            name: 'unclippedFills',
            summary: 'Use True to get fills that are not trimmed by all clipping planes'
          }
        ],
        returns: 'Array of Brep containing fills if there were any generated, trimmed if unclippedFills was false'
      },
      {
        signature: 'static ObjRef[] GetRenderMeshes(IEnumerable<RhinoObject> rhinoObjects,bool okToCreate,bool returnAllObjects)',
        summary: 'Gets the render meshes of some objects.',
        since: 5,
        parameters: [
          {
            name: 'rhinoObjects',
            summary: 'An array, a list, or any enumerable set of Rhino objects.'
          },
          {
            name: 'okToCreate',
            summary: 'True if the method is allowed to instantiate new meshes if they do not exist.'
          },
          {
            name: 'returnAllObjects',
            summary: 'True if all objects should be returned.'
          }
        ],
        returns: 'An array of object references.'
      },
      {
        signature: 'static Commands.Result MeshObjects(IEnumerable<RhinoObject> rhinoObjects,MeshingParameters parameters,bool simpleDialog,Mesh[] meshes,ObjectAttributes[] attributes)',
        summary: 'Meshes Rhino objects.',
        since: 5.9,
        parameters: [
          {
            name: 'rhinoObjects',
            summary: 'The Rhino objects to mesh.'
          },
          {
            name: 'parameters',
            summary: 'The parameters used to create the meshes. The meshing parameters may change.'
          },
          {
            name: 'simpleDialog',
            summary: 'True to display the simple mesh parameters dialog, False to display the detailed mesh parameters dialog.'
          },
          {
            name: 'meshes',
            summary: 'The created meshes are appended to this array.'
          },
          {
            name: 'attributes',
            summary: 'The object attributes that coincide with each created mesh are appended to this array.'
          }
        ],
        returns: 'The results of the calculation.'
      },
      {
        signature: 'static Commands.Result MeshObjects(IEnumerable<RhinoObject> rhinoObjects,MeshingParameters parameters,int uiStyle,Transform xform,Mesh[] meshes,ObjectAttributes[] attributes)',
        summary: 'Meshes Rhino objects.',
        since: 6,
        parameters: [
          {
            name: 'rhinoObjects',
            summary: 'The Rhino objects to mesh.'
          },
          {
            name: 'parameters',
            summary: 'The parameters used to create the meshes. The meshing parameters may change.'
          },
          {
            name: 'uiStyle',
            summary: 'The user interface style, where: -1 = no interface, 0 = simple dialog, 1 = details dialog, 2 = script or batch mode'
          },
          {
            name: 'xform',
            summary: 'Transform to be used for export with origin, or Z to Y up, etc.'
          },
          {
            name: 'meshes',
            summary: 'The created meshes are appended to this array.'
          },
          {
            name: 'attributes',
            summary: 'The object attributes that coincide with each created mesh are appended to this array.'
          }
        ],
        returns: 'The results of the calculation.'
      },
      {
        signature: 'static Commands.Result MeshObjects(IEnumerable<RhinoObject> rhinoObjects,MeshingParameters parameters,Mesh[] meshes,ObjectAttributes[] attributes)',
        summary: 'Meshes Rhino objects.',
        since: 5.9,
        parameters: [
          {
            name: 'rhinoObjects',
            summary: 'The Rhino objects to mesh.'
          },
          {
            name: 'parameters',
            summary: 'The parameters used to create the meshes.'
          },
          {
            name: 'meshes',
            summary: 'The created meshes are appended to this array.'
          },
          {
            name: 'attributes',
            summary: 'The object attributes that coincide with each created mesh are appended to this array.'
          }
        ],
        returns: 'The results of the calculation.'
      },
      {
        signature: 'bool CommitChanges()',
        summary: 'Moves changes made to this RhinoObject into the RhinoDoc.',
        since: 5,
        returns: 'True if changes were made.'
      },
      {
        signature: 'int CreateMeshes(MeshType meshType,MeshingParameters parameters,bool ignoreCustomParameters)',
        summary: 'Create meshes used to render and analyze surface and polysrf objects.',
        since: 5,
        parameters: [
          {
            name: 'meshType',
            summary: 'type of meshes to create'
          },
          {
            name: 'parameters',
            summary: 'in parameters that control the quality of the meshes that are created'
          },
          {
            name: 'ignoreCustomParameters',
            summary: `Default should be false. Should the object ignore any custom meshing
     parameters on the object's attributes`
          }
        ],
        returns: 'number of meshes created'
      },
      {
        signature: 'void Description(TextLog textLog)',
        summary: 'Get a brief description of a object, including it\'s attributes and geometry.',
        since: 6,
        parameters: [
          {
            name: 'textLog',
            summary: 'A textlog for collecting the description.'
          }
        ]
      },
      {
        signature: 'GeometryBase DuplicateGeometry()',
        summary: 'Constructs a deep (full) copy of the geometry.',
        since: 5,
        returns: 'A copy of the internal geometry.'
      },
      {
        signature: 'bool EnableCustomGrips(CustomObjectGrips customGrips)',
        summary: 'Turns on/off the object\'s editing grips.',
        since: 5,
        parameters: [
          {
            name: 'customGrips',
            summary: 'The custom object grips.'
          }
        ],
        returns: `True if the call succeeded.  If you attempt to add custom grips to an
     object that does not support custom grips, then False is returned.`
      },
      {
        signature: 'bool EnableVisualAnalysisMode(VisualAnalysisMode mode,bool enable)',
        summary: 'Used to turn analysis modes on and off.',
        since: 5,
        parameters: [
          {
            name: 'mode',
            summary: 'A visual analysis mode.'
          },
          {
            name: 'enable',
            summary: 'True if the mode should be activated; False otherwise.'
          }
        ],
        returns: 'True if this object supports the analysis mode.'
      },
      {
        signature: 'Display.VisualAnalysisMode[] GetActiveVisualAnalysisModes()',
        summary: 'Gets a list of currently enabled analysis modes for this object.',
        since: 5,
        returns: 'An array of visual analysis modes. The array can be empty, but not null.'
      },
      {
        signature: 'IConvertible GetCustomRenderMeshParameter(Guid providerId,String parameterName)',
        summary: 'Query the object for the value of a given named custom render mesh parameter.',
        since: 6,
        parameters: [
          {
            name: 'providerId',
            summary: 'Id of the custom render mesh provider'
          },
          {
            name: 'parameterName',
            summary: 'Name of the parameter'
          }
        ],
        returns: 'IConvertible. Note that you can\'t directly cast from object, instead you have to use the Convert mechanism.'
      },
      {
        signature: 'bool GetDynamicTransform(Transform transform)',
        summary: `While an object is being dynamically tranformed (dragged, rotated, ...),
     the current transformation can be retrieved and used for creating
     dynamic display.`,
        since: 5,
        returns: `True if the object is being edited and its transformation
     is available.  False if the object is not being edited,
     in which case the identity xform is returned.`
      },
      {
        signature: 'GripObject[] GetGrips()',
        summary: `Returns grips for this object If grips are enabled. If grips are not
     enabled, returns null.`,
        since: 5,
        returns: 'An array of grip objects; or None if there are no grips.'
      },
      {
        signature: 'int[] GetGroupList()',
        summary: `Allocates an array of group indices of length GroupCount.
     If GroupCount is 0, then this method returns null.`,
        since: 5,
        returns: 'An array of group indices, or None if GroupCount is 0.'
      },
      {
        signature: 'ComponentIndex[] GetHighlightedSubObjects()',
        summary: 'Gets a list of all highlighted subobjects.',
        since: 5,
        returns: 'An array of all highlighted subobjects; or None is there are none.'
      },
      {
        signature: 'Material GetMaterial(bool frontMaterial)',
        summary: `Gets material that this object uses based on it's attributes and the document
     that the object is associated with.  In the rare case that a document is not
     associated with this object, None will be returned.`,
        since: 5,
        parameters: [
          {
            name: 'frontMaterial',
            summary: 'If true, gets the material used to render the object\'s front side'
          }
        ]
      },
      {
        signature: 'Material GetMaterial(ComponentIndex componentIndex)',
        summary: `Get the Material associated with the sub object
     identified by componentIndex if the component index is
     set to ComponentIndex.Unset
     then the top level material is returned.`,
        since: 6,
        parameters: [
          {
            name: 'componentIndex',
            summary: `Returns the material associated with the specified sub object or the
     objects top level material if it is set to ComponentIndex.Unset`
          }
        ],
        returns: `Returns the Material associated with the sub object
     identified by componentIndex if the component index is
     set to ComponentIndex.Unset then the top level material
     is returned.`
      },
      {
        signature: 'Material GetMaterial(ComponentIndex componentIndex,Guid plugInId)',
        summary: `Get the Material associated with the sub object
     identified by componentIndex if the component index is
     set to ComponentIndex.Unset
     then the top level material is returned.`,
        since: 6,
        parameters: [
          {
            name: 'componentIndex',
            summary: `Returns the material associated with the specified sub object or the
     objects top level material if it is set to ComponentIndex.Unset`
          },
          {
            name: 'plugInId',
            summary: 'The plug-in specific material to look for.'
          }
        ],
        returns: `Returns the Material associated with the sub object
     identified by componentIndex if the component index is set to
     ComponentIndex.Unset
     then the top level material is returned.`
      },
      {
        signature: 'Material GetMaterial(ComponentIndex componentIndex,Guid plugInId,ObjectAttributes attributes)',
        summary: `Get the Material associated with the sub object
     identified by componentIndex if the component index is
     set to ComponentIndex.Unset then the top level material
     is returned.`,
        since: 6,
        parameters: [
          {
            name: 'componentIndex',
            summary: `Returns the material associated with the specified sub object or the
     objects top level material if it is set to ComponentIndex.Unset`
          },
          {
            name: 'plugInId',
            summary: 'The plug-in specific material to look for.'
          },
          {
            name: 'attributes',
            summary: `Optional object attributes used to determine the material source, if
     None the objects attributes are used.`
          }
        ],
        returns: `Returns the Material associated with the sub object
     identified by componentIndex if the component index is set to
     ComponentIndex.Unset then the top level material is returned.`
      },
      {
        signature: 'Mesh[] GetMeshes(MeshType meshType)',
        summary: 'Get existing meshes used to render and analyze surface and polysrf objects.',
        since: 5,
        returns: 'An array of meshes.'
      },
      {
        signature: 'RenderMaterial GetRenderMaterial(bool frontMaterial)',
        summary: `Gets the RenderMaterial that this object uses based on it's attributes
     and the document that the object is associated with. If there is no 
     RenderMaterial associated with this object then None is returned.  If
     None is returned you should call GetMaterial to get the material used
     to render this object.`,
        since: 5.1,
        parameters: [
          {
            name: 'frontMaterial',
            summary: `If true, gets the material used to render the object's front side
     otherwise; gets the material used to render the back side of the
     object.`
          }
        ],
        returns: `If there is a RenderMaterial associated with this objects' associated
     Material then it is returned otherwise; None is returned.`
      },
      {
        signature: 'RenderMaterial GetRenderMaterial(ComponentIndex componentIndex)',
        summary: `Gets the RenderMaterial associated with this object if there is one. If
     there is no RenderMaterial associated with this object then None is
     returned.  If None is returned you should call GetMaterial to get the
     material used to render this object.`,
        since: 6,
        parameters: [
          {
            name: 'componentIndex',
            summary: `Returns the RenderMaterial associated with the specified sub object or
     the objects top level material if it is set to ComponentIndex.Unset`
          }
        ],
        returns: `Returns the RenderMaterial associated with the sub object
     identified by componentIndex if the component index is set to
     ComponentIndex.Unset then the top level
     RenderMaterail is returned.  If this method returns None it means there
     is no RenderMaterial associated with the object or  sub object so you
     should may GetMaterial get the objects generic material.`
      },
      {
        signature: 'RenderMaterial GetRenderMaterial(ComponentIndex componentIndex,Guid plugInId)',
        summary: `Gets the RenderMaterial associated with this object if there is one. If
     there is no RenderMaterial associated with this object then None is
     returned.  If None is returned you should call GetMaterial to get the
     material used to render this object.`,
        since: 6,
        parameters: [
          {
            name: 'componentIndex',
            summary: `Returns the RenderMaterial associated with the specified sub object or
     the objects top level material if it is set to
     Rhino.Geometry.ComponentIndex.Unset`
          },
          {
            name: 'plugInId',
            summary: 'The plug-in specific material to look for.'
          }
        ],
        returns: `Returns the RenderMaterial associated with the sub object
     identified by componentIndex if the component index is set to
     ComponentIndex.Unset then the top level
     RenderMaterail is returned.  If this method returns None it means there
     is no RenderMaterial associated with the object or sub object so you
     should may GetMaterial get the objects generic material.`
      },
      {
        signature: 'RenderMaterial GetRenderMaterial(ComponentIndex componentIndex,Guid plugInId,ObjectAttributes attributes)',
        summary: `Gets the RenderMaterial associated with this object if there is one. If
     there is no RenderMaterial associated with this object then None is
     returned.  If None is returned you should call GetMaterial to get the
     material used to render this object.`,
        since: 6,
        parameters: [
          {
            name: 'componentIndex',
            summary: `Returns the RenderMaterial associated with the specified sub object or
     the objects top level material if it is set to
     Rhino.Geometry.ComponentIndex.Unset`
          },
          {
            name: 'plugInId',
            summary: 'The plug-in specific material to look for.'
          },
          {
            name: 'attributes',
            summary: `Optional object attributes used to determine the material source, if
     None the objects attributes are used.`
          }
        ],
        returns: `Returns the RenderMaterial associated with the sub object
     identified by componentIndex if the component index is set to
     ComponentIndex.Unset then the top level
     RenderMaterail is returned.  If this method returns None it means there
     is no RenderMaterial associated with the object or  sub object so you
     should may GetMaterial get the objects generic material.`
      },
      {
        signature: 'MeshingParameters GetRenderMeshParameters()',
        summary: `Meshing parameters that this object uses for generating render meshes. If the
     object's attributes do not have custom meshing parameters, then the document's
     meshing parameters are used.`,
        since: 5
      },
      {
        signature: 'RenderPrimitiveList GetRenderPrimitiveList(ViewportInfo viewport,bool preview)',
        summary: 'Build custom render mesh(es) for this object.',
        since: 5.7,
        parameters: [
          {
            name: 'viewport',
            summary: 'The viewport being rendered.'
          },
          {
            name: 'preview',
            summary: `Type of mesh to build, if preview is True then a smaller mesh may be
     generated in less time, False is meant when actually rendering.`
          }
        ],
        returns: 'Returns a RenderPrimitiveList if successful otherwise returns null.'
      },
      {
        signature: 'RenderPrimitiveList GetRenderPrimitiveList(ViewportInfo viewport,DisplayPipelineAttributes attrs)',
        summary: 'Build custom render mesh(es) for this object.',
        since: 6,
        parameters: [
          {
            name: 'viewport',
            summary: 'The viewport being rendered.'
          },
          {
            name: 'attrs',
            summary: 'Attributes for the view mode you are supplying meshes for.  Will be None if this is a modal rendering.'
          }
        ],
        returns: 'Returns a RenderPrimitiveList if successful otherwise returns null.'
      },
      {
        signature: 'ComponentIndex[] GetSelectedSubObjects()',
        summary: 'Get a list of all selected sub-objects.',
        since: 5,
        returns: 'An array of subobject indices, or None if there are none.'
      },
      {
        signature: 'RhinoObject[] GetSubObjects()',
        summary: 'Gets an array of sub-objects.',
        since: 5,
        returns: 'An array of subobjects, or None if there are none.'
      },
      {
        signature: 'int[] GetTextureChannels()',
        summary: 'Get a list of the texture mapping channel Id\'s associated with object.',
        since: 5.7,
        returns: 'Returns an array of channel Id\'s or an empty list if there are not mappings.'
      },
      {
        signature: 'TextureMapping GetTextureMapping(int channel)',
        since: 5.7
      },
      {
        signature: 'TextureMapping GetTextureMapping(int channel,Transform objectTransform)',
        summary: 'Get objects texture mapping',
        since: 5.7
      },
      {
        signature: 'bool HasTextureMapping()',
        summary: 'Returns True if this object has a texture mapping form any source (pluginId)',
        since: 6
      },
      {
        signature: 'bool Highlight(bool enable)',
        summary: 'Modifies the highlighting of the object.',
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'True if highlighting should be enabled.'
          }
        ],
        returns: 'True if the object is now highlighted.'
      },
      {
        signature: 'bool HighlightSubObject(ComponentIndex componentIndex,bool highlight)',
        summary: 'Highlights a subobject.',
        since: 5,
        parameters: [
          {
            name: 'componentIndex',
            summary: 'A subobject component index.'
          },
          {
            name: 'highlight',
            summary: 'True if the subobject should be highlighted.'
          }
        ],
        returns: 'True if the subobject is now highlighted.'
      },
      {
        signature: 'bool InVisualAnalysisMode()',
        summary: 'Reports if any visual analysis mode is currently active for an object.',
        since: 5,
        returns: 'True if an analysis mode is active; otherwise false.'
      },
      {
        signature: 'bool InVisualAnalysisMode(VisualAnalysisMode mode)',
        summary: 'Reports if a visual analysis mode is currently active for an object.',
        since: 5,
        parameters: [
          {
            name: 'mode',
            summary: `The mode to check for.
     Use None if you want to see if any mode is active.`
          }
        ],
        returns: 'True if the specified analysis mode is active; otherwise false.'
      },
      {
        signature: 'bool IsActiveInViewport(RhinoViewport viewport)',
        summary: 'Determine if this object is active in a particular viewport.',
        since: 5,
        returns: 'True if the object is active in viewport'
      },
      {
        signature: 'int IsHighlighted(bool checkSubObjects)',
        summary: 'Check highlight state.',
        since: 5,
        parameters: [
          {
            name: 'checkSubObjects',
            summary: `If True and the entire object is not highlighted, and some subset of the object
     is highlighted, like some edges of a surface, then 3 is returned.
     If False and the entire object is not highlighted, then zero is returned.`
          }
        ],
        returns: '0: object is not highlighted.1: entire object is highlighted.3: one or more proper sub-objects are highlighted.'
      },
      {
        signature: 'bool IsMeshable(MeshType meshType)',
        summary: 'Returns True if the object is capable of having a mesh of the specified type',
        since: 5
      },
      {
        signature: 'bool IsSelectable()',
        summary: 'Reports if an object can be selected.',
        since: 5,
        returns: 'True if object is capable of being selected.'
      },
      {
        signature: 'bool IsSelectable(bool ignoreSelectionState,bool ignoreGripsState,bool ignoreLayerLocking,bool ignoreLayerVisibility)',
        summary: 'Reports if an object can be selected.',
        since: 5,
        parameters: [
          {
            name: 'ignoreSelectionState',
            summary: `If true, then selected objects are selectable.
     If false, then selected objects are not selectable.`
          },
          {
            name: 'ignoreGripsState',
            summary: `If true, then objects with grips on can be selected.
     If false, then the value returned by the object's IsSelectableWithGripsOn() function decides if the object can be selected.`
          },
          {
            name: 'ignoreLayerLocking',
            summary: `If true, then objects on locked layers are selectable.
     If false, then objects on locked layers are not selectable.`
          },
          {
            name: 'ignoreLayerVisibility',
            summary: `If true, then objects on hidden layers are selectable.
     If false, then objects on hidden layers are not selectable.`
          }
        ],
        returns: 'True if object is capable of being selected.'
      },
      {
        signature: 'int IsSelected(bool checkSubObjects)',
        summary: 'Check selection state.',
        since: 5,
        parameters: [
          {
            name: 'checkSubObjects',
            summary: `(False is good default)
     If True and the entire object is not selected, and some subset of the object
     is selected, like some edges of a surface, then 3 is returned.
     If False and the entire object is not selected, then zero is returned.`
          }
        ],
        returns: `0 = object is not selected.
     1 = object is selected.
     2 = entire object is selected persistently.
     3 = one or more proper sub-objects are selected.`
      },
      {
        signature: 'bool IsSubObjectHighlighted(ComponentIndex componentIndex)',
        summary: 'Determines if a subobject is highlighted.',
        since: 5,
        parameters: [
          {
            name: 'componentIndex',
            summary: 'A subobject component index.'
          }
        ],
        returns: 'True if the subobject is highlighted.'
      },
      {
        signature: 'bool IsSubObjectSelectable(ComponentIndex componentIndex,bool ignoreSelectionState)',
        summary: 'Reports if a subobject can be selected.',
        since: 5,
        parameters: [
          {
            name: 'componentIndex',
            summary: 'index of subobject to check.'
          },
          {
            name: 'ignoreSelectionState',
            summary: `If true, then selected objects are selectable.
     If false, then selected objects are not selectable.`
          }
        ],
        returns: 'True if the specified subobject can be selected.'
      },
      {
        signature: 'bool IsSubObjectSelected(ComponentIndex componentIndex)',
        summary: 'Check sub-object selection state.',
        since: 5,
        parameters: [
          {
            name: 'componentIndex',
            summary: 'Index of subobject to check.'
          }
        ],
        returns: 'True if the subobject is selected.'
      },
      {
        signature: 'uint MemoryEstimate()',
        summary: `Computes an estimate of the number of bytes that this object is using in memory.
     Note that this is a runtime memory estimate and does not directly compare to the
     amount of space take up by the object when saved to a file.`,
        since: 5,
        returns: 'The estimated number of bytes this object occupies in memory.'
      },
      {
        signature: 'int MeshCount(MeshType meshType,MeshingParameters parameters)',
        summary: `RhinoObjects can have several different types of meshes and 
     different numbers of meshes.  A b-rep can have a render and 
     an analysis mesh on each face.  A mesh object has a single 
     render mesh and no analysis mesh. Curve, point, and annotation
     objects have no meshes.`,
        since: 5,
        parameters: [
          {
            name: 'meshType',
            summary: 'type of mesh to count'
          },
          {
            name: 'parameters',
            summary: `if not None and if the object can change its mesh (like a brep),
     then only meshes that were created with these mesh parameters are counted.`
          }
        ],
        returns: 'number of meshes'
      },
      {
        signature: 'int Select(bool on)',
        summary: 'Selects an object.',
        since: 5,
        parameters: [
          {
            name: 'on',
            summary: 'The new selection state; True activates selection.'
          }
        ],
        returns: '0: object is not selected.1: object is selected.2: object is selected persistently.'
      },
      {
        signature: 'int Select(bool on,bool syncHighlight)',
        summary: 'Selects an object.',
        since: 5,
        parameters: [
          {
            name: 'on',
            summary: 'The new selection state; True activates selection.'
          },
          {
            name: 'syncHighlight',
            summary: `If true, then the object is hightlighted if it is selected
     and not hightlighted if is is not selected.
     Highlighting can be and stay out of sync, as its specification is independent.`
          }
        ],
        returns: '0: object is not selected.1: object is selected.2: object is selected persistently.'
      },
      {
        signature: 'int Select(bool on,bool syncHighlight,bool persistentSelect,bool ignoreGripsState,bool ignoreLayerLocking,bool ignoreLayerVisibility)',
        summary: 'Selects an object.',
        since: 5,
        parameters: [
          {
            name: 'on',
            summary: 'The new selection state; True activates selection.'
          },
          {
            name: 'syncHighlight',
            summary: `If true, then the object is highlighted if it is selected 
     and unhighlighted if is is not selected.
     Highlighting can be and stay out of sync, as its specification is independent.`
          },
          {
            name: 'persistentSelect',
            summary: 'Objects that are persistently selected stay selected when a command terminates.'
          },
          {
            name: 'ignoreGripsState',
            summary: `If true, then objects with grips on can be selected.
     If false, then the value returned by the object's IsSelectableWithGripsOn() function
     decides if the object can be selected when it has grips turned on.`
          },
          {
            name: 'ignoreLayerLocking',
            summary: `If true, then objects on locked layers can be selected.
     If false, then objects on locked layers cannot be selected.`
          },
          {
            name: 'ignoreLayerVisibility',
            summary: `If true, then objects on hidden layers can be selectable.
     If false, then objects on hidden layers cannot be selected.`
          }
        ],
        returns: '0: object is not selected.1: object is selected.2: object is selected persistently.'
      },
      {
        signature: 'int SelectSubObject(ComponentIndex componentIndex,bool select,bool syncHighlight)',
        summary: 'Reports if an object can be selected.',
        since: 5,
        parameters: [
          {
            name: 'componentIndex',
            summary: 'Index of subobject to check.'
          },
          {
            name: 'select',
            summary: 'The new selection state; True activates selection.'
          },
          {
            name: 'syncHighlight',
            summary: `(default=true)
     If true, then the object is highlighted if it is selected 
     and unhighlighted if is is not selected.`
          }
        ],
        returns: `0: object is not selected
     1: object is selected
     2: object is selected persistently.`
      },
      {
        signature: 'int SelectSubObject(ComponentIndex componentIndex,bool select,bool syncHighlight,bool persistentSelect)',
        summary: 'Reports if an object can be selected.',
        since: 6,
        parameters: [
          {
            name: 'componentIndex',
            summary: 'Index of subobject to check.'
          },
          {
            name: 'select',
            summary: 'The new selection state; True activates selection.'
          },
          {
            name: 'syncHighlight',
            summary: `(default=true)
     If true, then the object is highlighted if it is selected 
     and unhighlighted if is is not selected.`
          },
          {
            name: 'persistentSelect',
            summary: `When true, selection persists even after the current command
     terminates.`
          }
        ],
        returns: '0: object is not selected1: object is selected2: object is selected persistently.'
      },
      {
        signature: 'void SetCustomRenderMeshParameter(Guid providerId,String parameterName,object value)',
        summary: 'Set the named custom render mesh parameter value for this object.',
        since: 6,
        parameters: [
          {
            name: 'providerId',
            summary: 'Id of the custom render mesh provider'
          },
          {
            name: 'parameterName',
            summary: ''
          },
          {
            name: 'value',
            summary: ''
          }
        ]
      },
      {
        signature: 'int SetTextureMapping(int channel,TextureMapping tm)',
        since: 6
      },
      {
        signature: 'string ShortDescription(bool plural)',
        summary: 'Gets a localized short descriptive name of the object.',
        since: 5,
        parameters: [
          {
            name: 'plural',
            summary: 'True if the descriptive name should in plural.'
          }
        ],
        returns: 'A string with the short localized descriptive name.'
      },
      {
        signature: 'bool SupportsRenderPrimitiveList(ViewportInfo viewport,bool preview)',
        summary: 'Determines if custom render meshes will be built for a particular object.',
        since: 5.7,
        parameters: [
          {
            name: 'viewport',
            summary: 'The viewport being rendered.'
          },
          {
            name: 'preview',
            summary: `Type of mesh to build. If attrs is non-None then a smaller mesh may be
     generated in less time, False is meant when actually rendering.`
          }
        ],
        returns: 'Returns True if custom render mesh(es) will get built for this object.'
      },
      {
        signature: 'bool SupportsRenderPrimitiveList(ViewportInfo viewport,DisplayPipelineAttributes attrs)',
        summary: 'Determines if custom render meshes will be built for a particular object.',
        since: 6,
        parameters: [
          {
            name: 'viewport',
            summary: 'The viewport being rendered.'
          },
          {
            name: 'attrs',
            summary: `Type of mesh to build. If attrs is non-None then a smaller mesh may be
     generated in less time, False is meant when actually rendering.`
          }
        ],
        returns: 'Returns True if custom render mesh(es) will get built for this object.'
      },
      {
        signature: 'bool TryGetRenderPrimitiveBoundingBox(ViewportInfo viewport,bool preview,BoundingBox boundingBox)',
        summary: `Get the bounding box for the custom render meshes associated with this
     object.`,
        since: 5.7,
        parameters: [
          {
            name: 'viewport',
            summary: 'The viewport being rendered.'
          },
          {
            name: 'preview',
            summary: `Type of mesh to build, if preview is True then a smaller mesh may be
     generated in less time, False is meant when actually rendering.`
          },
          {
            name: 'boundingBox',
            summary: `This will be set to BoundingBox.Unset on failure otherwise it will be
     the bounding box for the custom render meshes associated with this
     object.`
          }
        ],
        returns: `Returns True if the bounding box was successfully calculated otherwise
     returns False on error.`
      },
      {
        signature: 'bool TryGetRenderPrimitiveBoundingBox(ViewportInfo viewport,DisplayPipelineAttributes attrs,BoundingBox boundingBox)',
        summary: `Get the bounding box for the custom render meshes associated with this
     object.`,
        since: 6,
        parameters: [
          {
            name: 'viewport',
            summary: 'The viewport being rendered.'
          },
          {
            name: 'attrs',
            summary: 'Attributes for the view mode you are supplying meshes for.  Will be None if this is a modal rendering.'
          },
          {
            name: 'boundingBox',
            summary: `This will be set to BoundingBox.Unset on failure otherwise it will be
     the bounding box for the custom render meshes associated with this
     object.`
          }
        ],
        returns: `Returns True if the bounding box was successfully calculated otherwise
     returns False on error.`
      },
      {
        signature: 'int UnhighlightAllSubObjects()',
        summary: 'Removes highlighting from all subobjects.',
        since: 5,
        returns: 'The number of changed subobjects.'
      },
      {
        signature: 'int UnselectAllSubObjects()',
        summary: 'Removes selection from all subobjects.',
        since: 5,
        returns: 'The number of unselected subobjects.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'RhinoObjectEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'Guid ObjectId',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoObject TheObject',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'RhinoObjectSelectionEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RhinoDoc Document',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoObject[] RhinoObjects',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool Selected',
        summary: `Returns True if objects are being selected.
       Returns False if objects are being deseleced.`,
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'RhinoReplaceObjectEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RhinoDoc Document',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoObject NewRhinoObject',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid ObjectId',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoObject OldRhinoObject',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'RhinoTransformObjectsEventArgs',
    dataType: 1,
    summary: 'EventArgs passed to RhinoDoc.BeforeTransform.',
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'int ObjectCount',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'RhinoObject[] Objects',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'bool ObjectsWillBeCopied',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Transform Transform',
        since: 5.1,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'SelectionMethod',
    dataType: 3,
    summary: 'Defines enumerated values for several kinds of selection methods.',
    values: [
      {
        signature: 'Other = 0',
        summary: 'Selected by non-mouse method (SelAll, etc.)'
      },
      {
        signature: 'MousePick = 1',
        summary: 'Selected by a mouse click on the object.'
      },
      {
        signature: 'WindowBox = 2',
        summary: `Selected by a mouse selection window box. 
     Window selection indicates the object is completely contained by the selection rectangle.`
      },
      {
        signature: 'CrossingBox = 3',
        summary: `Selected by a mouse selection crossing box. 
     A crossing selection indicates the object intersects with the selection rectangle.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.SnapShots',
    name: 'SnapShotsClient',
    dataType: 1,
    summary: 'This is the abstract interface class for for all Snapshot clients.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SnapShotsClient()',
        summary: 'SnapShotsClient constructor',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int SerialNumber',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static string ApplicationCategory()',
        summary: 'Predefined application category',
        since: 6
      },
      {
        signature: 'static string DocumentCategory()',
        summary: 'Predefined document category',
        since: 6
      },
      {
        signature: 'static string LayersCategory()',
        summary: 'Predefined layers category',
        since: 6
      },
      {
        signature: 'static string LightsCategory()',
        summary: 'Predefined lights category',
        since: 6
      },
      {
        signature: 'static string ObjectsCategory()',
        summary: 'Predefined objects category',
        since: 6
      },
      {
        signature: 'static bool RegisterSnapShotClient(SnapShotsClient client)',
        summary: 'Function used to register snapshots client',
        since: 6
      },
      {
        signature: 'static string RenderingCategory()',
        summary: 'Predefined rendering category',
        since: 6
      },
      {
        signature: 'static string ViewsCategory()',
        summary: 'Predefined views category',
        since: 6
      },
      {
        signature: 'bool AnimateDocument(RhinoDoc doc,double dPos,BinaryArchiveReader archive_start,BinaryArchiveReader archive_stop)',
        summary: 'Called for each frame. Starting at 0.0.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document.'
          },
          {
            name: 'dPos',
            summary: 'dPos is is the current frame. Starting at 0.0.'
          },
          {
            name: 'archive_start',
            summary: 'archive_start is a archive to the data of the starting position.'
          },
          {
            name: 'archive_stop',
            summary: 'archive_stop is a archive to the data of the ending position.'
          }
        ],
        returns: 'True if successful, otherwise false.'
      },
      {
        signature: 'bool AnimateObject(RhinoDoc doc,RhinoObject doc_object,Transform transform,double dPos,BinaryArchiveReader archive_start,BinaryArchiveReader archive_stop)',
        summary: 'Called for each frame. Starting at 0.0.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document.'
          },
          {
            name: 'doc_object',
            summary: 'doc_obj is the current object.'
          },
          {
            name: 'transform',
            summary: `transform is a transformation matrix. The matrix is set to identity the first time an object is associated with a snapshot.
     After that the matrix is updated when the object is transformed(scale, rotate etc.).`
          },
          {
            name: 'dPos',
            summary: 'dPos is is the current frame. Starting at 0.0.'
          },
          {
            name: 'archive_start',
            summary: 'archive_start is a archive to the data of the starting position.'
          },
          {
            name: 'archive_stop',
            summary: 'archive_stop is a archive to the data of the ending position.'
          }
        ]
      },
      {
        signature: 'void AnimationStart(RhinoDoc doc,int iFrames)',
        summary: 'Called once at the start of an animation.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document.'
          },
          {
            name: 'iFrames',
            summary: 'iFrames is the number of frames to be animated.'
          }
        ]
      },
      {
        signature: 'bool AnimationStop(RhinoDoc doc)',
        summary: 'Called once at the end of an animation.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document.'
          }
        ]
      },
      {
        signature: 'string Category()',
        summary: `The category of this client. Usually one of the above predefined categories like e.g
     object, rendering or application category`,
        since: 6
      },
      {
        signature: 'Guid ClientId()',
        summary: 'The unique id of this client.',
        since: 6,
        returns: 'The unique id of this client.'
      },
      {
        signature: 'void Dispose()',
        summary: 'SnapShotsClient Dispose',
        since: 6
      },
      {
        signature: 'void ExtendBoundingBoxForDocumentAnimation(RhinoDoc doc,BinaryArchiveReader archive_start,BinaryArchiveReader archive_stop,BoundingBox bbox)',
        summary: 'Called once at the start of an animation. This can be used to extend the scene bounding box to avoid clipping.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document.'
          },
          {
            name: 'archive_start',
            summary: 'archive_start is a archive to the data of the starting position.'
          },
          {
            name: 'archive_stop',
            summary: 'archive_stop is a archive to the data of the ending position.'
          },
          {
            name: 'bbox',
            summary: 'bbox is the current scene bounding box.'
          }
        ]
      },
      {
        signature: 'void ExtendBoundingBoxForObjectAnimation(RhinoDoc doc,RhinoObject doc_object,Transform transform,BinaryArchiveReader archive_start,BinaryArchiveReader archive_stop,BoundingBox bbox)',
        summary: 'Called once at the start of an animation. This can be used to extend the scene bounding box to avoid clipping.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document.'
          },
          {
            name: 'doc_object',
            summary: 'doc_obj is the current object.'
          },
          {
            name: 'transform',
            summary: `transform is a transformation matrix. The matrix is set to identity the first time an object is associated with a snapshot.
     After that the matrix is updated when the object is transformed(scale, rotate etc.).`
          },
          {
            name: 'archive_start',
            summary: 'archive_start is a archive to the data of the starting position.'
          },
          {
            name: 'archive_stop',
            summary: 'archive_stop is a archive to the data of the ending position.'
          },
          {
            name: 'bbox',
            summary: 'bbox is the current scene bounding box.'
          }
        ]
      },
      {
        signature: 'bool IsCurrentModelStateInAnySnapshot(RhinoDoc doc,BinaryArchiveReader archive,SimpleArrayBinaryArchiveReader archive_array,TextLog text_log)',
        summary: 'Called before restoring a snapshot. Warns the user if the current model state is not already saved.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document.'
          },
          {
            name: 'archive',
            summary: 'archive is the current state of the model.'
          },
          {
            name: 'archive_array',
            summary: 'archive_array is a list of client data.'
          },
          {
            name: 'text_log',
            summary: 'text_log is used to list the missing items that cannot be found in the current model.'
          }
        ],
        returns: 'return True if successful, otherwise false.'
      },
      {
        signature: 'bool IsCurrentModelStateInAnySnapshot(RhinoDoc doc,RhinoObject doc_object,BinaryArchiveReader archive,SimpleArrayBinaryArchiveReader archive_array,TextLog text_log)',
        summary: 'Called before restoring a snapshot. Warns the user if the current model state is not already saved.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document.'
          },
          {
            name: 'doc_object',
            summary: 'doc_object is the current object.'
          },
          {
            name: 'archive',
            summary: 'archive is the current state of the model.'
          },
          {
            name: 'archive_array',
            summary: 'archive_array is a list of client data.'
          },
          {
            name: 'text_log',
            summary: 'text_log is used to list the missing items that cannot be found in the current model.'
          }
        ],
        returns: 'return True if successful, otherwise false.'
      },
      {
        signature: 'string Name()',
        summary: 'The client\'s name.',
        since: 6,
        returns: 'The client\'s name.'
      },
      {
        signature: 'bool ObjectTransformNotification(RhinoDoc doc,RhinoObject doc_object,Transform transform,BinaryArchiveReader archive)',
        summary: 'Called for every object that is associated with a snapshot and gets transformed in Rhino. This is getting called for each stored snapshot and gives the client the possibility to update the stored data.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document.'
          },
          {
            name: 'doc_object',
            summary: 'doc_obj is the current object.'
          },
          {
            name: 'transform',
            summary: `transform is a transformation matrix. The matrix is set to identity the first time an object is associated with a snapshot.
     After that the matrix is updated when the object is transformed(scale, rotate etc.).`
          },
          {
            name: 'archive',
            summary: 'archive is a archive which can be used to update the stored data.'
          }
        ],
        returns: 'True if successful, otherwise false.'
      },
      {
        signature: 'Guid PlugInId()',
        summary: 'The plug-in id that registers this client.',
        since: 6,
        returns: 'The plug-in id that registers this client.'
      },
      {
        signature: 'bool PrepareForDocumentAnimation(RhinoDoc doc,BinaryArchiveReader archive_start,BinaryArchiveReader archive_stop)',
        summary: 'Called once at the start of an animation.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document.'
          },
          {
            name: 'archive_start',
            summary: 'archive_start is a archive to the data of the starting position.'
          },
          {
            name: 'archive_stop',
            summary: 'archive_stop is a archive to the data of the ending position.'
          }
        ],
        returns: 'True if successful, otherwise'
      },
      {
        signature: 'bool PrepareForObjectAnimation(RhinoDoc doc,RhinoObject doc_object,Transform transform,BinaryArchiveReader archive_start,BinaryArchiveReader archive_stop)',
        summary: 'Called once at the start of an animation.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document.'
          },
          {
            name: 'doc_object',
            summary: 'doc_obj is the current object.'
          },
          {
            name: 'transform',
            summary: `transform is a transformation matrix. The matrix is set to identity the first time an object is associated with a snapshot.
     After that the matrix is updated when the object is transformed(scale, rotate etc.).`
          },
          {
            name: 'archive_start',
            summary: 'archive_start is a archive to the data of the starting position.'
          },
          {
            name: 'archive_stop',
            summary: 'archive_stop is a archive to the data of the ending position.'
          }
        ],
        returns: 'True if successful, otherwise false.'
      },
      {
        signature: 'bool RestoreDocument(RhinoDoc doc,BinaryArchiveReader archive)',
        summary: 'Called when the user restores a snapshot and SupportDocument() returns true.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document'
          },
          {
            name: 'archive',
            summary: 'archive is the archive to read the data from'
          }
        ],
        returns: 'True if successful, otherwise false'
      },
      {
        signature: 'bool RestoreObject(RhinoDoc doc,RhinoObject doc_object,Transform transform,BinaryArchiveReader archive)',
        summary: 'Called when the user restores a snapshot and SupportsObjects() and SupportsObject(Rhino.DocObjects.RhinoObject doc_object) returns true.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document.'
          },
          {
            name: 'doc_object',
            summary: 'doc_obj is the current object.'
          },
          {
            name: 'transform',
            summary: `transform is a transformation matrix. The matrix is set to identity the first time an object is associated with a snapshot.
     After that the matrix is updated when the object is transformed(scale, rotate etc.).`
          },
          {
            name: 'archive',
            summary: 'archive is the archive to read the data from.'
          }
        ],
        returns: 'True if successful, otherwise false.'
      },
      {
        signature: 'bool SaveDocument(RhinoDoc doc,BinaryArchiveWriter archive)',
        summary: 'Called when the user saves a snapshot and SupportDocument() returns true.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document'
          },
          {
            name: 'archive',
            summary: 'archive is the archive to write the data to'
          }
        ],
        returns: 'True if successful, otherwise false'
      },
      {
        signature: 'bool SaveObject(RhinoDoc doc,RhinoObject doc_object,Transform transform,BinaryArchiveWriter archive)',
        summary: 'Called when the user saves a snapshot and SupportsObjects() and SupportsObject(Rhino.DocObjects.RhinoObject doc_object) returns true.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'doc is the current document.'
          },
          {
            name: 'doc_object',
            summary: 'doc_obj is the current object.'
          },
          {
            name: 'transform',
            summary: `transform is a transformation matrix. The matrix is set to identity the first time an object is associated with a snapshot.
     After that the matrix is updated when the object is transformed(scale, rotate etc.).`
          },
          {
            name: 'archive',
            summary: 'archive is the archive to write the data to.'
          }
        ],
        returns: 'True if successful, otherwise false.'
      },
      {
        signature: 'void SnapshotRestored(RhinoDoc doc)',
        summary: 'Called after all clients restored their data.',
        since: 6
      },
      {
        signature: 'bool SupportsAnimation()',
        summary: 'Returns True if the client allows animation.',
        since: 6,
        returns: 'True if the client allows animation.'
      },
      {
        signature: 'bool SupportsDocument()',
        summary: 'Defines if the client supports document user data or not',
        since: 6,
        returns: 'True if the client saves/restores document user data.'
      },
      {
        signature: 'bool SupportsObject(RhinoObject doc_object)',
        summary: 'Returns True if the client saves/restores object user data for the given object.',
        since: 6,
        parameters: [
          {
            name: 'doc_object',
            summary: 'doc_object is the given object'
          }
        ],
        returns: 'True if the client saves/restores object user data for the given object.'
      },
      {
        signature: 'bool SupportsObjects()',
        summary: 'Returns True if the client saves/restores object user data.',
        since: 6,
        returns: 'True if the client saves/restores object user data.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'SubDObject',
    dataType: 1,
    summary: 'Rhino object for SubD',
    baseclass: 'Rhino.DocObjects.RhinoObject'
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'SurfaceObject',
    dataType: 1,
    summary: 'Represents a Rhino.Geometry.Surface in a document.',
    baseclass: 'Rhino.DocObjects.RhinoObject',
    properties: [
      {
        signature: 'Surface SurfaceGeometry',
        summary: 'Gets the surface geometry linked with this object.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Surface DuplicateSurfaceGeometry()',
        summary: 'Constructs a new deep copy of the surface geometry.',
        since: 5,
        returns: 'The copy of the geometry.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'BitmapTable',
    dataType: 1,
    summary: 'Stores the list of bitmaps in a Rhino document.',
    baseclass: 'RhinoDocCommonTable<BitmapEntry>',
    interfaces: ['ICollection<BitmapEntry>'],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.Image.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int AddBitmap(string bitmapFilename,bool replaceExisting)',
        summary: 'Adds a new bitmap with specified name to the bitmap table.',
        since: 5,
        parameters: [
          {
            name: 'bitmapFilename',
            summary: 'If NULL or empty, then a unique name of the form "Bitmap 01" will be automatically created.'
          },
          {
            name: 'replaceExisting',
            summary: `If True and the there is alread a bitmap using the specified name, then that bitmap is replaced.
     If False and there is already a bitmap using the specified name, then -1 is returned.`
          }
        ],
        returns: 'index of new bitmap in table on success. -1 on error.'
      },
      {
        signature: 'bool Delete(BitmapEntry item)',
        summary: 'Removes the bitmap from the table.',
        since: 6,
        parameters: [
          {
            name: 'item',
            summary: 'The item to remove. Null will always return false.'
          }
        ],
        returns: 'True if the item could be deleted; otherwise, false.'
      },
      {
        signature: 'bool DeleteBitmap(string bitmapFilename)',
        summary: 'Deletes a bitmap.',
        since: 5,
        parameters: [
          {
            name: 'bitmapFilename',
            summary: 'The bitmap file name.'
          }
        ],
        returns: `True if successful. False if the bitmap cannot be deleted because it
     is the current bitmap or because it bitmap contains active geometry.`
      },
      {
        signature: 'bool ExportToFile(int index,string path)',
        summary: 'Writes a bitmap to a file.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'The index of the bitmap to be written.'
          },
          {
            name: 'path',
            summary: 'The full path, including file name and extension, name of the file to write.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'int ExportToFiles(string directoryPath,int overwrite)',
        summary: 'Exports all the bitmaps in the table to files.',
        since: 5,
        parameters: [
          {
            name: 'directoryPath',
            summary: `full path to the directory where the bitmaps should be saved.
     If NULL, a dialog is used to interactively get the directory name.`
          },
          {
            name: 'overwrite',
            summary: '0 = no, 1 = yes, 2 = ask.'
          }
        ],
        returns: 'Number of bitmaps written.'
      },
      {
        signature: 'BitmapEntry Find(string name,bool createFile,string fileName)',
        summary: `This function first attempts to find the file with "name" on the disk.
     If it does find it, "fileName" is set to the full path of the file and
     the BitmapEntry returned will be null, even if there was a BitmapEntry
     with "name" in the bitmap table.
     If the function cannot find the file on the disk, it searches the bitmap
     table.  If it finds it, the returned BitmapEntry entry will be the entry
     in the table with that name.
     Additionally, if "createFile" is true, and an entry is found, the file
     will be written to the disk and it's full path will be contained in "fileName".`,
        since: 5.1,
        parameters: [
          {
            name: 'name',
            summary: 'Name of the file to search for including file extension.'
          },
          {
            name: 'createFile',
            summary: `If this is true, and the file is not found on the disk but is found in
     the BitmapTable, then the BitmapEntry will get saved to the Rhino bitmap
     file cache and fileName will contain the full path to the cached file.`
          },
          {
            name: 'fileName',
            summary: `The full path to the current location of this file or an empty string
     if the file was not found and/or not extracted successfully.`
          }
        ],
        returns: `Returns None if "name" was found on the disk.  If name was not found on the disk,
     returns the BitmapEntry with the specified name if it is found in the bitmap table
     and None if it was not found in the bitmap table.`
      },
      {
        signature: 'BitmapEntry FindIndex(int index)',
        summary: `Retrieves a BitmapEntry object based on Index. This seach type of search is discouraged.
     We are moving towards using only IDs for all tables.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index to search for.'
          }
        ],
        returns: 'A BitmapEntry object, or None if none was found.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'DimStyleTable',
    dataType: 1,
    baseclass: 'RhinoDocCommonTable<DimensionStyle>',
    interfaces: ['ICollection<DimensionStyle>'],
    properties: [
      {
        signature: 'DimensionStyle[] BuiltInStyles',
        summary: 'Creates an array of default AnnotationStyle objects',
        since: 6,
        property: ['get']
      },
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.DimStyle.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'DimensionStyle Current',
        summary: 'Returns an instance of the current DimensionStyle.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'DimensionStyle CurrentDimensionStyle',
        summary: 'Do not use. Use the Current property.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid CurrentId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int CurrentIndex',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int Add(DimensionStyle dimstyle,bool reference)',
        summary: 'Adds a new DimensionStyle to the document.',
        since: 6,
        parameters: [
          {
            name: 'dimstyle',
            summary: 'The dimension style to add'
          },
          {
            name: 'reference',
            summary: 'if True the dimstyle will not be saved in files.'
          }
        ],
        returns: 'index of new AnnotationStyle.'
      },
      {
        signature: 'int Add(string name)',
        summary: `Adds a new AnnotationStyle to the document. The new AnnotationStyle will be initialized
     with the current default AnnotationStyle properties.`,
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'Name of the new AnnotationStyle. If None or empty, Rhino automatically generates the name.'
          }
        ],
        returns: 'index of new AnnotationStyle.'
      },
      {
        signature: 'int Add(string name,bool reference)',
        summary: `Adds a new AnnotationStyle to the document. The new AnnotationStyle will be initialized
     with the current default AnnotationStyle properties.`,
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'Name of the new AnnotationStyle. If None or empty, Rhino automatically generates the name.'
          },
          {
            name: 'reference',
            summary: 'if True the dimstyle will not be saved in files.'
          }
        ],
        returns: 'index of new AnnotationStyle.'
      },
      {
        signature: 'bool Delete(DimensionStyle item)',
        summary: 'Removes an annotation style.',
        since: 6,
        parameters: [
          {
            name: 'item',
            summary: 'The item to remove.'
          }
        ],
        returns: 'True if the item was removed; False otherwise.'
      },
      {
        signature: 'bool Delete(int index,bool quiet)',
        since: 6
      },
      {
        signature: 'DimensionStyle Find(Guid styleId,bool ignoreDeleted)',
        since: 6
      },
      {
        signature: 'DimensionStyle Find(string name,bool ignoreDeleted)',
        since: 5
      },
      {
        signature: 'DimensionStyle FindIndex(int index)',
        summary: `Retrieves a DimensionStyle object based on Index. This seach type of search is discouraged.
     We are moving towards using only IDs for all tables.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index to search for.'
          }
        ],
        returns: 'A DimensionStyle object, or None if none was found.'
      },
      {
        signature: 'DimensionStyle FindName(string name)',
        summary: 'Finds the DimensionStyle with a given name and retuns it. None is returned if no DimensionStyle is found.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'The string to search. Deleted styles are ignored.'
          }
        ],
        returns: 'The instance, or null.'
      },
      {
        signature: 'DimensionStyle FindRoot(Guid styleId,bool ignoreDeleted)',
        since: 6
      },
      {
        signature: 'IEnumerator<DimensionStyle> GetEnumerator()',
        since: 5
      },
      {
        signature: 'string GetUnusedStyleName()',
        summary: 'Get a unique name for a style that does not already exist in the DimStyle table',
        since: 6
      },
      {
        signature: 'string GetUnusedStyleName(string rootName)',
        summary: 'Get a unique name for a dimension style that does not already exist in the DimStyle table',
        since: 6,
        parameters: [
          {
            name: 'rootName',
            summary: 'prefix in name; typically the parent style name'
          }
        ]
      },
      {
        signature: 'ModifyType Modify(DimensionStyle dimstyle,AnnotationBase annotation)',
        since: 6
      },
      {
        signature: 'bool Modify(DimensionStyle newSettings,Guid dimstyleId,bool quiet)',
        summary: 'Modifies dimension style settings.',
        since: 6,
        parameters: [
          {
            name: 'newSettings',
            summary: 'This information is copied.'
          },
          {
            name: 'dimstyleId',
            summary: 'Id of dimension style'
          },
          {
            name: 'quiet',
            summary: 'if true, information message boxes pop up when illegal changes are attempted.'
          }
        ],
        returns: 'True if successful. False if Id is not already in table'
      },
      {
        signature: 'bool Modify(DimensionStyle newSettings,int dimstyleIndex,bool quiet)',
        summary: 'Modifies dimension style settings.',
        since: 6,
        parameters: [
          {
            name: 'newSettings',
            summary: 'This information is copied.'
          },
          {
            name: 'dimstyleIndex',
            summary: 'zero based index of dimension to set. Must be in the range 0 <= dimstyleIndex < DimStyleTable.Count.'
          },
          {
            name: 'quiet',
            summary: 'if true, information message boxes pop up when illegal changes are attempted.'
          }
        ],
        returns: 'True if successful. False if dimstyleIndex is out of range'
      },
      {
        signature: 'bool SetCurrent(int index,bool quiet)',
        summary: 'Sets the Current property.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index of the current DimStyle.'
          },
          {
            name: 'quiet',
            summary: 'True if error dialog boxes are disabled. False if they are enabled.'
          }
        ],
        returns: 'True if the method achieved its goal; otherwise false.'
      },
      {
        signature: 'bool SetCurrentDimensionStyleIndex(int index,bool quiet)',
        summary: 'Do not use. Use the SetCurrent method.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Do not use.'
          },
          {
            name: 'quiet',
            summary: 'Do not use.'
          }
        ],
        returns: 'Do not use.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'DimStyleTableEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RhinoDoc Document',
        since: 6,
        property: ['get']
      },
      {
        signature: 'DimStyleTableEventType EventType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int Index',
        since: 6,
        property: ['get']
      },
      {
        signature: 'DimensionStyle NewState',
        since: 6,
        property: ['get']
      },
      {
        signature: 'DimensionStyle OldState',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'DimStyleTableEventType',
    dataType: 3,
    values: [
      {
        signature: 'Added'
      },
      {
        signature: 'Deleted'
      },
      {
        signature: 'Undeleted'
      },
      {
        signature: 'Modified',
        summary: 'name, color, etc., change'
      },
      {
        signature: 'Sorted',
        summary: 'doc.m_dimstyle_table.Sort() potentially changed sort order'
      },
      {
        signature: 'Current',
        summary: 'current dim style change'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'FontTable',
    dataType: 1,
    summary: `Font tables store the list of fonts in a Rhino document.
   The FontTable is now just a wrapper around the DimStyles table.`,
    interfaces: ['IEnumerable<Font>', 'Collections.IRhinoTable<Font>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Number of fonts in the table.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int CurrentIndex',
        summary: `At all times, there is a "current" font.  Unless otherwise specified,
     new dimension objects are assigned to the current font. The current
     font is never deleted.
     Returns: Zero based font index of the current font.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'Document that owns this table.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int FindOrCreate(string face,bool bold,bool italic)',
        summary: `Get a DimensionStyle with the specified characteristics
     the settings other than face, bold and italic are copied from the current style`,
        since: 5
      },
      {
        signature: 'int FindOrCreate(string face,bool bold,bool italic,DimensionStyle template_style)',
        summary: 'Get a DimensionStyle with the specified characteristics',
        since: 6,
        parameters: [
          {
            name: 'face',
            summary: ''
          },
          {
            name: 'bold',
            summary: ''
          },
          {
            name: 'italic',
            summary: ''
          },
          {
            name: 'template_style',
            summary: 'the settings other than face, bold and italic are copied from the template_style'
          }
        ]
      },
      {
        signature: 'IEnumerator<Font> GetEnumerator()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'GroupTable',
    dataType: 1,
    summary: 'Group tables store the list of groups in a Rhino document.',
    baseclass: 'RhinoDocCommonTable<Group>',
    interfaces: ['ICollection<Group>'],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int Add()',
        summary: 'Adds a new empty group to the group table.',
        since: 5,
        returns: `>=0 index of new group. 
       -1 group not added because a group with that name already exists.`
      },
      {
        signature: 'int Add(IEnumerable<Guid> objectIds)',
        summary: 'Adds a new group to the group table with a set of objects.',
        since: 5,
        parameters: [
          {
            name: 'objectIds',
            summary: 'An array, a list or any enumerable set of object IDs.'
          }
        ],
        returns: `>=0 index of new group.
       -1 group not added because a group with that name already exists.`
      },
      {
        signature: 'int Add(string groupName)',
        summary: 'Adds a new empty group to the group table.',
        since: 5,
        parameters: [
          {
            name: 'groupName',
            summary: 'name of new group.'
          }
        ],
        returns: `>=0 index of new group. 
       -1 group not added because a group with that name already exists.`
      },
      {
        signature: 'int Add(string groupName,IEnumerable<Guid> objectIds)',
        summary: 'Adds a new group to the group table with a set of objects.',
        since: 5,
        parameters: [
          {
            name: 'groupName',
            summary: 'Name of new group.'
          },
          {
            name: 'objectIds',
            summary: 'An array, a list or any enumerable set of object IDs.'
          }
        ],
        returns: `>=0 index of new group. 
       -1 group not added because a group with that name already exists.`
      },
      {
        signature: 'bool AddToGroup(int groupIndex,Guid objectId)',
        summary: 'Adds an object to an existing group.',
        since: 5,
        parameters: [
          {
            name: 'groupIndex',
            summary: 'The group index value.'
          },
          {
            name: 'objectId',
            summary: 'An ID of an object.'
          }
        ],
        returns: 'True if the operation was successful.'
      },
      {
        signature: 'bool AddToGroup(int groupIndex,IEnumerable<Guid> objectIds)',
        summary: 'Adds a list of objects to an existing group.',
        since: 5,
        parameters: [
          {
            name: 'groupIndex',
            summary: 'The group index value.'
          },
          {
            name: 'objectIds',
            summary: 'An array, a list or any enumerable set of IDs to objects.'
          }
        ],
        returns: 'True if at least an operation was successful.'
      },
      {
        signature: 'bool ChangeGroupName(int groupIndex,string newName)',
        since: 5
      },
      {
        signature: 'bool Delete(Group item)',
        since: 6
      },
      {
        signature: 'bool Delete(int groupIndex)',
        summary: `Deletes a group from this table.
       Deleted groups are kept in the runtime group table so that undo
       will work with groups.  Call IsDeleted() to determine if a group is deleted.`,
        since: 5,
        parameters: [
          {
            name: 'groupIndex',
            summary: 'An group index to be deleted.'
          }
        ],
        returns: 'True if the operation was successful.'
      },
      {
        signature: 'int Find(string groupName)',
        summary: 'Finds a group with a given name.',
        since: 6,
        parameters: [
          {
            name: 'groupName',
            summary: 'Name of group to search for. Ignores case.'
          }
        ],
        returns: `>=0 index of the group with the given name.
       RhinoMath.UnsetIntIndex no group found with the given name.`
      },
      {
        signature: 'int Find(string groupName,bool ignoreDeletedGroups)',
        summary: 'Finds a group with a given name.',
        since: 5,
        parameters: [
          {
            name: 'groupName',
            summary: 'Name of group to search for. Ignores case.'
          },
          {
            name: 'ignoreDeletedGroups',
            summary: 'This parameter is ignored. Deleted groups are never searched.'
          }
        ],
        returns: `>=0 index of the group with the given name.
       -1 no group found with the given name.`
      },
      {
        signature: 'Group FindIndex(int index)',
        summary: `Retrieves a Group object based on Index. This seach type of search is discouraged.
       We are moving towards using only IDs for all tables.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index to search for.'
          }
        ],
        returns: 'A Group object, or None if none was found.'
      },
      {
        signature: 'Group FindName(string name)',
        summary: 'Finds a Linetype given its name. Returns the instance, rather than the index.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the Linetype to be searched.'
          }
        ],
        returns: 'An Linetype, or None on error.'
      },
      {
        signature: 'Group FindNameHash(NameHash nameHash)',
        summary: 'Finds a Linetype given its name hash.',
        since: 6,
        parameters: [
          {
            name: 'nameHash',
            summary: 'The name hash of the Linetype to be searched.'
          }
        ],
        returns: 'An Linetype, or None on error.'
      },
      {
        signature: 'RhinoObject[] GroupMembers(int groupIndex)',
        summary: 'Gets an array of all of the objects in a group.',
        since: 5,
        parameters: [
          {
            name: 'groupIndex',
            summary: 'The index of the group in this table.'
          }
        ],
        returns: 'An array with all the objects in the specified group.'
      },
      {
        signature: 'string GroupName(int groupIndex)',
        since: 5
      },
      {
        signature: 'string[] GroupNames(bool ignoreDeletedGroups)',
        since: 5
      },
      {
        signature: 'int GroupObjectCount(int groupIndex)',
        since: 5
      },
      {
        signature: 'int Hide(int groupIndex)',
        since: 5
      },
      {
        signature: 'bool IsDeleted(int groupIndex)',
        since: 5
      },
      {
        signature: 'int Lock(int groupIndex)',
        since: 5
      },
      {
        signature: 'int Show(int groupIndex)',
        since: 5
      },
      {
        signature: 'bool Undelete(int groupIndex)',
        since: 5
      },
      {
        signature: 'int Unlock(int groupIndex)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'GroupTableEventArgs',
    dataType: 1,
    summary: 'Contains group table event data.',
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RhinoDoc Document',
        summary: 'The document in which the event occurred.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'GroupTableEventType EventType',
        summary: 'The event type.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int GroupIndex',
        summary: 'The index of the Group that has changed.',
        since: 6.1,
        property: ['get']
      },
      {
        signature: 'Group NewState',
        summary: 'The Group that has changed.',
        since: 6.1,
        property: ['get']
      },
      {
        signature: 'Group OldState',
        summary: 'If the event is GroupTableEventType.Modified, then the old Group.',
        since: 6.1,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'GroupTableEventType',
    dataType: 3,
    summary: 'Defines the types of group table events.',
    values: [
      {
        signature: 'Added = 0',
        summary: 'A group was added.'
      },
      {
        signature: 'Deleted = 1',
        summary: 'A group was deleted.'
      },
      {
        signature: 'Undeleted = 2',
        summary: 'A group was undeleted.'
      },
      {
        signature: 'Modified = 3',
        summary: 'A group was modified.'
      },
      {
        signature: 'Sorted = 4',
        summary: 'The group table was sorted.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'HatchPatternTable',
    dataType: 1,
    summary: 'All of the hatch pattern definitions contained in a rhino document.',
    baseclass: 'RhinoDocCommonTable<HatchPattern>',
    interfaces: ['ICollection<HatchPattern>'],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int CurrentHatchPatternIndex',
        summary: `At all times, there is a "current" hatch pattern.  Unless otherwise
     specified, new objects are assigned to the current hatch pattern.
     The current hatch pattern is never locked, hidden, or deleted.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'int Add(HatchPattern pattern)',
        summary: 'Adds a new hatch pattern with specified definition to the table.',
        since: 5,
        parameters: [
          {
            name: 'pattern',
            summary: `definition of new hatch pattern. The information in pattern is copied.
     If patern.Name is empty the a unique name of the form "HatchPattern 01"
     will be automatically created.`
          }
        ],
        returns: `>=0 index of new hatch pattern
     -1  not added because a hatch pattern with that name already exists or
     some other problem occured.`
      },
      {
        signature: 'bool Delete(HatchPattern item)',
        since: 6
      },
      {
        signature: 'bool Delete(HatchPattern item,bool quiet)',
        since: 6
      },
      {
        signature: 'int Find(string name,bool ignoreDeleted)',
        summary: 'Finds the hatch pattern with a given name. Search ignores case.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the hatch patter to be found.'
          },
          {
            name: 'ignoreDeleted',
            summary: 'True means don\'t search deleted hatch patterns.'
          }
        ],
        returns: 'Index of the hatch pattern with the given name. -1 if no hatch pattern found.'
      },
      {
        signature: 'HatchPattern FindIndex(int index)',
        summary: `Retrieves a HatchPattern object based on Index. This seach type of search is discouraged.
     We are moving towards using only IDs for all tables.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index to search for.'
          }
        ],
        returns: 'A HatchPattern object, or None if none was found.'
      },
      {
        signature: 'HatchPattern FindName(string name)',
        summary: 'Finds the hatch pattern with a given name. Search ignores case.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the hatch patter to be found.'
          }
        ],
        returns: 'Hatch pattern with the given name. Null if no hatch pattern found.'
      },
      {
        signature: 'HatchPattern FindNameHash(NameHash nameHash)',
        summary: 'Finds a HatchPattern given its name hash.',
        since: 6,
        parameters: [
          {
            name: 'nameHash',
            summary: 'The name hash of the HatchPattern to be searched.'
          }
        ],
        returns: 'An Linetype, or None on error.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'InstanceDefinitionTable',
    dataType: 1,
    baseclass: 'RhinoDocCommonTable<InstanceDefinition>',
    properties: [
      {
        signature: 'int ActiveCount',
        summary: 'Number of items in the instance definitions table, excluding deleted definitions.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ModelComponentType ComponentType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int Count',
        summary: 'Number of items in the instance definitions table.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'Document that owns this table.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int Add(string name,string description,Point3d basePoint,GeometryBase geometry,ObjectAttributes attributes)',
        summary: 'Adds an instance definition to the instance definition table.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'The definition name.'
          },
          {
            name: 'description',
            summary: 'The definition description.'
          },
          {
            name: 'basePoint',
            summary: 'A base point.'
          },
          {
            name: 'geometry',
            summary: 'An element.'
          },
          {
            name: 'attributes',
            summary: 'An attribute.'
          }
        ],
        returns: '>=0  index of instance definition in the instance definition table. -1 on failure.'
      },
      {
        signature: 'int Add(string name,string description,Point3d basePoint,IEnumerable<GeometryBase> geometry)',
        summary: 'Adds an instance definition to the instance definition table.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'The definition name.'
          },
          {
            name: 'description',
            summary: 'The definition description.'
          },
          {
            name: 'basePoint',
            summary: 'A base point.'
          },
          {
            name: 'geometry',
            summary: 'An array, a list or any enumerable set of geometry.'
          }
        ],
        returns: '>=0  index of instance definition in the instance definition table. -1 on failure.'
      },
      {
        signature: 'int Add(string name,string description,Point3d basePoint,IEnumerable<GeometryBase> geometry,IEnumerable<ObjectAttributes> attributes)',
        summary: 'Adds an instance definition to the instance definition table.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'The definition name.'
          },
          {
            name: 'description',
            summary: 'The definition description.'
          },
          {
            name: 'basePoint',
            summary: 'A base point.'
          },
          {
            name: 'geometry',
            summary: 'An array, a list or any enumerable set of geometry.'
          },
          {
            name: 'attributes',
            summary: 'An array, a list or any enumerable set of attributes.'
          }
        ],
        returns: '>=0  index of instance definition in the instance definition table. -1 on failure.'
      },
      {
        signature: 'void Compact(bool ignoreUndoReferences)',
        summary: `Purge deleted instance definition information that is not in use.
     This function is time consuming and should be used in a thoughtful manner.`,
        since: 5.9,
        parameters: [
          {
            name: 'ignoreUndoReferences',
            summary: `If false, then deleted instance definition information that could possibly
     be undeleted by the Undo command will not be deleted. If true, then all
     deleted instance definition information is deleted.`
          }
        ]
      },
      {
        signature: 'bool Delete(InstanceDefinition item)',
        summary: 'Deletes the instance definition. This deletes all references too.',
        since: 6,
        parameters: [
          {
            name: 'item',
            summary: 'The item to delete.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'bool Delete(int idefIndex,bool deleteReferences,bool quiet)',
        summary: 'Deletes the instance definition.',
        since: 5,
        parameters: [
          {
            name: 'idefIndex',
            summary: `zero based index of instance definition to delete.
     This must be in the range 0 <= idefIndex < InstanceDefinitionTable.Count.`
          },
          {
            name: 'deleteReferences',
            summary: `True to delete all references to this definition.
     False to delete definition only if there are no references.`
          },
          {
            name: 'quiet',
            summary: `If true, no warning message box appears if an instance definition cannot be
     deleted because it is the current layer or it contains active geometry.`
          }
        ],
        returns: 'True if successful. False if the instance definition has active references and bDeleteReferences is false.'
      },
      {
        signature: 'bool DestroySourceArchive(InstanceDefinition definition,bool quiet)',
        summary: `Destroys all source archive information.
     Specifically:
     * InstanceDefinition.SourceArchive is set to the empty string.
     * SourceRelativePath is set to false
     * The alternative source archive path is set to the empty string.
     * Checksum.Zero() is used to private destroy all checksum information.
     * InstanceDefinition.UpdateType is set to InstanceDefinitionUpdateType.Static.`,
        since: 6,
        parameters: [
          {
            name: 'definition',
            summary: 'The instance definition to be modified.'
          },
          {
            name: 'quiet',
            summary: 'If true, then message boxes about erroneous parameters will not be shown.'
          }
        ],
        returns: 'Returns True if the definition was successfully modified otherwise returns false.'
      },
      {
        signature: 'InstanceDefinition Find(Guid instanceId,bool ignoreDeletedInstanceDefinitions)',
        summary: 'Finds the instance definition with a given id.',
        since: 5,
        parameters: [
          {
            name: 'instanceId',
            summary: 'Unique id of the instance definition to search for.'
          },
          {
            name: 'ignoreDeletedInstanceDefinitions',
            summary: 'True means don\'t search deleted instance definitions.'
          }
        ],
        returns: 'The specified instance definition, or None if nothing matching was found.'
      },
      {
        signature: 'InstanceDefinition Find(string instanceDefinitionName)',
        summary: 'Finds the instance definition with a given name.',
        since: 6,
        parameters: [
          {
            name: 'instanceDefinitionName',
            summary: 'name of instance definition to search for (ignores case)'
          }
        ],
        returns: 'The specified instance definition, or None if nothing matching was found.'
      },
      {
        signature: 'InstanceDefinition Find(string instanceDefinitionName,bool ignoreDeletedInstanceDefinitions)',
        summary: 'Finds the instance definition with a given name.',
        since: 5,
        parameters: [
          {
            name: 'instanceDefinitionName',
            summary: 'name of instance definition to search for (ignores case)'
          },
          {
            name: 'ignoreDeletedInstanceDefinitions',
            summary: 'True means don\'t search deleted instance definitions.'
          }
        ],
        returns: 'The specified instance definition, or None if nothing matching was found.'
      },
      {
        signature: 'IEnumerator<InstanceDefinition> GetEnumerator()',
        since: 5
      },
      {
        signature: 'InstanceDefinition[] GetList(bool ignoreDeleted)',
        summary: 'Gets an array of instance definitions.',
        since: 5,
        parameters: [
          {
            name: 'ignoreDeleted',
            summary: 'If True then deleted idefs are filtered out.'
          }
        ],
        returns: 'An array of instance definitions. This can be empty, but not null.'
      },
      {
        signature: 'string GetUnusedInstanceDefinitionName()',
        summary: `Gets unsed instance definition name used as default when creating
     new instance definitions.`,
        since: 5,
        returns: 'An unused instance definition name string.'
      },
      {
        signature: 'string GetUnusedInstanceDefinitionName(string root)',
        summary: `Gets unsed instance definition name used as default when creating
     new instance definitions.`,
        since: 5,
        parameters: [
          {
            name: 'root',
            summary: 'The returned name is \'root nn\'  If root is empty, then \'Block\' (localized) is used.'
          }
        ],
        returns: 'An unused instance definition name string.'
      },
      {
        signature: 'string GetUnusedInstanceDefinitionName(string root,uint defaultSuffix)',
        summary: `Gets unsed instance definition name used as default when creating
     new instance definitions.`,
        since: 5,
        parameters: [
          {
            name: 'root',
            summary: 'The returned name is \'root nn\'  If root is empty, then \'Block\' (localized) is used.'
          },
          {
            name: 'defaultSuffix',
            summary: `Unique names are created by appending a decimal number to the
     localized term for "Block" as in "Block 01", "Block 02",
     and so on.  When defaultSuffix is supplied, the search for an unused
     name begins at "Block suffix".`
          }
        ],
        returns: 'An unused instance definition name string.'
      },
      {
        signature: 'int InstanceDefinitionIndex(Guid instanceId,bool ignoreDeletedInstanceDefinitions)',
        summary: 'Get the index of the instance definition with a given id.',
        since: 6,
        parameters: [
          {
            name: 'instanceId',
            summary: 'Unique id of the instance definition to search for'
          },
          {
            name: 'ignoreDeletedInstanceDefinitions',
            summary: 'True means don\'t search deleted instance definitions.'
          }
        ],
        returns: 'index > -1 if instance definition was found.'
      },
      {
        signature: 'bool MakeSourcePathRelative(InstanceDefinition idef,bool relative,bool quiet)',
        summary: `Obsolete method that always returns false.
     Marks the source path for a linked instance definition as relative or absolute.`,
        since: 5,
        parameters: [
          {
            name: 'idef',
            summary: 'The instance definition to be marked.'
          },
          {
            name: 'relative',
            summary: 'If true, the path should be considered as relative.If false, the path should be considered as absolute.'
          },
          {
            name: 'quiet',
            summary: 'If true, then message boxes about erroneous parameters will not be shown.'
          }
        ],
        returns: 'True if the instance definition could be modified.'
      },
      {
        signature: 'bool Modify(InstanceDefinition idef,string newName,string newDescription,bool quiet)',
        summary: `Modifies the instance definition name and description.
     Does not change instance definition ID or geometry.`,
        since: 5,
        parameters: [
          {
            name: 'idef',
            summary: 'The instance definition to be modified.'
          },
          {
            name: 'newName',
            summary: 'The new name.'
          },
          {
            name: 'newDescription',
            summary: 'The new description string.'
          },
          {
            name: 'quiet',
            summary: 'If true, information message boxes pop up when illegal changes are attempted.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Modify(int idefIndex,string newName,string newDescription,bool quiet)',
        summary: `Modifies the instance definition name and description.
     Does not change instance definition ID or geometry.`,
        since: 5,
        parameters: [
          {
            name: 'idefIndex',
            summary: 'The index of the instance definition to be modified.'
          },
          {
            name: 'newName',
            summary: 'The new name.'
          },
          {
            name: 'newDescription',
            summary: 'The new description string.'
          },
          {
            name: 'quiet',
            summary: 'If true, information message boxes pop up when illegal changes are attempted.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool ModifyGeometry(int idefIndex,GeometryBase newGeometry,ObjectAttributes newAttributes)',
        since: 5
      },
      {
        signature: 'bool ModifyGeometry(int idefIndex,IEnumerable<GeometryBase> newGeometry)',
        since: 5
      },
      {
        signature: 'bool ModifyGeometry(int idefIndex,IEnumerable<GeometryBase> newGeometry,IEnumerable<ObjectAttributes> newAttributes)',
        summary: `Modifies the instance definition geometry and replaces all references
     to the current definition with references to the new definition.`,
        since: 5,
        parameters: [
          {
            name: 'idefIndex',
            summary: 'The index of the instance definition to be modified.'
          },
          {
            name: 'newGeometry',
            summary: 'The new geometry.'
          },
          {
            name: 'newAttributes',
            summary: 'The new attributes.'
          }
        ],
        returns: 'True if operation succeeded.'
      },
      {
        signature: 'bool ModifySourceArchive(int idefIndex,FileReference sourceArchive,InstanceDefinitionUpdateType updateType,bool quiet)',
        summary: `If the instance definition is linked or embedded, use SetSource to
     specify the source archive.`,
        since: 6,
        parameters: [
          {
            name: 'idefIndex',
            summary: 'The index of the instance definition to be modified.'
          },
          {
            name: 'sourceArchive',
            summary: 'The new source archive file name.'
          },
          {
            name: 'updateType',
            summary: ''
          },
          {
            name: 'quiet',
            summary: 'If true, then message boxes about erroneous parameters will not be shown.'
          }
        ],
        returns: 'Returns True if the definition was successfully modified otherwise returns false.'
      },
      {
        signature: 'bool ModifySourceArchive(int idefIndex,string sourceArchive,InstanceDefinitionUpdateType updateType,bool quiet)',
        summary: `If the instance definition is linked or embedded, use SetSource to
     specify the source archive.`,
        since: 6,
        parameters: [
          {
            name: 'idefIndex',
            summary: 'The index of the instance definition to be modified.'
          },
          {
            name: 'sourceArchive',
            summary: 'The new source archive file name.'
          },
          {
            name: 'updateType',
            summary: ''
          },
          {
            name: 'quiet',
            summary: 'If true, then message boxes about erroneous parameters will not be shown.'
          }
        ],
        returns: 'Returns True if the definition was successfully modified otherwise returns false.'
      },
      {
        signature: 'bool Purge(int idefIndex)',
        summary: 'Purges an instance definition and its definition geometry.',
        since: 5.9,
        parameters: [
          {
            name: 'idefIndex',
            summary: `zero based index of instance definition to delete.
     This must be in the range 0 <= idefIndex < InstanceDefinitionTable.Count.`
          }
        ],
        returns: `True if successful. False if the instance definition cannot be purged
     because it is in use by reference objects or undo information.`
      },
      {
        signature: 'bool RefreshLinkedBlock(InstanceDefinition definition)',
        summary: 'Reload linked block definitions and update the Rhino display.',
        since: 6,
        parameters: [
          {
            name: 'definition',
            summary: 'Instance definition to reload.'
          }
        ],
        returns: 'Returns True if the linked file was successfully read and updated.'
      },
      {
        signature: 'bool Undelete(int idefIndex)',
        summary: 'Undeletes an instance definition that has been deleted by Delete()',
        since: 5.9,
        parameters: [
          {
            name: 'idefIndex',
            summary: `zero based index of instance definition to delete.
     This must be in the range 0 <= idefIndex < InstanceDefinitionTable.Count.`
          }
        ],
        returns: 'True if successful'
      },
      {
        signature: 'bool UndoModify(int idefIndex)',
        summary: `Restores the instance definition to its previous state,
     if the instance definition has been modified and the modification can be undone.`,
        since: 5,
        parameters: [
          {
            name: 'idefIndex',
            summary: 'The index of the instance definition to be restored.'
          }
        ],
        returns: 'True if operation succeeded.'
      },
      {
        signature: 'bool UpdateLinkedInstanceDefinition(int idefIndex,string filename,bool updateNestedLinks,bool quiet)',
        summary: 'Read the objects from a file and use them as the instance\'s definition geometry.',
        since: 5.9,
        parameters: [
          {
            name: 'idefIndex',
            summary: `zero based index of instance definition to delete.
     This must be in the range 0 <= idefIndex < InstanceDefinitionTable.Count.`
          },
          {
            name: 'filename',
            summary: 'name of file (can be any type of file that Rhino or a plug-in can read)'
          },
          {
            name: 'updateNestedLinks',
            summary: `If True and the instance definition referes to a linked instance definition,
     that needs to be updated, then the nested defition is also updated. If
     false, nested updates are skipped.`
          },
          {
            name: 'quiet',
            summary: ''
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'InstanceDefinitionTableEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RhinoDoc Document',
        since: 5.3,
        property: ['get']
      },
      {
        signature: 'InstanceDefinitionTableEventType EventType',
        since: 5.3,
        property: ['get']
      },
      {
        signature: 'int InstanceDefinitionIndex',
        since: 5.3,
        property: ['get']
      },
      {
        signature: 'InstanceDefinition NewState',
        since: 5.3,
        property: ['get']
      },
      {
        signature: 'InstanceDefinitionGeometry OldState',
        since: 5.3,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'InstanceDefinitionTableEventType',
    dataType: 3,
    values: [
      {
        signature: 'Added = 0'
      },
      {
        signature: 'Deleted = 1'
      },
      {
        signature: 'Undeleted = 2'
      },
      {
        signature: 'Modified = 3'
      },
      {
        signature: 'Sorted = 4',
        summary: 'InstanceDefinitionTable.Sort() potentially changed sort order.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'LayerTable',
    dataType: 1,
    baseclass: 'RhinoDocCommonTable<Layer>',
    interfaces: ['ICollection<Layer>'],
    properties: [
      {
        signature: 'int ActiveCount',
        summary: 'Returns number of layers in the layer table, excluding deleted layers.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ModelComponentType ComponentType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int Count',
        summary: 'Returns number of layers in the layer table, including deleted layers.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Layer CurrentLayer',
        summary: `At all times, there is a "current" layer. Unless otherwise specified,
     new objects are assigned to the current layer. The current layer is
     never locked, hidden, or deleted.
     
     Returns reference to the current layer. Note that this reference may
     become invalid after a call to AddLayer().`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'int CurrentLayerIndex',
        summary: `At all times, there is a "current" layer.  Unless otherwise specified, new objects
     are assigned to the current layer. The current layer is never locked, hidden, or deleted.
     Resturns: Zero based layer table index of the current layer.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'Document that owns this table.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int Add()',
        summary: 'Adds a new layer with default definition to the layer table.',
        since: 5,
        returns: 'index of new layer.'
      },
      {
        signature: 'int Add(Layer layer)',
        summary: 'Adds a new layer with specified definition to the layer table.',
        since: 5,
        parameters: [
          {
            name: 'layer',
            summary: `definition of new layer. The information in layer is copied. If layer.Name is empty
     the a unique name of the form "Layer 01" will be automatically created.`
          }
        ],
        returns: `>=0 index of new layer
     -1  layer not added because a layer with that name already exists.`
      },
      {
        signature: 'int Add(string layerName,Color layerColor)',
        summary: 'Adds a new layer with specified definition to the layer table.',
        since: 5,
        parameters: [
          {
            name: 'layerName',
            summary: 'Name for new layer. Cannot be a None or zero-length string.'
          },
          {
            name: 'layerColor',
            summary: 'Color of new layer. Alpha components will be ignored.'
          }
        ],
        returns: `>=0 index of new layer
     -1  layer not added because a layer with that name already exists.`
      },
      {
        signature: 'int AddReferenceLayer()',
        summary: `Adds a new reference layer with default definition to the layer table.
     Reference layers are not saved in files.`,
        since: 5,
        returns: 'index of new layer.'
      },
      {
        signature: 'int AddReferenceLayer(Layer layer)',
        summary: `Adds a new reference layer with specified definition to the layer table
     Reference layers are not saved in files.`,
        since: 5,
        parameters: [
          {
            name: 'layer',
            summary: `definition of new layer. The information in layer is copied. If layer.Name is empty
     the a unique name of the form "Layer 01" will be automatically created.`
          }
        ],
        returns: `>=0 index of new layer
     -1  layer not added because a layer with that name already exists.`
      },
      {
        signature: 'bool Delete(Guid layerId,bool quiet)',
        summary: 'Deletes layer.',
        since: 6,
        parameters: [
          {
            name: 'layerId',
            summary: 'Id of the layer to be deleted.'
          },
          {
            name: 'quiet',
            summary: `If true, no warning message box appears if a layer the layer cannot be
     deleted because it is the current layer or it contains active geometry.`
          }
        ],
        returns: `True if successful. False if layerIndex is out of range or the the layer cannot be
     deleted because it is the current layer or because it layer contains active geometry.`
      },
      {
        signature: 'bool Delete(int layerIndex,bool quiet)',
        summary: 'Deletes layer.',
        since: 5,
        parameters: [
          {
            name: 'layerIndex',
            summary: 'zero based index of layer to delete. This must be in the range 0 <= layerIndex < LayerTable.Count.'
          },
          {
            name: 'quiet',
            summary: `If true, no warning message box appears if a layer the layer cannot be
     deleted because it is the current layer or it contains active geometry.`
          }
        ],
        returns: `True if successful. False if layerIndex is out of range or the the layer cannot be
     deleted because it is the current layer or because it layer contains active geometry.`
      },
      {
        signature: 'bool Delete(Layer layer)',
        summary: 'Deletes layer.',
        since: 6,
        parameters: [
          {
            name: 'layer',
            summary: 'Layer to be deleted.'
          }
        ],
        returns: `True if successful. False if layerIndex is out of range or the the layer cannot be
     deleted because it is the current layer or because it layer contains active geometry.`
      },
      {
        signature: 'bool Delete(Layer layer,bool quiet)',
        summary: 'Deletes layer.',
        since: 6,
        parameters: [
          {
            name: 'layer',
            summary: 'Layer to be deleted.'
          },
          {
            name: 'quiet',
            summary: `If true, no warning message box appears if a layer the layer cannot be
     deleted because it is the current layer or it contains active geometry.`
          }
        ],
        returns: `True if successful. False if layerIndex is out of range or the the layer cannot be
     deleted because it is the current layer or because it layer contains active geometry.`
      },
      {
        signature: 'int[] Duplicate(IEnumerable<int> layerIndices,bool duplicateObjects,bool duplicateSublayers)',
        summary: 'Duplicates, or copies, one or more layers. Duplicated layers are added to the document.',
        since: 6.18,
        parameters: [
          {
            name: 'layerIndices',
            summary: 'The indices of layers to duplicate.'
          },
          {
            name: 'duplicateObjects',
            summary: 'If true, then layer objects will also be duplicated and added to the document.'
          },
          {
            name: 'duplicateSublayers',
            summary: 'If true, then all sublayers of the layer will be duplicated.'
          }
        ],
        returns: 'The indices of the newly added layers if successful, an empty array on failure.'
      },
      {
        signature: 'int[] Duplicate(int layerIndex,bool duplicateObjects,bool duplicateSublayers)',
        summary: 'Duplicates, or copies, a layer. Duplicated layers are added to the document.',
        since: 6.18,
        parameters: [
          {
            name: 'layerIndex',
            summary: 'The index of the layer to duplicate.'
          },
          {
            name: 'duplicateObjects',
            summary: 'If true, then layer objects will also be duplicated and added to the document.'
          },
          {
            name: 'duplicateSublayers',
            summary: 'If true, then all sublayers of the layer will be duplicated.'
          }
        ],
        returns: 'The indices of the newly added layers if successful, an empty array on failure.'
      },
      {
        signature: 'int Find(Guid layerId,bool ignoreDeletedLayers)',
        summary: 'Finds a layer with a matching ID.',
        since: 5,
        parameters: [
          {
            name: 'layerId',
            summary: 'A valid layer ID.'
          },
          {
            name: 'ignoreDeletedLayers',
            summary: 'If true, deleted layers are not checked.'
          }
        ],
        returns: `>=0 index of the layer with the given name
     -1  no layer has the given name.`
      },
      {
        signature: 'int Find(Guid layerId,bool ignoreDeletedLayers,int notFoundReturnValue)',
        summary: 'Finds a layer with a matching ID.',
        since: 6,
        parameters: [
          {
            name: 'layerId',
            summary: 'A valid layer ID.'
          },
          {
            name: 'ignoreDeletedLayers',
            summary: 'If true, deleted layers are not checked.'
          },
          {
            name: 'notFoundReturnValue',
            summary: `Should be -1 to get the index of the OpenNURBS default layer,
     or RhinoMath.UnsetIntIndex to get an always-out-of-bound value.`
          }
        ],
        returns: 'The index of the found layer, or notFoundReturnValue.'
      },
      {
        signature: 'int Find(Guid parentId,string layerName,bool ignoreDeletedLayers)',
        summary: 'Finds a layer with a given name and matching parent ID.',
        since: 6,
        parameters: [
          {
            name: 'parentId',
            summary: 'A valid layer ID.'
          },
          {
            name: 'layerName',
            summary: 'name of layer to search for. The search ignores case.'
          },
          {
            name: 'ignoreDeletedLayers',
            summary: 'If true, deleted layers are not checked. NOT SUPPORTED FOR NAME SEARCH, only for Guids.'
          }
        ],
        returns: `>=0 index of the layer with the given name
     -1  no layer has the given name.`
      },
      {
        signature: 'int Find(Guid parentId,string layerName,int notFoundReturnValue)',
        summary: 'Finds a layer with a given name and matching parent ID.',
        since: 6,
        parameters: [
          {
            name: 'parentId',
            summary: 'A valid layer ID.'
          },
          {
            name: 'layerName',
            summary: 'name of layer to search for. The search ignores case.'
          },
          {
            name: 'notFoundReturnValue',
            summary: `Should be -1 to get the index of the OpenNURBS default layer,
     or RhinoMath.UnsetIntIndex to get an always-out-of-bound value.`
          }
        ],
        returns: 'The index of the found layer, or notFoundReturnValue.'
      },
      {
        signature: 'int Find(string layerName,bool ignoreDeletedLayers)',
        summary: `Finds the layer with a given name. If multiple layers exist that have the same name, the
     first match layer index will be returned.
     Deleted layers have no name.`,
        since: 5,
        parameters: [
          {
            name: 'layerName',
            summary: 'name of layer to search for. The search ignores case.'
          },
          {
            name: 'ignoreDeletedLayers',
            summary: 'True means don\'t search deleted layers.'
          }
        ],
        returns: `index of the layer with the given name.
     If no layer is found, the index of the default layer, -1, is returned.`
      },
      {
        signature: 'int FindByFullPath(string layerPath,bool ignoreDeletedLayers)',
        since: 5
      },
      {
        signature: 'int FindByFullPath(string layerPath,int notFoundReturnValue)',
        summary: `Searches for a layer using the fully qualified name, that includes ancestors.
     Deleted layers have no name.`,
        since: 6,
        parameters: [
          {
            name: 'layerPath',
            summary: 'The full layer name.'
          },
          {
            name: 'notFoundReturnValue',
            summary: `Should be -1 to get the index of the OpenNURBS default layer,
     or RhinoMath.UnsetIntIndex to get an always-out-of-bound value.`
          }
        ],
        returns: 'The index of the found layer, or notFoundReturnValue.'
      },
      {
        signature: 'Layer FindIndex(int index)',
        summary: `Retrieves a Layer object based on Index. This seach type of search is discouraged.
     We are moving towards using only IDs for all tables.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index to search for.'
          }
        ],
        returns: 'A Layer object, or None if none was found.'
      },
      {
        signature: 'Layer FindName(string layerName)',
        summary: `Finds the layer with a given name. If multiple layers exist that have the same name, the
     first match layer index will be returned.
     Deleted layers have no name.The default layer is NOT included in the search. If required, use the overload with startIndex input.`,
        since: 6,
        parameters: [
          {
            name: 'layerName',
            summary: 'name of layer to search for. The search ignores case.'
          }
        ],
        returns: 'A layer, or null.'
      },
      {
        signature: 'Layer FindName(string layerName,int startIndex)',
        summary: `Finds the next layer that has an index equal or higher than the searched value.
     Search in case-insensitive.`,
        since: 6,
        parameters: [
          {
            name: 'layerName',
            summary: 'The layer to search for.'
          },
          {
            name: 'startIndex',
            summary: `If you specify RhinoMath.UnsetIntIndex, then also default layers will be included.
     This is the first index that will be tested.`
          }
        ],
        returns: 'A layer, or null.'
      },
      {
        signature: 'Layer FindNameHash(NameHash nameHash)',
        summary: 'Finds a Layer given its name hash.',
        since: 6,
        parameters: [
          {
            name: 'nameHash',
            summary: 'The name hash of the Layer to be searched.'
          }
        ],
        returns: 'An Layer, or None on error.'
      },
      {
        signature: 'Layer FindNext(int index,string layerName)',
        summary: 'Use FindName(name, index).',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'Do not use.'
          },
          {
            name: 'layerName',
            summary: 'Do not use.'
          }
        ],
        returns: 'Do not use.'
      },
      {
        signature: 'int FindNext(int index,string layerName,bool ignoreDeletedLayers)',
        since: 5
      },
      {
        signature: 'bool ForceLayerVisible(Guid layerId)',
        summary: 'Makes a layer and all of its parent layers visible.',
        since: 5,
        parameters: [
          {
            name: 'layerId',
            summary: 'The layer ID to be made visible.'
          }
        ],
        returns: 'True if the operation succeeded.'
      },
      {
        signature: 'bool ForceLayerVisible(int layerIndex)',
        summary: 'Makes a layer and all of its parent layers visible.',
        since: 5,
        parameters: [
          {
            name: 'layerIndex',
            summary: 'The layer index to be made visible.'
          }
        ],
        returns: 'True if the operation succeeded.'
      },
      {
        signature: 'IEnumerator<Layer> GetEnumerator()',
        since: 5
      },
      {
        signature: 'bool GetSelected(List<int> layerIndices)',
        summary: 'Returns the indices of layers that are selected on the Layer user interface.',
        parameters: [
          {
            name: 'layerIndices',
            summary: 'The indices of selected layers.'
          }
        ],
        returns: 'True if the layer user inteface is visible, False otherwise.'
      },
      {
        signature: 'string GetUnusedLayerName()',
        summary: 'Gets the next unused layer name used as default when creating new layers.',
        since: 6,
        returns: 'An unused layer name string.'
      },
      {
        signature: 'string GetUnusedLayerName(bool ignoreDeleted)',
        summary: 'Gets the next unused layer name used as default when creating new layers.',
        since: 5,
        parameters: [
          {
            name: 'ignoreDeleted',
            summary: 'If this is True then Rhino may use a name used by a deleted layer.'
          }
        ],
        returns: 'An unused layer name string.'
      },
      {
        signature: 'bool Modify(Layer newSettings,Guid layerId,bool quiet)',
        summary: 'Modifies layer settings.',
        since: 6,
        parameters: [
          {
            name: 'newSettings',
            summary: 'This information is copied.'
          },
          {
            name: 'layerId',
            summary: 'Id of layer.'
          },
          {
            name: 'quiet',
            summary: 'if false, information message boxes pop up when illegal changes are attempted.'
          }
        ],
        returns: `True if successful. False if layerIndex is out of range or the settings attempt
     to lock or hide the current layer.`
      },
      {
        signature: 'bool Modify(Layer newSettings,int layerIndex,bool quiet)',
        summary: 'Modifies layer settings.',
        since: 5,
        parameters: [
          {
            name: 'newSettings',
            summary: 'This information is copied.'
          },
          {
            name: 'layerIndex',
            summary: 'zero based index of layer to set.  This must be in the range 0 <= layerIndex < LayerTable.Count.'
          },
          {
            name: 'quiet',
            summary: 'if false, information message boxes pop up when illegal changes are attempted.'
          }
        ],
        returns: `True if successful. False if layerIndex is out of range or the settings attempt
     to lock or hide the current layer.`
      },
      {
        signature: 'bool Purge(Guid layerId,bool quiet)',
        summary: 'Deletes a layer and all geometry objects on a layer.',
        since: 6,
        parameters: [
          {
            name: 'layerId',
            summary: 'Id of the layer to purge.'
          },
          {
            name: 'quiet',
            summary: `If true, no warning message box appears if a layer the layer cannot be
     deleted because it is the current layer.`
          }
        ],
        returns: `True if successful. False if layerIndex is out of range or the the layer cannot be
     deleted because it is the current layer.`
      },
      {
        signature: 'bool Purge(int layerIndex,bool quiet)',
        summary: 'Deletes a layer and all geometry objects on a layer',
        since: 5.5,
        parameters: [
          {
            name: 'layerIndex',
            summary: 'zero based index of layer to delete. This must be in the range 0 <= layerIndex < LayerTable.Count.'
          },
          {
            name: 'quiet',
            summary: `If true, no warning message box appears if a layer the layer cannot be
     deleted because it is the current layer.`
          }
        ],
        returns: `True if successful. False if layerIndex is out of range or the the layer cannot be
     deleted because it is the current layer.`
      },
      {
        signature: 'bool Select(IEnumerable<int> layerIndices,bool bDeselect)',
        summary: 'Selects layers in the Layer user interface.',
        since: 6,
        parameters: [
          {
            name: 'layerIndices',
            summary: 'The indices of layers to select.'
          },
          {
            name: 'bDeselect',
            summary: 'If true, then any previously selected layers will be unselected.'
          }
        ],
        returns: 'True if the layer user inteface is visible, False otherwise.'
      },
      {
        signature: 'bool SetCurrentLayerIndex(int layerIndex,bool quiet)',
        summary: `At all times, there is a "current" layer. Unless otherwise specified, new objects
     are assigned to the current layer. The current layer is never locked, hidden, or deleted.`,
        since: 5,
        parameters: [
          {
            name: 'layerIndex',
            summary: `Value for new current layer. 0 <= layerIndex < LayerTable.Count.
     The layer's mode is automatically set to NormalMode.`
          },
          {
            name: 'quiet',
            summary: 'if true, then no warning message box pops up if the current layer request can\'t be satisfied.'
          }
        ],
        returns: 'True if current layer index successfully set.'
      },
      {
        signature: 'bool Undelete(int layerIndex)',
        summary: 'Undeletes a layer that has been deleted by DeleteLayer().',
        since: 5,
        parameters: [
          {
            name: 'layerIndex',
            summary: `zero based index of layer to undelete.
     This must be in the range 0 <= layerIndex < LayerTable.Count.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool UndoModify(Guid layerId)',
        summary: `Restores the layer to its previous state,
     if the layer has been modified and the modification can be undone.`,
        since: 6,
        parameters: [
          {
            name: 'layerId',
            summary: 'The layer Id to be used.'
          }
        ],
        returns: 'True if this layer had been modified and the modifications were undone.'
      },
      {
        signature: 'bool UndoModify(Guid layerId,uint undoRecordSerialNumber)',
        summary: `Restores the layer to its previous state,
     if the layer has been modified and the modification can be undone.`,
        since: 6,
        parameters: [
          {
            name: 'layerId',
            summary: 'The layer Id to be used.'
          },
          {
            name: 'undoRecordSerialNumber',
            summary: 'The undo record serial number. Pass 0 not to specify one.'
          }
        ],
        returns: 'True if this layer had been modified and the modifications were undone.'
      },
      {
        signature: 'bool UndoModify(int layerIndex)',
        summary: `Restores the layer to its previous state,
     if the layer has been modified and the modification can be undone.`,
        since: 5,
        parameters: [
          {
            name: 'layerIndex',
            summary: 'The layer index to be used.'
          }
        ],
        returns: 'True if this layer had been modified and the modifications were undone.'
      },
      {
        signature: 'bool UndoModify(int layerIndex,uint undoRecordSerialNumber)',
        summary: `Restores the layer to its previous state,
     if the layer has been modified and the modification can be undone.`,
        since: 5,
        parameters: [
          {
            name: 'layerIndex',
            summary: 'The layer index to be used.'
          },
          {
            name: 'undoRecordSerialNumber',
            summary: 'The undo record serial number. Pass 0 not to specify one.'
          }
        ],
        returns: 'True if this layer had been modified and the modifications were undone.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'LayerTableEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RhinoDoc Document',
        since: 5,
        property: ['get']
      },
      {
        signature: 'LayerTableEventType EventType',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int LayerIndex',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Layer NewState',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Layer OldState',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'LayerTableEventType',
    dataType: 3,
    values: [
      {
        signature: 'Added = 0'
      },
      {
        signature: 'Deleted = 1'
      },
      {
        signature: 'Undeleted = 2'
      },
      {
        signature: 'Modified = 3'
      },
      {
        signature: 'Sorted = 4',
        summary: 'LayerTable.Sort() potentially changed sort order.'
      },
      {
        signature: 'Current = 5',
        summary: 'Current layer change.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'LightTable',
    dataType: 1,
    baseclass: 'RhinoDocCommonTable<LightObject>',
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int Count',
        summary: 'Number of lights in the light table.  Does not include Sun or Skylight.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'Document that owns this light table.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Skylight Skylight',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Sun Sun',
        summary: `Gets the Sun instance that is applied to the document.
     If the RDK is loaded, an instance is always returned.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int Add(Light light)',
        since: 5
      },
      {
        signature: 'int Add(Light light,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'bool Delete(int index,bool quiet)',
        since: 6
      },
      {
        signature: 'bool Delete(LightObject item)',
        since: 6
      },
      {
        signature: 'int Find(Guid id,bool ignoreDeleted)',
        since: 5
      },
      {
        signature: 'LightObject FindIndex(int index)',
        summary: `Retrieves a  object based on Index. This seach type of search is discouraged.
     We are moving towards using only IDs for all tables.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index to search for.'
          }
        ],
        returns: 'A  object, or None if none was found.'
      },
      {
        signature: 'LightObject FindName(string name)',
        summary: `Finds the LightObject with a given name.
     Deleted lights have no name.`,
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'Name to search.'
          }
        ],
        returns: 'A layer. If no layer is found, None is returned.'
      },
      {
        signature: 'LightObject FindNameHash(NameHash nameHash)',
        summary: 'Finds a LightObject given its name hash.',
        since: 6,
        parameters: [
          {
            name: 'nameHash',
            summary: 'The name hash of the LightObject to be searched.'
          }
        ],
        returns: 'A LightObject, or None on error.'
      },
      {
        signature: 'IEnumerator<LightObject> GetEnumerator()',
        since: 5
      },
      {
        signature: 'bool Modify(Guid id,Light light)',
        since: 5
      },
      {
        signature: 'bool Modify(int index,Light light)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'LightTableEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RhinoDoc Document',
        since: 5.3,
        property: ['get']
      },
      {
        signature: 'LightTableEventType EventType',
        since: 5.3,
        property: ['get']
      },
      {
        signature: 'int LightIndex',
        since: 5.3,
        property: ['get']
      },
      {
        signature: 'LightObject NewState',
        since: 5.3,
        property: ['get']
      },
      {
        signature: 'Light OldState',
        since: 5.3,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'LightTableEventType',
    dataType: 3,
    values: [
      {
        signature: 'Added = 0'
      },
      {
        signature: 'Deleted = 1'
      },
      {
        signature: 'Undeleted = 2'
      },
      {
        signature: 'Modified = 3'
      },
      {
        signature: 'Sorted = 4',
        summary: 'LightTable.Sort() potentially changed sort order.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'LinetypeTable',
    dataType: 1,
    baseclass: 'RhinoDocCommonTable<Linetype>',
    interfaces: ['ICollection<Linetype>'],
    properties: [
      {
        signature: 'int ActiveCount',
        summary: 'Returns number of linetypes in the linetypes table, excluding deleted linetypes.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string ByLayerLinetypeName',
        summary: 'Returns the text name of the bylayer linetype.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string ByParentLinetypeName',
        summary: 'Returns the text name of the byparent linetype.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'ModelComponentType ComponentType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string ContinuousLinetypeName',
        summary: 'Returns the text name of the continuous linetype.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Count',
        summary: 'Returns number of linetypes in the linetypes table, including deleted linetypes.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Linetype CurrentLinetype',
        summary: `Returns reference to the current linetype. Note that this reference may
     become invalid after a call to AddLinetype().`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'int CurrentLinetypeIndex',
        summary: `At all times, there is a "current" linetype.  Unless otherwise specified,
     new objects are assigned to the current linetype. If the current linetype
     source is LinetypeFromLayer the object's layer's linetype is used instead.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'ObjectLinetypeSource CurrentLinetypeSource',
        summary: 'Source used by an object to determine its current linetype to be used by new objects.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'Document that owns this table.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double LinetypeScale',
        summary: `For display in Rhino viewports, the linetypes are scaled by a single scale
     factor for all viewports. This is not used for printing, where all linetype
     patterns are scaled to print in their defined size 1:1 on the paper.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'int Add(Linetype linetype)',
        summary: 'Adds a new linetype with specified definition to the linetype table.',
        since: 5,
        parameters: [
          {
            name: 'linetype',
            summary: `Definition of new linetype.  The information in linetype is copied.
     If linetype.Name is empty then a unique name of the form "Linetype 01"
     will be automatically created.`
          }
        ],
        returns: 'Index of newline type or -1 on error.'
      },
      {
        signature: 'int Add(string name,IEnumerable<double> segmentLengths)',
        summary: 'Adds a new linetype with specified definition to the linetype table.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'A name for the new linetype.'
          },
          {
            name: 'segmentLengths',
            summary: 'Positive values are dashes, negative values are gaps.'
          }
        ],
        returns: 'Index of new linetype or -1 on error.'
      },
      {
        signature: 'int AddReferenceLinetype(Linetype linetype)',
        summary: 'Adds a reference linetypes that will not be saved in files.',
        since: 5,
        parameters: [
          {
            name: 'linetype',
            summary: `Definition of new linetype.  The information in linetype is copied.
     If linetype.Name is empty then a unique name of the form "Linetype 01"
     will be automatically created.`
          }
        ],
        returns: 'Index of new linetype or -1 on error.'
      },
      {
        signature: 'bool Delete(IEnumerable<int> indices,bool quiet)',
        summary: 'Deletes multiple linetypes.',
        since: 5,
        parameters: [
          {
            name: 'indices',
            summary: 'An array, a list or any enumerable instance of linetype indices.'
          },
          {
            name: 'quiet',
            summary: `If true, no warning message box appears if a linetype the
     linetype cannot be deleted because it is the current linetype
     or it contains active geometry.`
          }
        ],
        returns: 'True if operation succeeded.'
      },
      {
        signature: 'bool Delete(int index,bool quiet)',
        summary: 'Deletes linetype.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'zero based index of linetype to delete.'
          },
          {
            name: 'quiet',
            summary: `If true, no warning message box appears if a linetype the
     linetype cannot be deleted because it is the current linetype
     or it contains active geometry.`
          }
        ],
        returns: `True if successful. False if linetypeIndex is out of range or the
     linetype cannot be deleted because it is the current linetype or
     because it linetype is referenced by active geometry.`
      },
      {
        signature: 'bool Delete(Linetype item)',
        since: 6
      },
      {
        signature: 'int Find(Guid id,bool ignoreDeletedLinetypes)',
        summary: 'Finds a linetype with a matching ID.',
        since: 5,
        parameters: [
          {
            name: 'id',
            summary: 'The ID of the line type to be found.'
          },
          {
            name: 'ignoreDeletedLinetypes',
            summary: 'If true, deleted linetypes are not checked.'
          }
        ],
        returns: `Zero or a positive value if the index of the linetype with the given ID is found.
     -1 if no linetype has the given ID.`
      },
      {
        signature: 'int Find(string name)',
        summary: 'Finds the linetype with a given name.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'search ignores case.'
          }
        ],
        returns: `>=0 index of the linetype with the given name
     -1  no linetype has the given name.`
      },
      {
        signature: 'int Find(string name,bool ignoreDeletedLinetypes)',
        summary: 'Obsolete. Use the other overload.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'search ignores case.'
          },
          {
            name: 'ignoreDeletedLinetypes',
            summary: 'If true, deleted linetypes are not checked.'
          }
        ],
        returns: `>=0 index of the linetype with the given name
     -1  no linetype has the given name.`
      },
      {
        signature: 'Linetype FindIndex(int index)',
        summary: `Retrieves a Linetype object based on Index. This seach type of search is discouraged.
     We are moving towards using only IDs for all tables.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index to search for.'
          }
        ],
        returns: 'A Linetype object, or None if none was found.'
      },
      {
        signature: 'Linetype FindName(string name)',
        summary: 'Finds the linetype with a given name.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'The name.'
          }
        ],
        returns: 'A linetype, or None if the name does not exist.'
      },
      {
        signature: 'IEnumerator<Linetype> GetEnumerator()',
        since: 5
      },
      {
        signature: 'string GetUnusedLinetypeName()',
        summary: 'Gets unused linetype name used as default when creating new linetypes.',
        since: 6,
        returns: 'The unused linetype name.'
      },
      {
        signature: 'string GetUnusedLinetypeName(bool ignoreDeleted)',
        summary: 'Obsolete. Use the other overload. Gets unused linetype name used as default when creating new linetypes.',
        since: 5,
        parameters: [
          {
            name: 'ignoreDeleted',
            summary: 'If this is True then a name used by a deleted linetype is allowed.'
          }
        ],
        returns: 'The unused linetype name.'
      },
      {
        signature: 'int LinetypeIndexForObject(RhinoObject rhinoObject)',
        summary: `Returns the effective linetype index to be used to find the 
     linetype definition to draw an object. If an object's linetype
     source is LinetypeFromObject, the linetype index in the object's
     attributes is used. If an object's linetype source is LinetypeFromLayer
     the linetype index from the object's layer is used.`,
        since: 5,
        parameters: [
          {
            name: 'rhinoObject',
            summary: 'The Rhino object to use in the query.'
          }
        ],
        returns: 'The effective linetype index.'
      },
      {
        signature: 'int LoadDefaultLinetypes()',
        summary: 'Fills in the linetype table with any default linetypes not already included.',
        since: 6,
        returns: 'The number of default linetypes added to the linetype table.'
      },
      {
        signature: 'bool Modify(Linetype linetype,int index,bool quiet)',
        summary: 'Modify linetype settings.',
        since: 5,
        parameters: [
          {
            name: 'linetype',
            summary: 'New linetype settings. This information is copied.'
          },
          {
            name: 'index',
            summary: 'Zero based index of linetype to set.'
          },
          {
            name: 'quiet',
            summary: 'if true, information message boxes pop up when illegal changes are attempted.'
          }
        ],
        returns: `True if successful. False if linetype_index is out of range or the
     settings attempt to lock or hide the current linetype.`
      },
      {
        signature: 'bool SetCurrentLinetypeIndex(int linetypeIndex,bool quiet)',
        summary: `At all times, there is a "current" linetype. Unless otherwise specified, new objects
     are assigned to the current linetype. The current linetype is never deleted.`,
        since: 5,
        parameters: [
          {
            name: 'linetypeIndex',
            summary: 'Value for new current linetype. 0 <= linetypeIndex < LinetypeTable.Count.'
          },
          {
            name: 'quiet',
            summary: 'if true, then no warning message box pops up if the current linetype request can\'t be satisfied.'
          }
        ],
        returns: 'True if current linetype index successfully set.'
      },
      {
        signature: 'bool Undelete(int index)',
        summary: 'Restores a linetype that has been deleted.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'A linetype index to be undeleted.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool UndoModify(int index)',
        summary: `If the linetype has been modified and the modifcation can be undone,
     then UndoModify() will restore the linetype to its previous state.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Zero based index of linetype for which to undo changes.'
          }
        ],
        returns: 'True if this linetype had been modified and the modifications were undone.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'MaterialTable',
    dataType: 1,
    baseclass: 'RhinoDocCommonTable<Material>',
    interfaces: ['ICollection<Material>'],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int CurrentMaterialIndex',
        summary: `At all times, there is a "current" material.  Unless otherwise
     specified, new objects are assigned to the current material.
     The current material is never locked, hidden, or deleted.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ObjectMaterialSource CurrentMaterialSource',
        summary: 'Gets or sets the current material source.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'int Add()',
        summary: 'Adds a new material to the table based on the default material.',
        since: 5,
        returns: 'The position of the new material in the table.'
      },
      {
        signature: 'int Add(Material material)',
        summary: 'Adds a new material to the table based on a given material.',
        since: 5,
        parameters: [
          {
            name: 'material',
            summary: 'A model of the material to be added.'
          }
        ],
        returns: 'The position of the new material in the table.'
      },
      {
        signature: 'int Add(Material material,bool reference)',
        summary: 'Adds a new material to the table based on a given material.',
        since: 5,
        parameters: [
          {
            name: 'material',
            summary: 'A model of the material to be added.'
          },
          {
            name: 'reference',
            summary: `True if this material is supposed to be a reference material.
     Reference materials are not saved in the file.`
          }
        ],
        returns: 'The position of the new material in the table.'
      },
      {
        signature: 'bool Delete(Material item)',
        since: 6
      },
      {
        signature: 'bool DeleteAt(int materialIndex)',
        summary: 'Removes a material at a specific position from this material table.',
        since: 5,
        parameters: [
          {
            name: 'materialIndex',
            summary: 'The position to be removed.'
          }
        ],
        returns: `True if successful. False if materialIndex is out of range or the
     material cannot be deleted because it is the current material or because
     it material contains active geometry.`
      },
      {
        signature: 'int Find(Guid materialId,bool ignoreDeletedMaterials)',
        summary: 'Finds a material with a matching id.',
        since: 5,
        parameters: [
          {
            name: 'materialId',
            summary: 'A material ID to be found.'
          },
          {
            name: 'ignoreDeletedMaterials',
            summary: 'If true, deleted materials are not checked.'
          }
        ],
        returns: `>=0 index of the material with the given name
     -1  no material has the given name.`
      },
      {
        signature: 'int Find(string materialName,bool ignoreDeletedMaterials)',
        summary: 'Finds a meterial with a given name.',
        since: 5,
        parameters: [
          {
            name: 'materialName',
            summary: 'Name of the material to search for. The search ignores case.'
          },
          {
            name: 'ignoreDeletedMaterials',
            summary: 'True means don\'t search deleted materials.'
          }
        ],
        returns: `>=0 index of the material with the given name
     -1  no material has the given name.`
      },
      {
        signature: 'Material FindIndex(int index)',
        summary: `Retrieves a Material object based on Index. This seach type of search is discouraged.
     We are moving towards using only IDs for all tables.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index to search for.'
          }
        ],
        returns: 'A Material object, or None if none was found.'
      },
      {
        signature: 'bool Modify(Material newSettings,int materialIndex,bool quiet)',
        summary: 'Modify material settings.',
        since: 5,
        parameters: [
          {
            name: 'newSettings',
            summary: 'This information is copied.'
          },
          {
            name: 'materialIndex',
            summary: 'zero based index of material to set.  This must be in the range 0 <= layerIndex < MaterialTable.Count.'
          },
          {
            name: 'quiet',
            summary: 'if true, information message boxes pop up when illegal changes are attempted.'
          }
        ],
        returns: `True if successful. False if materialIndex is out of range or the settings attempt
     to lock or hide the current material.`
      },
      {
        signature: 'bool ResetMaterial(int materialIndex)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'MaterialTableEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RhinoDoc Document',
        since: 5,
        property: ['get']
      },
      {
        signature: 'MaterialTableEventType EventType',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Index',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Material OldSettings',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'MaterialTableEventType',
    dataType: 3,
    values: [
      {
        signature: 'Added = 0'
      },
      {
        signature: 'Deleted = 1'
      },
      {
        signature: 'Undeleted = 2'
      },
      {
        signature: 'Modified = 3'
      },
      {
        signature: 'Sorted = 4'
      },
      {
        signature: 'Current = 5'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'ModifyType',
    dataType: 3,
    values: [
      {
        signature: 'Modify'
      },
      {
        signature: 'Override'
      },
      {
        signature: 'NotSaved'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'NamedConstructionPlaneTable',
    dataType: 1,
    summary: `Contains all named construction planes in a rhino document.
   This class cannot be inherited.`,
    interfaces: ['IEnumerable<ConstructionPlane>', 'Collections.IRhinoTable<ConstructionPlane>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Number of construction planes in the table.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'Gets the document that owns this table.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int Add(string name,Plane plane)',
        summary: 'Adds named construction plane to document.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: `If name is empty, a unique name is automatically created.
     If there is already a named onstruction plane with the same name, that 
     construction plane is replaced.`
          },
          {
            name: 'plane',
            summary: 'The plane value.'
          }
        ],
        returns: `0 based index of named construction plane.
     -1 on failure.`
      },
      {
        signature: 'bool Delete(int index)',
        summary: 'Remove named construction plane from the document.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'zero based array index.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Delete(string name)',
        summary: 'Remove named construction plane from the document.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'name of the construction plane.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'int Find(string name)',
        summary: 'Finds a named construction plane.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'Name of construction plane to search for.'
          }
        ],
        returns: `>=0 index of the construction plane with the given name.
     -1 no construction plane found with the given name.`
      },
      {
        signature: 'IEnumerator<ConstructionPlane> GetEnumerator()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'NamedLayerStateTable',
    dataType: 1,
    summary: 'All named layer states in a Rhino document.',
    properties: [
      {
        signature: 'int Count',
        summary: 'Returns the number of named layers states in the document.',
        since: 6.14,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'Document that owns this table.',
        since: 6.14,
        property: ['get']
      },
      {
        signature: 'string[] Names',
        summary: 'Returns the names of named layer states in the document.',
        since: 6.14,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool Delete(string name)',
        summary: 'Deletes an exising named layer state.',
        since: 6.14,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the layer state.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'int FindName(string name)',
        summary: 'Returns the index of an existing named layer state.',
        since: 6.14,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the layer state.'
          }
        ],
        returns: '>0 if successful, -1 if not found.'
      },
      {
        signature: 'int Import(string filename)',
        summary: 'Imports named layer states from a 3dm file.',
        since: 6.15,
        parameters: [
          {
            name: 'filename',
            summary: 'The name of the file to import.'
          }
        ],
        returns: 'The number of named layers states imported.'
      },
      {
        signature: 'bool Rename(string oldName,string newName)',
        summary: 'Renames an existing named layer state.',
        since: 6.14,
        parameters: [
          {
            name: 'oldName',
            summary: 'The name of the layer state.'
          },
          {
            name: 'newName',
            summary: 'The new name'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool Restore(string name,RestoreLayerProperties properties)',
        summary: 'Restores a named layer state.',
        since: 6.14,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the layer state.'
          },
          {
            name: 'properties',
            summary: 'The layer properties to restore.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool Restore(string name,RestoreLayerProperties properties,Guid viewportId)',
        summary: 'Restores a named layer state.',
        since: 6.14,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the layer state.'
          },
          {
            name: 'properties',
            summary: 'The layer properties to restore.'
          },
          {
            name: 'viewportId',
            summary: 'The id of the layout or detail viewport to restore the per-viewprot layer properties.'
          }
        ]
      },
      {
        signature: 'int Save(string name)',
        summary: 'Saves or updates a named layer state.',
        since: 6.14,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the layer state. If the named layer state already exists, it will be updated.'
          }
        ],
        returns: 'The index of the newly added, or updated, layer state.'
      },
      {
        signature: 'int Save(string name,Guid viewportId)',
        summary: 'Saves or updates a named layer state.',
        since: 6.14,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the layer state. If the named layer state already exists, it will be updated.'
          },
          {
            name: 'viewportId',
            summary: 'The id of the layout or detail viewport, required to save per viewport layer state properties.'
          }
        ],
        returns: 'The index of the newly added, or updated, layer state.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'NamedPositionTable',
    dataType: 1,
    summary: 'All named positions in a rhino document.',
    properties: [
      {
        signature: 'int Count',
        summary: 'Number of Named Positions in the table.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'Document that owns this table.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid[] Ids',
        summary: 'Array of Named Position guids.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string[] Names',
        summary: 'Array of Named Position names.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool Append(Guid id,IEnumerable<Guid> objectIds)',
        summary: 'Append objects to a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'Guid of the Named Position which you want to append to.'
          },
          {
            name: 'objectIds',
            summary: 'New object ids to be included in this Named Position.'
          }
        ],
        returns: 'True or False depending on whether the Append was successful.'
      },
      {
        signature: 'bool Append(Guid id,IEnumerable<RhinoObject> objects)',
        summary: 'Append objects to a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'Guid of the Named Position which you want to append to.'
          },
          {
            name: 'objects',
            summary: 'Collection of Rhino Objects to be included in this Named Position.'
          }
        ],
        returns: 'True or False depending on whether the Append was successful.'
      },
      {
        signature: 'bool Append(string name,IEnumerable<Guid> objectIds)',
        summary: 'Append objects to a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'Name of the Named Position which you want to append to.'
          },
          {
            name: 'objectIds',
            summary: 'New object Guids to be included in this Named Position.'
          }
        ],
        returns: 'True or False depending on whether the Append was successful.'
      },
      {
        signature: 'bool Append(string name,IEnumerable<RhinoObject> objects)',
        summary: 'Append objects to a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'Name of the Named Position which you want to append to.'
          },
          {
            name: 'objects',
            summary: 'Collection of Rhino Objects to be included in this Named Position.'
          }
        ],
        returns: 'True or False depending on whether the Append was successful.'
      },
      {
        signature: 'bool Delete(Guid id)',
        summary: 'Delete a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'Guid of the Named Position which you want to delete.'
          }
        ],
        returns: 'True or False depending on whether the Delete was successful, Null in case the id does not exist as a Named Position.'
      },
      {
        signature: 'bool Delete(string name)',
        summary: 'Delete a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'Name of the Named Position which you want to delete.'
          }
        ],
        returns: 'True or False depending on whether the Delete was successful, Null in case the id does not exist as a Named Position.'
      },
      {
        signature: 'Guid Id(string name)',
        summary: 'Guid of a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'Name of the Named Position for which you want to retrieve the Guid.'
          }
        ],
        returns: 'The Guid of the Named Position.  If not found, an empty Guid is returned.'
      },
      {
        signature: 'string Name(Guid id)',
        summary: 'Name of a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'Guid of the Named Position for which you want to retrieve the name.'
          }
        ],
        returns: 'The name of the Named Position as a string.'
      },
      {
        signature: 'Guid[] ObjectIds(Guid id)',
        summary: 'Array of Rhino Object Guids related to a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'The Guid of the named position from which you want to retrieve the objects.'
          }
        ],
        returns: 'Array of Guid which pertain to the objects tracked by the Named Position.'
      },
      {
        signature: 'Guid[] ObjectIds(string name)',
        summary: 'Array of Rhino Object Guids related to a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the Named Position from which you want to retrieve the objects.'
          }
        ],
        returns: 'Array of Guid which pertain to the objects tracked by the Named Position, or None in case no such Named Position is found.'
      },
      {
        signature: 'RhinoObject[] Objects(Guid id)',
        summary: 'Array of Rhino Objects related to a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'The Guid of the named position from which you want to retrieve the objects.'
          }
        ],
        returns: 'Array of Rhino Objects which are tracked by the Named Position.'
      },
      {
        signature: 'RhinoObject[] Objects(string name)',
        summary: 'Array of Rhino Objects related to a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the Named Position from which you want to retrieve the objects.'
          }
        ],
        returns: 'Array of Rhino Objects which are tracked by the Named Position if successful, None if no such Named Position exists.'
      },
      {
        signature: 'bool ObjectXform(Guid id,Guid objId,Transform xform)',
        summary: 'Retrieve the Transform of a Rhino Object relate dto a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'The Guid of the Named Position'
          },
          {
            name: 'objId',
            summary: 'The Guid of the Rhino Object from which to retrieve the Transform.'
          },
          {
            name: 'xform',
            summary: 'The Transform to retrieve.'
          }
        ],
        returns: 'Transform of the RhinoObject related to the Named Position.'
      },
      {
        signature: 'bool ObjectXform(Guid id,RhinoObject obj,Transform xform)',
        summary: 'Retrieve the Transform of a Rhino Object relate dto a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'The Guid of the Named Position'
          },
          {
            name: 'obj',
            summary: 'The Rhino Object from which to retrieve the Transform.'
          },
          {
            name: 'xform',
            summary: 'The Transform to retrieve.'
          }
        ],
        returns: 'Transform of the RhinoObject related to the Named Position.'
      },
      {
        signature: 'bool Rename(Guid id,string name)',
        summary: 'Rename a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'Guid of the Named Position which you want to rename.'
          },
          {
            name: 'name',
            summary: 'New name for the Named Position.'
          }
        ],
        returns: 'True or False depending on whether the Rename was successful.  For example, this method might return False if you attempt to remane the Named Position with the currently assigned name.'
      },
      {
        signature: 'bool Rename(string oldName,string name)',
        summary: 'Rename a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'oldName',
            summary: 'Current name of the Named Position which you want to rename.'
          },
          {
            name: 'name',
            summary: 'New name for the Named Position.'
          }
        ],
        returns: 'True or False depending on whether the Rename was successful.  For example, this method might return False if you attempt to remane the Named Position with the currently assigned name.'
      },
      {
        signature: 'bool Restore(Guid id)',
        summary: 'Restore a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'Guid of the Named Position to restore.'
          }
        ],
        returns: 'True or False based on whether the Named Position was able to be restored.'
      },
      {
        signature: 'bool Restore(string name)',
        summary: 'Restore a Named Position.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'Name of the Named Position to restore.'
          }
        ],
        returns: 'True or False based on whether the Named Position was able to be restored.'
      },
      {
        signature: 'Guid Save(string name,IEnumerable<Guid> objectIds)',
        summary: 'Save a new Named Position.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'Name for this Named Position.'
          },
          {
            name: 'objectIds',
            summary: 'Array of Rhino Object Ids which should be included in this Named Position.'
          }
        ],
        returns: 'Guid of the newly saved Named Position.'
      },
      {
        signature: 'Guid Save(string name,IEnumerable<RhinoObject> objects)',
        summary: 'Save a new Named Position.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'Name for this Named Position.'
          },
          {
            name: 'objects',
            summary: 'Array of Rhino Objects which should be included in this Named Position.'
          }
        ],
        returns: 'Guid of the newly saved Named Position.'
      },
      {
        signature: 'bool Update(Guid id)',
        summary: 'Updates a Named Position, effectively storing the current positions of the objects which the Named Position is tracking.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'Guid of the Named Position which you want to update.'
          }
        ],
        returns: 'True or False depending on whether the Update was successful.'
      },
      {
        signature: 'bool Update(string name)',
        summary: 'Updates a Named Position, effectively storing the current positions of the objects which the Named Position is tracking.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'Name of the Named Position which you want to update.'
          }
        ],
        returns: 'True or False depending on whether the Update was successful.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'NamedViewTable',
    dataType: 1,
    summary: 'All named views in a rhino document.',
    interfaces: ['IEnumerable<ViewInfo>', 'Collections.IRhinoTable<ViewInfo>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Number of named views in the table.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'Document that owns this table.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int Add(string name,Guid viewportId)',
        summary: 'Adds named view to document which is based on an existing viewport.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: `If name is empty, a unique name is automatically created.
     If there is already a named view with the same name, that view is replaced.`
          },
          {
            name: 'viewportId',
            summary: 'Id of an existing viewport in the document. View information is copied from this viewport.'
          }
        ],
        returns: `0 based index of named view.
     -1 on failure.`
      },
      {
        signature: 'int Add(ViewInfo view)',
        since: 5
      },
      {
        signature: 'bool Delete(int index)',
        summary: 'Remove named view from the document.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'index of the named view in the named view table.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Delete(string name)',
        summary: 'Remove named view from the document.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'name of the view.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'int FindByName(string name)',
        summary: 'Finds a named view.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'name to search for.'
          }
        ],
        returns: `>=0 index of the found named view
     -1 no named view found.`
      },
      {
        signature: 'IEnumerator<ViewInfo> GetEnumerator()',
        since: 5
      },
      {
        signature: 'bool Rename(int index,string newName)',
        summary: 'Renames a named view.',
        since: 7,
        parameters: [
          {
            name: 'index',
            summary: 'Index of the named view in the named view table.'
          },
          {
            name: 'newName',
            summary: 'The new name.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool Rename(string oldName,string newName)',
        summary: 'Renames a named view.',
        since: 7,
        parameters: [
          {
            name: 'oldName',
            summary: 'The name of a named view in the named view table.'
          },
          {
            name: 'newName',
            summary: 'The new name.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool Restore(int index,RhinoView view,bool backgroundBitmap)',
        since: 5
      },
      {
        signature: 'bool Restore(int index,RhinoViewport viewport)',
        summary: 'Sets the MainViewport of a standard RhinoView to a named views settings',
        since: 6
      },
      {
        signature: 'bool Restore(int index,RhinoViewport viewport,bool backgroundBitmap)',
        since: 5.9
      },
      {
        signature: 'bool RestoreAnimated(int index,RhinoView view,bool backgroundBitmap)',
        since: 5
      },
      {
        signature: 'bool RestoreAnimated(int index,RhinoView view,bool backgroundBitmap,int frames,int frameRate)',
        since: 5
      },
      {
        signature: 'bool RestoreAnimated(int index,RhinoViewport viewport,bool backgroundBitmap)',
        since: 5.9
      },
      {
        signature: 'bool RestoreAnimated(int index,RhinoViewport viewport,bool backgroundBitmap,int frames,int frameRate)',
        since: 5.9
      },
      {
        signature: 'bool RestoreAnimatedConstantSpeed(int index,RhinoViewport viewport,double units_per_frame,int ms_delay)',
        since: 6
      },
      {
        signature: 'bool RestoreAnimatedConstantTime(int index,RhinoViewport viewport,int frames,int ms_delay)',
        since: 6
      },
      {
        signature: 'bool RestoreWithAspectRatio(int index,RhinoViewport viewport)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'ObjectTable',
    dataType: 1,
    baseclass: 'RhinoDocCommonTable<RhinoObject>',
    interfaces: ['ICollection<RhinoObject>'],
    properties: [
      {
        signature: 'BoundingBox BoundingBox',
        summary: `Gets the boundingbox for all objects (normal, locked and hidden) in this
     document that exist in "model" space. This bounding box does not include
     objects that exist in layout space.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'BoundingBox BoundingBoxVisible',
        summary: `Gets the boundingbox for all visible objects (normal and locked) in this
     document that exist in "model" space. This bounding box does not include
     hidden objects or any objects that exist in layout space.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'ModelComponentType ComponentType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'Gets the document that owns this object table.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int HistoryRecordCount',
        summary: 'Returns the amount of history records in this document.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Guid Add(GeometryBase geometry)',
        summary: `Adds geometry that is not further specified.
     This is meant, for example, to handle addition of sets of different geometrical entities.`,
        since: 5,
        parameters: [
          {
            name: 'geometry',
            summary: 'The base geometry. This cannot be null.'
          }
        ],
        returns: 'The new object ID on success.'
      },
      {
        signature: 'Guid Add(GeometryBase geometry,ObjectAttributes attributes)',
        summary: `Adds geometry that is not further specified.
     This is meant, for example, to handle addition of sets of different geometrical entities.`,
        since: 5,
        parameters: [
          {
            name: 'geometry',
            summary: 'The base geometry. This cannot be null.'
          },
          {
            name: 'attributes',
            summary: 'The object attributes. This can be null.'
          }
        ],
        returns: 'The new object ID on success.'
      },
      {
        signature: 'Guid Add(GeometryBase geometry,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: `Adds geometry that is not further specified.
     This is meant, for example, to handle addition of sets of different geometrical entities.`,
        since: 6,
        parameters: [
          {
            name: 'geometry',
            summary: 'The base geometry. This cannot be null.'
          },
          {
            name: 'attributes',
            summary: 'The object attributes. This can be null.'
          },
          {
            name: 'history',
            summary: 'The history information that will be saved.'
          },
          {
            name: 'reference',
            summary: 'If reference is true, object will not be saved in the 3dm file.'
          }
        ],
        returns: 'The new object ID on success.'
      },
      {
        signature: 'Guid AddAngularDimension(AngularDimension dimension)',
        summary: 'Adds a angular dimension object to the document.',
        since: 5,
        parameters: [
          {
            name: 'dimension',
            summary: 'Dimension object to add.'
          }
        ],
        returns: 'The Id of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddAngularDimension(AngularDimension dimension,ObjectAttributes attributes)',
        summary: 'Adds a angular dimension object to the document.',
        since: 5,
        parameters: [
          {
            name: 'dimension',
            summary: 'Dimension object to add.'
          },
          {
            name: 'attributes',
            summary: ''
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddAngularDimension(AngularDimension dimension,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds an angular dimension object to the document.',
        since: 5,
        parameters: [
          {
            name: 'dimension',
            summary: 'Dimension object to add.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to dimension.'
          },
          {
            name: 'history',
            summary: 'Object history to save.'
          },
          {
            name: 'reference',
            summary: 'If reference, then object will not be saved into the 3dm file.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddArc(Arc arc)',
        summary: 'Adds a curve object to the document representing an arc.',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'An arc value.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddArc(Arc arc,ObjectAttributes attributes)',
        summary: 'Adds a curve object to the document representing an arc.',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'An arc value.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to arc.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddArc(Arc arc,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddBox(Box box)',
        summary: 'Adds a box to the object table.',
        since: 6,
        parameters: [
          {
            name: 'box',
            summary: 'The box.'
          }
        ],
        returns: 'The ID.'
      },
      {
        signature: 'Guid AddBox(Box box,ObjectAttributes attributes)',
        summary: 'Adds a box to the object table.',
        since: 6,
        parameters: [
          {
            name: 'box',
            summary: 'The box.'
          },
          {
            name: 'attributes',
            summary: 'Attributes that will be linked with the surface object.'
          }
        ],
        returns: 'The ID.'
      },
      {
        signature: 'Guid AddBox(Box box,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds a box to the object table, as an extrusion.',
        since: 6,
        parameters: [
          {
            name: 'box',
            summary: 'The box.'
          },
          {
            name: 'attributes',
            summary: 'Attributes that will be linked with the surface object.'
          },
          {
            name: 'history',
            summary: 'History data records.'
          },
          {
            name: 'reference',
            summary: 'If a reference, object will not be saved in the document.'
          }
        ],
        returns: 'The ID.'
      },
      {
        signature: 'Guid AddBrep(Brep brep)',
        summary: 'Adds a brep object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'A duplicate of this brep is added to Rhino.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddBrep(Brep brep,ObjectAttributes attributes)',
        summary: 'Adds a brep object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'A duplicate of this brep is added to Rhino.'
          },
          {
            name: 'attributes',
            summary: 'attributes to apply to brep.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddBrep(Brep brep,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddBrep(Brep brep,ObjectAttributes attributes,HistoryRecord history,bool reference,bool splitKinkySurfaces)',
        since: 5
      },
      {
        signature: 'Guid AddCentermark(Centermark centermark,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds an ordinate dimension object to the document.',
        since: 6,
        parameters: [
          {
            name: 'centermark',
            summary: 'Dimension object to add.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to dimension.'
          },
          {
            name: 'history',
            summary: 'Object history to save.'
          },
          {
            name: 'reference',
            summary: 'If reference, then object will not be saved into the 3dm file.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddCircle(Circle circle)',
        summary: 'Adds a curve object to the document representing a circle.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'A circle value.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddCircle(Circle circle,ObjectAttributes attributes)',
        summary: 'Adds a curve object to the document representing a circle.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'A circle value.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to circle.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddCircle(Circle circle,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,Guid clippedViewportId)',
        summary: 'Adds a clipping plane object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'The plane value.'
          },
          {
            name: 'uMagnitude',
            summary: 'The size in the U direction.'
          },
          {
            name: 'vMagnitude',
            summary: 'The size in the V direction.'
          },
          {
            name: 'clippedViewportId',
            summary: 'Viewport ID that the new clipping plane will clip.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,Guid clippedViewportId,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,IEnumerable<Guid> clippedViewportIds)',
        summary: 'Adds a clipping plane object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'The plane value.'
          },
          {
            name: 'uMagnitude',
            summary: 'The size in the U direction.'
          },
          {
            name: 'vMagnitude',
            summary: 'The size in the V direction.'
          },
          {
            name: 'clippedViewportIds',
            summary: `A list, an array or any enumerable set of viewport IDs
     that the new clipping plane will clip.`
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,IEnumerable<Guid> clippedViewportIds,ObjectAttributes attributes)',
        summary: 'Adds a clipping plane object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'The plane value.'
          },
          {
            name: 'uMagnitude',
            summary: 'The size in the U direction.'
          },
          {
            name: 'vMagnitude',
            summary: 'The size in the V direction.'
          },
          {
            name: 'clippedViewportIds',
            summary: `A list, an array or any enumerable set of viewport IDs
     that the new clipping plane will clip.`
          },
          {
            name: 'attributes',
            summary: 'Document attributes for the plane.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,IEnumerable<Guid> clippedViewportIds,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddCurve(Curve curve)',
        summary: 'Adds a curve object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'A curve. A duplicate of this curve is added to Rhino.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddCurve(Curve curve,ObjectAttributes attributes)',
        summary: 'Adds a curve object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'A curve. A duplicate of this curve is added to Rhino.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to curve.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddCurve(Curve curve,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddEllipse(Ellipse ellipse)',
        summary: 'Adds a curve object to the document representing an ellipse.',
        since: 5,
        parameters: [
          {
            name: 'ellipse',
            summary: 'An ellipse value.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddEllipse(Ellipse ellipse,ObjectAttributes attributes)',
        summary: 'Adds a curve object to the document representing an ellipse.',
        since: 5,
        parameters: [
          {
            name: 'ellipse',
            summary: 'An ellipse value.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to ellipse.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddEllipse(Ellipse ellipse,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid[] AddExplodedInstancePieces(InstanceObject instance,bool explodeNestedInstances,bool deleteInstance)',
        since: 5.11
      },
      {
        signature: 'Guid AddExtrusion(Extrusion extrusion)',
        summary: 'Adds an extrusion object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'extrusion',
            summary: 'A duplicate of this extrusion is added to Rhino.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddExtrusion(Extrusion extrusion,ObjectAttributes attributes)',
        summary: 'Adds an extrusion object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'extrusion',
            summary: 'A duplicate of this extrusion is added to Rhino.'
          },
          {
            name: 'attributes',
            summary: 'Attributes that will be linked with the extrusion object.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddExtrusion(Extrusion extrusion,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddHatch(Hatch hatch)',
        since: 5
      },
      {
        signature: 'Guid AddHatch(Hatch hatch,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'Guid AddHatch(Hatch hatch,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddInstanceObject(int instanceDefinitionIndex,Transform instanceXform)',
        summary: 'Adds an instance object to the document.',
        since: 5,
        parameters: [
          {
            name: 'instanceDefinitionIndex',
            summary: 'The index of the instance definition.'
          },
          {
            name: 'instanceXform',
            summary: 'The instance transformation.'
          }
        ],
        returns: 'A unique identifier for the object if successful. Guid.Empty it not successful.'
      },
      {
        signature: 'Guid AddInstanceObject(int instanceDefinitionIndex,Transform instanceXform,ObjectAttributes attributes)',
        summary: 'Adds an instance object to the document.',
        since: 5,
        parameters: [
          {
            name: 'instanceDefinitionIndex',
            summary: 'The index of the instance definition.'
          },
          {
            name: 'instanceXform',
            summary: 'The instance transformation.'
          },
          {
            name: 'attributes',
            summary: 'The attribues to apply to the instance object.'
          }
        ],
        returns: 'A unique identifier for the object if successful. Guid.Empty it not successful.'
      },
      {
        signature: 'Guid AddInstanceObject(int instanceDefinitionIndex,Transform instanceXform,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds an instance object to the document.',
        since: 6.24,
        parameters: [
          {
            name: 'instanceDefinitionIndex',
            summary: 'The index of the instance definition.'
          },
          {
            name: 'instanceXform',
            summary: 'The instance transformation.'
          },
          {
            name: 'attributes',
            summary: 'The attribues to apply to the instance object.'
          },
          {
            name: 'history',
            summary: 'The history record associated with this instance object.'
          },
          {
            name: 'reference',
            summary: 'True if the object is from a reference file. Reference objects do not persist in archives.'
          }
        ],
        returns: 'A unique identifier for the object if successful. Guid.Empty it not successful.'
      },
      {
        signature: 'Guid AddLeader(IEnumerable<Point3d> points)',
        since: 5
      },
      {
        signature: 'Guid AddLeader(Leader leader)',
        summary: 'Adds a Leader object to the document.',
        since: 6,
        parameters: [
          {
            name: 'leader',
            summary: 'The leader object.'
          }
        ],
        returns: 'The Id of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddLeader(Leader leader,ObjectAttributes attributes)',
        summary: 'Addsa Leader object to the document.',
        since: 6,
        parameters: [
          {
            name: 'leader',
            summary: 'The leader object.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to rich text.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddLeader(Leader leader,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds a Leader object to the document.',
        since: 6,
        parameters: [
          {
            name: 'leader',
            summary: 'The leader object.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to rich text.'
          },
          {
            name: 'history',
            summary: 'Object history to save.'
          },
          {
            name: 'reference',
            summary: 'If reference, then object will not be saved into the 3dm file.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddLeader(Plane plane,IEnumerable<Point2d> points)',
        since: 5
      },
      {
        signature: 'Guid AddLeader(Plane plane,IEnumerable<Point2d> points,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'Guid AddLeader(string text,IEnumerable<Point3d> points)',
        since: 5
      },
      {
        signature: 'Guid AddLeader(string text,Plane plane,IEnumerable<Point2d> points)',
        since: 5
      },
      {
        signature: 'Guid AddLeader(string text,Plane plane,IEnumerable<Point2d> points,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'Guid AddLeader(string text,Plane plane,IEnumerable<Point2d> points,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddLine(Line line)',
        summary: 'Adds a line object to Rhino.',
        since: 5,
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddLine(Line line,ObjectAttributes attributes)',
        summary: 'Adds a line object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'The line value.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to line.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddLine(Point3d from,Point3d to)',
        summary: 'Adds a line object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'from',
            summary: 'The line origin.'
          },
          {
            name: 'to',
            summary: 'The line end.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddLine(Point3d from,Point3d to,ObjectAttributes attributes)',
        summary: 'Adds a line object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'from',
            summary: 'The line origin.'
          },
          {
            name: 'to',
            summary: 'The line end.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to line.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddLine(Point3d from,Point3d to,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddLinearDimension(LinearDimension dimension)',
        summary: 'Adds a linear dimension object to the document.',
        since: 5,
        parameters: [
          {
            name: 'dimension',
            summary: 'Dimension object to add.'
          }
        ],
        returns: 'The Id of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddLinearDimension(LinearDimension dimension,ObjectAttributes attributes)',
        summary: 'Adds a linear dimension object to the document.',
        since: 5,
        parameters: [
          {
            name: 'dimension',
            summary: 'Dimension object to add.'
          },
          {
            name: 'attributes',
            summary: ''
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddLinearDimension(LinearDimension dimension,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds a linear dimension object to the document.',
        since: 5,
        parameters: [
          {
            name: 'dimension',
            summary: 'Dimension object to add.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to dimension.'
          },
          {
            name: 'history',
            summary: 'Object history to save.'
          },
          {
            name: 'reference',
            summary: 'If reference, then object will not be saved into the 3dm file.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddMesh(Mesh mesh)',
        summary: 'Adds a mesh object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'A duplicate of this mesh is added to Rhino.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddMesh(Mesh mesh,ObjectAttributes attributes)',
        summary: 'Adds a mesh object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'A duplicate of this mesh is added to Rhino.'
          },
          {
            name: 'attributes',
            summary: 'Attributes that will be linked with the mesh object.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddMesh(Mesh mesh,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddMesh(Mesh mesh,ObjectAttributes attributes,HistoryRecord history,bool reference,bool requireValidMesh)',
        since: 6
      },
      {
        signature: 'Guid AddMorphControl(MorphControl morphControl)',
        since: 5
      },
      {
        signature: 'Guid AddMorphControl(MorphControl morphControl,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'Guid AddMorphControl(MorphControl morphControl,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 6
      },
      {
        signature: 'Guid AddOrdinateDimension(OrdinateDimension dimordinate,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds an ordinate dimension object to the document.',
        since: 6,
        parameters: [
          {
            name: 'dimordinate',
            summary: 'Dimension object to add.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to dimension.'
          },
          {
            name: 'history',
            summary: 'Object history to save.'
          },
          {
            name: 'reference',
            summary: 'If reference, then object will not be saved into the 3dm file.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddPictureFrame(Plane plane,string texturePath,bool asMesh,double width,double height,bool selfIllumination,bool embedBitmap)',
        summary: `Creates a PictureFrame object from a plane and a path to an image file,
     Note, a PictureFrame object is just a Plane surface or mesh that has a
     material with a texture assigned to it that displays in all display
     modes.`,
        since: 5.1,
        parameters: [
          {
            name: 'plane',
            summary: `Plane in which the PictureFrame will be created.  Bottom left corner of
     picture will be at plane's origin, width will be in the plane's x axis
     direction, height will be in the plane's y axis direction.`
          },
          {
            name: 'texturePath',
            summary: 'path to an image file'
          },
          {
            name: 'asMesh',
            summary: 'If true, the function will make a MeshObject rather than a surface'
          },
          {
            name: 'width',
            summary: `Width of the resulting PictureFrame. If 0.0, the width of the pictureframe
     is the width of the image if height is also 0.0 or calculated from the
     height and aspect ratio of the image if height is not 0.0.`
          },
          {
            name: 'height',
            summary: `Height of the resulting PictureFrame. If 0.0, the height of the pictureframe
     is the height of the image if width is also 0.0 or calculated from the width
     and aspect ratio of the image if width is not 0.0.`
          },
          {
            name: 'selfIllumination',
            summary: `If true, the image mapped to the picture frame plane always displays at full
     intensity and is not affected by light or shadow.`
          },
          {
            name: 'embedBitmap',
            summary: `If true, the funtion adds the the image to the bitmaptable of the document
     to which the PictureFrame will be added`
          }
        ],
        returns: 'A unique identifier for the object'
      },
      {
        signature: 'Guid AddPoint(double x,double y,double z)',
        summary: 'Adds a point object to the document.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X component of point coordinate.'
          },
          {
            name: 'y',
            summary: 'Y component of point coordinate.'
          },
          {
            name: 'z',
            summary: 'Z component of point coordinate.'
          }
        ],
        returns: 'A unique identifier for the object..'
      },
      {
        signature: 'Guid AddPoint(Point point,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds a point object and its geometry-linked information to the document',
        since: 6,
        parameters: [
          {
            name: 'point',
            summary: 'A point geometry class.'
          },
          {
            name: 'attributes',
            summary: 'attributes to apply to point. None is acceptible'
          },
          {
            name: 'history',
            summary: 'history associated with this point. None is acceptable'
          },
          {
            name: 'reference',
            summary: `True if the object is from a reference file.  Reference objects do
     not persist in archives`
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPoint(Point3d point)',
        summary: 'Adds a point object to the document.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'location of point.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPoint(Point3d point,ObjectAttributes attributes)',
        summary: 'Adds a point object to the document.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'location of point.'
          },
          {
            name: 'attributes',
            summary: 'attributes to apply to point. None is acceptible'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPoint(Point3d point,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds a point object to the document',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'location of point'
          },
          {
            name: 'attributes',
            summary: 'attributes to apply to point. None is acceptible'
          },
          {
            name: 'history',
            summary: 'history associated with this point. None is acceptable'
          },
          {
            name: 'reference',
            summary: `True if the object is from a reference file.  Reference objects do
     not persist in archives`
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPoint(Point3f point)',
        summary: 'Adds a point object to the document.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'location of point.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPoint(Point3f point,ObjectAttributes attributes)',
        summary: 'Adds a point object to the document.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'location of point.'
          },
          {
            name: 'attributes',
            summary: 'attributes to apply to point.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPointCloud(IEnumerable<Point3d> points)',
        summary: 'Adds a point cloud object to the document.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of points.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPointCloud(IEnumerable<Point3d> points,ObjectAttributes attributes)',
        summary: 'Adds a point cloud object to the document.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of points.'
          },
          {
            name: 'attributes',
            summary: 'attributes to apply to point cloud.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPointCloud(IEnumerable<Point3d> points,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds a point cloud object to the document.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of points'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to point cloud. None is acceptable'
          },
          {
            name: 'history',
            summary: 'history associated with this pointcloud. None is acceptable'
          },
          {
            name: 'reference',
            summary: `True if the object is from a reference file.  Reference objects do
     not persist in archives`
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPointCloud(PointCloud cloud)',
        summary: 'Adds a point cloud object to the document.',
        since: 5,
        parameters: [
          {
            name: 'cloud',
            summary: 'PointCloud to add.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPointCloud(PointCloud cloud,ObjectAttributes attributes)',
        summary: 'Adds a point cloud object to the document.',
        since: 5,
        parameters: [
          {
            name: 'cloud',
            summary: 'PointCloud to add.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to point cloud.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPointCloud(PointCloud cloud,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds a point cloud object to the document.',
        since: 5,
        parameters: [
          {
            name: 'cloud',
            summary: 'PointCloud to add.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to point cloud. None is acceptable'
          },
          {
            name: 'history',
            summary: 'history associated with this pointcloud. None is acceptable'
          },
          {
            name: 'reference',
            summary: `True if the object is from a reference file.  Reference objects do
     not persist in archives`
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'RhinoList<Guid> AddPoints(IEnumerable<Point3d> points)',
        summary: 'Adds multiple points to the document.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to add.'
          }
        ],
        returns: 'List of object ids.'
      },
      {
        signature: 'RhinoList<Guid> AddPoints(IEnumerable<Point3d> points,ObjectAttributes attributes)',
        summary: 'Adds multiple points to the document.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to add.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to point objects.'
          }
        ],
        returns: 'List of object ids.'
      },
      {
        signature: 'RhinoList<Guid> AddPoints(IEnumerable<Point3f> points)',
        summary: 'Adds multiple points to the document.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to add.'
          }
        ],
        returns: 'List of object ids.'
      },
      {
        signature: 'RhinoList<Guid> AddPoints(IEnumerable<Point3f> points,ObjectAttributes attributes)',
        summary: 'Adds multiple points to the document.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to add.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to point objects.'
          }
        ],
        returns: 'List of object ids.'
      },
      {
        signature: 'Guid AddPolyline(IEnumerable<Point3d> points)',
        summary: 'Adds a polyline object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A Polyline; a list, an array, or any enumerable set of Point3d.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPolyline(IEnumerable<Point3d> points,ObjectAttributes attributes)',
        summary: 'Adds a polyline object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A Polyline; a list, an array, or any enumerable set of Point3d.'
          },
          {
            name: 'attributes',
            summary: 'attributes to apply to line.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPolyline(IEnumerable<Point3d> points,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddRadialDimension(RadialDimension dimension)',
        since: 5
      },
      {
        signature: 'Guid AddRadialDimension(RadialDimension dimension,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'Guid AddRadialDimension(RadialDimension dimension,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds a radial dimension object to the document.',
        since: 5,
        parameters: [
          {
            name: 'dimension',
            summary: 'Dimension object to add.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to dimension.'
          },
          {
            name: 'history',
            summary: 'Object history to save.'
          },
          {
            name: 'reference',
            summary: 'If reference, then object will not be saved into the 3dm file.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddRectangle(Rectangle3d rectangle)',
        summary: 'Adds a rectangle to the object table.',
        since: 6,
        parameters: [
          {
            name: 'rectangle',
            summary: 'The rectangle.'
          }
        ],
        returns: 'The ID.'
      },
      {
        signature: 'Guid AddRectangle(Rectangle3d rectangle,ObjectAttributes attributes)',
        summary: 'Adds a rectangle to the object table.',
        since: 6,
        parameters: [
          {
            name: 'rectangle',
            summary: 'The rectangle.'
          },
          {
            name: 'attributes',
            summary: 'Attributes that will be linked with the surface object.'
          }
        ],
        returns: 'The ID.'
      },
      {
        signature: 'Guid AddRectangle(Rectangle3d rectangle,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds a rectangle to the object table.',
        since: 6,
        parameters: [
          {
            name: 'rectangle',
            summary: 'The rectangle.'
          },
          {
            name: 'attributes',
            summary: 'Attributes that will be linked with the surface object.'
          },
          {
            name: 'history',
            summary: 'History data records.'
          },
          {
            name: 'reference',
            summary: 'If a reference, object will not be saved in the document.'
          }
        ],
        returns: 'The ID.'
      },
      {
        signature: 'void AddRhinoObject(BrepObject brepObject,Brep brep)',
        since: 5
      },
      {
        signature: 'void AddRhinoObject(CurveObject curveObject,Curve curve)',
        since: 5
      },
      {
        signature: 'void AddRhinoObject(CustomBrepObject brepObject)',
        since: 5
      },
      {
        signature: 'void AddRhinoObject(CustomBrepObject brepObject,HistoryRecord history)',
        since: 6.1
      },
      {
        signature: 'void AddRhinoObject(CustomCurveObject curveObject,HistoryRecord history)',
        since: 6.1
      },
      {
        signature: 'void AddRhinoObject(CustomMeshObject meshObject)',
        since: 5
      },
      {
        signature: 'void AddRhinoObject(CustomMeshObject meshObject,HistoryRecord history)',
        since: 6.1
      },
      {
        signature: 'void AddRhinoObject(CustomPointObject pointObject)',
        since: 5.6
      },
      {
        signature: 'void AddRhinoObject(CustomPointObject pointObject,HistoryRecord history)',
        since: 6.1
      },
      {
        signature: 'void AddRhinoObject(MeshObject meshObject,Mesh mesh)',
        since: 5
      },
      {
        signature: 'void AddRhinoObject(PointObject pointObject,Point point)',
        since: 5.6
      },
      {
        signature: 'Guid AddSphere(Sphere sphere)',
        since: 5
      },
      {
        signature: 'Guid AddSphere(Sphere sphere,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'Guid AddSphere(Sphere sphere,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddSubD(SubD subD)',
        summary: 'Adds a SubD object to Rhino.',
        since: 7,
        parameters: [
          {
            name: 'subD',
            summary: 'A duplicate of this SubD is added to Rhino.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddSubD(SubD subD,ObjectAttributes attributes)',
        summary: 'Adds a SubD object to Rhino.',
        since: 7,
        parameters: [
          {
            name: 'subD',
            summary: 'A duplicate of this SubD is added to Rhino.'
          },
          {
            name: 'attributes',
            summary: 'Attributes that will be linked with the object.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddSubD(SubD subD,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds a SubD object to Rhino.',
        since: 7,
        parameters: [
          {
            name: 'subD',
            summary: 'A duplicate of this SubD is added to Rhino.'
          },
          {
            name: 'attributes',
            summary: 'Attributes that will be linked with the object.'
          },
          {
            name: 'history',
            summary: ''
          },
          {
            name: 'reference',
            summary: ''
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddSurface(Surface surface)',
        summary: 'Adds a surface object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'A duplicate of this surface is added to Rhino.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddSurface(Surface surface,ObjectAttributes attributes)',
        summary: 'Adds a surface object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'A duplicate of this surface is added to Rhino.'
          },
          {
            name: 'attributes',
            summary: 'Attributes that will be linked with the surface object.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddSurface(Surface surface,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic)',
        summary: 'Adds an annotation text object to the document.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text string.'
          },
          {
            name: 'plane',
            summary: 'Plane of text.'
          },
          {
            name: 'height',
            summary: 'Height of text.'
          },
          {
            name: 'fontName',
            summary: 'Name of FontFace.'
          },
          {
            name: 'bold',
            summary: 'Bold flag.'
          },
          {
            name: 'italic',
            summary: 'Italic flag.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,ObjectAttributes attributes)',
        summary: 'Adds an annotation text object to the document.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text string.'
          },
          {
            name: 'plane',
            summary: 'Plane of text.'
          },
          {
            name: 'height',
            summary: 'Height of text.'
          },
          {
            name: 'fontName',
            summary: 'Name of FontFace.'
          },
          {
            name: 'bold',
            summary: 'Bold flag.'
          },
          {
            name: 'italic',
            summary: 'Italic flag.'
          },
          {
            name: 'attributes',
            summary: 'Attributes that will be linked with the object.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,TextJustification justification)',
        since: 5
      },
      {
        signature: 'Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,TextJustification justification,ObjectAttributes attributes)',
        since: 5
      },
      {
        signature: 'Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,TextJustification justification,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'Guid AddText(Text3d text3d)',
        summary: 'Adds an annotation text object to the document.',
        since: 5,
        parameters: [
          {
            name: 'text3d',
            summary: 'The text object to add.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddText(Text3d text3d,ObjectAttributes attributes)',
        summary: 'Adds an annotation text object to the document.',
        since: 5,
        parameters: [
          {
            name: 'text3d',
            summary: 'The text object to add.'
          },
          {
            name: 'attributes',
            summary: 'Object Attributes.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddText(TextEntity text)',
        summary: 'Adds a v6_TextObject to the document.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text object to add.'
          }
        ],
        returns: 'The Id of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddText(TextEntity text,ObjectAttributes attributes)',
        summary: 'Adds a text object to the document.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text object to add.'
          },
          {
            name: 'attributes',
            summary: ''
          }
        ],
        returns: 'The Id of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddText(TextEntity text,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        summary: 'Adds a text object to the document.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text object to add.'
          },
          {
            name: 'attributes',
            summary: ''
          },
          {
            name: 'history',
            summary: 'Object history to save.'
          },
          {
            name: 'reference',
            summary: 'If reference, then object will not be saved into the 3dm file.'
          }
        ],
        returns: 'The Id of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddTextDot(string text,Point3d location)',
        summary: 'Adds a text dot object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'A text string.'
          },
          {
            name: 'location',
            summary: 'A point position.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddTextDot(string text,Point3d location,ObjectAttributes attributes)',
        summary: 'Adds a text dot object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'A text string.'
          },
          {
            name: 'location',
            summary: 'A point position.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to curve.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddTextDot(TextDot dot)',
        summary: 'Adds a text dot object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'dot',
            summary: 'A text dot that will be copied.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddTextDot(TextDot dot,ObjectAttributes attributes)',
        summary: 'Adds a text dot object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'dot',
            summary: 'A text dot that will be copied.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to text dot.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddTextDot(TextDot dot,ObjectAttributes attributes,HistoryRecord history,bool reference)',
        since: 5
      },
      {
        signature: 'RhinoObject[] AllObjectsSince(uint runtimeSerialNumber)',
        summary: 'Gets all the objects that have been added to the document since a given runtime serial number.',
        since: 5,
        parameters: [
          {
            name: 'runtimeSerialNumber',
            summary: 'Runtime serial number of the last object not to include in the list.'
          }
        ],
        returns: 'An array of objects or None if no objects were added since the given runtime serial number.'
      },
      {
        signature: 'bool Delete(Guid objectId,bool quiet)',
        summary: 'Deletes object from document. The deletion can be undone by calling UndeleteObject().',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of the object to delete.'
          },
          {
            name: 'quiet',
            summary: 'If false, a message box will appear when an object cannot be deleted.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'int Delete(IEnumerable<Guid> objectIds,bool quiet)',
        summary: 'Deletes a collection of objects from the document.',
        since: 5,
        parameters: [
          {
            name: 'objectIds',
            summary: 'Ids of all objects to delete.'
          },
          {
            name: 'quiet',
            summary: 'If false, a message box will appear when an object cannot be deleted.'
          }
        ],
        returns: 'The number of successfully deleted objects.'
      },
      {
        signature: 'bool Delete(ObjRef objref,bool quiet)',
        summary: 'Deletes objref.Object(). The deletion can be undone by calling UndeleteObject().',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'objref.Object() will be deleted.'
          },
          {
            name: 'quiet',
            summary: 'If false, a message box will appear when an object cannot be deleted.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Delete(ObjRef objref,bool quiet,bool ignoreModes)',
        summary: 'Deletes objref.Object(). The deletion can be undone by calling UndeleteObject().',
        since: 6,
        parameters: [
          {
            name: 'objref',
            summary: 'objref.Object() will be deleted.'
          },
          {
            name: 'quiet',
            summary: 'If false, a message box will appear when an object cannot be deleted.'
          },
          {
            name: 'ignoreModes',
            summary: `If true, locked and hidden objects are deleted.  If False objects that
     are locked, hidden, or on locked or hidden layers are not deleted.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Delete(RhinoObject item)',
        summary: 'Deletes an object, taking into account modes and not showing error message boxes.',
        since: 6,
        parameters: [
          {
            name: 'item',
            summary: 'The object to delete.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'bool Delete(RhinoObject obj,bool quiet)',
        summary: 'Deletes object from document. The deletion can be undone by calling UndeleteObject().',
        since: 5,
        parameters: [
          {
            name: 'obj',
            summary: 'The object to delete.'
          },
          {
            name: 'quiet',
            summary: 'If false, a message box will appear when an object cannot be deleted.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Delete(RhinoObject obj,bool quiet,bool ignoreModes)',
        summary: 'Deletes object from document. The deletion can be undone by calling UndeleteObject().',
        since: 6,
        parameters: [
          {
            name: 'obj',
            summary: 'The object to delete.'
          },
          {
            name: 'quiet',
            summary: 'If false, a message box will appear when an object cannot be deleted.'
          },
          {
            name: 'ignoreModes',
            summary: `If true, locked and hidden objects are deleted.  If False objects that
     are locked, hidden, or on locked or hidden layers are not deleted.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool DeleteGrip(GripObject grip)',
        summary: 'Deletes a grip object.',
        since: 6.5,
        parameters: [
          {
            name: 'grip',
            summary: 'The grip object to delete.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'bool DeleteGrip(Guid gripId)',
        summary: 'Deletes a grip object.',
        since: 6.5,
        parameters: [
          {
            name: 'gripId',
            summary: 'The id of the grip object to delete.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'bool DeleteGrip(ObjRef gripRef)',
        summary: 'Deletes a grip object.',
        since: 6.5,
        parameters: [
          {
            name: 'gripRef',
            summary: 'A reference to the grip object to delete.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'int DeleteGrips(IEnumerable<GripObject> grips)',
        summary: 'Deletes one or more grip objects.',
        since: 6.5,
        parameters: [
          {
            name: 'grips',
            summary: 'The grip objects to delete.'
          }
        ],
        returns: 'The number of successfully deleted grip objects.'
      },
      {
        signature: 'int DeleteGrips(IEnumerable<Guid> gripIds)',
        summary: 'Deletes one or more grip objects.',
        since: 6.5,
        parameters: [
          {
            name: 'gripIds',
            summary: 'The ids of the grip objects to delete.'
          }
        ],
        returns: 'The number of successfully deleted grip objects.'
      },
      {
        signature: 'int DeleteGrips(IEnumerable<ObjRef> gripRefs)',
        summary: 'Deletes one or more grip objects.',
        since: 6.5,
        parameters: [
          {
            name: 'gripRefs',
            summary: 'References to the grip objects to delete.'
          }
        ],
        returns: 'The number of successfully deleted grip objects.'
      },
      {
        signature: 'int DeleteGrips(RhinoObject owner,IEnumerable<int> gripIndices)',
        summary: 'Deletes one or more grip objects.',
        since: 6.5,
        parameters: [
          {
            name: 'owner',
            summary: 'The owner of the grip objects.'
          },
          {
            name: 'gripIndices',
            summary: 'The indices of the grip objects to delete.'
          }
        ],
        returns: 'The number of successfully deleted grip objects.'
      },
      {
        signature: 'Guid Duplicate(Guid objectId)',
        summary: 'Same as TransformObject(objref, ON_Xform.Identity, false)',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'An ID to an object in the document that needs to be duplicated.'
          }
        ],
        returns: 'The new object ID.'
      },
      {
        signature: 'Guid Duplicate(ObjRef objref)',
        summary: `Duplicates the object that is referenced by objref.
     Same as Transform(objref, Transform.Identity, false)`,
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'A Rhino object reference to follow for object duplication.'
          }
        ],
        returns: 'The new object ID.'
      },
      {
        signature: 'Guid Duplicate(RhinoObject obj)',
        summary: `Duplicates the object that is referenced by obj.
     Same as TransformObject(obj, Transform.Identityy, false)`,
        since: 5,
        parameters: [
          {
            name: 'obj',
            summary: 'A Rhino object to duplicate.'
          }
        ],
        returns: 'The new object ID.'
      },
      {
        signature: 'RhinoObject Find(Guid objectId)',
        summary: 'Please use FindId().',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Do not use this method.'
          }
        ],
        returns: 'Do not use this method.'
      },
      {
        signature: 'RhinoObject Find(uint runtimeSerialNumber)',
        summary: `Use the object runtime serial number to find a rhino object in the document. This is the value stored on
     RhinoObject.RuntimeObjectSerialNumber. The RhinoObject constructor sets the runtime serial number and every
     instance of a RhinoObject class will have a unique serial number for the duration of the Rhino application.
     If an object is replaced with a new object, then the new object will have a different runtime serial number.
     Deleted objects stored in the undo list maintain their runtime serial numbers and this funtion will return
     pointers to these objects. Call RhinoObject.IsDeleted if you need to determine if the returned object is
     active or deleted.  The runtime serial number is not saved in files.`,
        since: 5,
        parameters: [
          {
            name: 'runtimeSerialNumber',
            summary: 'Runtime serial number to search for.'
          }
        ],
        returns: 'Reference to the rhino object with the objectId or None if no such object could be found.'
      },
      {
        signature: 'RhinoObject[] FindByCrossingWindowRegion(RhinoViewport viewport,IEnumerable<Point3d> region,bool inside,ObjectType filter)',
        summary: 'Finds objects bounded by a polyline region',
        since: 5.7,
        parameters: [
          {
            name: 'viewport',
            summary: 'viewport to use for selection'
          },
          {
            name: 'region',
            summary: 'list of points that define the'
          },
          {
            name: 'inside',
            summary: 'should objects returned be the ones inside of this region (or outside)'
          },
          {
            name: 'filter',
            summary: 'filter down list by object type'
          }
        ],
        returns: 'An array of RhinoObjects that are inside of this region'
      },
      {
        signature: 'RhinoObject[] FindByCrossingWindowRegion(RhinoViewport viewport,Point2d screen1,Point2d screen2,bool inside,ObjectType filter)',
        summary: 'Finds objects bounded by a region',
        since: 5.8,
        parameters: [
          {
            name: 'viewport',
            summary: 'viewport to use for selection'
          },
          {
            name: 'screen1',
            summary: 'first screen corner'
          },
          {
            name: 'screen2',
            summary: 'second screen corner'
          },
          {
            name: 'inside',
            summary: 'should objects returned be the ones inside of this region (or outside)'
          },
          {
            name: 'filter',
            summary: 'filter down list by object type'
          }
        ],
        returns: 'An array of RhinoObjects that are inside of this region'
      },
      {
        signature: 'RhinoObject[] FindByDrawColor(Color drawColor,bool includeLights)',
        summary: 'Finds all objects whose draw color matches a given color.',
        since: 5,
        parameters: [
          {
            name: 'drawColor',
            summary: 'The alpha value of this color is ignored.'
          },
          {
            name: 'includeLights',
            summary: 'True if lights should be included.'
          }
        ],
        returns: 'An array of Rhino document objects. This array can be empty.'
      },
      {
        signature: 'RhinoObject[] FindByFilter(ObjectEnumeratorSettings filter)',
        summary: 'Same as GetObjectList but converts the result to an array.',
        since: 5,
        parameters: [
          {
            name: 'filter',
            summary: 'The object enumerator filter to customize inclusion requirements.'
          }
        ],
        returns: 'A Rhino object array. This array can be emptry but not null.'
      },
      {
        signature: 'RhinoObject[] FindByGroup(int groupIndex)',
        summary: 'Finds all RhinoObjects that are in a given group.',
        since: 5,
        parameters: [
          {
            name: 'groupIndex',
            summary: 'Index of group to search for.'
          }
        ],
        returns: 'An array of objects that belong to the specified group or None if no objects could be found.'
      },
      {
        signature: 'RhinoObject[] FindByLayer(Layer layer)',
        summary: 'Finds all RhinoObjects that are in a given layer.',
        since: 5,
        parameters: [
          {
            name: 'layer',
            summary: 'Layer to search.'
          }
        ],
        returns: 'Array of objects that belong to the specified group or None if no objects could be found.'
      },
      {
        signature: 'RhinoObject[] FindByLayer(string layerName)',
        summary: 'Finds all RhinoObjects that are in a given layer.',
        since: 5,
        parameters: [
          {
            name: 'layerName',
            summary: 'Name of layer to search.'
          }
        ],
        returns: 'Array of objects that belong to the specified group or None if no objects could be found.'
      },
      {
        signature: 'RhinoObject[] FindByObjectType(ObjectType typeFilter)',
        since: 5
      },
      {
        signature: 'RhinoObject[] FindByUserString(string key,string value,bool caseSensitive)',
        summary: 'Finds all objects whose UserString matches the search patterns.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'Search pattern for UserString keys (supported wildcards are: ? = any single character, * = any sequence of characters).'
          },
          {
            name: 'value',
            summary: 'Search pattern for UserString values (supported wildcards are: ? = any single character, * = any sequence of characters).'
          },
          {
            name: 'caseSensitive',
            summary: 'If true, string comparison will be case sensitive.'
          }
        ],
        returns: 'An array of all objects whose UserString matches with the search patterns or None when no such objects could be found.'
      },
      {
        signature: 'RhinoObject[] FindByUserString(string key,string value,bool caseSensitive,bool searchGeometry,bool searchAttributes,ObjectEnumeratorSettings filter)',
        summary: 'Finds all objects whose UserString matches the search patterns.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'Search pattern for UserString keys (supported wildcards are: ? = any single character, * = any sequence of characters).'
          },
          {
            name: 'value',
            summary: 'Search pattern for UserString values (supported wildcards are: ? = any single character, * = any sequence of characters).'
          },
          {
            name: 'caseSensitive',
            summary: 'If true, string comparison will be case sensitive.'
          },
          {
            name: 'searchGeometry',
            summary: 'If true, UserStrings attached to the geometry of an object will be searched.'
          },
          {
            name: 'searchAttributes',
            summary: 'If true, UserStrings attached to the attributes of an object will be searched.'
          },
          {
            name: 'filter',
            summary: 'Filter used to restrict the number of objects searched.'
          }
        ],
        returns: 'An array of all objects whose UserString matches with the search patterns or None when no such objects could be found.'
      },
      {
        signature: 'RhinoObject[] FindByUserString(string key,string value,bool caseSensitive,bool searchGeometry,bool searchAttributes,ObjectType filter)',
        summary: 'Finds all objects whose UserString matches the search patterns.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'Search pattern for UserString keys (supported wildcards are: ? = any single character, * = any sequence of characters).'
          },
          {
            name: 'value',
            summary: 'Search pattern for UserString values (supported wildcards are: ? = any single character, * = any sequence of characters).'
          },
          {
            name: 'caseSensitive',
            summary: 'If true, string comparison will be case sensitive.'
          },
          {
            name: 'searchGeometry',
            summary: 'If true, UserStrings attached to the geometry of an object will be searched.'
          },
          {
            name: 'searchAttributes',
            summary: 'If true, UserStrings attached to the attributes of an object will be searched.'
          },
          {
            name: 'filter',
            summary: 'Object type filter.'
          }
        ],
        returns: 'An array of all objects whose UserString matches with the search patterns or None when no such objects could be found.'
      },
      {
        signature: 'RhinoObject[] FindByWindowRegion(RhinoViewport viewport,IEnumerable<Point3d> region,bool inside,ObjectType filter)',
        summary: 'Finds objects bounded by a polyline region',
        since: 5.7,
        parameters: [
          {
            name: 'viewport',
            summary: 'viewport to use for selection'
          },
          {
            name: 'region',
            summary: 'list of points that define the'
          },
          {
            name: 'inside',
            summary: 'should objects returned be the ones inside of this region (or outside)'
          },
          {
            name: 'filter',
            summary: 'filter down list by object type'
          }
        ],
        returns: 'An array of RhinoObjects that are inside of this region'
      },
      {
        signature: 'RhinoObject[] FindByWindowRegion(RhinoViewport viewport,Point2d screen1,Point2d screen2,bool inside,ObjectType filter)',
        summary: 'Finds objects bounded by a polyline region',
        since: 5.8,
        parameters: [
          {
            name: 'viewport',
            summary: 'viewport to use for selection'
          },
          {
            name: 'screen1',
            summary: 'first screen corner'
          },
          {
            name: 'screen2',
            summary: 'second screen corner'
          },
          {
            name: 'inside',
            summary: 'should objects returned be the ones inside of this region (or outside)'
          },
          {
            name: 'filter',
            summary: 'filter down list by object type'
          }
        ],
        returns: 'An array of RhinoObjects that are inside of this region'
      },
      {
        signature: 'ClippingPlaneObject[] FindClippingPlanesForViewport(RhinoViewport viewport)',
        summary: 'Finds all of the clipping plane objects that actively clip a viewport.',
        since: 5,
        parameters: [
          {
            name: 'viewport',
            summary: 'The viewport in which clipping planes are searched.'
          }
        ],
        returns: 'An array of clipping plane objects. The array can be emptry but not null.'
      },
      {
        signature: 'GeometryBase FindGeometry(Guid id)',
        summary: 'Same as FindId, but returns the Geometry property directly, if it exists.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'ID of object to search for.'
          }
        ],
        returns: 'Reference to the geometry in the rhino object with the objectId or None if no such object could be found.'
      },
      {
        signature: 'RhinoObject FindId(Guid id)',
        summary: `Uses the object guid to find a rhino object. Deleted objects cannot be found by id.
     The guid is the value that is stored on RhinoObject.Id
     In a single document, no two active objects have the same guid. If an object is
     replaced with a new object, then the guid  persists. For example, if the _Move command
     moves an object, then the moved object inherits it's guid from the starting object.
     If the Copy command copies an object, then the copy gets a new guid. This guid persists
     through file saving/openning operations. This function will not find grip objects.`,
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'ID of object to search for.'
          }
        ],
        returns: 'Reference to the rhino object with the objectId or None if no such object could be found.'
      },
      {
        signature: 'IEnumerator<RhinoObject> GetEnumerator()',
        since: 5
      },
      {
        signature: 'IEnumerable<RhinoObject> GetObjectList(ObjectEnumeratorSettings settings)',
        since: 5
      },
      {
        signature: 'IEnumerable<RhinoObject> GetObjectList(ObjectType typeFilter)',
        since: 5
      },
      {
        signature: 'IEnumerable<RhinoObject> GetObjectList(Type typeFilter)',
        since: 5
      },
      {
        signature: 'IEnumerable<T> GetObjectsByType()',
        since: 6
      },
      {
        signature: 'IEnumerable<T> GetObjectsByType(ObjectEnumeratorSettings settings)',
        since: 6
      },
      {
        signature: 'IEnumerable<RhinoObject> GetSelectedObjects(bool includeLights,bool includeGrips)',
        since: 5
      },
      {
        signature: 'ObjectType GetSelectedObjectTypes()',
        since: 6
      },
      {
        signature: 'RhinoObject GripUpdate(RhinoObject obj,bool deleteOriginal)',
        summary: `Altered grip positions on a RhinoObject are used to calculate an updated object
     that is added to the document.`,
        since: 5,
        parameters: [
          {
            name: 'obj',
            summary: 'object with modified grips to update.'
          },
          {
            name: 'deleteOriginal',
            summary: 'if true, obj is deleted from the document.'
          }
        ],
        returns: 'new RhinoObject on success; otherwise null.'
      },
      {
        signature: 'bool Hide(Guid objectId,bool ignoreLayerMode)',
        summary: 'If Object().IsNormal() is true, then the object will be hidden.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to hide.'
          },
          {
            name: 'ignoreLayerMode',
            summary: 'if true, the object will be hidden even if it is on a layer that is locked or off.'
          }
        ],
        returns: 'True if the object was successfully hidden.'
      },
      {
        signature: 'bool Hide(ObjRef objref,bool ignoreLayerMode)',
        summary: 'If objref.Object().IsNormal() is true, then the object will be hidden.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to object to hide.'
          },
          {
            name: 'ignoreLayerMode',
            summary: 'if true, the object will be hidden even if it is on a layer that is locked or off.'
          }
        ],
        returns: 'True if the object was successfully hidden.'
      },
      {
        signature: 'bool Hide(RhinoObject obj,bool ignoreLayerMode)',
        summary: 'If obj.IsNormal() is true, then the object will be hidden.',
        since: 5,
        parameters: [
          {
            name: 'obj',
            summary: 'object to hide.'
          },
          {
            name: 'ignoreLayerMode',
            summary: 'if true, the object will be hidden even if it is on a layer that is locked or off.'
          }
        ],
        returns: 'True if the object was successfully hidden.'
      },
      {
        signature: 'bool Lock(Guid objectId,bool ignoreLayerMode)',
        summary: 'If objref.Object().IsNormal() is true, then the object will be locked.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of normal object to lock.'
          },
          {
            name: 'ignoreLayerMode',
            summary: 'if true, the object will be locked even if it is on a layer that is locked or off.'
          }
        ],
        returns: 'True if the object was successfully locked.'
      },
      {
        signature: 'bool Lock(ObjRef objref,bool ignoreLayerMode)',
        summary: 'If objref.Object().IsNormal() is true, then the object will be locked.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to normal object to lock.'
          },
          {
            name: 'ignoreLayerMode',
            summary: 'if true, the object will be locked even if it is on a layer that is locked or off.'
          }
        ],
        returns: 'True if the object was successfully locked.'
      },
      {
        signature: 'bool Lock(RhinoObject obj,bool ignoreLayerMode)',
        summary: 'If obj.IsNormal() is true, then the object will be locked.',
        since: 5,
        parameters: [
          {
            name: 'obj',
            summary: 'normal object to lock.'
          },
          {
            name: 'ignoreLayerMode',
            summary: 'if true, the object will be locked even if it is on a layer that is locked or off.'
          }
        ],
        returns: 'True if the object was successfully locked.'
      },
      {
        signature: 'bool ModifyAttributes(Guid objectId,ObjectAttributes newAttributes,bool quiet)',
        summary: 'Modifies an object\'s attributes.  Cannot be used to change object id.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to modify.'
          },
          {
            name: 'newAttributes',
            summary: 'new attributes.'
          },
          {
            name: 'quiet',
            summary: 'if true, then warning message boxes are disabled.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool ModifyAttributes(ObjRef objref,ObjectAttributes newAttributes,bool quiet)',
        summary: 'Modifies an object\'s attributes.  Cannot be used to change object id.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to object to modify.'
          },
          {
            name: 'newAttributes',
            summary: 'new attributes.'
          },
          {
            name: 'quiet',
            summary: 'if true, then warning message boxes are disabled.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool ModifyAttributes(RhinoObject obj,ObjectAttributes newAttributes,bool quiet)',
        summary: 'Modifies an object\'s attributes.  Cannot be used to change object id.',
        since: 5,
        parameters: [
          {
            name: 'obj',
            summary: 'object to modify.'
          },
          {
            name: 'newAttributes',
            summary: 'new attributes.'
          },
          {
            name: 'quiet',
            summary: 'if true, then warning message boxes are disabled.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool ModifyRenderMaterial(Guid objectId,RenderMaterial material)',
        summary: `Modifies an object's render material assignment, this will set the
     objects material source to ObjectMaterialSource.MaterialFromObject.`,
        since: 5.7,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to modify.'
          },
          {
            name: 'material',
            summary: 'Material to assign to this object.'
          }
        ],
        returns: 'Returns True on success otherwise returns false.'
      },
      {
        signature: 'bool ModifyRenderMaterial(ObjRef objRef,RenderMaterial material)',
        summary: `Modifies an object's render material assignment, this will set the
     objects material source to ObjectMaterialSource.MaterialFromObject.`,
        since: 5.7,
        parameters: [
          {
            name: 'objRef',
            summary: 'Object to modify.'
          },
          {
            name: 'material',
            summary: 'Material to assign to this object.'
          }
        ],
        returns: 'Returns True on success otherwise returns false.'
      },
      {
        signature: 'bool ModifyRenderMaterial(RhinoObject obj,RenderMaterial material)',
        summary: `Modifies an object's render material assignment, this will set the
     objects material source to ObjectMaterialSource.MaterialFromObject.`,
        since: 5.7,
        parameters: [
          {
            name: 'obj',
            summary: 'Object to modify.'
          },
          {
            name: 'material',
            summary: 'Material to assign to this object.'
          }
        ],
        returns: 'Returns True on success otherwise returns false.'
      },
      {
        signature: 'bool ModifyTextureMapping(Guid objId,int channel,TextureMapping mapping)',
        since: 5.7
      },
      {
        signature: 'bool ModifyTextureMapping(ObjRef objRef,int channel,TextureMapping mapping)',
        since: 5.7
      },
      {
        signature: 'bool ModifyTextureMapping(RhinoObject obj,int channel,TextureMapping mapping)',
        since: 5.7
      },
      {
        signature: 'RhinoObject MostRecentObject()',
        summary: 'Gets the most recently added object that is still in the Document.',
        since: 5,
        returns: 'The most recent (non-deleted) object in the document, or None if no such object exists.'
      },
      {
        signature: 'int ObjectCount(ObjectEnumeratorSettings filter)',
        since: 5
      },
      {
        signature: 'ObjRef[] PickObjects(PickContext pickContext)',
        summary: 'Pick one or more objects based on a given pick context',
        since: 6,
        parameters: [
          {
            name: 'pickContext',
            summary: 'settings used to define what is picked'
          }
        ],
        returns: 'zero or more objects'
      },
      {
        signature: 'bool Purge(RhinoObject rhinoObject)',
        summary: `Removes object from document and deletes the pointer. Typically you will
     want to call Delete instead in order to keep the object on the undo list.`,
        since: 5,
        parameters: [
          {
            name: 'rhinoObject',
            summary: 'A Rhino object that will be deleted.'
          }
        ],
        returns: 'True if the object was purged; otherwise false.'
      },
      {
        signature: 'bool Purge(uint runtimeSerialNumber)',
        summary: `Removes object from document and deletes the pointer. Typically you will
     want to call Delete instead in order to keep the object on the undo list.`,
        since: 5,
        parameters: [
          {
            name: 'runtimeSerialNumber',
            summary: 'A runtime serial number of the object that will be deleted.'
          }
        ],
        returns: 'True if the object was purged; otherwise false.'
      },
      {
        signature: 'bool Replace(Guid objectId,Arc arc)',
        summary: 'Replaces one object with new curve object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'arc',
            summary: 'new arc to be added.  The arc is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,Brep brep)',
        summary: 'Replaces one object with new brep object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'brep',
            summary: `new surface to be added
     A duplicate of the brep is added to the Rhino model.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,Brep brep,bool splitKinkySurfaces)',
        since: 6.1
      },
      {
        signature: 'bool Replace(Guid objectId,Circle circle)',
        summary: 'Replaces one object with new curve object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'circle',
            summary: 'new circle to be added.  The circle is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,Curve curve)',
        summary: 'Replaces one object with new curve object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'curve',
            summary: 'New curve to be added. A duplicate of the curve is added to the Rhino model.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,Extrusion extrusion)',
        summary: 'Replaces one object with new extrusion object.',
        since: 6,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'extrusion',
            summary: 'New extrusion to be added. A duplicate of the extrusion is added to the Rhino model.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,Hatch hatch)',
        summary: 'Replaces one object with new hatch object.',
        since: 6.1,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'hatch',
            summary: 'new hatch to be added. The hatch is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,Leader leader)',
        summary: 'Replaces one object with new text object.',
        since: 6,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'leader',
            summary: 'new leader to be added.  The leader is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,Line line)',
        summary: 'Replaces one object with new line curve object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'line',
            summary: 'new line to be added.  The line is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,Mesh mesh)',
        summary: 'Replaces one object with new mesh object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'mesh',
            summary: `new mesh to be added
     A duplicate of the mesh is added to the Rhino model.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,Point point)',
        summary: 'Replaces one object with new point object.',
        since: 6,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'point',
            summary: 'new point to be added.  The point is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,Point3d point)',
        summary: 'Replaces one object with new point object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'point',
            summary: 'new point to be added.  The point is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,PointCloud pointcloud)',
        summary: 'Replaces one object with new pointcloud object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'pointcloud',
            summary: `new pointcloud to be added
     A duplicate of the pointcloud is added to the Rhino model.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,Polyline polyline)',
        summary: 'Replaces one object with new curve object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'polyline',
            summary: 'new polyline to be added.  The polyline is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,SubD subD)',
        summary: 'Replaces one object with new subd object.',
        since: 7,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'subD',
            summary: `new mesh to be added
     A duplicate of the mesh is added to the Rhino model.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,Surface surface)',
        summary: 'Replaces one object with new surface object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'surface',
            summary: `new surface to be added
     A duplicate of the surface is added to the Rhino model.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,TextDot dot)',
        summary: 'Replaces one object with new textdot object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'dot',
            summary: 'new textdot to be added.  The textdot is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(Guid objectId,TextEntity text)',
        summary: 'Replaces one object with new text object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to be replaced.'
          },
          {
            name: 'text',
            summary: 'new text to be added.  The text is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,Arc arc)',
        summary: 'Replaces one object with new curve object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'Reference to old object to be replaced. The object objref.Object() will be deleted.'
          },
          {
            name: 'arc',
            summary: 'new arc to be added.  The arc is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,Brep brep)',
        summary: 'Replaces one object with new brep object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to old object to be replaced. The objref.Object() will be deleted.'
          },
          {
            name: 'brep',
            summary: `new brep to be added
     A duplicate of the brep is added to the Rhino model.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,Brep brep,bool splitKinkySurfaces)',
        since: 6.1
      },
      {
        signature: 'bool Replace(ObjRef objref,Circle circle)',
        summary: 'Replaces one object with new curve object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'Reference to old object to be replaced. The object objref.Object() will be deleted.'
          },
          {
            name: 'circle',
            summary: 'new circle to be added.  The circle is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,Curve curve)',
        summary: 'Replaces one object with new curve object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to old object to be replaced. The objref.Object() will be deleted.'
          },
          {
            name: 'curve',
            summary: 'New curve to be added. A duplicate of the curve is added to the Rhino model.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,Extrusion extrusion)',
        summary: 'Replaces one object with new extrusion object.',
        since: 6,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to old object to be replaced. The objref.Object() will be deleted.'
          },
          {
            name: 'extrusion',
            summary: 'New extrusion to be added. A duplicate of the extrusion is added to the Rhino model.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,Hatch hatch)',
        summary: 'Replaces one object with new hatch object.',
        since: 6.1,
        parameters: [
          {
            name: 'objref',
            summary: 'Reference to old object to be replaced. The object objref.Object() will be deleted.'
          },
          {
            name: 'hatch',
            summary: 'new hatch to be added. The hatch is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,Leader leader)',
        summary: 'Replaces one object with new text object.',
        since: 6,
        parameters: [
          {
            name: 'objref',
            summary: 'Reference to old object to be replaced. The object objref.Object() will be deleted.'
          },
          {
            name: 'leader',
            summary: 'new leader to be added.  The leader is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,Line line)',
        summary: 'Replaces one object with new line curve object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'Reference to old object to be replaced. The object objref.Object() will be deleted.'
          },
          {
            name: 'line',
            summary: 'new line to be added.  The line is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,Mesh mesh)',
        summary: 'Replaces one object with new mesh object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to old object to be replaced. The objref.Object() will be deleted.'
          },
          {
            name: 'mesh',
            summary: `new mesh to be added
     A duplicate of the mesh is added to the Rhino model.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,Point point)',
        summary: 'Replaces one object with new point object.',
        since: 6,
        parameters: [
          {
            name: 'objref',
            summary: 'Reference to old object to be replaced. The object objref.Object() will be deleted.'
          },
          {
            name: 'point',
            summary: 'new point to be added.  The point is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,Point3d point)',
        summary: 'Replaces one object with new point object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'Reference to old object to be replaced. The object objref.Object() will be deleted.'
          },
          {
            name: 'point',
            summary: 'new point to be added.  The point is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,PointCloud pointcloud)',
        summary: 'Replaces one object with new pointcloud object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to old object to be replaced. The objref.Object() will be deleted.'
          },
          {
            name: 'pointcloud',
            summary: `new pointcloud to be added
     A duplicate of the pointcloud is added to the Rhino model.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,Polyline polyline)',
        summary: 'Replaces one object with new curve object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'Reference to old object to be replaced. The object objref.Object() will be deleted.'
          },
          {
            name: 'polyline',
            summary: 'new polyline to be added.  The polyline is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,RhinoObject newObject)',
        summary: `Replaces one object with another. Conceptually, this function is the same as calling
     Setting new_object attributes = old_object attributes
     DeleteObject(old_object);
     AddObject(old_object);`,
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to old object to be replaced. The objref.Object() will be deleted.'
          },
          {
            name: 'newObject',
            summary: 'new replacement object - must not be in document.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,SubD subD)',
        summary: 'Replaces one object with a new SubD object.',
        since: 7,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to old object to be replaced. The objref.Object() will be deleted.'
          },
          {
            name: 'subD',
            summary: `new SubD to be added
     A duplicate of the SubD is added to the Rhino model.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,Surface surface)',
        summary: 'Replaces one object with new surface object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to old object to be replaced. The objref.Object() will be deleted.'
          },
          {
            name: 'surface',
            summary: `new surface to be added
     A duplicate of the surface is added to the Rhino model.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,TextDot dot)',
        summary: 'Replaces one object with new textdot object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'Reference to old object to be replaced. The object objref.Object() will be deleted.'
          },
          {
            name: 'dot',
            summary: 'new textdot to be added.  The textdot is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Replace(ObjRef objref,TextEntity text)',
        summary: 'Replaces one object with new text object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'Reference to old object to be replaced. The object objref.Object() will be deleted.'
          },
          {
            name: 'text',
            summary: 'new text to be added.  The text is copied.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool ReplaceInstanceObject(Guid objectId,int instanceDefinitionIndex)',
        summary: 'Replaces the underlying instance definition of an instance object.',
        since: 6.8,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of the instance object to be replaced.'
          },
          {
            name: 'instanceDefinitionIndex',
            summary: 'The index of the new instance definition to use.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool ReplaceInstanceObject(ObjRef objref,int instanceDefinitionIndex)',
        summary: 'Replaces the underlying instance definition of an instance object.',
        since: 6.8,
        parameters: [
          {
            name: 'objref',
            summary: 'Reference to the instance object to be replaced. The objref.Object() will be deleted.'
          },
          {
            name: 'instanceDefinitionIndex',
            summary: 'The index of the new instance definition to use.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool Select(Guid objectId)',
        summary: 'Select a single object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to select.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Select(Guid objectId,bool select)',
        summary: 'Select or deselects a single object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to select.'
          },
          {
            name: 'select',
            summary: 'If true, the object will be selected, if false, it will be deselected.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Select(Guid objectId,bool select,bool syncHighlight)',
        summary: 'Select or deselects a single object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to select.'
          },
          {
            name: 'select',
            summary: 'If true, the object will be selected, if false, it will be deselected.'
          },
          {
            name: 'syncHighlight',
            summary: `If true, then the object is highlighted if it is selected 
     and unhighlighted if is is not selected.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Select(Guid objectId,bool select,bool syncHighlight,bool persistentSelect)',
        summary: 'Select or deselects a single object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to select.'
          },
          {
            name: 'select',
            summary: 'If true, the object will be selected, if false, it will be deselected.'
          },
          {
            name: 'syncHighlight',
            summary: `If true, then the object is highlighted if it is selected 
     and unhighlighted if is is not selected.`
          },
          {
            name: 'persistentSelect',
            summary: 'Objects that are persistently selected stay selected when a command terminates.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Select(Guid objectId,bool select,bool syncHighlight,bool persistentSelect,bool ignoreGripsState,bool ignoreLayerLocking,bool ignoreLayerVisibility)',
        summary: 'Select or deselects a single object.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of object to select.'
          },
          {
            name: 'select',
            summary: 'If true, the object will be selected, if false, it will be deselected.'
          },
          {
            name: 'syncHighlight',
            summary: `If true, then the object is highlighted if it is selected 
     and unhighlighted if is is not selected.`
          },
          {
            name: 'persistentSelect',
            summary: 'Objects that are persistently selected stay selected when a command terminates.'
          },
          {
            name: 'ignoreGripsState',
            summary: `If true, then objects with grips on can be selected.
     If false, then the value returned by the object's IsSelectableWithGripsOn() function
     decides if the object can be selected when it has grips turned on.`
          },
          {
            name: 'ignoreLayerLocking',
            summary: 'If true, then objects on locked layers can be selected.'
          },
          {
            name: 'ignoreLayerVisibility',
            summary: 'If true, then objects on hidden layers can be selectable.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'int Select(IEnumerable<Guid> objectIds)',
        summary: 'Selects a collection of objects.',
        since: 5,
        parameters: [
          {
            name: 'objectIds',
            summary: 'Ids of objects to select.'
          }
        ],
        returns: 'Number of objects successfully selected.'
      },
      {
        signature: 'int Select(IEnumerable<Guid> objectIds,bool select)',
        summary: 'Selects or deselects a collection of objects.',
        since: 5,
        parameters: [
          {
            name: 'objectIds',
            summary: 'Ids of objects to select or deselect.'
          },
          {
            name: 'select',
            summary: `If true, objects will be selected. 
     If false, objects will be deselected.`
          }
        ],
        returns: 'Number of objects successfully selected or deselected.'
      },
      {
        signature: 'int Select(IEnumerable<ObjRef> objRefs)',
        summary: 'Selects a collection of objects.',
        since: 5,
        parameters: [
          {
            name: 'objRefs',
            summary: 'References to objects to select.'
          }
        ],
        returns: 'Number of objects successfully selected.'
      },
      {
        signature: 'int Select(IEnumerable<ObjRef> objRefs,bool select)',
        summary: 'Selects or deselects a collection of objects.',
        since: 5,
        parameters: [
          {
            name: 'objRefs',
            summary: 'References to objects to select or deselect.'
          },
          {
            name: 'select',
            summary: `If true, objects will be selected. 
     If false, objects will be deselected.`
          }
        ],
        returns: 'Number of objects successfully selected or deselected.'
      },
      {
        signature: 'bool Select(ObjRef objref)',
        summary: 'Select a single object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'Object represented by this ObjRef is selected.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Select(ObjRef objref,bool select)',
        summary: 'Select or deselects a single object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'Object represented by this ObjRef is selected.'
          },
          {
            name: 'select',
            summary: 'If true, the object will be selected, if false, it will be deselected.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Select(ObjRef objref,bool select,bool syncHighlight)',
        summary: 'Select or deselects a single object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'Object represented by this ObjRef is selected.'
          },
          {
            name: 'select',
            summary: 'If true, the object will be selected, if false, it will be deselected.'
          },
          {
            name: 'syncHighlight',
            summary: `If true, then the object is highlighted if it is selected 
     and unhighlighted if is is not selected.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Select(ObjRef objref,bool select,bool syncHighlight,bool persistentSelect)',
        summary: 'Select or deselects a single object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'Object represented by this ObjRef is selected.'
          },
          {
            name: 'select',
            summary: 'If true, the object will be selected, if false, it will be deselected.'
          },
          {
            name: 'syncHighlight',
            summary: `If true, then the object is highlighted if it is selected 
     and unhighlighted if is is not selected.`
          },
          {
            name: 'persistentSelect',
            summary: 'Objects that are persistently selected stay selected when a command terminates.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Select(ObjRef objref,bool select,bool syncHighlight,bool persistentSelect,bool ignoreGripsState,bool ignoreLayerLocking,bool ignoreLayerVisibility)',
        summary: 'Select or deselects a single object.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'Object represented by this ObjRef is selected.'
          },
          {
            name: 'select',
            summary: 'If true, the object will be selected, if false, it will be deselected.'
          },
          {
            name: 'syncHighlight',
            summary: `If true, then the object is highlighted if it is selected 
     and unhighlighted if is is not selected.`
          },
          {
            name: 'persistentSelect',
            summary: 'Objects that are persistently selected stay selected when a command terminates.'
          },
          {
            name: 'ignoreGripsState',
            summary: `If true, then objects with grips on can be selected.
     If false, then the value returned by the object's IsSelectableWithGripsOn() function
     decides if the object can be selected when it has grips turned on.`
          },
          {
            name: 'ignoreLayerLocking',
            summary: 'If true, then objects on locked layers can be selected.'
          },
          {
            name: 'ignoreLayerVisibility',
            summary: 'If true, then objects on hidden layers can be selectable.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Show(Guid objectId,bool ignoreLayerMode)',
        summary: 'If Object().IsHidden() is true, then the object will be returned to normal (visible and selectable) mode.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of the normal object to show.'
          },
          {
            name: 'ignoreLayerMode',
            summary: 'if true, the object will be shown even if it is on a layer that is locked or off.'
          }
        ],
        returns: 'True if the object was successfully shown.'
      },
      {
        signature: 'bool Show(ObjRef objref,bool ignoreLayerMode)',
        summary: 'If objref.Object().IsHidden() is true, then the object will be returned to normal (visible and selectable) mode.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to normal object to show.'
          },
          {
            name: 'ignoreLayerMode',
            summary: 'if true, the object will be shown even if it is on a layer that is locked or off.'
          }
        ],
        returns: 'True if the object was successfully shown.'
      },
      {
        signature: 'bool Show(RhinoObject obj,bool ignoreLayerMode)',
        summary: 'If obj.IsHidden() is true, then the object will be returned to normal (visible and selectable) mode.',
        since: 5,
        parameters: [
          {
            name: 'obj',
            summary: 'the normal object to show.'
          },
          {
            name: 'ignoreLayerMode',
            summary: 'if true, the object will be shown even if it is on a layer that is locked or off.'
          }
        ],
        returns: 'True if the object was successfully shown.'
      },
      {
        signature: 'Guid Transform(Guid objectId,Transform xform,bool deleteOriginal)',
        summary: `Constructs a new object that is the transformation of the existing object
     and deletes the existing object if deleteOriginal is true.`,
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of rhino object to transform. This object will be deleted if deleteOriginal is true.'
          },
          {
            name: 'xform',
            summary: 'transformation to apply.'
          },
          {
            name: 'deleteOriginal',
            summary: `if true, the original object is deleted
     if false, the original object is not deleted.`
          }
        ],
        returns: `Id of the new object that is the transformation of the existing_object.
     The new object has identical attributes.`
      },
      {
        signature: 'Guid Transform(ObjRef objref,Transform xform,bool deleteOriginal)',
        summary: `Constructs a new object that is the transformation of the existing object
     and deletes the existing object if deleteOriginal is true.`,
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to object to transform. The objref.Object() will be deleted if deleteOriginal is true.'
          },
          {
            name: 'xform',
            summary: 'transformation to apply.'
          },
          {
            name: 'deleteOriginal',
            summary: `if true, the original object is deleted
     if false, the original object is not deleted.`
          }
        ],
        returns: `Id of the new object that is the transformation of the existing_object.
     The new object has identical attributes.`
      },
      {
        signature: 'Guid Transform(RhinoObject obj,Transform xform,bool deleteOriginal)',
        summary: `Constructs a new object that is the transformation of the existing object
     and deletes the existing object if deleteOriginal is true.`,
        since: 5,
        parameters: [
          {
            name: 'obj',
            summary: 'Rhino object to transform. This object will be deleted if deleteOriginal is true.'
          },
          {
            name: 'xform',
            summary: 'transformation to apply.'
          },
          {
            name: 'deleteOriginal',
            summary: `if true, the original object is deleted
     if false, the original object is not deleted.`
          }
        ],
        returns: `Id of the new object that is the transformation of the existing_object.
     The new object has identical attributes.`
      },
      {
        signature: 'Guid TransformWithHistory(Guid objectId,Transform xform)',
        summary: `Constructs a new object that is the transformation of the existing object
     and records history of the transformation if history recording is turned on.
     If history recording is not enabled, this function will act the same as
     Transform(objectId, xform, false)`,
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of rhino object to transform.'
          },
          {
            name: 'xform',
            summary: 'transformation to apply.'
          }
        ],
        returns: `Id of the new object that is the transformation of the existing_object.
     The new object has identical attributes.`
      },
      {
        signature: 'Guid TransformWithHistory(ObjRef objref,Transform xform)',
        summary: `Constructs a new object that is the transformation of the existing object
     and records history of the transformation if history recording is turned on.
     If history recording is not enabled, this function will act the same as
     Transform(objref, xform, false)`,
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to object to transform.'
          },
          {
            name: 'xform',
            summary: 'transformation to apply.'
          }
        ],
        returns: `Id of the new object that is the transformation of the existing_object.
     The new object has identical attributes.`
      },
      {
        signature: 'Guid TransformWithHistory(RhinoObject obj,Transform xform)',
        summary: `Constructs a new object that is the transformation of the existing object
     and records history of the transformation if history recording is turned on.
     If history recording is not enabled, this function will act the same as
     Transform(obj, xform, false)`,
        since: 5,
        parameters: [
          {
            name: 'obj',
            summary: 'Rhino object to transform.'
          },
          {
            name: 'xform',
            summary: 'transformation to apply.'
          }
        ],
        returns: `Id of the new object that is the transformation of the existing_object.
     The new object has identical attributes.`
      },
      {
        signature: 'bool TryFindPoint(Guid id,Point3d point)',
        summary: 'Finds the location of a point, if a point exists in the document.',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'ID of point object to search for.'
          },
          {
            name: 'point',
            summary: 'The point will be passed here.'
          }
        ],
        returns: 'True on success; False if point was not found, id represented another geometry type, or on error.'
      },
      {
        signature: 'bool Undelete(RhinoObject rhinoObject)',
        since: 5
      },
      {
        signature: 'bool Undelete(uint runtimeSerialNumber)',
        since: 5
      },
      {
        signature: 'bool Unlock(Guid objectId,bool ignoreLayerMode)',
        summary: 'If Object().IsLocked() is true, then the object will be returned to normal (visible and selectable) mode.',
        since: 5,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of locked object to unlock.'
          },
          {
            name: 'ignoreLayerMode',
            summary: 'if true, the object will be unlocked even if it is on a layer that is locked or off.'
          }
        ],
        returns: 'True if the object was successfully unlocked.'
      },
      {
        signature: 'bool Unlock(ObjRef objref,bool ignoreLayerMode)',
        summary: 'If objref.Object().IsLocked() is true, then the object will be returned to normal (visible and selectable) mode.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'reference to locked object to unlock.'
          },
          {
            name: 'ignoreLayerMode',
            summary: 'if true, the object will be unlocked even if it is on a layer that is locked or off.'
          }
        ],
        returns: 'True if the object was successfully unlocked.'
      },
      {
        signature: 'bool Unlock(RhinoObject obj,bool ignoreLayerMode)',
        summary: 'If obj.IsLocked() is true, then the object will be returned to normal (visible and selectable) mode.',
        since: 5,
        parameters: [
          {
            name: 'obj',
            summary: 'locked object to unlock.'
          },
          {
            name: 'ignoreLayerMode',
            summary: 'if true, the object will be unlocked even if it is on a layer that is locked or off.'
          }
        ],
        returns: 'True if the object was successfully unlocked.'
      },
      {
        signature: 'int UnselectAll()',
        summary: 'Unselect objects.',
        since: 5,
        returns: 'Number of object that were unselected.'
      },
      {
        signature: 'int UnselectAll(bool ignorePersistentSelections)',
        summary: 'Unselect objects.',
        since: 5,
        parameters: [
          {
            name: 'ignorePersistentSelections',
            summary: 'if true, then objects that are persistently selected will not be unselected.'
          }
        ],
        returns: 'Number of object that were unselected.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'RestoreLayerProperties',
    dataType: 3,
    values: [
      {
        signature: 'None = 0x0',
        summary: 'Restore nothing'
      },
      {
        signature: 'Current = 0x1',
        summary: 'Restore current layer'
      },
      {
        signature: 'Visible = 0x2',
        summary: 'Restore layer visibility'
      },
      {
        signature: 'Locked = 0x4',
        summary: 'Restore layer locked status'
      },
      {
        signature: 'Color = 0x8',
        summary: 'Restore layer color'
      },
      {
        signature: 'Linetype = 0x10',
        summary: 'Restore layer linetype'
      },
      {
        signature: 'PrintColor = 0x20',
        summary: 'Restore layer print color'
      },
      {
        signature: 'PrintWidth = 0x40',
        summary: 'Restore layer print width'
      },
      {
        signature: 'ViewportVisible = 0x80',
        summary: 'Restore per-viewport layer visibility'
      },
      {
        signature: 'ViewportColor = 0x100',
        summary: 'Restore per-viewport layer color'
      },
      {
        signature: 'ViewportPrintColor = 0x200',
        summary: 'Restore per-viewport layer print color'
      },
      {
        signature: 'ViewportPrintWidth = 0x400',
        summary: 'Restore per-viewport layer print width'
      },
      {
        signature: 'RenderMaterial = 0x800',
        summary: 'Restore render material'
      },
      {
        signature: 'Unused = 0x1000',
        summary: 'Unused flag'
      },
      {
        signature: 'All = 0xFFFFFFFF',
        summary: 'Restore all layer properties'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'RhinoDocCommonTable',
    dataType: 1,
    baseclass: 'CommonComponentTable<T>',
    properties: [
      {
        signature: 'RhinoDoc Document',
        summary: 'Document that owns this table.',
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'RuntimeDocumentDataTable',
    dataType: 1,
    summary: `Collection of document runtime data. This is a good place to
   put non-serialized, per document data.`,
    baseclass: 'Dictionary<object, object>',
    properties: [
      {
        signature: 'RhinoDoc Document',
        since: 6.3,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'T GetValue(object key,Func<RhinoDoc, T> newT)',
        summary: `Checks the dictionary for the specified key, if found and the value is not
     None then then the value is returned.  If the key is not found or its value
     is None then newT(Document) is called to create a new value instnce which
     is put in the dictionary and returned.`,
        parameters: [
          {
            name: 'key',
            summary: 'Key to search for.'
          },
          {
            name: 'newT',
            summary: 'Function called to create new value'
          }
        ],
        returns: `Returns the document specific instance of type T using the specified
     dictionary key.`
      },
      {
        signature: 'T TryGetValue(object key)',
        summary: `Check dictionary for value and return it properly cast if
     found.`,
        since: 6.15,
        parameters: [
          {
            name: 'key',
            summary: 'Key to search for.'
          }
        ],
        returns: `Returns the document specific instance of type T using the specified
     dictionary key or None if not found.`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'SnapshotTable',
    dataType: 1,
    summary: 'All snapshots in a rhino document.',
    properties: [
      {
        signature: 'RhinoDoc Document',
        summary: 'Document that owns this table.',
        since: 6.7,
        property: ['get']
      },
      {
        signature: 'string[] Names',
        summary: 'Array of Snapshot names.',
        since: 6.7,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'StringTable',
    dataType: 1,
    summary: 'Collection of document user data strings',
    properties: [
      {
        signature: 'int Count',
        summary: 'The number of user data strings in the current document.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'Document that owns this object table.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int DocumentDataCount',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int DocumentUserTextCount',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Delete(string key)',
        since: 5
      },
      {
        signature: 'void Delete(string section,string entry)',
        summary: 'Removes user data strings from the document.',
        since: 5,
        parameters: [
          {
            name: 'section',
            summary: 'name of section to delete. If null, all sections will be deleted.'
          },
          {
            name: 'entry',
            summary: 'name of entry to delete. If null, all entries will be deleted for a given section.'
          }
        ]
      },
      {
        signature: 'string[] GetEntryNames(string section)',
        summary: 'Return list of all entry names for a given section of user data strings in the document.',
        since: 5,
        parameters: [
          {
            name: 'section',
            summary: 'The section from which to retrieve section names.'
          }
        ],
        returns: 'An array of section names. This can be empty, but not null.'
      },
      {
        signature: 'string GetKey(int i)',
        since: 5
      },
      {
        signature: 'string[] GetSectionNames()',
        summary: `Returns a list of all the section names for user data strings in the document.
     By default a section name is a key that is prefixed with a string separated by a backslash.`,
        since: 5,
        returns: 'An array of section names. This can be empty, but not null.'
      },
      {
        signature: 'string GetValue(int i)',
        since: 5
      },
      {
        signature: 'string GetValue(string key)',
        since: 5
      },
      {
        signature: 'string GetValue(string section,string entry)',
        summary: 'Gets a user data string from the document.',
        since: 5,
        parameters: [
          {
            name: 'section',
            summary: 'The section at which to get the value.'
          },
          {
            name: 'entry',
            summary: 'The entry to search for.'
          }
        ],
        returns: 'The user data.'
      },
      {
        signature: 'string SetString(string key,string value)',
        summary: 'Adds or sets a user data string to the document.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The key.'
          },
          {
            name: 'value',
            summary: 'The entry value.'
          }
        ],
        returns: 'The previous value if successful and a previous value existed.'
      },
      {
        signature: 'string SetString(string section,string entry,string value)',
        summary: 'Adds or sets a user data string to the document.',
        since: 5,
        parameters: [
          {
            name: 'section',
            summary: 'The section.'
          },
          {
            name: 'entry',
            summary: 'The entry name.'
          },
          {
            name: 'value',
            summary: 'The entry value.'
          }
        ],
        returns: 'The previous value if successful and a previous value existed.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects.Tables',
    name: 'ViewTable',
    dataType: 1,
    interfaces: ['IEnumerable<RhinoView>'],
    properties: [
      {
        signature: 'RhinoView ActiveView',
        summary: 'Gets or Sets the active view.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'Document that owns this object table.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool ModelSpaceIsActive',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool RedrawEnabled',
        summary: 'Returns or sets (enable or disables) screen redrawing.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'RhinoView Add(string title,DefinedViewportProjection projection,Rectangle position,bool floating)',
        summary: 'Constructs a new Rhino view and, at the same time, adds it to the list.',
        since: 5,
        parameters: [
          {
            name: 'title',
            summary: 'The title of the new Rhino view.'
          },
          {
            name: 'projection',
            summary: 'A basic projection type.'
          },
          {
            name: 'position',
            summary: 'A position.'
          },
          {
            name: 'floating',
            summary: 'True if the view floats; False if it is docked.'
          }
        ],
        returns: 'The newly constructed Rhino view; or None on error.'
      },
      {
        signature: 'RhinoPageView AddPageView(string title)',
        summary: 'Constructs a new page view with a given title and, at the same time, adds it to the list.',
        since: 5,
        parameters: [
          {
            name: 'title',
            summary: 'If None or empty, a name will be generated as "Page #" where # is the largest page number.'
          }
        ],
        returns: 'The newly created page view on success; or None on error.'
      },
      {
        signature: 'RhinoPageView AddPageView(string title,double pageWidth,double pageHeight)',
        summary: 'Constructs a new page view with a given title and size and, at the same time, adds it to the list.',
        since: 5,
        parameters: [
          {
            name: 'title',
            summary: 'If None or empty, a name will be generated as "Page #" where # is the largest page number.'
          },
          {
            name: 'pageWidth',
            summary: 'The page total width.'
          },
          {
            name: 'pageHeight',
            summary: 'The page total height.'
          }
        ],
        returns: 'The newly created page view on success; or None on error.'
      },
      {
        signature: 'void DefaultViewLayout()',
        since: 5
      },
      {
        signature: 'void EnableCameraIcon(RhinoView view)',
        summary: 'Use to turn camera icon on and off',
        since: 6,
        parameters: [
          {
            name: 'view',
            summary: `If null, any camera icon is turned off. If not null, the camera icon for that
     view is turned on.`
          }
        ]
      },
      {
        signature: 'RhinoView Find(Guid mainViewportId)',
        summary: 'Finds a view in this document with a given main viewport Id.',
        since: 5,
        parameters: [
          {
            name: 'mainViewportId',
            summary: 'The ID of the main viewport looked for.'
          }
        ],
        returns: 'View on success. None if the view could not be found in this document.'
      },
      {
        signature: 'RhinoView Find(string mainViewportName,bool compareCase)',
        summary: `Finds a view in this document with a main viewport that has a given name. Note that there
     may be multiple views in this document that have the same name. This function only returns
     the first view found. If you want to find all the views with a given name, use the GetViewList
     function and iterate through the views.`,
        since: 5,
        parameters: [
          {
            name: 'mainViewportName',
            summary: 'The name of the main viewport.'
          },
          {
            name: 'compareCase',
            summary: 'True if capitalization influences comparison; otherwise, false.'
          }
        ],
        returns: 'A Rhino view on success; None on error.'
      },
      {
        signature: 'void FlashObjects(IEnumerable<RhinoObject> list,bool useSelectionColor)',
        summary: `Cause objects selection state to change momentarily so the object
     appears to flash on the screen.`,
        since: 5,
        parameters: [
          {
            name: 'list',
            summary: 'An array, a list or any enumerable set of Rhino objects.'
          },
          {
            name: 'useSelectionColor',
            summary: `If true, flash between object color and selection color. If false,
     flash between visible and invisible.`
          }
        ]
      },
      {
        signature: 'void FourViewLayout(bool useMatchingViews)',
        since: 5
      },
      {
        signature: 'IEnumerator<RhinoView> GetEnumerator()',
        since: 5
      },
      {
        signature: 'RhinoPageView[] GetPageViews()',
        summary: 'Gets all page views in the document.',
        since: 5,
        returns: 'An array with all page views. The return value can be an empty array but not null.'
      },
      {
        signature: 'RhinoView[] GetStandardRhinoViews()',
        since: 5
      },
      {
        signature: 'RhinoView[] GetViewList(bool includeStandardViews,bool includePageViews)',
        summary: 'Gets an array of all the views.',
        since: 5,
        parameters: [
          {
            name: 'includeStandardViews',
            summary: 'True if "Right", "Perspective", etc., view should be included; False otherwise.'
          },
          {
            name: 'includePageViews',
            summary: 'True if page-related views should be included; False otherwise.'
          }
        ],
        returns: 'A array of Rhino views. This array can be emptry, but not null.'
      },
      {
        signature: 'bool IsCameraIconVisible(RhinoView view)',
        summary: 'Determine if a camera icon is being shown',
        since: 6,
        parameters: [
          {
            name: 'view',
            summary: 'if null, then all views are tested. If not null, then just view is tested.'
          }
        ]
      },
      {
        signature: 'void Redraw()',
        summary: 'Redraws all views.',
        since: 5
      },
      {
        signature: 'void ThreeViewLayout(bool useMatchingViews)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'TextDisplayAlignment',
    dataType: 3,
    summary: 'Defines enumerated values for the line alignment of text.',
    values: [
      {
        signature: 'Normal = 0',
        summary: 'Normal alignment.'
      },
      {
        signature: 'Horizontal = 1',
        summary: 'Horizontal alignment.'
      },
      {
        signature: 'AboveLine = 2',
        summary: 'Above line alignment.'
      },
      {
        signature: 'InLine = 3',
        summary: 'In line alignment.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'TextDotObject',
    dataType: 1,
    summary: 'Represents a text dot that is a document.',
    baseclass: 'Rhino.DocObjects.RhinoObject'
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'TextHorizontalAlignment',
    dataType: 3,
    summary: 'Horizontal location of text attach point relative to text',
    values: [
      {
        signature: 'Left = 0',
        summary: 'Attach at left of text lines (Independent of glyphs being displayed.)'
      },
      {
        signature: 'Center = 1',
        summary: 'Attach point at center of text horizontal advance (not glyph bounding box)'
      },
      {
        signature: 'Right = 2',
        summary: 'Attach point at right text horizontal advance (not glyph bounding box)'
      },
      {
        signature: 'Auto = 3',
        summary: `Used for Leaders only
     Attach point adjusts to Right or Left depending on leader tail direction in view
     If tail direction is to the Left, alignment is Right
     If tail direction is to the Right, alignment is Left`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'TextObject',
    dataType: 1,
    summary: 'Rhino Object that represents text geometry and attributes',
    baseclass: 'Rhino.DocObjects.AnnotationObjectBase',
    properties: [
      {
        signature: 'TextEntity TextGeometry',
        summary: 'Get the text geometry for this object.',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'TextOrientation',
    dataType: 3,
    summary: 'Method for getting rotation for drawing text',
    values: [
      {
        signature: 'InPlane = 0',
        summary: 'Text has fixed rotation on a world coordinate plane'
      },
      {
        signature: 'InView = 1',
        summary: 'Text is drawn on a plane perpendicular to view direction horizontal to the screen'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'Texture',
    dataType: 1,
    summary: 'Represents a texture that is mapped on objects.',
    baseclass: 'Rhino.Runtime.CommonObject',
    constructors: [
      {
        signature: 'Texture()',
        summary: 'Initializes a new texture.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'bool ApplyUvwTransform',
        summary: `If True then the UVW transform is applied to the texture
     otherwise the UVW transform is ignored.`,
        since: 5.6,
        property: ['get', 'set']
      },
      {
        signature: 'bool Enabled',
        summary: `If the texture is enabled then it will be visible in the rendered
     display otherwise it will not.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string FileName',
        summary: `Gets or sets a file name that is used by this texture.
     NOTE: We are moving away from string-based FileName, and suggest
     the usage of the new FileReference class.Also, this filename may well not be a path that makes sense
     on a user's computer because it was a path initially set on
     a different user's computer. If you want to get a workable path
     for this user, use the BitmapTable.Find function using this
     property.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'FileReference FileReference',
        summary: `Gets or sets a copy of the file reference that is used by this texture.
     After the get or the set method complete,
     you own the copy you received or passed in, and can Dispose() of it.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Guid Id',
        summary: 'Gets the globally unique identifier of this texture.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int MappingChannelId',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'TextureCombineMode TextureCombineMode',
        summary: `Determines how this texture is combined with others in a material's
     texture list.`,
        since: 5.6,
        property: ['get', 'set']
      },
      {
        signature: 'TextureType TextureType',
        summary: 'Controls how the pixels in the bitmap are interpreted',
        since: 5.6,
        property: ['get', 'set']
      },
      {
        signature: 'Transform UvwTransform',
        summary: `Transform to be applied to each instance of this texture
     if ApplyUvw is true`,
        since: 5.6,
        property: ['get', 'set']
      },
      {
        signature: 'TextureUvwWrapping WrapU',
        summary: 'Texture wrapping mode in the U direction',
        since: 5.6,
        property: ['get', 'set']
      },
      {
        signature: 'TextureUvwWrapping WrapV',
        summary: 'Texture wrapping mode in the V direction',
        since: 5.6,
        property: ['get', 'set']
      },
      {
        signature: 'TextureUvwWrapping WrapW',
        summary: 'Texture wrapping mode in the W direction',
        since: 5.6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void GetAlphaBlendValues(double constant,double a0,double a1,double a2,double a3)',
        summary: `If the TextureCombineMode is Blend, then the blending function
     for alpha is determined by
     
     new alpha = constant
                 + a0*(current alpha)
                 + a1*(texture alpha)
                 + a2*min(current alpha,texture alpha)
                 + a3*max(current alpha,texture alpha)`,
        since: 5.6
      },
      {
        signature: 'void SetAlphaBlendValues(double constant,double a0,double a1,double a2,double a3)',
        summary: `If the TextureCombineMode is Blend, then the blending function
     for alpha is determined by
     
     new alpha = constant
                 + a0*(current alpha)
                 + a1*(texture alpha)
                 + a2*min(current alpha,texture alpha)
                 + a3*max(current alpha,texture alpha)`,
        since: 5.6
      },
      {
        signature: 'void SetRGBBlendValues(Color color,double a0,double a1,double a2,double a3)',
        summary: `If the TextureCombineMode is Blend, then the blending function
     for RGB is determined by
     
     new rgb = colorcolor
             + a0[0]*(current RGB)
             + a1[1]*(texture RGB)
             + a2[2]*min(current RGB,texture RGB)
             + a3[3]*max(current RGB,texture RGB)`,
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'TextureCombineMode',
    dataType: 3,
    summary: `Determines how this texture is combined with others in a material's
   texture list.`,
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'Modulate = 1',
        summary: 'Modulate with material diffuse color'
      },
      {
        signature: 'Decal = 2',
        summary: 'Decal'
      },
      {
        signature: 'Blend = 3',
        summary: `Blend texture with others in the material
       To "add" a texture, set BlendAmount = +1
       To "subtract" a texture, set BlendAmount = -1`
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'TextureType',
    dataType: 3,
    summary: `The TextureType controls how the pixels in the bitmap
   are interpreted.`,
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'Bitmap = 1',
        summary: 'Deprecated - this should be diffuse'
      },
      {
        signature: 'Diffuse = 1',
        summary: 'The diffuse color of the material, ideally the albedo.'
      },
      {
        signature: 'Bump = 2',
        summary: 'bump map'
      },
      {
        signature: 'Transparency = 3',
        summary: 'Deprecated - see Opacity.  This has always actually meant opacity in Rhino, so there is nothing to change.'
      },
      {
        signature: 'Opacity = 3',
        summary: 'value = alpha'
      },
      {
        signature: 'Emap = 4',
        summary: 'Emap/Environment texture'
      },
      {
        signature: 'PBR_BaseColor = 1',
        summary: 'Physically based materials only - base color.  Re-uses diffuse texture slot.'
      },
      {
        signature: 'PBR_Subsurface = 10',
        summary: 'Physically based materials only - subsurface (greyscale)'
      },
      {
        signature: 'PBR_SubsurfaceScattering = 11',
        summary: 'Physically based materials only - subsurface scattering'
      },
      {
        signature: 'PBR_SubsurfaceScatteringRadius = 12',
        summary: 'Physically based materials only - subsurface scattering radius (greyscale)'
      },
      {
        signature: 'PBR_Metallic = 13',
        summary: 'Physically based materials only - metallic (greyscale)'
      },
      {
        signature: 'PBR_Specular = 14',
        summary: 'Physically based materials only - specular (greyscale)'
      },
      {
        signature: 'PBR_SpecularTint = 15',
        summary: 'Physically based materials only - specular tint (greyscale)'
      },
      {
        signature: 'PBR_Roughness = 16',
        summary: 'Physically based materials only - roughness (greyscale)'
      },
      {
        signature: 'PBR_Anisotropic = 17',
        summary: 'Physically based materials only - anisotropic (greyscale)'
      },
      {
        signature: 'PBR_Anisotropic_Rotation = 18',
        summary: 'Physically based materials only - anisotropic rotation 0 = 0, 255 = 360'
      },
      {
        signature: 'PBR_Sheen = 19',
        summary: 'Physically based materials only - sheen (greyscale)'
      },
      {
        signature: 'PBR_SheenTint = 20',
        summary: 'Physically based materials only - sheen tint (greyscale)'
      },
      {
        signature: 'PBR_Clearcoat = 21',
        summary: 'Physically based materials only - clearcoat (greyscale)'
      },
      {
        signature: 'PBR_ClearcoatRoughness = 22',
        summary: 'Physically based materials only - clearcoat roughness (greyscale)'
      },
      {
        signature: 'PBR_OpacityIor = 23',
        summary: 'Physically based materials only - ior (greyscale - remaps from 1.0 to 2.0)'
      },
      {
        signature: 'PBR_OpacityRoughness = 24',
        summary: 'Physically based materials only - transparency roughness (greyscale)'
      },
      {
        signature: 'PBR_Emission = 25',
        summary: 'Physically based materials only - emission (greyscale)'
      },
      {
        signature: 'PBR_AmbientOcclusion = 26',
        summary: 'Physically based materials only - occulusion (greyscale)'
      },
      {
        signature: 'PBR_Displacement = 28',
        summary: 'Physically based materials only - normal 8-bit RGB, alpha is ignored'
      },
      {
        signature: 'PBR_ClearcoatBump = 29',
        summary: 'Physically based materials only - clearcoat normal  or bump (normal map, RGB)'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'TextureUvwWrapping',
    dataType: 3,
    summary: 'Defines Texture UVW wrapping modes',
    values: [
      {
        signature: 'Repeat = 0',
        summary: 'Repeat the texture'
      },
      {
        signature: 'Clamp = 1',
        summary: 'Clamp the texture'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'TextVerticalAlignment',
    dataType: 3,
    summary: 'Vertical location of text attach point relative to text',
    values: [
      {
        signature: 'Top = 0',
        summary: 'Attach to top of an "I" on the first line. (Independent of glyphs being displayed.)'
      },
      {
        signature: 'MiddleOfTop = 1',
        summary: 'Attach to middle of an "I" on the first line. (Independent of glyphs being displayed.)'
      },
      {
        signature: 'BottomOfTop = 2',
        summary: 'Attach to baseline of first line. (Independent of glyphs being displayed.)'
      },
      {
        signature: 'Middle = 3',
        summary: 'Attach to middle of text vertical advance. (Independent of glyphs being displayed.)'
      },
      {
        signature: 'MiddleOfBottom = 4',
        summary: 'Attach to middle of an "I" on the last line. (Independent of glyphs being displayed.)'
      },
      {
        signature: 'Bottom = 5',
        summary: 'Attach to the basline of the last line. (Independent of glyphs being displayed.)'
      },
      {
        signature: 'BottomOfBoundingBox = 6',
        summary: 'Attach to the bottom of the boudning box of the visible glyphs.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ViewInfo',
    dataType: 1,
    summary: `Represents the name and orientation of a View (and named view).
   views can be thought of as cameras.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'ViewInfo(RhinoViewport rhinoViewPort)',
        summary: 'Access to the ViewInfo for given RhinoViewport',
        since: 6
      },
      {
        signature: 'ViewInfo(uint docRuntimeSerialNumber)',
        summary: 'Construct the ViewInfo for active viewport of given doc.',
        since: 6,
        parameters: [
          {
            name: 'docRuntimeSerialNumber',
            summary: `Runtime serial number of the
     document to query for the active viewport`
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'double FocalBlurAperture',
        summary: 'Gets or sets the Focal blur aperture of the active viewport',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double FocalBlurDistance',
        summary: 'Gets or sets the Focal blur distance of the active viewport',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double FocalBlurJitter',
        summary: 'Gets or sets the Focal blur jitter of the active viewport',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ViewInfoFocalBlurModes FocalBlurMode',
        summary: 'Gets or sets the Focal blur mode of the active viewport',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'uint FocalBlurSampleCount',
        summary: 'Gets or sets the Focal blur sample count of the active viewport',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string Name',
        summary: 'Gets or sets the name of the view.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowWallpaperInGrayScale',
        summary: 'True if wallpaper (if any) is to be shown in gray scale in this view.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'ViewportInfo Viewport',
        summary: 'Gets the viewport, or viewing frustum, associated with this view.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string WallpaperFilename',
        summary: 'Get filename for wallpaper set to this view, if any.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool WallpaperHidden',
        summary: 'True if wallpaper (if any) is to be hidden from this view.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ViewInfoFocalBlurModes',
    dataType: 3,
    summary: 'The different focal blur modes of the ViewInfo',
    values: [
      {
        signature: 'None',
        summary: 'No focal blur'
      },
      {
        signature: 'Automatic',
        summary: 'Autofocus on selected objects'
      },
      {
        signature: 'Manual',
        summary: 'Fully manual focus'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'ViewportInfo',
    dataType: 1,
    summary: 'Represents a viewing frustum.',
    baseclass: 'Rhino.Runtime.CommonObject',
    constructors: [
      {
        signature: 'ViewportInfo()',
        summary: 'Initializes a new instance.',
        since: 5
      },
      {
        signature: 'ViewportInfo(RhinoViewport rhinoViewport)',
        summary: 'Copies all of the ViewportInfo data from an existing RhinoViewport.',
        since: 5,
        parameters: [
          {
            name: 'rhinoViewport',
            summary: 'A viewport to copy.'
          }
        ]
      },
      {
        signature: 'ViewportInfo(ViewportInfo other)',
        summary: 'Initializes a new instance by copying values from another instance.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The other viewport info.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Vector3d DefaultCameraDirection',
        summary: 'Default z=up perspective camera direction',
        since: 6,
        property: ['get']
      },
      {
        signature: 'double Camera35mmLensLength',
        summary: `This property assumes the camera is horizontal and crop the
     film rather than the image when the aspect of the frustum
     is not 36/24.  (35mm film is 36mm wide and 24mm high.)
     Setting preserves camera location,
     changes the frustum, but maintains the frustum's aspect.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double CameraAngle',
        summary: 'Gets or sets the 1/2 smallest angle. See GetCameraAngles for more information.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d CameraDirection',
        summary: 'Gets the direction that the camera faces.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d CameraLocation',
        summary: 'Gets the camera location (position) point.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CameraUp',
        summary: 'Gets the camera up vector.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CameraX',
        summary: 'Gets the unit "to the right" vector.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CameraY',
        summary: 'Gets the unit "up" vector.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CameraZ',
        summary: 'Gets the unit vector in -CameraDirection.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double FrustumAspect',
        summary: `Setting FrustumAspect changes the larger of the frustum's width/height
     so that the resulting value of width/height matches the requested
     aspect.  The camera angle is not changed.  If you change the shape
     of the view port with a call SetScreenPort(), then you generally 
     want to call SetFrustumAspect() with the value returned by 
     GetScreenPortAspect().`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double FrustumBottom',
        summary: `Gets the frustum bottom value. This is -top if the frustum has a horizontal symmetry axis.
     This number is usually negative.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Plane FrustumBottomPlane',
        summary: 'Gets the frustum bottom plane that separates visibile from off-screen.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d FrustumCenter',
        summary: 'Gets the frustum center point.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double FrustumFar',
        summary: 'Gets the frustum far-cutting value.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Plane FrustumFarPlane',
        summary: `Gets far clipping plane if camera and frustum
     are valid.  The plane's frame is the same as the camera's
     frame.  The origin is located at the intersection of the
     camera direction ray and the far clipping plane. The plane's
     normal points into the frustum towards the camera location.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double FrustumHeight',
        summary: 'Gets the frustum height. This is FrustumTop - FrustumBottom.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double FrustumLeft',
        summary: `Gets the frustum left value. This is -right if the frustum has a vertical symmetry axis.
     This number is usually negative.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Plane FrustumLeftPlane',
        summary: 'Gets the frustum left plane that separates visibile from off-screen.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double FrustumMaximumDiameter',
        summary: 'Gets the frustum maximum diameter, or the maximum between FrustumWidth and FrustumHeight.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double FrustumMinimumDiameter',
        summary: 'Gets the frustum minimum diameter, or the minimum between FrustumWidth and FrustumHeight.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double FrustumNear',
        summary: 'Gets the frustum near-cutting value.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Plane FrustumNearPlane',
        summary: `Gets near clipping plane if camera and frustum
     are valid.  The plane's frame is the same as the camera's
     frame.  The origin is located at the intersection of the
     camera direction ray and the near clipping plane. The plane's
     normal points out of the frustum towards the camera
     location.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double FrustumRight',
        summary: `Gets the frustum right value. This is -left if the frustum has a vertical symmetry axis.
     This number is usually positive.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Plane FrustumRightPlane',
        summary: 'Gets the frustum right plane that separates visibile from off-screen.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double FrustumTop',
        summary: `Gets the frustum top value. This is -bottom if the frustum has a horizontal symmetry axis.
     This number is usually positive.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Plane FrustumTopPlane',
        summary: 'Gets the frustum top plane that separates visibile from off-screen.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double FrustumWidth',
        summary: 'Gets the frustum width. This is FrustumRight - FrustumLeft.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid Id',
        summary: `Sets the viewport's id to the value used to 
     uniquely identify this viewport.
     There is no approved way to change the viewport 
     id once it is set in order to maintain consistency
     across multiple viewports and those routines that 
     manage them.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsCameraDirectionLocked',
        summary: 'Gets or sets a value that indicates whether the direction that the camera faces is unmodifiable.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsCameraLocationLocked',
        summary: 'Gets or sets a value that indicates whether the camera location is unmodifiable.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsCameraUpLocked',
        summary: 'Gets or sets a value that indicates whether the camera up vector is unmodifiable.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsFrustumLeftRightSymmetric',
        summary: 'Gets or sets a value that indicates whether the camera frustum has a vertical symmetry axis.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsFrustumTopBottomSymmetric',
        summary: 'Gets or sets a value that indicates whether the camera frustum has a horizontal symmetry axis.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsParallelProjection',
        summary: 'Get or set whether this projection is parallel.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsPerspectiveProjection',
        summary: 'Get or set whether this projection is perspective.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsTwoPointPerspectiveProjection',
        summary: 'Gets a value that indicates whether this projection is a two-point perspective.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValidCamera',
        summary: 'Gets a value that indicates whether the camera is valid.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValidFrustum',
        summary: 'Gets a value that indicates whether the frustum is valid.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double PerspectiveMinNearDist',
        summary: `Expert user function to control the minimum
     value of near when perspective projections
     are being used.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double PerspectiveMinNearOverFar',
        summary: `Expert user function to control the minimum
     ratio of near/far when perspective projections
     are begin used.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'Rectangle ScreenPort',
        summary: 'Get or set the screen port. SetScreenPort(System.Drawing.Rectangle) and GetScreenPort()',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double ScreenPortAspect',
        summary: `Gets the sceen aspect ratio.
     This is width / height.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d TargetPoint',
        summary: `The current value of the target point.  This point does not play
     a role in the view projection calculations.  It can be used as a 
     fixed point when changing the camera so the visible regions of the
     before and after frustums both contain the region of interest.
     The default constructor sets this point on ON_3dPoint::UnsetPoint.
     You must explicitly call one SetTargetPoint() functions to set
     the target point.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'SizeF ViewScale',
        summary: `Applies scaling factors to parallel projection clipping coordinates
     by setting the m_clip_mod transformation. 
     If you want to compress the view projection across the viewing
     plane, then set x = 0.5, y = 1.0, and z = 1.0.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static double CalculateCameraRotationAngle(Vector3d direction,Vector3d up)',
        summary: 'Calculates the camera rotation angle.',
        since: 6.8,
        parameters: [
          {
            name: 'direction',
            summary: 'The camera direction.'
          },
          {
            name: 'up',
            summary: 'The camera up direction.'
          }
        ],
        returns: 'The camera rotation angle in radians.'
      },
      {
        signature: 'static Vector3d CalculateCameraUpDirection(Point3d location,Vector3d direction,double angle)',
        summary: 'Calculates the camera up direction.',
        since: 6.8,
        parameters: [
          {
            name: 'location',
            summary: 'The camera location.'
          },
          {
            name: 'direction',
            summary: 'The camera direction.'
          },
          {
            name: 'angle',
            summary: 'The camera rotation angle in radians.'
          }
        ],
        returns: 'The camera up direction.'
      },
      {
        signature: 'bool ChangeToParallelProjection(bool symmetricFrustum)',
        summary: `Use this function to change projections of valid viewports
     from parallel to perspective.  It will make common additional
     adjustments to the frustum and camera location so the resulting
     views are similar.  The camera direction and target point are
     not be changed.
     If the current projection is parallel and symmetricFrustum,
     FrustumIsLeftRightSymmetric() and FrustumIsTopBottomSymmetric()
     are all equal, then no changes are made and True is returned.`,
        since: 5,
        parameters: [
          {
            name: 'symmetricFrustum',
            summary: 'True if you want the resulting frustum to be symmetric.'
          }
        ],
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool ChangeToPerspectiveProjection(double targetDistance,bool symmetricFrustum,double lensLength)',
        summary: `Use this function to change projections of valid viewports
     from parallel to perspective.  It will make common additional
     adjustments to the frustum and camera location so the resulting
     views are similar.  The camera direction and target point are
     not changed.
     If the current projection is perspective and symmetricFrustum,
     IsFrustumIsLeftRightSymmetric, and IsFrustumIsTopBottomSymmetric
     are all equal, then no changes are made and True is returned.`,
        since: 5,
        parameters: [
          {
            name: 'targetDistance',
            summary: `If RhinoMath.UnsetValue this parameter is ignored.
     Otherwise it must be > 0 and indicates which plane in the current view frustum should be perserved.`
          },
          {
            name: 'symmetricFrustum',
            summary: 'True if you want the resulting frustum to be symmetric.'
          },
          {
            name: 'lensLength',
            summary: `(pass 50.0 when in doubt)
     35 mm lens length to use when changing from parallel
     to perspective projections. If the current projection
     is perspective or lens_length is <= 0.0,
     then this parameter is ignored.`
          }
        ],
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool ChangeToSymmetricFrustum(bool isLeftRightSymmetric,bool isTopBottomSymmetric,double targetDistance)',
        summary: `If needed, adjusts the current frustum so it has the 
     specified symmetries and adjust the camera location
     so the target plane remains visible.`,
        since: 5,
        parameters: [
          {
            name: 'isLeftRightSymmetric',
            summary: 'If true, the frustum will be adjusted so left = -right.'
          },
          {
            name: 'isTopBottomSymmetric',
            summary: 'If true, the frustum will be adjusted so top = -bottom.'
          },
          {
            name: 'targetDistance',
            summary: `If projection is not perspective or target_distance is RhinoMath.UnsetValue,
     then this parameter is ignored. If the projection is perspective and targetDistance
     is not RhinoMath.UnsetValue, then it must be > 0.0 and it is used to determine
     which plane in the old frustum will appear unchanged in the new frustum.`
          }
        ],
        returns: 'Returns True if the viewport has now a frustum with the specified symmetries.'
      },
      {
        signature: 'bool ChangeToTwoPointPerspectiveProjection(double targetDistance,Vector3d up,double lensLength)',
        summary: `Changes projections of valid viewports
     to a two point perspective.  It will make common additional
     adjustments to the frustum and camera location and direction
     so the resulting views are similar.
     If the current projection is perspective and
     IsFrustumIsLeftRightSymmetric is True and
     IsFrustumIsTopBottomSymmetric is false, then no changes are
     made and True is returned.`,
        since: 5,
        parameters: [
          {
            name: 'targetDistance',
            summary: `If RhinoMath.UnsetValue this parameter is ignored.  Otherwise
     it must be > 0 and indicates which plane in the current 
     view frustum should be perserved.`
          },
          {
            name: 'up',
            summary: `The locked up direction. Pass Vector3d.Zero if you want to use the world
     axis direction that is closest to the current up direction.
     Pass CameraY() if you want to preserve the current up direction.`
          },
          {
            name: 'lensLength',
            summary: `(pass 50.0 when in doubt)
     35 mm lens length to use when changing from parallel
     to perspective projections. If the current projection
     is perspective or lens_length is <= 0.0,
     then this parameter is ignored.`
          }
        ],
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool DollyCamera(Vector3d dollyVector)',
        summary: `DollyCamera() does not update the frustum's clipping planes.
     To update the frustum's clipping planes call DollyFrustum(d)
     with d = dollyVector o cameraFrameZ.  To convert screen locations
     into a dolly vector, use GetDollyCameraVector().
     Does not update frustum.  To update frustum use DollyFrustum(d) with d = dollyVector o cameraFrameZ.`,
        since: 5,
        parameters: [
          {
            name: 'dollyVector',
            summary: 'dolly vector in world coordinates.'
          }
        ],
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool DollyExtents(BoundingBox cameraCoordinateBoundingBox,double border)',
        summary: `Dolly the camera location and so that the view frustum contains
     all of the document objects that can be seen in view.
     If the projection is perspective, the camera angle is not changed.`,
        since: 5.6,
        parameters: [
          {
            name: 'cameraCoordinateBoundingBox',
            summary: ''
          },
          {
            name: 'border',
            summary: `If border > 1.0, then the fustum in enlarged by this factor
     to provide a border around the view.  1.1 works well for
     parallel projections; 0.0 is suggested for perspective projections.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool DollyExtents(IEnumerable<GeometryBase> geometry,double border)',
        summary: `Dolly the camera location and so that the view frustum contains
     all of the document objects that can be seen in view.
     If the projection is perspective, the camera angle is not changed.`,
        since: 5.6,
        parameters: [
          {
            name: 'geometry',
            summary: ''
          },
          {
            name: 'border',
            summary: `If border > 1.0, then the fustum in enlarged by this factor
     to provide a border around the view.  1.1 works well for
     parallel projections; 0.0 is suggested for perspective projections.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool DollyFrustum(double dollyDistance)',
        summary: 'Moves the frustum clipping planes.',
        since: 5,
        parameters: [
          {
            name: 'dollyDistance',
            summary: 'Distance to move in camera direction.'
          }
        ],
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool Extents(double halfViewAngleRadians,BoundingBox bbox)',
        summary: `Extends this viewport view to include a bounding box.
     Use Extents() as a quick way to set a viewport to so that bounding
     volume is inside of a viewports frustrum.
     The view angle is used to determine the position of the camera.`,
        since: 5,
        parameters: [
          {
            name: 'halfViewAngleRadians',
            summary: '1/2 smallest subtended view angle in radians.'
          },
          {
            name: 'bbox',
            summary: 'A bounding box in 3d world coordinates.'
          }
        ],
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool Extents(double halfViewAngleRadians,Sphere sphere)',
        summary: `Extends this viewport view to include a sphere.
     Use Extents() as a quick way to set a viewport to so that bounding
     volume is inside of a viewports frustrum.
     The view angle is used to determine the position of the camera.`,
        since: 5,
        parameters: [
          {
            name: 'halfViewAngleRadians',
            summary: '1/2 smallest subtended view angle in radians.'
          },
          {
            name: 'sphere',
            summary: 'A sphere in 3d world coordinates.'
          }
        ],
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'Point3d FrustumCenterPoint(double targetDistance)',
        summary: `Return a point on the central axis of the view frustum.
     This point is a good choice for a general purpose target point.`,
        since: 5,
        parameters: [
          {
            name: 'targetDistance',
            summary: `If targetDistance > 0.0, then the distance from the returned
     point to the camera plane will be targetDistance. Note that
     if the frustum is not symmetric, the distance from the
     returned point to the camera location will be larger than
     targetDistance.
     If targetDistance == ON_UNSET_VALUE and the frustum
     is valid with near > 0.0, then 0.5*(near + far) will be used
     as the targetDistance.`
          }
        ],
        returns: `A point on the frustum's central axis.  If the viewport or input
     is not valid, then ON_3dPoint::UnsetPoint is returned.`
      },
      {
        signature: 'bool GetBoundingBoxDepth(BoundingBox bbox,double nearDistance,double farDistance)',
        summary: `Gets near and far clipping distances of a bounding box.
     This function ignores the current value of the viewport's 
     near and far settings. If the viewport is a perspective
     projection, the it intersects the semi infinite frustum
     volume with the bounding box and returns the near and far
     distances of the intersection.  If the viewport is a parallel
     projection, it instersects the infinte view region with the
     bounding box and returns the near and far distances of the
     projection.`,
        since: 5,
        parameters: [
          {
            name: 'bbox',
            summary: 'The bounding box to sample.'
          },
          {
            name: 'nearDistance',
            summary: `Near distance of the box. This value can be zero or 
     negative when the camera location is inside bbox.`
          },
          {
            name: 'farDistance',
            summary: `Far distance of the box. This value can be equal to 
     near_dist, zero or negative when the camera location is in front of the bounding box.`
          }
        ],
        returns: `True if the bounding box intersects the view frustum and near_dist/far_dist were set. 
     False if the bounding box does not intesect the view frustum.`
      },
      {
        signature: 'bool GetCameraAngles(double halfDiagonalAngleRadians,double halfVerticalAngleRadians,double halfHorizontalAngleRadians)',
        summary: 'Gets the field of view angles.',
        since: 5,
        parameters: [
          {
            name: 'halfDiagonalAngleRadians',
            summary: '1/2 of diagonal subtended angle. This out parameter is assigned during this call.'
          },
          {
            name: 'halfVerticalAngleRadians',
            summary: '1/2 of vertical subtended angle. This out parameter is assigned during this call.'
          },
          {
            name: 'halfHorizontalAngleRadians',
            summary: '1/2 of horizontal subtended angle. This out parameter is assigned during this call.'
          }
        ],
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool GetCameraFrame(Point3d location,Vector3d cameraX,Vector3d cameraY,Vector3d cameraZ)',
        summary: 'Gets location and vectors of this camera.',
        since: 5,
        parameters: [
          {
            name: 'location',
            summary: 'An out parameter that will be filled with a point during the call.'
          },
          {
            name: 'cameraX',
            summary: 'An out parameter that will be filled with the X vector during the call.'
          },
          {
            name: 'cameraY',
            summary: 'An out parameter that will be filled with the Y vector during the call.'
          },
          {
            name: 'cameraZ',
            summary: 'An out parameter that will be filled with the Z vector during the call.'
          }
        ],
        returns: 'True if current camera orientation is valid; otherwise false.'
      },
      {
        signature: 'Vector3d GetDollyCameraVector(int screenX0,int screenY0,int screenX1,int screenY1,double projectionPlaneDistance)',
        summary: 'Gets a world coordinate dolly vector that can be passed to DollyCamera().',
        since: 5,
        parameters: [
          {
            name: 'screenX0',
            summary: 'Screen coords of start point.'
          },
          {
            name: 'screenY0',
            summary: 'Screen coords of start point.'
          },
          {
            name: 'screenX1',
            summary: 'Screen coords of end point.'
          },
          {
            name: 'screenY1',
            summary: 'Screen coords of end point.'
          },
          {
            name: 'projectionPlaneDistance',
            summary: 'Distance of projection plane from camera. When in doubt, use 0.5*(frus_near+frus_far).'
          }
        ],
        returns: 'The world coordinate dolly vector.'
      },
      {
        signature: 'Vector3d GetDollyCameraVector(Point screen0,Point screen1,double projectionPlaneDistance)',
        summary: 'Gets a world coordinate dolly vector that can be passed to DollyCamera().',
        since: 5,
        parameters: [
          {
            name: 'screen0',
            summary: 'Start point.'
          },
          {
            name: 'screen1',
            summary: 'End point.'
          },
          {
            name: 'projectionPlaneDistance',
            summary: 'Distance of projection plane from camera. When in doubt, use 0.5*(frus_near+frus_far).'
          }
        ],
        returns: 'The world coordinate dolly vector.'
      },
      {
        signature: 'Point3d[] GetFarPlaneCorners()',
        summary: `Gets the corners of far clipping plane rectangle.
     4 points are returned in the order of bottom left, bottom right,
     top left, top right.`,
        since: 5,
        returns: `Four corner points on success.
     Empty array if viewport is not valid.`
      },
      {
        signature: 'bool GetFrustum(double left,double right,double bottom,double top,double nearDistance,double farDistance)',
        summary: 'Gets the view frustum.',
        since: 5,
        parameters: [
          {
            name: 'left',
            summary: 'A left value that will be filled during the call.'
          },
          {
            name: 'right',
            summary: 'A right value that will be filled during the call.'
          },
          {
            name: 'bottom',
            summary: 'A bottom value that will be filled during the call.'
          },
          {
            name: 'top',
            summary: 'A top value that will be filled during the call.'
          },
          {
            name: 'nearDistance',
            summary: 'A near distance value that will be filled during the call.'
          },
          {
            name: 'farDistance',
            summary: 'A far distance value that will be filled during the call.'
          }
        ],
        returns: 'True if operation succeeded; otherwise, false.'
      },
      {
        signature: 'Line GetFrustumLine(double screenX,double screenY)',
        summary: `Gets the world coordinate line in the view frustum
     that projects to a point on the screen.`,
        since: 5.1,
        parameters: [
          {
            name: 'screenX',
            summary: '(screenx,screeny) = screen location.'
          },
          {
            name: 'screenY',
            summary: '(screenx,screeny) = screen location.'
          }
        ],
        returns: '3d world coordinate line segment starting on the near clipping plane and ending on the far clipping plane.'
      },
      {
        signature: 'Line GetFrustumLine(Point screenPoint)',
        summary: `Gets the world coordinate line in the view frustum
     that projects to a point on the screen.`,
        since: 5.1,
        parameters: [
          {
            name: 'screenPoint',
            summary: 'screen location'
          }
        ],
        returns: '3d world coordinate line segment starting on the near clipping plane and ending on the far clipping plane.'
      },
      {
        signature: 'Line GetFrustumLine(PointF screenPoint)',
        summary: `Gets the world coordinate line in the view frustum
     that projects to a point on the screen.`,
        since: 5.1,
        parameters: [
          {
            name: 'screenPoint',
            summary: 'screen location'
          }
        ],
        returns: '3d world coordinate line segment starting on the near clipping plane and ending on the far clipping plane.'
      },
      {
        signature: 'Point3d[] GetNearPlaneCorners()',
        summary: `Gets the corners of near clipping plane rectangle.
     4 points are returned in the order of bottom left, bottom right,
     top left, top right.`,
        since: 5,
        returns: `Four corner points on success.
     Empty array if viewport is not valid.`
      },
      {
        signature: 'bool GetPointDepth(Point3d point,double distance)',
        summary: `Gets the clipping distance of a point. This function ignores the
     current value of the viewport's near and far settings. If
     the viewport is a perspective projection, then it intersects
     the semi infinite frustum volume with the bounding box and
     returns the near and far distances of the intersection.
     If the viewport is a parallel projection, it instersects the
     infinte view region with the bounding box and returns the
     near and far distances of the projection.`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point to measure.'
          },
          {
            name: 'distance',
            summary: 'distance of the point (can be < 0)'
          }
        ],
        returns: `True if the bounding box intersects the view frustum and
     near_dist/far_dist were set.
     False if the bounding box does not intesect the view frustum.`
      },
      {
        signature: 'System.Drawing.Rectangle GetScreenPort()',
        summary: `Gets the location of viewport in pixels.
     See documentation for SetScreenPort(int, int, int, int, int, int).`,
        since: 5,
        returns: 'The rectangle, or System.Drawing.Rectangle.Empty rectangle on error.'
      },
      {
        signature: 'System.Drawing.Rectangle GetScreenPort(int near,int far)',
        summary: `Gets the location of viewport in pixels.
     See value meanings in SetScreenPort.`,
        since: 5,
        parameters: [
          {
            name: 'near',
            summary: 'The near value. This out parameter is assigned during the call.'
          },
          {
            name: 'far',
            summary: 'The far value. This out parameter is assigned during the call.'
          }
        ],
        returns: 'The rectangle, or System.Drawing.Rectangle.Empty rectangle on error.'
      },
      {
        signature: 'void GetScreenPortLocation(int left,int top,int right,int bottom)',
        summary: 'Get the location of viewport in pixels (non System.Drawing version of GetScreenPort)',
        since: 6
      },
      {
        signature: 'bool GetSphereDepth(Sphere sphere,double nearDistance,double farDistance)',
        summary: 'Gets near and far clipping distances of a bounding sphere.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'The sphere to sample.'
          },
          {
            name: 'nearDistance',
            summary: 'Near distance of the sphere (can be < 0)'
          },
          {
            name: 'farDistance',
            summary: 'Far distance of the sphere (can be equal to near_dist)'
          }
        ],
        returns: `True if the sphere intersects the view frustum and near_dist/far_dist were set.
     False if the sphere does not intesect the view frustum.`
      },
      {
        signature: 'double GetWorldToScreenScale(Point3d pointInFrustum)',
        summary: 'Gets the scale factor from point in frustum to screen scale.',
        since: 5.1,
        parameters: [
          {
            name: 'pointInFrustum',
            summary: 'point in viewing frustum.'
          }
        ],
        returns: 'number of pixels per world unit at the 3d point.'
      },
      {
        signature: 'Transform GetXform(CoordinateSystem sourceSystem,CoordinateSystem destinationSystem)',
        summary: 'Computes a transform from a coordinate system to another.',
        since: 5,
        parameters: [
          {
            name: 'sourceSystem',
            summary: 'The coordinate system to map from.'
          },
          {
            name: 'destinationSystem',
            summary: 'The coordinate system to map into.'
          }
        ],
        returns: 'The 4x4 transformation matrix (acts on the left).'
      },
      {
        signature: 'bool RotateCamera(double rotationAngleRadians,Vector3d rotationAxis,Point3d rotationCenter)',
        summary: 'Rotates the view camera.',
        since: 7,
        parameters: [
          {
            name: 'rotationAngleRadians',
            summary: 'The amount to rotate expressed in radians.'
          },
          {
            name: 'rotationAxis',
            summary: 'The axis to rotate around.'
          },
          {
            name: 'rotationCenter',
            summary: 'The point to rotate around.'
          }
        ],
        returns: 'True if rotation is successful, False otherwise.'
      },
      {
        signature: 'bool SetCameraDirection(Vector3d direction)',
        summary: 'Sets the direction that the camera faces.',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: 'A new direction.'
          }
        ],
        returns: 'True if the direction was set; otherwise false.'
      },
      {
        signature: 'bool SetCameraLocation(Point3d location)',
        summary: 'Sets the camera location (position) point.',
        since: 5,
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool SetCameraUp(Vector3d up)',
        summary: 'Sets the camera up vector.',
        since: 5,
        parameters: [
          {
            name: 'up',
            summary: 'A new direction.'
          }
        ],
        returns: 'True if the direction was set; otherwise false.'
      },
      {
        signature: 'bool SetFrustum(double left,double right,double bottom,double top,double nearDistance,double farDistance)',
        summary: `Sets the view frustum. If FrustumSymmetryIsLocked() is true
     and left != -right or bottom != -top, then they will be
     adjusted so the resulting frustum is symmetric.`,
        since: 5,
        parameters: [
          {
            name: 'left',
            summary: 'A new left value.'
          },
          {
            name: 'right',
            summary: 'A new right value.'
          },
          {
            name: 'bottom',
            summary: 'A new bottom value.'
          },
          {
            name: 'top',
            summary: 'A new top value.'
          },
          {
            name: 'nearDistance',
            summary: 'A new near distance value.'
          },
          {
            name: 'farDistance',
            summary: 'A new far distance value.'
          }
        ],
        returns: 'True if operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool SetFrustumNearFar(BoundingBox boundingBox)',
        summary: 'Sets the frustum near and far using a bounding box.',
        since: 5,
        parameters: [
          {
            name: 'boundingBox',
            summary: 'A bounding box to use.'
          }
        ],
        returns: 'True if operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool SetFrustumNearFar(double nearDistance,double farDistance)',
        summary: 'Sets the frustum near and far distances using two values.',
        since: 5,
        parameters: [
          {
            name: 'nearDistance',
            summary: 'The new near distance.'
          },
          {
            name: 'farDistance',
            summary: 'The new far distance.'
          }
        ],
        returns: 'True if operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool SetFrustumNearFar(double nearDistance,double farDistance,double minNearDistance,double minNearOverFar,double targetDistance)',
        summary: 'Sets near and far clipping distance subject to constraints.',
        since: 5,
        parameters: [
          {
            name: 'nearDistance',
            summary: '(>0) desired near clipping distance.'
          },
          {
            name: 'farDistance',
            summary: '(>near_dist) desired near clipping distance.'
          },
          {
            name: 'minNearDistance',
            summary: `If min_near_dist <= 0.0, it is ignored.
     If min_near_dist > 0 and near_dist < min_near_dist, then the frustum's near_dist will be increased to min_near_dist.`
          },
          {
            name: 'minNearOverFar',
            summary: `If min_near_over_far <= 0.0, it is ignored.
     If near_dist < far_dist*min_near_over_far, then
     near_dist is increased and/or far_dist is decreased
     so that near_dist = far_dist*min_near_over_far.
     If near_dist < target_dist < far_dist, then near_dist
     near_dist is increased and far_dist is decreased so that
     projection precision will be good at target_dist.
     Otherwise, near_dist is simply set to 
     far_dist*min_near_over_far.`
          },
          {
            name: 'targetDistance',
            summary: `If target_dist <= 0.0, it is ignored.
     If target_dist > 0, it is used as described in the
     description of the min_near_over_far parameter.`
          }
        ],
        returns: 'True if operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool SetFrustumNearFar(Point3d center,double radius)',
        summary: 'Sets the frustum near and far using a center point and radius.',
        since: 5,
        parameters: [
          {
            name: 'center',
            summary: 'A center point.'
          },
          {
            name: 'radius',
            summary: 'A radius value.'
          }
        ],
        returns: 'True if operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool SetScreenPort(int left,int right,int bottom,int top,int near,int far)',
        summary: `Location of viewport in pixels.
     These are provided so you can set the port you are using
     and get the appropriate transformations to and from
     screen space.
     // For a Windows window
     /      int width = width of window client area in pixels;
     /      int height = height of window client area in pixels;
     /      port_left = 0;
     /      port_right = width;
     /      port_top = 0;
     /      port_bottom = height;
     /      port_near = 0;
     /      port_far = 1;
     /      SetScreenPort( port_left, port_right, 
     /                     port_bottom, port_top, 
     /                     port_near, port_far );`,
        since: 5,
        parameters: [
          {
            name: 'left',
            summary: 'A left value.'
          },
          {
            name: 'right',
            summary: 'A left value. (port_left != port_right)'
          },
          {
            name: 'bottom',
            summary: 'A bottom value.'
          },
          {
            name: 'top',
            summary: 'A top value. (port_top != port_bottom)'
          },
          {
            name: 'near',
            summary: 'A near value.'
          },
          {
            name: 'far',
            summary: 'A far value.'
          }
        ],
        returns: 'True if input is valid.'
      },
      {
        signature: 'bool SetScreenPort(Rectangle windowRectangle)',
        summary: `Gets the location of viewport in pixels.
     See value meanings in SetScreenPort.`,
        since: 5,
        parameters: [
          {
            name: 'windowRectangle',
            summary: 'A new rectangle.'
          }
        ],
        returns: 'True if input is valid.'
      },
      {
        signature: 'bool SetScreenPort(Rectangle windowRectangle,int near,int far)',
        summary: `Gets the location of viewport in pixels.
     See value meanings in SetScreenPort.`,
        since: 5,
        parameters: [
          {
            name: 'windowRectangle',
            summary: 'A new rectangle.'
          },
          {
            name: 'near',
            summary: 'The near value.'
          },
          {
            name: 'far',
            summary: 'The far value.'
          }
        ],
        returns: 'True if input is valid.'
      },
      {
        signature: 'double TargetDistance(bool useFrustumCenterFallback)',
        summary: `Gets the distance from the target point to the camera plane.
     Note that if the frustum is not symmetric, then this distance
     is shorter than the distance from the target to the camera location.`,
        since: 5,
        parameters: [
          {
            name: 'useFrustumCenterFallback',
            summary: `If bUseFrustumCenterFallback is False and the target point is
     not valid, then ON_UNSET_VALUE is returned.
     If bUseFrustumCenterFallback is True and the frustum is valid
     and current target point is not valid or is behind the camera,
     then 0.5*(near + far) is returned.`
          }
        ],
        returns: `Shortest signed distance from camera plane to target point.
     If the target point is on the visible side of the camera,
     a positive value is returned.  ON_UNSET_VALUE is returned
     when the input of view is not valid.`
      },
      {
        signature: 'bool TransformCamera(Transform xform)',
        summary: 'Transforms the view camera location, direction, and up.',
        since: 7,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation to apply to camera.'
          }
        ],
        returns: `True if a valid camera was transformed, False if
     invalid camera, frustum, or transformation.`
      },
      {
        signature: 'void UnlockCamera()',
        summary: 'Unlocks the camera vectors and location.',
        since: 5
      },
      {
        signature: 'void UnlockFrustumSymmetry()',
        summary: 'Unlocks frustum horizontal and vertical symmetries.',
        since: 5
      },
      {
        signature: 'bool ZoomToScreenRect(int left,int top,int right,int bottom)',
        summary: `Zooms to a screen zone.
     View changing from screen input points. Handy for
     using a mouse to manipulate a view.
     ZoomToScreenRect() may change camera and frustum settings.`,
        since: 5,
        parameters: [
          {
            name: 'left',
            summary: 'Screen coord.'
          },
          {
            name: 'top',
            summary: 'Screen coord.'
          },
          {
            name: 'right',
            summary: 'Screen coord.'
          },
          {
            name: 'bottom',
            summary: 'Screen coord.'
          }
        ],
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool ZoomToScreenRect(Rectangle windowRectangle)',
        summary: `Zooms to a screen zone.
     View changing from screen input points. Handy for
     using a mouse to manipulate a view.
     ZoomToScreenRect() may change camera and frustum settings.`,
        since: 5,
        parameters: [
          {
            name: 'windowRectangle',
            summary: 'The new window rectangle in screen space.'
          }
        ],
        returns: 'True if the operation succeeded; otherwise, false.'
      }
    ]
  },
  {
    namespace: 'Rhino.DocObjects',
    name: 'Worksession',
    dataType: 1,
    summary: 'Manages a list of models that are being used as reference geometry.',
    properties: [
      {
        signature: 'RhinoDoc Document',
        summary: 'Gets the document that owns this worksession.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string FileName',
        summary: `Returns the path to the open worksession, or .rws, file. 
     If there is no worksession file open, or the active worksession
     has not yet been saved, then None is returned.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'int ModelCount',
        summary: `Returns the number of models in the worksession. The active model will included
     in this count whether or not it has been saved.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'string[] ModelPaths',
        summary: `Returns the paths to the models used by the worksession. If the active model has
     not been saved, then it will not be included in the output array.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint RuntimeSerialNumber',
        summary: `Unique serial number for the worksession while the application is running.
     This is not a persistent value.`,
        since: 6.3,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static string FileNameFromRuntimeSerialNumber(uint runtimeSerialNumber)',
        summary: `Returns the path to the open worksession, or .rws, file. 
     If there is no worksession file open, or the active worksession
     has not yet been saved, then None is returned.`,
        since: 6.3
      },
      {
        signature: 'string ModelPathFromSerialNumber(uint modelSerialNumber)',
        summary: 'Returns the path to a model, used by the worksession, given a reference model serial number',
        since: 6.12,
        parameters: [
          {
            name: 'modelSerialNumber',
            summary: 'The reference model serial number.'
          }
        ],
        returns: 'The path to the model if successful, None otherwise.'
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'DocumentEventArgs',
    dataType: 1,
    summary: 'Provides document information for RhinoDoc events.',
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RhinoDoc Document',
        summary: 'Gets the document for this event. This field might be null.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int DocumentId',
        summary: 'Gets the document Id of the document for this event.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'uint DocumentSerialNumber',
        summary: 'Gets the uniques document serial number for this event',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'DocumentOpenEventArgs',
    dataType: 1,
    summary: 'Provides document information for RhinoDoc events.',
    baseclass: 'Rhino.DocumentEventArgs',
    properties: [
      {
        signature: 'string FileName',
        summary: 'Name of file being opened.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool Merge',
        summary: `True if file is being merged into the current document. This
     occurs during the "Import" command.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool Reference',
        summary: 'True if file is opened as a reference file.',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'DocumentSaveEventArgs',
    dataType: 1,
    summary: 'Provides document information for RhinoDoc events.',
    baseclass: 'Rhino.DocumentEventArgs',
    properties: [
      {
        signature: 'bool ExportSelected',
        summary: 'True if only selected objects are being written to a file.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string FileName',
        summary: 'Name of file being written.',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'BinaryArchiveException',
    dataType: 1,
    summary: `Thrown by BinaryArchiveReader and BinaryArchiveWriter classes when
   an IO error has occured.`,
    baseclass: 'System.IO.IOException',
    constructors: [
      {
        signature: 'BinaryArchiveException(string message)',
        summary: 'Initializes a new instance of the BinaryArchiveException class.',
        since: 5,
        parameters: [
          {
            name: 'message',
            summary: 'The inner message to show to users.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'BinaryArchiveFile',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'BinaryArchiveFile(string filename,BinaryArchiveMode mode)',
        since: 5.1
      }
    ],
    properties: [
      {
        signature: 'BinaryArchiveReader Reader',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'BinaryArchiveWriter Writer',
        since: 5.1,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Close()',
        since: 5.1
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5.1
      },
      {
        signature: 'bool Open()',
        since: 5.1
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'BinaryArchiveMode',
    dataType: 3,
    values: [
      {
        signature: 'Unknown = 0'
      },
      {
        signature: 'Read = 1'
      },
      {
        signature: 'Write = 2'
      },
      {
        signature: 'ReadWrite = 3'
      },
      {
        signature: 'Read3dm = 5'
      },
      {
        signature: 'Write3dm = 6'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'BinaryArchiveReader',
    dataType: 1,
    summary: `Represents an entity that is capable of reading a binary archive and
   instantiating strongly-typed objects.`,
    properties: [
      {
        signature: 'int Archive3dmVersion',
        summary: `If a 3dm archive is being read or written, then this is the
     version of the 3dm archive format (1, 2, 3, 4 or 5).
     0     a 3dm archive is not being read/written
     1     a version 1 3dm archive is being read/written
     2     a version 2 3dm archive is being read/written
     3     a version 3 3dm archive is being read/written
     4     a version 4 3dm archive is being read/written
     5     an old version 5 3dm archive is being read
     50    a version 5 3dm archive is being read/written.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'ulong CurrentPosition',
        summary: 'current offset (in bytes) into archive ( like ftell() )',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool ReadErrorOccured',
        summary: 'Gets or sets whether en error occurred during reading.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'bool AtEnd()',
        summary: 'True if at end of a file',
        since: 5.1
      },
      {
        signature: 'bool BeginRead3dmChunk(uint expectedTypeCode,int majorVersion,int minorVersion)',
        summary: 'Begins reading a chunk that must be in the archive at this location.',
        since: 6,
        returns: `True if beginning of the chunk was read.  In this case you must call EndRead3dmChunk(),
     even if something goes wrong while you attempt to read the interior of the chunk.
     False if the chunk did not exist at the current location in the file.`
      },
      {
        signature: 'bool BeginRead3dmChunk(uint typeCode,long value)',
        summary: 'Begins reading a chunk that must be in the archive at this location.'
      },
      {
        signature: 'uint Dump3dmChunk(TextLog log)',
        summary: `Fnction for studying contents of a file.  The primary use is as an aid
     to help dig through files that have been damaged (bad disks, transmission
     errors, etc.) If an error is found, a line that begins with the word
     "ERROR" is printed.`,
        since: 5.1,
        parameters: [
          {
            name: 'log',
            summary: 'log where information is printed to'
          }
        ],
        returns: `0 if something went wrong, otherwise the typecode of the chunk that
     was just studied.`
      },
      {
        signature: 'bool EnableCRCCalculation(bool enable)',
        summary: `Expert user function to control CRC calculation while reading and writing.
     Typically this is used when seeking around and reading/writing information
     in non-serial order.`,
        since: 6,
        returns: `Current state of CRC calculation.  Use the returned value to restore the
     CRC calculation setting after you are finished doing your fancy pants
     expert IO.`
      },
      {
        signature: 'bool EndRead3dmChunk(bool suppressPartiallyReadChunkWarning)',
        summary: 'Calling this will skip rest of stuff in chunk if it was only partially read.',
        since: 6,
        parameters: [
          {
            name: 'suppressPartiallyReadChunkWarning',
            summary: `Generally, a call to ON_WARNING is made when a chunk is partially read.
     If suppressPartiallyReadChunkWarning is true, then no warning is issued
     for partially read chunks.`
          }
        ]
      },
      {
        signature: 'void Read3dmChunkVersion(int major,int minor)',
        summary: `A chunk version is a single byte that encodes a major.minor
     version number.  Useful when creating I/O code for 3dm chunks
     that may change in the future.  Increment the minor version 
     number if new information is added to the end of the chunk. 
     Increment the major version if the format of the chunk changes
     in some other way.`,
        since: 5,
        parameters: [
          {
            name: 'major',
            summary: '0 to 15.'
          },
          {
            name: 'minor',
            summary: '0 to 16.'
          }
        ],
        returns: 'True on successful read.'
      },
      {
        signature: 'bool Read3dmStartSection(int version,string comment)',
        since: 5.1,
        parameters: [
          {
            name: 'version',
            summary: '.3dm file version (2, 3, 4, 5 or 50)'
          },
          {
            name: 'comment',
            summary: `String with application name, et cetera.  This information is primarily
     used when debugging files that contain problems.  McNeel and Associates
     stores application name, application version, compile date, and the OS
     in use when file was written.`
          }
        ],
        returns: 'True on success'
      },
      {
        signature: 'bool ReadBool()',
        summary: 'Reads a bool from the archive.',
        since: 5,
        returns: 'The value that was read.'
      },
      {
        signature: 'bool[] ReadBoolArray()',
        summary: `Reads an array of bool from the archive.
     An array is returned even if the input was another enumerable type.`,
        since: 5,
        returns: 'The array that was read.'
      },
      {
        signature: 'Geometry.BoundingBox ReadBoundingBox()',
        summary: 'Reads a Rhino.Geometry.BoundingBox from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'byte ReadByte()',
        summary: 'Reads a byte from the archive.',
        since: 5,
        returns: 'The value that was read.'
      },
      {
        signature: 'byte[] ReadByteArray()',
        summary: `Reads an array of byte from the archive.
     An array is returned even if the input was another enumerable type.`,
        since: 5,
        returns: 'The array that was read.'
      },
      {
        signature: 'void ReadCheckSum()',
        summary: `Reads a legacy ON_CheckSum, only provided to read data chunks from old
     V5 files, the CheckSum read is discarded`,
        since: 6
      },
      {
        signature: 'System.Drawing.Color ReadColor()',
        summary: 'Reads a System.Drawing.Color from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'byte[] ReadCompressedBuffer()',
        summary: `Reads an array of compressed byte information from the archive and uncompresses it.
     An array is returned even if the input was another enumerable type.`,
        since: 5.9,
        returns: 'The array that was read.'
      },
      {
        signature: 'Rhino.Collections.ArchivableDictionary ReadDictionary()',
        summary: 'Reads a complete Rhino.Collections.ArchivableDictionary from the archive.',
        since: 5,
        returns: 'The newly instantiated object.'
      },
      {
        signature: 'double ReadDouble()',
        summary: 'Reads a double from the archive.',
        since: 5,
        returns: 'The value that was read.'
      },
      {
        signature: 'double[] ReadDoubleArray()',
        summary: `Reads an array of double from the archive.
     An array is returned even if the input was another enumerable type.`,
        since: 5,
        returns: 'The array that was read.'
      },
      {
        signature: 'System.Drawing.Font ReadFont()',
        summary: 'Reads a System.Drawing.Font from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'Geometry.GeometryBase ReadGeometry()',
        summary: `Reads a Rhino.Geometry.GeometryBase-derived object from the archive.
     The  class is abstract.`,
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'Geometry.GeometryBase[] ReadGeometryArray()',
        since: 7
      },
      {
        signature: 'Guid ReadGuid()',
        summary: 'Reads a Guid from the archive.',
        since: 5,
        returns: 'The value that was read.'
      },
      {
        signature: 'Guid[] ReadGuidArray()',
        summary: `Reads an array of Guid from the archive.
     An array is returned even if the input was another enumerable type.`,
        since: 5,
        returns: 'The array that was read.'
      },
      {
        signature: 'int ReadInt()',
        summary: 'Reads a int from the archive.',
        since: 5,
        returns: 'The value that was read.'
      },
      {
        signature: 'Int64 ReadInt64()',
        summary: 'Reads a long from the archive.',
        since: 5,
        returns: 'The value that was read.'
      },
      {
        signature: 'int[] ReadIntArray()',
        summary: `Reads an array of int from the archive.
     An array is returned even if the input was another enumerable type.`,
        since: 5,
        returns: 'The array that was read.'
      },
      {
        signature: 'Geometry.Interval ReadInterval()',
        summary: 'Reads a Rhino.Geometry.Interval from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'Geometry.Line ReadLine()',
        summary: 'Reads a Rhino.Geometry.Line from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'Geometry.MeshingParameters ReadMeshingParameters()',
        summary: 'Reads a Rhino.Geometry.MeshingParameters from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'DocObjects.ObjRef ReadObjRef()',
        summary: 'Reads a Rhino.DocObjects.ObjRef from the archive',
        since: 5.8,
        returns: 'the element that was read'
      },
      {
        signature: 'DocObjects.ObjRef[] ReadObjRefArray()',
        summary: `Reads an array of double from the archive.
     An array is returned even if the input was another enumerable type.`,
        since: 5.8,
        returns: 'The array that was read.'
      },
      {
        signature: 'Geometry.Plane ReadPlane()',
        summary: 'Reads a Rhino.Geometry.Plane from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'System.Drawing.Point ReadPoint()',
        summary: 'Reads a System.Drawing.Point from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'Geometry.Point2d ReadPoint2d()',
        summary: 'Reads a Rhino.Geometry.Point2d from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'Geometry.Point3d ReadPoint3d()',
        summary: 'Reads a Rhino.Geometry.Point3d from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'Geometry.Point3f ReadPoint3f()',
        summary: 'Reads a Rhino.Geometry.Point3f from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'Geometry.Point4d ReadPoint4d()',
        summary: 'Reads a Rhino.Geometry.Point4d from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'System.Drawing.PointF ReadPointF()',
        summary: 'Reads a System.Drawing.PointF from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'Geometry.Ray3d ReadRay3d()',
        summary: 'Reads a Rhino.Geometry.Ray3d from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'System.Drawing.Rectangle ReadRectangle()',
        summary: 'Reads a System.Drawing.Rectangle from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'System.Drawing.RectangleF ReadRectangleF()',
        summary: 'Reads a System.Drawing.RectangleF from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'RenderSettings ReadRenderSettings()',
        summary: 'Reads a Rhino.Render.RenderSettings-derived object from the archive.',
        since: 6,
        returns: 'The element that was read.'
      },
      {
        signature: 'sbyte ReadSByte()',
        summary: 'Reads a sbyte from the archive.',
        since: 5,
        returns: 'The value that was read.'
      },
      {
        signature: 'sbyte[] ReadSByteArray()',
        summary: `Reads an array of sbyte from the archive.
     An array is returned even if the input was another enumerable type.`,
        since: 5,
        returns: 'The array that was read.'
      },
      {
        signature: 'short ReadShort()',
        summary: 'Reads a short from the archive.',
        since: 5,
        returns: 'The value that was read.'
      },
      {
        signature: 'short[] ReadShortArray()',
        summary: `Reads an array of short from the archive.
     An array is returned even if the input was another enumerable type.`,
        since: 5,
        returns: 'The array that was read.'
      },
      {
        signature: 'float ReadSingle()',
        summary: 'Reads a float from the archive.',
        since: 5,
        returns: 'The value that was read.'
      },
      {
        signature: 'float[] ReadSingleArray()',
        summary: `Reads an array of float from the archive.
     An array is returned even if the input was another enumerable type.`,
        since: 5,
        returns: 'The array that was read.'
      },
      {
        signature: 'System.Drawing.Size ReadSize()',
        summary: 'Reads a System.Drawing.Size from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'System.Drawing.SizeF ReadSizeF()',
        summary: 'Reads a System.Drawing.SizeF from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'string ReadString()',
        summary: 'Reads a string from the archive.',
        since: 5,
        returns: 'The value that was read.'
      },
      {
        signature: 'string[] ReadStringArray()',
        summary: `Reads an array of string from the archive.
     An array is returned even if the input was another enumerable type.`,
        since: 5,
        returns: 'The array that was read.'
      },
      {
        signature: 'Geometry.Transform ReadTransform()',
        summary: 'Reads a Rhino.Geometry.Transform from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'uint ReadUInt()',
        summary: 'Reads a uint from the archive.',
        since: 5,
        returns: 'The value that was read.'
      },
      {
        signature: 'ushort ReadUShort()',
        summary: 'Reads a ushort from the archive.',
        since: 5,
        returns: 'The value that was read.'
      },
      {
        signature: 'string ReadUtf8String()',
        summary: 'Reads a string from the archive.',
        since: 6,
        returns: 'The value that was read.'
      },
      {
        signature: 'Geometry.Vector2d ReadVector2d()',
        summary: 'Reads a Rhino.Geometry.Vector2d from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'Geometry.Vector3d ReadVector3d()',
        summary: 'Reads a Rhino.Geometry.Vector3d from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'Geometry.Vector3f ReadVector3f()',
        summary: 'Reads a Rhino.Geometry.Vector3f from the archive.',
        since: 5,
        returns: 'The element that was read.'
      },
      {
        signature: 'bool SeekFromCurrentPosition(long byteOffset)',
        summary: 'seek from current position ( like fseek( ,SEEK_CUR) )'
      },
      {
        signature: 'bool SeekFromCurrentPosition(ulong byteOffset,bool forward)',
        summary: 'seek from current position ( like fseek( ,SEEK_CUR) )',
        parameters: [
          {
            name: 'byteOffset',
            summary: ''
          },
          {
            name: 'forward',
            summary: 'seek forward of backward in the archive'
          }
        ]
      },
      {
        signature: 'bool SeekFromStart(ulong byteOffset)',
        summary: 'seek from start position ( like fseek( ,SEEK_SET) )'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'BinaryArchiveWriter',
    dataType: 1,
    summary: 'Represents an entity that is able to write data to an archive.',
    properties: [
      {
        signature: 'int Archive3dmVersion',
        summary: `If a 3dm archive is being read or written, then this is the
     version of the 3dm archive format (1, 2, 3, 4 or 5).
     0     a 3dm archive is not being read/written
     1     a version 1 3dm archive is being read/written
     2     a version 2 3dm archive is being read/written
     3     a version 3 3dm archive is being read/written
     4     a version 4 3dm archive is being read/written
     5     an old version 5 3dm archive is being read
     50    a version 5 3dm archive is being read/written.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool WriteErrorOccured',
        summary: 'Gets or sets whether an error occurred.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'bool BeginWrite3dmChunk(uint typecode,int majorVersion,int minorVersion)',
        summary: 'Begins writing a chunk',
        since: 6,
        parameters: [
          {
            name: 'typecode',
            summary: 'chunk\'s typecode'
          },
          {
            name: 'majorVersion',
            summary: ''
          },
          {
            name: 'minorVersion',
            summary: ''
          }
        ],
        returns: `True if input was valid and chunk was started.  In this case you must call
     EndWrite3dmChunk(), even if something goes wrong while you attempt to write
     the contents of the chunk.
     False if input was not valid or the write failed.`
      },
      {
        signature: 'bool BeginWrite3dmChunk(uint typecode,long value)',
        summary: 'Begins writing a chunk'
      },
      {
        signature: 'bool EnableCRCCalculation(bool enable)',
        summary: `Expert user function to control CRC calculation while reading and writing.
     Typically this is used when seeking around and reading/writing information
     in non-serial order.`,
        since: 6,
        returns: `Current state of CRC calculation.  Use the returned value to restore the
     CRC calculation setting after you are finished doing your fancy pants
     expert IO.`
      },
      {
        signature: 'bool EndWrite3dmChunk()',
        summary: 'updates length in chunk header',
        since: 6
      },
      {
        signature: 'void Write3dmChunkVersion(int major,int minor)',
        summary: `A chunk version is a single byte that encodes a major.minor
     version number.  Useful when creating I/O code for 3dm chunks
     that may change in the future.  Increment the minor version 
     number if new information is added to the end of the chunk. 
     Increment the major version if the format of the chunk changes
     in some other way.`,
        since: 5,
        parameters: [
          {
            name: 'major',
            summary: '0 to 15.'
          },
          {
            name: 'minor',
            summary: '0 to 16.'
          }
        ],
        returns: 'True on successful read.'
      },
      {
        signature: 'void WriteBool(bool value)',
        summary: 'Writes a bool value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteBoolArray(IEnumerable<bool> value)',
        summary: `Writes a list, an array, or any enumerable of bool to the archive.
     The return will always be an array.`,
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteBoundingBox(BoundingBox value)',
        summary: 'Writes a Rhino.Geometry.BoundingBox value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteByte(byte value)',
        summary: 'Writes a byte value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteByteArray(IEnumerable<byte> value)',
        summary: `Writes a list, an array, or any enumerable of byte to the archive.
     The return will always be an array.`,
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteColor(Color value)',
        summary: 'Writes a System.Drawing.Color value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteCompressedBuffer(IEnumerable<byte> value)',
        summary: `Writes a list, an array, or any enumerable of byte to the archive as a compressed buffer.
     The return will always be an array.`,
        since: 5.9,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteDictionary(ArchivableDictionary dictionary)',
        summary: 'Delivers the complete content of a dictionary to the archive.',
        since: 5,
        parameters: [
          {
            name: 'dictionary',
            summary: 'A dictionary to archive.'
          }
        ]
      },
      {
        signature: 'void WriteDouble(double value)',
        summary: 'Writes a double value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteDoubleArray(IEnumerable<double> value)',
        summary: `Writes a list, an array, or any enumerable of double to the archive.
     The return will always be an array.`,
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteEmptyCheckSum()',
        summary: `Reads a legacy ON_CheckSum, only provided to read data chunks from old
     V5 files, the CheckSum read is discarded`,
        since: 6
      },
      {
        signature: 'void WriteFont(Font value)',
        summary: 'Writes a System.Drawing.Font value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteGeometry(GeometryBase value)',
        summary: 'Writes a Rhino.Geometry.GeometryBase value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteGeometryArray(IEnumerable<GeometryBase> geometry)',
        since: 7
      },
      {
        signature: 'void WriteGuid(Guid value)',
        summary: 'Writes a Guid value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteGuidArray(IEnumerable<Guid> value)',
        summary: `Writes a list, an array, or any enumerable of Guid to the archive.
     The return will always be an array.`,
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteInt(int value)',
        summary: 'Writes a int value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteInt64(Int64 value)',
        summary: 'Writes a Int64 value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteIntArray(IEnumerable<int> value)',
        summary: `Writes a list, an array, or any enumerable of int to the archive.
     The return will always be an array.`,
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteInterval(Interval value)',
        summary: 'Writes a Rhino.Geometry.Interval value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteLine(Line value)',
        summary: 'Writes a Rhino.Geometry.Line value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteMeshingParameters(MeshingParameters value)',
        summary: 'Writes a Rhino.Geometry.MeshingParameters value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteObjRef(ObjRef objref)',
        summary: 'Writes a Rhino.DocObjects.ObjRef to the archive',
        since: 5.8,
        returns: 'the element that was read'
      },
      {
        signature: 'void WriteObjRefArray(IEnumerable<ObjRef> objrefs)',
        summary: `Writes a list, an array, or any enumerable of Rhino.DocObjects.ObjRef to the archive.
     The return will always be an array.`,
        since: 5.8,
        parameters: [
          {
            name: 'objrefs',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WritePlane(Plane value)',
        summary: 'Writes a Rhino.Geometry.Plane value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WritePoint(Point value)',
        summary: 'Writes a System.Drawing.Point value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WritePoint2d(Point2d value)',
        summary: 'Writes a Rhino.Geometry.Point2d value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WritePoint3d(Point3d value)',
        summary: 'Writes a Rhino.Geometry.Point3d value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WritePoint3f(Point3f value)',
        summary: 'Writes a Rhino.Geometry.Point3f value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WritePoint4d(Point4d value)',
        summary: 'Writes a Rhino.Geometry.Point4d value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WritePointF(PointF value)',
        summary: 'Writes a System.Drawing.PointF value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteRay3d(Ray3d value)',
        summary: 'Writes a Rhino.Geometry.Ray3d value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteRectangle(Rectangle value)',
        summary: 'Writes a System.Drawing.Rectangle value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteRectangleF(RectangleF value)',
        summary: 'Writes a System.Drawing.RectangleF value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteRenderSettings(RenderSettings value)',
        summary: 'Writes a Rhino.Render.RenderSettings value to the archive.',
        since: 6,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteSByte(sbyte value)',
        summary: 'Writes a sbyte value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteSByteArray(IEnumerable<sbyte> value)',
        summary: `Writes a list, an array, or any enumerable of sbyte to the archive.
     The return will always be an array.`,
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteShort(short value)',
        summary: 'Writes a short value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteShortArray(IEnumerable<short> value)',
        summary: `Writes a list, an array, or any enumerable of short to the archive.
     The return will always be an array.`,
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteSingle(float value)',
        summary: 'Writes a float value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteSingleArray(IEnumerable<float> value)',
        summary: `Writes a list, an array, or any enumerable of float to the archive.
     The return will always be an array.`,
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteSize(Size value)',
        summary: 'Writes a System.Drawing.Size value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteSizeF(SizeF value)',
        summary: 'Writes a System.Drawing.SizeF value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteString(string value)',
        summary: 'Writes a string value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteStringArray(IEnumerable<string> value)',
        summary: `Writes a list, an array, or any enumerable of string to the archive.
     The return will always be an array.`,
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteTransform(Transform value)',
        summary: 'Writes a Rhino.Geometry.Transform value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteUInt(uint value)',
        summary: 'Writes a uint value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteUShort(ushort value)',
        summary: 'Writes a ushort value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteUtf8String(string value)',
        summary: 'Writes a string value to the archive.',
        since: 6,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteVector2d(Vector2d value)',
        summary: 'Writes a Rhino.Geometry.Vector2d value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteVector3d(Vector3d value)',
        summary: 'Writes a Rhino.Geometry.Vector3d value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      },
      {
        signature: 'void WriteVector3f(Vector3f value)',
        summary: 'Writes a Rhino.Geometry.Vector3f value to the archive.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A value to write.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'CommonComponentTable',
    dataType: 1,
    summary: 'Provides a base table type that encompasses all document tables, both in RhinoDoc and File3dm.',
    interfaces: ['ICommonComponentTable<T>', 'IList<T>', 'IReadOnlyList<T>'],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns the actual component type of a table.',
        property: ['get']
      },
      {
        signature: 'int Count',
        summary: 'Returns the count of all items, including deleted ones.',
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Clear()',
        summary: 'Marks all items as deleted.'
      },
      {
        signature: 'bool Delete(T item)',
        summary: 'Deletes an item. Items that are deleted are still keeping their space, but the \'IsDeleted\' flag is checked.',
        parameters: [
          {
            name: 'item',
            summary: 'An item to delete.'
          }
        ],
        returns: 'True if an items could be deleted (e.g., it was not locked).'
      },
      {
        signature: 'T FindId(Guid id)',
        summary: `Uses the guid to find a model component. Deleted objects cannot be found by id.
     The guid is the value that is stored in the .Id property.
     In a single document, no two active objects have the same guid. If an object is
     replaced with a new object, then the guid  persists. For example, if the _Move command
     moves an object, then the moved object inherits its guid from the starting object.
     If the Copy command copies an object, then the copy gets a new guid. This guid persists
     through file saving/openning operations. This function will not find grip objects.`,
        parameters: [
          {
            name: 'id',
            summary: 'ID of model component to search for.'
          }
        ],
        returns: 'Reference to the rhino object with the objectId or None if no such object could be found.'
      },
      {
        signature: 'IEnumerator<T> GetEnumerator()',
        summary: 'Returns the enumerator that yields all items.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'ContentHash',
    dataType: 1,
    summary: `Contains information that is useful to uniquly identify an object.
   This object is immutable.`,
    interfaces: ['ICloneable', 'IEquatable<ContentHash>'],
    properties: [
      {
        signature: 'ulong ByteCount',
        summary: 'Gets the length of the content, in bytes.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'DateTime HashTime',
        summary: 'Gets the hash time, rounded to seconds.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'byte[] Sha1ContentHash',
        summary: 'Gets the 20-bytes long SHA1 hash of the content.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'byte[] Sha1NameHash',
        summary: 'Gets the 20-bytes long SHA1 hash of the name.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static ContentHash CreateFromFile(string path)',
        summary: 'Creates a new ContentHash, representing the content of a file.',
        since: 6,
        parameters: [
          {
            name: 'path',
            summary: 'A path. This can be None and can refer to a nonexisting path.'
          }
        ]
      },
      {
        signature: 'ContentHash Clone()',
        summary: `Creates a copy of this content hash.
     Because content hash is immutable, this can be used as a deep copy.`,
        since: 6,
        returns: 'A different instance of the same content hash.'
      },
      {
        signature: 'bool Equals(ContentHash other)',
        summary: 'Determines if another content hash has the same value.',
        since: 6,
        parameters: [
          {
            name: 'other',
            summary: 'The other content hash to compare.'
          }
        ],
        returns: 'True if the two hashes are equal.'
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines if another object is a content hash with same value.',
        parameters: [
          {
            name: 'obj',
            summary: 'The other content hash to compare.'
          }
        ],
        returns: 'True if the two hashes are equal.'
      },
      {
        signature: 'int GetHashCode()',
        summary: `Gets an hash code for this content hash.
     Two equal content hashes have equal hash code. The other way around might not be true.`,
        returns: 'An hash code value.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'DracoCompression',
    dataType: 1,
    summary: 'Google draco compression for mesh and point cloud data',
    interfaces: ['IDisposable'],
    methods: [
      {
        signature: 'static DracoCompression Compress(Mesh mesh)',
        summary: 'Compress a mesh using default compression options.',
        since: 7,
        parameters: [
          {
            name: 'mesh',
            summary: 'mesh to compress'
          }
        ],
        returns: 'instance of class representing the compressed data'
      },
      {
        signature: 'static DracoCompression Compress(Mesh mesh,DracoCompressionOptions options)',
        summary: 'Compress a mesh',
        since: 7,
        parameters: [
          {
            name: 'mesh',
            summary: 'mesh to compress'
          },
          {
            name: 'options',
            summary: 'options used to determine how the comression will occur'
          }
        ],
        returns: 'instance of class representing the compressed data'
      },
      {
        signature: 'static Rhino.Geometry.GeometryBase DecompressBase64String(string encoded)',
        summary: 'Decompress base64 encoded version of draco data into either a mesh or point cloud',
        since: 7,
        parameters: [
          {
            name: 'encoded',
            summary: 'compressed draco data'
          }
        ],
        returns: 'Mesh or point cloud on success. None on failure'
      },
      {
        signature: 'static Rhino.Geometry.GeometryBase DecompressByteArray(byte[] bytes)',
        summary: 'Decompress data into either a mesh or point cloud.',
        since: 7,
        parameters: [
          {
            name: 'bytes',
            summary: 'compressed draco data'
          }
        ],
        returns: 'Mesh or point cloud on success. None on failure'
      },
      {
        signature: 'static Rhino.Geometry.GeometryBase DecompressFile(string path)',
        summary: 'Read compressed data from disk and decompress to RhinoCommon geometry',
        since: 7,
        parameters: [
          {
            name: 'path',
            summary: 'path to read from'
          }
        ],
        returns: 'Mesh or point cloud on success. None on failure'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 7
      },
      {
        signature: 'string ToBase64String()',
        summary: 'Convert byte array of draco compressed data into a base64 encoded string',
        since: 7
      },
      {
        signature: 'bool Write(string path)',
        summary: 'Write the compressed data to disk',
        since: 7,
        parameters: [
          {
            name: 'path',
            summary: 'path to write to'
          }
        ],
        returns: 'True on success'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'DracoCompressionOptions',
    dataType: 1,
    summary: 'Options for applying drac compression',
    constructors: [
      {
        signature: 'DracoCompressionOptions()',
        summary: 'Initializes to default options',
        since: 7
      }
    ],
    properties: [
      {
        signature: 'int CompressionLevel',
        summary: 'Compression level. 0 if fastest, but least compression. 10 is slowest, but best compression',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'int NormalQuantizationBits',
        summary: `Sets the quantization compression options for normal values. The
     values will be quantized in a box defined by the maximum extent
     of the values. I.e., the actual precision of this option depends
     on the scale of the attribute values.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'int PositionQuantizationBits',
        summary: `Sets the quantization compression options for position values. The
     values will be quantized in a box defined by the maximum extent
     of the values. I.e., the actual precision of this option depends
     on the scale of the attribute values.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'int TextureCoordintateQuantizationBits',
        summary: `Sets the quantization compression options for texture coordinate
     values. The values will be quantized in a box defined by the maximum
     extent of the values. I.e., the actual precision of this option depends
     on the scale of the attribute values.`,
        since: 7,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dm',
    dataType: 1,
    summary: `Represents a 3dm file, which is stored using the OpenNURBS file standard.
   The 3dm format is the main Rhinoceros storage format.Visit http://www.opennurbs.com/ for more details.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'File3dm()',
        summary: 'Initializes a new instance of a 3dm file.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'File3dmDimStyleTable AllDimStyles',
        summary: 'Dimension Styles in this file.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'File3dmGroupTable AllGroups',
        summary: 'Grpups in this file.',
        since: 6.5,
        property: ['get']
      },
      {
        signature: 'File3dmHatchPatternTable AllHatchPatterns',
        summary: 'Hatch patterns in this file.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'File3dmInstanceDefinitionTable AllInstanceDefinitions',
        summary: 'Instance definitions in this file',
        since: 6,
        property: ['get']
      },
      {
        signature: 'File3dmLayerTable AllLayers',
        summary: 'Layers in this file.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'File3dmLinetypeTable AllLinetypes',
        summary: 'Linetypes in this file.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'File3dmMaterialTable AllMaterials',
        summary: 'Materials in this file.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'File3dmNamedConstructionPlanes AllNamedConstructionPlanes',
        summary: 'Named construction planes in this file.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'File3dmViewTable AllNamedViews',
        summary: 'Named views in this file.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'File3dmViewTable AllViews',
        summary: 'Views that represent the RhinoViews which are displayed when Rhino loads this file.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string ApplicationDetails',
        summary: 'Gets or sets details for the application that wrote this file.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string ApplicationName',
        summary: 'Gets or sets the name of the application that wrote this file.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string ApplicationUrl',
        summary: 'Gets or sets a URL for the application that wrote this file.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'DateTime Created',
        summary: `Get the DateTime that this file was originally created. If the
     value is not set in the 3dm file, then DateTime.MinValue is returned`,
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'string CreatedBy',
        summary: 'Gets a string that names the user who created the file.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'IList<DimensionStyle> DimStyles',
        summary: 'Dimension Styles in this file.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'IList<HatchPattern> HatchPatterns',
        summary: 'Hatch patterns in this file',
        since: 5,
        property: ['get']
      },
      {
        signature: 'IList<InstanceDefinitionGeometry> InstanceDefinitions',
        summary: 'Instance definitions in this file.',
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'DateTime LastEdited',
        summary: `Get the DateTime that this file was last edited. If the
     value is not set in the 3dm file, then DateTime.MinValue is returned`,
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'string LastEditedBy',
        summary: 'Gets a string that names the user who last edited the file.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'IList<Layer> Layers',
        summary: 'Layers in this file.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'IList<Linetype> Linetypes',
        summary: 'Linetypes in this file.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ManifestTable Manifest',
        summary: 'Retrieves the manifest with all object descriptions in this file.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'IList<Material> Materials',
        summary: 'Materials in this file.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'IList<ConstructionPlane> NamedConstructionPlanes',
        summary: 'Named construction planes in this file.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'IList<ViewInfo> NamedViews',
        summary: 'Named views in this file.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'File3dmNotes Notes',
        summary: 'Gets or sets the model notes.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'File3dmObjectTable Objects',
        summary: `Gets access to the File3dmObjectTable class associated with this file,
     which contains all objects.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'File3dmPlugInDataTable PlugInData',
        summary: 'Custom plug-in data in this file.  This data is not attached to any geometry or attributes',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Revision',
        summary: 'Gets or sets the revision number.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'File3dmSettings Settings',
        summary: `Settings include tolerance, and unit system, and defaults used
     for creating views and objects.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'string StartSectionComments',
        summary: 'Gets or sets the start section comments, which are the comments with which the 3dm file begins.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'File3dmStringTable Strings',
        summary: 'Document user strings in this file',
        since: 6,
        property: ['get']
      },
      {
        signature: 'IList<ViewInfo> Views',
        summary: 'Views that represent the RhinoViews which are displayed when Rhino loads this file.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static File3dm Read(string path)',
        summary: 'Reads a 3dm file from a specified location.',
        since: 5,
        parameters: [
          {
            name: 'path',
            summary: 'The file to read.'
          }
        ],
        returns: 'new File3dm on success, None on error.'
      },
      {
        signature: 'static File3dm Read(string path,TableTypeFilter tableTypeFilterFilter,ObjectTypeFilter objectTypeFilter)',
        summary: 'Reads a 3dm file from a specified location.',
        since: 5.9,
        parameters: [
          {
            name: 'path',
            summary: 'The file to read.'
          },
          {
            name: 'tableTypeFilterFilter',
            summary: `If tableTypeFilterFilter is None, then everything in the archive is read.
     Otherwise tableTypeFilterFilter identifies what tables should be read.`
          },
          {
            name: 'objectTypeFilter',
            summary: `If objectTypeFilter is not None, then is a filter made by bitwise oring
     values to select which types of objects will be read from the model object
     table.`
          }
        ],
        returns: 'new File3dm on success, None on error.'
      },
      {
        signature: 'static void ReadApplicationData(string path,string applicationName,string applicationUrl,string applicationDetails)',
        summary: 'Reads only the application information from an existing 3dm file.',
        since: 5,
        parameters: [
          {
            name: 'path',
            summary: 'A location on disk or network.'
          },
          {
            name: 'applicationName',
            summary: 'The application name. This out parameter is assigned during this call.'
          },
          {
            name: 'applicationUrl',
            summary: 'The application URL. This out parameter is assigned during this call.'
          },
          {
            name: 'applicationDetails',
            summary: 'The application details. This out parameter is assigned during this call.'
          }
        ]
      },
      {
        signature: 'static int ReadArchiveVersion(string path)',
        summary: 'Reads only the archive 3dm version from an existing 3dm file.',
        since: 5.1,
        parameters: [
          {
            name: 'path',
            summary: 'The file from which to read the archive version.'
          }
        ],
        returns: 'The 3dm file archive version.'
      },
      {
        signature: 'static DimensionStyle[] ReadDimensionStyles(string path)',
        summary: 'Read the dimension styles table out of a 3dm file.',
        since: 6,
        parameters: [
          {
            name: 'path',
            summary: 'The location of the file.'
          }
        ],
        returns: `Array of dimension styles on success (empty array if file does not contain dimension styles)
     None on error`
      },
      {
        signature: 'static string ReadNotes(string path)',
        summary: 'Reads only the notes from an existing 3dm file.',
        since: 5,
        parameters: [
          {
            name: 'path',
            summary: 'The file from which to read the notes.'
          }
        ],
        returns: 'The 3dm file notes.'
      },
      {
        signature: 'static System.Drawing.Bitmap ReadPreviewImage(string path)',
        summary: 'Attempts to read the preview image out of a 3dm file.',
        since: 5,
        parameters: [
          {
            name: 'path',
            summary: 'The location of the file.'
          }
        ],
        returns: 'A bitmap, or None on failure.'
      },
      {
        signature: 'static bool ReadRevisionHistory(string path,string createdBy,string lastEditedBy,int revision,DateTime createdOn,DateTime lastEditedOn)',
        summary: `Quickly check a file for it's revision information.  This function does
     not read the entire file, just what it needs to get revision information out`,
        since: 5.6,
        parameters: [
          {
            name: 'path',
            summary: 'path to the 3dm file'
          },
          {
            name: 'createdBy',
            summary: 'original author of the file'
          },
          {
            name: 'lastEditedBy',
            summary: 'last person to edit the file'
          },
          {
            name: 'revision',
            summary: 'which revision this file is at'
          },
          {
            name: 'createdOn',
            summary: 'date file was created (DateTime.MinValue if not set in file)'
          },
          {
            name: 'lastEditedOn',
            summary: 'date file was last edited (DateTime.MinValue if not set in file)'
          }
        ],
        returns: 'True on success'
      },
      {
        signature: 'static File3dm ReadWithLog(string path,string errorLog)',
        summary: `Read a 3dm file from a specified location and log any archive
     reading errors.`,
        since: 5,
        parameters: [
          {
            name: 'path',
            summary: 'The file to read.'
          },
          {
            name: 'errorLog',
            summary: 'Any archive reading errors are logged here.'
          }
        ],
        returns: 'New File3dm on success, None on error.'
      },
      {
        signature: 'static File3dm ReadWithLog(string path,TableTypeFilter tableTypeFilterFilter,ObjectTypeFilter objectTypeFilter,string errorLog)',
        summary: 'Reads a 3dm file from a specified location.',
        since: 5.9,
        parameters: [
          {
            name: 'path',
            summary: 'The file to read.'
          },
          {
            name: 'tableTypeFilterFilter',
            summary: `If tableTypeFilterFilter is None, then everything in the archive is read.
     Otherwise tableTypeFilterFilter identifies what tables should be read.`
          },
          {
            name: 'objectTypeFilter',
            summary: `If objectTypeFilter is not None, then is a filter made by bitwise oring
     values to select which types of objects will be read from the model object
     table.`
          },
          {
            name: 'errorLog',
            summary: 'Any archive reading errors are logged here.'
          }
        ],
        returns: 'new File3dm on success, None on error.'
      },
      {
        signature: 'int Audit(bool attemptRepair,int repairCount,string errors,int[] warnings)',
        summary: 'This function is only kept for forward assembly compatibility.',
        since: 5,
        parameters: [
          {
            name: 'attemptRepair',
            summary: 'Ignored.'
          },
          {
            name: 'repairCount',
            summary: 'Is set to 0.'
          },
          {
            name: 'errors',
            summary: 'Contains no meaninful error.'
          },
          {
            name: 'warnings',
            summary: 'Is set to null.'
          }
        ],
        returns: 'Returns 0.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'string Dump()',
        summary: 'Prepares a text dump of the entire model.',
        since: 5,
        returns: 'The text dump.'
      },
      {
        signature: 'string DumpSummary()',
        summary: 'Prepares a text dump of model properties and settings.',
        since: 5,
        returns: 'The text dump.'
      },
      {
        signature: 'void DumpToTextLog(TextLog log)',
        summary: 'Prepares a text dump of the entire model.',
        since: 5.1
      },
      {
        signature: 'System.Drawing.Bitmap GetPreviewImage()',
        summary: 'Preview image used for file explorer',
        since: 6
      },
      {
        signature: 'bool IsValid(string errors)',
        summary: `The File3dm object is kept consistent during its creation.
     Therefore, this function now returns only true.`,
        since: 5,
        parameters: [
          {
            name: 'errors',
            summary: 'No errors are found.'
          }
        ],
        returns: 'True in any case.'
      },
      {
        signature: 'bool IsValid(TextLog errors)',
        summary: `The File3dm object is kept consistent during its creation.
     Therefore, this function now returns only true.`,
        since: 5.1,
        parameters: [
          {
            name: 'errors',
            summary: 'No errors are found.'
          }
        ],
        returns: '>True in any case.'
      },
      {
        signature: 'void Polish()',
        summary: 'This function is only kept for forward assembly compatibility.',
        since: 5
      },
      {
        signature: 'void SetPreviewImage(Bitmap image)',
        summary: 'Preview image used for file explorer',
        since: 6
      },
      {
        signature: 'bool Write(string path,File3dmWriteOptions options)',
        summary: `Writes contents of this model to an openNURBS archive.
     If the model is not valid, then Write will refuse to write it.`,
        since: 5.9,
        parameters: [
          {
            name: 'path',
            summary: 'The file name to use for writing.'
          },
          {
            name: 'options',
            summary: 'An options instance, or None for default.'
          }
        ],
        returns: `True if archive is written with no error.
     False if errors occur.`
      },
      {
        signature: 'bool Write(string path,int version)',
        summary: `Writes contents of this model to an openNURBS archive.
     If the model is not valid, then Write will refuse to write it.`,
        since: 5,
        parameters: [
          {
            name: 'path',
            summary: 'The file name to use for writing.'
          },
          {
            name: 'version',
            summary: `Version of the openNURBS archive to write.  Must be [2; current version].
     Rhino can read its current version, plus earlier file versions except 1.
     Use latest version when possible.
     Alternatively, 0 is a placeholder for the last valid version.`
          }
        ],
        returns: `True if archive is written with no error.
     False if errors occur.`
      },
      {
        signature: 'bool WriteWithLog(string path,File3dmWriteOptions options,string errorLog)',
        summary: `Writes contents of this model to an openNURBS archive.
     If the model is not valid, then Write will refuse to write it.`,
        since: 6,
        parameters: [
          {
            name: 'path',
            summary: 'The file name to use for writing.'
          },
          {
            name: 'options',
            summary: 'An options instance, or None for default.'
          },
          {
            name: 'errorLog',
            summary: 'This argument will be filled by out reference.'
          }
        ],
        returns: `True if archive is written with no error.
     False if errors occur.`
      },
      {
        signature: 'bool WriteWithLog(string path,int version,string errorLog)',
        summary: `Writes contents of this model to an openNURBS archive.
     If the model is not valid, then Write will refuse to write it.`,
        since: 5,
        parameters: [
          {
            name: 'path',
            summary: 'The file name to use for writing.'
          },
          {
            name: 'version',
            summary: `Version of the openNURBS archive to write.  Must be [2; current version].
     Rhino can read its current version, plus earlier file versions except 1.
     Use latest version when possible.
     Alternatively, 0 is a placeholder for the last valid version.`
          },
          {
            name: 'errorLog',
            summary: 'This argument will be filled by out reference.'
          }
        ],
        returns: `True if archive is written with no error.
     False if errors occur.`
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dm.ObjectTypeFilter',
    dataType: 3,
    values: [
      {
        signature: 'None = UnsafeNativeMethods.ObjectTypeFilter.None'
      },
      {
        signature: 'Point = UnsafeNativeMethods.ObjectTypeFilter.Point',
        summary: 'some type of Point'
      },
      {
        signature: 'Pointset = UnsafeNativeMethods.ObjectTypeFilter.Pointset',
        summary: 'some type of PointCloud, PointGrid, ...'
      },
      {
        signature: 'Curve = UnsafeNativeMethods.ObjectTypeFilter.Curve',
        summary: 'some type of Curve like LineCurve, NurbsCurve, etc.'
      },
      {
        signature: 'Surface = UnsafeNativeMethods.ObjectTypeFilter.Surface',
        summary: 'some type of Surface like PlaneSurface, NurbsSurface, etc.'
      },
      {
        signature: 'Brep = UnsafeNativeMethods.ObjectTypeFilter.Brep',
        summary: 'some type of Brep'
      },
      {
        signature: 'Mesh = UnsafeNativeMethods.ObjectTypeFilter.Mesh',
        summary: 'some type of Mesh'
      },
      {
        signature: 'Annotation = UnsafeNativeMethods.ObjectTypeFilter.Annotation',
        summary: 'some type of Annotation'
      },
      {
        signature: 'InstanceDefinition = UnsafeNativeMethods.ObjectTypeFilter.InstanceDefinition',
        summary: 'some type of InstanceDefinition'
      },
      {
        signature: 'InstanceReference = UnsafeNativeMethods.ObjectTypeFilter.InstanceReference',
        summary: 'some type of InstanceReference'
      },
      {
        signature: 'TextDot = UnsafeNativeMethods.ObjectTypeFilter.TextDot',
        summary: 'some type of TextDot'
      },
      {
        signature: 'DetailView = UnsafeNativeMethods.ObjectTypeFilter.Detail',
        summary: 'some type of DetailView'
      },
      {
        signature: 'Hatch = UnsafeNativeMethods.ObjectTypeFilter.Hatch',
        summary: 'some type of Hatch'
      },
      {
        signature: 'Extrusion = UnsafeNativeMethods.ObjectTypeFilter.Extrusion',
        summary: 'some type of Extrusion'
      },
      {
        signature: 'Any = UnsafeNativeMethods.ObjectTypeFilter.Any'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dm.TableTypeFilter',
    dataType: 3,
    values: [
      {
        signature: 'None = UnsafeNativeMethods.ReadFileTableTypeFilter.None'
      },
      {
        signature: 'Properties = UnsafeNativeMethods.ReadFileTableTypeFilter.PropertiesTable'
      },
      {
        signature: 'Settings = UnsafeNativeMethods.ReadFileTableTypeFilter.SettingsTable'
      },
      {
        signature: 'Bitmap = UnsafeNativeMethods.ReadFileTableTypeFilter.BitmapTable'
      },
      {
        signature: 'TextureMapping = UnsafeNativeMethods.ReadFileTableTypeFilter.TextureMappingTable'
      },
      {
        signature: 'Material = UnsafeNativeMethods.ReadFileTableTypeFilter.MaterialTable'
      },
      {
        signature: 'Linetype = UnsafeNativeMethods.ReadFileTableTypeFilter.LinetypeTable'
      },
      {
        signature: 'Layer = UnsafeNativeMethods.ReadFileTableTypeFilter.LayerTable'
      },
      {
        signature: 'Group = UnsafeNativeMethods.ReadFileTableTypeFilter.GroupTable'
      },
      {
        signature: 'Font = UnsafeNativeMethods.ReadFileTableTypeFilter.FontTable'
      },
      {
        signature: 'FutureFont = UnsafeNativeMethods.ReadFileTableTypeFilter.FutureFontTable'
      },
      {
        signature: 'Dimstyle = UnsafeNativeMethods.ReadFileTableTypeFilter.DimstyleTable'
      },
      {
        signature: 'Light = UnsafeNativeMethods.ReadFileTableTypeFilter.LightTable'
      },
      {
        signature: 'Hatchpattern = UnsafeNativeMethods.ReadFileTableTypeFilter.HatchpatternTable'
      },
      {
        signature: 'InstanceDefinition = UnsafeNativeMethods.ReadFileTableTypeFilter.InstanceDefinitionTable'
      },
      {
        signature: 'ObjectTable = UnsafeNativeMethods.ReadFileTableTypeFilter.ObjectTable'
      },
      {
        signature: 'Historyrecord = UnsafeNativeMethods.ReadFileTableTypeFilter.HistoryrecordTable'
      },
      {
        signature: 'UserTable = UnsafeNativeMethods.ReadFileTableTypeFilter.UserTable'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmCommonComponentTable',
    dataType: 1,
    summary: 'Provides a base table type that is shared among all File3dm tables.',
    baseclass: 'CommonComponentTable<T>',
    interfaces: ['ICollection<T>'],
    methods: [
      {
        signature: 'void Add(T item)',
        summary: 'Adds an item.',
        parameters: [
          {
            name: 'item',
            summary: 'The item to add.'
          }
        ]
      },
      {
        signature: 'void Delete(int index)',
        summary: 'Flags a component as deleted.',
        parameters: [
          {
            name: 'index',
            summary: 'The index of the item to flag.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'bool Delete(T item)',
        summary: 'Flags a component as deleted.',
        parameters: [
          {
            name: 'item',
            summary: 'The item to flag.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'string Dump()',
        summary: 'Prepares a text dump of object table.',
        returns: 'A string containing the dump.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmDimStyleTable',
    dataType: 1,
    summary: 'Provides access to annotation styles in the 3dm file.',
    baseclass: 'File3dmCommonComponentTable<DimensionStyle>',
    interfaces: ['IList<DimensionStyle>'],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.DimStyle.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'DimensionStyle FindIndex(int index)',
        summary: `Retrieves a DimensionStyle object based on Index. This search type of search is discouraged.
     We are moving towards using only IDs for all tables.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index to search for.'
          }
        ],
        returns: 'A DimensionStyle object, or None if none was found.'
      },
      {
        signature: 'DimensionStyle FindName(string name)',
        summary: 'Finds a DimensionStyle given its name.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the DimensionStyle to be searched.'
          }
        ],
        returns: 'An DimensionStyle, or None on error.'
      },
      {
        signature: 'DimensionStyle FindNameHash(NameHash nameHash)',
        summary: 'Finds a DimensionStyle given its name hash.',
        since: 6,
        parameters: [
          {
            name: 'nameHash',
            summary: 'The name hash of the DimensionStyle to be searched.'
          }
        ],
        returns: 'An DimensionStyle, or None on error.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmGroupTable',
    dataType: 1,
    summary: 'Provides access to groups in the 3dm file.',
    baseclass: 'File3dmCommonComponentTable<Group>',
    interfaces: ['IList<Group>'],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.Group.',
        since: 6.5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Group FindIndex(int groupIndex)',
        summary: `Retrieves a Group object based on an index. This search type of search is discouraged.
     We are moving towards using only IDs for all tables.`,
        since: 6.5,
        parameters: [
          {
            name: 'groupIndex',
            summary: 'The index to search for.'
          }
        ],
        returns: 'A Group object, or None if none was found.'
      },
      {
        signature: 'Group FindName(string name)',
        summary: 'Finds a Group given its name.',
        since: 6.5,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the Group to be searched.'
          }
        ],
        returns: 'A Group, or None on error.'
      },
      {
        signature: 'Group FindNameHash(NameHash nameHash)',
        summary: 'Finds a Group given its name hash.',
        since: 6.5,
        parameters: [
          {
            name: 'nameHash',
            summary: 'The name hash of the Group to be searched.'
          }
        ],
        returns: 'A Group, or None on error.'
      },
      {
        signature: 'File3dmObject[] GroupMembers(int groupIndex)',
        summary: 'Gets an array of all of the objects in a group.',
        since: 6.2,
        parameters: [
          {
            name: 'groupIndex',
            summary: 'The index of the group in this table.'
          }
        ],
        returns: 'Array of objects that belong to the specified group or empty array if no objects could be found.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmHatchPatternTable',
    dataType: 1,
    summary: 'Provides access to hatch pattern definitions in the 3dm file.',
    baseclass: 'File3dmCommonComponentTable<HatchPattern>',
    interfaces: ['IList<HatchPattern>'],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.HatchPattern.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'HatchPattern FindIndex(int index)',
        summary: `Retrieves a HatchPattern object based on Index. This search type of search is discouraged.
     We are moving towards using only IDs for all tables.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index to search for.'
          }
        ],
        returns: 'A HatchPattern object, or None if none was found.'
      },
      {
        signature: 'HatchPattern FindName(string name)',
        summary: 'Finds a HatchPattern given its name.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the HatchPattern to be searched.'
          }
        ],
        returns: 'An HatchPattern, or None on error.'
      },
      {
        signature: 'HatchPattern FindNameHash(NameHash nameHash)',
        summary: 'Finds a HatchPattern given its name hash.',
        since: 6,
        parameters: [
          {
            name: 'nameHash',
            summary: 'The name hash of the HatchPattern to be searched.'
          }
        ],
        returns: 'An HatchPattern, or None on error.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmInstanceDefinitionTable',
    dataType: 1,
    summary: 'Provides access to instance (block) definitions in the 3dm file.',
    baseclass: 'File3dmCommonComponentTable<InstanceDefinitionGeometry>',
    interfaces: ['IList<InstanceDefinitionGeometry>'],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.InstanceDefinition.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int Add(string name,string description,Point3d basePoint,GeometryBase geometry,ObjectAttributes attributes)',
        summary: 'Adds an instance definition to the instance definition table.',
        since: 6.5,
        parameters: [
          {
            name: 'name',
            summary: 'The definition name.'
          },
          {
            name: 'description',
            summary: 'The definition description.'
          },
          {
            name: 'basePoint',
            summary: 'A base point.'
          },
          {
            name: 'geometry',
            summary: 'An element.'
          },
          {
            name: 'attributes',
            summary: 'An attribute.'
          }
        ],
        returns: '>=0  index of instance definition in the instance definition table. -1 on failure.'
      },
      {
        signature: 'int Add(string name,string description,Point3d basePoint,IEnumerable<GeometryBase> geometry)',
        summary: 'Adds an instance definition to the instance definition table.',
        since: 6.5,
        parameters: [
          {
            name: 'name',
            summary: 'The definition name.'
          },
          {
            name: 'description',
            summary: 'The definition description.'
          },
          {
            name: 'basePoint',
            summary: 'A base point.'
          },
          {
            name: 'geometry',
            summary: 'An array, a list or any enumerable set of geometry.'
          }
        ],
        returns: '>=0  index of instance definition in the instance definition table. -1 on failure.'
      },
      {
        signature: 'int Add(string name,string description,Point3d basePoint,IEnumerable<GeometryBase> geometry,IEnumerable<ObjectAttributes> attributes)',
        summary: 'Adds an instance definition to the instance definition table.',
        since: 6.5,
        parameters: [
          {
            name: 'name',
            summary: 'The definition name.'
          },
          {
            name: 'description',
            summary: 'The definition description.'
          },
          {
            name: 'basePoint',
            summary: 'A base point.'
          },
          {
            name: 'geometry',
            summary: 'An array, a list or any enumerable set of geometry.'
          },
          {
            name: 'attributes',
            summary: 'An array, a list or any enumerable set of attributes.'
          }
        ],
        returns: '>=0  index of instance definition in the instance definition table. -1 on failure.'
      },
      {
        signature: 'int AddLinked(string filename,string name,string description)',
        summary: 'Adds a linked instance definition to the instance definition table.',
        since: 6.13,
        parameters: [
          {
            name: 'filename',
            summary: 'Full path of the file to link.'
          },
          {
            name: 'name',
            summary: 'The definition name.'
          },
          {
            name: 'description',
            summary: 'The definition description.'
          }
        ]
      },
      {
        signature: 'InstanceDefinitionGeometry FindName(string name)',
        summary: 'Finds an InstanceDefinitionGeometry given its name.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the InstanceDefinitionGeometry to be searched.'
          }
        ],
        returns: 'An InstanceDefinitionGeometry, or None on error.'
      },
      {
        signature: 'InstanceDefinitionGeometry FindNameHash(NameHash nameHash)',
        summary: 'Finds a InstanceDefinitionGeometry given its name hash.',
        since: 6,
        parameters: [
          {
            name: 'nameHash',
            summary: 'The name hash of the InstanceDefinitionGeometry to be searched.'
          }
        ],
        returns: 'An InstanceDefinitionGeometry, or None on error.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmLayerTable',
    dataType: 1,
    summary: 'Provides access to layers in the 3dm file.',
    baseclass: 'File3dmCommonComponentTable<Layer>',
    interfaces: ['IList<Layer>'],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.Layer.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Layer FindIndex(int index)',
        summary: `Retrieves a Layer object based on Index. This search type of search is discouraged.
     We are moving towards using only IDs for all tables.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index to search for.'
          }
        ],
        returns: 'A Layer object, or None if none was found.'
      },
      {
        signature: 'Layer FindName(string name,Guid parentId)',
        summary: 'Finds a Layer given its name.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the Layer to be searched.'
          },
          {
            name: 'parentId',
            summary: 'The id of the parent Layer to be searched.'
          }
        ],
        returns: 'A Layer, or None on error.'
      },
      {
        signature: 'Layer FindNameHash(NameHash nameHash)',
        summary: 'Finds a Layer given its name hash.',
        since: 6,
        parameters: [
          {
            name: 'nameHash',
            summary: 'The name hash of the Layer to be searched.'
          }
        ],
        returns: 'An Layer, or None on error.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmLinetypeTable',
    dataType: 1,
    summary: 'Provides access to Linetypes in the 3dm file.',
    baseclass: 'File3dmCommonComponentTable<Linetype>',
    interfaces: ['IList<DocObjects.Linetype>'],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.LinePattern.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Linetype FindIndex(int index)',
        summary: `Retrieves a Linetype object based on Index. This search type of search is discouraged.
     We are moving towards using only IDs for all tables.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index to search for.'
          }
        ],
        returns: 'A Linetype, or None if none was found.'
      },
      {
        signature: 'Linetype FindName(string name)',
        summary: 'Finds a Linetype given its name.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the Linetype to be searched.'
          }
        ],
        returns: 'A Linetype, or None on error.'
      },
      {
        signature: 'Linetype FindNameHash(NameHash nameHash)',
        summary: 'Finds a Linetype given its name hash.',
        since: 6,
        parameters: [
          {
            name: 'nameHash',
            summary: 'The name hash of the Linetype to be searched.'
          }
        ],
        returns: 'An Linetype, or None on error.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmMaterialTable',
    dataType: 1,
    summary: 'Provides access to materials in the 3dm file.',
    baseclass: 'File3dmCommonComponentTable<Material>',
    interfaces: ['IList<DocObjects.Material>'],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.RenderMaterial.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'DocObjects.Material FindIndex(int index)',
        summary: `Retrieves a material based on Index. This search type of search is discouraged.
     We are moving towards using only IDs for all tables.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index to search for.'
          }
        ],
        returns: 'A material, or None if none was found.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmNamedConstructionPlanes',
    dataType: 1,
    summary: 'Provides access to namned construction planes in the 3dm file.',
    interfaces: ['IList<ConstructionPlane>', 'Collections.IRhinoTable<ConstructionPlane>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Number of named construction planes in the table.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(ConstructionPlane cplane)',
        summary: 'Adds a named construction plane to the table.',
        since: 6,
        parameters: [
          {
            name: 'cplane',
            summary: 'The construction plane to add.'
          }
        ]
      },
      {
        signature: 'int Add(string name,Plane plane)',
        summary: 'Adds a named construction plane to the table.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the named construction plane.'
          },
          {
            name: 'plane',
            summary: 'The plane value.'
          }
        ],
        returns: `0 based index of the named construction plane.
     -1 on failure.`
      },
      {
        signature: 'void Clear()',
        summary: 'Removes all named construction planes from the table.',
        since: 6
      },
      {
        signature: 'bool Contains(ConstructionPlane cplane)',
        summary: 'Returns an indication of the presence of a named construction plane in the table.',
        since: 6,
        parameters: [
          {
            name: 'cplane',
            summary: 'The construction plane to check.'
          }
        ],
        returns: 'True if the named construction plane is in the table; False otherwise.'
      },
      {
        signature: 'void CopyTo(ConstructionPlane[] array,int arrayIndex)',
        summary: 'Copies the content of the table to an array.',
        since: 6
      },
      {
        signature: 'bool Delete(ConstructionPlane cplane)',
        summary: 'Deletes a named construction plane from the table.',
        since: 6,
        parameters: [
          {
            name: 'cplane',
            summary: 'The construction plane to delete.'
          }
        ]
      },
      {
        signature: 'bool Delete(int index)',
        summary: 'Remove a named construction plane from the table.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'Zero based array index.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'ConstructionPlane FindName(string name)',
        summary: 'Finds a named construction plane given its name.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the construction plane to be searched.'
          }
        ],
        returns: 'A ConstructionPlane, or None if not found.'
      },
      {
        signature: 'IEnumerator<ConstructionPlane> GetEnumerator()',
        summary: 'Gets an enumerator that yields all construction planes in this collection.',
        since: 6,
        returns: 'The enumerator.'
      },
      {
        signature: 'int IndexOf(ConstructionPlane cplane)',
        summary: 'Returns the index of a named construction plane.',
        since: 6,
        parameters: [
          {
            name: 'cplane',
            summary: 'The construction plane to be searched.'
          }
        ],
        returns: 'The index of the named construction plane, -1 if not found.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmNotes',
    dataType: 1,
    summary: 'Represents the notes information stored in a 3dm file.',
    constructors: [
      {
        signature: 'File3dmNotes()',
        summary: 'Creates empty default notes',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'bool IsHtml',
        summary: 'Gets or sets the text format. If the format is HTML, true; False otherwise.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsVisible',
        summary: 'Gets or sets the notes visibility. If the notes are visible, true; False otherwise.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Notes',
        summary: 'Gets or sets the text content of the notes.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Rectangle WindowRectangle',
        summary: 'Gets or sets the position of the Notes when they were saved.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmObject',
    dataType: 1,
    summary: 'Used to store geometry table object definition and attributes in a File3dm.',
    baseclass: 'Rhino.DocObjects.ModelComponent',
    interfaces: ['IEquatable<File3dmObject>'],
    properties: [
      {
        signature: 'ObjectAttributes Attributes',
        summary: 'Gets the attributes that are linked with this document object.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.ModelGeometry.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'GeometryBase Geometry',
        summary: 'Gets the geometry that is linked with this document object.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string Name',
        summary: 'Gets or sets the Name of the object. Equivalent to this.Attributes.Name.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'bool Equals(File3dmObject other)',
        summary: 'Verified that two File3dmObject items refer to the same object in a document.',
        since: 6,
        parameters: [
          {
            name: 'other',
            summary: 'The other item to test.'
          }
        ],
        returns: 'True is the two objects coincide.'
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Verified that two objects refer to the same object in a document.',
        parameters: [
          {
            name: 'obj',
            summary: 'The other item to test.'
          }
        ],
        returns: 'True is the two objects coincide.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Provides an hash code for this item.',
        returns: 'The hash code.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmObjectTable',
    dataType: 1,
    summary: `Represents a simple object table for a file that is open externally.
   This class mimics Rhino.DocObjects.Tables.ObjectTable while providing external eccess to the file.`,
    baseclass: 'File3dmCommonComponentTable<File3dmObject>',
    interfaces: ['IEnumerable<File3dmObject>'],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.ModelGeometry.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int Count',
        summary: 'Returns the total amount of items in the object table, including lights.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(File3dmObject item)',
        summary: 'Duplicates the object, then adds a copy of the object to the document.',
        since: 6,
        parameters: [
          {
            name: 'item',
            summary: 'The item to duplicate and add.'
          }
        ]
      },
      {
        signature: 'Guid AddAngularDimension(AngularDimension dimension)',
        summary: 'Adds a angular dimension object to the 3dm file object table.',
        since: 6.5,
        parameters: [
          {
            name: 'dimension',
            summary: 'Dimension object to add.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddAngularDimension(AngularDimension dimension,ObjectAttributes attributes)',
        summary: 'Adds a angular dimension object to the 3dm file object table.',
        since: 6.5,
        parameters: [
          {
            name: 'dimension',
            summary: 'Dimension object to add.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to dimension.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddArc(Arc arc)',
        summary: 'Adds a curve object to the document representing an arc.',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'An arc.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddArc(Arc arc,ObjectAttributes attributes)',
        summary: 'Adds a curve object to the document representing an arc.',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'An arc to add.'
          },
          {
            name: 'attributes',
            summary: 'attributes to apply to arc.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddBrep(Brep brep)',
        summary: 'Adds a brep object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'A duplicate of this brep is added to Rhino.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddBrep(Brep brep,ObjectAttributes attributes)',
        summary: 'Adds a brep object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'A duplicate of this brep is added to Rhino.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to brep.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddCircle(Circle circle)',
        summary: 'Adds a curve object to the document representing a circle.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'A circle to add.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddCircle(Circle circle,ObjectAttributes attributes)',
        summary: 'Adds a curve object to the document representing a circle.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'A circle to add.'
          },
          {
            name: 'attributes',
            summary: 'attributes to apply to circle.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,Guid clippedViewportId)',
        summary: 'Adds a clipping plane object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'A plane.'
          },
          {
            name: 'uMagnitude',
            summary: 'The size in U direction.'
          },
          {
            name: 'vMagnitude',
            summary: 'The size in V direction.'
          },
          {
            name: 'clippedViewportId',
            summary: 'The viewport id that the new clipping plane will clip.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,IEnumerable<Guid> clippedViewportIds)',
        summary: 'Adds a clipping plane object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'A plane.'
          },
          {
            name: 'uMagnitude',
            summary: 'The size in U direction.'
          },
          {
            name: 'vMagnitude',
            summary: 'The size in V direction.'
          },
          {
            name: 'clippedViewportIds',
            summary: 'A list, an array or any enumerable of viewport ids that the new clipping plane will clip.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,IEnumerable<Guid> clippedViewportIds,ObjectAttributes attributes)',
        summary: 'Adds a clipping plane object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'A plane.'
          },
          {
            name: 'uMagnitude',
            summary: 'The size in U direction.'
          },
          {
            name: 'vMagnitude',
            summary: 'The size in V direction.'
          },
          {
            name: 'clippedViewportIds',
            summary: 'list of viewport ids that the new clipping plane will clip.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to point cloud.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddCurve(Curve curve)',
        summary: 'Adds a curve object to the table.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'A curve to add.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddCurve(Curve curve,ObjectAttributes attributes)',
        summary: 'Adds a curve object to the table.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'A duplicate of this curve is added to Rhino.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to curve.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddEllipse(Ellipse ellipse)',
        summary: 'Adds a curve object to the document representing an ellipse.',
        since: 5,
        parameters: [
          {
            name: 'ellipse',
            summary: 'An ellipse to add.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddEllipse(Ellipse ellipse,ObjectAttributes attributes)',
        summary: 'Adds a curve object to the document representing an ellipse.',
        since: 5,
        parameters: [
          {
            name: 'ellipse',
            summary: 'An ellipse to add.'
          },
          {
            name: 'attributes',
            summary: 'attributes to apply to ellipse.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddExtrusion(Extrusion extrusion)',
        summary: 'Adds an extrusion object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'extrusion',
            summary: 'A duplicate of this extrusion is added to Rhino.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddExtrusion(Extrusion extrusion,ObjectAttributes attributes)',
        summary: 'Adds an extrusion object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'extrusion',
            summary: 'A duplicate of this extrusion is added to Rhino.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to link to the object.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddHatch(Hatch hatch)',
        summary: 'Adds a hatch to the document.',
        since: 5,
        parameters: [
          {
            name: 'hatch',
            summary: 'A hatch.'
          }
        ],
        returns: 'A unique identifier for the hatch, or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddHatch(Hatch hatch,ObjectAttributes attributes)',
        summary: 'Adds a hatch to the document.',
        since: 5,
        parameters: [
          {
            name: 'hatch',
            summary: 'A hatch.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to brep.'
          }
        ],
        returns: 'A unique identifier for the hatch, or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddInstanceObject(InstanceReferenceGeometry instanceReference)',
        summary: 'Adds an instance reference geometry object to the table.',
        since: 6.5,
        parameters: [
          {
            name: 'instanceReference',
            summary: 'The instance reference geometry object.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddInstanceObject(InstanceReferenceGeometry instanceReference,ObjectAttributes attributes)',
        summary: 'Adds an instance reference geometry object to the table.',
        since: 6.5,
        parameters: [
          {
            name: 'instanceReference',
            summary: 'The instance reference geometry object.'
          },
          {
            name: 'attributes',
            summary: 'The attributes to link with the object.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddInstanceObject(int instanceDefinitionIndex,Transform instanceXform)',
        summary: 'Adds an instance reference geometry object to the table.',
        since: 6.5,
        parameters: [
          {
            name: 'instanceDefinitionIndex',
            summary: 'The index of the instance definition geometry object.'
          },
          {
            name: 'instanceXform',
            summary: 'The transformation.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddInstanceObject(int instanceDefinitionIndex,Transform instanceXform,ObjectAttributes attributes)',
        summary: 'Adds an instance reference geometry object to the table.',
        since: 6.5,
        parameters: [
          {
            name: 'instanceDefinitionIndex',
            summary: 'The index of the instance definition geometry object.'
          },
          {
            name: 'instanceXform',
            summary: 'The transformation.'
          },
          {
            name: 'attributes',
            summary: 'The object attributes.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddLeader(IEnumerable<Point3d> points)',
        summary: 'Adds an annotation leader to the document. This overload is only provided in the Rhino SDK.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of 2d points.'
          }
        ],
        returns: 'A unique identifier for the object; or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddLeader(Plane plane,IEnumerable<Point2d> points)',
        summary: 'Adds an annotation leader to the document.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'A plane.'
          },
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of 2d points.'
          }
        ],
        returns: 'A unique identifier for the object; or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddLeader(Plane plane,IEnumerable<Point2d> points,ObjectAttributes attributes)',
        summary: 'Adds an annotation leader to the document.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'A plane.'
          },
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of 2d points.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to brep.'
          }
        ],
        returns: 'A unique identifier for the object; or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddLeader(string text,IEnumerable<Point3d> points)',
        summary: 'Adds an annotation leader to the document. This overload is only provided in the Rhino SDK.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'The text.'
          },
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of 2d points.'
          }
        ],
        returns: 'A unique identifier for the object; or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddLeader(string text,Plane plane,IEnumerable<Point2d> points)',
        summary: 'Adds an annotation leader to the document.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'The text.'
          },
          {
            name: 'plane',
            summary: 'A plane.'
          },
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of 2d points.'
          }
        ],
        returns: 'A unique identifier for the object; or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddLeader(string text,Plane plane,IEnumerable<Point2d> points,ObjectAttributes attributes)',
        summary: 'Adds an annotation leader to the document.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'The text.'
          },
          {
            name: 'plane',
            summary: 'A plane.'
          },
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of 2d points.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to brep.'
          }
        ],
        returns: 'A unique identifier for the object; or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddLine(Line line)',
        summary: 'Adds a line object to Rhino.',
        since: 5,
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddLine(Line line,ObjectAttributes attributes)',
        summary: 'Adds a line object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'A line.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to line.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddLine(Point3d from,Point3d to)',
        summary: 'Adds a line object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'from',
            summary: 'A line start point.'
          },
          {
            name: 'to',
            summary: 'A line end point.'
          }
        ],
        returns: 'A unique identifier of new rhino object.'
      },
      {
        signature: 'Guid AddLine(Point3d from,Point3d to,ObjectAttributes attributes)',
        summary: 'Adds a line object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'from',
            summary: 'The start point of the line.'
          },
          {
            name: 'to',
            summary: 'The end point of the line.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to line.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddLinearDimension(LinearDimension dimension)',
        summary: 'Adds a linear dimension to the 3dm file object table.',
        since: 5,
        parameters: [
          {
            name: 'dimension',
            summary: 'A dimension.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddLinearDimension(LinearDimension dimension,ObjectAttributes attributes)',
        summary: 'Adds a linear dimension to the 3dm file object table.',
        since: 5,
        parameters: [
          {
            name: 'dimension',
            summary: 'A dimension.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to dimension.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddMesh(Mesh mesh)',
        summary: 'Adds a mesh object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'A duplicate of this mesh is added to Rhino.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddMesh(Mesh mesh,ObjectAttributes attributes)',
        summary: 'Adds a mesh object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'A duplicate of this mesh is added to Rhino.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to link to the object.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPoint(double x,double y,double z)',
        summary: 'Adds a point object to the table.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X component of point coordinate.'
          },
          {
            name: 'y',
            summary: 'Y component of point coordinate.'
          },
          {
            name: 'z',
            summary: 'Z component of point coordinate.'
          }
        ],
        returns: 'id of new object.'
      },
      {
        signature: 'Guid AddPoint(Point3d point)',
        summary: 'Adds a point object to the table.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A location for point.'
          }
        ],
        returns: 'Id of new object.'
      },
      {
        signature: 'Guid AddPoint(Point3d point,ObjectAttributes attributes)',
        summary: 'Adds a point object to the document.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A location for point.'
          },
          {
            name: 'attributes',
            summary: 'attributes to apply to point.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPoint(Point3f point)',
        summary: 'Adds a point object to the document.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'location of point.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPoint(Point3f point,ObjectAttributes attributes)',
        summary: 'Adds a point object to the document.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'location of point.'
          },
          {
            name: 'attributes',
            summary: 'attributes to apply to point.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPointCloud(IEnumerable<Point3d> points)',
        summary: 'Adds a point cloud object to the document.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of Point3d.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPointCloud(IEnumerable<Point3d> points,ObjectAttributes attributes)',
        summary: 'Adds a point cloud object to the document.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of Point3d.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to point cloud.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPointCloud(PointCloud cloud)',
        summary: 'Adds a point cloud object to the document.',
        since: 5,
        parameters: [
          {
            name: 'cloud',
            summary: 'PointCloud to add.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPointCloud(PointCloud cloud,ObjectAttributes attributes)',
        summary: 'Adds a point cloud object to the document.',
        since: 5,
        parameters: [
          {
            name: 'cloud',
            summary: 'PointCloud to add.'
          },
          {
            name: 'attributes',
            summary: 'attributes to apply to point cloud.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid[] AddPoints(IEnumerable<Point3d> points)',
        summary: 'Adds multiple points to the document.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to add.'
          }
        ],
        returns: 'List of object ids.'
      },
      {
        signature: 'Guid[] AddPoints(IEnumerable<Point3d> points,ObjectAttributes attributes)',
        summary: 'Adds multiple points to the document.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to add.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to point objects.'
          }
        ],
        returns: 'An array of object unique identifiers.'
      },
      {
        signature: 'Guid[] AddPoints(IEnumerable<Point3f> points)',
        summary: 'Adds multiple points to the document.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to add.'
          }
        ],
        returns: 'An array of object unique identifiers.'
      },
      {
        signature: 'Guid[] AddPoints(IEnumerable<Point3f> points,ObjectAttributes attributes)',
        summary: 'Adds multiple points to the document.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to add.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to point objects.'
          }
        ],
        returns: 'An array of object unique identifiers.'
      },
      {
        signature: 'Guid AddPolyline(IEnumerable<Point3d> points)',
        summary: 'Adds a polyline object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of Point3d.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddPolyline(IEnumerable<Point3d> points,ObjectAttributes attributes)',
        summary: 'Adds a polyline object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of Point3d.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to apply to line.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddSphere(Sphere sphere)',
        summary: 'Adds a surface object to the document representing a sphere.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'A sphere to add.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddSphere(Sphere sphere,ObjectAttributes attributes)',
        summary: 'Adds a surface object to the document representing a sphere.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'A sphere to add.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to link with the sphere.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddSurface(Surface surface)',
        summary: 'Adds a surface object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'A duplicate of this surface is added to Rhino.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddSurface(Surface surface,ObjectAttributes attributes)',
        summary: 'Adds a surface object to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'A duplicate of this surface is added to Rhino.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to link to the object.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic)',
        summary: 'Adds an annotation text object to the document.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text string.'
          },
          {
            name: 'plane',
            summary: 'Plane of text.'
          },
          {
            name: 'height',
            summary: 'Height of text.'
          },
          {
            name: 'fontName',
            summary: 'Name of FontFace.'
          },
          {
            name: 'bold',
            summary: 'Bold flag.'
          },
          {
            name: 'italic',
            summary: 'Italic flag.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,ObjectAttributes attributes)',
        summary: 'Adds an annotation text object to the document.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text string.'
          },
          {
            name: 'plane',
            summary: 'Plane of text.'
          },
          {
            name: 'height',
            summary: 'Height of text.'
          },
          {
            name: 'fontName',
            summary: 'Name of FontFace.'
          },
          {
            name: 'bold',
            summary: 'Bold flag.'
          },
          {
            name: 'italic',
            summary: 'Italic flag.'
          },
          {
            name: 'attributes',
            summary: 'Object Attributes.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,TextJustification justification)',
        summary: 'Adds an annotation text object to the document.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text string.'
          },
          {
            name: 'plane',
            summary: 'Plane of text.'
          },
          {
            name: 'height',
            summary: 'Height of text.'
          },
          {
            name: 'fontName',
            summary: 'Name of FontFace.'
          },
          {
            name: 'bold',
            summary: 'Bold flag.'
          },
          {
            name: 'italic',
            summary: 'Italic flag.'
          },
          {
            name: 'justification',
            summary: 'The justification of the text.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,TextJustification justification,ObjectAttributes attributes)',
        summary: 'Adds an annotation text object to the document.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text string.'
          },
          {
            name: 'plane',
            summary: 'Plane of text.'
          },
          {
            name: 'height',
            summary: 'Height of text.'
          },
          {
            name: 'fontName',
            summary: 'Name of FontFace.'
          },
          {
            name: 'bold',
            summary: 'Bold flag.'
          },
          {
            name: 'italic',
            summary: 'Italic flag.'
          },
          {
            name: 'justification',
            summary: 'The justification of the text.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to link to the object.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddText(Text3d text3d)',
        summary: 'Adds an annotation text object to the document.',
        since: 5,
        parameters: [
          {
            name: 'text3d',
            summary: 'The text object to add.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddText(Text3d text3d,ObjectAttributes attributes)',
        summary: 'Adds an annotation text object to the document.',
        since: 5,
        parameters: [
          {
            name: 'text3d',
            summary: 'The text object to add.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to link to the object.'
          }
        ],
        returns: 'The Guid of the newly added object or Guid.Empty on failure.'
      },
      {
        signature: 'Guid AddTextDot(string text,Point3d location)',
        summary: 'Adds a text dot object to the table.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'The text.'
          },
          {
            name: 'location',
            summary: 'The location.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddTextDot(string text,Point3d location,ObjectAttributes attributes)',
        summary: 'Adds a text dot object to the table.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'The text.'
          },
          {
            name: 'location',
            summary: 'The location.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to link with curve.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddTextDot(TextDot dot)',
        summary: 'Adds a text dot object to the table.',
        since: 5,
        parameters: [
          {
            name: 'dot',
            summary: 'The text dot.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'Guid AddTextDot(TextDot dot,ObjectAttributes attributes)',
        summary: 'Adds a text dot object to the table.',
        since: 5,
        parameters: [
          {
            name: 'dot',
            summary: 'The text dot.'
          },
          {
            name: 'attributes',
            summary: 'Attributes to link with text dot.'
          }
        ],
        returns: 'A unique identifier for the object.'
      },
      {
        signature: 'bool Delete(Guid objectId)',
        summary: 'Deletes object from document.',
        since: 5.2,
        parameters: [
          {
            name: 'objectId',
            summary: 'Id of the object to delete.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'int Delete(IEnumerable<Guid> objectIds)',
        summary: 'Deletes a collection of objects from the document.',
        since: 5.2,
        parameters: [
          {
            name: 'objectIds',
            summary: 'Ids of all objects to delete.'
          }
        ],
        returns: 'The number of successfully deleted objects.'
      },
      {
        signature: 'File3dmObject[] FindByGroup(Group group)',
        summary: 'Finds all File3dmObject that are in a given group.',
        since: 6.2,
        parameters: [
          {
            name: 'group',
            summary: 'A group instance.'
          }
        ],
        returns: 'Array of objects that belong to the specified group or empty array if no objects could be found.'
      },
      {
        signature: 'File3dmObject[] FindByLayer(Layer layer)',
        summary: 'Finds all File3dmObject that are in a given layer.',
        since: 6,
        parameters: [
          {
            name: 'layer',
            summary: 'A layer instance.'
          }
        ],
        returns: 'Array of objects that belong to the specified layer or empty array if no objects could be found.'
      },
      {
        signature: 'File3dmObject[] FindByLayer(string layer)',
        summary: 'Finds all File3dmObject that are in a given layer.',
        since: 5,
        parameters: [
          {
            name: 'layer',
            summary: 'Layer to search.'
          }
        ],
        returns: 'Array of objects that belong to the specified layer or empty array if no objects could be found.'
      },
      {
        signature: 'Rhino.Geometry.BoundingBox GetBoundingBox()',
        summary: 'Gets the bounding box containing every object in this table.',
        since: 5,
        returns: 'The computed bounding box.'
      },
      {
        signature: 'IEnumerator<File3dmObject> GetEnumerator()',
        summary: `Returns an enumerator that yields all objects in this document.
     Like in Rhino, this includes lights. Unlike in Rhino, however, all lights are returned in the end of the list.`,
        since: 5,
        returns: 'An enumerator that yields all objects in a document.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmPlugInData',
    dataType: 1,
    summary: 'Custom data in the file supplied by a plug-in',
    properties: [
      {
        signature: 'Guid PlugInId',
        summary: 'Plug-in this data is associated with',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmPlugInDataTable',
    dataType: 1,
    summary: 'Table of custom data provided by plug-ins',
    interfaces: ['IEnumerable<File3dmPlugInData>', 'Collections.IRhinoTable<File3dmPlugInData>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of File3dmPlugInData in this table.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Clear()',
        summary: 'Remove all entries from this table',
        since: 5
      },
      {
        signature: 'string Dump()',
        summary: 'Prepares a text dump of table.',
        since: 5,
        returns: 'A string containing the dump.'
      },
      {
        signature: 'IEnumerator<File3dmPlugInData> GetEnumerator()',
        summary: 'Gets the enumerator that visits any File3dmPlugInData in this table.',
        since: 5,
        returns: 'The enumerator.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmSettings',
    dataType: 1,
    summary: 'General settings in a 3dm file.',
    properties: [
      {
        signature: 'double ModelAbsoluteTolerance',
        summary: 'Gets or sets the model space absolute tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double ModelAngleToleranceDegrees',
        summary: 'Gets or sets the model space angle tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double ModelAngleToleranceRadians',
        summary: 'Gets or sets the model space angle tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d ModelBasepoint',
        summary: `Gets or sets the model basepoint that is used when the file is read as an instance definition.
     This point is mapped to the origin in the instance definition.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double ModelRelativeTolerance',
        summary: 'Gets or sets the model space relative tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'UnitSystem ModelUnitSystem',
        summary: 'Gets or sets the model unit system, using Rhino.UnitSystem enumeration.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string ModelUrl',
        summary: 'Gets or sets a Uniform Resource Locator (URL) direction for the model.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PageAbsoluteTolerance',
        summary: 'Gets or sets the page space absolute tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PageAngleToleranceDegrees',
        summary: 'Gets or sets the page space angle tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PageAngleToleranceRadians',
        summary: 'Gets or sets the page space angle tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PageRelativeTolerance',
        summary: 'Gets or sets the page space relative tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'UnitSystem PageUnitSystem',
        summary: 'Gets or sets the page unit system, using Rhino.UnitSystem enumeration.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmStringTable',
    dataType: 1,
    summary: 'Provides access to document strings in the 3dm file.',
    properties: [
      {
        signature: 'int Count',
        summary: 'Returns the number of document strings in the 3dm file.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int DocumentUserTextCount',
        summary: 'Returns the number of Section/Entry-style key values.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Delete(string key)',
        summary: 'Removes a document string from the 3dm file.',
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: 'The key to remove.'
          }
        ]
      },
      {
        signature: 'void Delete(string section,string entry)',
        summary: 'Removes document strings from the 3dm file.',
        since: 6,
        parameters: [
          {
            name: 'section',
            summary: 'name of section to delete. If null, all sections will be deleted.'
          },
          {
            name: 'entry',
            summary: 'name of entry to delete. If null, all entries will be deleted for a given section.'
          }
        ]
      },
      {
        signature: 'string[] GetEntryNames(string section)',
        summary: 'Return list of all entry names for a given section of document strings in the 3dm file.',
        since: 6,
        parameters: [
          {
            name: 'section',
            summary: 'The section from which to retrieve section names.'
          }
        ],
        returns: 'An array of section names. This can be empty, but not null.'
      },
      {
        signature: 'string GetKey(int i)',
        summary: 'Returns a key value at a given index.',
        since: 6,
        parameters: [
          {
            name: 'i',
            summary: 'The index.'
          }
        ],
        returns: 'The key if successful.'
      },
      {
        signature: 'string[] GetSectionNames()',
        summary: `Returns a list of all the section names for document strings in the 3dm file.
     By default a section name is a key that is prefixed with a string separated by a backslash.`,
        since: 6,
        returns: 'An array of section names. This can be empty, but not null.'
      },
      {
        signature: 'string GetValue(int i)',
        summary: 'Returns a string value at a given index.',
        since: 6,
        parameters: [
          {
            name: 'i',
            summary: 'The index at which to get the value.'
          }
        ],
        returns: 'The string value if successful.'
      },
      {
        signature: 'string GetValue(string key)',
        summary: 'Returns a string value at a key.',
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: 'The key at which to get the value.'
          }
        ],
        returns: 'The string value if successful.'
      },
      {
        signature: 'string GetValue(string section,string entry)',
        summary: 'Returns a string value given a section and entry.',
        since: 6,
        parameters: [
          {
            name: 'section',
            summary: 'The section at which to get the value.'
          },
          {
            name: 'entry',
            summary: 'The entry to search for.'
          }
        ],
        returns: 'The string value if successful.'
      },
      {
        signature: 'string SetString(string key,string value)',
        summary: 'Adds or sets a a document string in the 3dm file.',
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: 'The key.'
          },
          {
            name: 'value',
            summary: 'The entry value.'
          }
        ],
        returns: 'The previous value if successful.'
      },
      {
        signature: 'string SetString(string section,string entry,string value)',
        summary: 'Adds or sets a document string in the 3dm file.',
        since: 6,
        parameters: [
          {
            name: 'section',
            summary: 'The section.'
          },
          {
            name: 'entry',
            summary: 'The entry name.'
          },
          {
            name: 'value',
            summary: 'The entry value.'
          }
        ],
        returns: 'The previous value if successful.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmTypeCodes',
    dataType: 1,
    summary: `Typecode format 4 bytes long
  
  x xxxxxxxxxxxxxxx,x xxx xxxx xxxx x x xx
  | |               | |               | |  |
  |        |        |                 |
  |        |        |         |       +---  "stuff" bit
  |        |        |         |
  |        |        |         +-- specific codes
  |        |        |
  |        |        +-- RESERVED - DO NOT USE (should be 0) (will be used to control CRC on/off)
  |        |
  |        +-- category:_000 0000 0000 0001  Legacy geometry    TCODE_LEGACY_GEOMETRY
  |                     _000 0000 0000 0010  openNURBS object   TCODE_OPENNURBS_OBJECT
  |                     _000 0000 0000 0100  -- RESERVED - DO NOT USE (should be 0 in any typecode) -- 
  |                     _000 0000 0000 1000  -- RESERVED - DO NOT USE (should be 0 in any typecode) --                     
  |                     _000 0000 0001 0000  Geometry           TCODE_GEOMETRY
  |                     _000 0000 0010 0000  Annotation
  |                     _000 0000 0100 0000  Display Attributes TCODE_DISPLAY
  |                     _000 0000 1000 0000  Rendering          TCODE_RENDER     
  |                     _000 0001 0000 0000                         
  |                     _000 0010 0000 0000  Interface          TCODE_INTERFACE 
  |                     _000 0100 0000 0000  -- RESERVED - DO NOT USE (should be 0 in any typecode) --
  |                     _000 1000 0000 0000  Tolerances         TCODE_TOLERANCE
  |                     _001 0000 0000 0000  Tables             TCODE_TABLE    
  |                     _010 0000 0000 0000  Table record       TCODE_TABLEREC
  |                     _100 0000 0000 0000  User information   TCODE_USER
  | 
  +-- format: 0 - data size in header  - data block follows    TCODE_SHORT
              1 - data in header - no data block follows`
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmViewTable',
    dataType: 1,
    summary: 'Provides access to views in the 3dm file.',
    interfaces: ['IList<ViewInfo>', 'Collections.IRhinoTable<DocObjects.ViewInfo>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of items in the table.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(ViewInfo item)',
        summary: 'Adds a',
        since: 6
      },
      {
        signature: 'void Clear()',
        summary: 'Removes all items from the table.',
        since: 6
      },
      {
        signature: 'bool Contains(ViewInfo item)',
        summary: 'Returns an indication of the presence of a view in the table.',
        since: 6,
        parameters: [
          {
            name: 'item',
            summary: 'The view to check.'
          }
        ],
        returns: 'True if the item is in the table; False otherwise.'
      },
      {
        signature: 'void CopyTo(ViewInfo[] array,int arrayIndex)',
        summary: 'Copies the content of teh table to an array.',
        since: 6
      },
      {
        signature: 'bool Delete(int index)',
        summary: 'Removes an item.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index of the item to remove.'
          }
        ],
        returns: 'True if the item was removed.'
      },
      {
        signature: 'bool Delete(ViewInfo item)',
        summary: 'Deletes an item.',
        since: 6
      },
      {
        signature: 'ViewInfo FindName(string name)',
        summary: 'Finds a ViewInfo given its name.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'The name of the ViewInfo to be searched.'
          }
        ],
        returns: 'An ViewInfo, or None on error.'
      },
      {
        signature: 'IEnumerator<DocObjects.ViewInfo> GetEnumerator()',
        summary: 'Returns an enumerator that yields all views in the table.',
        since: 6,
        returns: 'An enumerator.'
      },
      {
        signature: 'int IndexOf(ViewInfo item)',
        summary: 'Returns the index of the current ViewInfo.',
        since: 6,
        parameters: [
          {
            name: 'item',
            summary: 'The item to be searched.'
          }
        ],
        returns: 'The index of the ViewInfo.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'File3dmWriteOptions',
    dataType: 1,
    summary: 'Options used by File3dm.Write',
    constructors: [
      {
        signature: 'File3dmWriteOptions()',
        summary: 'Initializes properties to defaults.',
        since: 5.9
      }
    ],
    properties: [
      {
        signature: 'bool SaveAnalysisMeshes',
        summary: 'Include analysis meshes in the file. Default is true',
        since: 5.9,
        property: ['get', 'set']
      },
      {
        signature: 'bool SaveRenderMeshes',
        summary: 'Include Render meshes in the file. Default is true',
        since: 5.9,
        property: ['get', 'set']
      },
      {
        signature: 'bool SaveUserData',
        summary: 'Include custom user data in the file. Default is true',
        since: 5.9,
        property: ['get', 'set']
      },
      {
        signature: 'int Version',
        summary: 'File version. Default is major version number of this assembly version.Must be in range [2; current version].Alternatively, 0 is a placeholder for the last valid version.Rhino can read its current version, plus earlier file versions except 1.Use latest version when possible.',
        since: 5.9,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void EnableAnalysisMeshes(ObjectType objectType,bool enable)',
        summary: `Activates saving of analysis meshes for specific types of objects.
     If you do not specify the state for an object type, its default is used.
     Currently SubD mesh saving is disabled by default, while Brep and Extrusion is enabled.`,
        since: 6,
        parameters: [
          {
            name: 'objectType',
            summary: `The object type. Mostly mesh, brep, extrusion and SubD (or their flag combinations) make sense here.
     DO NOT specify a 'filter' or subobject type.`
          },
          {
            name: 'enable',
            summary: 'If false, disables saving for this object type.'
          }
        ]
      },
      {
        signature: 'void EnableRenderMeshes(ObjectType objectType,bool enable)',
        summary: `Activates saving of render meshes for specific types of objects.
     If you do not specify the state for an object type, its default is used.
     Specifically, currently SubD mesh saving is disabled by default, while Brep and Extrusion is on.`,
        since: 6,
        parameters: [
          {
            name: 'objectType',
            summary: `The object type. Mostly brep, extrusion and SubD (or their flag combinations) make sense here.
     DO NOT specify a 'filter' or subobject type.`
          },
          {
            name: 'enable',
            summary: 'If false, disables saving for this object type.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileFindPreference',
    dataType: 3,
    summary: 'Defines options for file search.',
    values: [
      {
        signature: 'None = 0',
        summary: 'The choice is not defined.'
      },
      {
        signature: 'FullPath = 1',
        summary: 'File name exists in FullPath().'
      },
      {
        signature: 'RelativePath = 2',
        summary: 'File name exists in base path + RelativePath().'
      },
      {
        signature: 'BasePath = 3',
        summary: 'File name exists in base path directory.'
      },
      {
        signature: 'ContentMatch = 4',
        summary: 'File with mathing content exists.'
      },
      {
        signature: 'MostRecent = 5',
        summary: 'Most recently modifed file.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObj',
    dataType: 1,
    summary: 'Support for obj file format',
    methods: [
      {
        signature: 'static bool Read(String filename,RhinoDoc doc,FileObjReadOptions options)',
        since: 6
      },
      {
        signature: 'static WriteFileResult Write(StreamWriter stream,RhinoDoc doc,FileObjWriteOptions options)',
        summary: 'Write an obj stream based on the contents of a RhinoDoc',
        since: 7
      },
      {
        signature: 'static WriteFileResult Write(String filename,Mesh[] meshes,FileObjWriteOptions options)',
        summary: 'Write an obj file with an array of meshes',
        since: 7,
        parameters: [
          {
            name: 'filename',
            summary: 'path to write to'
          },
          {
            name: 'meshes',
            summary: 'meshes to write as obj format'
          },
          {
            name: 'options',
            summary: ''
          }
        ]
      },
      {
        signature: 'static WriteFileResult Write(String filename,RhinoDoc doc,FileObjWriteOptions options)',
        summary: 'Write an obj file based on the contents of a RhinoDoc',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObjReadOptions',
    dataType: 1,
    summary: 'Options used when reading an obj file.',
    constructors: [
      {
        signature: 'FileObjReadOptions(FileReadOptions readOptions)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'bool DisplayColorFromObjMaterial',
        summary: 'Determines whether textures are read from the .mtl file, if it exists.',
        since: 6.5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IgnoreTextures',
        summary: 'Determines whether textures are read from the .mtl file, if it exists.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool MapYtoZ',
        summary: 'Setting to transform OBJ\'s Y axis to Rhino\'s Z axis',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool MorphTargetOnly',
        summary: 'TODO',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ReverseGroupOrder',
        summary: `Determines how groups/layers are nested when reading an obj file.
     Left to Right (default = false) or Right to Left (true)`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool Split32BitTextures',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'UseObjGsAs UseObjGroupsAs',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool UseObjObjects',
        summary: `Determines whether or not "o"s in the obj file
     will be interpreted as objects in the Rhino model`,
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'Transform GetTransform()',
        summary: 'Calculates the YToZ transform.',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObjReadOptions.UseObjGsAs',
    dataType: 3,
    summary: `Determines how "g"s in the obj file will be interpreted
     on import`,
    values: [
      {
        signature: 'IgnoreObjGroups = 0',
        summary: 'OBJ "g"s in the file are ignored'
      },
      {
        signature: 'ObjGroupsAsLayers = 1',
        summary: 'OBJ "g"s in the file will become Rhino layers'
      },
      {
        signature: 'ObjGroupsAsGroups = 2',
        summary: 'OBJ "g"s in the file will become Rhino groups'
      },
      {
        signature: 'ObjGroupsAsObjects = 3',
        summary: 'OBJ "g"s in the file will become Rhino objects'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObjWriteOptions',
    dataType: 1,
    constructors: [
      {
        signature: 'FileObjWriteOptions(FileWriteOptions writeOptions)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'string ActualFilePathOnMac',
        since: 6.3,
        property: ['get', 'set']
      },
      {
        signature: 'bool CreateNgons',
        summary: 'Setting to enable/diable the creation of ngons for the output',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool CullUnnecessaryVertexesInNgons',
        summary: `Setting to determine whether interior colinear vertexes are part of the 
     ngon.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'AsciiEol EolType',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ObjGroupNames ExportGroupNameLayerNames',
        summary: `Setting to determine whether object, group or layer names
     will become "g"s in the OBJ output file`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ExportMaterialDefinitions',
        summary: 'Setting to write an .mtl file and "usemtl"s in the obj file',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ExportNormals',
        summary: 'Enable/disable export of vertex normals, if they exist.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ObjObjectNames ExportObjectNames',
        summary: `Setting to determine what object names in Rhino 
     will become in the OBJ output file`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ExportOpenMeshes',
        summary: 'Enable/Disable bailing when an open mesh is encountered.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ExportTcs',
        summary: 'Enable/disable export of texture coordinates, if they exist.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ExportVcs',
        summary: 'Enable/disable export of vertex colors, if they exist.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool IncludeUnweldedEdgesInNgons',
        summary: `Setting to determine whether unwelded edges are ignored in the 
     creation of an ngon.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool MapZtoY',
        summary: 'Setting to transform Rhino\'s Z axis to OBJ\'s Y axis',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool MergeNestedGroupingNames',
        summary: 'Setting to merge nested layer or group names into a single OBJ group name',
        since: 6.7,
        property: ['get', 'set']
      },
      {
        signature: 'MeshingParameters MeshParameters',
        summary: 'Mesh parameters to use when meshing geometry that is not already a mesh.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'VertexWelding MeshType',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int MinNgonFaceCount',
        summary: 'Minimum number of faces to consider creation of ngon',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'GeometryType ObjectType',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int SignificantDigits',
        summary: 'Number of significant digits to write out for floating point numbers',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool SortObjGroups',
        summary: 'Setting to enable/disable sorting of OBJ groups',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'SubDMeshing SubDMeshType',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'int SubDSurfaceMeshingDensity',
        summary: `Determines how coarse the mesh output
     will be when surface meshing subd objects
     
     See comments for ON_SubDDisplayParameters in opennurbs_mesh.h
     for details regarding numbers used.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'CurveType TrimCurveType',
        summary: 'trimming curve option',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool UnderbarMaterialNames',
        summary: 'Enable/disable replacing white space with underbars in material names.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool UseRelativeIndexing',
        summary: `Determines whether to use relative indexing.
     
     TRUE = use relative (negative) indexing
     FALSE = use absolute (positive) indexing`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool UseSimpleDialog',
        summary: 'Determines whether to use the simple or detailed meshing dialog.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool WrapLongLines',
        summary: 'Setting to enable/disable line wrapping with "\\"s',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'Transform GetTransform()',
        summary: `Calculates the transform combination of ZToY and
     any the translation that might occur in a SavewithOrigin.`,
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObjWriteOptions.AsciiEol',
    dataType: 3,
    summary: 'End of Line',
    values: [
      {
        signature: 'Crlf = 0',
        summary: 'MicroSoft'
      },
      {
        signature: 'Lf = 1',
        summary: 'UNIX'
      },
      {
        signature: 'Cr = 2',
        summary: 'Apple'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObjWriteOptions.CurveType',
    dataType: 3,
    summary: 'Type of curve used for trimmed surfaces',
    values: [
      {
        signature: 'Polyline = 0',
        summary: 'Polyline approximation, see comments for AngleTolRadians'
      },
      {
        signature: 'Nurbs = 1'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObjWriteOptions.GeometryType',
    dataType: 3,
    summary: `(trimmed) NURBS surfaces may be exported                              
     as either NURBS or meshes`,
    values: [
      {
        signature: 'Nurbs = 0'
      },
      {
        signature: 'Mesh = 1'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObjWriteOptions.ObjGroupNames',
    dataType: 3,
    values: [
      {
        signature: 'NoGroups = 0',
        summary: 'Neither layer or group names are exported as OBJ groups'
      },
      {
        signature: 'LayerAsGroup = 1',
        summary: 'Rhino layer names are exported as OBJ groups'
      },
      {
        signature: 'GroupAsGroup = 2',
        summary: 'Rhino group names are exported as OBJ groups'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObjWriteOptions.ObjObjectNames',
    dataType: 3,
    values: [
      {
        signature: 'NoObjects = 0',
        summary: 'Object names are not exported'
      },
      {
        signature: 'ObjectAsGroup = 1',
        summary: 'Rhino Object names are exported as OBJ groups'
      },
      {
        signature: 'ObjectAsObject = 2',
        summary: 'Rhino Object names are exported as OBJ objects'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObjWriteOptions.SubDMeshing',
    dataType: 3,
    summary: 'Determines whether the surface or control net of a SubD object is used to generate a mesh',
    values: [
      {
        signature: 'Surface = 0',
        summary: 'The SubD surface is used'
      },
      {
        signature: 'ControlNet = 1',
        summary: 'The SubD control net is used'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObjWriteOptions.VertexWelding',
    dataType: 3,
    summary: 'Determines how/if vertexes of the mesh in Rhino will be modified in the output',
    values: [
      {
        signature: 'Normal = 0',
        summary: 'Mesh is exported in existing state'
      },
      {
        signature: 'Welded = 1',
        summary: `Mesh topology vertex indexing is used for the v in the OBJ output file
       normals and texture coordinates, if they exist, come from the mesh`
      },
      {
        signature: 'Unwelded = 2',
        summary: 'Each face gets it\'s own vertex, and normal and tc if they exist, in the output'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObjWriter.ObjGroupComparer',
    dataType: 1,
    interfaces: ['IComparer<ObjRhinoObject>']
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObjWriter.ObjLayerComparer',
    dataType: 1,
    interfaces: ['IComparer<ObjRhinoObject>']
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObjWriter.ObjRhinoObject',
    dataType: 1
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileObjWriter.RhinoObjectMesh',
    dataType: 1
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FilePdf',
    dataType: 1,
    summary: 'Support for PDF file format',
    methods: [
      {
        signature: 'static FilePdf Create()',
        summary: 'Create a new instance of a FilePdf class',
        since: 6
      },
      {
        signature: 'int AddPage(int widthInDots,int heightInDots,int dotsPerInch)',
        summary: 'Add a blank page to this document',
        since: 6.5,
        returns: 'page number on success'
      },
      {
        signature: 'int AddPage(ViewCaptureSettings settings)',
        summary: `Add a new page to this document and draw a viewport into it based on
     provided ViewCaptureSettings`,
        since: 6,
        returns: 'page number on success'
      },
      {
        signature: 'void DrawBitmap(int pageNumber,Bitmap bitmap,float left,float top,float width,float height,float rotationInDegrees)',
        summary: 'Draw a bitmap',
        since: 6.5
      },
      {
        signature: 'void DrawLine(int pageNumber,PointF from,PointF to,Color strokeColor,float strokeWidth)',
        summary: 'Draw a line',
        since: 6.5
      },
      {
        signature: 'void DrawPolyline(int pageNumber,PointF[] polyline,Color fillColor,Color strokeColor,float strokeWidth)',
        summary: 'Draw a polyline path',
        since: 6.5
      },
      {
        signature: 'void DrawText(int pageNumber,string text,double x,double y,float heightPoints,Font onfont,Color fillColor,Color strokeColor,float strokeWidth,float angleDegrees,TextHorizontalAlignment horizontalAlignment,TextVerticalAlignment verticalAlignment)',
        summary: 'Draw text on a page',
        since: 6.5
      },
      {
        signature: 'object PdfDocumentImplementation()',
        summary: 'Get actual implementation of PdfDocument class',
        since: 6
      },
      {
        signature: 'void Write(Stream stream)',
        summary: 'Write pdf to a stream',
        since: 6
      },
      {
        signature: 'void Write(string filename)',
        summary: 'Write pdf to a file',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FilePdfEventArgs',
    dataType: 1,
    summary: 'Used for events that are fired while constructing/saving a Pdf',
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'FilePdf Pdf',
        summary: 'The document that is about to be written',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FilePly',
    dataType: 1,
    summary: 'Support for ply file format',
    methods: [
      {
        signature: 'static WriteFileResult Write(String filename,RhinoDoc doc,FilePlyWriteOptions options)',
        summary: 'Write a ply file based on the contents of a RhinoDoc',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FilePlyWriteOptions',
    dataType: 1,
    constructors: [
      {
        signature: 'FilePlyWriteOptions(FileWriteOptions writeOptions)',
        since: 7
      }
    ],
    properties: [
      {
        signature: 'bool ExportASCII',
        summary: 'Determines whether to export as Ascii.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool ExportColors',
        summary: 'Determines whether to export vertex colors.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool ExportMaterial',
        summary: 'Determines whether to export a material.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool ExportNormals',
        summary: 'Determines whether to export vertex normals.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'MeshingParameters MeshingParameters',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool UseSimpleDialog',
        summary: 'Determines whether to use the simple or detailed meshing dialog.',
        since: 7,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileReadOptions',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'FileReadOptions()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'bool BatchMode',
        summary: 'True means you cannot ask questions during reading. (no dialogs, no "getters", etc.)',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ImportMode',
        summary: `True means we are merging whatever is being read into an existing document.
      This means you need to consider things like:
     
     If the information being read is in a different unit system, it should be
     scaled if UseScaleGeometry is true.
     
     There can be existing layers, fonts, materials, dimension styles, hatch
     patterns, and so on with the same name as items being read from the file.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ImportReferenceMode',
        summary: `True means we are reading information for a work session reference model
     or a linked instance definition.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool InsertMode',
        summary: `True means we are reading information that will be used to create an
     instance definition or some other type of "inserting" that is supported
     by Rhino's "Insert" command.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool NewMode',
        summary: `True means we are reading template information in something like
     a OnFileNew event.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool OpenMode',
        summary: `True means we are reading the information into an empty document.  This
     means you need to consider things like:
     Setting the unit system (if the file has a unit system)Creating a default layer if one is not there.Setting up appropriate views when you're finished reading.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ScaleGeometry',
        summary: `true: If ImportMode is True and the geometry in the file being read has
     a unit system different from the model's unit system, then apply the unit
     conversion scale to the file's geometry before adding it to the model.
     
     false: Do not scale. Once case where this happens is when an instance
     definition is read from a file and the model space instance references
     have been scaled. In case the instance definition geometry cannot be
     scaled or the net result is that the size of the instance reference
     object is scaled by the square of the scale factor.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool UseScaleGeometry',
        summary: `If this parameter is true, then no questions are asked when unit conversion
     scaling is optional and the setting specified by ScaleGeometry is used.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileReference',
    dataType: 1,
    summary: `Manages a reference to an existing or nonexisting file,
   using either or both absolute or relative paths.
   Once constructed, this class is immutable.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'FileReference(string fullPath,string relativePath,ContentHash hash,FileReferenceStatus status)',
        summary: `Constructs a new instance of the FileReference class,
     given a fullPath, a relativePath a content hash and a status value.`,
        since: 6
      }
    ],
    properties: [
      {
        signature: 'ContentHash ContentHash',
        summary: 'Gets the content hash.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string FullPath',
        summary: 'Gets the absolute path of this file reference.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'FileReferenceStatus FullPathStatus',
        summary: 'Gets the file reference status.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsSet',
        summary: 'Returns an indication of the fact that the reference is actually set to a non-None value.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string RelativePath',
        summary: 'Gets the relative path of this file reference.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static FileReference CreateFromFullAndRelativePaths(string fullPath,string relativePath)',
        summary: 'Returns a new file reference. This returns a new instance even if the path does not exist.',
        since: 6,
        parameters: [
          {
            name: 'fullPath',
            summary: 'A full path. This parameter cannot be null.'
          },
          {
            name: 'relativePath',
            summary: 'A relative path. This parameter can be null.'
          }
        ],
        returns: 'A file reference to the specified paths.'
      },
      {
        signature: 'static FileReference CreateFromFullPath(string fullPath)',
        summary: 'Returns a new file reference. This returns a new instance even if the path does not exist.',
        since: 6,
        parameters: [
          {
            name: 'fullPath',
            summary: 'A full path.'
          }
        ],
        returns: 'A file reference to the specified path.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Reclaims unmanaged resources used by this object.',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileReferenceStatus',
    dataType: 3,
    summary: 'Enumerates a list of file statuses.',
    values: [
      {
        signature: 'Unknown = 0',
        summary: 'Status of a the full path is not known.'
      },
      {
        signature: 'FullPathValid = 1',
        summary: 'Full path is valid.'
      },
      {
        signature: 'FileNotFound = 2',
        summary: 'Unable to locate file.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileSlc',
    dataType: 1,
    summary: 'Support for writing slice (slc) file format',
    methods: [
      {
        signature: 'static bool Write(string filename,RhinoDoc doc,FileSlcWriteOptions options)',
        summary: 'Write a slc file based on the contents of a RhinoDoc',
        since: 7,
        parameters: [
          {
            name: 'filename',
            summary: 'path to write a file to'
          },
          {
            name: 'doc',
            summary: 'document to get geometry from'
          },
          {
            name: 'options',
            summary: 'options used for generating the slc file'
          }
        ],
        returns: 'True on success'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileSlcWriteOptions',
    dataType: 1,
    summary: 'Options used when writing a slc file',
    properties: [
      {
        signature: 'double AngleBetweenSegmentsDegrees',
        summary: `The angle that determines how smooth the polylines of the slice curves
     will be. When the number is small you will get a smooth final output
     but it will take more time to export and a larger file.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d EndPoint',
        summary: 'End of the slicing normal',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double SliceDistance',
        summary: `The distance between the slices or layers of curves that your final
     output will contain. The distance should be based on the slice
     thickness of your final output device`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d StartPoint',
        summary: 'Start of the slicing normal',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool UseMeshes',
        summary: `Use meshes to generate slices. The curves for each slice are generated
     by intersecting the object mesh with a plane. the Angle between
     polyline segments data is not used when this value is true`,
        since: 7,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileStp',
    dataType: 1,
    summary: 'Support for writing step (stp) file format',
    methods: [
      {
        signature: 'static bool Write(string filename,RhinoDoc doc,FileStpWriteOptions options)',
        summary: 'Write a stp file based on the contents of a RhinoDoc',
        since: 7,
        parameters: [
          {
            name: 'filename',
            summary: 'path to write a file to'
          },
          {
            name: 'doc',
            summary: 'document to get geometry from'
          },
          {
            name: 'options',
            summary: 'options used for generating the stp file'
          }
        ],
        returns: 'True on success'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileStpWriteOptions',
    dataType: 1,
    summary: 'Options used when writing a stp file',
    properties: [
      {
        signature: 'bool Export2dCurves',
        summary: `Some (not most, and not Rhino) importing applications can make use of
     the 2-D trimming curves to get a more accurate and faster import. The
     size of the step file will be larger`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool ExportBlack',
        summary: `Let importing application set color for black objects. If a Rhino
     object has color black, no color is assigned to the object in the step
     file.This will cause the importing application to give the object its
     default color.This is desirable because black objects look like
     ink blots in some applications.This option is grayed out if the schema
     option is AP203ControConfigDesign since that schema does not include
     color entities.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool SplitClosedSurfaces',
        summary: `Splits closed surfaces, for example, the interior surfaces of drilled
     holes.`,
        since: 7,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileType',
    dataType: 1,
    constructors: [
      {
        signature: 'FileType(string extension,string description)',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'string Description',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Extension',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'FileWriteOptions',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'FileWriteOptions()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'string DestinationFileName',
        summary: `For use on Apple frameworks only.
     Retrns the final destination file name.`,
        since: 6.3,
        property: ['get']
      },
      {
        signature: 'int FileVersion',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IncludeBitmapTable',
        summary: 'The file written should include the bitmap table if your File Writing Plug-in supports it.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IncludeHistory',
        summary: 'The file written should include history information if your File Writing Plug-In supports it.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IncludePreviewImage',
        summary: 'The file written should include a preview image if your File Writing Plug-in supports it.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IncludeRenderMeshes',
        summary: 'The file written should include the render meshes if your File Writing Plug-in supports it.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool SuppressAllInput',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool SuppressDialogBoxes',
        summary: 'If true, it means the command has been run with a \'-\', meaning you should not ask questions during writing. (no dialogs, no "getters", etc.)',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool UpdateDocumentPath',
        summary: `If a complete, current version, 3dm file is successfully saved, then
     the name of the file will be used to update the document's default file
     path and title and document will be marked as not modified.`,
        since: 6.7,
        property: ['get', 'set']
      },
      {
        signature: 'bool WriteAsTemplate',
        summary: 'Write as template',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool WriteGeometryOnly',
        summary: 'If true, the file written should include only geometry File Writing Plug-in supports it.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool WriteSelectedObjectsOnly',
        summary: 'If true, this command should export only the objects currently selected in the Rhino model.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool WriteUserData',
        summary: 'If true, the file written should include User Data if your File Writing Plug-in supports it.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Transform Xform',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'ICommonComponentTable',
    dataType: 4,
    summary: `Provides methods to use all File3dm and RhinoDoc tables under the same contract.
   Do not derive from this interface. This is to ensure all tables can be used with the same method list.`
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'ImageFile',
    dataType: 1,
    summary: 'Support functions for image files',
    methods: [
      {
        signature: 'static bool SupportsAlphaChannel(string filename)',
        summary: `Returns True if file at given path is an image file and that file format supports
     an alpha channel`,
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'ManifestTable',
    dataType: 1,
    summary: `Maintains an index to every model component that is in the 3dm file.
   This is the "more comprehensive" table that contains all objects in all other tables.`,
    interfaces: ['ICommonComponentTable<ModelComponent>'],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.Mixed.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int Count',
        summary: 'Total number of items in the manifest, including deleted items.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'long LongCount',
        summary: 'Total number of items in the manifest, including deleted items.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'object Parent',
        summary: 'Returns the parent object. This is the RhinoDoc, or the File3md file.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static ModelComponentType GetModelComponentTypeFromGenericType()',
        summary: 'Returns the result of the ComponentType property of a ModelComponent.',
        since: 6,
        returns: 'A ModelComponentType.'
      },
      {
        signature: 'int ActiveObjectCount(ModelComponentType type)',
        summary: 'Total number of items in the manifest, including deleted items.',
        since: 6
      },
      {
        signature: 'void Clear()',
        summary: 'Marks all items as deleted.',
        since: 6
      },
      {
        signature: 'bool Contains(ModelComponent item)',
        summary: 'Determines if an items is contained in this table.',
        since: 6,
        parameters: [
          {
            name: 'item',
            summary: 'An item, or null. Null is never contained.'
          }
        ],
        returns: 'True if the item is contained; otherwise, false.'
      },
      {
        signature: 'void CopyTo(ModelComponent[] array,int arrayIndex)',
        summary: 'Copies the content of this table to an array.',
        since: 6,
        parameters: [
          {
            name: 'array',
            summary: 'The array to copy to.'
          },
          {
            name: 'arrayIndex',
            summary: 'The position in the array from which to start copying.'
          }
        ]
      },
      {
        signature: 'T FindId(Guid id)',
        summary: `Uses the guid to find a model component. Deleted objects cannot be found by id.
     The guid is the value that is stored in the .Id property.
     In a single document, no two active objects have the same guid. If an object is
     replaced with a new object, then the guid  persists. For example, if the _Move command
     moves an object, then the moved object inherits its guid from the starting object.
     If the Copy command copies an object, then the copy gets a new guid. This guid persists
     through file saving/openning operations. This function will not find grip objects.`,
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'Index of model component to search for.'
          }
        ],
        returns: 'Reference to the rhino object or None if no such object could be found.'
      },
      {
        signature: 'ModelComponent FindId(Guid id)',
        summary: `Uses the guid to find a model component. Deleted objects cannot be found by id.
     The guid is the value that is stored in the .Id property.
     In a single document, no two active objects have the same guid. If an object is
     replaced with a new object, then the guid  persists. For example, if the _Move command
     moves an object, then the moved object inherits its guid from the starting object.
     If the Copy command copies an object, then the copy gets a new guid. This guid persists
     through file saving/openning operations. This function will not find grip objects.`,
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'ID of model component to search for.'
          }
        ],
        returns: 'Reference to the rhino object with the objectId or None if no such object could be found.'
      },
      {
        signature: 'ModelComponent FindId(Guid id,ModelComponentType type)',
        summary: `Uses the guid to find a model component. Deleted objects cannot be found by id.
     The guid is the value that is stored in the .Id property.
     In a single document, no two active objects have the same guid. If an object is
     replaced with a new object, then the guid  persists. For example, if the _Move command
     moves an object, then the moved object inherits its guid from the starting object.
     If the Copy command copies an object, then the copy gets a new guid. This guid persists
     through file saving/openning operations. This function will not find grip objects.`,
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'ID of model component to search for.'
          },
          {
            name: 'type',
            summary: `The type to be searched. If this is ModelComponentType.Unset
     then all types are searched.`
          }
        ],
        returns: 'Reference to the rhino object with the objectId or None if no such object could be found.'
      },
      {
        signature: 'T FindIndex(int index)',
        summary: `Uses the index to find a model component.
     The index is the value that is stored in the .Index property.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'Index of model component to search for.'
          }
        ],
        returns: 'Reference to the rhino object or None if no such object could be found.'
      },
      {
        signature: 'ModelComponent FindIndex(int index,ModelComponentType type)',
        summary: `Uses the index to find a model component.
     The index is the value that is stored in the .Index property.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'Index of model component to search for.'
          },
          {
            name: 'type',
            summary: 'The type to be searched. Cannot be ModelComponentType.Unset.'
          }
        ],
        returns: 'Reference to the rhino object or None if no such object could be found.'
      },
      {
        signature: 'T FindName(string name,Guid parent)',
        summary: `Uses the name to find a model component.
     The name is the value that is stored in the .Name property.
     Deleted objects have no name.`,
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'Name of model component to search for.'
          },
          {
            name: 'parent',
            summary: 'Parent object id. This is only required for layers.'
          }
        ],
        returns: 'Reference to the rhino object or None if no such object could be found.'
      },
      {
        signature: 'ModelComponent FindName(string name,ModelComponentType type,Guid parent)',
        summary: `Uses the name to find a model component.
     The name is the value that is stored in the .Name property.
     Deleted objects have no name.`,
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'Name of model component to search for.'
          },
          {
            name: 'type',
            summary: 'The type to be searched. Cannot be ModelComponentType.Unset.'
          },
          {
            name: 'parent',
            summary: 'Parent object id. This is only required for layers.'
          }
        ],
        returns: 'Reference to the rhino object or None if no such object could be found.'
      },
      {
        signature: 'T FindNameHash(NameHash nameHash)',
        summary: `Uses the hash of the name to find a model component.
     Deleted objects have no name.`,
        since: 6,
        parameters: [
          {
            name: 'nameHash',
            summary: 'Name hash of model component to search for.'
          }
        ]
      },
      {
        signature: 'ModelComponent FindNameHash(NameHash nameHash,ModelComponentType type)',
        summary: `Uses the hash of the name to find a model component.
     Deleted objects have no name.`,
        since: 6,
        parameters: [
          {
            name: 'nameHash',
            summary: 'NameHash of model component to search for.'
          },
          {
            name: 'type',
            summary: 'The type to be searched. Cannot be ModelComponentType.Unset.'
          }
        ],
        returns: 'Reference to the rhino object or None if no such object could be found.'
      },
      {
        signature: 'IEnumerator<T> GetEnumerator()',
        summary: 'Visits all model components in the document, including default ones.',
        since: 6,
        returns: 'An enumerator.'
      },
      {
        signature: 'IEnumerator<ModelComponent> GetEnumerator()',
        summary: 'Visits all model components in the document, including default ones.',
        since: 6,
        returns: 'An enumerator.'
      },
      {
        signature: 'IEnumerator<ModelComponent> GetEnumerator(ModelComponentType type)',
        summary: `Returns an enumerators that yields all model components, including default ones,
     relating to a particular type.`,
        since: 6,
        parameters: [
          {
            name: 'type',
            summary: 'The model component type.'
          }
        ],
        returns: 'An enumerator.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'NameHash',
    dataType: 1,
    summary: `Contains information that is useful to uniquly identify an object name.
   This object is immutable.`,
    interfaces: ['ICloneable', 'IEquatable<NameHash>'],
    constructors: [
      {
        signature: 'NameHash(string name)',
        summary: 'Creates a new NameHash, representing a piece of text.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'A name. This can be None and can refer to a nonexisting path.'
          }
        ]
      },
      {
        signature: 'NameHash(string name,Guid parentId)',
        summary: 'Creates a new NameHash, representing a piece of text.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'A name. This can be None and can refer to a nonexisting path.'
          },
          {
            name: 'parentId',
            summary: 'The id of the parent layer. This is only useful with layers.'
          }
        ]
      },
      {
        signature: 'NameHash(string name,Guid parentId,bool ignoreCase)',
        summary: 'Creates a new NameHash, representing a piece of text.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'A name. This can be None and can refer to a nonexisting path.'
          },
          {
            name: 'parentId',
            summary: 'The id of the parent layer. This is only useful with layers.'
          },
          {
            name: 'ignoreCase',
            summary: 'All manifest searches currently ignore case, except for groups.'
          }
        ]
      },
      {
        signature: 'NameHash(string name,Guid parentId,ModelComponentType type)',
        summary: 'Creates a new NameHash, representing a piece of text.',
        since: 6,
        parameters: [
          {
            name: 'name',
            summary: 'A name. This can be None and can refer to a nonexisting path.'
          },
          {
            name: 'parentId',
            summary: 'The id of the parent layer. This is only useful with layers.'
          },
          {
            name: 'type',
            summary: 'Calls DocObjects.ModelComponent.ModelComponentTypeIgnoresCase to determine if case should be used in search.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'uint MappedCodePoints',
        summary: 'Gets the NameHash flags. In some cases = number of mapped code points.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid ParentId',
        summary: 'Only useful if this participates in a tree structure, as with layers.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'byte[] Sha1Hash',
        summary: 'Gets the 20-bytes long SHA-1 hash of ordinal minimum mapped unicode (UTF-32) code points.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static NameHash CreateFilePathHash(string path)',
        summary: 'Creates a new NameHash, representing the name of a file.',
        since: 6,
        parameters: [
          {
            name: 'path',
            summary: 'A path. This can be None and can refer to a nonexisting path.'
          }
        ]
      },
      {
        signature: 'NameHash Clone()',
        summary: `Creates a copy of this name hash.
     Because content hash is immutable, this can be used as a deep copy.`,
        since: 6,
        returns: 'A different instance of the same name hash.'
      },
      {
        signature: 'bool Equals(NameHash other)',
        summary: 'Determines if another name hash has the same value.',
        since: 6,
        parameters: [
          {
            name: 'other',
            summary: 'The other name hash to compare.'
          }
        ],
        returns: 'True if the two hashes are equal.'
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines if another object is a name hash with same value.',
        parameters: [
          {
            name: 'obj',
            summary: 'The other content hash to compare.'
          }
        ],
        returns: 'True if the two hashes are equal.'
      },
      {
        signature: 'int GetHashCode()',
        summary: `Gets an hash code for this name hash.
     Two equal content hashes have equal hash code. The other way around might not be true.`,
        returns: 'An hash code value.'
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'SerializationOptions',
    dataType: 1,
    summary: `Contains options for serializing -or storing- data,
   such as Rhino version and user data.`,
    constructors: [
      {
        signature: 'SerializationOptions()',
        summary: 'Initializes a new instance of the SerializationOptions class.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'int RhinoVersion',
        summary: 'Gets or sets a value indicating the Rhino version.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool WriteUserData',
        summary: 'Gets or sets a value indicating whether to write user data.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'SHA1OpenNURBS',
    dataType: 1,
    summary: `Provides the OpenNURBS implementation of SHA1.
   
   This class is provided only with the purpose of hashing. It is not meant to be
   used for any cryptographic purpose.`,
    baseclass: 'SHA1',
    constructors: [
      {
        signature: 'SHA1OpenNURBS()',
        summary: 'Constructs a new instance of the SHA1 algorithm.',
        since: 6
      }
    ],
    methods: [
      {
        signature: 'static byte[] FileSystemPathHash(string path,bool? ignoreCase)',
        summary: `Computes the SHA1 hash of a file system path, converted to UTF8.
         These file system paths have identical values of FileSystemPathHash():/x/y/z/name.ext\\x\\y\\z\\name.ext/x//y//z/name.ext/x/y/a/b/c/../../../z/name.ext/X/Y/Z/NAME.EXT (When ignoreCase is true)`,
        parameters: [
          {
            name: 'path',
            summary: 'A non-None path string.'
          },
          {
            name: 'ignoreCase',
            summary: `If case should be ignored.
     If this is None or unspecified, the operating system default is used.`
          }
        ],
        returns: 'A 20-byte long SHA1 hash.'
      },
      {
        signature: 'static byte[] StringHash(string input)',
        summary: 'Computes the SHA1 hash of a string, converted to UTF8.',
        since: 6,
        returns: 'A 20-byte long SHA1 hash.'
      },
      {
        signature: 'void Initialize()',
        summary: `Resets this instance of the algorithm, so that it can be used again.
     It is not required to call this method after creation.`,
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.FileIO',
    name: 'TextLog',
    dataType: 1,
    summary: 'Used for collecting text data',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'TextLog()',
        summary: `Creates a text log that stores all text in memory.  Use ToString on this
     version of the TextLog to get the text that we written`,
        since: 5.1
      },
      {
        signature: 'TextLog(IntPtr ptr)',
        since: 6
      },
      {
        signature: 'TextLog(string filename)',
        summary: `Creates a text log that writes all text to a file. If no filename is
     provided, then text is written to StdOut`,
        since: 5.1,
        parameters: [
          {
            name: 'filename',
            summary: `Name of file to create and write to. If null, then text output
     is sent to StdOut`
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int IndentSize',
        summary: '0: one tab per indent. >0: number of spaces per indent',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static TextLog NewCommandLine()',
        summary: `Returns a reference to a TextLog that prints to the Rhino command line.
     Each new command line reference holds its own indents.`,
        since: 7
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5.1
      },
      {
        signature: 'void PopIndent()',
        summary: 'Decrease the indentation level',
        since: 5.1
      },
      {
        signature: 'void Print(string text)',
        summary: 'Send text to the textlog',
        since: 5.1
      },
      {
        signature: 'void Print(string format,object arg0)',
        summary: 'Send formatted text to the textlog',
        since: 5.1
      },
      {
        signature: 'void Print(string format,object arg0,object arg1)',
        summary: 'Send formatted text to the textlog',
        since: 5.1
      },
      {
        signature: 'void PrintWrappedText(string text,int lineLength)',
        summary: 'Send text wrapped at a set line length',
        since: 5.1
      },
      {
        signature: 'void PushIndent()',
        summary: 'Increase the indentation level',
        since: 5.1
      },
      {
        signature: 'string ToString()',
        summary: `If the TextLog was constructed using the empty constructor, then the text
     information is stored in a runtime string.  The contents of this string
     is retrieved using ToString for this case`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'AngularDimension',
    dataType: 1,
    summary: 'Represents a dimension of an entity that can be measured with an angle.',
    baseclass: 'Dimension',
    constructors: [
      {
        signature: 'AngularDimension()',
        since: 6
      },
      {
        signature: 'AngularDimension(Arc arc,double offset)',
        summary: 'Create an angular dimension from a given arc',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'The start and end points of the arc are the start and endpoints of the dimension'
          },
          {
            name: 'offset',
            summary: 'How far to offset the dimension location from the arc'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'AngleDisplayFormat AngleFormat',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int AngleResolution',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double AngleRoundoff',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ZeroSuppression AngleZeroSuppression',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Point2d ArrowPoint1',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Point2d ArrowPoint2',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Point2d CenterPoint',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Point2d DefPoint1',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Point2d DefPoint2',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Point2d DimlinePoint',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static AngularDimension Create(DimensionStyle dimStyle,Plane plane,Vector3d horizontal,Point3d centerpoint,Point3d defpoint1,Point3d defpoint2,Point3d dimlinepoint)',
        summary: 'Initialize Dimension parameters',
        since: 6,
        parameters: [
          {
            name: 'dimStyle',
            summary: 'Dimension\'s DimensionStyle'
          },
          {
            name: 'plane',
            summary: 'Dimension\'s Plane'
          },
          {
            name: 'horizontal',
            summary: 'Horizontal reference direction'
          },
          {
            name: 'centerpoint',
            summary: 'Dimension centerpoint'
          },
          {
            name: 'defpoint1',
            summary: 'First definition point'
          },
          {
            name: 'defpoint2',
            summary: 'Second definition point'
          },
          {
            name: 'dimlinepoint',
            summary: 'Point on dimension line'
          }
        ]
      },
      {
        signature: 'static AngularDimension Create(Guid styleId,Plane plane,Point3d extpoint1,Point3d extpoint2,Point3d dirpoint1,Point3d dirpoint2,Point3d dimlinepoint)',
        summary: 'Initialize Dimension parameters',
        since: 6,
        parameters: [
          {
            name: 'styleId',
            summary: 'Dimension\'s AnnotationStyle'
          },
          {
            name: 'plane',
            summary: 'Dimension\'s plane'
          },
          {
            name: 'extpoint1',
            summary: 'First dimension point'
          },
          {
            name: 'extpoint2',
            summary: 'Second definition point'
          },
          {
            name: 'dirpoint1',
            summary: 'First direction point'
          },
          {
            name: 'dirpoint2',
            summary: 'Second direction point'
          },
          {
            name: 'dimlinepoint',
            summary: 'Point on dimension line'
          }
        ]
      },
      {
        signature: 'bool AdjustFromPoints(Plane plane,Point3d centerpoint,Point3d defpoint1,Point3d defpoint2,Point3d dimlinepoint)',
        summary: 'Update Dimension geometry from point locations',
        since: 6,
        parameters: [
          {
            name: 'plane',
            summary: 'Dimension\'s plane'
          },
          {
            name: 'centerpoint',
            summary: 'Dimension\'s centerpoint'
          },
          {
            name: 'defpoint1',
            summary: 'First definition point'
          },
          {
            name: 'defpoint2',
            summary: 'Second definition point'
          },
          {
            name: 'dimlinepoint',
            summary: 'Point on dimension line'
          }
        ]
      },
      {
        signature: 'bool AdjustFromPoints(Plane plane,Point3d extpoint1,Point3d extpoint2,Point3d dirpoint1,Point3d dirpoint2,Point3d dimlinepoint)',
        summary: 'Update Dimension geometry from point locations',
        since: 6,
        parameters: [
          {
            name: 'plane',
            summary: 'Dimension\'s plane'
          },
          {
            name: 'extpoint1',
            summary: 'First dimension point'
          },
          {
            name: 'extpoint2',
            summary: 'Second definition point'
          },
          {
            name: 'dirpoint1',
            summary: 'First direction point'
          },
          {
            name: 'dirpoint2',
            summary: 'Second direction point'
          },
          {
            name: 'dimlinepoint',
            summary: 'Point on dimension line'
          }
        ]
      },
      {
        signature: 'bool Get3dPoints(Point3d centerpoint,Point3d defpoint1,Point3d defpoint2,Point3d arrowpoint1,Point3d arrowpoint2,Point3d dimlinepoint,Point3d textpoint)',
        summary: 'Get locations of dimension\'s 3d points',
        since: 6,
        parameters: [
          {
            name: 'centerpoint',
            summary: 'Dimension\'s center point'
          },
          {
            name: 'defpoint1',
            summary: 'First definition point'
          },
          {
            name: 'defpoint2',
            summary: 'Second definition point'
          },
          {
            name: 'arrowpoint1',
            summary: 'First arrow point'
          },
          {
            name: 'arrowpoint2',
            summary: 'Second arrow point'
          },
          {
            name: 'dimlinepoint',
            summary: 'Point on dimension line'
          },
          {
            name: 'textpoint',
            summary: 'Text location point'
          }
        ]
      },
      {
        signature: 'string GetAngleDisplayText(DimensionStyle style)',
        since: 6
      },
      {
        signature: 'bool GetDisplayLines(DimensionStyle style,double scale,Line[] lines,Arc[] arcs)',
        since: 6
      },
      {
        signature: 'bool GetTextRectangle(Point3d[] corners)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'AnnotationBase',
    dataType: 1,
    summary: `Provides a common base class to all annotation geometry.
   This class refers to the geometric element that is independent from the document.`,
    baseclass: 'Rhino.Geometry.GeometryBase',
    properties: [
      {
        signature: 'LengthDisplay AlternateDimensionLengthDisplay',
        summary: 'Alternate length display units and format',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'AnnotationType AnnotationType',
        summary: 'Type of annotation',
        since: 6,
        property: ['get']
      },
      {
        signature: 'char DecimalSeparator',
        summary: 'Set or get the decimal separator c',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'LengthDisplay DimensionLengthDisplay',
        summary: 'Length display units and format',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double DimensionScale',
        summary: 'Gets or sets the dimension scale',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'DimensionStyle DimensionStyle',
        summary: 'If there are no overrides then the parent style is returned otherwise the dimension style saved with the annotation is returned.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid DimensionStyleId',
        summary: `Id of this annotation's parent dimstyle
     If this annotation has overrides to dimstyle properties, 
     those overrides will be represented in the DimensionStyle
     returned by DimensionStyle(ParentStyle)`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawForward',
        summary: 'Gets or sets whether the text is oriented towards the reader when viewed from behind',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawTextFrame',
        summary: 'Gets or sets whether to draw a frame around a text mask',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'Font FirstCharFont',
        summary: 'Returns the font used by the first run of text in an annotation',
        since: 6.5,
        property: ['get']
      },
      {
        signature: 'Font Font',
        summary: 'The base Font for the text of the annotation.  The text string is rich text and therefore a different font that the base font can be associated with sub strings of the text',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int FontIndex',
        summary: 'Obsolete; use Font property instead',
        since: 6.1,
        property: ['get', 'set']
      },
      {
        signature: 'double FormatWidth',
        summary: 'Text format width (Wrapping rectangle)',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool HasPropertyOverrides',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Color MaskColor',
        summary: `Color to use for drawing a text mask when it is enabled. If the mask is
     enabled and MaskColor is System.Drawing.Color.Transparent, then the
     viewport's color will be used for the MaskColor`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'MaskType MaskColorSource',
        summary: 'Gets or sets whether the mask background color is from the background or from a color',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool MaskEnabled',
        summary: 'Determines whether or not to draw a Text Mask',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'MaskFrame MaskFrame',
        summary: 'Gets or sets whether to draw a frame around a text mask',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double MaskOffset',
        summary: `Offset for the border around text of the rectangle used to draw the mask.  This 
     value multiplied by TextHeight is the offset on each side of the tight rectangle 
     around the text characters to the mask rectangle. The default value is 0.1.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool MaskUsesViewportColor',
        summary: `If true, the viewport's color is used for the mask color. If
     false, the color defined by MaskColor is used`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'DimensionStyle ParentDimensionStyle',
        summary: 'The parent dimension style associated with this annotation',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string PlainText',
        summary: 'Text stripped of RTF formatting information',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string PlainTextWithFields',
        summary: 'Text stripped of RTF formatting information and with field expressions intact',
        since: 6.19,
        property: ['get']
      },
      {
        signature: 'Plane Plane',
        summary: 'Plane that this annotation lies on',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string RichText',
        summary: 'Text including additional RTF formatting information',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string Text',
        summary: 'Text including additional RTF formatting information',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string TextFormula',
        summary: 'See RichText',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool TextHasRtfFormatting',
        since: 6,
        property: ['get']
      },
      {
        signature: 'double TextHeight',
        summary: `AnnotationBase.TextHeight
     Gets the parent dimstyle for the annotation and 
     gets or sets the text height in the dimstyle`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool TextIsWrapped',
        summary: 'Is text wrapping on',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double TextModelWidth',
        summary: 'Width of text in the model',
        since: 6,
        property: ['get']
      },
      {
        signature: 'double TextRotationDegrees',
        summary: 'Rotation of text in degrees',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double TextRotationRadians',
        summary: 'Rotation of text in radians',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static bool FirstCharProperties(string rtf_str,bool bold,bool italic,bool underline,string facename)',
        since: 6
      },
      {
        signature: 'static string FormatRtfString(string rtf_in,bool clear_bold,bool set_bold,bool clear_italic,bool set_italic,bool clear_underline,bool set_underline,bool clear_facename,bool set_facename,string facename)',
        since: 6
      },
      {
        signature: 'static double GetDimensionScale(RhinoDoc doc,DimensionStyle dimstyle,RhinoViewport vport)',
        summary: 'Get view dependent dimension scale',
        since: 6
      },
      {
        signature: 'static string PlainTextToRtf(string str)',
        since: 6
      },
      {
        signature: 'bool ClearPropertyOverrides()',
        summary: 'Clears all overriden properties for this annotation',
        since: 6
      },
      {
        signature: 'BoundingBox GetBoundingBox(Transform xform)',
        summary: 'Aligned Boundingbox solver. Gets the world axis aligned boundingbox for the transformed geometry.',
        since: 6.1,
        parameters: [
          {
            name: 'xform',
            summary: `Transformation to apply to bbox after calculation. 
     The geometry is not modified.`
          }
        ],
        returns: `The boundingbox of the transformed geometry in world coordinates 
     or BoundingBox.Empty if not bounding box could be found.`
      },
      {
        signature: 'DimensionStyle GetDimensionStyle(DimensionStyle parentDimStyle)',
        summary: `Return the proper dimension style from which to get properties
     for this annotation object
     If this object has style overrides, those will be included in the 
     returned dimension style and the style will be updated to include
     the current state of the parent style for non-overridden fields`,
        since: 6
      },
      {
        signature: 'string GetPlainTextWithRunMap(int[] map)',
        summary: `Return plain text string for this annotation with field expressions unevaluated 
     intrunmap is an array of ints in groups of 3: run index, char pos start, length`,
        since: 7
      },
      {
        signature: 'bool IsAllBold()',
        summary: 'Returns True if all of the text in the annotation is Bold, otherwise returns false',
        since: 6.22
      },
      {
        signature: 'bool IsAllItalic()',
        summary: 'Returns True if all of the text in the annotation is Italic, otherwise returns false',
        since: 6.22
      },
      {
        signature: 'bool IsAllUnderlined()',
        summary: 'Returns True if all of the text in the annotation is Underlined, otherwise returns false',
        since: 6.22
      },
      {
        signature: 'bool IsPropertyOverridden(Field field)',
        summary: 'Returns True if a property is overridden',
        since: 6
      },
      {
        signature: 'bool RunReplace(string repl_string,int start_run_idx,int start_run_pos,int end_run_idx,int end_run_pos)',
        summary: 'Replace text within a formatted string',
        since: 7
      },
      {
        signature: 'bool SetBold(bool set_on)',
        since: 6
      },
      {
        signature: 'bool SetFacename(bool set_on,string facename)',
        since: 6
      },
      {
        signature: 'bool SetItalic(bool set_on)',
        since: 6
      },
      {
        signature: 'bool SetOverrideDimStyle(DimensionStyle OverrideStyle)',
        summary: `Set a style including overrides for this annotation object.
     The DimensionStyle OverrideStyle must have the override fields marked 
     as overridden and must have it's Id set to nil.
     Use DimensinoStyle.SetFieldOverride(Field field) and related functions
     to manage override settings. To override a field, the field value must be set
     and the field must be marked as an override. 
     The DimensionStyle passed in here must not be in the dimstyle table`,
        since: 6
      },
      {
        signature: 'void SetRichText(string rtfText,DimensionStyle dimstyle)',
        since: 6
      },
      {
        signature: 'bool SetUnderline(bool set_on)',
        since: 6
      },
      {
        signature: 'void WrapText()',
        summary: 'Wrap text',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'AnnotationType',
    dataType: 3,
    summary: 'ON::AnnotationType identifies the type of an annotation object derived from ON_Annotation.',
    values: [
      {
        signature: 'Unset = 0',
        summary: 'Not a valid annotation type.'
      },
      {
        signature: 'Aligned = 1',
        summary: 'Linear distance between two points with dimension line parallel to the dimensioned points.'
      },
      {
        signature: 'Angular = 2',
        summary: 'Angle bewteen two lines.'
      },
      {
        signature: 'Diameter = 3',
        summary: 'Arc or circle diameter dimension.'
      },
      {
        signature: 'Radius = 4',
        summary: 'Arc or circle radius dimension.'
      },
      {
        signature: 'Rotated = 5',
        summary: 'Linear distance between two points with dimension line horizontal, vertical or rotated by a specified amount.'
      },
      {
        signature: 'Ordinate = 6',
        summary: 'Ordinate dimension. Typically used to document an offset distance between the center of a circle and a reference point.'
      },
      {
        signature: 'ArcLen = 7',
        summary: 'Arc length of a curve.'
      },
      {
        signature: 'CenterMark = 8',
        summary: 'Center mark dimension. Typically used to document the center of an arc or circle.'
      },
      {
        signature: 'Text = 9',
        summary: 'Text. Stand alone text with a wide variety of uses.'
      },
      {
        signature: 'Leader = 10',
        summary: 'Leader. Text and a curve with an arrow head.'
      },
      {
        signature: 'Angular3pt = 11',
        summary: 'Angular3pt. Angle defined by 3 points.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Arc',
    dataType: 2,
    summary: `Represents the value of a plane, two angles and a radius in
   a subcurve of a three-dimensional circle.
   
   The curve is parameterized by an angle expressed in radians. For an IsValid arc
   the total subtended angle AngleRadians() = Domain()(1) - Domain()(0) must satisfy
   0 < AngleRadians() < 2*PiThe parameterization of the Arc is inherited from the Circle it is derived from.
   In particulart -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxiswhere xaxis and yaxis, (part of Circle.Plane) form an othonormal frame of the plane
   containing the circle.`,
    constructors: [
      {
        signature: 'Arc(Circle circle,double angleRadians)',
        summary: 'Initializes a new instance of an arc from a base circle and an angle.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'Circle to base arc upon.'
          },
          {
            name: 'angleRadians',
            summary: 'Sweep angle of arc (in radians)'
          }
        ]
      },
      {
        signature: 'Arc(Circle circle,Interval angleIntervalRadians)',
        summary: 'Initializes a new instance of an arc from a base circle and an interval of angles.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'Circle to base arc upon.'
          },
          {
            name: 'angleIntervalRadians',
            summary: 'Increasing angle interval in radians with angleIntervalRadians.Length() <= 2.0*Math.PI.'
          }
        ]
      },
      {
        signature: 'Arc(Plane plane,double radius,double angleRadians)',
        summary: 'Initializes a new arc from a base plane, a radius value and an angle.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'The plane of the arc (arc center will be located at plane origin)'
          },
          {
            name: 'radius',
            summary: 'Radius of arc.'
          },
          {
            name: 'angleRadians',
            summary: 'Sweep angle of arc (in radians)'
          }
        ]
      },
      {
        signature: 'Arc(Plane plane,Point3d center,double radius,double angleRadians)',
        summary: 'Initializes a new aligned arc at the given center point, with a custom radius and angle.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Alignment plane for arc. The arc will be parallel to this plane.'
          },
          {
            name: 'center',
            summary: 'Center point for arc.'
          },
          {
            name: 'radius',
            summary: 'Radius of arc.'
          },
          {
            name: 'angleRadians',
            summary: 'Sweep angle of arc (in radians)'
          }
        ]
      },
      {
        signature: 'Arc(Point3d center,double radius,double angleRadians)',
        summary: 'Initializes a new horizontal arc at the given center point, with a custom radius and angle.',
        since: 5,
        parameters: [
          {
            name: 'center',
            summary: 'Center point of arc.'
          },
          {
            name: 'radius',
            summary: 'Radius of arc.'
          },
          {
            name: 'angleRadians',
            summary: 'Sweep angle of arc (in radians)'
          }
        ]
      },
      {
        signature: 'Arc(Point3d startPoint,Point3d pointOnInterior,Point3d endPoint)',
        summary: `Initializes a new arc through three points. If the points are coincident 
     or colinear, this will result in an Invalid arc.`,
        since: 5,
        parameters: [
          {
            name: 'startPoint',
            summary: 'Start point of arc.'
          },
          {
            name: 'pointOnInterior',
            summary: 'Point on arc interior.'
          },
          {
            name: 'endPoint',
            summary: 'End point of arc.'
          }
        ]
      },
      {
        signature: 'Arc(Point3d pointA,Vector3d tangentA,Point3d pointB)',
        summary: `Initializes a new arc from end points and a tangent vector. 
     If the tangent is parallel with the endpoints this will result in an Invalid arc.`,
        since: 5,
        parameters: [
          {
            name: 'pointA',
            summary: 'Start point of arc.'
          },
          {
            name: 'tangentA',
            summary: 'Tangent at start of arc.'
          },
          {
            name: 'pointB',
            summary: 'End point of arc.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Arc Unset',
        summary: 'Gets an Arc with Unset components.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Angle',
        summary: 'Gets or sets the sweep -or subtended- angle (in Radians) for this arc segment.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double AngleDegrees',
        summary: 'Gets or sets the sweep -or subtended- angle (in Radians) for this arc segment.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Interval AngleDomain',
        summary: 'Gets or sets the angle domain (in Radians) of this arc.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d Center',
        summary: 'Gets or sets the center point for this arc.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Circumference',
        summary: 'Gets the circumference of the circle that is coincident with this arc.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Diameter',
        summary: 'Gets or sets the Diameter of this arc.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double EndAngle',
        summary: 'Gets or sets the end angle (in Radians) for this arc segment.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double EndAngleDegrees',
        summary: 'Gets or sets the end angle (in Radians) for this arc segment.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d EndPoint',
        summary: 'Gets the end point of the arc.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsCircle',
        summary: 'Gets a value indicating whether or not this arc is a complete circle.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: `Gets a value indicating whether or not this arc is valid.
     Detail:
      Radius>0 and 0<AngleRadians()<=2*Math.Pi.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Length',
        summary: 'Gets the length of the arc. (Length = Radius * (subtended angle in radians)).',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d MidPoint',
        summary: 'Gets the mid-point of the arc.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Plane Plane',
        summary: 'Gets or sets the plane in which this arc lies.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Radius',
        summary: 'Gets or sets the radius of this arc.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double StartAngle',
        summary: 'Gets or sets the start angle (in Radians) for this arc segment.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double StartAngleDegrees',
        summary: 'Gets or sets the start angle (in Radians) for this arc segment.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d StartPoint',
        summary: 'Gets the start point of the arc.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'BoundingBox BoundingBox()',
        summary: 'Computes the 3D axis aligned bounding box for this arc.',
        since: 5,
        returns: 'Bounding box of arc.'
      },
      {
        signature: 'double ClosestParameter(Point3d testPoint)',
        summary: 'Gets parameter on the arc closest to a test point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to get close to.'
          }
        ],
        returns: `Parameter (in radians) of the point on the arc that
     is closest to the test point. If testPoint is the center
     of the arc, then the starting point of the arc is
     (arc.Domain()[0]) returned. If no parameter could be found, 
     RhinoMath.UnsetValue is returned.`
      },
      {
        signature: 'Point3d ClosestPoint(Point3d testPoint)',
        summary: 'Computes the point on an arc that is closest to a test point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to get close to.'
          }
        ],
        returns: `The point on the arc that is closest to testPoint. If testPoint is
     the center of the arc, then the starting point of the arc is returned.
     UnsetPoint on failure.`
      },
      {
        signature: 'bool EpsilonEquals(Arc other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(Arc other)',
        summary: 'Determines whether another arc has the same value as this arc.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'An arc.'
          }
        ],
        returns: 'True if obj is equal to this arc; otherwise false.'
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines whether another object is an arc and has the same value as this arc.',
        parameters: [
          {
            name: 'obj',
            summary: 'An object.'
          }
        ],
        returns: 'True if obj is an arc and is exactly equal to this arc; otherwise false.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Computes a hash code for the present arc.',
        returns: 'A non-unique integer that represents this arc.'
      },
      {
        signature: 'Point3d PointAt(double t)',
        summary: 'Gets the point at the given arc parameter.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Arc parameter to evaluate.'
          }
        ],
        returns: 'The point at the given parameter.'
      },
      {
        signature: 'void Reverse()',
        summary: `Reverses the orientation of the arc. Changes the domain from [a,b]
     to [-b,-a].`,
        since: 5
      },
      {
        signature: 'Vector3d TangentAt(double t)',
        summary: 'Gets the tangent at the given parameter.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Parameter of tangent to evaluate.'
          }
        ],
        returns: 'The tangent at the arc at the given parameter.'
      },
      {
        signature: 'NurbsCurve ToNurbsCurve()',
        summary: `Initializes a nurbs curve representation of this arc. 
     This amounts to the same as calling NurbsCurve.CreateFromArc().`,
        since: 5,
        returns: 'A nurbs curve representation of this arc or None if no such representation could be made.'
      },
      {
        signature: 'NurbsCurve ToNurbsCurve(int degree,int cvCount)',
        summary: 'Create a uniform non-ratonal cubic NURBS approximation of an arc.',
        since: 6,
        parameters: [
          {
            name: 'degree',
            summary: '>=1'
          },
          {
            name: 'cvCount',
            summary: 'cv count >=5'
          }
        ],
        returns: 'NURBS curve approximation of an arc on success'
      },
      {
        signature: 'bool Transform(Transform xform)',
        summary: 'Transforms the arc using a Transformation matrix.',
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: `Transformations to apply. 
     Note that arcs cannot handle non-euclidian transformations.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Trim(Interval domain)',
        summary: 'Sets arc\'s angle domain (in radians) as a subdomain of the circle.',
        since: 5,
        parameters: [
          {
            name: 'domain',
            summary: '0 < domain[1] - domain[0] <= 2.0 * RhinoMath.Pi.'
          }
        ],
        returns: 'True on success, False on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'ArcCurve',
    dataType: 1,
    summary: `Represent arcs and circles.
   ArcCurve.IsCircle returns True if the curve is a complete circle.`,
    baseclass: 'Rhino.Geometry.Curve',
    constructors: [
      {
        signature: 'ArcCurve()',
        summary: `Initializes a new ArcCurve instance.
     Radius is set to 1, position to Origin and Domain to full span (circle).`,
        since: 5
      },
      {
        signature: 'ArcCurve(Arc arc)',
        summary: `Initializes a new ArcCurve instance,
     copying values from another Arc.`,
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'Another Arc.'
          }
        ]
      },
      {
        signature: 'ArcCurve(Arc arc,double t0,double t1)',
        summary: `Initializes a new ArcCurve instance,
     copying values from another Arc and specifying the 
     needed parametrization of the arc.
     Arc will not be cut again at these parameterizations.`,
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'An original arc.'
          },
          {
            name: 't0',
            summary: 'A new Domain.T0 value.'
          },
          {
            name: 't1',
            summary: 'A new Domain.T1 value.'
          }
        ]
      },
      {
        signature: 'ArcCurve(ArcCurve other)',
        summary: `Initializes a new ArcCurve instance,
     copying values from another ArcCurve.`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Another ArcCurve.'
          }
        ]
      },
      {
        signature: 'ArcCurve(Circle circle)',
        summary: `Initializes a new ArcCurve instance,
     copying the shape of a Circle.
     Parameterization will be [0;circle.Circumference]`,
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'The original circle.'
          }
        ]
      },
      {
        signature: 'ArcCurve(Circle circle,double t0,double t1)',
        summary: `Initializes a new ArcCurve instance,
     copying values from a Circle and specifying the 
     needed parametrization of the arc.
     Circle will not be newly cut at these parameterizations.`,
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'A circle.'
          },
          {
            name: 't0',
            summary: 'A new Domain.T0 value.'
          },
          {
            name: 't1',
            summary: 'A new Domain.T1 value.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'double AngleDegrees',
        summary: 'Gets the angles of this arc in degrees.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double AngleRadians',
        summary: 'Gets the angles of this arc in radians.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Arc Arc',
        summary: 'Gets the arc that is contained within this ArcCurve.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsCompleteCircle',
        summary: 'Gets a value indicating whether or not this curve can be represented by a complete circle.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Radius',
        summary: 'Gets the radius of this ArcCurve.',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'AreaMassProperties',
    dataType: 1,
    summary: `Contains static initialization methods and allows access to the computed
   metrics of area, area centroid and area moments in closed
   planar curves, in meshes, in surfaces, in hatches and in boundary representations.`,
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'double Area',
        summary: 'Gets the area solution.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double AreaError',
        summary: 'Gets the uncertainty in the area calculation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d Centroid',
        summary: 'Gets the area centroid in the world coordinate system.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CentroidCoordinatesMomentsOfInertia',
        summary: `Moments of inertia with respect to centroid coordinate system.
     X = integral of ((y-y0)^2 + (z-z0)^2) dm
     Y = integral of ((z-z0)^2 + (x-x0)^2) dm
     Z = integral of ((z-z0)^2 + (y-y0)^2) dm
     where (x0,y0,z0) = centroid.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CentroidCoordinatesMomentsOfInertiaError',
        summary: 'Uncertainty in centroid coordinates moments of inertia calculation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CentroidCoordinatesRadiiOfGyration',
        summary: `Radii of gyration with respect to centroid coordinate system.
     X = sqrt(integral of ((y-y0)^2 + (z-z0)^2) dm/M)
     Y = sqrt(integral of ((z-z0)^2 + (x-x0)^2) dm/M)
     Z = sqrt(integral of ((z-z0)^2 + (y-y0)^2) dm/M)
     where (x0,y0,z0) = centroid.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CentroidCoordinatesSecondMoments',
        summary: `Second moments with respect to centroid coordinate system.
     X = integral of (x-x0)^2 dm
     Y = integral of (y-y0)^2 dm
     Z = integral of (z-z0)^2 dm
     where (x0,y0,z0) = centroid.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CentroidCoordinatesSecondMomentsError',
        summary: 'Uncertainty in centroid coordinates second moments calculation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CentroidError',
        summary: 'Gets the uncertainty in the centroid calculation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesFirstMoments',
        summary: `Returns the world coordinate first moments if they were able to be calculated.
     X is integral of "x dm" over the area
     Y is integral of "y dm" over the area
     Z is integral of "z dm" over the area.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesFirstMomentsError',
        summary: 'Uncertainty in world coordinates first moments calculation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesMomentsOfInertia',
        summary: `The moments of inertia about the world coordinate axes.
     X = integral of (y^2 + z^2) dm
     Y = integral of (z^2 + x^2) dm
     Z = integral of (z^2 + y^2) dm.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesMomentsOfInertiaError',
        summary: 'Uncertainty in world coordinates moments of inertia calculation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesProductMoments',
        summary: `Returns the world coordinate product moments if they were able to be calculated.
     X is integral of "xy dm" over the area
     Y is integral of "yz dm" over the area
     Z is integral of "zx dm" over the area.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesProductMomentsError',
        summary: 'Uncertainty in world coordinates second moments calculation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesRadiiOfGyration',
        summary: `Radii of gyration with respect to world coordinate system.
     X = sqrt(integral of (y^2 + z^2) dm/M)
     Y = sqrt(integral of (z^2 + x^2) dm/M)
     Z = sqrt(integral of (z^2 + y^2) dm/M)`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesSecondMoments',
        summary: `Returns the world coordinate first moments if they were able to be calculated.
     X is integral of "xx dm" over the area
     Y is integral of "yy dm" over the area
     Z is integral of "zz dm" over the area.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesSecondMomentsError',
        summary: 'Uncertainty in world coordinates second moments calculation.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static AreaMassProperties Compute(Brep brep)',
        summary: 'Computes an AreaMassProperties for a brep.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'Brep to measure.'
          }
        ],
        returns: 'The AreaMassProperties for the given Brep or None on failure.'
      },
      {
        signature: 'static AreaMassProperties Compute(Brep brep,bool area,bool firstMoments,bool secondMoments,bool productMoments)',
        summary: 'Compute the AreaMassProperties for a single Brep.',
        since: 6.3,
        parameters: [
          {
            name: 'brep',
            summary: 'Brep to measure.'
          },
          {
            name: 'area',
            summary: 'True to calculate area.'
          },
          {
            name: 'firstMoments',
            summary: 'True to calculate area first moments, area, and area centroid.'
          },
          {
            name: 'secondMoments',
            summary: 'True to calculate area second moments.'
          },
          {
            name: 'productMoments',
            summary: 'True to calculate area product moments.'
          }
        ],
        returns: 'The AreaMassProperties for the given Brep or None on failure.'
      },
      {
        signature: 'static AreaMassProperties Compute(Curve closedPlanarCurve)',
        summary: 'Computes an AreaMassProperties for a closed planar curve.',
        since: 5,
        parameters: [
          {
            name: 'closedPlanarCurve',
            summary: 'Curve to measure.'
          }
        ],
        returns: 'The AreaMassProperties for the given curve or None on failure.'
      },
      {
        signature: 'static AreaMassProperties Compute(Curve closedPlanarCurve,double planarTolerance)',
        summary: 'Computes an AreaMassProperties for a closed planar curve.',
        since: 5,
        parameters: [
          {
            name: 'closedPlanarCurve',
            summary: 'Curve to measure.'
          },
          {
            name: 'planarTolerance',
            summary: 'absolute tolerance used to insure the closed curve is planar'
          }
        ],
        returns: 'The AreaMassProperties for the given curve or None on failure.'
      },
      {
        signature: 'static AreaMassProperties Compute(Hatch hatch)',
        summary: 'Computes an AreaMassProperties for a hatch.',
        since: 5,
        parameters: [
          {
            name: 'hatch',
            summary: 'Hatch to measure.'
          }
        ],
        returns: 'The AreaMassProperties for the given hatch or None on failure.'
      },
      {
        signature: 'static AreaMassProperties Compute(IEnumerable<GeometryBase> geometry)',
        summary: `Computes the Area properties for a collection of geometric objects. 
     At present only Breps, Surfaces, Meshes and Planar Closed Curves are supported.`,
        since: 5.1,
        parameters: [
          {
            name: 'geometry',
            summary: 'Objects to include in the area computation.'
          }
        ],
        returns: 'The Area properties for the entire collection or None on failure.'
      },
      {
        signature: 'static AreaMassProperties Compute(IEnumerable<GeometryBase> geometry,bool area,bool firstMoments,bool secondMoments,bool productMoments)',
        summary: `Computes the AreaMassProperties for a collection of geometric objects. 
     At present only Breps, Surfaces, Meshes and Planar Closed Curves are supported.`,
        since: 6.3,
        parameters: [
          {
            name: 'geometry',
            summary: 'Objects to include in the area computation.'
          },
          {
            name: 'area',
            summary: 'True to calculate area.'
          },
          {
            name: 'firstMoments',
            summary: 'True to calculate area first moments, area, and area centroid.'
          },
          {
            name: 'secondMoments',
            summary: 'True to calculate area second moments.'
          },
          {
            name: 'productMoments',
            summary: 'True to calculate area product moments.'
          }
        ],
        returns: 'The AreaMassProperties for the entire collection or None on failure.'
      },
      {
        signature: 'static AreaMassProperties Compute(Mesh mesh)',
        summary: 'Computes an AreaMassProperties for a mesh.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh to measure.'
          }
        ],
        returns: 'The AreaMassProperties for the given Mesh or None on failure.'
      },
      {
        signature: 'static AreaMassProperties Compute(Mesh mesh,bool area,bool firstMoments,bool secondMoments,bool productMoments)',
        summary: 'Compute the AreaMassProperties for a single Mesh.',
        since: 6.3,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh to measure.'
          },
          {
            name: 'area',
            summary: 'True to calculate area.'
          },
          {
            name: 'firstMoments',
            summary: 'True to calculate area first moments, area, and area centroid.'
          },
          {
            name: 'secondMoments',
            summary: 'True to calculate area second moments.'
          },
          {
            name: 'productMoments',
            summary: 'True to calculate area product moments.'
          }
        ],
        returns: 'The AreaMassProperties for the given Mesh or None on failure.'
      },
      {
        signature: 'static AreaMassProperties Compute(Surface surface)',
        summary: 'Computes an AreaMassProperties for a surface.',
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'Surface to measure.'
          }
        ],
        returns: 'The AreaMassProperties for the given Surface or None on failure.'
      },
      {
        signature: 'static AreaMassProperties Compute(Surface surface,bool area,bool firstMoments,bool secondMoments,bool productMoments)',
        summary: 'Compute the AreaMassProperties for a single Surface.',
        since: 6.3,
        parameters: [
          {
            name: 'surface',
            summary: 'Surface to measure.'
          },
          {
            name: 'area',
            summary: 'True to calculate area.'
          },
          {
            name: 'firstMoments',
            summary: 'True to calculate area first moments, area, and area centroid.'
          },
          {
            name: 'secondMoments',
            summary: 'True to calculate area second moments.'
          },
          {
            name: 'productMoments',
            summary: 'True to calculate area product moments.'
          }
        ],
        returns: 'The AreaMassProperties for the given Surface or None on failure.'
      },
      {
        signature: 'bool CentroidCoordinatesPrincipalMoments(double x,Vector3d xaxis,double y,Vector3d yaxis,double z,Vector3d zaxis)',
        summary: `Calculates the principal moments and principal axes with repect to centroid coordinates. 
     These are simply the eigenvalues and eigenvectors of the centroid coordinate inertia matrix.`,
        since: 6.9,
        parameters: [
          {
            name: 'x',
            summary: 'Principal moment.'
          },
          {
            name: 'xaxis',
            summary: 'Principal axis for x.'
          },
          {
            name: 'y',
            summary: 'Principal moment.'
          },
          {
            name: 'yaxis',
            summary: 'Principal axis for y.'
          },
          {
            name: 'z',
            summary: 'Principal moment.'
          },
          {
            name: 'zaxis',
            summary: 'Principal axis for z.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'bool WorldCoordinatesPrincipalMoments(double x,Vector3d xaxis,double y,Vector3d yaxis,double z,Vector3d zaxis)',
        summary: `Calculates the principal moments and principal axes with repect to world coordinates. 
     These are simply the eigenvalues and eigenvectors of the world coordinate inertia matrix.`,
        since: 6.9,
        parameters: [
          {
            name: 'x',
            summary: 'Principal moment.'
          },
          {
            name: 'xaxis',
            summary: 'Principal axis for x.'
          },
          {
            name: 'y',
            summary: 'Principal moment.'
          },
          {
            name: 'yaxis',
            summary: 'Principal axis for y.'
          },
          {
            name: 'z',
            summary: 'Principal moment.'
          },
          {
            name: 'zaxis',
            summary: 'Principal axis for z.'
          }
        ],
        returns: 'True if successful.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Arrowhead',
    dataType: 1,
    summary: 'Arrowhead used by annotation',
    constructors: [
      {
        signature: 'Arrowhead()',
        summary: 'Constructor',
        since: 6
      },
      {
        signature: 'Arrowhead(ArrowType arrowType,Guid blockId)',
        summary: 'Constructor',
        since: 6,
        parameters: [
          {
            name: 'arrowType',
            summary: 'type of this arrowhead'
          },
          {
            name: 'blockId',
            summary: 'Guid of the block used for user defined display'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'ArrowType ArrowType',
        summary: 'Type of arrowhead used by annotation',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid BlockId',
        summary: 'Id of block used for user-defined arrowhead',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BezierCurve',
    dataType: 1,
    summary: `Represents a Bezier curve.
   Note: as an exception, the bezier curve is not derived from .`,
    interfaces: ['IDisposable', 'ISerializable'],
    constructors: [
      {
        signature: 'BezierCurve(IEnumerable<Point2d> controlPoints)',
        summary: 'Create bezier curve with controls defined by a list of 2d points',
        since: 5
      },
      {
        signature: 'BezierCurve(IEnumerable<Point3d> controlPoints)',
        summary: 'Create bezier curve with controls defined by a list of 3d points',
        since: 5
      },
      {
        signature: 'BezierCurve(IEnumerable<Point4d> controlPoints)',
        summary: 'Create bezier curve with controls defined by a list of 4d points',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'int ControlVertexCount',
        summary: 'Number of control vertices in this curve',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Dimension',
        summary: 'Dimension of Bezier',
        since: 6.3,
        property: ['get']
      },
      {
        signature: 'bool IsRational',
        summary: `Gets a value indicating whether or not the curve is rational. 
     Rational curves have control-points with custom weights.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: 'Tests an object to see if it is valid.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static BezierCurve[] CreateBeziers(Curve sourceCurve)',
        summary: `Create an array of Bezier curves that fit to an existing curve. Please note, these
     Beziers can be of any order and may be rational.`,
        since: 6,
        parameters: [
          {
            name: 'sourceCurve',
            summary: 'The curve to fit Beziers to'
          }
        ],
        returns: 'A new array of Bezier curves'
      },
      {
        signature: 'static BezierCurve[] CreateCubicBeziers(Curve sourceCurve,double distanceTolerance,double kinkTolerance)',
        summary: 'Constructs an array of cubic, non-rational beziers that fit a curve to a tolerance.',
        since: 5,
        parameters: [
          {
            name: 'sourceCurve',
            summary: 'A curve to approximate.'
          },
          {
            name: 'distanceTolerance',
            summary: 'The max fitting error. Use RhinoMath.SqrtEpsilon as a minimum.'
          },
          {
            name: 'kinkTolerance',
            summary: `If the input curve has a g1-discontinuity with angle radian measure
     greater than kinkTolerance at some point P, the list of beziers will
     also have a kink at P.`
          }
        ],
        returns: 'A new array of bezier curves. The array can be empty and might contain None items.'
      },
      {
        signature: 'static BezierCurve CreateLoftedBezier(IEnumerable<Point2d> points)',
        summary: 'Loft a bezier through a list of points',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: '2 or more points to interpolate'
          }
        ],
        returns: 'new bezier curve if successful'
      },
      {
        signature: 'static BezierCurve CreateLoftedBezier(IEnumerable<Point3d> points)',
        summary: 'Loft a bezier through a list of points',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: '2 or more points to interpolate'
          }
        ],
        returns: 'new bezier curve if successful'
      },
      {
        signature: 'bool ChangeDimension(int desiredDimension)',
        summary: 'Change dimension of bezier.',
        since: 5,
        returns: 'True if successful.  False if desired_dimension < 1'
      },
      {
        signature: 'Vector3d CurvatureAt(double t)',
        summary: 'Evaluate the curvature vector at a curve parameter.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Evaluation parameter.'
          }
        ],
        returns: 'Curvature vector of the curve at the parameter t.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'BoundingBox GetBoundingBox(bool accurate)',
        summary: 'Boundingbox solver. Gets the world axis aligned boundingbox for the curve.',
        since: 5,
        parameters: [
          {
            name: 'accurate',
            summary: `If true, a physically accurate boundingbox will be computed. 
     If not, a boundingbox estimate will be computed. For some geometry types there is no 
     difference between the estimate and the accurate boundingbox. Estimated boundingboxes 
     can be computed much (much) faster than accurate (or "tight") bounding boxes. 
     Estimated bounding boxes are always similar to or larger than accurate bounding boxes.`
          }
        ],
        returns: `The boundingbox of the geometry in world coordinates or BoundingBox.Empty 
     if not bounding box could be found.`
      },
      {
        signature: 'Point2d GetControlVertex2d(int index)',
        summary: 'Get location of a control vertex.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Control vertex index (0 <= index < ControlVertexCount)'
          }
        ],
        returns: 'If the bezier is rational, the euclidean location is returned.'
      },
      {
        signature: 'Point3d GetControlVertex3d(int index)',
        summary: 'Get location of a control vertex.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Control vertex index (0 <= index < ControlVertexCount)'
          }
        ],
        returns: 'If the bezier is rational, the euclidean location is returned.'
      },
      {
        signature: 'Point4d GetControlVertex4d(int index)',
        summary: 'Get location of a control vertex.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Control vertex index (0 <= index < ControlVertexCount)'
          }
        ],
        returns: `Homogenous value of control vertex. If the bezier is not
     rational, the weight is 1.`
      },
      {
        signature: 'void GetObjectData(SerializationInfo info,StreamingContext context)',
        summary: 'Populates a System.Runtime.Serialization.SerializationInfo with the data needed to serialize the target object.',
        since: 6.3,
        parameters: [
          {
            name: 'info',
            summary: 'The System.Runtime.Serialization.SerializationInfo to populate with data.'
          },
          {
            name: 'context',
            summary: 'The destination (see System.Runtime.Serialization.StreamingContext) for this serialization.'
          }
        ]
      },
      {
        signature: 'bool IncreaseDegree(int desiredDegree)',
        summary: 'Increase degree of bezier',
        since: 5,
        returns: 'True if successful.  False if desiredDegree < current degree.'
      },
      {
        signature: 'bool MakeNonRational()',
        summary: 'Make bezier non-rational',
        since: 5,
        returns: 'treu if successful'
      },
      {
        signature: 'bool MakeRational()',
        summary: 'Make bezier rational',
        since: 5,
        returns: 'True if successful'
      },
      {
        signature: 'Point3d PointAt(double t)',
        summary: 'Evaluates point at a curve parameter.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Evaluation parameter.'
          }
        ],
        returns: 'Point (location of curve at the parameter t).'
      },
      {
        signature: 'bool Split(double t,BezierCurve left,BezierCurve right)',
        summary: 'Divides the Bezier curve at the specified parameter.',
        since: 6,
        parameters: [
          {
            name: 't',
            summary: 'parameter must satisfy 0 < t < 1'
          },
          {
            name: 'left',
            summary: ''
          },
          {
            name: 'right',
            summary: ''
          }
        ],
        returns: 'True on success'
      },
      {
        signature: 'Vector3d TangentAt(double t)',
        summary: 'Evaluates the unit tangent vector at a curve parameter.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Evaluation parameter.'
          }
        ],
        returns: 'Unit tangent vector of the curve at the parameter t.'
      },
      {
        signature: 'NurbsCurve ToNurbsCurve()',
        summary: 'Constructs a NURBS curve representation of this curve.',
        since: 5,
        returns: 'NURBS representation of the curve on success, None on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BlendContinuity',
    dataType: 3,
    summary: 'Used in curve and surface blending functions',
    values: [
      {
        signature: 'Position = 0'
      },
      {
        signature: 'Tangency = 1'
      },
      {
        signature: 'Curvature = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BlendType',
    dataType: 3,
    summary: 'Blend types used for creating filleted Brep edges',
    values: [
      {
        signature: 'Chamfer = 0',
        summary: 'Creates a ruled surface between brep edges with varying chamfer distances.'
      },
      {
        signature: 'Fillet = 1',
        summary: 'Creates a tangent surface between brep edges with varying radius values.'
      },
      {
        signature: 'Blend = 2',
        summary: 'Creates a curvature-continuous blend surface between brep edges with varying radius values.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BoundingBox',
    dataType: 2,
    summary: `Represents the value of two points in a bounding box 
   defined by the two extreme corner points.
   This box is therefore aligned to the world X, Y and Z axes.`,
    constructors: [
      {
        signature: 'BoundingBox(double minX,double minY,double minZ,double maxX,double maxY,double maxZ)',
        summary: 'Constructs a boundingbox from numeric extremes.',
        since: 5,
        parameters: [
          {
            name: 'minX',
            summary: 'Lower extreme for box X size.'
          },
          {
            name: 'minY',
            summary: 'Lower extreme for box Y size.'
          },
          {
            name: 'minZ',
            summary: 'Lower extreme for box Z size.'
          },
          {
            name: 'maxX',
            summary: 'Upper extreme for box X size.'
          },
          {
            name: 'maxY',
            summary: 'Upper extreme for box Y size.'
          },
          {
            name: 'maxZ',
            summary: 'Upper extreme for box Z size.'
          }
        ]
      },
      {
        signature: 'BoundingBox(IEnumerable<Point3d> points)',
        summary: 'Constructs a boundingbox from a collection of points.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to include in the boundingbox.'
          }
        ]
      },
      {
        signature: 'BoundingBox(IEnumerable<Point3d> points,Transform xform)',
        summary: 'Constructs a boundingbox from a collection of points.',
        since: 6,
        parameters: [
          {
            name: 'points',
            summary: 'Points to include in the boundingbox.'
          },
          {
            name: 'xform',
            summary: 'Transformation.'
          }
        ]
      },
      {
        signature: 'BoundingBox(Point3d min,Point3d max)',
        summary: 'Constructs a new boundingbox from two corner points.',
        since: 5,
        parameters: [
          {
            name: 'min',
            summary: 'Point containing all the minimum coordinates.'
          },
          {
            name: 'max',
            summary: 'Point containing all the maximum coordinates.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static BoundingBox Empty',
        summary: 'Gets an [Empty] boundingbox. An Empty box is an invalid structure that has negative width.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static BoundingBox Unset',
        summary: 'Gets a boundingbox that has Unset coordinates for Min and Max.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Area',
        summary: 'Gets the area of this BoundingBox.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Point3d Center',
        summary: 'Gets the point in the center of the boundingbox.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d Diagonal',
        summary: `Gets the diagonal vector of this BoundingBox. 
     The diagonal connects the Min and Max points.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: `Gets a value that indicates whether or not this boundingbox is valid. 
     Empty boxes are not valid, and neither are boxes with unset points.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d Max',
        summary: 'Gets or sets the point in the maximal corner.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d Min',
        summary: 'Gets or sets the point in the minimal corner.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Volume',
        summary: 'Gets the volume of this BoundingBox.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static BoundingBox Intersection(BoundingBox a,BoundingBox b)',
        summary: 'Computes the intersection of two bounding boxes.',
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'A first bounding box.'
          },
          {
            name: 'b',
            summary: 'A second bounding box.'
          }
        ],
        returns: 'The intersection bounding box.'
      },
      {
        signature: 'static BoundingBox Union(BoundingBox a,BoundingBox b)',
        summary: 'Returns a new BoundingBox that represents the union of boxes a and b.',
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'First box to include in union.'
          },
          {
            name: 'b',
            summary: 'Second box to include in union.'
          }
        ],
        returns: 'The BoundingBox that contains both a and b.'
      },
      {
        signature: 'static BoundingBox Union(BoundingBox box,Point3d point)',
        summary: 'Returns a new BoundingBox that represents the union of a bounding box and a point.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to include in the union.'
          },
          {
            name: 'point',
            summary: 'Point to include in the union.'
          }
        ],
        returns: 'The BoundingBox that contains both the box and the point.'
      },
      {
        signature: 'Point3d ClosestPoint(Point3d point)',
        summary: 'Finds the closest point on or in the boundingbox.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Sample point.'
          }
        ],
        returns: 'The point on or in the box that is closest to the sample point.'
      },
      {
        signature: 'Point3d ClosestPoint(Point3d point,bool includeInterior)',
        summary: 'Finds the closest point on or in the boundingbox.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Sample point.'
          },
          {
            name: 'includeInterior',
            summary: `If false, the point is projected onto the boundary faces only, 
     otherwise the interior of the box is also taken into consideration.`
          }
        ],
        returns: 'The point on or in the box that is closest to the sample point.'
      },
      {
        signature: 'bool Contains(BoundingBox box)',
        summary: `Determines whether this boundingbox contains another boundingbox.
     This is the same as calling Contains(box,false).`,
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to test.'
          }
        ],
        returns: 'True if the box is on the inside of this boundingbox, or is coincident with the surface of it.'
      },
      {
        signature: 'bool Contains(BoundingBox box,bool strict)',
        summary: `Determines whether this boundingbox contains another boundingbox.
     The user can choose how to treat boundingboxes with coincidents surfaces.`,
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to test.'
          },
          {
            name: 'strict',
            summary: `If true, the box needs to be fully on the inside of the boundingbox. 
     I.e. coincident boxes will be considered 'outside'.`
          }
        ],
        returns: 'True if the box is (strictly) on the inside of this BoundingBox.'
      },
      {
        signature: 'bool Contains(Point3d point)',
        summary: 'Tests a point for boundingbox inclusion. This is the same as calling Contains(point, false)',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to test.'
          }
        ],
        returns: 'True if the point is on the inside of or coincident with this boundingbox; otherwise false.'
      },
      {
        signature: 'bool Contains(Point3d point,bool strict)',
        summary: 'Tests a point for BoundingBox inclusion.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to test.'
          },
          {
            name: 'strict',
            summary: `If true, the point needs to be fully on the inside of the BoundingBox. 
     I.e. coincident points will be considered 'outside'.`
          }
        ],
        returns: 'If \'strict\' is affirmative, True if the point is inside this boundingbox; False if it is on the surface or outside.If \'strict\' is negative, True if the point is on the surface or on the inside of the boundingbox; otherwise false.'
      },
      {
        signature: 'Point3d Corner(bool minX,bool minY,bool minZ)',
        summary: 'Gets one of the eight corners of the box.',
        since: 5,
        parameters: [
          {
            name: 'minX',
            summary: 'True for the minimum on the X axis; False for the maximum.'
          },
          {
            name: 'minY',
            summary: 'True for the minimum on the Y axis; False for the maximum.'
          },
          {
            name: 'minZ',
            summary: 'True for the minimum on the Z axis; False for the maximum.'
          }
        ],
        returns: 'The requested point.'
      },
      {
        signature: 'Point3d FurthestPoint(Point3d point)',
        summary: 'Finds the furthest point on the Box.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Sample point.'
          }
        ],
        returns: 'The point on the box that is furthest from the sample point.'
      },
      {
        signature: 'Point3d[] GetCorners()',
        summary: `Gets an array filled with the 8 corner points of this box.
     See remarks for the return order.`,
        since: 5,
        returns: 'An array of 8 corners.'
      },
      {
        signature: 'Line[] GetEdges()',
        summary: 'Gets an array of the 12 edges of this box.',
        since: 5,
        returns: 'If the boundingbox IsValid, the 12 edges; otherwise, null.'
      },
      {
        signature: 'void Inflate(double amount)',
        summary: `Inflates the box with equal amounts in all directions. 
     Inflating with negative amounts may result in decreasing boxes. 
     Invalid boxes can not be inflated.`,
        since: 5,
        parameters: [
          {
            name: 'amount',
            summary: 'Amount (in model units) to inflate this box in all directions.'
          }
        ]
      },
      {
        signature: 'void Inflate(double xAmount,double yAmount,double zAmount)',
        summary: `Inflate the box with custom amounts in all directions. 
     Inflating with negative amounts may result in decreasing boxes. 
     InValid boxes can not be inflated.`,
        since: 5,
        parameters: [
          {
            name: 'xAmount',
            summary: 'Amount (in model units) to inflate this box in the x direction.'
          },
          {
            name: 'yAmount',
            summary: 'Amount (in model units) to inflate this box in the y direction.'
          },
          {
            name: 'zAmount',
            summary: 'Amount (in model units) to inflate this box in the z direction.'
          }
        ]
      },
      {
        signature: 'int IsDegenerate(double tolerance)',
        summary: 'Determines whether a bounding box is degenerate (flat) in one or more directions.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: `Distances <= tolerance will be considered to be zero.  If tolerance
     is negative (default), then a scale invarient tolerance is used.`
          }
        ],
        returns: `0 = box is not degenerate
     1 = box is a rectangle (degenerate in one direction).
     2 = box is a line (degenerate in two directions).
     3 = box is a point (degenerate in three directions)
     4 = box is not valid.`
      },
      {
        signature: 'bool MakeValid()',
        summary: `Ensures that the box is defined in an increasing fashion along X, Y and Z axes.
     If the Min or Max points are unset, this function will not change the box.`,
        since: 5,
        returns: 'True if the box was made valid, False if the box could not be made valid.'
      },
      {
        signature: 'Point3d PointAt(double tx,double ty,double tz)',
        summary: `Evaluates the boundingbox with normalized parameters.
     The box has idealized side length of 1x1x1.`,
        since: 5,
        parameters: [
          {
            name: 'tx',
            summary: 'Normalized (between 0 and 1 is inside the box) parameter along the X direction.'
          },
          {
            name: 'ty',
            summary: 'Normalized (between 0 and 1 is inside the box) parameter along the Y direction.'
          },
          {
            name: 'tz',
            summary: 'Normalized (between 0 and 1 is inside the box) parameter along the Z direction.'
          }
        ],
        returns: 'The point at the {tx, ty, tz} parameters.'
      },
      {
        signature: 'Brep ToBrep()',
        summary: 'Constructs a Brep representation of this boundingbox.',
        since: 5,
        returns: 'If this operation is sucessfull, a Brep representation of this box; otherwise null.'
      },
      {
        signature: 'string ToString()',
        summary: 'Constructs the string representation of this aligned boundingbox.',
        returns: 'Text.'
      },
      {
        signature: 'bool Transform(Transform xform)',
        summary: `Updates this boundingbox to be the smallest axis aligned
     boundingbox that contains the transformed result of its 8 original corner
     points.`,
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'A transform.'
          }
        ],
        returns: 'True if this operation is sucessfull; otherwise false.'
      },
      {
        signature: 'void Union(BoundingBox other)',
        summary: 'Updates this BoundingBox to represent the union of itself and another box.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Box to include in this union.'
          }
        ]
      },
      {
        signature: 'void Union(Point3d point)',
        summary: 'Updates this BoundingBox to represent the union of itself and a point.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to include in the union.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Box',
    dataType: 2,
    summary: `Represents the value of a plane and three intervals in
   an orthogonal, oriented box that is not necessarily parallel to the world Y, X, Z axes.`,
    constructors: [
      {
        signature: 'Box(BoundingBox bbox)',
        summary: `Initializes a new Box that mimics a BoundingBox struct. 
     The orientation plane of the Box is coincident with the 
     World XY plane.`,
        since: 5,
        parameters: [
          {
            name: 'bbox',
            summary: 'BoundingBox to mimic.'
          }
        ]
      },
      {
        signature: 'Box(Plane basePlane,BoundingBox boundingbox)',
        summary: 'Initializes a world aligned box from a base plane and a boundingbox.',
        since: 5,
        parameters: [
          {
            name: 'basePlane',
            summary: 'Base plane of bounging box.'
          },
          {
            name: 'boundingbox',
            summary: 'Bounding Box in plane coordinates.'
          }
        ]
      },
      {
        signature: 'Box(Plane basePlane,GeometryBase geometry)',
        summary: `Initializes a box that contains a generic piece of geometry.
     This box will be aligned with an arbitrary plane.`,
        since: 5,
        parameters: [
          {
            name: 'basePlane',
            summary: 'Base plane for aligned bounding box.'
          },
          {
            name: 'geometry',
            summary: 'Geometry to box.'
          }
        ]
      },
      {
        signature: 'Box(Plane basePlane,IEnumerable<Point3d> points)',
        summary: 'Initializes the smallest box that contains a set of points.',
        since: 5,
        parameters: [
          {
            name: 'basePlane',
            summary: 'Orientation of the box.'
          },
          {
            name: 'points',
            summary: 'Points to include, Invalid points will be ignored.'
          }
        ]
      },
      {
        signature: 'Box(Plane basePlane,Interval xSize,Interval ySize,Interval zSize)',
        summary: 'Initializes a new box from a base Plane and three Intervals.',
        since: 5,
        parameters: [
          {
            name: 'basePlane',
            summary: 'Orientation plane of the box.'
          },
          {
            name: 'xSize',
            summary: 'Dimensions along the base plane X-Axis.'
          },
          {
            name: 'ySize',
            summary: 'Dimensions along the base plane Y-Axis.'
          },
          {
            name: 'zSize',
            summary: 'Dimensions along the base plane Z-Axis.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Box Empty',
        summary: 'Empty Box. Empty boxes are considered to be invalid.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Box Unset',
        summary: 'Gets a Box whose base plane and axis dimensions are all Unset.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Area',
        summary: 'Gets the total surface area of this box.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BoundingBox BoundingBox',
        summary: 'Gets the world axis aligned Bounding box for this oriented box.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d Center',
        summary: 'Gets the point that is in the center of the box.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: `Gets the validity of this Box. Boxes are invalid when the base plane or any of 
     the dimension intervals are invalid or decreasing.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Plane Plane',
        summary: 'Gets or sets the orientation plane for this Box.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Volume',
        summary: 'Gets the total volume of this box.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Interval X',
        summary: `Gets or sets the Interval that describes the dimension of the 
     Box along the orientation plane X-Axis. Otherwise known as the Width of the Box.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Interval Y',
        summary: `Gets or sets the Interval that describes the dimension of the 
     Box along the orientation plane Y-Axis. Otherwise known as the Depth of the Box.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Interval Z',
        summary: `Gets or sets the Interval that describes the dimension of the 
     Box along the orientation plane Z-Axis. Otherwise known as the Height of the Box.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'Point3d ClosestPoint(Point3d point)',
        summary: 'Finds the closest point on or in the Box. The box should be Valid for this to work.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Sample point.'
          }
        ],
        returns: 'The point on or in the box that is closest to the sample point.'
      },
      {
        signature: 'bool Contains(BoundingBox box)',
        summary: 'Test a boundingbox for Box inclusion. This is the same as calling Contains(box,false)',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to test.'
          }
        ],
        returns: 'True if the box is on the inside of or coincident with this Box.'
      },
      {
        signature: 'bool Contains(BoundingBox box,bool strict)',
        summary: 'Test a boundingbox for Box inclusion.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to test.'
          },
          {
            name: 'strict',
            summary: `If true, the boundingbox needs to be fully on the inside of this Box. 
     I.e. coincident boxes will be considered 'outside'.`
          }
        ],
        returns: 'True if the box is (strictly) on the inside of this Box.'
      },
      {
        signature: 'bool Contains(Box box)',
        summary: 'Test a box for Box inclusion. This is the same as calling Contains(box,false)',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to test.'
          }
        ],
        returns: 'True if the box is on the inside of or coincident with this Box.'
      },
      {
        signature: 'bool Contains(Box box,bool strict)',
        summary: 'Test a box for Box inclusion.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to test.'
          },
          {
            name: 'strict',
            summary: `If true, the box needs to be fully on the inside of this Box. 
     I.e. coincident boxes will be considered 'outside'.`
          }
        ],
        returns: 'True if the box is (strictly) on the inside of this Box.'
      },
      {
        signature: 'bool Contains(Point3d point)',
        summary: 'Determines whether a point is included in this box. This is the same as calling Contains(point,false)',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to test.'
          }
        ],
        returns: 'True if the point is on the inside of or coincident with this Box.'
      },
      {
        signature: 'bool Contains(Point3d point,bool strict)',
        summary: 'Determines whether a point is included in this box.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to test.'
          },
          {
            name: 'strict',
            summary: `If true, the point needs to be fully on the inside of the Box. 
     I.e. coincident points will be considered 'outside'.`
          }
        ],
        returns: 'True if the point is (strictly) on the inside of this Box.'
      },
      {
        signature: 'bool EpsilonEquals(Box other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'Point3d FurthestPoint(Point3d point)',
        summary: 'Finds the furthest point on the Box. The Box should be Valid for this to work properly.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Sample point.'
          }
        ],
        returns: 'The point on the box that is furthest from the sample point.'
      },
      {
        signature: 'Point3d[] GetCorners()',
        summary: 'Gets an array of the 8 corner points of this box.',
        since: 5,
        returns: 'An array of 8 corners.'
      },
      {
        signature: 'void Inflate(double amount)',
        summary: `Inflates the box by a given offset in each direction.
     Inflating with negative amounts may result in decreasing boxes. 
     InValid boxes cannot be inflated.`,
        since: 5,
        parameters: [
          {
            name: 'amount',
            summary: 'Amount (in model units) to inflate this box in all directions.'
          }
        ]
      },
      {
        signature: 'void Inflate(double xAmount,double yAmount,double zAmount)',
        summary: `Inflates the box by a given offset in each direction.
     Inflating with negative amounts may result in decreasing boxes.
     InValid boxes cannot be inflated.`,
        since: 5,
        parameters: [
          {
            name: 'xAmount',
            summary: 'Amount (in model units) to inflate this box in the x direction.'
          },
          {
            name: 'yAmount',
            summary: 'Amount (in model units) to inflate this box in the y direction.'
          },
          {
            name: 'zAmount',
            summary: 'Amount (in model units) to inflate this box in the z direction.'
          }
        ]
      },
      {
        signature: 'bool MakeValid()',
        summary: 'Attempts to make the Box valid. This is not always possible.',
        since: 5,
        returns: `True if the box was made valid, or if it was valid to begin with. 
     False if the box remains in a differently abled state.`
      },
      {
        signature: 'Point3d PointAt(double x,double y,double z)',
        summary: `Evaluates the box volume at the given unitized parameters.
     The box has idealized side length of 1x1x1.`,
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'Unitized parameter (between 0 and 1 is inside the box) along box X direction.'
          },
          {
            name: 'y',
            summary: 'Unitized parameter (between 0 and 1 is inside the box) along box Y direction.'
          },
          {
            name: 'z',
            summary: 'Unitized parameter (between 0 and 1 is inside the box) along box Z direction.'
          }
        ],
        returns: 'The point at (x,y,z).'
      },
      {
        signature: 'void RepositionBasePlane(Point3d origin)',
        summary: `Repositions the origin of the Base plane for this box without affecting 
     the physical dimensions.`,
        since: 5,
        parameters: [
          {
            name: 'origin',
            summary: 'The new base plane origin.'
          }
        ]
      },
      {
        signature: 'Brep ToBrep()',
        summary: 'Constructs a brep representation of this box.',
        since: 5,
        returns: 'A Brep representation of this box or null.'
      },
      {
        signature: 'Extrusion ToExtrusion()',
        summary: 'Constructs an extrusion representation of this box.',
        since: 6,
        returns: 'An Extrusion representation of this box or null.'
      },
      {
        signature: 'bool Transform(Transform xform)',
        summary: `Transforms this Box using a Transformation matrix. If the Transform does not preserve 
     Similarity, the dimensions of the resulting box cannot be trusted.`,
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation matrix to apply to this Box.'
          }
        ],
        returns: 'True if the Box was successfully transformed, False if otherwise.'
      },
      {
        signature: 'void Union(Point3d point)',
        summary: `Constructs a union between this Box and the given point. 
     This grows the box in directions so it contains the point.`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to include.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Brep',
    dataType: 1,
    summary: 'Boundary Representation. A surface or polysurface along with trim curve information.',
    baseclass: 'Rhino.Geometry.GeometryBase',
    constructors: [
      {
        signature: 'Brep()',
        summary: 'Initializes a new empty brep',
        since: 5.4
      }
    ],
    properties: [
      {
        signature: 'BrepCurveList Curves2D',
        summary: 'Parameter space trimming curves (used by trims)',
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'BrepCurveList Curves3D',
        summary: 'Pointers to 3d curves (used by edges)',
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'BrepEdgeList Edges',
        summary: 'Gets the brep edges list accessor.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BrepFaceList Faces',
        summary: 'Gets the brep faces list accessor.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsManifold',
        summary: `Gets a value indicating whether or not the Brep is manifold. 
     Non-Manifold breps have at least one edge that is shared among three or more faces.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsSolid',
        summary: 'Determines whether this brep is a solid, or a closed oriented manifold.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsSurface',
        summary: `Returns True if the Brep has a single face and that face is geometrically the same
     as the underlying surface.  I.e., the face has trivial trimming.
     In this case, the surface is the first face surface. The flag
     Brep.Faces[0].OrientationIsReversed records the correspondence between the surface's
     natural parametric orientation and the orientation of the Brep.trivial trimming here means that there is only one loop curve in the brep
     and that loop curve is the same as the underlying surface boundary.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'BrepLoopList Loops',
        summary: 'Gets the brep loop list accessor.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BrepSolidOrientation SolidOrientation',
        summary: 'Gets the solid orientation state of this Brep.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BrepSurfaceList Surfaces',
        summary: 'Parametric surfaces used by faces',
        since: 5.4,
        property: ['get']
      },
      {
        signature: 'BrepTrimList Trims',
        summary: 'Gets the brep trims list accessor.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'BrepVertexList Vertices',
        summary: 'Gets the brep vertices list accessor.',
        since: 5.5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Brep ChangeSeam(BrepFace face,int direction,double parameter,double tolerance)',
        summary: 'Change the seam of a closed trimmed surface.',
        since: 6.4,
        parameters: [
          {
            name: 'face',
            summary: 'A Brep face with a closed underlying surface.'
          },
          {
            name: 'direction',
            summary: 'The parameter direction (0 = U, 1 = V). The face\'s underlying surface must be closed in this direction.'
          },
          {
            name: 'parameter',
            summary: 'The parameter at which to place the seam.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance used to cut up surface.'
          }
        ],
        returns: 'A new Brep that has the same geoemtry as the face with a relocated seam if successful, or None on failure.'
      },
      {
        signature: 'static Brep CopyTrimCurves(BrepFace trimSource,Surface surfaceSource,double tolerance)',
        summary: 'Copy all trims from a Brep face onto a surface.',
        since: 5,
        parameters: [
          {
            name: 'trimSource',
            summary: 'Brep face which defines the trimming curves.'
          },
          {
            name: 'surfaceSource',
            summary: 'The surface to trim.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for rebuilding 3D trim curves.'
          }
        ],
        returns: 'A brep with the shape of surfaceSource and the trims of trimSource or None on failure.'
      },
      {
        signature: 'static Brep CreateBaseballSphere(Point3d center,double radius,double tolerance)',
        summary: 'Creates a brep representation of the sphere with two similar trimmed NURBS surfaces, and no singularities.',
        since: 6,
        parameters: [
          {
            name: 'center',
            summary: 'The center of the sphere.'
          },
          {
            name: 'radius',
            summary: 'The radius of the sphere.'
          },
          {
            name: 'tolerance',
            summary: `Used in computing 2d trimming curves. If >= 0.0, then the max of 
     ON_0.0001 * radius and RhinoMath.ZeroTolerance will be used.`
          }
        ],
        returns: 'A new brep, or None on error.'
      },
      {
        signature: 'static Curve CreateBlendShape(BrepFace face0,BrepEdge edge0,double t0,bool rev0,BlendContinuity continuity0,BrepFace face1,BrepEdge edge1,double t1,bool rev1,BlendContinuity continuity1)',
        summary: 'Makes a curve blend between points on two surface edges. The blend will be tangent to the surfaces and perpendicular to the edges.',
        since: 6,
        parameters: [
          {
            name: 'face0',
            summary: 'First face to blend from.'
          },
          {
            name: 'edge0',
            summary: 'First edge to blend from.'
          },
          {
            name: 't0',
            summary: 'Location on first edge for first end of blend curve.'
          },
          {
            name: 'rev0',
            summary: 'If false, edge0 will be used in its natural direction. If true, edge0 will be used in the reversed direction.'
          },
          {
            name: 'continuity0',
            summary: 'Continuity for the blend at the start.'
          },
          {
            name: 'face1',
            summary: 'Second face to blend from.'
          },
          {
            name: 'edge1',
            summary: 'Second edge to blend from.'
          },
          {
            name: 't1',
            summary: 'Location on second edge for second end of blend curve.'
          },
          {
            name: 'rev1',
            summary: 'If false, edge1 will be used in its natural direction. If true, edge1 will be used in the reversed direction.'
          },
          {
            name: 'continuity1',
            summary: '>Continuity for the blend at the end.'
          }
        ],
        returns: 'The blend curve on success. None on failure'
      },
      {
        signature: 'static Brep[] CreateBlendSurface(BrepFace face0,BrepEdge edge0,Interval domain0,bool rev0,BlendContinuity continuity0,BrepFace face1,BrepEdge edge1,Interval domain1,bool rev1,BlendContinuity continuity1)',
        summary: 'Makes a surface blend between two surface edges.',
        since: 6,
        parameters: [
          {
            name: 'face0',
            summary: 'First face to blend from.'
          },
          {
            name: 'edge0',
            summary: 'First edge to blend from.'
          },
          {
            name: 'domain0',
            summary: 'The domain of edge0 to use.'
          },
          {
            name: 'rev0',
            summary: 'If false, edge0 will be used in its natural direction. If true, edge0 will be used in the reversed direction.'
          },
          {
            name: 'continuity0',
            summary: 'Continuity for the blend at the start.'
          },
          {
            name: 'face1',
            summary: 'Second face to blend from.'
          },
          {
            name: 'edge1',
            summary: 'Second edge to blend from.'
          },
          {
            name: 'domain1',
            summary: 'The domain of edge1 to use.'
          },
          {
            name: 'rev1',
            summary: 'If false, edge1 will be used in its natural direction. If true, edge1 will be used in the reversed direction.'
          },
          {
            name: 'continuity1',
            summary: 'Continuity for the blend at the end.'
          }
        ],
        returns: 'Array of Breps if successful.'
      },
      {
        signature: 'static Brep[] CreateBooleanDifference(Brep firstBrep,Brep secondBrep,double tolerance)',
        summary: 'Compute the Solid Difference of two Breps.',
        since: 5,
        parameters: [
          {
            name: 'firstBrep',
            summary: 'First Brep for boolean difference.'
          },
          {
            name: 'secondBrep',
            summary: 'Second Brep for boolean difference.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for difference operation.'
          }
        ],
        returns: 'An array of Brep results or None on failure.'
      },
      {
        signature: 'static Brep[] CreateBooleanDifference(Brep firstBrep,Brep secondBrep,double tolerance,bool manifoldOnly)',
        summary: 'Compute the Solid Difference of two Breps.',
        since: 6,
        parameters: [
          {
            name: 'firstBrep',
            summary: 'First Brep for boolean difference.'
          },
          {
            name: 'secondBrep',
            summary: 'Second Brep for boolean difference.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for difference operation.'
          },
          {
            name: 'manifoldOnly',
            summary: 'If true, non-manifold input breps are ignored.'
          }
        ],
        returns: 'An array of Brep results or None on failure.'
      },
      {
        signature: 'static Brep[] CreateBooleanDifference(IEnumerable<Brep> firstSet,IEnumerable<Brep> secondSet,double tolerance)',
        summary: 'Compute the Solid Difference of two sets of Breps.',
        since: 5,
        parameters: [
          {
            name: 'firstSet',
            summary: 'First set of Breps (the set to subtract from).'
          },
          {
            name: 'secondSet',
            summary: 'Second set of Breps (the set to subtract).'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for difference operation.'
          }
        ],
        returns: 'An array of Brep results or None on failure.'
      },
      {
        signature: 'static Brep[] CreateBooleanDifference(IEnumerable<Brep> firstSet,IEnumerable<Brep> secondSet,double tolerance,bool manifoldOnly)',
        summary: 'Compute the Solid Difference of two sets of Breps.',
        since: 6,
        parameters: [
          {
            name: 'firstSet',
            summary: 'First set of Breps (the set to subtract from).'
          },
          {
            name: 'secondSet',
            summary: 'Second set of Breps (the set to subtract).'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for difference operation.'
          },
          {
            name: 'manifoldOnly',
            summary: 'If true, non-manifold input breps are ignored.'
          }
        ],
        returns: 'An array of Brep results or None on failure.'
      },
      {
        signature: 'static Brep[] CreateBooleanIntersection(Brep firstBrep,Brep secondBrep,double tolerance)',
        summary: 'Compute the Solid Intersection of two Breps.',
        since: 5,
        parameters: [
          {
            name: 'firstBrep',
            summary: 'First Brep for boolean intersection.'
          },
          {
            name: 'secondBrep',
            summary: 'Second Brep for boolean intersection.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for intersection operation.'
          }
        ],
        returns: 'An array of Brep results or None on failure.'
      },
      {
        signature: 'static Brep[] CreateBooleanIntersection(Brep firstBrep,Brep secondBrep,double tolerance,bool manifoldOnly)',
        summary: 'Compute the Solid Intersection of two Breps.',
        since: 6,
        parameters: [
          {
            name: 'firstBrep',
            summary: 'First Brep for boolean intersection.'
          },
          {
            name: 'secondBrep',
            summary: 'Second Brep for boolean intersection.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for intersection operation.'
          },
          {
            name: 'manifoldOnly',
            summary: 'If true, non-manifold input breps are ignored.'
          }
        ],
        returns: 'An array of Brep results or None on failure.'
      },
      {
        signature: 'static Brep[] CreateBooleanIntersection(IEnumerable<Brep> firstSet,IEnumerable<Brep> secondSet,double tolerance)',
        summary: 'Compute the Solid Intersection of two sets of Breps.',
        since: 5,
        parameters: [
          {
            name: 'firstSet',
            summary: 'First set of Breps.'
          },
          {
            name: 'secondSet',
            summary: 'Second set of Breps.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for intersection operation.'
          }
        ],
        returns: 'An array of Brep results or None on failure.'
      },
      {
        signature: 'static Brep[] CreateBooleanIntersection(IEnumerable<Brep> firstSet,IEnumerable<Brep> secondSet,double tolerance,bool manifoldOnly)',
        summary: 'Compute the Solid Intersection of two sets of Breps.',
        since: 6,
        parameters: [
          {
            name: 'firstSet',
            summary: 'First set of Breps.'
          },
          {
            name: 'secondSet',
            summary: 'Second set of Breps.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for intersection operation.'
          },
          {
            name: 'manifoldOnly',
            summary: 'If true, non-manifold input breps are ignored.'
          }
        ],
        returns: 'An array of Brep results or None on failure.'
      },
      {
        signature: 'static Brep[] CreateBooleanSplit(Brep firstBrep,Brep secondBrep,double tolerance)',
        summary: 'Splits shared areas of Breps and creates separate Breps from the shared and unshared parts.',
        since: 6.16,
        parameters: [
          {
            name: 'firstBrep',
            summary: 'The Brep to split.'
          },
          {
            name: 'secondBrep',
            summary: 'The cutting Brep.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for splitting operation. When in doubt, use the document\'s model absolute tolerance.'
          }
        ],
        returns: 'An array of Brep if successful, an empty array on failure.'
      },
      {
        signature: 'static Brep[] CreateBooleanSplit(IEnumerable<Brep> firstSet,IEnumerable<Brep> secondSet,double tolerance)',
        summary: 'Splits shared areas of Breps and creates separate Breps from the shared and unshared parts.',
        since: 6.16,
        parameters: [
          {
            name: 'firstSet',
            summary: 'The Breps to split.'
          },
          {
            name: 'secondSet',
            summary: 'The cutting Breps.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for splitting operation. When in doubt, use the document\'s model absolute tolerance.'
          }
        ],
        returns: 'An array of Brep if successful, an empty array on failure.'
      },
      {
        signature: 'static Brep[] CreateBooleanUnion(IEnumerable<Brep> breps,double tolerance)',
        summary: 'Compute the Boolean Union of a set of Breps.',
        since: 5,
        parameters: [
          {
            name: 'breps',
            summary: 'Breps to union.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for union operation.'
          }
        ],
        returns: 'An array of Brep results or None on failure.'
      },
      {
        signature: 'static Brep[] CreateBooleanUnion(IEnumerable<Brep> breps,double tolerance,bool manifoldOnly)',
        summary: 'Compute the Boolean Union of a set of Breps.',
        since: 6,
        parameters: [
          {
            name: 'breps',
            summary: 'Breps to union.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for union operation.'
          },
          {
            name: 'manifoldOnly',
            summary: 'If true, non-manifold input breps are ignored.'
          }
        ],
        returns: 'An array of Brep results or None on failure.'
      },
      {
        signature: 'static Brep[] CreateChamferSurface(BrepFace face0,Point2d uv0,double radius0,BrepFace face1,Point2d uv1,double radius1,bool trim,bool extend,double tolerance,Brep[] outBreps0,Brep[] outBreps1)',
        summary: 'Creates a ruled surface as a bevel between two input surface edges.',
        since: 6,
        parameters: [
          {
            name: 'face0',
            summary: 'First face to chamfer from.'
          },
          {
            name: 'uv0',
            summary: 'A parameter face0 at the side you want to keep after chamfering.'
          },
          {
            name: 'radius0',
            summary: 'The distance from the intersection of face0 to the edge of the chamfer.'
          },
          {
            name: 'face1',
            summary: 'Second face to chamfer from.'
          },
          {
            name: 'uv1',
            summary: 'A parameter face1 at the side you want to keep after chamfering.'
          },
          {
            name: 'radius1',
            summary: 'The distance from the intersection of face1 to the edge of the chamfer.'
          },
          {
            name: 'trim',
            summary: 'If true, the input faces will be trimmed, if false, the input faces will be split.'
          },
          {
            name: 'extend',
            summary: 'If true, then when one input surface is longer than the other, the chamfer surface is extended to the input surface edges.'
          },
          {
            name: 'tolerance',
            summary: 'The tolerance. In in doubt, the the document\'s model absolute tolerance.'
          },
          {
            name: 'outBreps0',
            summary: 'The trim or split results of the Brep owned by face0.'
          },
          {
            name: 'outBreps1',
            summary: 'The trim or split results of the Brep owned by face1.'
          }
        ],
        returns: 'Array of Breps if successful.'
      },
      {
        signature: 'static Brep[] CreateChamferSurface(BrepFace face0,Point2d uv0,double radius0,BrepFace face1,Point2d uv1,double radius1,bool extend,double tolerance)',
        summary: 'Creates a ruled surface as a bevel between two input surface edges.',
        since: 6,
        parameters: [
          {
            name: 'face0',
            summary: 'First face to chamfer from.'
          },
          {
            name: 'uv0',
            summary: 'A parameter face0 at the side you want to keep after chamfering.'
          },
          {
            name: 'radius0',
            summary: 'The distance from the intersection of face0 to the edge of the chamfer.'
          },
          {
            name: 'face1',
            summary: 'Second face to chamfer from.'
          },
          {
            name: 'uv1',
            summary: 'A parameter face1 at the side you want to keep after chamfering.'
          },
          {
            name: 'radius1',
            summary: 'The distance from the intersection of face1 to the edge of the chamfer.'
          },
          {
            name: 'extend',
            summary: 'If true, then when one input surface is longer than the other, the chamfer surface is extended to the input surface edges.'
          },
          {
            name: 'tolerance',
            summary: 'The tolerance. In in doubt, the the document\'s model absolute tolerance.'
          }
        ],
        returns: 'Array of Breps if successful.'
      },
      {
        signature: 'static Curve[] CreateContourCurves(Brep brepToContour,Plane sectionPlane)',
        summary: 'Constructs the contour curves for a brep, using a slicing plane.',
        since: 5,
        parameters: [
          {
            name: 'brepToContour',
            summary: 'A brep or polysurface.'
          },
          {
            name: 'sectionPlane',
            summary: 'A plane.'
          }
        ],
        returns: 'An array with intersected curves. This array can be empty.'
      },
      {
        signature: 'static Curve[] CreateContourCurves(Brep brepToContour,Point3d contourStart,Point3d contourEnd,double interval)',
        summary: 'Constructs the contour curves for a brep at a specified interval.',
        since: 5,
        parameters: [
          {
            name: 'brepToContour',
            summary: 'A brep or polysurface.'
          },
          {
            name: 'contourStart',
            summary: 'A point to start.'
          },
          {
            name: 'contourEnd',
            summary: 'A point to use as the end.'
          },
          {
            name: 'interval',
            summary: 'The interaxial offset in world units.'
          }
        ],
        returns: 'An array with intersected curves. This array can be empty.'
      },
      {
        signature: 'static Mesh[] CreateCurvatureAnalysisMesh(Brep brep,CurvatureAnalysisSettingsState state)',
        summary: `Create an array of analysis meshes for the brep using the specified settings.
     Meshes aren't set on the brep.`,
        since: 6,
        parameters: [
          {
            name: 'brep',
            summary: ''
          },
          {
            name: 'state',
            summary: 'CurvatureAnalysisSettingsState'
          }
        ],
        returns: 'True if meshes were created'
      },
      {
        signature: 'static Brep[] CreateDevelopableLoft(Curve crv0,Curve crv1,bool reverse0,bool reverse1,int density)',
        summary: 'Creates a single developable surface between two curves.',
        since: 6.1,
        parameters: [
          {
            name: 'crv0',
            summary: 'The first rail curve.'
          },
          {
            name: 'crv1',
            summary: 'The second rail curve.'
          },
          {
            name: 'reverse0',
            summary: 'Reverse the first rail curve.'
          },
          {
            name: 'reverse1',
            summary: 'Reverse the second rail curve'
          },
          {
            name: 'density',
            summary: 'The number of rulings across the surface.'
          }
        ],
        returns: 'The output Breps if successful, otherwise an empty array.'
      },
      {
        signature: 'static Brep[] CreateDevelopableLoft(NurbsCurve rail0,NurbsCurve rail1,IEnumerable<Point2d> fixedRulings)',
        summary: 'Creates a single developable surface between two curves.',
        since: 6.1,
        parameters: [
          {
            name: 'rail0',
            summary: 'The first rail curve.'
          },
          {
            name: 'rail1',
            summary: 'The second rail curve.'
          },
          {
            name: 'fixedRulings',
            summary: `Rulings define lines across the surface that define the straight sections on the developable surface,
     where rulings[i].X = parameter on first rail curve, and rulings[i].Y = parameter on second rail curve.
     Note, rulings will be automatically adjusted to minimum twist.`
          }
        ],
        returns: 'The output Breps if successful, otherwise an empty array.'
      },
      {
        signature: 'static Brep CreateEdgeSurface(IEnumerable<Curve> curves)',
        summary: 'Constructs a coons patch from 2, 3, or 4 curves.',
        since: 5,
        parameters: [
          {
            name: 'curves',
            summary: 'A list, an array or any enumerable set of curves.'
          }
        ],
        returns: 'resulting brep or None on failure.'
      },
      {
        signature: 'static Brep[] CreateFilletEdges(Brep brep,IEnumerable<int> edgeIndices,IEnumerable<double> startRadii,IEnumerable<double> endRadii,BlendType blendType,RailType railType,double tolerance)',
        summary: 'Fillets, chamfers, or blends the edges of a brep.',
        since: 6,
        parameters: [
          {
            name: 'brep',
            summary: 'The brep to fillet, chamfer, or blend edges.'
          },
          {
            name: 'edgeIndices',
            summary: 'An array of one or more edge indices where the fillet, chamfer, or blend will occur.'
          },
          {
            name: 'startRadii',
            summary: 'An array of starting fillet, chamfer, or blend radaii, one for each edge index.'
          },
          {
            name: 'endRadii',
            summary: 'An array of ending fillet, chamfer, or blend radaii, one for each edge index.'
          },
          {
            name: 'blendType',
            summary: 'The blend type.'
          },
          {
            name: 'railType',
            summary: 'The rail type.'
          },
          {
            name: 'tolerance',
            summary: 'The tolerance to be used to perform calculations.'
          }
        ],
        returns: 'Array of Breps if successful.'
      },
      {
        signature: 'static Brep[] CreateFilletSurface(BrepFace face0,Point2d uv0,BrepFace face1,Point2d uv1,double radius,bool trim,bool extend,double tolerance,Brep[] outBreps0,Brep[] outBreps1)',
        summary: 'Creates a constant-radius round surface between two surfaces.',
        since: 6,
        parameters: [
          {
            name: 'face0',
            summary: 'First face to fillet from.'
          },
          {
            name: 'uv0',
            summary: 'A parameter face0 at the side you want to keep after filleting.'
          },
          {
            name: 'face1',
            summary: 'Second face to fillet from.'
          },
          {
            name: 'uv1',
            summary: 'A parameter face1 at the side you want to keep after filleting.'
          },
          {
            name: 'radius',
            summary: 'The fillet radius.'
          },
          {
            name: 'trim',
            summary: 'If true, the input faces will be trimmed, if false, the input faces will be split.'
          },
          {
            name: 'extend',
            summary: 'If true, then when one input surface is longer than the other, the fillet surface is extended to the input surface edges.'
          },
          {
            name: 'tolerance',
            summary: 'The tolerance. In in doubt, the the document\'s model absolute tolerance.'
          },
          {
            name: 'outBreps0',
            summary: 'The trim or split results of the Brep owned by face0.'
          },
          {
            name: 'outBreps1',
            summary: 'The trim or split results of the Brep owned by face1.'
          }
        ],
        returns: 'Array of Breps if successful.'
      },
      {
        signature: 'static Brep[] CreateFilletSurface(BrepFace face0,Point2d uv0,BrepFace face1,Point2d uv1,double radius,bool extend,double tolerance)',
        summary: 'Creates a constant-radius round surface between two surfaces.',
        since: 6,
        parameters: [
          {
            name: 'face0',
            summary: 'First face to fillet from.'
          },
          {
            name: 'uv0',
            summary: 'A parameter face0 at the side you want to keep after filleting.'
          },
          {
            name: 'face1',
            summary: 'Second face to fillet from.'
          },
          {
            name: 'uv1',
            summary: 'A parameter face1 at the side you want to keep after filleting.'
          },
          {
            name: 'radius',
            summary: 'The fillet radius.'
          },
          {
            name: 'extend',
            summary: 'If true, then when one input surface is longer than the other, the fillet surface is extended to the input surface edges.'
          },
          {
            name: 'tolerance',
            summary: 'The tolerance. In in doubt, the the document\'s model absolute tolerance.'
          }
        ],
        returns: 'Array of Breps if successful.'
      },
      {
        signature: 'static Brep CreateFromBox(BoundingBox box)',
        summary: 'Constructs new brep that matches a bounding box.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'A box to use for creation.'
          }
        ],
        returns: 'A new brep; or None on failure.'
      },
      {
        signature: 'static Brep CreateFromBox(Box box)',
        summary: 'Constructs new brep that matches an aligned box.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to match.'
          }
        ],
        returns: 'A Brep with 6 faces that is similar to the Box.'
      },
      {
        signature: 'static Brep CreateFromBox(IEnumerable<Point3d> corners)',
        summary: 'Constructs new brep from 8 corner points.',
        since: 5,
        parameters: [
          {
            name: 'corners',
            summary: `8 points defining the box corners arranged as the vN labels indicate.
     v7_______e6____v6|\\             |\\| e7           | e5|  \\ ______e4_____\\e11 v4         |   v5|   |        e10   ||   |          |   |v3--|---e2----v2   e9 \\  e8          \\  | e3 |            e1|   \\|             \\|    v0_____e0______v1`
          }
        ],
        returns: 'A new brep, or None on error.'
      },
      {
        signature: 'static Brep CreateFromCone(Cone cone,bool capBottom)',
        summary: `Constructs a Brep representation of the cone with a single
     face for the cone, an edge along the cone seam, 
     and vertices at the base and apex ends of this seam edge.
     The optional cap is a single face with one circular edge 
     starting and ending at the base vertex.`,
        since: 5,
        parameters: [
          {
            name: 'cone',
            summary: 'A cone value.'
          },
          {
            name: 'capBottom',
            summary: 'if True the base of the cone should be capped.'
          }
        ],
        returns: 'A Brep if successful, None on error.'
      },
      {
        signature: 'static Brep CreateFromCornerPoints(Point3d corner1,Point3d corner2,Point3d corner3,double tolerance)',
        summary: 'Makes a brep with one face.',
        since: 5,
        parameters: [
          {
            name: 'corner1',
            summary: 'A first corner.'
          },
          {
            name: 'corner2',
            summary: 'A second corner.'
          },
          {
            name: 'corner3',
            summary: 'A third corner.'
          },
          {
            name: 'tolerance',
            summary: 'Minimum edge length without collapsing to a singularity.'
          }
        ],
        returns: 'A boundary representation, or None on error.'
      },
      {
        signature: 'static Brep CreateFromCornerPoints(Point3d corner1,Point3d corner2,Point3d corner3,Point3d corner4,double tolerance)',
        summary: 'make a Brep with one face.',
        since: 5,
        parameters: [
          {
            name: 'corner1',
            summary: 'A first corner.'
          },
          {
            name: 'corner2',
            summary: 'A second corner.'
          },
          {
            name: 'corner3',
            summary: 'A third corner.'
          },
          {
            name: 'corner4',
            summary: 'A fourth corner.'
          },
          {
            name: 'tolerance',
            summary: 'Minimum edge length allowed before collapsing the side into a singularity.'
          }
        ],
        returns: 'A boundary representation, or None on error.'
      },
      {
        signature: 'static Brep CreateFromCylinder(Cylinder cylinder,bool capBottom,bool capTop)',
        summary: 'Constructs a Brep definition of a cylinder.',
        since: 5,
        parameters: [
          {
            name: 'cylinder',
            summary: 'cylinder.IsFinite() must be true.'
          },
          {
            name: 'capBottom',
            summary: 'if True end at cylinder.m_height[0] should be capped.'
          },
          {
            name: 'capTop',
            summary: 'if True end at cylinder.m_height[1] should be capped.'
          }
        ],
        returns: `A Brep representation of the cylinder with a single face for the cylinder,
     an edge along the cylinder seam, and vertices at the bottom and top ends of this
     seam edge. The optional bottom/top caps are single faces with one circular edge
     starting and ending at the bottom/top vertex.`
      },
      {
        signature: 'static Brep CreateFromJoinedEdges(Brep brep0,int edgeIndex0,Brep brep1,int edgeIndex1,double joinTolerance)',
        summary: 'Joins two naked edges, or edges that are coincident or close together, from two Breps.',
        since: 6,
        parameters: [
          {
            name: 'brep0',
            summary: 'The first Brep.'
          },
          {
            name: 'edgeIndex0',
            summary: 'The edge index on the first Brep.'
          },
          {
            name: 'brep1',
            summary: 'The second Brep.'
          },
          {
            name: 'edgeIndex1',
            summary: 'The edge index on the second Brep.'
          },
          {
            name: 'joinTolerance',
            summary: 'The join tolerance.'
          }
        ],
        returns: 'The resulting Brep if successful, None on failure.'
      },
      {
        signature: 'static Brep[] CreateFromLoft(IEnumerable<Curve> curves,Point3d start,Point3d end,LoftType loftType,bool closed)',
        summary: 'Constructs one or more Breps by lofting through a set of curves.',
        since: 5,
        parameters: [
          {
            name: 'curves',
            summary: `The curves to loft through. This function will not perform any curve sorting. You must pass in
     curves in the order you want them lofted. This function will not adjust the directions of open
     curves. Use Curve.DoDirectionsMatch and Curve.Reverse to adjust the directions of open curves.
     This function will not adjust the seams of closed curves. Use Curve.ChangeClosedCurveSeam to
     adjust the seam of closed curves.`
          },
          {
            name: 'start',
            summary: 'Optional starting point of loft. Use Point3d.Unset if you do not want to include a start point.'
          },
          {
            name: 'end',
            summary: 'Optional ending point of loft. Use Point3d.Unset if you do not want to include an end point.'
          },
          {
            name: 'loftType',
            summary: 'type of loft to perform.'
          },
          {
            name: 'closed',
            summary: 'True if the last curve in this loft should be connected back to the first one.'
          }
        ],
        returns: `Constructs a closed surface, continuing the surface past the last curve around to the
     first curve. Available when you have selected three shape curves.`
      },
      {
        signature: 'static Brep[] CreateFromLoftRebuild(IEnumerable<Curve> curves,Point3d start,Point3d end,LoftType loftType,bool closed,int rebuildPointCount)',
        summary: `Constructs one or more Breps by lofting through a set of curves. Input for the loft is simplified by
     rebuilding to a specified number of control points.`,
        since: 5,
        parameters: [
          {
            name: 'curves',
            summary: `The curves to loft through. This function will not perform any curve sorting. You must pass in
     curves in the order you want them lofted. This function will not adjust the directions of open
     curves. Use Curve.DoDirectionsMatch and Curve.Reverse to adjust the directions of open curves.
     This function will not adjust the seams of closed curves. Use Curve.ChangeClosedCurveSeam to
     adjust the seam of closed curves.`
          },
          {
            name: 'start',
            summary: 'Optional starting point of loft. Use Point3d.Unset if you do not want to include a start point.'
          },
          {
            name: 'end',
            summary: 'Optional ending point of lost. Use Point3d.Unset if you do not want to include an end point.'
          },
          {
            name: 'loftType',
            summary: 'type of loft to perform.'
          },
          {
            name: 'closed',
            summary: 'True if the last curve in this loft should be connected back to the first one.'
          },
          {
            name: 'rebuildPointCount',
            summary: 'A number of points to use while rebuilding the curves. 0 leaves turns this parameter off.'
          }
        ],
        returns: `Constructs a closed surface, continuing the surface past the last curve around to the
     first curve. Available when you have selected three shape curves.`
      },
      {
        signature: 'static Brep[] CreateFromLoftRefit(IEnumerable<Curve> curves,Point3d start,Point3d end,LoftType loftType,bool closed,double refitTolerance)',
        summary: `Constructs one or more Breps by lofting through a set of curves. Input for the loft is simplified by
     refitting to a specified tolerance.`,
        since: 5,
        parameters: [
          {
            name: 'curves',
            summary: `The curves to loft through. This function will not perform any curve sorting. You must pass in
     curves in the order you want them lofted. This function will not adjust the directions of open
     curves. Use Curve.DoDirectionsMatch and Curve.Reverse to adjust the directions of open curves.
     This function will not adjust the seams of closed curves. Use Curve.ChangeClosedCurveSeam to
     adjust the seam of closed curves.`
          },
          {
            name: 'start',
            summary: 'Optional starting point of loft. Use Point3d.Unset if you do not want to include a start point.'
          },
          {
            name: 'end',
            summary: 'Optional ending point of lost. Use Point3d.Unset if you do not want to include an end point.'
          },
          {
            name: 'loftType',
            summary: 'type of loft to perform.'
          },
          {
            name: 'closed',
            summary: 'True if the last curve in this loft should be connected back to the first one.'
          },
          {
            name: 'refitTolerance',
            summary: 'A distance to use in refitting, or 0 if you want to turn this parameter off.'
          }
        ],
        returns: `Constructs a closed surface, continuing the surface past the last curve around to the
     first curve. Available when you have selected three shape curves.`
      },
      {
        signature: 'static Brep CreateFromMesh(Mesh mesh,bool trimmedTriangles)',
        summary: 'Create a brep representation of a mesh',
        since: 5.1,
        parameters: [
          {
            name: 'mesh',
            summary: ''
          },
          {
            name: 'trimmedTriangles',
            summary: `if true, triangles in the mesh will be represented by trimmed planes in
     the brep. If false, triangles in the mesh will be represented by
     untrimmed singular bilinear NURBS surfaces in the brep.`
          }
        ]
      },
      {
        signature: 'static Brep CreateFromOffsetFace(BrepFace face,double offsetDistance,double offsetTolerance,bool bothSides,bool createSolid)',
        summary: 'Offsets a face including trim information to create a new brep.',
        since: 5,
        parameters: [
          {
            name: 'face',
            summary: 'the face to offset.'
          },
          {
            name: 'offsetDistance',
            summary: 'An offset distance.'
          },
          {
            name: 'offsetTolerance',
            summary: 'Use 0.0 to make a loose offset. Otherwise, the document\'s absolute tolerance is usually sufficient.'
          },
          {
            name: 'bothSides',
            summary: 'When true, offset to both sides of the input face.'
          },
          {
            name: 'createSolid',
            summary: 'When true, make a solid object.'
          }
        ],
        returns: `A new brep if successful. The brep can be disjoint if bothSides is True and createSolid is false,
     or if createSolid is True and connecting the offsets with side surfaces fails.
     None if unsuccessful.`
      },
      {
        signature: 'static Brep CreateFromRevSurface(RevSurface surface,bool capStart,bool capEnd)',
        summary: 'Constructs a brep form of a surface of revolution.',
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'The surface of revolution.'
          },
          {
            name: 'capStart',
            summary: `if true, the start of the revolute is not on the axis of revolution,
     and the surface of revolution is closed, then a circular cap will be
     added to close of the hole at the start of the revolute.`
          },
          {
            name: 'capEnd',
            summary: `if true, the end of the revolute is not on the axis of revolution,
     and the surface of revolution is closed, then a circular cap will be
     added to close of the hole at the end of the revolute.`
          }
        ],
        returns: 'A Brep if successful, None on error.'
      },
      {
        signature: 'static Brep CreateFromSphere(Sphere sphere)',
        summary: 'Constructs a Brep definition of a sphere.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'The input sphere provides the orienting plane and radius.'
          }
        ],
        returns: 'A Brep if successful, None on error.'
      },
      {
        signature: 'static Brep CreateFromSurface(Surface surface)',
        summary: `Constructs a Brep from a surface. The resulting Brep has an outer boundary made
     from four trims. The trims are ordered so that they run along the south, east,
     north, and then west side of the surface's parameter space.`,
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'A surface to convert.'
          }
        ],
        returns: 'Resulting brep or None on failure.'
      },
      {
        signature: 'static Brep[] CreateFromSweep(Curve rail,Curve shape,bool closed,double tolerance)',
        summary: `Sweep1 function that fits a surface through a profile curve that define the surface cross-sections
     and one curve that defines a surface edge.`,
        since: 5,
        parameters: [
          {
            name: 'rail',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'shape',
            summary: 'Shape curve'
          },
          {
            name: 'closed',
            summary: 'Only matters if shape is closed'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance for fitting surface and rails'
          }
        ],
        returns: 'Array of Brep sweep results'
      },
      {
        signature: 'static Brep[] CreateFromSweep(Curve rail1,Curve rail2,Curve shape,bool closed,double tolerance)',
        summary: `General 2 rail sweep. If you are not producing the sweep results that you are after, then
     use the SweepTwoRail class with options to generate the swept geometry.`,
        since: 5,
        parameters: [
          {
            name: 'rail1',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'rail2',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'shape',
            summary: 'Shape curve'
          },
          {
            name: 'closed',
            summary: 'Only matters if shape is closed'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance for fitting surface and rails'
          }
        ],
        returns: 'Array of Brep sweep results'
      },
      {
        signature: 'static Brep[] CreateFromSweep(Curve rail1,Curve rail2,IEnumerable<Curve> shapes,bool closed,double tolerance)',
        summary: `General 2 rail sweep. If you are not producing the sweep results that you are after, then
     use the SweepTwoRail class with options to generate the swept geometry.`,
        since: 5,
        parameters: [
          {
            name: 'rail1',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'rail2',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'shapes',
            summary: 'Shape curves'
          },
          {
            name: 'closed',
            summary: 'Only matters if shapes are closed'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance for fitting surface and rails'
          }
        ],
        returns: 'Array of Brep sweep results'
      },
      {
        signature: 'static Brep[] CreateFromSweep(Curve rail1,Curve rail2,IEnumerable<Curve> shapes,Point3d start,Point3d end,bool closed,double tolerance,SweepRebuild rebuild,int rebuildPointCount,double refitTolerance,bool preserveHeight)',
        summary: `Sweep2 function that fits a surface through profile curves that define the surface cross-sections
     and two curves that defines a surface edge.`,
        since: 6.16,
        parameters: [
          {
            name: 'rail1',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'rail2',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'shapes',
            summary: 'Shape curves'
          },
          {
            name: 'start',
            summary: 'Optional starting point of sweep. Use Point3d.Unset if you do not want to include a start point.'
          },
          {
            name: 'end',
            summary: 'Optional ending point of sweep. Use Point3d.Unset if you do not want to include an end point.'
          },
          {
            name: 'closed',
            summary: 'Only matters if shapes are closed.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance for fitting surface and rails.'
          },
          {
            name: 'rebuild',
            summary: 'The rebuild style.'
          },
          {
            name: 'rebuildPointCount',
            summary: 'If rebuild == SweepRebuild.Rebuild, the number of points. Otherwise specify 0.'
          },
          {
            name: 'refitTolerance',
            summary: 'If rebuild == SweepRebuild.Refit, the refit tolerenace. Otherwise, specify 0.0'
          },
          {
            name: 'preserveHeight',
            summary: 'Removes the association between the height scaling from the width scaling'
          }
        ],
        returns: 'Array of Brep sweep results'
      },
      {
        signature: 'static Brep[] CreateFromSweep(Curve rail,IEnumerable<Curve> shapes,bool closed,double tolerance)',
        summary: `Sweep1 function that fits a surface through profile curves that define the surface cross-sections
     and one curve that defines a surface edge.`,
        since: 5,
        parameters: [
          {
            name: 'rail',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'shapes',
            summary: 'Shape curves'
          },
          {
            name: 'closed',
            summary: 'Only matters if shapes are closed'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance for fitting surface and rails'
          }
        ],
        returns: 'Array of Brep sweep results'
      },
      {
        signature: 'static Brep[] CreateFromSweepInParts(Curve rail1,Curve rail2,IEnumerable<Curve> shapes,IEnumerable<Point2d> rail_params,bool closed,double tolerance)',
        summary: 'Makes a 2 rail sweep. Like CreateFromSweep but the result is split where parameterization along a rail changes abruptly.',
        since: 6,
        parameters: [
          {
            name: 'rail1',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'rail2',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'shapes',
            summary: 'Shape curves'
          },
          {
            name: 'rail_params',
            summary: 'Shape parameters'
          },
          {
            name: 'closed',
            summary: 'Only matters if shapes are closed'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance for fitting surface and rails'
          }
        ],
        returns: 'Array of Brep sweep results'
      },
      {
        signature: 'static Brep[] CreateFromSweepSegmented(Curve rail,Curve shape,bool closed,double tolerance)',
        summary: `Sweep1 function that fits a surface through a profile curve that define the surface cross-sections
     and one curve that defines a surface edge. The Segmented version breaks the rail at curvature kinks
     and sweeps each piece separately, then put the results together into a Brep.`,
        since: 6.14,
        parameters: [
          {
            name: 'rail',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'shape',
            summary: 'Shape curve'
          },
          {
            name: 'closed',
            summary: 'Only matters if shape is closed'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance for fitting surface and rails'
          }
        ],
        returns: 'Array of Brep sweep results'
      },
      {
        signature: 'static Brep[] CreateFromSweepSegmented(Curve rail,IEnumerable<Curve> shapes,bool closed,double tolerance)',
        summary: `Sweep1 function that fits a surface through a series of profile curves that define the surface cross-sections
     and one curve that defines a surface edge. The Segmented version breaks the rail at curvature kinks
     and sweeps each piece separately, then put the results together into a Brep.`,
        since: 6.14,
        parameters: [
          {
            name: 'rail',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'shapes',
            summary: 'Shape curves'
          },
          {
            name: 'closed',
            summary: 'Only matters if shapes are closed'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance for fitting surface and rails'
          }
        ],
        returns: 'Array of Brep sweep results'
      },
      {
        signature: 'static Brep[] CreateFromTaperedExtrude(Curve curveToExtrude,double distance,Vector3d direction,Point3d basePoint,double draftAngleRadians,ExtrudeCornerType cornerType)',
        summary: 'Extrude a curve to a taper making a brep (potentially more than 1)',
        since: 5.1,
        parameters: [
          {
            name: 'curveToExtrude',
            summary: 'the curve to extrude'
          },
          {
            name: 'distance',
            summary: 'the distance to extrude'
          },
          {
            name: 'direction',
            summary: 'the direction of the extrusion'
          },
          {
            name: 'basePoint',
            summary: 'the basepoint of the extrusion'
          },
          {
            name: 'draftAngleRadians',
            summary: 'angle of the extrusion'
          },
          {
            name: 'cornerType',
            summary: ''
          }
        ],
        returns: 'array of breps on success'
      },
      {
        signature: 'static Brep[] CreateFromTaperedExtrude(Curve curveToExtrude,double distance,Vector3d direction,Point3d basePoint,double draftAngleRadians,ExtrudeCornerType cornerType,double tolerance,double angleToleranceRadians)',
        summary: 'Extrude a curve to a taper making a brep (potentially more than 1)',
        since: 6,
        parameters: [
          {
            name: 'curveToExtrude',
            summary: 'the curve to extrude'
          },
          {
            name: 'distance',
            summary: 'the distance to extrude'
          },
          {
            name: 'direction',
            summary: 'the direction of the extrusion'
          },
          {
            name: 'basePoint',
            summary: 'the basepoint of the extrusion'
          },
          {
            name: 'draftAngleRadians',
            summary: 'angle of the extrusion'
          },
          {
            name: 'cornerType',
            summary: ''
          },
          {
            name: 'tolerance',
            summary: 'tolerance to use for the extrusion'
          },
          {
            name: 'angleToleranceRadians',
            summary: 'angle tolerance to use for the extrusion'
          }
        ],
        returns: 'array of breps on success'
      },
      {
        signature: 'static Brep[] CreateFromTaperedExtrudeWithRef(Curve curve,Vector3d direction,double distance,double draftAngle,Plane plane,double tolerance)',
        summary: 'Creates one or more Breps by extruding a curve a distance along an axis with draft angle.',
        since: 6.14,
        parameters: [
          {
            name: 'curve',
            summary: 'The curve to extrude.'
          },
          {
            name: 'direction',
            summary: 'The extrusion direction.'
          },
          {
            name: 'distance',
            summary: 'The extrusion distance.'
          },
          {
            name: 'draftAngle',
            summary: 'The extrusion draft angle in radians.'
          },
          {
            name: 'plane',
            summary: `The end of the extrusion will be parallel to this plane, and "distance" from the plane's origin.
     The plane's origin is generally be a point on the curve. For planar curves, a natural choice for the
     plane's normal direction will be the normal direction of the curve's plane. In any case, 
     plane.Normal = direction may make sense.`
          },
          {
            name: 'tolerance',
            summary: 'The intersecting and trimming tolerance.'
          }
        ],
        returns: 'An array of Breps if successful.'
      },
      {
        signature: 'static Brep[] CreateOffsetBrep(Brep brep,double distance,bool solid,bool extend,double tolerance,Brep[] outBlends,Brep[] outWalls)',
        summary: 'Offsets a Brep.',
        since: 6,
        parameters: [
          {
            name: 'brep',
            summary: 'The Brep to offset.'
          },
          {
            name: 'distance',
            summary: `The distance to offset. This is a signed distance value with respect to
     face normals and flipped faces.`
          },
          {
            name: 'solid',
            summary: `If true, then the function makes a closed solid from the input and offset
     surfaces by lofting a ruled surface between all of the matching edges.`
          },
          {
            name: 'extend',
            summary: `If true, then the function maintains the sharp corners when the original
     surfaces have sharps corner. If False, then the function creates fillets
     at sharp corners in the original surfaces.`
          },
          {
            name: 'tolerance',
            summary: 'The offset tolerance.'
          },
          {
            name: 'outBlends',
            summary: 'The results of the calculation.'
          },
          {
            name: 'outWalls',
            summary: 'The results of the calculation.'
          }
        ],
        returns: `Array of Breps if successful. If the function succeeds in offsetting, a
     single Brep will be returned. Otherwise, the array will contain the 
     offset surfaces, outBlends will contain the set of blends used to fill
     in gaps (if extend is false), and outWalls will contain the set of wall
     surfaces that was supposed to join the offset to the original (if solid
     is true).`
      },
      {
        signature: 'static Brep CreatePatch(IEnumerable<GeometryBase> geometry,int uSpans,int vSpans,double tolerance)',
        summary: `Constructs a brep patch.
     This is the simple version of fit that uses a plane with u x v spans.
     It makes a plane by fitting to the points from the input geometry to use as the starting surface.
     The surface has the specified u and v span count.`,
        since: 5,
        parameters: [
          {
            name: 'geometry',
            summary: `A combination of Curve, brep trims,
     Point, PointCloud or Mesh.
     Curves and trims are sampled to get points. Trims are sampled for
     points and normals.`
          },
          {
            name: 'uSpans',
            summary: 'The number of spans in the U direction.'
          },
          {
            name: 'vSpans',
            summary: 'The number of spans in the V direction.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance used by input analysis functions for loop finding, trimming, etc.'
          }
        ],
        returns: 'A brep fit through input on success, or None on error.'
      },
      {
        signature: 'static Brep CreatePatch(IEnumerable<GeometryBase> geometry,Surface startingSurface,double tolerance)',
        summary: `Constructs a brep patch.
     This is the simple version of fit that uses a specified starting surface.`,
        since: 5,
        parameters: [
          {
            name: 'geometry',
            summary: `Combination of Curves, BrepTrims, Points, PointClouds or Meshes.
     Curves and trims are sampled to get points. Trims are sampled for
     points and normals.`
          },
          {
            name: 'startingSurface',
            summary: 'A starting surface (can be null).'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance used by input analysis functions for loop finding, trimming, etc.'
          }
        ],
        returns: 'Brep fit through input on success, or None on error.'
      },
      {
        signature: 'static Brep CreatePatch(IEnumerable<GeometryBase> geometry,Surface startingSurface,int uSpans,int vSpans,bool trim,bool tangency,double pointSpacing,double flexibility,double surfacePull,bool[] fixEdges,double tolerance)',
        summary: 'Constructs a brep patch using all controls',
        since: 5,
        parameters: [
          {
            name: 'geometry',
            summary: `A combination of Curve, brep trims,
     Point, PointCloud or Mesh.
     Curves and trims are sampled to get points. Trims are sampled for
     points and normals.`
          },
          {
            name: 'startingSurface',
            summary: 'A starting surface (can be null).'
          },
          {
            name: 'uSpans',
            summary: 'Number of surface spans used when a plane is fit through points to start in the U direction.'
          },
          {
            name: 'vSpans',
            summary: 'Number of surface spans used when a plane is fit through points to start in the U direction.'
          },
          {
            name: 'trim',
            summary: 'If true, try to find an outer loop from among the input curves and trim the result to that loop'
          },
          {
            name: 'tangency',
            summary: `If true, try to find brep trims in the outer loop of curves and try to
     fit to the normal direction of the trim's surface at those locations.`
          },
          {
            name: 'pointSpacing',
            summary: 'Basic distance between points sampled from input curves.'
          },
          {
            name: 'flexibility',
            summary: `Determines the behavior of the surface in areas where its not otherwise
     controlled by the input.  Lower numbers make the surface behave more
     like a stiff material; higher, less like a stiff material.  That is,
     each span is made to more closely match the spans adjacent to it if there
     is no input geometry mapping to that area of the surface when the
     flexibility value is low.  The scale is logrithmic. Numbers around 0.001
     or 0.1 make the patch pretty stiff and numbers around 10 or 100 make the
     surface flexible.`
          },
          {
            name: 'surfacePull',
            summary: `Tends to keep the result surface where it was before the fit in areas where
     there is on influence from the input geometry`
          },
          {
            name: 'fixEdges',
            summary: `Array of four elements. Flags to keep the edges of a starting (untrimmed)
     surface in place while fitting the interior of the surface.  Order of
     flags is left, bottom, right, top`
          },
          {
            name: 'tolerance',
            summary: 'Tolerance used by input analysis functions for loop finding, trimming, etc.'
          }
        ],
        returns: 'A brep fit through input on success, or None on error.'
      },
      {
        signature: 'static Brep[] CreatePipe(Curve rail,double radius,bool localBlending,PipeCapMode cap,bool fitRail,double absoluteTolerance,double angleToleranceRadians)',
        summary: 'Creates a single walled pipe',
        since: 5,
        parameters: [
          {
            name: 'rail',
            summary: 'the path curve for the pipe'
          },
          {
            name: 'radius',
            summary: 'radius of the pipe'
          },
          {
            name: 'localBlending',
            summary: `If True, Local (pipe radius stays constant at the ends and changes more rapidly in the middle) is applied.
     If False, Global (radius is linearly blended from one end to the other, creating pipes that taper from one radius to the other) is applied`
          },
          {
            name: 'cap',
            summary: 'end cap mode'
          },
          {
            name: 'fitRail',
            summary: `If the curve is a polycurve of lines and arcs, the curve is fit and a single surface is created;
     otherwise the result is a polysurface with joined surfaces created from the polycurve segments.`
          },
          {
            name: 'absoluteTolerance',
            summary: 'The sweeping and fitting tolerance. If you are unsure what to use, then use the document\'s absolute tolerance'
          },
          {
            name: 'angleToleranceRadians',
            summary: 'The angle tolerance. If you are unsure what to use, then either use the document\'s angle tolerance in radians'
          }
        ],
        returns: 'Array of created pipes on success'
      },
      {
        signature: 'static Brep[] CreatePipe(Curve rail,IEnumerable<double> railRadiiParameters,IEnumerable<double> radii,bool localBlending,PipeCapMode cap,bool fitRail,double absoluteTolerance,double angleToleranceRadians)',
        summary: 'Creates a single walled pipe',
        since: 5,
        parameters: [
          {
            name: 'rail',
            summary: 'the path curve for the pipe'
          },
          {
            name: 'railRadiiParameters',
            summary: `one or more normalized curve parameters where changes in radius occur.
     Important: curve parameters must be normalized - ranging between 0.0 and 1.0.`
          },
          {
            name: 'radii',
            summary: 'An array of radii - one at each normalized curve parameter in railRadiiParameters.'
          },
          {
            name: 'localBlending',
            summary: `If True, Local (pipe radius stays constant at the ends and changes more rapidly in the middle) is applied.
     If False, Global (radius is linearly blended from one end to the other, creating pipes that taper from one radius to the other) is applied`
          },
          {
            name: 'cap',
            summary: 'end cap mode'
          },
          {
            name: 'fitRail',
            summary: `If the curve is a polycurve of lines and arcs, the curve is fit and a single surface is created;
     otherwise the result is a polysurface with joined surfaces created from the polycurve segments.`
          },
          {
            name: 'absoluteTolerance',
            summary: 'The sweeping and fitting tolerance. If you are unsure what to use, then use the document\'s absolute tolerance'
          },
          {
            name: 'angleToleranceRadians',
            summary: 'The angle tolerance. If you are unsure what to use, then either use the document\'s angle tolerance in radians'
          }
        ],
        returns: 'Array of created pipes on success'
      },
      {
        signature: 'static Brep[] CreatePlanarBreps(Curve inputLoop)',
        summary: 'Constructs a set of planar breps as outlines by the loops.',
        since: 5,
        parameters: [
          {
            name: 'inputLoop',
            summary: 'A curve that should form the boundaries of the surfaces or polysurfaces.'
          }
        ],
        returns: 'An array of Planar Breps.'
      },
      {
        signature: 'static Brep[] CreatePlanarBreps(Curve inputLoop,double tolerance)',
        summary: 'Constructs a set of planar breps as outlines by the loops.',
        since: 6,
        parameters: [
          {
            name: 'inputLoop',
            summary: 'A curve that should form the boundaries of the surfaces or polysurfaces.'
          },
          {
            name: 'tolerance',
            summary: ''
          }
        ],
        returns: 'An array of Planar Breps.'
      },
      {
        signature: 'static Brep[] CreatePlanarBreps(CurveList inputLoops)',
        summary: 'Constructs a set of planar Breps as outlines by the loops.',
        since: 5,
        parameters: [
          {
            name: 'inputLoops',
            summary: 'Curve loops that delineate the planar boundaries.'
          }
        ],
        returns: 'An array of Planar Breps or None on error.'
      },
      {
        signature: 'static Brep[] CreatePlanarBreps(CurveList inputLoops,double tolerance)',
        summary: 'Constructs a set of planar Breps as outlines by the loops.',
        since: 6,
        parameters: [
          {
            name: 'inputLoops',
            summary: 'Curve loops that delineate the planar boundaries.'
          },
          {
            name: 'tolerance',
            summary: ''
          }
        ],
        returns: 'An array of Planar Breps.'
      },
      {
        signature: 'static Brep[] CreatePlanarBreps(IEnumerable<Curve> inputLoops)',
        summary: 'Constructs a set of planar breps as outlines by the loops.',
        since: 5,
        parameters: [
          {
            name: 'inputLoops',
            summary: 'Curve loops that delineate the planar boundaries.'
          }
        ],
        returns: 'An array of Planar Breps.'
      },
      {
        signature: 'static Brep[] CreatePlanarBreps(IEnumerable<Curve> inputLoops,double tolerance)',
        summary: 'Constructs a set of planar breps as outlines by the loops.',
        since: 6,
        parameters: [
          {
            name: 'inputLoops',
            summary: 'Curve loops that delineate the planar boundaries.'
          },
          {
            name: 'tolerance',
            summary: ''
          }
        ],
        returns: 'An array of Planar Breps.'
      },
      {
        signature: 'static Brep CreateQuadSphere(Sphere sphere)',
        summary: 'Constructs a Brep definition of a quad sphere.',
        since: 6,
        parameters: [
          {
            name: 'sphere',
            summary: 'The input sphere provides the orienting plane and radius.'
          }
        ],
        returns: 'A Brep if successful, None on error.'
      },
      {
        signature: 'static Brep[] CreateShell(Brep brep,IEnumerable<int> facesToRemove,double distance,double tolerance)',
        summary: 'Creates a hollowed out shell from a solid Brep. Function only operates on simple, solid, manifold Breps.',
        since: 5.4,
        parameters: [
          {
            name: 'brep',
            summary: 'The solid Brep to shell.'
          },
          {
            name: 'facesToRemove',
            summary: 'The indices of the Brep faces to remove. These surfaces are removed and the remainder is offset inward, using the outer parts of the removed surfaces to join the inner and outer parts.'
          },
          {
            name: 'distance',
            summary: 'The distance, or thickness, for the shell. This is a signed distance value with respect to face normals and flipped faces.'
          },
          {
            name: 'tolerance',
            summary: 'The offset tolerane. When in doubt, use the document\'s absolute tolerance.'
          }
        ],
        returns: 'An array of Brep results or None on failure.'
      },
      {
        signature: 'static Brep[] CreateSolid(IEnumerable<Brep> breps,double tolerance)',
        summary: 'Constructs closed polysurfaces from surfaces and polysurfaces that bound a region in space.',
        since: 5,
        parameters: [
          {
            name: 'breps',
            summary: 'The intersecting surfaces and polysurfaces to automatically trim and join into closed polysurfaces.'
          },
          {
            name: 'tolerance',
            summary: 'The trim and join tolerance. If set to RhinoMath.UnsetValue, Rhino\'s global absolute tolerance is used.'
          }
        ],
        returns: 'The resulting polysurfaces on success or None on failure.'
      },
      {
        signature: 'static Brep CreateTrimmedPlane(Plane plane,Curve curve)',
        summary: 'Create a Brep trimmed plane.',
        since: 6,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane that will be trimmed.'
          },
          {
            name: 'curve',
            summary: 'A simple (no self intersections) closed curve that defines the outer boundary of the trimmed plane.'
          }
        ],
        returns: 'Resulting brep or None on failure.'
      },
      {
        signature: 'static Brep CreateTrimmedPlane(Plane plane,IEnumerable<Curve> curves)',
        summary: 'Create a Brep trimmed plane.',
        since: 6,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane that will be trimmed.'
          },
          {
            name: 'curves',
            summary: 'A list of curves that form a simple (no self intersections) closed curve that defines the outer boundary of the trimmed plane.'
          }
        ],
        returns: 'Resulting brep or None on failure.'
      },
      {
        signature: 'static Brep CreateTrimmedSurface(BrepFace trimSource,Surface surfaceSource)',
        summary: `Constructs a Brep using the trimming information of a brep face and a surface. 
     Surface must be roughly the same shape and in the same location as the trimming brep face.`,
        since: 5,
        parameters: [
          {
            name: 'trimSource',
            summary: 'BrepFace which contains trimmingSource brep.'
          },
          {
            name: 'surfaceSource',
            summary: 'Surface that trims of BrepFace will be applied to.'
          }
        ],
        returns: 'A brep with the shape of surfaceSource and the trims of trimSource or None on failure.'
      },
      {
        signature: 'static Brep CreateTrimmedSurface(BrepFace trimSource,Surface surfaceSource,double tolerance)',
        summary: `Constructs a Brep using the trimming information of a brep face and a surface. 
     Surface must be roughly the same shape and in the same location as the trimming brep face.`,
        since: 6,
        parameters: [
          {
            name: 'trimSource',
            summary: 'BrepFace which contains trimmingSource brep.'
          },
          {
            name: 'surfaceSource',
            summary: 'Surface that trims of BrepFace will be applied to.'
          },
          {
            name: 'tolerance',
            summary: ''
          }
        ],
        returns: 'A brep with the shape of surfaceSource and the trims of trimSource or None on failure.'
      },
      {
        signature: 'static Brep[] JoinBreps(IEnumerable<Brep> brepsToJoin,double tolerance)',
        summary: `Joins the breps in the input array at any overlapping edges to form
     as few as possible resulting breps. There may be more than one brep in the result array.`,
        since: 5,
        parameters: [
          {
            name: 'brepsToJoin',
            summary: 'A list, an array or any enumerable set of breps to join.'
          },
          {
            name: 'tolerance',
            summary: '3d distance tolerance for detecting overlapping edges.'
          }
        ],
        returns: 'new joined breps on success, None on failure.'
      },
      {
        signature: 'static Brep MergeBreps(IEnumerable<Brep> brepsToMerge,double tolerance)',
        summary: `Combines two or more breps into one. A merge is like a boolean union that keeps the inside pieces. This
     function creates non-manifold Breps which in general are unusual in Rhino. You may want to consider using
     JoinBreps or CreateBooleanUnion functions instead.`,
        since: 5,
        parameters: [
          {
            name: 'brepsToMerge',
            summary: 'must contain more than one Brep.'
          },
          {
            name: 'tolerance',
            summary: 'the tolerance to use when merging.'
          }
        ],
        returns: 'Single merged Brep on success. Null on error.'
      },
      {
        signature: 'static Brep MergeSurfaces(Brep brep0,Brep brep1,double tolerance,double angleToleranceRadians)',
        summary: 'Merges two surfaces into one surface at untrimmed edges. Both surfaces must be untrimmed and share an edge.',
        since: 6,
        parameters: [
          {
            name: 'brep0',
            summary: 'The first single-face Brep to merge.'
          },
          {
            name: 'brep1',
            summary: 'The second single-face Brep to merge.'
          },
          {
            name: 'tolerance',
            summary: 'Surface edges must be within this tolerance for the two surfaces to merge.'
          },
          {
            name: 'angleToleranceRadians',
            summary: 'Edge must be within this angle tolerance in order for contiguous edges to be combined into a single edge.'
          }
        ],
        returns: 'The merged Brep if successful, None if not successful.'
      },
      {
        signature: 'static Brep MergeSurfaces(Brep brep0,Brep brep1,double tolerance,double angleToleranceRadians,Point2d point0,Point2d point1,double roundness,bool smooth)',
        summary: 'Merges two surfaces into one surface at untrimmed edges. Both surfaces must be untrimmed and share an edge.',
        since: 6,
        parameters: [
          {
            name: 'brep0',
            summary: 'The first single-face Brep to merge.'
          },
          {
            name: 'brep1',
            summary: 'The second single-face Brep to merge.'
          },
          {
            name: 'tolerance',
            summary: 'Surface edges must be within this tolerance for the two surfaces to merge.'
          },
          {
            name: 'angleToleranceRadians',
            summary: 'Edge must be within this angle tolerance in order for contiguous edges to be combined into a single edge.'
          },
          {
            name: 'point0',
            summary: '2D pick point on the first single-face Brep. The value can be unset.'
          },
          {
            name: 'point1',
            summary: '2D pick point on the second single-face Brep. The value can be unset.'
          },
          {
            name: 'roundness',
            summary: 'Defines the roundness of the merge. Acceptable values are between 0.0 (sharp) and 1.0 (smooth).'
          },
          {
            name: 'smooth',
            summary: 'The surface will be smooth. This makes the surface behave better for control point editing, but may alter the shape of both surfaces.'
          }
        ],
        returns: 'The merged Brep if successful, None if not successful.'
      },
      {
        signature: 'static Brep MergeSurfaces(Surface surface0,Surface surface1,double tolerance,double angleToleranceRadians)',
        summary: 'Merges two surfaces into one surface at untrimmed edges.',
        since: 6,
        parameters: [
          {
            name: 'surface0',
            summary: 'The first surface to merge.'
          },
          {
            name: 'surface1',
            summary: 'The second surface to merge.'
          },
          {
            name: 'tolerance',
            summary: 'Surface edges must be within this tolerance for the two surfaces to merge.'
          },
          {
            name: 'angleToleranceRadians',
            summary: 'Edge must be within this angle tolerance in order for contiguous edges to be combined into a single edge.'
          }
        ],
        returns: 'The merged surfaces as a Brep if successful, None if not successful.'
      },
      {
        signature: 'static Brep TryConvertBrep(GeometryBase geometry)',
        summary: 'Attempts to convert a generic Geometry object into a Brep.',
        since: 5,
        parameters: [
          {
            name: 'geometry',
            summary: 'Geometry to convert, not all types of GeometryBase can be represented by BReps.'
          }
        ],
        returns: `Brep if a brep form could be created or None if this is not possible. If geometry was of type Brep to 
     begin with, the same object is returned, i.e. it is not duplicated.`
      },
      {
        signature: 'int AddEdgeCurve(Curve curve)',
        summary: 'Add a 3d curve used by the brep edges',
        since: 5.4,
        returns: 'Index used to reference this geometry in the edge curve list'
      },
      {
        signature: 'int AddSurface(Surface surface)',
        summary: 'Adds a 3D surface used by BrepFace.',
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'A copy of the surface is added to this brep.'
          }
        ],
        returns: `Index that should be used to reference the geometry.
     -1 is returned if the input is not acceptable.`
      },
      {
        signature: 'int AddTrimCurve(Curve curve)',
        summary: 'Add a 2d curve used by the brep trims',
        since: 5.4,
        returns: 'Index used to reference this geometry in the trimming curve list'
      },
      {
        signature: 'void Append(Brep other)',
        summary: `Appends a copy of another brep to this and updates indices of appended
     brep parts.  Duplicates are not removed`,
        since: 5.4
      },
      {
        signature: 'Brep CapPlanarHoles(double tolerance)',
        summary: 'Returns a new Brep that is equivalent to this Brep with all planar holes capped.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'Tolerance to use for capping.'
          }
        ],
        returns: 'New brep on success. None on error.'
      },
      {
        signature: 'Point3d ClosestPoint(Point3d testPoint)',
        summary: 'Finds a point on the brep that is closest to testPoint.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Base point to project to brep.'
          }
        ],
        returns: 'The point on the Brep closest to testPoint or Point3d.Unset if the operation failed.'
      },
      {
        signature: 'bool ClosestPoint(Point3d testPoint,Point3d closestPoint,ComponentIndex ci,double s,double t,double maximumDistance,Vector3d normal)',
        summary: `Finds a point on a Brep that is closest to testPoint.
     The method searches all Brep faces looking for the one closest to testPoint.
     When found, if the closest point falls on the inactive region of the face, then 
     the method finds the face's edge that is closest to testPoint.`,
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'base point to project to surface.'
          },
          {
            name: 'closestPoint',
            summary: 'location of the closest brep point.'
          },
          {
            name: 'ci',
            summary: `Component index of the brep component that contains
     the closest point. Possible types are brep_face, brep_edge or brep_vertex.`
          },
          {
            name: 's',
            summary: `If the ci type is brep_edge, then s is the parameter
     of the closest edge point.`
          },
          {
            name: 't',
            summary: `If the ci type is brep_face, then (s,t) is the parameter
     of the closest edge point.`
          },
          {
            name: 'maximumDistance',
            summary: `If maximumDistance > 0, then only points whose distance
     is <= maximumDistance will be returned. Using a positive
     value of maximumDistance can substantially speed up the search.`
          },
          {
            name: 'normal',
            summary: `The normal to the face if ci is a brep_face
     and the tangent to the edge if ci is brep_edge.`
          }
        ],
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'void Compact()',
        summary: `Deletes any unreferenced objects from arrays, reindexes as needed, and
     shrinks arrays to minimum required size. Uses CUllUnused* members to
     delete any unreferenced objects from arrays.`,
        since: 5
      },
      {
        signature: 'bool CullUnused2dCurves()',
        summary: 'Culls 3d curves not referenced by an edge.',
        since: 5,
        returns: 'True if operation succeeded; False otherwise.'
      },
      {
        signature: 'bool CullUnused3dCurves()',
        summary: 'Culls 2d curves not referenced by a trim.',
        since: 5,
        returns: 'True if operation succeeded; False otherwise.'
      },
      {
        signature: 'bool CullUnusedEdges()',
        summary: 'Culls edges with m_edge_index == -1.',
        since: 5,
        returns: 'True if operation succeeded; False otherwise.'
      },
      {
        signature: 'bool CullUnusedFaces()',
        summary: 'Culls faces with m_face_index == -1.',
        since: 5,
        returns: 'True if operation succeeded; False otherwise.'
      },
      {
        signature: 'bool CullUnusedLoops()',
        summary: 'Culls loops with m_loop_index == -1.',
        since: 5,
        returns: 'True if operation succeeded; False otherwise.'
      },
      {
        signature: 'bool CullUnusedSurfaces()',
        summary: 'Culls surfaces not referenced by a face.',
        since: 5,
        returns: 'True if operation succeeded; False otherwise.'
      },
      {
        signature: 'bool CullUnusedTrims()',
        summary: 'Culls trims with m_trim_index == -1.',
        since: 5,
        returns: 'True if operation succeeded; False otherwise.'
      },
      {
        signature: 'bool CullUnusedVertices()',
        summary: 'Culls vertices with m_vertex_index == -1.',
        since: 5,
        returns: 'True if operation succeeded; False otherwise.'
      },
      {
        signature: 'GeometryBase Duplicate()',
        summary: 'Copies this brep.',
        since: 5,
        returns: 'A brep.'
      },
      {
        signature: 'Brep DuplicateBrep()',
        summary: `Same as Duplicate(), but already performs a cast to a brep.
     This cast always succeeds.`,
        since: 5,
        returns: 'A brep.'
      },
      {
        signature: 'Curve[] DuplicateEdgeCurves()',
        summary: 'Duplicate all the edges of this Brep.',
        since: 5,
        returns: 'An array of edge curves.'
      },
      {
        signature: 'Curve[] DuplicateEdgeCurves(bool nakedOnly)',
        summary: 'Duplicate edges of this Brep.',
        since: 5,
        parameters: [
          {
            name: 'nakedOnly',
            summary: `If true, then only the "naked" edges are duplicated.
     If false, then all edges are duplicated.`
          }
        ],
        returns: 'Array of edge curves on success.'
      },
      {
        signature: 'Curve[] DuplicateNakedEdgeCurves(bool outer,bool inner)',
        summary: 'Duplicate naked edges of this Brep',
        since: 5.7
      },
      {
        signature: 'Brep DuplicateSubBrep(IEnumerable<int> faceIndices)',
        summary: 'Copy a subset of this Brep into another Brep.',
        since: 5,
        parameters: [
          {
            name: 'faceIndices',
            summary: `array of face indices in this brep to copy.
     (If any values in faceIndices are out of range or if faceIndices contains
     duplicates, this function will return null.)`
          }
        ],
        returns: 'A brep, or None on error.'
      },
      {
        signature: 'Point3d[] DuplicateVertices()',
        summary: 'Duplicate all the corner vertices of this Brep.',
        since: 5,
        returns: 'An array or corner vertices.'
      },
      {
        signature: 'void FindCoincidentBrepComponents(Point3d point,double tolerance,int[] faces,int[] edges,int[] vertices)',
        summary: 'Find the indices of all brep faces, edges and vertices that are within tolerance of a test-point.',
        since: 6.2,
        parameters: [
          {
            name: 'point',
            summary: 'Test point.'
          },
          {
            name: 'tolerance',
            summary: 'Coincidence tolerance.'
          },
          {
            name: 'faces',
            summary: 'Array of BrepFace indices.'
          },
          {
            name: 'edges',
            summary: 'Array of BrepEdge indices.'
          },
          {
            name: 'vertices',
            summary: 'Array of BrepVertex indices.'
          }
        ]
      },
      {
        signature: 'void Flip()',
        summary: 'Reverses entire brep orientation of all faces.',
        since: 5
      },
      {
        signature: 'double GetArea()',
        summary: `Compute the Area of the Brep. If you want proper Area data with moments 
     and error information, use the AreaMassProperties class.`,
        since: 5,
        returns: 'The area of the Brep.'
      },
      {
        signature: 'double GetArea(double relativeTolerance,double absoluteTolerance)',
        summary: `Compute the Area of the Brep. If you want proper Area data with moments 
     and error information, use the AreaMassProperties class.`,
        since: 5,
        parameters: [
          {
            name: 'relativeTolerance',
            summary: 'Relative tolerance to use for area calculation.'
          },
          {
            name: 'absoluteTolerance',
            summary: 'Absolute tolerance to use for area calculation.'
          }
        ],
        returns: 'The area of the Brep.'
      },
      {
        signature: 'bool GetPointInside(double tolerance,Point3d point)',
        summary: 'Finds a point inside of a solid Brep.',
        since: 6.19,
        parameters: [
          {
            name: 'tolerance',
            summary: `Used for intersecting rays and is not necessarily related to the distance from the brep to the found point.
     When in doubt, use the document's model absolute tolerance.`
          },
          {
            name: 'point',
            summary: 'A point inside the solid Brep.'
          }
        ],
        returns: `Returns False if the input is not solid and manifold, if the Brep's bounding box is less than 2.0 * tolerance wide, 
     or if no point could be found due to ray shooting or other errors. Otherwise, True is returned.`
      },
      {
        signature: 'BrepRegion[] GetRegions()',
        summary: 'Gets an array containing all regions in this brep.',
        since: 5,
        returns: 'An array of regions in this brep. This array can be empty, but not null.'
      },
      {
        signature: 'double GetVolume()',
        summary: `Compute the Volume of the Brep. If you want proper Volume data with moments 
     and error information, use the VolumeMassProperties class.`,
        since: 5,
        returns: 'The volume of the Brep.'
      },
      {
        signature: 'double GetVolume(double relativeTolerance,double absoluteTolerance)',
        summary: `Compute the Volume of the Brep. If you want proper Volume data with moments 
     and error information, use the VolumeMassProperties class.`,
        since: 5,
        parameters: [
          {
            name: 'relativeTolerance',
            summary: 'Relative tolerance to use for area calculation.'
          },
          {
            name: 'absoluteTolerance',
            summary: 'Absolute tolerance to use for area calculation.'
          }
        ],
        returns: 'The volume of the Brep.'
      },
      {
        signature: 'Curve[] GetWireframe(int density)',
        summary: 'Constructs all the Wireframe curves for this Brep.',
        since: 5,
        parameters: [
          {
            name: 'density',
            summary: 'Wireframe density. Valid values range between -1 and 99.'
          }
        ],
        returns: 'An array of Wireframe curves or None on failure.'
      },
      {
        signature: 'bool IsDuplicate(Brep other,double tolerance)',
        summary: 'See if this and other are same brep geometry.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'other brep.'
          },
          {
            name: 'tolerance',
            summary: 'tolerance to use when comparing control points.'
          }
        ],
        returns: 'True if breps are the same.'
      },
      {
        signature: 'bool IsPointInside(Point3d point,double tolerance,bool strictlyIn)',
        summary: `Determines if point is inside a Brep.  This question only makes sense when
     the brep is a closed and manifold.  This function does not not check for
     closed or manifold, so result is not valid in those cases.  Intersects
     a line through point with brep, finds the intersection point Q closest
     to point, and looks at face normal at Q.  If the point Q is on an edge
     or the intersection is not transverse at Q, then another line is used.`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: '3d point to test.'
          },
          {
            name: 'tolerance',
            summary: `3d distance tolerance used for intersection and determining strict inclusion.
     A good default is RhinoMath.SqrtEpsilon.`
          },
          {
            name: 'strictlyIn',
            summary: `if true, point is in if inside brep by at least tolerance.
     if false, point is in if truly in or within tolerance of boundary.`
          }
        ],
        returns: 'True if point is in, False if not.'
      },
      {
        signature: 'bool IsValidGeometry(string log)',
        summary: `Expert user function that tests the brep to see if its geometry information is valid.
     The value of brep.IsValidTopology() must be True before brep.IsValidGeometry() can be
     safely called.`,
        since: 5,
        parameters: [
          {
            name: 'log',
            summary: `If the brep geometry is not valid, then a brief description of the problem
     in English is assigned to this out parameter. The information is suitable for
     low-level debugging purposes by programmers and is not intended to be
     useful as a high level user interface tool. Otherwise, string.Empty.`
          }
        ],
        returns: 'A value that indicates whether the geometry is valid.'
      },
      {
        signature: 'bool IsValidTolerancesAndFlags(string log)',
        summary: `Expert user function that tests the brep to see if its tolerances and
     flags are valid.  The values of brep.IsValidTopology() and
     brep.IsValidGeometry() must be True before brep.IsValidTolerancesAndFlags()
     can be safely called.`,
        since: 5,
        parameters: [
          {
            name: 'log',
            summary: `If the brep tolerance or flags are not valid, then a brief description 
     of the problem in English is assigned to this out parameter. The information is
     suitable for low-level debugging purposes by programmers and is not
     intended to be useful as a high level user interface tool. Otherwise, string.Empty.`
          }
        ],
        returns: 'A value that indicates'
      },
      {
        signature: 'bool IsValidTopology(string log)',
        summary: 'Tests the brep to see if its topology information is valid.',
        since: 5,
        parameters: [
          {
            name: 'log',
            summary: `If the brep topology is not valid, then a brief english description of
     the problem is appended to the log.  The information appended to log is
     suitable for low-level debugging purposes by programmers and is not
     intended to be useful as a high level user interface tool.`
          }
        ],
        returns: 'True if the topology is valid; False otherwise.'
      },
      {
        signature: 'bool Join(Brep otherBrep,double tolerance,bool compact)',
        summary: `If any edges of this brep overlap edges of otherBrep, merge a copy of otherBrep into this
     brep joining all edges that overlap within tolerance.`,
        since: 5,
        parameters: [
          {
            name: 'otherBrep',
            summary: 'Brep to be added to this brep.'
          },
          {
            name: 'tolerance',
            summary: '3d distance tolerance for detecting overlapping edges.'
          },
          {
            name: 'compact',
            summary: 'if true, set brep flags and tolerances, remove unused faces and edges.'
          }
        ],
        returns: 'True if any edges were joined.'
      },
      {
        signature: 'bool JoinEdges(int edgeIndex0,int edgeIndex1,double joinTolerance,bool compact)',
        summary: 'Joins two naked edges, or edges that are coincident or close together.',
        since: 6,
        parameters: [
          {
            name: 'edgeIndex0',
            summary: 'The first edge index.'
          },
          {
            name: 'edgeIndex1',
            summary: 'The second edge index.'
          },
          {
            name: 'joinTolerance',
            summary: 'The join tolerance.'
          },
          {
            name: 'compact',
            summary: `If joining more than one edge pair and want the edge indices of subsequent pairs to remain valid, 
     set to false. But then call Brep.Compact() on the final result.`
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'int JoinNakedEdges(double tolerance)',
        summary: 'Joins naked edge pairs within the same brep that overlap within tolerance.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'The tolerance value.'
          }
        ],
        returns: 'number of joins made.'
      },
      {
        signature: 'bool MakeValidForV2()',
        summary: `No support is available for this function.
     Expert user function that converts all geometry in brep to nurbs form.`,
        since: 6
      },
      {
        signature: 'bool MergeCoplanarFaces(double tolerance)',
        summary: 'Merges adjacent coplanar faces into single faces.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: `Tolerance for determining when edges are adjacent.
     When in doubt, use the document's ModelAbsoluteTolerance property.`
          }
        ],
        returns: 'True if faces were merged, False if no faces were merged.'
      },
      {
        signature: 'bool MergeCoplanarFaces(double tolerance,double angleTolerance)',
        summary: 'Merges adjacent coplanar faces into single faces.',
        since: 6.1,
        parameters: [
          {
            name: 'tolerance',
            summary: `Tolerance for determining when edges are adjacent.
     When in doubt, use the document's ModelAbsoluteTolerance property.`
          },
          {
            name: 'angleTolerance',
            summary: `Angle tolerance, in radians, for determining when faces are parallel.
     When in doubt, use the document's ModelAngleToleranceRadians property.`
          }
        ],
        returns: 'True if faces were merged, False if no faces were merged.'
      },
      {
        signature: 'void RebuildTrimsForV2(BrepFace face,NurbsSurface nurbsSurface)',
        summary: `No support is available for this function.
     Expert user function used by MakeValidForV2 to convert trim
     curves from one surface to its NURBS form. After calling this function,
     you need to change the surface of the face to a NurbsSurface.`,
        since: 5,
        parameters: [
          {
            name: 'face',
            summary: `Face whose underlying surface has a parameterization that is different
     from its NURBS form.`
          },
          {
            name: 'nurbsSurface',
            summary: 'NURBS form of the face\'s underlying surface.'
          }
        ]
      },
      {
        signature: 'bool RemoveFins()',
        summary: 'Recursively removes any Brep face with a naked edge. This function is only useful for non-manifold Breps.',
        since: 7,
        returns: 'True if successful, False if everything is removed or if the result has any Brep edges with more than two Brep trims.'
      },
      {
        signature: 'Brep RemoveHoles(double tolerance)',
        summary: 'Remove all inner loops, or holes, in a Brep.',
        since: 6,
        parameters: [
          {
            name: 'tolerance',
            summary: 'The tolerance. When in doubt, use the document\'s model absolute tolerance.'
          }
        ],
        returns: 'The Brep without holes if successful, None otherwise.'
      },
      {
        signature: 'Brep RemoveHoles(IEnumerable<ComponentIndex> loops,double tolerance)',
        summary: 'Removes inner loops, or holes, in a Brep.',
        since: 6.8,
        parameters: [
          {
            name: 'loops',
            summary: 'A list of BrepLoop component indexes, where BrepLoop.LoopType == Rhino.Geometry.BrepLoopType.Inner.'
          },
          {
            name: 'tolerance',
            summary: 'The tolerance. When in doubt, use the document\'s model absolute tolerance.'
          }
        ],
        returns: 'The Brep without holes if successful, None otherwise.'
      },
      {
        signature: 'bool Repair(double tolerance)',
        summary: `Fills in missing or fixes incorrect component information from a Brep. 
     Useful when reading Brep information from other file formats that do not 
     provide as complete of a Brep definition as requried by Rhino.`,
        since: 6,
        parameters: [
          {
            name: 'tolerance',
            summary: 'The repair tolerance. When in doubt, use the document\'s model absolute tolerance.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'void SetTolerancesBoxesAndFlags()',
        summary: 'Set tolerances and flags in a Brep.',
        since: 6
      },
      {
        signature: 'void SetTolerancesBoxesAndFlags(bool bLazy,bool bSetVertexTolerances,bool bSetEdgeTolerances,bool bSetTrimTolerances,bool bSetTrimIsoFlags,bool bSetTrimTypeFlags,bool bSetLoopTypeFlags,bool bSetTrimBoxes)',
        summary: 'Set tolerances and flags in a Brep.',
        since: 6,
        parameters: [
          {
            name: 'bLazy',
            summary: 'If true, only flags and tolerances that are not set will be calculated.'
          },
          {
            name: 'bSetVertexTolerances',
            summary: 'Set True to compute BrepVertex tolerances.'
          },
          {
            name: 'bSetEdgeTolerances',
            summary: 'Set True to compute BrepEdge tolerances.'
          },
          {
            name: 'bSetTrimTolerances',
            summary: 'Set True to compute BrepTrim tolerances.'
          },
          {
            name: 'bSetTrimIsoFlags',
            summary: 'Set True to compute BrepTrim.IsoStatus values.'
          },
          {
            name: 'bSetTrimTypeFlags',
            summary: 'Set True to compute BrepTrim.TrimType values.'
          },
          {
            name: 'bSetLoopTypeFlags',
            summary: 'Set True to compute BrepLoop.BrepLoopType values.'
          },
          {
            name: 'bSetTrimBoxes',
            summary: 'Set True to compute BrepTrim bounding boxes.'
          }
        ]
      },
      {
        signature: 'void SetTrimIsoFlags()',
        summary: `This function can be used to set the BrepTrim::m_iso
     flag. It is intended to be used when creating a Brep from
     a definition that does not include compatible parameter space
     type information.`,
        since: 5.4
      },
      {
        signature: 'void SetVertices()',
        summary: `This function can be used to compute vertex information for a
     b-rep when everything but the Vertices array is properly filled in.
     It is intended to be used when creating a Brep from a 
     definition that does not include explicit vertex information.`,
        since: 5.4
      },
      {
        signature: 'Brep[] Split(Brep cutter,double intersectionTolerance)',
        summary: 'Splits a Brep into pieces using a Brep as a cutter.',
        since: 5,
        parameters: [
          {
            name: 'cutter',
            summary: 'The Brep to use as a cutter.'
          },
          {
            name: 'intersectionTolerance',
            summary: 'The tolerance with which to compute intersections.'
          }
        ],
        returns: 'A new array of Breps. This array can be empty.'
      },
      {
        signature: 'Brep[] Split(Brep cutter,double intersectionTolerance,bool toleranceWasRaised)',
        summary: 'Splits a Brep into pieces using a Brep as a cutter.',
        since: 5,
        parameters: [
          {
            name: 'cutter',
            summary: 'The Brep to use as a cutter.'
          },
          {
            name: 'intersectionTolerance',
            summary: 'The tolerance with which to compute intersections.'
          },
          {
            name: 'toleranceWasRaised',
            summary: `Set to True if the split failed at intersectionTolerance but succeeded
     when the tolerance was increased to twice intersectionTolerance.`
          }
        ],
        returns: 'A new array of Breps. This array can be empty.'
      },
      {
        signature: 'Brep[] Split(IEnumerable<Brep> cutters,double intersectionTolerance)',
        summary: 'Splits a Brep into pieces using Breps as cutters.',
        since: 6.13,
        parameters: [
          {
            name: 'cutters',
            summary: 'One or more Breps to use as cutters.'
          },
          {
            name: 'intersectionTolerance',
            summary: 'The tolerance with which to compute intersections.'
          }
        ],
        returns: 'A new array of Breps. This array can be empty.'
      },
      {
        signature: 'Brep[] Split(IEnumerable<Curve> cutters,double intersectionTolerance)',
        summary: 'Splits a Brep into pieces using curves, at least partially on the Brep, as cutters.',
        since: 6.13,
        parameters: [
          {
            name: 'cutters',
            summary: 'The splitting curves. Only the portion of the curve on the Brep surface will be used for cutting.'
          },
          {
            name: 'intersectionTolerance',
            summary: 'The tolerance with which to compute intersections.'
          }
        ],
        returns: 'A new array of Breps. This array can be empty.'
      },
      {
        signature: 'Brep[] Split(IEnumerable<GeometryBase> cutters,Vector3d normal,bool planView,double intersectionTolerance)',
        summary: 'Splits a Brep into pieces using a combination of curves, to be extruded, and Breps as cutters.',
        since: 6.13,
        parameters: [
          {
            name: 'cutters',
            summary: 'The curves, surfaces, faces and Breps to be used as cutters. Any other geometry is ignored.'
          },
          {
            name: 'normal',
            summary: 'A construction plane normal, used in deciding how to extrude a curve into a cutter.'
          },
          {
            name: 'planView',
            summary: 'Set True if the assume view is a plan, or parallel projection, view.'
          },
          {
            name: 'intersectionTolerance',
            summary: 'The tolerance with which to compute intersections.'
          }
        ],
        returns: 'A new array of Breps. This array can be empty.'
      },
      {
        signature: 'void Standardize()',
        summary: `Standardizes all trims, edges, and faces in the brep.
     After standardizing, there may be unused curves and surfaces in the
     brep.  Call Brep.Compact to remove these unused curves and surfaces.`,
        since: 5
      },
      {
        signature: 'bool TransformComponent(IEnumerable<ComponentIndex> components,Transform xform,double tolerance,double timeLimit,bool useMultipleThreads)',
        summary: 'Transform an array of Brep components, bend neighbors to match, and leave the rest fixed.',
        since: 6,
        parameters: [
          {
            name: 'components',
            summary: 'The Brep components to transform.'
          },
          {
            name: 'xform',
            summary: 'The transformation to apply.'
          },
          {
            name: 'tolerance',
            summary: 'The desired fitting tolerance to use when bending faces that share edges with both fixed and transformed components.'
          },
          {
            name: 'timeLimit',
            summary: `If the deformation is extreme, it can take a long time to calculate the result.
     If time_limit > 0, then the value specifies the maximum amount of time in seconds you want to spend before giving up.`
          },
          {
            name: 'useMultipleThreads',
            summary: 'True if multiple threads can be used.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'Brep[] Trim(Brep cutter,double intersectionTolerance)',
        summary: `Trims a brep with an oriented cutter. The parts of the brep that lie inside
     (opposite the normal) of the cutter are retained while the parts to the
     outside (in the direction of the normal) are discarded.  If the Cutter is
     closed, then a connected component of the Brep that does not intersect the
     cutter is kept if and only if it is contained in the inside of cutter.
     That is the region bounded by cutter opposite from the normal of cutter,
     If cutter is not closed all these components are kept.`,
        since: 5,
        parameters: [
          {
            name: 'cutter',
            summary: 'A cutting brep.'
          },
          {
            name: 'intersectionTolerance',
            summary: 'A tolerance value with which to compute intersections.'
          }
        ],
        returns: 'This Brep is not modified, the trim results are returned in an array.'
      },
      {
        signature: 'Brep[] Trim(Plane cutter,double intersectionTolerance)',
        summary: `Trims a Brep with an oriented cutter.  The parts of Brep that lie inside
     (opposite the normal) of the cutter are retained while the parts to the
     outside ( in the direction of the normal ) are discarded. A connected
     component of Brep that does not intersect the cutter is kept if and only
     if it is contained in the inside of Cutter.  That is the region bounded by
     cutter opposite from the normal of cutter, or in the case of a Plane cutter
     the halfspace opposite from the plane normal.`,
        since: 5,
        parameters: [
          {
            name: 'cutter',
            summary: 'A cutting plane.'
          },
          {
            name: 'intersectionTolerance',
            summary: 'A tolerance value with which to compute intersections.'
          }
        ],
        returns: 'This Brep is not modified, the trim results are returned in an array.'
      },
      {
        signature: 'Brep[] UnjoinEdges(IEnumerable<int> edgesToUnjoin)',
        summary: 'Unjoins, or separates, edges within the Brep. Note, seams in closed surfaces will not separate.',
        since: 6,
        parameters: [
          {
            name: 'edgesToUnjoin',
            summary: 'The indices of the Brep edges to unjoin.'
          }
        ],
        returns: 'This Brep is not modified, the trim results are returned in an array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BrepEdge',
    dataType: 1,
    summary: 'Represents a single edge curve in a Brep object.',
    baseclass: 'Rhino.Geometry.CurveProxy',
    properties: [
      {
        signature: 'Brep Brep',
        summary: 'Gets the Brep that owns this edge.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Curve EdgeCurve',
        summary: 'Get the brep.Curves3D[] 3d curve geometry used by this edge or null.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int EdgeCurveIndex',
        summary: 'Get the brep.Curves3D[] index of the 3d curve geometry used by this edge or -1.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int EdgeIndex',
        summary: 'Gets the index of this edge in the Brep.Edges collection.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BrepVertex EndVertex',
        summary: 'BrepVertex at end of edge',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'BrepVertex StartVertex',
        summary: 'BrepVertex at start of edge',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'double Tolerance',
        summary: `Gets or sets the accuracy of the edge curve (>=0.0 or RhinoMath.UnsetValue)
     A value of UnsetValue indicates that the tolerance should be computed.
    
     The maximum distance from the edge's 3d curve to any surface of a face
     that has this edge as a portion of its boundary must be <= this tolerance.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int TrimCount',
        summary: 'Gets the number of trim-curves that use this edge.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'EdgeAdjacency Valence',
        summary: `Gets the topological valency of this edge. The topological valency 
     is defined by how many adjacent faces share this edge.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int[] AdjacentFaces()',
        summary: 'Gets the indices of all the BrepFaces that use this edge.',
        since: 5
      },
      {
        signature: 'Concavity ConcavityAt(double t,double tolerance)',
        summary: 'Determine the concavity of this edge at a specific parameter.',
        since: 6.2,
        parameters: [
          {
            name: 't',
            summary: 'Edge curve parameter.'
          },
          {
            name: 'tolerance',
            summary: 'Angle tolerance for tangent faces.'
          }
        ],
        returns: 'Concavity measure at parameter.'
      },
      {
        signature: 'bool GetEdgeParameter(int trimIndex,double trimParameter,double edgeParameter)',
        summary: 'Get corresponding edge parameter for given trim at given trim parameter.',
        since: 5.12,
        returns: 'True on success'
      },
      {
        signature: 'bool IsSmoothManifoldEdge(double angleToleranceRadians)',
        summary: `For a manifold, non-boundary edge, decides whether or not the two surfaces
     on either side meet smoothly.`,
        since: 5,
        parameters: [
          {
            name: 'angleToleranceRadians',
            summary: 'used to decide if surface normals on either side are parallel.'
          }
        ],
        returns: `True if edge is manifold, has exactly 2 trims, and surface normals on either
     side agree to within angle_tolerance.`
      },
      {
        signature: 'bool SetEdgeCurve(int curve3dIndex)',
        summary: 'Set 3d curve geometry used by a b-rep edge.',
        since: 5.4,
        parameters: [
          {
            name: 'curve3dIndex',
            summary: 'index of 3d curve in m_C3[] array'
          }
        ],
        returns: 'True if successful'
      },
      {
        signature: 'bool SetEdgeCurve(int curve3dIndex,Interval subDomain)',
        summary: 'Set 3d curve geometry used by a b-rep edge.',
        since: 5.4,
        parameters: [
          {
            name: 'curve3dIndex',
            summary: 'index of 3d curve in m_C3[] array'
          },
          {
            name: 'subDomain',
            summary: ''
          }
        ],
        returns: 'True if successful'
      },
      {
        signature: 'int[] TrimIndices()',
        summary: 'Gets the indices of all trims associated with this edge.',
        since: 5.12,
        returns: 'Empty array on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BrepFace',
    dataType: 1,
    summary: `Provides strongly-typed access to brep faces.
   A Brep face is composed of one surface and trimming curves.`,
    baseclass: 'Rhino.Geometry.SurfaceProxy',
    properties: [
      {
        signature: 'Brep Brep',
        summary: 'Gets the Brep that owns this face.',
        since: 6.9,
        property: ['get']
      },
      {
        signature: 'int FaceIndex',
        summary: 'Index of face in Brep.Faces array.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsSurface',
        summary: `Gets a value indicating whether the face is synonymous with the underlying surface. 
     If a Face has no trimming curves then it is considered a Surface.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'BrepLoopList Loops',
        summary: 'Loops in this face.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool OrientationIsReversed',
        summary: 'True if face orientation is opposite of natural surface orientation.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'BrepLoop OuterLoop',
        summary: 'Every face has a single outer loop.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int SurfaceIndex',
        summary: 'Surface index of the 3d surface geometry used by this face or -1',
        since: 5.6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int[] AdjacentEdges()',
        summary: 'Gets the indices of all the BrepEdges that delineate this Face.',
        since: 5
      },
      {
        signature: 'int[] AdjacentFaces()',
        summary: 'Gets the indices of all the BrepFaces that surround (are adjacent to) this face.',
        since: 5
      },
      {
        signature: 'bool ChangeSurface(int surfaceIndex)',
        summary: 'Expert user tool that replaces the 3d surface geometry use by the face.',
        since: 5,
        parameters: [
          {
            name: 'surfaceIndex',
            summary: 'brep surface index of new surface.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'Brep CreateExtrusion(Curve pathCurve,bool cap)',
        summary: 'Extrude a face in a Brep.',
        since: 5.3,
        parameters: [
          {
            name: 'pathCurve',
            summary: 'The path to extrude along.'
          },
          {
            name: 'cap',
            summary: 'If true, the extrusion is capped with a translation of the face being extruded'
          }
        ],
        returns: 'A Brep on success or None on failure.'
      },
      {
        signature: 'bool DraftAnglePoint(Point2d testPoint,double testAngle,Vector3d pullDirection,bool edge,Point3d draftPoint,double draftAngle)',
        summary: 'Returns the surface draft angle and point at a parameter.',
        since: 6,
        parameters: [
          {
            name: 'testPoint',
            summary: 'The u,v parameter on the face to evaluate.'
          },
          {
            name: 'testAngle',
            summary: 'The angle in radians to test.'
          },
          {
            name: 'pullDirection',
            summary: 'The pull direction.'
          },
          {
            name: 'edge',
            summary: 'Restricts the point placement to an edge.'
          },
          {
            name: 'draftPoint',
            summary: 'The draft angle point.'
          },
          {
            name: 'draftAngle',
            summary: 'The draft angle in radians.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'Brep DuplicateFace(bool duplicateMeshes)',
        summary: 'Duplicate a face from the brep to create new single face brep.',
        since: 5,
        parameters: [
          {
            name: 'duplicateMeshes',
            summary: 'If true, shading meshes will be copied as well.'
          }
        ],
        returns: 'A new single-face brep synonymous with the current Face.'
      },
      {
        signature: 'Surface DuplicateSurface()',
        summary: 'Gets a copy to the untrimmed surface that this face is based on.',
        since: 5,
        returns: 'A copy of this face\'s underlying surface.'
      },
      {
        signature: 'Mesh GetMesh(MeshType meshType)',
        summary: 'Obtains a reference to a specified type of mesh for this brep face.',
        since: 5,
        parameters: [
          {
            name: 'meshType',
            summary: 'The mesh type.'
          }
        ],
        returns: 'A mesh.'
      },
      {
        signature: 'PointFaceRelation IsPointOnFace(double u,double v)',
        summary: 'Tests if a parameter space point is on the interior of a trimmed face.',
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'Parameter space point u value.'
          },
          {
            name: 'v',
            summary: 'Parameter space point v value.'
          }
        ],
        returns: 'A value describing the spatial relationship between the point and the face.'
      },
      {
        signature: 'Point3d[] PullPointsToFace(IEnumerable<Point3d> points,double tolerance)',
        summary: 'Pulls one or more points to a brep face.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to pull.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance for pulling operation. Only points that are closer than tolerance will be pulled to the face.'
          }
        ],
        returns: 'An array of pulled points.'
      },
      {
        signature: 'bool RebuildEdges(double tolerance,bool rebuildSharedEdges,bool rebuildVertices)',
        summary: 'Rebuild the edges used by a face so they lie on the surface.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'tolerance for fitting 3d edge curves.'
          },
          {
            name: 'rebuildSharedEdges',
            summary: `if False and and edge is used by this face and a neighbor, then the edge
     will be skipped.`
          },
          {
            name: 'rebuildVertices',
            summary: 'if true, vertex locations are updated to lie on the surface.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'Brep RemoveHoles(double tolerance)',
        summary: 'Remove all inner loops, or holes, from a Brep face.',
        since: 6
      },
      {
        signature: 'bool SetDomain(int direction,Interval domain)',
        summary: 'Sets the surface domain of this face.',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: 'Direction of face to set (0 = U, 1 = V).'
          },
          {
            name: 'domain',
            summary: 'Domain to apply.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetMesh(MeshType meshType,Mesh mesh)',
        summary: 'Sets a reference to a specified type of mesh for this brep face.',
        since: 5,
        parameters: [
          {
            name: 'meshType',
            summary: 'The mesh type.'
          },
          {
            name: 'mesh',
            summary: 'The new mesh.'
          }
        ],
        returns: 'True if the operation succeeded; otherwise false.'
      },
      {
        signature: 'bool ShrinkFace(ShrinkDisableSide disableSide)',
        summary: `Shrinks the underlying untrimmed surface of this Brep face close to trimming boundaries.
     Shrinking a surface is like extending smoothly, only backwards. knot of full multiplicity
     are added where you want the surface to be cut off. Then the remaining control points are
     thrown away.`,
        since: 6,
        parameters: [
          {
            name: 'disableSide',
            summary: 'The side(s) of the surface to not shrink.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool ShrinkSurfaceToEdge()',
        summary: `Shrinks the underlying untrimmed surface of this Brep face right to the trimming boundaries.
     Note, shrinking the trimmed surface can sometimes cause problems later since having
     the edges so close to the trimming boundaries can cause commands that use the surface
     edges as input to fail.`,
        since: 6.16,
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'Brep Split(IEnumerable<Curve> curves,double tolerance)',
        summary: 'Split this face using 3D trimming curves.',
        since: 5,
        parameters: [
          {
            name: 'curves',
            summary: 'Curves to split with.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance for splitting, when in doubt use the Document Absolute Tolerance.'
          }
        ],
        returns: 'A brep consisting of all the split fragments, or None on failure.'
      },
      {
        signature: 'Curve[] TrimAwareIsoCurve(int direction,double constantParameter)',
        summary: `Similar to IsoCurve function, except this function pays attention to trims on faces 
     and may return multiple curves.`,
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: `Direction of isocurve.
     0 = Isocurve connects all points with a constant U value.1 = Isocurve connects all points with a constant V value.`
          },
          {
            name: 'constantParameter',
            summary: 'Surface parameter that remains identical along the isocurves.'
          }
        ],
        returns: 'Isoparametric curves connecting all points with the constantParameter value.'
      },
      {
        signature: 'Interval[] TrimAwareIsoIntervals(int direction,double constantParameter)',
        summary: 'Gets intervals where the iso curve exists on a BrepFace (trimmed surface)',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: `Direction of isocurve.
     0 = Isocurve connects all points with a constant U value.1 = Isocurve connects all points with a constant V value.`
          },
          {
            name: 'constantParameter',
            summary: 'Surface parameter that remains identical along the isocurves.'
          }
        ],
        returns: `If direction = 0, the parameter space iso interval connects the 2d points
     (intervals[i][0],iso_constant) and (intervals[i][1],iso_constant).
     If direction = 1, the parameter space iso interval connects the 2d points
     (iso_constant,intervals[i][0]) and (iso_constant,intervals[i][1]).`
      },
      {
        signature: 'Surface UnderlyingSurface()',
        summary: 'Gets the untrimmed surface that is the base of this face.',
        since: 5,
        returns: 'A surface, or None on error.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BrepFace.ShrinkDisableSide',
    dataType: 3,
    summary: 'Defines bitwise mask flags indicating what side of a surface to not shrink.',
    values: [
      {
        signature: 'ShrinkAllSides = 0x0000',
        summary: 'Shrink on all four sides.'
      },
      {
        signature: 'DoNotShrinkWestSide = 0x0001',
        summary: 'Do not shrink on the west side of domain.'
      },
      {
        signature: 'DoNotShrinkSouthSide = 0x0002',
        summary: 'Do not shrink on the south side of domain.'
      },
      {
        signature: 'DoNotShrinkEastSide = 0x0004',
        summary: 'Do not shrink on the east side of domain.'
      },
      {
        signature: 'DoNotShrinkNorthSide = 0x0008',
        summary: 'Do not shrink on the north side of domain.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BrepLoop',
    dataType: 1,
    summary: `Represent a single loop in a Brep object. A loop is composed
   of a list of trim curves.`,
    baseclass: 'Rhino.Geometry.GeometryBase',
    properties: [
      {
        signature: 'Brep Brep',
        summary: 'Gets the Brep that owns this loop.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BrepFace Face',
        summary: 'BrepFace this loop belongs to.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int LoopIndex',
        summary: 'Gets the index of this loop in the Brep.Loops collection.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BrepLoopType LoopType',
        summary: 'type of loop.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BrepTrimList Trims',
        summary: 'List of trims for this loop',
        since: 5.1,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Curve To2dCurve()',
        summary: 'Create a 2d curve that traces the entire loop',
        since: 5.1
      },
      {
        signature: 'Curve To3dCurve()',
        summary: 'Create a 3D curve that approximates the loop geometry.',
        since: 5,
        returns: 'A 3D curve that approximates the loop or None on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BrepLoopType',
    dataType: 3,
    summary: 'Each brep loop has a defined type, e.g. outer, inner or point on surface.',
    values: [
      {
        signature: 'Unknown = 0',
        summary: 'Unknown loop type.'
      },
      {
        signature: 'Outer = 1',
        summary: '2d loop curves form a simple closed curve with a counterclockwise orientation.'
      },
      {
        signature: 'Inner = 2',
        summary: '2d loop curves form a simple closed curve with a clockwise orientation.'
      },
      {
        signature: 'Slit = 3',
        summary: 'Always closed - used internally during splitting operations.'
      },
      {
        signature: 'CurveOnSurface = 4',
        summary: `"loop" is a curveonsrf made from a single (open or closed) trim that
     has type TrimType.CurveOnSurface.`
      },
      {
        signature: 'PointOnSurface = 5',
        summary: `"loop" is a PointOnSurface made from a single trim that has
     type TrimType.PointOnSurface.`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BrepRegion',
    dataType: 1,
    summary: 'Represents a brep topological region that has sides.',
    baseclass: 'Rhino.Runtime.CommonObject',
    properties: [
      {
        signature: 'BoundingBox BoundingBox',
        summary: 'Gets the region bounding box.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Brep Brep',
        summary: 'Gets a reference to the Brep this region belongs to.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Index',
        summary: 'Gets the index of region in the RegionTopology array.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsFinite',
        summary: 'Gets a value indicating whether this region is finite.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Brep BoundaryBrep()',
        summary: `Gets the boundary of a region as a brep object. If the region is finite,
     the boundary will be a closed  manifold brep. The boundary may have more than one
     connected component.`,
        since: 5,
        returns: 'A brep or None on error.'
      },
      {
        signature: 'BrepRegionFaceSide[] GetFaceSides()',
        summary: 'Gets an array of BrepRegionFaceSide entities delimiting this region.',
        since: 5,
        returns: 'An array of region face sides. This array might be empty on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BrepRegionFaceSide',
    dataType: 1,
    summary: 'Represents a side of a BrepRegion entity.',
    baseclass: 'Rhino.Runtime.CommonObject',
    properties: [
      {
        signature: 'Brep Brep',
        summary: 'The brep this side belongs to.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BrepFace Face',
        summary: 'Gets the face this side belongs to.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BrepRegion Region',
        summary: 'The region this side belongs to.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool SurfaceNormalPointsIntoRegion',
        summary: 'Gets True if BrepFace\'s surface normal points into region; False otherwise.',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BrepSolidOrientation',
    dataType: 3,
    summary: 'Enumerates all possible Solid Orientations for a Brep.',
    values: [
      {
        signature: 'None = 0',
        summary: 'Brep is not a Solid.'
      },
      {
        signature: 'Inward = -1',
        summary: 'Brep is a Solid with inward facing normals.'
      },
      {
        signature: 'Outward = 1',
        summary: 'Brep is a Solid with outward facing normals.'
      },
      {
        signature: 'Unknown = 2',
        summary: 'Breps is a Solid but no orientation could be computed.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BrepTrim',
    dataType: 1,
    summary: `Brep trim information is stored in BrepTrim classes. Brep.Trims is an
   array of all the trims in the brep. A BrepTrim is derived from CurveProxy
   so the trim can supply easy to use evaluation tools via the Curve virtual
   member functions.
   Note well that the domains and orientations of the curve m_C2[trim.m_c2i]
   and the trim as a curve may not agree.`,
    baseclass: 'Rhino.Geometry.CurveProxy',
    properties: [
      {
        signature: 'Brep Brep',
        summary: 'Gets the Brep that owns this trim.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'BrepEdge Edge',
        summary: 'Brep edge this trim belongs to. This will be None for singular trims',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'BrepVertex EndVertex',
        summary: 'BrepVertex at end of trim',
        since: 6,
        property: ['get']
      },
      {
        signature: 'BrepFace Face',
        summary: 'Brep face this trim belongs to',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'IsoStatus IsoStatus',
        since: 5.6,
        property: ['get', 'set']
      },
      {
        signature: 'BrepLoop Loop',
        summary: 'Loop that this trim belongs to',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'BrepVertex StartVertex',
        summary: 'BrepVertex at start of trim',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Curve TrimCurve',
        summary: 'Gets the Brep.Curves2D 2d curve geometry used by this trim, or null.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int TrimCurveIndex',
        summary: 'Gets the Brep.Curves2D 2d curve index of the 2d curve geometry used by this trim, or -1.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int TrimIndex',
        summary: 'Gets the index of this trim in the Brep.Trims collection.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'BrepTrimType TrimType',
        summary: 'Type of trim',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void GetTolerances(double toleranceU,double toleranceV)',
        summary: `The values in tolerance[] record the accuracy of the parameter space
     trimming curves.`,
        since: 5.6
      },
      {
        signature: 'bool GetTrimParameter(double edgeParameter,double trimParameter)',
        summary: 'Get corresponding trim parameter at given edge parameter.',
        since: 5.12,
        returns: 'True on success'
      },
      {
        signature: 'bool IsReversed()',
        summary: 'Get orientation of trim with respect to it\'s corresponding edge.',
        since: 5.12,
        returns: 'True if the 2d trim and 3d edge have opposite orientations'
      },
      {
        signature: 'void SetTolerances(double toleranceU,double toleranceV)',
        summary: `The values in tolerance[] record the accuracy of the parameter space
     trimming curves.`,
        since: 5.6
      },
      {
        signature: 'bool SetTrimCurve(int curve2dIndex)',
        summary: 'Set 2d curve geometry used by a b-rep trim.',
        since: 5.4,
        parameters: [
          {
            name: 'curve2dIndex',
            summary: 'index of 2d curve in m_C2[] array'
          }
        ],
        returns: 'True if successful'
      },
      {
        signature: 'bool SetTrimCurve(int curve2dIndex,Interval subDomain)',
        summary: 'Set 2d curve geometry used by a b-rep trim.',
        since: 5.4,
        parameters: [
          {
            name: 'curve2dIndex',
            summary: 'index of 2d curve in m_C2[] array'
          },
          {
            name: 'subDomain',
            summary: ''
          }
        ],
        returns: 'True if successful'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BrepTrimType',
    dataType: 3,
    summary: 'Each brep trim has a defined type.',
    values: [
      {
        signature: 'Unknown = 0',
        summary: 'Unknown type'
      },
      {
        signature: 'Boundary = 1',
        summary: `Trim is connected to an edge, is part of an outer, inner or
     slit loop, and is the only trim connected to the edge.`
      },
      {
        signature: 'Mated = 2',
        summary: `Trim is connected to an edge, is part of an outer, inner or slit loop,
     no other trim from the same loop is connected to the edge, and at least
     one trim from a different loop is connected to the edge.`
      },
      {
        signature: 'Seam = 3',
        summary: `trim is connected to an edge, is part of an outer, inner or slit loop,
     and one other trim from the same loop is connected to the edge.
     (There can be other mated trims that are also connected to the edge.
     For example, the non-mainfold edge that results when a surface edge lies
     in the middle of another surface.)  Non-mainfold "cuts" have seam trims too.`
      },
      {
        signature: 'Singular = 4',
        summary: `Trim is part of an outer loop, the trim's 2d curve runs along the singular
     side of a surface, and the trim is NOT connected to an edge. (There is
     no 3d edge because the surface side is singular.)`
      },
      {
        signature: 'CurveOnSurface = 5',
        summary: `Trim is connected to an edge, is the only trim in a crfonsrf loop, and
     is the only trim connected to the edge.`
      },
      {
        signature: 'PointOnSurface = 6',
        summary: `Trim is a point on a surface, trim.m_pbox is records surface parameters,
     and is the only trim in a ptonsrf loop.  This trim is not connected to
     an edge and has no 2d curve.`
      },
      {
        signature: 'Slit = 7'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'BrepVertex',
    dataType: 1,
    summary: 'Brep vertex information',
    baseclass: 'Rhino.Geometry.Point',
    properties: [
      {
        signature: 'Brep Brep',
        summary: 'Gets the Brep that owns this vertex.',
        since: 5.4,
        property: ['get']
      },
      {
        signature: 'int VertexIndex',
        summary: 'Gets the index of this vertex in the Brep.Vertices collection.',
        since: 5.4,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int[] EdgeIndices()',
        summary: 'Gets the indices of all edges associated with this vertex.',
        since: 5.12,
        returns: 'Empty array on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Centermark',
    dataType: 1,
    summary: 'Represents a centermark',
    baseclass: 'Dimension',
    constructors: [
      {
        signature: 'Centermark()',
        since: 6
      }
    ],
    methods: [
      {
        signature: 'static Centermark Create(DimensionStyle dimStyle,Plane plane,Point3d centerpoint,double radius)',
        summary: 'Create a new centermark',
        since: 6,
        parameters: [
          {
            name: 'dimStyle',
            summary: 'Dimension\'s AnnotationStyle'
          },
          {
            name: 'plane',
            summary: 'Dimension\'s plane'
          },
          {
            name: 'centerpoint',
            summary: 'Dimension\'s center point'
          },
          {
            name: 'radius',
            summary: 'Centermark;s radius'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Circle',
    dataType: 2,
    summary: `Represents a circle in 3D.
   The values used are a radius and an orthonormal frame of the plane containing the circle,
   with origin at the center.The circle is parameterized by radians from 0 to 2 Pi given byt -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxiswhere center, xaxis and yaxis define the orthonormal frame of the circle plane.`,
    constructors: [
      {
        signature: 'Circle(Arc arc)',
        summary: 'Initializes a circle from an arc.',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'Arc that defines the plane and radius.'
          }
        ]
      },
      {
        signature: 'Circle(double radius)',
        summary: 'Initializes a circle with center (0,0,0) in the world XY plane.',
        since: 5,
        parameters: [
          {
            name: 'radius',
            summary: 'Radius of circle, should be a positive number.'
          }
        ]
      },
      {
        signature: 'Circle(Plane plane,double radius)',
        summary: 'Initializes a circle on a plane with a given radius.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane of circle. Plane origin defines the center of the circle.'
          },
          {
            name: 'radius',
            summary: 'Radius of circle (should be a positive value).'
          }
        ]
      },
      {
        signature: 'Circle(Plane plane,Point3d center,double radius)',
        summary: 'Initializes a circle parallel to a given plane with given center and radius.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane for circle.'
          },
          {
            name: 'center',
            summary: 'Center point override.'
          },
          {
            name: 'radius',
            summary: 'Radius of circle (should be a positive value).'
          }
        ]
      },
      {
        signature: 'Circle(Point3d center,double radius)',
        summary: 'Initializes a circle parallel to the world XY plane with given center and radius.',
        since: 5,
        parameters: [
          {
            name: 'center',
            summary: 'Center of circle.'
          },
          {
            name: 'radius',
            summary: 'Radius of circle (should be a positive value).'
          }
        ]
      },
      {
        signature: 'Circle(Point3d point1,Point3d point2,Point3d point3)',
        summary: 'Initializes a circle through three 3d points.',
        since: 5,
        parameters: [
          {
            name: 'point1',
            summary: 'The start/end of the circle is at point1.'
          },
          {
            name: 'point2',
            summary: 'Second point on the circle.'
          },
          {
            name: 'point3',
            summary: 'Third point on the circle.'
          }
        ]
      },
      {
        signature: 'Circle(Point3d startPoint,Vector3d tangentAtP,Point3d pointOnCircle)',
        summary: `Initializes a circle from two 3d points and a tangent at the first point.
     The start/end of the circle is at point "startPoint".`,
        since: 5,
        parameters: [
          {
            name: 'startPoint',
            summary: 'Start point of circle.'
          },
          {
            name: 'tangentAtP',
            summary: 'Tangent vector at start.'
          },
          {
            name: 'pointOnCircle',
            summary: 'Point coincident with desired circle.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Circle Unset',
        summary: 'Gets a circle with Unset components.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BoundingBox BoundingBox',
        summary: 'Gets the circle\'s 3d axis aligned bounding box.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d Center',
        summary: 'Gets or sets the center point of this circle.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Circumference',
        summary: 'Gets or sets the circumference of this circle.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Diameter',
        summary: `Gets or sets the diameter (radius * 2.0) of this circle. 
     Diameters should be positive values.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsValid',
        summary: 'A valid circle has radius larger than 0.0 and a base plane which is must also be valid.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d Normal',
        summary: 'Gets the normal vector for this circle.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Plane Plane',
        summary: 'Gets or sets the plane of the circle.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Radius',
        summary: `Gets or sets the radius of this circle. 
     Radii should be positive values.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static bool TryFitCircleToPoints(IEnumerable<Point3d> points,Circle circle)',
        summary: 'Attempt to fit a circle through a set of points.',
        since: 6.2,
        parameters: [
          {
            name: 'points',
            summary: 'The points through which to fit.'
          },
          {
            name: 'circle',
            summary: 'The resulting circle on success.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'static Circle TryFitCircleTT(Curve c1,Curve c2,double t1,double t2)',
        summary: 'Try to fit a circle to two curves using tangent relationships.',
        since: 5,
        parameters: [
          {
            name: 'c1',
            summary: 'First curve to touch.'
          },
          {
            name: 'c2',
            summary: 'Second curve to touch.'
          },
          {
            name: 't1',
            summary: 'Parameter on first curve close to desired solution.'
          },
          {
            name: 't2',
            summary: 'Parameter on second curve closet to desired solution.'
          }
        ],
        returns: 'Valid circle on success, Circle.Unset on failure.'
      },
      {
        signature: 'static Circle TryFitCircleTTT(Curve c1,Curve c2,Curve c3,double t1,double t2,double t3)',
        summary: 'Try to fit a circle to three curves using tangent relationships.',
        since: 5,
        parameters: [
          {
            name: 'c1',
            summary: 'First curve to touch.'
          },
          {
            name: 'c2',
            summary: 'Second curve to touch.'
          },
          {
            name: 'c3',
            summary: 'Third curve to touch.'
          },
          {
            name: 't1',
            summary: 'Parameter on first curve close to desired solution.'
          },
          {
            name: 't2',
            summary: 'Parameter on second curve closet to desired solution.'
          },
          {
            name: 't3',
            summary: 'Parameter on third curve close to desired solution.'
          }
        ],
        returns: 'Valid circle on success, Circle.Unset on failure.'
      },
      {
        signature: 'bool ClosestParameter(Point3d testPoint,double t)',
        summary: 'Gets the parameter on the circle which is closest to a test point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to project onto the circle.'
          },
          {
            name: 't',
            summary: 'Parameter on circle closes to testPoint.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'Point3d ClosestPoint(Point3d testPoint)',
        summary: 'Gets the point on the circle which is closest to a test point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to project onto the circle.'
          }
        ],
        returns: `The point on the circle that is closest to testPoint or
     Point3d.Unset on failure.`
      },
      {
        signature: 'Vector3d DerivativeAt(int derivative,double t)',
        summary: 'Determines the value of the Nth derivative at a parameter.',
        since: 5,
        parameters: [
          {
            name: 'derivative',
            summary: 'Which order of derivative is wanted.'
          },
          {
            name: 't',
            summary: 'Parameter to evaluate derivative. Valid values are 0, 1, 2 and 3.'
          }
        ],
        returns: 'The derivative of the circle at the given parameter.'
      },
      {
        signature: 'bool EpsilonEquals(Circle other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool IsInPlane(Plane plane,double tolerance)',
        summary: 'Evaluates whether or not this circle is co-planar with a given plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use.'
          }
        ],
        returns: 'True if the circle plane is co-planar with the given plane within tolerance.'
      },
      {
        signature: 'Point3d PointAt(double t)',
        summary: `Circles use trigonometric parameterization: 
     t -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis.`,
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Parameter of point to evaluate.'
          }
        ],
        returns: 'The point on the circle at the given parameter.'
      },
      {
        signature: 'void Reverse()',
        summary: `Reverse the orientation of the circle. Changes the domain from [a,b]
     to [-b,-a].`,
        since: 5
      },
      {
        signature: 'bool Rotate(double sinAngle,double cosAngle,Vector3d axis)',
        summary: 'Rotates the circle around an axis that starts at the base plane origin.',
        since: 5,
        parameters: [
          {
            name: 'sinAngle',
            summary: 'The value returned by Math.Sin(angle) to compose the rotation.'
          },
          {
            name: 'cosAngle',
            summary: 'The value returned by Math.Cos(angle) to compose the rotation.'
          },
          {
            name: 'axis',
            summary: 'A rotation axis.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Rotate(double sinAngle,double cosAngle,Vector3d axis,Point3d point)',
        summary: 'Rotates the circle around an axis that starts at the provided point.',
        since: 5,
        parameters: [
          {
            name: 'sinAngle',
            summary: 'The value returned by Math.Sin(angle) to compose the rotation.'
          },
          {
            name: 'cosAngle',
            summary: 'The value returned by Math.Cos(angle) to compose the rotation.'
          },
          {
            name: 'axis',
            summary: 'A rotation direction.'
          },
          {
            name: 'point',
            summary: 'A rotation base point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Rotate(double angle,Vector3d axis)',
        summary: 'Rotates the circle through a given angle.',
        since: 5,
        parameters: [
          {
            name: 'angle',
            summary: 'Angle (in radians) of the rotation.'
          },
          {
            name: 'axis',
            summary: 'Rotation axis.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Rotate(double angle,Vector3d axis,Point3d point)',
        summary: 'Rotates the circle through a given angle.',
        since: 5,
        parameters: [
          {
            name: 'angle',
            summary: 'Angle (in radians) of the rotation.'
          },
          {
            name: 'axis',
            summary: 'Rotation axis.'
          },
          {
            name: 'point',
            summary: 'Rotation anchor point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'Vector3d TangentAt(double t)',
        summary: `Circles use trigonometric parameterization: 
     t -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis.`,
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Parameter of tangent to evaluate.'
          }
        ],
        returns: 'The tangent at the circle at the given parameter.'
      },
      {
        signature: 'NurbsCurve ToNurbsCurve()',
        summary: `Constructs a nurbs curve representation of this circle. 
     This amounts to the same as calling NurbsCurve.CreateFromCircle().`,
        since: 5,
        returns: 'A nurbs curve representation of this circle or None if no such representation could be made.'
      },
      {
        signature: 'NurbsCurve ToNurbsCurve(int degree,int cvCount)',
        summary: 'Create a uniform non-ratonal cubic NURBS approximation of a circle.',
        since: 6,
        parameters: [
          {
            name: 'degree',
            summary: '>=1'
          },
          {
            name: 'cvCount',
            summary: 'cv count >=5'
          }
        ],
        returns: 'NURBS curve approximation of a circle on success'
      },
      {
        signature: 'bool Transform(Transform xform)',
        summary: 'Transforms this circle using an xform matrix.',
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation to apply.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Translate(Vector3d delta)',
        summary: 'Moves the circle.',
        since: 5,
        parameters: [
          {
            name: 'delta',
            summary: 'Translation vector.'
          }
        ],
        returns: 'True on success, False on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'ClippingPlaneSurface',
    dataType: 1,
    summary: `Represents a planar surface that is used as clipping plane in viewports.
   A clipping plane object maintains a list of viewports that it clips against.`,
    baseclass: 'Rhino.Geometry.PlaneSurface',
    properties: [
      {
        signature: 'Plane Plane',
        summary: 'Gets or sets the clipping plane.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'bool AddClipViewportId(Guid viewportId)',
        summary: 'Adds a viewport id to the list of viewports that this clipping plane clips.',
        since: 6.1,
        parameters: [
          {
            name: 'viewportId',
            summary: 'The id of the RhinoViewport to add.'
          }
        ],
        returns: 'True if the viewport was added, False if the viewport is already in the list.'
      },
      {
        signature: 'bool RemoveClipViewportId(Guid viewportId)',
        summary: 'Removes a viewport id that this being clipped by this clipping plane.',
        since: 6.1,
        parameters: [
          {
            name: 'viewportId',
            summary: 'The id of the RhinoViewport to remove.'
          }
        ],
        returns: 'True if the viewport was removed, False if the viewport was not in the list.'
      },
      {
        signature: 'Guid[] ViewportIds()',
        summary: 'Returns the ids of RhinoViewport objects that are clipped by this clipping plane.',
        since: 5,
        returns: 'The ids of RhinoViewport objects.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'BrepCurveList',
    dataType: 1,
    summary: 'Provides access to all the underlying curves in a Brep object.',
    interfaces: ['IEnumerable<Curve>', 'Rhino.Collections.IRhinoTable<Curve>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of curves in this list.',
        since: 5.6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int Add(Curve curve)',
        summary: 'Adds a curve',
        since: 5.6,
        parameters: [
          {
            name: 'curve',
            summary: 'A copy of the curve is added to this brep'
          }
        ],
        returns: `Index that should be used to reference the geometry.
     -1 is returned if the input is not acceptable.`
      },
      {
        signature: 'IEnumerator<Curve> GetEnumerator()',
        summary: 'Get an enumerator that visits all curves.',
        since: 5.6,
        returns: 'The enumerator.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'BrepEdgeList',
    dataType: 1,
    summary: 'Provides access to all the Edges in a Brep object.',
    interfaces: ['IEnumerable<BrepEdge>', 'Rhino.Collections.IRhinoTable<BrepEdge>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of brep edges.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'BrepEdge Add(BrepVertex startVertex,BrepVertex endVertex,int curve3dIndex,double edgeTolerance)',
        summary: 'Create and add a new edge to this list',
        since: 5.4
      },
      {
        signature: 'BrepEdge Add(BrepVertex startVertex,BrepVertex endVertex,int curve3dIndex,Interval subDomain,double edgeTolerance)',
        summary: 'Create and add a new edge to this list',
        since: 5.4
      },
      {
        signature: 'BrepEdge Add(int curve3dIndex)',
        summary: 'Create and add a new edge to this list',
        since: 5.4
      },
      {
        signature: 'BrepEdge Add(int startVertexIndex,int endVertexIndex,int curve3dIndex,double edgeTolerance)',
        summary: 'Create and add a new edge to this list',
        since: 5.6
      },
      {
        signature: 'BrepEdge Add(int startVertexIndex,int endVertexIndex,int curve3dIndex,Interval subDomain,double edgeTolerance)',
        summary: 'Create and add a new edge to this list',
        since: 5.6
      },
      {
        signature: 'IEnumerator<BrepEdge> GetEnumerator()',
        summary: 'Gets an enumerator that visits all edges.',
        since: 5,
        returns: 'The enumerator.'
      },
      {
        signature: 'int MergeAllEdges(double angleTolerance)',
        summary: `Merges all possible Brep edges. Edges across kinks cannot be merged.
     A pair of adjacent edges in a Brep  are mergable if the angle between them is less than tolerance and the valence of the shared vertex is 2.`,
        since: 6.23,
        parameters: [
          {
            name: 'angleTolerance',
            summary: 'The maximum allowable difference of angle in radian between adjacent edges that can be merged.'
          }
        ],
        returns: 'The number of edges merged.'
      },
      {
        signature: 'int MergeEdge(int edgeIndex,double angleTolerance)',
        summary: `Merge adjacent edges to a specified edge recursively.
     A pair of adjacent edges in a Brep  are mergable if the angle between them is less than tolerance and the valence of the shared vertex is 2.`,
        since: 6.23,
        parameters: [
          {
            name: 'edgeIndex',
            summary: '>Index of edge to merge.'
          },
          {
            name: 'angleTolerance',
            summary: 'The maximum allowable difference of angle in radian between adjacent edges that can be merged.'
          }
        ],
        returns: 'The number of edges merged.'
      },
      {
        signature: 'int SplitEdgeAtParameters(int edgeIndex,IEnumerable<double> edgeParameters)',
        summary: 'Splits an edge at the specified parameters.',
        since: 5,
        parameters: [
          {
            name: 'edgeIndex',
            summary: 'The index of the edge to be addressed.'
          },
          {
            name: 'edgeParameters',
            summary: 'The parameter along that edge.'
          }
        ],
        returns: 'Number of splits applied to the edge.'
      },
      {
        signature: 'bool SplitKinkyEdge(int edgeIndex,double kinkToleranceRadians)',
        summary: 'Splits the edge into G1 pieces.',
        since: 5,
        parameters: [
          {
            name: 'edgeIndex',
            summary: 'Index of edge to test and split.'
          },
          {
            name: 'kinkToleranceRadians',
            summary: 'The split tolerance in radians.'
          }
        ],
        returns: 'True if successful.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'BrepFaceList',
    dataType: 1,
    summary: 'Provides access to all the Faces in a Brep object.',
    interfaces: ['IEnumerable<BrepFace>', 'Rhino.Collections.IRhinoTable<BrepFace>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of brep faces.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'BrepFace Add(int surfaceIndex)',
        summary: `Create and add a new face to this list. An incomplete face is added.
     The caller must create and fill in the loops used by the face.`,
        since: 5.4,
        parameters: [
          {
            name: 'surfaceIndex',
            summary: 'index of surface in brep\'s Surfaces list'
          }
        ]
      },
      {
        signature: 'BrepFace Add(Surface surface)',
        summary: `Add a new face to a brep.  This creates a complete face with
     new vertices at the surface corners, new edges along the surface
     boundary, etc.  The loop of the returned face has four trims that
     correspond to the south, east, north, and west side of the 
     surface in that order.  If you use this version of Add to
     add an exiting brep, then you are responsible for using a tool
     like JoinEdges() to hook the new face to its neighbors.`,
        since: 5.4,
        parameters: [
          {
            name: 'surface',
            summary: 'surface is copied'
          }
        ]
      },
      {
        signature: 'BrepFace AddConeFace(BrepVertex vertex,BrepEdge edge,bool revEdge)',
        summary: `Add a new face to the brep whose surface geometry is a 
     ruled cone with the edge as the base and the vertex as
     the apex point.`,
        since: 5.4,
        parameters: [
          {
            name: 'vertex',
            summary: `The apex of the cone will be at this vertex.
     The north side of the surface's parameter
     space will be a singular point at the vertex.`
          },
          {
            name: 'edge',
            summary: 'The south side of the face\'s surface will run along this edge.'
          },
          {
            name: 'revEdge',
            summary: `True if the new face's outer boundary orientation along
     the edge is opposite the orientation of edge.`
          }
        ]
      },
      {
        signature: 'BrepFace AddRuledFace(BrepEdge edgeA,bool revEdgeA,BrepEdge edgeB,bool revEdgeB)',
        summary: `Add a new face to the brep whose surface geometry is a 
     ruled surface between two edges.`,
        since: 5.4,
        parameters: [
          {
            name: 'edgeA',
            summary: 'The south side of the face\'s surface will run along edgeA.'
          },
          {
            name: 'revEdgeA',
            summary: `True if the new face's outer boundary orientation along
     edgeA is opposite the orientation of edgeA.`
          },
          {
            name: 'edgeB',
            summary: 'The north side of the face\'s surface will run along edgeA'
          },
          {
            name: 'revEdgeB',
            summary: `True if the new face's outer boundary orientation along
     edgeB is opposite the orientation of edgeB`
          }
        ]
      },
      {
        signature: 'Brep ExtractFace(int faceIndex)',
        summary: 'Extracts a face from a Brep.',
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'A face index'
          }
        ],
        returns: 'A brep. This can be null.'
      },
      {
        signature: 'void Flip(bool onlyReversedFaces)',
        summary: 'Flips the orientation of faces.',
        since: 5,
        parameters: [
          {
            name: 'onlyReversedFaces',
            summary: `If true, clears all BrepFace.OrientationIsReversed flags by calling BrepFace.Transpose()
     on each face with a True OrientationIsReversed setting.
     If false, all of the faces are flipped regardless of their orientation.`
          }
        ]
      },
      {
        signature: 'IEnumerator<BrepFace> GetEnumerator()',
        summary: 'Gets an enumerators that yields BrepFace objects.',
        since: 5,
        returns: 'The enumerator.'
      },
      {
        signature: 'void RemoveAt(int faceIndex)',
        summary: 'Deletes a face at a specified index.',
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'The index of the mesh face.'
          }
        ]
      },
      {
        signature: 'bool RemoveSlits()',
        summary: 'Remove slit trims and slit boundaries from each face.',
        since: 5.1,
        returns: 'True if any slits were removed'
      },
      {
        signature: 'bool ShrinkFaces()',
        summary: `Shrinks all the underlying surfaces in this Brep. 
     Sometimes the surfaces extend far beyond the trimming boundaries of the Brep Face. 
     This function will remove those portions of the surfaces that are not used.`,
        since: 5,
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SplitBipolarFaces()',
        summary: `Splits surfaces with two singularities, like spheres, so the results
     have at most one singularity.`,
        since: 5,
        returns: 'True if successful.'
      },
      {
        signature: 'bool SplitClosedFaces(int minimumDegree)',
        summary: 'Splits closed surfaces so they are not closed.',
        since: 5,
        parameters: [
          {
            name: 'minimumDegree',
            summary: `If the degree of the surface < min_degree, the surface is not split.
     In some cases, minimumDegree = 2 is useful to preserve piecewise linear
     surfaces.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool SplitFaceAtTangents(int faceIndex)',
        summary: 'Splits the face of a Brep at tangent locations.',
        since: 6,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'The index of the face to split.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool SplitFacesAtTangents()',
        summary: 'Splits all of the faces of a Brep at tangent locations.',
        since: 6,
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool SplitKinkyFace(int faceIndex,double kinkTolerance)',
        summary: 'Splits a single face into G1 pieces.',
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'The index of the face to split.'
          },
          {
            name: 'kinkTolerance',
            summary: 'Tolerance (in radians) to use for crease detection.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SplitKinkyFaces()',
        summary: 'Splits any faces with creases into G1 pieces.',
        since: 5,
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SplitKinkyFaces(double kinkTolerance)',
        summary: 'Splits any faces with creases into G1 pieces.',
        since: 5,
        parameters: [
          {
            name: 'kinkTolerance',
            summary: 'Tolerance (in radians) to use for crease detection.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SplitKinkyFaces(double kinkTolerance,bool compact)',
        summary: 'Splits any faces with creases into G1 pieces.',
        since: 5,
        parameters: [
          {
            name: 'kinkTolerance',
            summary: 'Tolerance (in radians) to use for crease detection.'
          },
          {
            name: 'compact',
            summary: 'If true, the Brep will be compacted if possible.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool StandardizeFaceSurface(int faceIndex)',
        summary: `Standardizes the relationship between a BrepFace and the 3d surface it
     uses.  When done, the face will be the only face that references its 3d
     surface, and the orientations of the face and 3d surface will be the same.`,
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'The index of the face.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'void StandardizeFaceSurfaces()',
        summary: 'Standardize all faces in the brep.',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'BrepLoopList',
    dataType: 1,
    summary: 'Provides access to all the Loops in a Brep object.',
    interfaces: ['IEnumerable<BrepLoop>', 'Rhino.Collections.IRhinoTable<BrepLoop>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of brep loops.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'BrepLoop Add(BrepLoopType loopType)',
        summary: `Create a new empty boundary loop. The new loop will not be part of a face and
     will not include any trim curves.`,
        since: 5.4
      },
      {
        signature: 'BrepLoop Add(BrepLoopType loopType,BrepFace face)',
        summary: `Create a new boundary loop on a face.  After you get this
     BrepLoop, you still need to create the vertices, edges, 
     and trims that define the loop.`,
        since: 5.4,
        returns: 'New loop that needs to be filled in'
      },
      {
        signature: 'BrepLoop AddOuterLoop(int faceIndex)',
        summary: `Create a new outer boundary loop that runs along the sides
     of the face's surface.  All the necessary trims, edges,
     and vertices are created and added to the brep.`,
        since: 5.4,
        parameters: [
          {
            name: 'faceIndex',
            summary: `index of face that needs an outer boundary
     that runs along the sides of its surface.`
          }
        ],
        returns: 'New outer boundary loop that is complete.'
      },
      {
        signature: 'BrepLoop AddPlanarFaceLoop(int faceIndex,BrepLoopType loopType,IEnumerable<Curve> boundaryCurves)',
        summary: 'Add a planar trimming loop to a planar face',
        since: 5.4,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'index of planar face.  The underlying suface must be a PlaneSurface'
          },
          {
            name: 'loopType',
            summary: `type of loop to add.  If loopType is Unknown, then the loop direction
     is tested and the the new loops type will be set to Outer or Inner.
     If the loopType is Outer, then the direction of the new loop is tested
     and flipped if it is clockwise. If the loopType is Inner, then the
     direction of the new loop is tested and flipped if it is counter-clockwise.`
          },
          {
            name: 'boundaryCurves',
            summary: `list of 3d curves that form a simple (no self intersections) closed
     curve.  These curves define the 3d edge geometry and should be near
     the planar surface.`
          }
        ],
        returns: 'new loop if successful'
      },
      {
        signature: 'IEnumerator<BrepLoop> GetEnumerator()',
        summary: 'Gets an enumerator that visits all edges.',
        since: 5,
        returns: 'The enumerator.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'BrepSurfaceList',
    dataType: 1,
    summary: 'Provides access to all the underlying surfaces in a Brep object.',
    interfaces: ['IEnumerable<Surface>', 'Rhino.Collections.IRhinoTable<Surface>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of surfaces in a brep.',
        since: 5.4,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'IEnumerator<Surface> GetEnumerator()',
        summary: 'Gets an enumerator that visits all surfaces.',
        since: 5.4,
        returns: 'The enumerator.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'BrepTrimList',
    dataType: 1,
    summary: 'Provides access to all the Trims in a Brep object',
    interfaces: ['IEnumerable<BrepTrim>', 'Rhino.Collections.IRhinoTable<BrepTrim>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of brep trims.',
        since: 5.1,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'BrepTrim Add(bool rev3d,BrepEdge edge,int curve2dIndex)',
        summary: `Add a new trim that will be part of an inner, outer, or slit loop
     to the brep`,
        since: 5.4,
        parameters: [
          {
            name: 'rev3d',
            summary: 'True if the edge and trim have opposite directions'
          },
          {
            name: 'edge',
            summary: '3d edge associated with this trim'
          },
          {
            name: 'curve2dIndex',
            summary: 'index of 2d trimming curve'
          }
        ],
        returns: 'new trim'
      },
      {
        signature: 'BrepTrim Add(bool rev3d,BrepLoop loop,int curve2dIndex)',
        summary: `Add a new trim that will be part of an inner, outer, or slit loop
     to the brep`,
        since: 5.4,
        parameters: [
          {
            name: 'rev3d',
            summary: 'True if the edge and trim have opposite directions'
          },
          {
            name: 'loop',
            summary: 'trim is appended to this loop'
          },
          {
            name: 'curve2dIndex',
            summary: 'index of 2d trimming curve'
          }
        ],
        returns: 'new trim'
      },
      {
        signature: 'BrepTrim Add(BrepEdge edge,bool rev3d,BrepLoop loop,int curve2dIndex)',
        summary: `Add a new trim that will be part of an inner, outer, or slit loop
     to the brep.`,
        since: 5.4,
        parameters: [
          {
            name: 'edge',
            summary: '3d edge associated with this trim'
          },
          {
            name: 'rev3d',
            summary: 'True if the edge and trim have opposite directions'
          },
          {
            name: 'loop',
            summary: 'trim is appended to this loop'
          },
          {
            name: 'curve2dIndex',
            summary: 'index of 2d trimming curve'
          }
        ],
        returns: 'new trim'
      },
      {
        signature: 'BrepTrim Add(int curve2dIndex)',
        summary: `Add a new trim that will be part of an inner, outer, or slit loop
     to the brep.`,
        since: 5.4,
        parameters: [
          {
            name: 'curve2dIndex',
            summary: 'index of 2d trimming curve'
          }
        ],
        returns: 'New Trim'
      },
      {
        signature: 'BrepTrim AddCurveOnFace(BrepFace face,BrepEdge edge,bool rev3d,int curve2dIndex)',
        summary: 'Add a new curve on face to the brep',
        since: 5.4,
        parameters: [
          {
            name: 'face',
            summary: 'face that curve lies on'
          },
          {
            name: 'edge',
            summary: '3d edge associated with this curve on surface'
          },
          {
            name: 'rev3d',
            summary: 'True if the 3d edge and the 2d parameter space curve have opposite directions.'
          },
          {
            name: 'curve2dIndex',
            summary: 'index of 2d curve in face\'s parameter space'
          }
        ],
        returns: 'new trim that represents the curve on surface'
      },
      {
        signature: 'BrepTrim AddSingularTrim(BrepVertex vertex,BrepLoop loop,IsoStatus iso,int curve2dIndex)',
        summary: 'Add a new singular trim to the brep.',
        since: 5.4,
        parameters: [
          {
            name: 'vertex',
            summary: 'vertex along collapsed surface edge'
          },
          {
            name: 'loop',
            summary: 'trim is appended to this loop'
          },
          {
            name: 'iso',
            summary: ''
          },
          {
            name: 'curve2dIndex',
            summary: 'index of 2d trimming curve'
          }
        ],
        returns: 'new trim'
      },
      {
        signature: 'IEnumerator<BrepTrim> GetEnumerator()',
        summary: 'Gets an enumerator that visits all edges.',
        since: 5.1,
        returns: 'The enumerator.'
      },
      {
        signature: 'bool MatchEnds()',
        summary: 'Matches the endpoints of all trims in the Brep.',
        since: 6.19,
        returns: 'True if any trim\'s 2d curve is changed, False otherwise.'
      },
      {
        signature: 'bool MatchEnds(BrepLoop loop)',
        summary: 'Match the endpoints of all trims in a loop.',
        since: 6.19,
        parameters: [
          {
            name: 'loop',
            summary: 'The Brep loop.'
          }
        ],
        returns: 'True if any trim\'s 2d curve is changed, False otherwise.'
      },
      {
        signature: 'bool MatchEnds(BrepTrim trim0,BrepTrim trim1)',
        summary: 'Match the end of a trim to the start of the next trim.',
        since: 6.19,
        parameters: [
          {
            name: 'trim0',
            summary: 'The Brep trim.'
          },
          {
            name: 'trim1',
            summary: 'Trep trim that comes immediately after trim0 in the same loop.'
          }
        ],
        returns: 'True if either trim\'s 2d curve is changed, False otherwise.'
      },
      {
        signature: 'bool MatchEnds(int trimIndex)',
        summary: 'Match the endpoints of a trim to the next and previous trim.',
        since: 6.19,
        returns: 'True if any trim\'s 2d curve is changed, False otherwise.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'BrepVertexList',
    dataType: 1,
    summary: 'Provides access to all the Vertices in a Brep object',
    interfaces: ['IEnumerable<BrepVertex>', 'Rhino.Collections.IRhinoTable<BrepVertex>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of brep vertices.',
        since: 5.4,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'BrepVertex Add()',
        summary: 'Create and add a new vertex to this list',
        since: 5.4
      },
      {
        signature: 'BrepVertex Add(Point3d point,double vertexTolerance)',
        summary: 'Create and add a new vertex to this list',
        since: 5.4,
        parameters: [
          {
            name: 'point',
            summary: ''
          },
          {
            name: 'vertexTolerance',
            summary: 'Use RhinoMath.UnsetTolerance if you are unsure'
          }
        ]
      },
      {
        signature: 'BrepVertex AddPointOnFace(BrepFace face,double s,double t)',
        summary: 'Adds a new point on face to the brep',
        since: 5.4,
        parameters: [
          {
            name: 'face',
            summary: 'face that vertex lies on'
          },
          {
            name: 's',
            summary: 'surface parameters'
          },
          {
            name: 't',
            summary: 'surface parameters'
          }
        ],
        returns: 'new vertex that represents the point on face'
      },
      {
        signature: 'IEnumerator<BrepVertex> GetEnumerator()',
        summary: 'Gets an enumerator that visits all surfaces.',
        since: 5.4,
        returns: 'The enumerator.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'MeshFaceList',
    dataType: 1,
    summary: 'Provides access to the faces and Face related functionality of a Mesh.',
    interfaces: ['IResizableList<MeshFace>', 'IList', 'IReadOnlyList<MeshFace>'],
    properties: [
      {
        signature: 'int Capacity',
        summary: 'Gets or sets the total number of mesh triangles and quads the internal data structure can hold without resizing.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int Count',
        summary: 'Gets or sets the number of mesh faces. When getting this can includes invalid faces.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int QuadCount',
        summary: 'Gets the number of faces that are valid quads (4 corners).',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int TriangleCount',
        summary: 'Gets the number of faces that are valid triangles (3 corners).',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int AddFace(int vertex1,int vertex2,int vertex3)',
        summary: 'Appends a new triangular face to the end of the mesh face list.',
        since: 5,
        parameters: [
          {
            name: 'vertex1',
            summary: 'Index of first face corner.'
          },
          {
            name: 'vertex2',
            summary: 'Index of second face corner.'
          },
          {
            name: 'vertex3',
            summary: 'Index of third face corner.'
          }
        ],
        returns: 'The index of the newly added triangle.'
      },
      {
        signature: 'int AddFace(int vertex1,int vertex2,int vertex3,int vertex4)',
        summary: 'Appends a new quadragular face to the end of the mesh face list.',
        since: 5,
        parameters: [
          {
            name: 'vertex1',
            summary: 'Index of first face corner.'
          },
          {
            name: 'vertex2',
            summary: 'Index of second face corner.'
          },
          {
            name: 'vertex3',
            summary: 'Index of third face corner.'
          },
          {
            name: 'vertex4',
            summary: 'Index of fourth face corner.'
          }
        ],
        returns: 'The index of the newly added quad.'
      },
      {
        signature: 'int AddFace(MeshFace face)',
        summary: 'Appends a new mesh face to the end of the mesh face list.',
        since: 5,
        parameters: [
          {
            name: 'face',
            summary: 'Face to add.'
          }
        ],
        returns: 'The index of the newly added face.'
      },
      {
        signature: 'int[] AddFaces(IEnumerable<MeshFace> faces)',
        summary: 'Appends a list of faces to the end of the mesh face list.',
        since: 5,
        parameters: [
          {
            name: 'faces',
            summary: 'Faces to add.'
          }
        ],
        returns: 'Indices of the newly created faces'
      },
      {
        signature: 'int[] AdjacentFaces(int faceIndex)',
        summary: 'Gets all faces that share a topological edge with a given face.',
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'A face index.'
          }
        ],
        returns: 'All indices that share an edge.'
      },
      {
        signature: 'void Clear()',
        summary: 'Clears the Face list on the mesh.',
        since: 5
      },
      {
        signature: 'int ConvertNonPlanarQuadsToTriangles(double planarTolerance,double angleToleranceRadians,int splitMethod)',
        summary: 'Splits non-planar quads into two triangles based on given params.',
        since: 6,
        parameters: [
          {
            name: 'planarTolerance',
            summary: `If planarTolerance >= 0, then a quad is split if its vertices
     are not coplanar.  
     If both planarTolerance = Rhino.RhinoMath.UnsetValue and 
     angleToleranceRadians >= 0.0, then the planarity test is skipped.`
          },
          {
            name: 'angleToleranceRadians',
            summary: `If angleToleranceRadians >= 0.0, then a quad is split if the
     angle between opposite corner normals is > angleToleranceRadians.
     The corner normal is the normal to the triangle formed by two
     adjacent edges and the diagonal connecting their endpoints.
     A quad has four corner normals.
     If both angleToleranceRadians = Rhino.RhinoMath.UnsetValue and planarTolerance >= 0.0,
     then the corner normal angle test is skipped.`
          },
          {
            name: 'splitMethod',
            summary: `0 default 
       Currently divides along the short diagonal. This may be
       changed as better methods are found or preferences change.
       By passing zero, you let the developers of this code
       decide what's best for you over time.
     1 divide along the short diagonal
     2 divide along the long diagonal
     3 minimize resulting area
     4 maximize resulting area
     5 minimize angle between triangle normals
     6 maximize angle between triangle normals`
          }
        ],
        returns: 'Number of quads that were converted to triangles.'
      },
      {
        signature: 'bool ConvertQuadsToTriangles()',
        summary: 'Splits all quads along the short diagonal.',
        since: 5,
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool ConvertTrianglesToQuads(double angleToleranceRadians,double minimumDiagonalLengthRatio)',
        summary: 'Joins adjacent triangles into quads if the resulting quad is \'nice\'.',
        since: 5,
        parameters: [
          {
            name: 'angleToleranceRadians',
            summary: `Used to compare adjacent triangles' face normals. For two triangles 
     to be considered, the angle between their face normals has to 
     be <= angleToleranceRadians. When in doubt use RhinoMath.PI/90.0 (2 degrees).`
          },
          {
            name: 'minimumDiagonalLengthRatio',
            summary: `( <= 1.0) For two triangles to be considered the ratio of the 
     resulting quad's diagonals 
     (length of the shortest diagonal)/(length of longest diagonal). 
     has to be >= minimumDiagonalLengthRatio. When in doubt us .875.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'int CullDegenerateFaces()',
        summary: `Attempts to removes degenerate faces from the mesh.
     Degenerate faces are faces that contains such a combination of indices,
     that their final shape collapsed in a line or point.Before returning, this method also attempts to repair faces by juggling
     vertex indices.`,
        since: 5,
        returns: 'The number of degenerate faces that were removed.'
      },
      {
        signature: 'int DeleteFaces(IEnumerable<int> faceIndexes)',
        summary: 'Removes a collection of faces from the mesh without affecting the remaining geometry.',
        since: 5,
        parameters: [
          {
            name: 'faceIndexes',
            summary: 'An array containing all the face indices to be removed.'
          }
        ],
        returns: 'The number of faces deleted on success.'
      },
      {
        signature: 'int DeleteFaces(IEnumerable<int> faceIndexes,bool compact)',
        summary: 'Removes a collection of faces from the mesh without affecting the remaining geometry.',
        since: 6.6,
        parameters: [
          {
            name: 'faceIndexes',
            summary: 'An array containing all the face indices to be removed.'
          },
          {
            name: 'compact',
            summary: 'No longer used.'
          }
        ],
        returns: 'The number of faces deleted on success.'
      },
      {
        signature: 'void Destroy()',
        summary: `Releases all memory allocated to store faces. The list capacity will be 0 after this call.
     Subsequent calls can add new items.`,
        since: 6
      },
      {
        signature: 'Mesh ExtractDuplicateFaces()',
        summary: 'Extracts, or removes, duplicate faces.',
        since: 6,
        returns: 'A mesh containing the extracted duplicate faces if successful, None otherwise.'
      },
      {
        signature: 'Mesh ExtractFaces(IEnumerable<int> faceIndices)',
        summary: 'Extracts, or removes, faces.',
        since: 6,
        parameters: [
          {
            name: 'faceIndices',
            summary: 'The face indices to be extracted.'
          }
        ],
        returns: 'A mesh containing the extracted faces if successful, None otherwise.'
      },
      {
        signature: 'IndexPair[] GetClashingFacePairs(int maxPairCount)',
        summary: 'Gets an array of pairs of mesh faces that clash.',
        since: 6,
        parameters: [
          {
            name: 'maxPairCount',
            summary: `If >0, then at most this many pairs will be added to the output array.
     If <=0, then all clashing pairs will be added to the output array.`
          }
        ],
        returns: 'Array of pairs of mesh face indices.'
      },
      {
        signature: 'int[] GetConnectedFaces(int faceIndex,double angleRadians,bool greaterThanAngle)',
        summary: `Find all connected face indices where adjacent face normals meet
     the criteria of angleRadians and greaterThanAngle`,
        since: 5.6,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'face index to start from'
          },
          {
            name: 'angleRadians',
            summary: 'angle to use for comparison of what is connected'
          },
          {
            name: 'greaterThanAngle',
            summary: `If True angles greater than or equal to are considered connected.
     If false, angles less than or equal to are considerd connected.`
          }
        ],
        returns: 'list of connected face indices'
      },
      {
        signature: 'int[] GetConnectedFacesToEdges(int startFaceIndex,bool treatNonmanifoldLikeUnwelded)',
        summary: `Uses startFaceIndex and finds all connected face indexes up to unwelded
     or naked edges. If treatNonmanifoldLikeUnwelded is True then non-manifold
     edges will be considered as unwelded or naked`,
        since: 5.6,
        parameters: [
          {
            name: 'startFaceIndex',
            summary: 'Initial face index'
          },
          {
            name: 'treatNonmanifoldLikeUnwelded',
            summary: `True means non-manifold edges will be handled like unwelded edges, 
     False means they aren't considered`
          }
        ],
        returns: 'Array of connected face indexes'
      },
      {
        signature: 'int[] GetDuplicateFaces()',
        summary: 'Finds all of the duplicate faces.',
        since: 6,
        returns: `The indexes that are duplicates of other indexes if successful. 
     If there are no duplicate, then an empty array is returned.`
      },
      {
        signature: 'IEnumerator<MeshFace> GetEnumerator()',
        summary: 'Gets an enumerator that yields all faces in this collection.',
        since: 5,
        returns: 'The enumerator.'
      },
      {
        signature: 'MeshFace GetFace(int index)',
        summary: 'Returns the mesh face at the given index.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: `Index of face to get. Must be larger than or equal to zero and 
     smaller than the Face Count of the mesh.`
          }
        ],
        returns: 'The mesh face at the given index on success or MeshFace.Unset if the index is out of range.'
      },
      {
        signature: 'double GetFaceAspectRatio(int index)',
        summary: 'Returns the mesh face at the given index.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: `Index of face to get. Must be larger than or equal to zero and 
     smaller than the Face Count of the mesh.`
          }
        ],
        returns: 'The mesh face at the given index on success or MeshFace.Unset if the index is out of range.'
      },
      {
        signature: 'BoundingBox GetFaceBoundingBox(int faceIndex)',
        summary: 'Gets the bounding box of a face.',
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'A face index.'
          }
        ],
        returns: 'A new bounding box, or BoundingBox.Empty on error.'
      },
      {
        signature: 'Point3d GetFaceCenter(int faceIndex)',
        summary: `Gets the center point of a face.
     For a triangular face, this is the centroid or barycenter.For a quad, this is the avarage of four coner points.`,
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'A face index.'
          }
        ],
        returns: 'The center point.'
      },
      {
        signature: 'bool GetFaceVertices(int faceIndex,Point3f a,Point3f b,Point3f c,Point3f d)',
        summary: 'Gets the 3D location of the vertices forming a face.',
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'A face index.'
          },
          {
            name: 'a',
            summary: 'A first point. This out argument is assigned during the call.'
          },
          {
            name: 'b',
            summary: 'A second point. This out argument is assigned during the call.'
          },
          {
            name: 'c',
            summary: 'A third point. This out argument is assigned during the call.'
          },
          {
            name: 'd',
            summary: 'A fourth point. This out argument is assigned during the call.'
          }
        ],
        returns: 'True if the operation succeeded, otherwise false.'
      },
      {
        signature: 'int[] GetTopologicalVertices(int faceIndex)',
        summary: 'Gets the topology vertex indices of a face.',
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'A face index.'
          }
        ],
        returns: 'An array of integers.'
      },
      {
        signature: 'bool GetZeroAreaFaces(int[] whollyDegenerateFaces,int[] partiallyDegenerateFaces)',
        summary: `Examines and adds face indexes to whollyDegenerateFaces if the face is a triangle with zero area or a quad both triangles have zero area.
     Face indexes are added to partiallyDegenerateFaces when a quad has one triangle with zero area.`,
        since: 6,
        parameters: [
          {
            name: 'whollyDegenerateFaces',
            summary: 'Array of indexes for faces, both triangles and quads, that have zero area.'
          },
          {
            name: 'partiallyDegenerateFaces',
            summary: 'Array of indexes for quad faces, that have one triangle with zero area.'
          }
        ],
        returns: 'Returns True if the mesh has wholly or partially degenerate faces, False otherwise.'
      },
      {
        signature: 'bool HasNakedEdges(int faceIndex)',
        summary: `Returns True if at least one of the face edges are not topologically
     connected to any other faces.`,
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'A face index.'
          }
        ],
        returns: 'True if that face makes the mesh open, otherwise false.'
      },
      {
        signature: 'void Insert(int index,MeshFace face)',
        summary: 'Inserts a mesh face at a defined index in this list.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'An index.'
          },
          {
            name: 'face',
            summary: 'A face.'
          }
        ]
      },
      {
        signature: 'bool IsHidden(int faceIndex)',
        summary: `Gets a value indicating whether a face is hidden.
     A face is hidden if, and only if, at least one of its vertices is hidden.`,
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'A face index.'
          }
        ],
        returns: 'True if hidden, False if fully visible.'
      },
      {
        signature: 'void RemoveAt(int index)',
        summary: 'Removes a face from the mesh.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'The index of the face that will be removed.'
          }
        ]
      },
      {
        signature: 'void RemoveAt(int index,bool compact)',
        summary: 'Removes a face from the mesh.',
        since: 6.6,
        parameters: [
          {
            name: 'index',
            summary: 'The index of the face that will be removed.'
          },
          {
            name: 'compact',
            summary: 'No longer used.'
          }
        ]
      },
      {
        signature: 'int RemoveZeroAreaFaces(int fixedFaceCount)',
        summary: 'Deletes or fixes mesh faces that have zero area.',
        since: 6,
        parameters: [
          {
            name: 'fixedFaceCount',
            summary: 'Number of fixed partially degenerate faces.'
          }
        ],
        returns: 'Number of removed wholly degenerate faces.'
      },
      {
        signature: 'bool SetFace(int index,int vertex1,int vertex2,int vertex3)',
        summary: 'Sets a triangular face at a specific index of the mesh.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'A position in the list.'
          },
          {
            name: 'vertex1',
            summary: 'The first vertex index.'
          },
          {
            name: 'vertex2',
            summary: 'The second vertex index.'
          },
          {
            name: 'vertex3',
            summary: 'The third vertex index.'
          }
        ],
        returns: 'True if the operation succeeded, otherwise false.'
      },
      {
        signature: 'bool SetFace(int index,int vertex1,int vertex2,int vertex3,int vertex4)',
        summary: 'Sets a quadrangular face at a specific index of the mesh.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'A position in the list.'
          },
          {
            name: 'vertex1',
            summary: 'The first vertex index.'
          },
          {
            name: 'vertex2',
            summary: 'The second vertex index.'
          },
          {
            name: 'vertex3',
            summary: 'The third vertex index.'
          },
          {
            name: 'vertex4',
            summary: 'The fourth vertex index.'
          }
        ],
        returns: 'True if the operation succeeded, otherwise false.'
      },
      {
        signature: 'bool SetFace(int index,MeshFace face)',
        summary: 'Sets a face at a specific index of the mesh.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'A position in the list.'
          },
          {
            name: 'face',
            summary: 'A face.'
          }
        ],
        returns: 'True if the operation succeeded, otherwise false.'
      },
      {
        signature: 'int[] ToIntArray(bool asTriangles)',
        summary: `Copies all of the face indices to a linear array of indices per face.
     
     Note that this includes indices from invalid faces too.`,
        since: 5.9,
        parameters: [
          {
            name: 'asTriangles',
            summary: 'If set to true as triangles.'
          }
        ],
        returns: 'The int array. This method never returns null.'
      },
      {
        signature: 'int[] ToIntArray(bool asTriangles,List<int> replacedIndices)',
        summary: `Copies all of the faces to a linear array of indices.
     
     Clean-up of vertex indices if replacedIndices is a valid List<int>`,
        parameters: [
          {
            name: 'asTriangles',
            summary: 'If set to true as triangles.'
          },
          {
            name: 'replacedIndices',
            summary: 'List is populated with vertex indices that were replaced with 0. If replacedIndices is None there will be no cleanup'
          }
        ],
        returns: 'The int array. This method never returns null.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'MeshFaceNormalList',
    dataType: 1,
    summary: 'Provides access to the Face normals of a Mesh.',
    interfaces: ['IResizableList<Vector3f>', 'IList', 'IReadOnlyList<Vector3f>'],
    properties: [
      {
        signature: 'int Capacity',
        summary: 'Gets or sets the total number of face normals the internal data structure can hold without resizing.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int Count',
        summary: 'Gets or sets the number of mesh face normals.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'int AddFaceNormal(double x,double y,double z)',
        summary: 'Appends a face normal to the list of mesh face normals.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X component of face normal.'
          },
          {
            name: 'y',
            summary: 'Y component of face normal.'
          },
          {
            name: 'z',
            summary: 'Z component of face normal.'
          }
        ],
        returns: 'The index of the newly added face normal.'
      },
      {
        signature: 'int AddFaceNormal(float x,float y,float z)',
        summary: 'Appends a face normal to the list of mesh face normals.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X component of face normal.'
          },
          {
            name: 'y',
            summary: 'Y component of face normal.'
          },
          {
            name: 'z',
            summary: 'Z component of face normal.'
          }
        ],
        returns: 'The index of the newly added face normal.'
      },
      {
        signature: 'int AddFaceNormal(Vector3d normal)',
        summary: 'Appends a face normal to the list of mesh face normals.',
        since: 5,
        parameters: [
          {
            name: 'normal',
            summary: 'New face normal.'
          }
        ],
        returns: 'The index of the newly added face normal.'
      },
      {
        signature: 'int AddFaceNormal(Vector3f normal)',
        summary: 'Appends a face normal to the list of mesh face normals.',
        since: 5,
        parameters: [
          {
            name: 'normal',
            summary: 'New face normal.'
          }
        ],
        returns: 'The index of the newly added face normal.'
      },
      {
        signature: 'void Clear()',
        summary: 'Clears the Face Normal list on the mesh.',
        since: 5
      },
      {
        signature: 'bool ComputeFaceNormals()',
        summary: 'Computes all the face normals for this mesh based on the physical shape of the mesh.',
        since: 5,
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'void Destroy()',
        summary: `Releases all memory allocated to store face normals. The list capacity will be 0 after this call.
     Subsequent calls can add new items.`,
        since: 6
      },
      {
        signature: 'IEnumerator<Vector3f> GetEnumerator()',
        summary: 'Gets an enumerator that yields all normals (vectors) in this collection.',
        since: 5,
        returns: 'The enumerator.'
      },
      {
        signature: 'bool SetFaceNormal(int index,double x,double y,double z)',
        summary: 'Sets a face normal vector at an index using three double-precision numbers.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'An index.'
          },
          {
            name: 'x',
            summary: 'A x component.'
          },
          {
            name: 'y',
            summary: 'A y component.'
          },
          {
            name: 'z',
            summary: 'A z component.'
          }
        ],
        returns: 'True on success; False on error.'
      },
      {
        signature: 'bool SetFaceNormal(int index,float x,float y,float z)',
        summary: 'Sets a face normal vector at an index using three single-precision numbers.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'An index.'
          },
          {
            name: 'x',
            summary: 'A x component.'
          },
          {
            name: 'y',
            summary: 'A y component.'
          },
          {
            name: 'z',
            summary: 'A z component.'
          }
        ],
        returns: 'True on success; False on error.'
      },
      {
        signature: 'bool SetFaceNormal(int index,Vector3d normal)',
        summary: 'Sets a face normal vector at an index using a single-precision vector.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'An index.'
          },
          {
            name: 'normal',
            summary: 'A normal vector.'
          }
        ],
        returns: 'True on success; False on error.'
      },
      {
        signature: 'bool SetFaceNormal(int index,Vector3f normal)',
        summary: 'Sets a face normal vector at an index using a single-precision vector.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'An index.'
          },
          {
            name: 'normal',
            summary: 'A normal vector.'
          }
        ],
        returns: 'True on success; False on error.'
      },
      {
        signature: 'bool UnitizeFaceNormals()',
        summary: 'Unitizes all the existing face normals.',
        since: 5,
        returns: 'True on success, False on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'MeshNgonList',
    dataType: 1,
    summary: `Provides access to the ngons and n-gon related functionality of a Mesh.
   See also the Rhino.Geometry.Mesh.Ngons property for Ngon functionality details.`,
    interfaces: ['IResizableList<MeshNgon>', 'IList', 'IReadOnlyList<MeshNgon>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets or sets the number of mesh ngons.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'uint UnsignedCount',
        summary: 'Gets or sets the number of mesh ngons.',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'int AddNgon(MeshNgon ngon)',
        summary: 'Appends a new ngon to the end of the mesh ngon list.',
        since: 6,
        parameters: [
          {
            name: 'ngon',
            summary: 'Ngon to add.'
          }
        ],
        returns: 'The index of the newly added ngon.'
      },
      {
        signature: 'int[] AddNgons(IEnumerable<MeshNgon> ngons)',
        summary: 'Appends a list of ngons to the end of the mesh ngon list.',
        since: 6,
        parameters: [
          {
            name: 'ngons',
            summary: 'Ngons to add.'
          }
        ],
        returns: 'Indices of the newly created ngons'
      },
      {
        signature: 'int AddPlanarNgons(double planarTolerance)',
        summary: 'Add an ngon for each group of connected coplanar faces.',
        since: 6,
        parameters: [
          {
            name: 'planarTolerance',
            summary: '3d distance tolerance for coplanar test.'
          }
        ],
        returns: 'Number of ngons added to the mesh.'
      },
      {
        signature: 'int AddPlanarNgons(double planarTolerance,int minimumNgonVertexCount,int minimumNgonFaceCount,bool allowHoles)',
        summary: 'Add an ngon for each group of connected coplanar faces.',
        since: 6,
        parameters: [
          {
            name: 'planarTolerance',
            summary: '3d distance tolerance for coplanar test.'
          },
          {
            name: 'minimumNgonVertexCount',
            summary: 'Mininimum number of vertices for an ngon.'
          },
          {
            name: 'minimumNgonFaceCount',
            summary: 'Minimum number of faces for an ngon.'
          },
          {
            name: 'allowHoles',
            summary: 'Determines whether the ngon can have inner boundaries.'
          }
        ],
        returns: 'Number of ngons added to the mesh.'
      },
      {
        signature: 'void Clear()',
        summary: 'Clears the Ngon list on the mesh.',
        since: 6
      },
      {
        signature: 'IEnumerator<MeshNgon> GetEnumerator()',
        summary: 'Gets an enumerator that yields all ngons in this collection.',
        since: 6,
        returns: 'The enumerator.'
      },
      {
        signature: 'MeshNgon GetNgon(int index)',
        summary: 'Returns the mesh ngon at the given index.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: `Index of ngon to get. Must be larger than or equal to zero and 
     smaller than the Ngon Count of the mesh.`
          }
        ],
        returns: 'The mesh ngon at the given index.  This ngon can be MeshNgon.Empty.'
      },
      {
        signature: 'int[] GetNgonBoundary(IEnumerable<int> ngonFaceIndexList)',
        summary: 'Get a list of vertices that form the boundary of a face set. This is often use to get n-gon boundaries.',
        since: 6,
        parameters: [
          {
            name: 'ngonFaceIndexList',
            summary: 'List of mesh face indices.'
          }
        ],
        returns: 'List of mesh vertex indices that form the boundary of the face set.'
      },
      {
        signature: 'BoundingBox GetNgonBoundingBox(int index)',
        summary: 'Gets the bounding box of an ngon.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'A ngon index.'
          }
        ],
        returns: 'A new bounding box, or BoundingBox.Empty on error.'
      },
      {
        signature: 'BoundingBox GetNgonBoundingBox(MeshNgon ngon)',
        summary: 'Gets the bounding box of an ngon.',
        since: 6,
        parameters: [
          {
            name: 'ngon',
            summary: 'An ngon.'
          }
        ],
        returns: 'A new bounding box, or BoundingBox.Empty on error.'
      },
      {
        signature: 'Point3d GetNgonCenter(int index)',
        summary: `Gets the center point of an ngon.
     This the avarage of the corner points.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'A ngon index.'
          }
        ],
        returns: 'The center point.'
      },
      {
        signature: 'Point3d GetNgonCenter(MeshNgon ngon)',
        summary: `Gets the center point of an ngon.
     This the avarage of the corner points.`,
        since: 6,
        parameters: [
          {
            name: 'ngon',
            summary: 'An ngon.'
          }
        ],
        returns: 'The center point.'
      },
      {
        signature: 'int GetNgonEdgeCount(int index)',
        summary: 'Gets the complete edge count of an ngon.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'Ngon index.'
          }
        ],
        returns: 'Complete edge count or zero on error.'
      },
      {
        signature: 'int GetNgonOuterEdgeCount(int index)',
        summary: 'Gets the outer edge count of an ngon.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'Ngon index.'
          }
        ],
        returns: 'Outer edge count or zero on error.'
      },
      {
        signature: 'void Insert(int index,MeshNgon ngon)',
        summary: 'Inserts a mesh ngon at a defined index in this list.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'An ngon index.'
          },
          {
            name: 'ngon',
            summary: 'An ngon.'
          }
        ]
      },
      {
        signature: 'uint IsValid(int index)',
        summary: 'Tests an ngon to see if the vertex and face references are valid and pass partial boundary validity checks.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index of the ngon to test.'
          }
        ],
        returns: '0 if the ngon is not valid, otherwise the number of boundary edges.'
      },
      {
        signature: 'uint IsValid(int index,TextLog textLog)',
        summary: 'Tests an ngon to see if the vertex and face references are valid and pass partial boundary validity checks.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index of the ngon to test.'
          },
          {
            name: 'textLog',
            summary: 'A textlog for collecting information about problems.'
          }
        ],
        returns: '0 if the ngon is not valid, otherwise the number of boundary edges.'
      },
      {
        signature: 'Point3d[] NgonBoundaryVertexList(MeshNgon ngon,bool bAppendStartPoint)',
        summary: 'Get an ngon\'s boundary points.',
        since: 6,
        parameters: [
          {
            name: 'ngon',
            summary: 'ngon.'
          },
          {
            name: 'bAppendStartPoint',
            summary: 'If true, the first point in the list is also appended to the end of the list to create a closed polyline.'
          }
        ],
        returns: 'A list of ngon boundary points.'
      },
      {
        signature: 'bool NgonHasHoles(int index)',
        summary: 'Determines whether a ngon has holes.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'Ngon index.'
          }
        ],
        returns: 'True for holes (or malformed ngon, see remarks), False for no holes.'
      },
      {
        signature: 'int NgonIndexFromFaceIndex(int meshFaceIndex)',
        summary: 'Returns the index of a mesh ngon the face belongs to.',
        since: 6,
        parameters: [
          {
            name: 'meshFaceIndex',
            summary: 'Index of a mesh face.'
          }
        ],
        returns: 'The index of the mesh ngon the face belongs to or -1 if the face does not belong to an ngon.'
      },
      {
        signature: 'int Orientation(int index,bool permitHoles)',
        summary: 'Determine if the ngon\'s boundary orientation matches that of the set of faces it is made from.',
        since: 7,
        parameters: [
          {
            name: 'index',
            summary: 'Ngon index.'
          },
          {
            name: 'permitHoles',
            summary: 'True if the ngon is permitted to have interior holes, False otherwise.'
          }
        ],
        returns: `1: The ngon does not have holes, the ngon's faces are compatibly oriented, 
     and the ngon's outer boundary orientation matches the faces' orientation.
     -1: The ngon does not have holes, the ngon's faces are compatibly oriented,
     and the ngon's outer boundary orientation is opposite the faces' orientation.
     0: Otherwise.The ngon may be invalid, have holes, the ngon's faces may not be
     compatibly oriented, the ngons edges may not have a consistent orientation
     with respect to the faces, or some other issue.`
      },
      {
        signature: 'void RemoveAt(int index)',
        summary: 'Removes an ngon from the mesh.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index of the ngon.'
          }
        ]
      },
      {
        signature: 'int RemoveNgons(IEnumerable<int> indices)',
        summary: 'Remove one or more ngons from the mesh.',
        since: 6,
        parameters: [
          {
            name: 'indices',
            summary: 'An array of ngon indices.'
          }
        ],
        returns: 'The number of deleted ngons.'
      },
      {
        signature: 'void ReverseOuterBoundary(int index)',
        summary: 'Reverse the order of the m_vi[] array for an ngon',
        since: 7
      },
      {
        signature: 'void SetNgon(int index,MeshNgon ngon)',
        summary: 'Set an ngon in this list.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'An ngon index.'
          },
          {
            name: 'ngon',
            summary: 'An ngon.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'MeshTextureCoordinateList',
    dataType: 1,
    summary: 'Provides access to the Vertex Texture coordinates of a Mesh.',
    interfaces: ['IResizableList<Point2f>', 'IList', 'IReadOnlyList<Point2f>'],
    properties: [
      {
        signature: 'int Capacity',
        summary: 'Gets or sets the total number of texture coordinates the internal data structure can hold without resizing.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int Count',
        summary: 'Gets or sets the number of texture coordinates.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'int Add(double s,double t)',
        summary: 'Adds a new texture coordinate to the end of the Texture list.',
        since: 5,
        parameters: [
          {
            name: 's',
            summary: 'S component of new texture coordinate.'
          },
          {
            name: 't',
            summary: 'T component of new texture coordinate.'
          }
        ],
        returns: 'The index of the newly added texture coordinate.'
      },
      {
        signature: 'int Add(float s,float t)',
        summary: 'Adds a new texture coordinate to the end of the Texture list.',
        since: 5,
        parameters: [
          {
            name: 's',
            summary: 'S component of new texture coordinate.'
          },
          {
            name: 't',
            summary: 'T component of new texture coordinate.'
          }
        ],
        returns: 'The index of the newly added texture coordinate.'
      },
      {
        signature: 'int Add(Point2f tc)',
        summary: 'Adds a new texture coordinate to the end of the Texture list.',
        since: 5,
        parameters: [
          {
            name: 'tc',
            summary: 'Texture coordinate to add.'
          }
        ],
        returns: 'The index of the newly added texture coordinate.'
      },
      {
        signature: 'int Add(Point3d tc)',
        summary: 'Adds a new texture coordinate to the end of the Texture list.',
        since: 5,
        parameters: [
          {
            name: 'tc',
            summary: 'Texture coordinate to add.'
          }
        ],
        returns: 'The index of the newly added texture coordinate.'
      },
      {
        signature: 'bool AddRange(Point2f[] textureCoordinates)',
        summary: 'Appends an array of texture coordinates.',
        since: 5,
        parameters: [
          {
            name: 'textureCoordinates',
            summary: 'Texture coordinates to append.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'void Clear()',
        summary: 'Clears the Texture Coordinate list on the mesh.',
        since: 5
      },
      {
        signature: 'void Destroy()',
        summary: `Releases all memory allocated to store texture coordinates. The list capacity will be 0 after this call.
     Subsequent calls can add new items.`,
        since: 6
      },
      {
        signature: 'IEnumerator<Point2f> GetEnumerator()',
        summary: 'Gets an enumerator that yields all texture coordinates in this collection.',
        since: 5,
        returns: 'The enumerator.'
      },
      {
        signature: 'bool NormalizeTextureCoordinates()',
        summary: `Scales the texture coordinates so the texture domains are [0,1] 
     and eliminate any texture rotations.`,
        since: 5,
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool ReverseTextureCoordinates(int direction)',
        summary: `Reverses one coordinate direction of the texture coordinates.
     The region of the bitmap the texture uses does not change.
     Either Us or Vs direction is flipped.`,
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: '0 = first texture coordinate is reversed.1 = second texture coordinate is reversed.'
          }
        ],
        returns: 'True if operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool SetTextureCoordinate(int index,double s,double t)',
        summary: `Sets or adds a texture coordinate to the Texture Coordinate List.
     If [index] is less than [Count], the existing coordinate at [index] will be modified.If [index] equals [Count], a new coordinate is appended to the end of the coordinate list.If [index] is larger than [Count], the function will return false.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of texture coordinate to set.'
          },
          {
            name: 's',
            summary: 'S component of texture coordinate.'
          },
          {
            name: 't',
            summary: 'T component of texture coordinate.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetTextureCoordinate(int index,float s,float t)',
        summary: `Sets or adds a texture coordinate to the Texture Coordinate List.
     If [index] is less than [Count], the existing coordinate at [index] will be modified.If [index] equals [Count], a new coordinate is appended to the end of the coordinate list.If [index] is larger than [Count], the function will return false.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of texture coordinate to set.'
          },
          {
            name: 's',
            summary: 'S component of texture coordinate.'
          },
          {
            name: 't',
            summary: 'T component of texture coordinate.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetTextureCoordinate(int index,Point2f tc)',
        summary: `Sets or adds a texture coordinate to the Texture Coordinate List.
     If [index] is less than [Count], the existing coordinate at [index] will be modified.If [index] equals [Count], a new coordinate is appended to the end of the coordinate list.If [index] is larger than [Count], the function will return false.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of texture coordinate to set.'
          },
          {
            name: 'tc',
            summary: 'Texture coordinate point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetTextureCoordinate(int index,Point3f tc)',
        summary: `Sets or adds a texture coordinate to the Texture Coordinate List.
     If [index] is less than [Count], the existing coordinate at [index] will be modified.If [index] equals [Count], a new coordinate is appended to the end of the coordinate list.If [index] is larger than [Count], the function will return false.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of texture coordinate to set.'
          },
          {
            name: 'tc',
            summary: 'Texture coordinate point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetTextureCoordinates(Point2f[] textureCoordinates)',
        summary: 'Sets all texture coordinates in one go.',
        since: 5,
        parameters: [
          {
            name: 'textureCoordinates',
            summary: 'Texture coordinates to assign to the mesh.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetTextureCoordinates(TextureMapping mapping)',
        summary: 'Set all texture coordinates based on a texture mapping function',
        since: 5,
        parameters: [
          {
            name: 'mapping',
            summary: 'The new mapping type.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'float[] ToFloatArray()',
        summary: 'Copies all vertices to a linear array of float in u,v order',
        since: 6,
        returns: 'The float array.'
      },
      {
        signature: 'bool TransposeTextureCoordinates()',
        summary: `Transposes texture coordinates.
     The region of the bitmap the texture uses does not change.
     All texture coordinates rows (Us) become columns (Vs), and vice versa.`,
        since: 5,
        returns: 'True on success, False on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'MeshTopologyEdgeList',
    dataType: 1,
    summary: 'Represents an entry point to the list of edges in a mesh topology.',
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of edges in this list.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool CollapseEdge(int topologyEdgeIndex)',
        summary: 'Replaces a mesh edge with a vertex at its center and update adjacent faces as needed.',
        since: 5,
        parameters: [
          {
            name: 'topologyEdgeIndex',
            summary: 'An index of a topology edge in Mesh.TopologyEdges.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'Line EdgeLine(int topologyEdgeIndex)',
        summary: 'Gets the 3d line along an edge.',
        since: 5,
        parameters: [
          {
            name: 'topologyEdgeIndex',
            summary: 'The topology edge index.'
          }
        ],
        returns: 'Line along edge. If input is not valid, an Invalid Line is returned.'
      },
      {
        signature: 'int[] GetConnectedFaces(int topologyEdgeIndex)',
        summary: 'Gets indices of faces connected to an edge.',
        since: 5,
        parameters: [
          {
            name: 'topologyEdgeIndex',
            summary: 'An index of a topology edge that is queried.'
          }
        ],
        returns: 'An array of face indices the edge borders. This might be empty on error.'
      },
      {
        signature: 'int[] GetConnectedFaces(int topologyEdgeIndex,bool[] faceOrientationMatchesEdgeDirection)',
        summary: 'Gets indices of faces connected to an edge.',
        since: 5,
        parameters: [
          {
            name: 'topologyEdgeIndex',
            summary: 'An index of a topology edge that is queried.'
          },
          {
            name: 'faceOrientationMatchesEdgeDirection',
            summary: 'An array of Boolean values that explains whether each face direction matches the direction of the specified edge.'
          }
        ],
        returns: 'An array of face indices the edge borders. This might be empty on error.'
      },
      {
        signature: 'int GetEdgeIndex(int topologyVertex1,int topologyVertex2)',
        summary: `Returns index of edge that connects topological vertices. 
     returns -1 if no edge is found.`,
        since: 5,
        parameters: [
          {
            name: 'topologyVertex1',
            summary: 'The first topology vertex index.'
          },
          {
            name: 'topologyVertex2',
            summary: 'The second topology vertex index.'
          }
        ],
        returns: 'The edge index.'
      },
      {
        signature: 'int[] GetEdgesForFace(int faceIndex)',
        summary: 'Gets indices of edges that surround a given face.',
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'A face index.'
          }
        ],
        returns: 'A new array of indices to the topological edges that are connected with the specified face.'
      },
      {
        signature: 'int[] GetEdgesForFace(int faceIndex,bool[] sameOrientation)',
        summary: 'Gets indices of edges that surround a given face.',
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'A face index.'
          },
          {
            name: 'sameOrientation',
            summary: `Same length as returned edge index array. For each edge, the sameOrientation value
     tells you if the edge orientation matches the face orientation (true), or is
     reversed (false) compared to it.`
          }
        ],
        returns: 'A new array of indices to the topological edges that are connected with the specified face.'
      },
      {
        signature: 'IndexPair GetTopologyVertices(int topologyEdgeIndex)',
        summary: 'Gets the two topology vertices for a given topology edge.',
        since: 5,
        parameters: [
          {
            name: 'topologyEdgeIndex',
            summary: 'An index of a topology edge.'
          }
        ],
        returns: 'The pair of vertex indices the edge connects.'
      },
      {
        signature: 'bool IsEdgeUnwelded(int topologyEdgeIndex)',
        summary: 'Determines if the mesh edge is unwelded, or if the mesh faces that share the edge have unique vertex indices.',
        since: 6.13,
        parameters: [
          {
            name: 'topologyEdgeIndex',
            summary: 'An index of a topology edge in Mesh.TopologyEdges.'
          }
        ],
        returns: 'True if the edge is unwelded, False if the edge is welded.'
      },
      {
        signature: 'bool IsHidden(int topologyEdgeIndex)',
        summary: `Returns True if the topological edge is hidden. The mesh topology
     edge is hidden only if either of its mesh topology vertices is hidden.`,
        since: 5,
        parameters: [
          {
            name: 'topologyEdgeIndex',
            summary: 'An index of a topology edge in Mesh.TopologyEdges.'
          }
        ],
        returns: 'True if mesh topology edge is hidden.'
      },
      {
        signature: 'bool IsNgonInterior(int topologyEdgeIndex)',
        summary: 'Returns True if the topological edge is an interior ngon edge',
        since: 6,
        parameters: [
          {
            name: 'topologyEdgeIndex',
            summary: 'An index of a topology edge in Mesh.TopologyEdges.'
          }
        ],
        returns: 'True if mesh topology edge is an interior ngon edge.'
      },
      {
        signature: 'bool IsSwappableEdge(int topologyEdgeIndex)',
        summary: 'Determines if a mesh edge index is valid input for SwapEdge.',
        since: 5,
        parameters: [
          {
            name: 'topologyEdgeIndex',
            summary: 'An index of a topology edge in Mesh.TopologyEdges.'
          }
        ],
        returns: 'True if edge can be swapped.'
      },
      {
        signature: 'bool SplitEdge(int topologyEdgeIndex,double t)',
        summary: 'Divides a mesh edge to create two or more triangles',
        since: 5,
        parameters: [
          {
            name: 'topologyEdgeIndex',
            summary: 'Edge to divide'
          },
          {
            name: 't',
            summary: 'Parameter along edge. This is the same as getting an EdgeLine and calling PointAt(t) on that line'
          }
        ],
        returns: 'True if successful'
      },
      {
        signature: 'bool SplitEdge(int topologyEdgeIndex,Point3d point)',
        summary: 'Divides a mesh edge to create two or more triangles',
        since: 5,
        parameters: [
          {
            name: 'topologyEdgeIndex',
            summary: 'Edge to divide'
          },
          {
            name: 'point',
            summary: 'Location to perform the split'
          }
        ],
        returns: 'True if successful'
      },
      {
        signature: 'bool SwapEdge(int topologyEdgeIndex)',
        summary: 'If the edge is shared by two triangular face, then the edge is swapped.',
        since: 5,
        parameters: [
          {
            name: 'topologyEdgeIndex',
            summary: 'An index of a topology edge in Mesh.TopologyEdges.'
          }
        ],
        returns: 'True if successful.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'MeshTopologyVertexList',
    dataType: 1,
    summary: `Provides access to the mesh topology vertices of a mesh. Topology vertices are
   sets of vertices in the MeshVertexList that can topologically be considered the
   same vertex.`,
    interfaces: ['IEnumerable<Point3f>', 'IList<Point3f>', 'IList', 'IReadOnlyList<Point3f>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets or sets the number of mesh topology vertices.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int ConnectedEdge(int topologyVertexIndex,int edgeAtVertexIndex)',
        summary: `Gets a particular edge that is connected to a topological vertex.
     Call TopologyVertices.SortVertices before this if you are interested in ordered edges.`,
        since: 6,
        parameters: [
          {
            name: 'topologyVertexIndex',
            summary: 'Index of a topology vertex in Mesh.TopologyVertices.'
          },
          {
            name: 'edgeAtVertexIndex',
            summary: 'Index of the edge at the vertex.'
          }
        ],
        returns: 'The index of the connected edge.'
      },
      {
        signature: 'int[] ConnectedEdges(int topologyVertexIndex)',
        summary: `Gets all edges that are connected to a given vertex.
     Call TopologyVertices.SortVertices before this if you are interested in ordered edges.`,
        since: 6,
        parameters: [
          {
            name: 'topologyVertexIndex',
            summary: 'Index of a topology vertex in Mesh.TopologyVertices.'
          }
        ],
        returns: `Indices of all edges around vertex that are connected to this topological vertex.
     None if no faces are connected to this vertex.`
      },
      {
        signature: 'int ConnectedEdgesCount(int topologyVertexIndex)',
        summary: 'Gets the count of edges that are connected to a given vertex.',
        since: 6,
        parameters: [
          {
            name: 'topologyVertexIndex',
            summary: 'Index of a topology vertex in Mesh.TopologyVertices.'
          }
        ],
        returns: 'The amount of edges at this vertex. This can be 0.'
      },
      {
        signature: 'int[] ConnectedFaces(int topologyVertexIndex)',
        summary: 'Gets all faces that are connected to a given vertex.',
        since: 5,
        parameters: [
          {
            name: 'topologyVertexIndex',
            summary: 'Index of a topology vertex in Mesh.TopologyVertices.'
          }
        ],
        returns: `Indices of all faces in Mesh.Faces that are connected to this topological vertex.
     None if no faces are connected to this vertex.`
      },
      {
        signature: 'int[] ConnectedTopologyVertices(int topologyVertexIndex)',
        summary: 'Gets all topological vertices that are connected to a given vertex.',
        since: 5,
        parameters: [
          {
            name: 'topologyVertexIndex',
            summary: 'index of a topology vertex in Mesh.TopologyVertices.'
          }
        ],
        returns: `Indices of all topological vertices that are connected to this topological vertex.
     None if no vertices are connected to this vertex.`
      },
      {
        signature: 'int[] ConnectedTopologyVertices(int topologyVertexIndex,bool sorted)',
        summary: 'Gets all topological vertices that are connected to a given vertex.',
        since: 5,
        parameters: [
          {
            name: 'topologyVertexIndex',
            summary: 'index of a topology vertex in Mesh.TopologyVertices.'
          },
          {
            name: 'sorted',
            summary: 'if true, thr vertices are returned in a radially sorted order.'
          }
        ],
        returns: `Indices of all topological vertices that are connected to this topological vertex.
     None if no vertices are connected to this vertex.`
      },
      {
        signature: 'IEnumerator<Point3f> GetEnumerator()',
        summary: 'Gets an enumerator that yields all topology vertices in this collection.',
        since: 5,
        returns: 'The enumerator.'
      },
      {
        signature: 'int[] IndicesFromFace(int faceIndex)',
        summary: 'Returns TopologyVertexIndices for a given mesh face index.',
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'The index of a face to query.'
          }
        ],
        returns: 'An array of vertex indices.'
      },
      {
        signature: 'bool IsHidden(int topologyVertexIndex)',
        summary: `Returns True if the topological vertex is hidden. The mesh topology
     vertex is hidden if and only if all the ON_Mesh vertices it represents is hidden.`,
        since: 5,
        parameters: [
          {
            name: 'topologyVertexIndex',
            summary: 'index of a topology vertex in Mesh.TopologyVertices.'
          }
        ],
        returns: 'True if mesh topology vertex is hidden.'
      },
      {
        signature: 'int[] MeshVertexIndices(int topologyVertexIndex)',
        summary: 'Gets all indices of the mesh vertices that a given topology vertex represents.',
        since: 5,
        parameters: [
          {
            name: 'topologyVertexIndex',
            summary: 'Index of a topology vertex in Mesh.TopologyVertices to query.'
          }
        ],
        returns: 'Indices of all vertices that in Mesh.Vertices that a topology vertex represents.'
      },
      {
        signature: 'bool SortEdges()',
        summary: `Sorts the edge list for the mesh topology vertex list so that
     the edges are in radial order when you call ConnectedTopologyVertices.
     A nonmanifold edge is treated as a boundary edge with respect
     to sorting.  If any boundary or nonmanifold edges end at the
     vertex, then the first edge will be a boundary or nonmanifold edge.`,
        since: 5,
        returns: 'True on success.'
      },
      {
        signature: 'bool SortEdges(int topologyVertexIndex)',
        summary: `Sorts the edge list for as single mesh topology vertex so that
     the edges are in radial order when you call ConnectedTopologyVertices.
     A nonmanifold edge is treated as a boundary edge with respect
     to sorting.  If any boundary or nonmanifold edges end at the
     vertex, then the first edge will be a boundary or nonmanifold edge.`,
        since: 5,
        parameters: [
          {
            name: 'topologyVertexIndex',
            summary: 'index of a topology vertex in Mesh.TopologyVertices>'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'int TopologyVertexIndex(int vertexIndex)',
        summary: `Gets the topology vertex index for an existing mesh vertex in the mesh's
     VertexList.`,
        since: 5,
        parameters: [
          {
            name: 'vertexIndex',
            summary: 'Index of a vertex in the Mesh.Vertices.'
          }
        ],
        returns: 'Index of a topology vertex in the Mesh.TopologyVertices.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'MeshVertexColorList',
    dataType: 1,
    summary: 'Provides access to the vertex colors of a mesh object.',
    interfaces: ['IResizableList<Color>', 'IList', 'IReadOnlyList<Color>'],
    properties: [
      {
        signature: 'int Capacity',
        summary: 'Gets or sets the total number of vertex colors the internal data structure can hold without resizing.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int Count',
        summary: 'Gets or sets the number of mesh colors.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'MappingTag Tag',
        summary: 'Gets or sets a mapping information for the mesh associated with these vertex colors.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'int Add(Color color)',
        summary: 'Adds a new vertex color to the end of the color list.',
        since: 5,
        parameters: [
          {
            name: 'color',
            summary: 'Color to append, Alpha channels will be ignored.'
          }
        ],
        returns: 'The index of the newly added color.'
      },
      {
        signature: 'int Add(int red,int green,int blue)',
        summary: 'Adds a new vertex color to the end of the color list.',
        since: 5,
        parameters: [
          {
            name: 'red',
            summary: 'Red component of color, must be in the 0~255 range.'
          },
          {
            name: 'green',
            summary: 'Green component of color, must be in the 0~255 range.'
          },
          {
            name: 'blue',
            summary: 'Blue component of color, must be in the 0~255 range.'
          }
        ],
        returns: 'The index of the newly added color.'
      },
      {
        signature: 'bool AppendColors(Color[] colors)',
        summary: `Appends a collection of colors to the vertex color list. 
     For the Mesh to be valid, the number of colors must match the number of vertices.`,
        since: 5,
        parameters: [
          {
            name: 'colors',
            summary: 'Colors to append.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'void Clear()',
        summary: 'Clears the vertex color list on the mesh.',
        since: 5
      },
      {
        signature: 'bool CreateMonotoneMesh(Color baseColor)',
        summary: 'Constructs a valid vertex color list consisting of a single color.',
        since: 5,
        parameters: [
          {
            name: 'baseColor',
            summary: 'Color to apply to every vertex.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'void Destroy()',
        summary: `Releases all memory allocated to store vertex colors. The list capacity will be 0 after this call.
     Subsequent calls can add new items.`,
        since: 6
      },
      {
        signature: 'IEnumerator<Color> GetEnumerator()',
        summary: 'Gets an enumerator that yields all colors in this collection.',
        since: 5,
        returns: 'The enumerator.'
      },
      {
        signature: 'bool SetColor(int index,Color color)',
        summary: `Sets or adds a vertex to the Vertex List.
     If [index] is less than [Count], the existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: `Index of vertex color to set. 
     If index equals Count, then the color will be appended.`
          },
          {
            name: 'color',
            summary: 'Color to set, Alpha channels will be ignored.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetColor(int index,int red,int green,int blue)',
        summary: `Sets or adds a vertex color to the color List.
     If [index] is less than [Count], the existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: `Index of vertex color to set. 
     If index equals Count, then the color will be appended.`
          },
          {
            name: 'red',
            summary: 'Red component of vertex color. Value must be in the 0~255 range.'
          },
          {
            name: 'green',
            summary: 'Green component of vertex color. Value must be in the 0~255 range.'
          },
          {
            name: 'blue',
            summary: 'Blue component of vertex color. Value must be in the 0~255 range.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetColor(MeshFace face,Color color)',
        summary: 'Sets a color at the three or four vertex indices of a specified face.',
        since: 5,
        parameters: [
          {
            name: 'face',
            summary: 'A face to use to retrieve indices.'
          },
          {
            name: 'color',
            summary: 'A color.'
          }
        ],
        returns: 'True on success; False on error.'
      },
      {
        signature: 'bool SetColors(Color[] colors)',
        summary: `Sets all the vertex colors in one go. For the Mesh to be valid, the number 
     of colors must match the number of vertices.`,
        since: 5,
        parameters: [
          {
            name: 'colors',
            summary: 'Colors to set.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'int[] ToARGBArray()',
        summary: 'Return colors as an array of integers with packed ARGB values',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'MeshVertexList',
    dataType: 1,
    summary: 'Provides access to the vertices and vertex-related functionality of a mesh.',
    interfaces: ['IResizableList<Point3f>', 'IReadOnlyList<Point3f>', 'IList'],
    properties: [
      {
        signature: 'int Capacity',
        summary: 'Gets or sets the total number of vertices the internal data structure can hold without resizing.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int Count',
        summary: 'Gets or sets the number of mesh vertices.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool UseDoublePrecisionVertices',
        summary: 'Set to True if the vertices should be stored in double precision',
        since: 6.4,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static int Align(IEnumerable<Mesh> meshes,double distance,IEnumerable<IEnumerable<bool>> whichVertices)',
        summary: `Moves mesh vertices that belong to naked edges to neighboring vertices, within the specified distance.
     This forces unaligned mesh vertices to the same location and is helpful to clean meshes for 3D printing.See the _AlignMeshVertices Rhino command for more information.`,
        parameters: [
          {
            name: 'meshes',
            summary: 'The enumerable of meshes that need to have vertices adjusted.'
          },
          {
            name: 'distance',
            summary: 'Distance that should not be exceed when modifying the mesh.'
          },
          {
            name: 'whichVertices',
            summary: `If not null, defines which vertices should be considered for adjustment.
     If this parameter is non-null, then all items within it have to be non-None as well, defining for each mesh, which vertices to adjust.`
          }
        ],
        returns: 'If the operation succeeded, the number of moved vertices, or -1 on error.'
      },
      {
        signature: 'int Add(double x,double y,double z)',
        summary: 'Adds a new vertex to the end of the Vertex list.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X component of new vertex coordinate.'
          },
          {
            name: 'y',
            summary: 'Y component of new vertex coordinate.'
          },
          {
            name: 'z',
            summary: 'Z component of new vertex coordinate.'
          }
        ],
        returns: 'The index of the newly added vertex.'
      },
      {
        signature: 'int Add(float x,float y,float z)',
        summary: 'Adds a new vertex to the end of the Vertex list.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X component of new vertex coordinate.'
          },
          {
            name: 'y',
            summary: 'Y component of new vertex coordinate.'
          },
          {
            name: 'z',
            summary: 'Z component of new vertex coordinate.'
          }
        ],
        returns: 'The index of the newly added vertex.'
      },
      {
        signature: 'int Add(Point3d vertex)',
        summary: 'Adds a new vertex to the end of the Vertex list.',
        since: 5,
        parameters: [
          {
            name: 'vertex',
            summary: 'Location of new vertex.'
          }
        ],
        returns: 'The index of the newly added vertex.'
      },
      {
        signature: 'int Add(Point3f vertex)',
        summary: 'Adds a new vertex to the end of the Vertex list.',
        since: 5,
        parameters: [
          {
            name: 'vertex',
            summary: 'Location of new vertex.'
          }
        ],
        returns: 'The index of the newly added vertex.'
      },
      {
        signature: 'void AddVertices(IEnumerable<Point3d> vertices)',
        summary: `Adds a series of new vertices to the end of the vertex list.
     This overload accepts double-precision points.`,
        since: 5,
        parameters: [
          {
            name: 'vertices',
            summary: 'A list, an array or any enumerable set of Point3d.'
          }
        ]
      },
      {
        signature: 'void AddVertices(IEnumerable<Point3f> vertices)',
        summary: `Adds a series of new vertices to the end of the vertex list.
     This overload accepts single-precision points.`,
        since: 5,
        parameters: [
          {
            name: 'vertices',
            summary: 'A list, an array or any enumerable set of Point3f.'
          }
        ]
      },
      {
        signature: 'int Align(double distance,IEnumerable<bool> whichVertices)',
        summary: `Moves mesh vertices that belong to naked edges to neighboring vertices, within the specified distance.
     This forces unaligned mesh vertices to the same location and is helpful to clean meshes for 3D printing.See the _AlignMeshVertices Rhino command for more information.`,
        since: 6,
        parameters: [
          {
            name: 'distance',
            summary: 'Distance that should not be exceed when modifying the mesh.'
          },
          {
            name: 'whichVertices',
            summary: 'If not null, defines which vertices should be considered for adjustment.'
          }
        ],
        returns: 'If the operation succeeded, the number of moved vertices, or -1 on error.'
      },
      {
        signature: 'void Clear()',
        summary: 'Clears the Vertex list on the mesh.',
        since: 5
      },
      {
        signature: 'bool CombineIdentical(bool ignoreNormals,bool ignoreAdditional)',
        summary: 'Merges identical vertices.',
        since: 5,
        parameters: [
          {
            name: 'ignoreNormals',
            summary: 'If true, vertex normals will not be taken into consideration when comparing vertices.'
          },
          {
            name: 'ignoreAdditional',
            summary: `If true, texture coordinates, colors, and principal curvatures 
     will not be taken into consideration when comparing vertices.`
          }
        ],
        returns: 'True if the mesh is changed, in which case the mesh will have fewer vertices than before.'
      },
      {
        signature: 'int CullUnused()',
        summary: 'Removes all vertices that are currently not used by the Face list.',
        since: 5,
        returns: 'The number of unused vertices that were removed.'
      },
      {
        signature: 'void Destroy()',
        summary: `Releases all memory allocated to store faces. The list capacity will be 0 after this call.
     Subsequent calls can add new items.`,
        since: 6
      },
      {
        signature: 'int[] GetConnectedVertices(int vertexIndex)',
        summary: 'Gets indices of all vertices that form "edges" with a given vertex index.',
        since: 5,
        parameters: [
          {
            name: 'vertexIndex',
            summary: 'The index of a vertex to query.'
          }
        ],
        returns: 'An array of vertex indices that are connected with the specified vertex.'
      },
      {
        signature: 'IEnumerator<Point3f> GetEnumerator()',
        summary: 'Gets an enumerator that yields all mesh vertices (points) in this collection.',
        since: 5,
        returns: 'The enumerator.'
      },
      {
        signature: 'int[] GetTopologicalIndenticalVertices(int vertexIndex)',
        summary: `Gets a list of other vertices which are "topologically" identical
     to this vertex.`,
        since: 5,
        parameters: [
          {
            name: 'vertexIndex',
            summary: 'A vertex index in the mesh.'
          }
        ],
        returns: `Array of indices of vertices that are topoligically the same as this vertex. The
     array includes vertexIndex. Returns None on failure.`
      },
      {
        signature: 'int[] GetVertexFaces(int vertexIndex)',
        summary: 'Gets a list of all of the faces that share a given vertex.',
        since: 5,
        parameters: [
          {
            name: 'vertexIndex',
            summary: 'The index of a vertex in the mesh.'
          }
        ],
        returns: 'An array of indices of faces on success, None on failure.'
      },
      {
        signature: 'void Hide(int vertexIndex)',
        summary: 'Hides the vertex at the given index.',
        since: 5,
        parameters: [
          {
            name: 'vertexIndex',
            summary: 'Index of vertex to hide.'
          }
        ]
      },
      {
        signature: 'void HideAll()',
        summary: 'Hides all vertices in the mesh.',
        since: 5
      },
      {
        signature: 'bool IsHidden(int vertexIndex)',
        summary: 'Gets a value indicating whether or not a vertex is hidden.',
        since: 5,
        parameters: [
          {
            name: 'vertexIndex',
            summary: 'Index of vertex to query.'
          }
        ],
        returns: 'True if the vertex is hidden, False if it is not.'
      },
      {
        signature: 'Point3d Point3dAt(int index)',
        summary: 'Get double precision location at a given index',
        since: 6.4
      },
      {
        signature: 'bool Remove(IEnumerable<int> indices,bool shrinkFaces)',
        summary: 'Removes the vertices at the given indices and all faces that reference those vertices.',
        since: 5,
        parameters: [
          {
            name: 'indices',
            summary: 'Vertex indices to remove.'
          },
          {
            name: 'shrinkFaces',
            summary: 'If true, quads that reference the deleted vertex will be converted to triangles.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Remove(int index,bool shrinkFaces)',
        summary: 'Removes the vertex at the given index and all faces that reference that index.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of vertex to remove.'
          },
          {
            name: 'shrinkFaces',
            summary: 'If true, quads that reference the deleted vertex will be converted to triangles.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetVertex(int index,double x,double y,double z)',
        summary: `Sets or adds a vertex to the Vertex List.
     If [index] is less than [Count], the existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of vertex to set.'
          },
          {
            name: 'x',
            summary: 'X component of vertex location.'
          },
          {
            name: 'y',
            summary: 'Y component of vertex location.'
          },
          {
            name: 'z',
            summary: 'Z component of vertex location.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetVertex(int index,double x,double y,double z,bool updateNormals)',
        summary: `Sets or adds a vertex to the Vertex List.
     If [index] is less than [Count], the existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.`,
        since: 6.6,
        parameters: [
          {
            name: 'index',
            summary: 'Index of vertex to set.'
          },
          {
            name: 'x',
            summary: 'X component of vertex location.'
          },
          {
            name: 'y',
            summary: 'Y component of vertex location.'
          },
          {
            name: 'z',
            summary: 'Z component of vertex location.'
          },
          {
            name: 'updateNormals',
            summary: 'Set to True if you\'d like the vertex and face normals impacted by the change updated.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetVertex(int index,float x,float y,float z)',
        summary: `Sets or adds a vertex to the Vertex List.
     If [index] is less than [Count], the existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of vertex to set.'
          },
          {
            name: 'x',
            summary: 'X component of vertex location.'
          },
          {
            name: 'y',
            summary: 'Y component of vertex location.'
          },
          {
            name: 'z',
            summary: 'Z component of vertex location.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetVertex(int index,Point3d vertex)',
        summary: `Sets or adds a vertex to the Vertex List.
     If [index] is less than [Count], the existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of vertex to set.'
          },
          {
            name: 'vertex',
            summary: 'Vertex location.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetVertex(int index,Point3f vertex)',
        summary: `Sets or adds a vertex to the Vertex List.
     If [index] is less than [Count], the existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of vertex to set.'
          },
          {
            name: 'vertex',
            summary: 'Vertex location.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'void Show(int vertexIndex)',
        summary: 'Shows the vertex at the given index.',
        since: 5,
        parameters: [
          {
            name: 'vertexIndex',
            summary: 'Index of vertex to show.'
          }
        ]
      },
      {
        signature: 'void ShowAll()',
        summary: 'Shows all vertices in the mesh.',
        since: 5
      },
      {
        signature: 'float[] ToFloatArray()',
        summary: 'Copies all vertices to a linear array of float in x,y,z order',
        since: 5.9,
        returns: 'The float array.'
      },
      {
        signature: 'Point3d[] ToPoint3dArray()',
        summary: 'Copies all vertices to a new array of Point3d.',
        since: 5,
        returns: 'A new array.'
      },
      {
        signature: 'Point3f[] ToPoint3fArray()',
        summary: 'Copies all vertices to a new array of Point3f.',
        since: 5,
        returns: 'A new array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'MeshVertexNormalList',
    dataType: 1,
    summary: 'Provides access to the Vertex Normals of a Mesh.',
    interfaces: ['IResizableList<Vector3f>', 'IList', 'IReadOnlyList<Vector3f>'],
    properties: [
      {
        signature: 'int Capacity',
        summary: 'Gets or sets the amount of vertex normals that the list can hold without resizing.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int Count',
        summary: 'Gets or sets the number of mesh vertex normals.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'int Add(double x,double y,double z)',
        summary: 'Adds a new vertex normal at the end of the list.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X component of new vertex normal.'
          },
          {
            name: 'y',
            summary: 'Y component of new vertex normal.'
          },
          {
            name: 'z',
            summary: 'Z component of new vertex normal.'
          }
        ],
        returns: 'The index of the newly added vertex normal.'
      },
      {
        signature: 'int Add(float x,float y,float z)',
        summary: 'Adds a new vertex normal at the end of the list.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X component of new vertex normal.'
          },
          {
            name: 'y',
            summary: 'Y component of new vertex normal.'
          },
          {
            name: 'z',
            summary: 'Z component of new vertex normal.'
          }
        ],
        returns: 'The index of the newly added vertex normal.'
      },
      {
        signature: 'int Add(Vector3d normal)',
        summary: 'Adds a new vertex normal at the end of the list.',
        since: 5,
        parameters: [
          {
            name: 'normal',
            summary: 'new vertex normal.'
          }
        ],
        returns: 'The index of the newly added vertex normal.'
      },
      {
        signature: 'int Add(Vector3f normal)',
        summary: 'Adds a new vertex normal at the end of the list.',
        since: 5,
        parameters: [
          {
            name: 'normal',
            summary: 'new vertex normal.'
          }
        ],
        returns: 'The index of the newly added vertex normal.'
      },
      {
        signature: 'bool AddRange(Vector3f[] normals)',
        summary: 'Appends a collection of normal vectors.',
        since: 5,
        parameters: [
          {
            name: 'normals',
            summary: 'Normals to append.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'void Clear()',
        summary: 'Clears the vertex normal collection on the mesh.',
        since: 5
      },
      {
        signature: 'bool ComputeNormals()',
        summary: 'Computes the vertex normals based on the physical shape of the mesh.',
        since: 5,
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'void Destroy()',
        summary: `Releases all memory allocated to store vertex normals. The list capacity will be 0 after this call.
     Subsequent calls can add new items.`,
        since: 6
      },
      {
        signature: 'void Flip()',
        summary: `Reverses direction of all vertex normals
     This is the same as Mesh.Flip(true, false, false)`,
        since: 5
      },
      {
        signature: 'IEnumerator<Vector3f> GetEnumerator()',
        summary: 'Gets an enumerator that yields all normals (vectors) in this collection.',
        since: 5,
        returns: 'The enumerator.'
      },
      {
        signature: 'bool SetNormal(int index,double x,double y,double z)',
        summary: `Sets or adds a vertex normal to the list.
     If [index] is less than [Count], the existing vertex normal at [index] will be modified.If [index] equals [Count], a new vertex normal is appended to the end of the list.If [index] is larger than [Count], the function will return false.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of vertex normal to set.'
          },
          {
            name: 'x',
            summary: 'X component of vertex normal.'
          },
          {
            name: 'y',
            summary: 'Y component of vertex normal.'
          },
          {
            name: 'z',
            summary: 'Z component of vertex normal.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetNormal(int index,float x,float y,float z)',
        summary: `Sets or adds a normal to the list.
     If [index] is less than [Count], the existing vertex normal at [index] will be modified.If [index] equals [Count], a new vertex normal is appended to the end of the list.If [index] is larger than [Count], the function will return false.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of vertex normal to set.'
          },
          {
            name: 'x',
            summary: 'X component of vertex normal.'
          },
          {
            name: 'y',
            summary: 'Y component of vertex normal.'
          },
          {
            name: 'z',
            summary: 'Z component of vertex normal.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetNormal(int index,Vector3d normal)',
        summary: `Sets or adds a vertex normal to the list.
     If [index] is less than [Count], the existing vertex normal at [index] will be modified.If [index] equals [Count], a new vertex normal is appended to the end of the list.If [index] is larger than [Count], the function will return false.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of vertex normal to set.'
          },
          {
            name: 'normal',
            summary: 'The new normal at the index.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetNormal(int index,Vector3f normal)',
        summary: `Sets or adds a vertex normal to the list.
     If [index] is less than [Count], the existing vertex normal at [index] will be modified.If [index] equals [Count], a new vertex normal is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of vertex normal to set.'
          },
          {
            name: 'normal',
            summary: 'The new normal at the index.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetNormals(Vector3f[] normals)',
        summary: 'Sets all normal vectors in one go. This method destroys the current normal array if it exists.',
        since: 5,
        parameters: [
          {
            name: 'normals',
            summary: 'Normals for the entire mesh.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'float[] ToFloatArray()',
        summary: 'Copies all vertex normals to a linear array of float in x,y,z order',
        since: 6,
        returns: 'The float array.'
      },
      {
        signature: 'bool UnitizeNormals()',
        summary: 'Unitizes all vertex normals.',
        since: 5,
        returns: 'True on success, False on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'MeshVertexStatusList',
    dataType: 1,
    summary: 'Provides access to status information relative to components of a mesh.',
    interfaces: ['IResizableList<bool>', 'IList', 'IReadOnlyList<bool>'],
    properties: [
      {
        signature: 'int Capacity',
        summary: 'Gets or sets the total number of hidden vertex information the internal data structure can hold without resizing.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int Count',
        summary: 'Gets or sets the number of hidden vertices. For this to be a valid part of a mesh, this count should be the same as the one of mesh vertices.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int HiddenCount',
        summary: 'Gets a value indicating how many vertices have been set to hidden.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(bool hidden)',
        summary: 'Adds a new flag at the end of the list.',
        since: 6,
        parameters: [
          {
            name: 'hidden',
            summary: 'True if vertex is hidden.'
          }
        ],
        returns: 'The index of the newly added hidden vertex.'
      },
      {
        signature: 'void AddRange(IEnumerable<bool> values)',
        summary: 'Appends an array, a list or any enumerable of flags to the end of the list.',
        since: 6,
        parameters: [
          {
            name: 'values',
            summary: 'Hidden values to append.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'void Clear()',
        summary: 'Clears the hidden vertex list on the mesh. This results in a fully visible mesh.',
        since: 6
      },
      {
        signature: 'bool Contains(bool hidden)',
        summary: 'Determines if some vertices are hidden or some are shown.',
        since: 6,
        parameters: [
          {
            name: 'hidden',
            summary: 'The value to be checked. True means some vertex is hidden.'
          }
        ],
        returns: 'True if the array contains the specified value.'
      },
      {
        signature: 'void CopyTo(bool[] array,int arrayIndex)',
        summary: 'Copies to an array, starting at an index.',
        since: 6,
        parameters: [
          {
            name: 'array',
            summary: 'The array to be copied into.'
          },
          {
            name: 'arrayIndex',
            summary: 'The starting index in the array.'
          }
        ]
      },
      {
        signature: 'void Destroy()',
        summary: `Releases all memory allocated to store hidden vertices. The list capacity will be 0 after this call.
     Vertices will be immediately considered visible.Subsequent calls can add new items.`,
        since: 6
      },
      {
        signature: 'IEnumerator<bool> GetEnumerator()',
        summary: 'Gets an enumerator that yields all flags in this collection.',
        since: 6,
        returns: 'The enumerator.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'NurbsCurveKnotList',
    dataType: 1,
    summary: 'Provides access to the knot vector of a nurbs curve.',
    interfaces: ['IEnumerable<double>', 'IRhinoTable<double>', 'IEpsilonComparable<NurbsCurveKnotList>', 'IList<double>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Total number of knots in this curve.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsClampedEnd',
        summary: `Gets a value indicating whether or not the knot vector is clamped at the end of the curve. 
     Clamped curves are coincident with the first and last control-point. This requires fully multiple knots.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsClampedStart',
        summary: `Gets a value indicating whether or not the knot vector is clamped at the start of the curve. 
     Clamped curves start at the first control-point. This requires fully multiple knots.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool ClampEnd(CurveEnd end)',
        summary: 'Clamp end knots. Does not modify control point locations.',
        since: 5,
        parameters: [
          {
            name: 'end',
            summary: 'Curve end to clamp.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Contains(double item)',
        summary: 'Returns an indication of the presence of a value in the knot list.',
        since: 6,
        parameters: [
          {
            name: 'item',
            summary: 'The item.'
          }
        ],
        returns: 'True if present, False otherwise.'
      },
      {
        signature: 'void CopyTo(double[] array,int arrayIndex)',
        summary: 'Copies the list to an array.',
        since: 6,
        parameters: [
          {
            name: 'array',
            summary: 'The array to copy to.'
          },
          {
            name: 'arrayIndex',
            summary: 'The index into copy will begin.'
          }
        ]
      },
      {
        signature: 'bool CreatePeriodicKnots(double knotSpacing)',
        summary: `Compute a clamped, uniform, periodic knot vector based on the current
     degree and control point count. Does not change values of control
     vertices.`,
        since: 5,
        parameters: [
          {
            name: 'knotSpacing',
            summary: 'Spacing of subsequent knots.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool CreateUniformKnots(double knotSpacing)',
        summary: `Compute a clamped, uniform knot vector based on the current
     degree and control point count. Does not change values of control
     vertices.`,
        since: 5,
        parameters: [
          {
            name: 'knotSpacing',
            summary: 'Spacing of subsequent knots.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'void EnsurePrivateCopy()',
        summary: `If you want to keep a copy of this class around by holding onto it in a variable after a command
     completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can
     call this function as many times as you want.`,
        since: 5
      },
      {
        signature: 'bool EpsilonEquals(NurbsCurveKnotList other,double epsilon)',
        summary: 'Checks that all values in the other list are sequentially equal within epsilon to the values in this list.',
        since: 5.4,
        parameters: [
          {
            name: 'other',
            summary: 'The other list.'
          },
          {
            name: 'epsilon',
            summary: 'The epsilon value.'
          }
        ],
        returns: 'True if values are, orderly, equal within epsilon. False otherwise.'
      },
      {
        signature: 'int IndexOf(double item)',
        summary: 'Returns the first item in the list.',
        since: 6,
        parameters: [
          {
            name: 'item',
            summary: 'The value.'
          }
        ],
        returns: 'The index, or -1 if no index is found.'
      },
      {
        signature: 'bool InsertKnot(double value)',
        summary: `Inserts a knot and update control point locations.
     Does not change parameterization or locus of curve.`,
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'Knot value to insert.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool InsertKnot(double value,int multiplicity)',
        summary: `Inserts a knot and update control point locations.
     Does not change parameterization or locus of curve.`,
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'Knot value to insert.'
          },
          {
            name: 'multiplicity',
            summary: 'Multiplicity of knot to insert.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'int KnotMultiplicity(int index)',
        summary: 'Get knot multiplicity.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of knot to query.'
          }
        ],
        returns: 'The multiplicity (valence) of the knot.'
      },
      {
        signature: 'bool RemoveKnotAt(double t)',
        summary: 'Remove a knot from a curve and adjusts the remaining control points to maintain curve position as closely as possible.',
        since: 6,
        parameters: [
          {
            name: 't',
            summary: 'The parameter on the curve that is closest to the knot to be removed.'
          }
        ],
        returns: 'True if successful, False on failure.'
      },
      {
        signature: 'bool RemoveKnots(int index0,int index1)',
        summary: `Remove knots from a curve and adjusts the remaining control points to maintain curve position as closely as possible.
     The knots from Knots[index0] through Knots[index1 - 1] will be removed.`,
        since: 6,
        parameters: [
          {
            name: 'index0',
            summary: 'The starting knot index, where Degree-1 < index0 < index1 <= Points.Count-1.'
          },
          {
            name: 'index1',
            summary: 'The ending knot index, where Degree-1 < index0 < index1 <= Points.Count-1.'
          }
        ],
        returns: 'True if successful, False on failure.'
      },
      {
        signature: 'int RemoveMultipleKnots(int minimumMultiplicity,int maximumMultiplicity,double tolerance)',
        summary: 'Remove multiple knots from this curve.',
        since: 6,
        parameters: [
          {
            name: 'minimumMultiplicity',
            summary: 'Remove knots with multiplicity > minimumKnotMultiplicity.'
          },
          {
            name: 'maximumMultiplicity',
            summary: 'Remove knots with multiplicity < maximumKnotMultiplicity.'
          },
          {
            name: 'tolerance',
            summary: `When you remove knots, the shape of the curve is changed.
     If tolerance is RhinoMath.UnsetValue, any amount of change is permitted.
     If tolerance is >=0, the maximum distance between the input and output
     curve is restricted to be <= tolerance.`
          }
        ],
        returns: 'number of knots removed on success. 0 if no knots were removed'
      },
      {
        signature: 'double SuperfluousKnot(bool start)',
        summary: `Computes the knots that are superfluous because they are not used in NURBs evaluation.
     These make it appear so that the first and last curve spans are different from interior spans.
     http://wiki.mcneel.com/developer/onsuperfluousknot`,
        since: 5,
        parameters: [
          {
            name: 'start',
            summary: 'True if the query targets the first knot. Otherwise, the last knot.'
          }
        ],
        returns: 'A component.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'NurbsCurvePointList',
    dataType: 1,
    summary: 'Provides access to the control points of a nurbs curve.',
    interfaces: ['IEnumerable<ControlPoint>', 'IRhinoTable<ControlPoint>', 'IEpsilonComparable<NurbsCurvePointList>', 'IList<ControlPoint>'],
    properties: [
      {
        signature: 'double ControlPolygonLength',
        summary: 'Gets the length of the polyline connecting all control points.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Count',
        summary: 'Gets the number of control points in this curve.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int PointSize',
        summary: `Returns the control point size, or the number of doubles per control point. 
     For rational curves, PointSize = Curve.Dimension + 1. 
     For non-rational curves, PointSize = Curve.Dimension.`,
        since: 6.9,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool ChangeEndWeights(double w0,double w1)',
        summary: 'Use a combination of scaling and reparameterization to change the end weights to the specified values.',
        since: 5,
        parameters: [
          {
            name: 'w0',
            summary: 'Weight for first control point.'
          },
          {
            name: 'w1',
            summary: 'Weight for last control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Contains(ControlPoint item)',
        summary: 'Determines if this list contains an item.',
        since: 6,
        parameters: [
          {
            name: 'item',
            summary: 'The exact item to search for.'
          }
        ],
        returns: 'A boolean value.'
      },
      {
        signature: 'Polyline ControlPolygon()',
        summary: `Constructs a polyline through all the control points. 
     Note that periodic curves generate a closed polyline with fewer 
     points than control-points.`,
        since: 5,
        returns: 'A polyline connecting all control points.'
      },
      {
        signature: 'void CopyTo(ControlPoint[] array,int arrayIndex)',
        summary: 'Copied the list to an array.',
        since: 6,
        parameters: [
          {
            name: 'array',
            summary: 'The array to copy to.'
          },
          {
            name: 'arrayIndex',
            summary: 'The index in which the copy will begin.'
          }
        ]
      },
      {
        signature: 'void EnsurePrivateCopy()',
        summary: `If you want to keep a copy of this class around by holding onto it in a variable after a command
     completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can
     call this function as many times as you want.`,
        since: 5
      },
      {
        signature: 'bool EpsilonEquals(NurbsCurvePointList other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool GetPoint(int index,Point3d point)',
        summary: `Gets a world 3-D, or Euclidean, control point at the given index.
     The 4-D representation is (x, y, z, 1.0).`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'Index of control point to get.'
          },
          {
            name: 'point',
            summary: 'Coordinate of control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool GetPoint(int index,Point4d point)',
        summary: `Gets a homogeneous control point at the given index, where the 4-D representation is (x, y, z, w).
     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'Index of control point to get.'
          },
          {
            name: 'point',
            summary: 'Coordinate and weight of control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'double GetWeight(int index)',
        summary: `Gets the weight of a control point at the given index.
     Note, if the curve is non-rational, the weight will be 1.0.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'Index of control point to get.'
          }
        ],
        returns: 'The control point weight if successful, Rhino.Math.UnsetValue otherwise.'
      },
      {
        signature: 'int IndexOf(ControlPoint item)',
        summary: 'Gets the index of a control point, or -1.',
        since: 6,
        parameters: [
          {
            name: 'item',
            summary: 'The exact item to search for.'
          }
        ],
        returns: 'The index.'
      },
      {
        signature: 'bool MakeNonRational()',
        summary: 'Converts the curve to a Non-rational NURBS curve. Non-rational curves have unweighted control points.',
        since: 5,
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool MakeRational()',
        summary: 'Converts the curve to a Rational NURBS curve. Rational NURBS curves have weighted control points.',
        since: 5,
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetPoint(int index,double x,double y,double z)',
        summary: `Sets a world 3-D, or Euclidean, control point at the given index.
     The 4-D representation is (x, y, z, 1.0).`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'Index of control point to set.'
          },
          {
            name: 'x',
            summary: 'X coordinate of control point.'
          },
          {
            name: 'y',
            summary: 'Y coordinate of control point.'
          },
          {
            name: 'z',
            summary: 'Z coordinate of control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetPoint(int index,double x,double y,double z,double weight)',
        summary: `Sets a homogeneous control point at the given index, where the 4-D representation is (x, y, z, w).
     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of control point to set.'
          },
          {
            name: 'x',
            summary: 'X coordinate of control point.'
          },
          {
            name: 'y',
            summary: 'Y coordinate of control point.'
          },
          {
            name: 'z',
            summary: 'Z coordinate of control point.'
          },
          {
            name: 'weight',
            summary: 'Weight of control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetPoint(int index,Point3d point)',
        summary: `Sets a world 3-D, or Euclidean, control point at the given index.
     The 4-D representation is (x, y, z, 1.0).`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of control point to set.'
          },
          {
            name: 'point',
            summary: 'Coordinate of control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetPoint(int index,Point3d point,double weight)',
        summary: `Sets a world 3-D, or Euclidean, control point and weight at a given index.
     The 4-D representation is (x*w, y*w, z*w, w).`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'Index of control point to set.'
          },
          {
            name: 'point',
            summary: 'Coordinates of the control point.'
          },
          {
            name: 'weight',
            summary: 'Weight of control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetPoint(int index,Point4d point)',
        summary: `Sets a homogeneous control point at the given index, where the 4-D representation is (x, y, z, w).
     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of control point to set.'
          },
          {
            name: 'point',
            summary: 'Coordinate and weight of control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetWeight(int index,double weight)',
        summary: `Sets the weight of a control point at the given index
     Note, if the curve is non-rational, it will be converted to rational.`,
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'Index of control point to set.'
          },
          {
            name: 'weight',
            summary: 'The control point weight.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool UVNDirectionsAt(int index,Vector3d uDir,Vector3d vDir,Vector3d nDir)',
        summary: 'Calculates the U, V, and N directions of a NURBS curve control point similar to the method used by Rhino\'s MoveUVN command.',
        since: 7,
        parameters: [
          {
            name: 'index',
            summary: 'Index of control point.'
          },
          {
            name: 'uDir',
            summary: 'The U direction.'
          },
          {
            name: 'vDir',
            summary: 'The V direction.'
          },
          {
            name: 'nDir',
            summary: 'The N direction.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool ValidateSpacing(double closeTolerance,double stackTolerance,int[] closeIndices,int[] stackedIndices)',
        summary: 'Simple check of distance between adjacent control points',
        since: 6,
        parameters: [
          {
            name: 'closeTolerance',
            summary: 'tolerance to use for determining if control points are \'close\''
          },
          {
            name: 'stackTolerance',
            summary: 'tolerance to use for determining if control points are \'stacked\''
          },
          {
            name: 'closeIndices',
            summary: 'indices of \'close\' points are returned in this array'
          },
          {
            name: 'stackedIndices',
            summary: 'indices of \'stacked\' points are returned in this array'
          }
        ],
        returns: 'True if close or stacked indices are found'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'NurbsSurfaceKnotList',
    dataType: 1,
    summary: 'Provides access to the knot vector of a nurbs surface.',
    interfaces: ['IEnumerable<double>', 'Rhino.Collections.IRhinoTable<double>', 'IEpsilonComparable<NurbsSurfaceKnotList>'],
    properties: [
      {
        signature: 'bool ClampedAtEnd',
        summary: 'Determines if a knot vector is clamped.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool ClampedAtStart',
        summary: 'Determines if a knot vector is clamped.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Count',
        summary: 'Gets the total number of knots in this curve.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool CreatePeriodicKnots(double knotSpacing)',
        summary: `Compute a clamped, uniform, periodic knot vector based on the current
     degree and control point count. Does not change values of control
     vertices.`,
        since: 5,
        parameters: [
          {
            name: 'knotSpacing',
            summary: 'Spacing of subsequent knots.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool CreateUniformKnots(double knotSpacing)',
        summary: `Compute a clamped, uniform knot vector based on the current
     degree and control point count. Does not change values of control
     vertices.`,
        since: 5,
        parameters: [
          {
            name: 'knotSpacing',
            summary: 'Spacing of subsequent knots.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'void EnsurePrivateCopy()',
        summary: `If you want to keep a copy of this class around by holding onto it in a variable after a command
     completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can
     call this function as many times as you want.`,
        since: 5
      },
      {
        signature: 'bool EpsilonEquals(NurbsSurfaceKnotList other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool InsertKnot(double value)',
        summary: `Inserts a knot and update control point locations.
     Does not change parameterization or locus of curve.`,
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'Knot value to insert.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool InsertKnot(double value,int multiplicity)',
        summary: `Inserts a knot and update control point locations.
     Does not change parameterization or locus of curve.`,
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'Knot value to insert.'
          },
          {
            name: 'multiplicity',
            summary: 'Multiplicity of knot to insert.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'int KnotMultiplicity(int index)',
        summary: 'Get knot multiplicity.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of knot to query.'
          }
        ],
        returns: 'The multiplicity (valence) of the knot.'
      },
      {
        signature: 'bool RemoveKnots(int index0,int index1)',
        summary: `Remove knots from the knot vector and adjusts the remaining control points to maintain surface position as closely as possible.
     The knots from Knots[index0] through Knots[index1 - 1] will be removed.`,
        since: 6,
        parameters: [
          {
            name: 'index0',
            summary: 'The starting knot index, where Degree-1 < index0 < index1 <= Points.Count-1.'
          },
          {
            name: 'index1',
            summary: 'The ending knot index, where Degree-1 < index0 < index1 <= Points.Count-1.'
          }
        ],
        returns: 'True if successful, False on failure.'
      },
      {
        signature: 'bool RemoveKnotsAt(double u,double v)',
        summary: 'Remove knots from the surface and adjusts the remaining control points to maintain surface position as closely as possible.',
        since: 6,
        parameters: [
          {
            name: 'u',
            summary: 'The u parameter on the surface that is closest to the knot to be removed.'
          },
          {
            name: 'v',
            summary: 'The v parameter on the surface that is closest to the knot to be removed.'
          }
        ],
        returns: 'True if successful, False on failure.'
      },
      {
        signature: 'int RemoveMultipleKnots(int minimumMultiplicity,int maximumMultiplicity,double tolerance)',
        summary: 'Remove multiple knots from this surface',
        since: 6,
        parameters: [
          {
            name: 'minimumMultiplicity',
            summary: 'Remove knots with multiplicity > minimumKnotMultiplicity'
          },
          {
            name: 'maximumMultiplicity',
            summary: 'Remove knots with multiplicity < maximumKnotMultiplicity'
          },
          {
            name: 'tolerance',
            summary: `When you remove knots, the shape of the surface is changed.
     If tolerance is RhinoMath.UnsetValue, any amount of change is permitted.
     If tolerance is >=0, the maximum distance between the input and output
     surface is restricted to be <= tolerance.`
          }
        ],
        returns: 'number of knots removed on success. 0 if no knots were removed'
      },
      {
        signature: 'double SuperfluousKnot(bool start)',
        summary: `Computes the knots that are superfluous because they are not used in NURBs evaluation.
     These make it appear so that the first and last surface spans are different from interior spans.
     http://wiki.mcneel.com/developer/onsuperfluousknot`,
        since: 5,
        parameters: [
          {
            name: 'start',
            summary: 'True if the query targets the first knot. Otherwise, the last knot.'
          }
        ],
        returns: 'A component.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'NurbsSurfacePointList',
    dataType: 1,
    summary: 'Provides access to the control points of a nurbs surface.',
    interfaces: ['IEnumerable<ControlPoint>', 'IEpsilonComparable<NurbsSurfacePointList>'],
    properties: [
      {
        signature: 'int CountU',
        summary: 'Gets the number of control points in the U direction of this surface.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int CountV',
        summary: 'Gets the number of control points in the V direction of this surface.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int PointSize',
        summary: `Returns the control point size, or the number of doubles per control point. 
     For rational curves, PointSize = Surface.Dimension + 1. 
     For non-rational curves, PointSize = Surface.Dimension.`,
        since: 6.9,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void EnsurePrivateCopy()',
        summary: `If you want to keep a copy of this class around by holding onto it in a variable after a command
     completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can
     call this function as many times as you want.`,
        since: 5
      },
      {
        signature: 'bool EpsilonEquals(NurbsSurfacePointList other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'ControlPoint GetControlPoint(int u,int v)',
        summary: 'Gets the control point at the given (u, v) index.',
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'Index of control point in the surface U direction.'
          },
          {
            name: 'v',
            summary: 'Index of control point in the surface V direction.'
          }
        ],
        returns: 'The control point at the given (u, v) index.'
      },
      {
        signature: 'Point2d GetGrevillePoint(int u,int v)',
        summary: 'Gets the 2-D Greville point associated with the control point at the given (u, v) index.',
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'Index of control point in the surface U direction.'
          },
          {
            name: 'v',
            summary: 'Index of control point in the surface V direction.'
          }
        ],
        returns: 'A Surface UV coordinate on success, Point2d.Unset on failure.'
      },
      {
        signature: 'bool GetPoint(int u,int v,Point3d point)',
        summary: `Gets a world 3-D, or Euclidean, control point at the given (u, v) index.
     The 4-D representation is (x, y, z, 1.0).`,
        since: 6,
        parameters: [
          {
            name: 'u',
            summary: 'Index of control point in the surface U direction.'
          },
          {
            name: 'v',
            summary: 'Index of control point in the surface V direction.'
          },
          {
            name: 'point',
            summary: 'Coordinate of control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool GetPoint(int u,int v,Point4d point)',
        summary: `Gets a homogeneous control point at the given (u, v) index, where the 4-D representation is (x, y, z, w).
     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).`,
        since: 6,
        parameters: [
          {
            name: 'u',
            summary: 'Index of control point in the surface U direction.'
          },
          {
            name: 'v',
            summary: 'Index of control point in the surface V direction.'
          },
          {
            name: 'point',
            summary: 'Coordinate and weight of control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'double GetWeight(int u,int v)',
        summary: `Gets the weight of a control point at the given (u, v) index.
     Note, if the surface is non-rational, the weight will be 1.0.`,
        since: 6,
        parameters: [
          {
            name: 'u',
            summary: 'Index of control-point along surface U direction.'
          },
          {
            name: 'v',
            summary: 'Index of control-point along surface V direction.'
          }
        ],
        returns: 'The control point weight if successful, Rhino.Math.UnsetValue otherwise.'
      },
      {
        signature: 'bool SetControlPoint(int u,int v,ControlPoint cp)',
        summary: 'Sets the control point at the given (u, v) index.',
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'Index of control point in the surface U direction.'
          },
          {
            name: 'v',
            summary: 'Index of control point in the surface V direction.'
          },
          {
            name: 'cp',
            summary: 'The control point to set.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetControlPoint(int u,int v,Point3d cp)',
        summary: 'Sets the control point at the given (u, v) index.',
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'Index of control point in the surface U direction.'
          },
          {
            name: 'v',
            summary: 'Index of control point in the surface V direction.'
          },
          {
            name: 'cp',
            summary: 'The control point location to set (weight is assumed to be 1.0).'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetPoint(int u,int v,double x,double y,double z)',
        summary: `Sets a world 3-D, or Euclidean, control point at the given (u, v) index.
     The 4-D representation is (x, y, z, 1.0).`,
        since: 6,
        parameters: [
          {
            name: 'u',
            summary: 'Index of control point in the surface U direction.'
          },
          {
            name: 'v',
            summary: 'Index of control point in the surface V direction.'
          },
          {
            name: 'x',
            summary: 'X coordinate of control point.'
          },
          {
            name: 'y',
            summary: 'Y coordinate of control point.'
          },
          {
            name: 'z',
            summary: 'Z coordinate of control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetPoint(int u,int v,double x,double y,double z,double weight)',
        summary: `Sets a homogeneous control point at the given (u, v) index, where the 4-D representation is (x, y, z, w).
     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).`,
        since: 6,
        parameters: [
          {
            name: 'u',
            summary: 'Index of control point in the surface U direction.'
          },
          {
            name: 'v',
            summary: 'Index of control point in the surface V direction.'
          },
          {
            name: 'x',
            summary: 'X coordinate of control point.'
          },
          {
            name: 'y',
            summary: 'Y coordinate of control point.'
          },
          {
            name: 'z',
            summary: 'Z coordinate of control point.'
          },
          {
            name: 'weight',
            summary: 'Weight of control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetPoint(int u,int v,Point3d point)',
        summary: `Sets a world 3-D, or Euclidean, control point at the given (u, v) index.
     The 4-D representation is (x, y, z, 1.0).`,
        since: 6,
        parameters: [
          {
            name: 'u',
            summary: 'Index of control point in the surface U direction.'
          },
          {
            name: 'v',
            summary: 'Index of control point in the surface V direction.'
          },
          {
            name: 'point',
            summary: 'Coordinate of control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetPoint(int u,int v,Point3d point,double weight)',
        summary: `Sets a world 3-D, or Euclidean, control point and weight at a given index.
     The 4-D representation is (x*w, y*w, z*w, w).`,
        since: 6,
        parameters: [
          {
            name: 'u',
            summary: 'Index of control point in the surface U direction.'
          },
          {
            name: 'v',
            summary: 'Index of control point in the surface V direction.'
          },
          {
            name: 'point',
            summary: 'Coordinates of the control point.'
          },
          {
            name: 'weight',
            summary: 'Weight of control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetPoint(int u,int v,Point4d point)',
        summary: `Sets a homogeneous control point at the given (u, v) index, where the 4-D representation is (x, y, z, w).
     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).`,
        since: 6,
        parameters: [
          {
            name: 'u',
            summary: 'Index of control point in the surface U direction.'
          },
          {
            name: 'v',
            summary: 'Index of control point in the surface V direction.'
          },
          {
            name: 'point',
            summary: 'Coordinate and weight of control point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetWeight(int u,int v,double weight)',
        summary: `Sets the weight of a control point at the given (u, v) index.
     Note, if the surface is non-rational, it will be converted to rational.`,
        since: 6,
        parameters: [
          {
            name: 'u',
            summary: 'Index of control-point along surface U direction.'
          },
          {
            name: 'v',
            summary: 'Index of control-point along surface V direction.'
          },
          {
            name: 'weight',
            summary: 'The control point weight.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool UVNDirectionsAt(int u,int v,Vector3d uDir,Vector3d vDir,Vector3d nDir)',
        summary: 'Calculates the U, V, and N directions of a NURBS surface control point similar to the method used by Rhino\'s MoveUVN command.',
        since: 7,
        parameters: [
          {
            name: 'u',
            summary: 'Index of control-point along surface U direction.'
          },
          {
            name: 'v',
            summary: 'Index of control-point along surface V direction.'
          },
          {
            name: 'uDir',
            summary: 'The U direction.'
          },
          {
            name: 'vDir',
            summary: 'The V direction.'
          },
          {
            name: 'nDir',
            summary: 'The N direction.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool ValidateSpacing(double closeTolerance,double stackTolerance,IndexPair[] closeIndices,IndexPair[] stackedIndices)',
        summary: 'Simple check of distance between adjacent control points',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'SubDEdgeList',
    dataType: 1,
    summary: 'All edges in a SubD',
    interfaces: ['IEnumerable<SubDEdge>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of SubD edges.',
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'SubDEdge Add(SubDEdgeTag tag,SubDVertex v0,SubDVertex v1)',
        summary: 'Add a new edge to the list.',
        since: 7,
        parameters: [
          {
            name: 'tag',
            summary: 'The type of edge tag, such as smooth or corner.'
          },
          {
            name: 'v0',
            summary: 'First vertex.'
          },
          {
            name: 'v1',
            summary: 'Second vertex.'
          }
        ]
      },
      {
        signature: 'SubDEdge Find(int id)',
        summary: 'Find an edge in this SubD with a given id',
        since: 7
      },
      {
        signature: 'SubDEdge Find(uint id)',
        summary: 'Find an edge in this SubD with a given id',
        since: 7
      },
      {
        signature: 'IEnumerator<SubDEdge> GetEnumerator()',
        summary: 'Implementation of IEnumerable',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'SubDFaceList',
    dataType: 1,
    summary: 'All faces in a SubD',
    interfaces: ['IEnumerable<SubDFace>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of SubD faces.',
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'SubDFace Find(int id)',
        summary: 'Find a face in this SubD with a given id',
        since: 7
      },
      {
        signature: 'SubDFace Find(uint id)',
        summary: 'Find a face in this SubD with a given id',
        since: 7
      },
      {
        signature: 'IEnumerator<SubDFace> GetEnumerator()',
        summary: 'Implementation of IEnumerable',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Collections',
    name: 'SubDVertexList',
    dataType: 1,
    summary: 'Provides access to the vertices and vertex-related functionality of a SubD',
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of SubD vertices.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'SubDVertex First',
        summary: 'First vertex in this linked list of vertices',
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'SubDVertex Add(SubDVertexTag tag,Point3d vertex)',
        summary: 'Add a new vertex to the end of the Vertex list.',
        since: 7,
        parameters: [
          {
            name: 'tag',
            summary: 'The type of vertex tag, such as smooth or corner.'
          },
          {
            name: 'vertex',
            summary: 'Location of new vertex.'
          }
        ],
        returns: 'The newly added vertex.'
      },
      {
        signature: 'SubDVertex Find(int id)',
        summary: 'Find a vertex in this SubD with a given id',
        since: 7
      },
      {
        signature: 'SubDVertex Find(uint id)',
        summary: 'Find a vertex in this SubD with a given id',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'ComponentIndex',
    dataType: 2,
    summary: 'Represents an index of an element contained in another object.',
    constructors: [
      {
        signature: 'ComponentIndex(ComponentIndexType type,int index)',
        summary: 'Construct component index with a specific type/index combination',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'static ComponentIndex Unset',
        summary: 'The unset value of component index.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ComponentIndexType ComponentIndexType',
        summary: `The interpretation of Index depends on the Type value.
     Type             m_index interpretation (0 based indices)
     no_type            used when context makes it clear what array is being index
     brep_vertex        Brep.m_V[] array index
     brep_edge          Brep.m_E[] array index
     brep_face          Brep.m_F[] array index
     brep_trim          Brep.m_T[] array index
     brep_loop          Brep.m_L[] array index
     mesh_vertex        Mesh.m_V[] array index
     meshtop_vertex     MeshTopology.m_topv[] array index
     meshtop_edge       MeshTopology.m_tope[] array index
     mesh_face          Mesh.m_F[] array index
     idef_part          InstanceDefinition.m_object_uuid[] array index
     polycurve_segment  PolyCurve::m_segment[] array index
     dim_linear_point   LinearDimension2::POINT_INDEX
     dim_radial_point   RadialDimension2::POINT_INDEX
     dim_angular_point  AngularDimension2::POINT_INDEX
     dim_ordinate_point OrdinateDimension2::POINT_INDEX
     dim_text_point     TextEntity2 origin point.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Index',
        summary: `The interpretation of m_index depends on the m_type value.
     m_type             m_index interpretation (0 based indices)
     no_type            used when context makes it clear what array is being index
     brep_vertex        Brep.m_V[] array index
     brep_edge          Brep.m_E[] array index
     brep_face          Brep.m_F[] array index
     brep_trim          Brep.m_T[] array index
     brep_loop          Brep.m_L[] array index
     mesh_vertex        Mesh.m_V[] array index
     meshtop_vertex     MeshTopology.m_topv[] array index
     meshtop_edge       MeshTopology.m_tope[] array index
     mesh_face          Mesh.m_F[] array index
     idef_part          InstanceDefinition.m_object_uuid[] array index
     polycurve_segment  PolyCurve::m_segment[] array index
     dim_linear_point   LinearDimension2::POINT_INDEX
     dim_radial_point   RadialDimension2::POINT_INDEX
     dim_angular_point  AngularDimension2::POINT_INDEX
     dim_ordinate_point OrdinateDimension2::POINT_INDEX
     dim_text_point     TextEntity2 origin point.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool IsUnset()',
        summary: 'Return True is this component index is the same as the Unset component index',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'ComponentIndexType',
    dataType: 3,
    summary: 'Defines enumerated values to represent component index types.',
    values: [
      {
        signature: 'InvalidType = 0',
        summary: 'Not used. This is the default value of the enumeration type.'
      },
      {
        signature: 'BrepVertex = 1',
        summary: 'Targets a brep vertex index.'
      },
      {
        signature: 'BrepEdge = 2',
        summary: 'Targets a brep edge index.'
      },
      {
        signature: 'BrepFace = 3',
        summary: 'Targets a brep face index.'
      },
      {
        signature: 'BrepTrim = 4',
        summary: 'Targets a brep trim index.'
      },
      {
        signature: 'BrepLoop = 5',
        summary: 'Targets a brep loop index.'
      },
      {
        signature: 'MeshVertex = 11',
        summary: 'Targets a mesh vertex index.'
      },
      {
        signature: 'MeshTopologyVertex = 12',
        summary: 'Targets a mesh topology vertex index.'
      },
      {
        signature: 'MeshTopologyEdge = 13',
        summary: 'Targets a mesh topology edge index.'
      },
      {
        signature: 'MeshFace = 14',
        summary: 'Targets a mesh face index.'
      },
      {
        signature: 'MeshNgon = 15',
        summary: 'Targets a mesh ngon index.'
      },
      {
        signature: 'InstanceDefinitionPart = 21',
        summary: 'Targets an instance definition part index.'
      },
      {
        signature: 'PolycurveSegment = 31',
        summary: 'Targets a polycurve segment index.'
      },
      {
        signature: 'PointCloudPoint = 41',
        summary: 'Targets a pointcloud point index.'
      },
      {
        signature: 'GroupMember = 51',
        summary: 'Targets a group member index.'
      },
      {
        signature: 'ExtrusionBottomProfile = 61',
        summary: '3d bottom profile curves. Index identifies profile component'
      },
      {
        signature: 'ExtrusionTopProfile = 62',
        summary: '3d top profile curves. Index identifies profile component'
      },
      {
        signature: 'ExtrusionWallEdge = 63',
        summary: `3d wall edge curve.
     Index/2: identifies profile component
     Index%2: 0=start, 1=end`
      },
      {
        signature: 'ExtrusionWallSurface = 64',
        summary: `Side wall surfaces.
     Index identifies profile component`
      },
      {
        signature: 'ExtrusionCapSurface = 65',
        summary: 'Bottom and top cap surfaces. Index 0=bottom, 1=top'
      },
      {
        signature: 'ExtrusionPath = 66',
        summary: 'Extrusion path (axis line). Index -1=entire path, 0=start point, 1=endpoint'
      },
      {
        signature: 'SubdVertex = 71',
        summary: 'Targets a SubD vertex pointer Id. Ids are not guaranteed to be sequential.'
      },
      {
        signature: 'SubdEdge = 72',
        summary: 'Targets a SubD edge pointer Id. Ids are not guaranteed to be sequential.'
      },
      {
        signature: 'SubdFace = 73',
        summary: 'Targets a SubD face pointer Id. Ids are not guaranteed to be sequential.'
      },
      {
        signature: 'DimLinearPoint = 100',
        summary: 'Targets a linear dimension point index.'
      },
      {
        signature: 'DimRadialPoint = 101',
        summary: 'Targets a radial dimension point index.'
      },
      {
        signature: 'DimAngularPoint = 102',
        summary: 'Targets an angular dimension point index.'
      },
      {
        signature: 'DimOrdinatePoint = 103',
        summary: 'Targets an ordinate dimension point index.'
      },
      {
        signature: 'DimTextPoint = 104',
        summary: 'Targets a text point index.'
      },
      {
        signature: 'NoType = 0x0FFFFFFF',
        summary: 'Targets no specific type.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'ComponentStatus',
    dataType: 2,
    summary: `Provides information about selection, highlighting, visibility, editability and integrity states of a component.
   This structure is immutable.`,
    properties: [
      {
        signature: 'static ComponentStatus AllSet',
        summary: 'All flags are checked.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static ComponentStatus Clear',
        summary: 'This is the default value and equal to undefined.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static ComponentStatus Damaged',
        summary: 'The damaged flag is checked.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static ComponentStatus Hidden',
        summary: 'The hidden flag is checked.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static ComponentStatus Highlighted',
        summary: 'The highlight selection flag is checked.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static ComponentStatus Locked',
        summary: 'The locked flag is checked.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static ComponentStatus Selected',
        summary: 'The selection flag is checked.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static ComponentStatus SelectedPersistent',
        summary: 'The persistent selection flag is checked.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsClear',
        summary: 'True if every setting is 0 or false.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsDamaged',
        summary: 'Returns False if component is not damaged. True otherwise.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsHidden',
        summary: 'Returns True if hidden. False otherwise.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsHighlighted',
        summary: 'Returns True if highlighted. False otherwise.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsLocked',
        summary: 'Returns True if locked. False otherwise.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsSelected',
        summary: 'Returns True if selected or selected persistent. False otherwise.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsSelectedPersistent',
        summary: 'Returns True if selected persistent. False otherwise.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool Equals(ComponentStatus other)',
        summary: 'Determines if another ComponentStatus and this are equal.',
        since: 6,
        parameters: [
          {
            name: 'other',
            summary: 'A ComponentStatus.'
          }
        ],
        returns: 'True if equal in value. False otherwise'
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines if an object and this are equal.',
        parameters: [
          {
            name: 'obj',
            summary: 'An object.'
          }
        ],
        returns: 'True if equal in value. False otherwise'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Serves as a special hash function. The inner value is used for the purpose.',
        returns: 'An integer deriving from a bit mask.'
      },
      {
        signature: 'bool HasAllEqualStates(ComponentStatus statesFilter,ComponentStatus comparand)',
        summary: 'For the purposes of this test, Selected and SelectedPersistent are considered equal.',
        since: 6,
        parameters: [
          {
            name: 'statesFilter',
            summary: 'If no states are specified, then False is returned.'
          },
          {
            name: 'comparand',
            summary: `If a state is set in states_filter, the corresponding state
     in "this" and comparand will be tested.`
          }
        ],
        returns: 'True if at all tested states in "this" and comparand are identical.'
      },
      {
        signature: 'bool HasNoEqualStates(ComponentStatus statesFilter,ComponentStatus comparand)',
        summary: 'For the purposes of this test, Selected and SelectedPersistent are considered equal.',
        since: 6,
        parameters: [
          {
            name: 'statesFilter',
            summary: 'If no states are specified, then False is returned.'
          },
          {
            name: 'comparand',
            summary: `If a state is set in states_filter, the corresponding state
     in "this" and comparand will be tested.`
          }
        ],
        returns: 'True if at all tested states in "this" and comparand are identical.'
      },
      {
        signature: 'bool HasSomeEqualStates(ComponentStatus statesFilter,ComponentStatus comparand)',
        summary: 'For the purposes of this test, Selected and SelectedPersistent are considered equal.',
        since: 6,
        parameters: [
          {
            name: 'statesFilter',
            summary: 'If no states are specified, then False is returned.'
          },
          {
            name: 'comparand',
            summary: `If a state is set in states_filter, the corresponding state
     in "this" and comparand will be tested.`
          }
        ],
        returns: 'True if at least one tested state in "this" and comparand are identical.'
      },
      {
        signature: 'string ToString()',
        summary: 'Provides a string representation of this ComponentStatus.',
        returns: 'The representation in English.'
      },
      {
        signature: 'ComponentStatus WithStates(ComponentStatus additionalStatus)',
        summary: `Activates any information flag described in any of the two input component statuses
     and returns a new ComponentStatus with those flags checked.`,
        since: 6,
        parameters: [
          {
            name: 'additionalStatus',
            summary: 'To be used for adding status values.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Concavity',
    dataType: 3,
    summary: 'Enumerates the possible types of edge concavity types.',
    values: [
      {
        signature: 'None = -1',
        summary: `Concavity is not relevant, for example naked and non-manifold edges
     cannot have a concavity measure.`
      },
      {
        signature: 'Tangent = 0',
        summary: 'Faces on either side of the edge are tangent within tolerance.'
      },
      {
        signature: 'Convex = 1',
        summary: 'Faces on either side of the edge are convex.'
      },
      {
        signature: 'Concave = 2',
        summary: 'Faces on either side of the edge are concave.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Cone',
    dataType: 2,
    summary: 'Represents the center plane, radius and height values in a right circular cone.',
    constructors: [
      {
        signature: 'Cone(Plane plane,double height,double radius)',
        summary: 'Initializes a new cone with a specified base plane, height and radius.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Base plane of cone.  The apex of the cone is at the plane\'s origin.'
          },
          {
            name: 'height',
            summary: 'Height of cone.'
          },
          {
            name: 'radius',
            summary: 'Radius of cone.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Cone Unset',
        summary: 'Gets an invalid Cone.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d ApexPoint',
        summary: 'Point at tip of the cone.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d Axis',
        summary: 'Unit vector axis of cone.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d BasePoint',
        summary: 'Center of base circle.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Height',
        summary: 'Gets or sets the height of the circular right cone.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsValid',
        summary: 'True if plane is valid, height is not zero and radius is not zero.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Plane Plane',
        summary: 'Gets or sets the base plane of the cone.  The apex of the cone is at the plane\'s origin.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Radius',
        summary: 'Gets or sets the radius of the cone.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'double AngleInDegrees()',
        summary: `Computes the angle (in degrees) between the axis and the 
     side of the cone.
     The angle and the height have the same sign.`,
        since: 5,
        returns: 'An angle in degrees.'
      },
      {
        signature: 'double AngleInRadians()',
        summary: `Computes the angle (in radians) between the axis and the 
     side of the cone.
     The angle and the height have the same sign.`,
        since: 5,
        returns: 'Math.Atan(Radius / Height) if the height is not 0; 0 if the radius is 0; Math.PI otherwise.'
      },
      {
        signature: 'bool EpsilonEquals(Cone other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'Brep ToBrep(bool capBottom)',
        summary: `Gets a Brep representation of the cone with a single
     face for the cone, an edge along the cone seam, 
     and vertices at the base and apex ends of this seam edge.
     The optional cap is a single face with one circular edge 
     starting and ending at the base vertex.`,
        since: 5,
        parameters: [
          {
            name: 'capBottom',
            summary: 'True if the bottom should be filled with a surface. False otherwise.'
          }
        ],
        returns: 'A brep (polysurface) representation of this cone values.'
      },
      {
        signature: 'NurbsSurface ToNurbsSurface()',
        summary: `Constructs a Nurbs surface representation of this Cone. 
     This is synonymous with calling NurbsSurface.CreateFromCone().`,
        since: 5,
        returns: 'A Nurbs surface representation of the cone or null.'
      },
      {
        signature: 'RevSurface ToRevSurface()',
        summary: `Constructs a RevSurface representation of this Cone. 
     This is synonymous with calling RevSurface.CreateFromCone().`,
        since: 5,
        returns: 'A RevSurface representation of the cone or null.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'ConicSectionType',
    dataType: 3,
    summary: 'Defines enumerated values for types of conic sections.',
    values: [
      {
        signature: 'Unknown = 0',
        summary: 'The curve shape is unknown.'
      },
      {
        signature: 'Circle = 1',
        summary: 'The curve has the shape of a circle.'
      },
      {
        signature: 'Ellipse = 2',
        summary: 'The curve has the shape of an ellipse.'
      },
      {
        signature: 'Hyperbola = 3',
        summary: 'The curve has the shape of a hyperbola.'
      },
      {
        signature: 'Parabola = 4',
        summary: 'The curve has the shape of a parabola.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Continuity',
    dataType: 3,
    summary: `Provides enumerated values for continuity along geometry,
     such as continuous first derivative or continuous unit tangent and curvature.`,
    values: [
      {
        signature: 'None = 0',
        summary: 'There is no continuity.'
      },
      {
        signature: 'C0_continuous = 1',
        summary: `Continuous Function : Test for parametric continuity. In particular, all types of curves
       are considered infinitely continuous at the start/end of the evaluation domain.`
      },
      {
        signature: 'C1_continuous = 2',
        summary: `Continuous first derivative : Test for parametric continuity. In particular,
       all types of curves are considered infinitely continuous at the start/end
       of the evaluation domain.`
      },
      {
        signature: 'C2_continuous = 3',
        summary: `Continuous first derivative and second derivative : Test for parametric continuity.
       In particular, all types of curves are considered infinitely continuous at the
       start/end of the evaluation domain.`
      },
      {
        signature: 'G1_continuous = 4',
        summary: `Continuous unit tangent : Test for parametric continuity. In particular, all types of
       curves are considered infinitely continuous at the start/end of the evaluation domain.`
      },
      {
        signature: 'G2_continuous = 5',
        summary: `Continuous unit tangent and curvature : Test for parametric continuity. In particular,
       all types of curves are considered infinitely continuous at the start/end of the
       evaluation domain.`
      },
      {
        signature: 'C0_locus_continuous = 6',
        summary: `Locus continuous function :
       Continuity tests using the following enum values are identical to tests using the
       preceding enum values on the INTERIOR of a curve's domain. At the END of a curve
       a "locus" test is performed in place of a parametric test. In particular, at the
       END of a domain, all open curves are locus discontinuous. At the END of a domain,
       all closed curves are at least C0_locus_continuous. By convention all Curves
       are considered locus continuous at the START of the evaluation domain. This
       convention is not strictly correct, but it was adopted to make iterative kink
       finding tools easier to use and so that locus discontinuities are reported once
       at the end parameter of a curve rather than twice.`
      },
      {
        signature: 'C1_locus_continuous = 7',
        summary: `Locus continuous first derivative :
       Continuity tests using the following enum values are identical to tests using the
       preceding enum values on the INTERIOR of a curve's domain. At the END of a curve
       a "locus" test is performed in place of a parametric test. In particular, at the
       END of a domain, all open curves are locus discontinuous. At the END of a domain,
       all closed curves are at least C0_locus_continuous. By convention all Curves
       are considered locus continuous at the START of the evaluation domain. This
       convention is not strictly correct, but it was adopted to make iterative kink
       finding tools easier to use and so that locus discontinuities are reported once
       at the end parameter of a curve rather than twice.`
      },
      {
        signature: 'C2_locus_continuous = 8',
        summary: `Locus continuous first and second derivative :
       Continuity tests using the following enum values are identical to tests using the
       preceding enum values on the INTERIOR of a curve's domain. At the END of a curve
       a "locus" test is performed in place of a parametric test. In particular, at the
       END of a domain, all open curves are locus discontinuous. At the END of a domain,
       all closed curves are at least C0_locus_continuous. By convention all Curves
       are considered locus continuous at the START of the evaluation domain. This
       convention is not strictly correct, but it was adopted to make iterative kink
       finding tools easier to use and so that locus discontinuities are reported once
       at the end parameter of a curve rather than twice.`
      },
      {
        signature: 'G1_locus_continuous = 9',
        summary: `Locus continuous unit tangent :
       Continuity tests using the following enum values are identical to tests using the
       preceding enum values on the INTERIOR of a curve's domain. At the END of a curve
       a "locus" test is performed in place of a parametric test. In particular, at the
       END of a domain, all open curves are locus discontinuous. At the END of a domain,
       all closed curves are at least C0_locus_continuous. By convention all Curves
       are considered locus continuous at the START of the evaluation domain. This
       convention is not strictly correct, but it was adopted to make iterative kink
       finding tools easier to use and so that locus discontinuities are reported once
       at the end parameter of a curve rather than twice.`
      },
      {
        signature: 'G2_locus_continuous = 10',
        summary: `Locus continuous unit tangent and curvature :
       Continuity tests using the following enum values are identical to tests using the
       preceding enum values on the INTERIOR of a curve's domain. At the END of a curve
       a "locus" test is performed in place of a parametric test. In particular, at the
       END of a domain, all open curves are locus discontinuous. At the END of a domain,
       all closed curves are at least C0_locus_continuous. By convention all Curves
       are considered locus continuous at the START of the evaluation domain. This
       convention is not strictly correct, but it was adopted to make iterative kink
       finding tools easier to use and so that locus discontinuities are reported once
       at the end parameter of a curve rather than twice.`
      },
      {
        signature: 'Cinfinity_continuous = 11',
        summary: 'Analytic discontinuity. Cinfinity_continuous is a euphanisim for "at a knot".'
      },
      {
        signature: 'Gsmooth_continuous = 12',
        summary: 'Aesthetic discontinuity'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'ControlPoint',
    dataType: 2,
    summary: 'Represents control point geometry with three-dimensional position and weight.',
    constructors: [
      {
        signature: 'ControlPoint(double x,double y,double z)',
        summary: `Constructs a new world 3-D, or Euclidean, control point.
     The 4-D representation is (x, y, z, 1.0).`,
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X coordinate of the control point.'
          },
          {
            name: 'y',
            summary: 'Y coordinate of the control point.'
          },
          {
            name: 'z',
            summary: 'Z coordinate of the control pointt.'
          }
        ]
      },
      {
        signature: 'ControlPoint(double x,double y,double z,double weight)',
        summary: `Constructs a new homogeneous control point, where the 4-D representation is (x, y, z, w).
     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).`,
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X coordinate of the control point.'
          },
          {
            name: 'y',
            summary: 'Y coordinate of the control point.'
          },
          {
            name: 'z',
            summary: 'Z coordinate of the control point.'
          },
          {
            name: 'weight',
            summary: 'Weight factor of the control point. You should not use weights less than or equal to zero.'
          }
        ]
      },
      {
        signature: 'ControlPoint(Point3d pt)',
        summary: `Constructs a new world 3-D, or Euclidean, control point.
     The 4-D representation of this is (x, y, z, 1.0).`,
        since: 5,
        parameters: [
          {
            name: 'pt',
            summary: 'Coordinates of the control point.'
          }
        ]
      },
      {
        signature: 'ControlPoint(Point3d euclideanPt,double weight)',
        summary: `Constructs a control point from a world 3-D, or Euclidean, location and a weight.
     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).`,
        since: 5,
        parameters: [
          {
            name: 'euclideanPt',
            summary: 'Coordinates of the control point.'
          },
          {
            name: 'weight',
            summary: 'Weight factor of the control point. You should not use weights less than or equal to zero.'
          }
        ]
      },
      {
        signature: 'ControlPoint(Point4d pt)',
        summary: `Constructs a new homogeneous control point, where the 4-D representation is (x, y, z, w).
     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).`,
        since: 5,
        parameters: [
          {
            name: 'pt',
            summary: 'Coordinates of the control point.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static ControlPoint Unset',
        summary: 'Gets the predefined, unset control point.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d Location',
        summary: 'Gets or sets world 3-D, or Euclidean location of the control point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Weight',
        summary: 'Gets or sets the weight of this control point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double X',
        summary: 'Gets or sets the X coordinate of the control point.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double Y',
        summary: 'Gets or sets the Y coordinate of the control point.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double Z',
        summary: 'Gets or sets the Z coordinate of the control point.',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'bool EpsilonEquals(ControlPoint other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(ControlPoint other)',
        summary: 'Determines if two points exactly match.',
        since: 6,
        parameters: [
          {
            name: 'other',
            summary: 'The other point.'
          }
        ],
        returns: 'True if the other control point exactly matches this one.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Curve',
    dataType: 1,
    summary: `Represents a base class that is common to most RhinoCommon curve types.
   A curve represents an entity that can be all visited by providing
   a single parameter, usually called t.`,
    baseclass: 'Rhino.Geometry.GeometryBase',
    properties: [
      {
        signature: 'int Degree',
        summary: `Gets the maximum algebraic degree of any span
     or a good estimate if curve spans are not algebraic.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Dimension',
        summary: `Gets the dimension of the object.
     The dimension is typically three. For parameter space trimming
     curves the dimension is two. In rare cases the dimension can
     be one or greater than three.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Interval Domain',
        summary: 'Gets or sets the domain of the curve.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsClosed',
        summary: 'Gets a value indicating whether or not this curve is a closed curve.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsPeriodic',
        summary: 'Gets a value indicating whether or not this curve is considered to be Periodic.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d PointAtEnd',
        summary: 'Evaluates point at the end of the curve.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d PointAtStart',
        summary: 'Evaluates point at the start of the curve.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int SpanCount',
        summary: 'Gets the number of non-empty smooth (c-infinity) spans in the curve.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d TangentAtEnd',
        summary: 'Evaluate unit tangent vector at the end of the curve.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d TangentAtStart',
        summary: 'Evaluates the unit tangent vector at the start of the curve.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Curve CreateArcBlend(Point3d startPt,Vector3d startDir,Point3d endPt,Vector3d endDir,double controlPointLengthRatio)',
        summary: 'Creates a polycurve consisting of two tangent arc segments that connect two points and two directions.',
        since: 6.1,
        parameters: [
          {
            name: 'startPt',
            summary: 'Start of the arc blend curve.'
          },
          {
            name: 'startDir',
            summary: 'Start direction of the arc blend curve.'
          },
          {
            name: 'endPt',
            summary: 'End of the arc blend curve.'
          },
          {
            name: 'endDir',
            summary: 'End direction of the arc blend curve.'
          },
          {
            name: 'controlPointLengthRatio',
            summary: `The ratio of the control polygon lengths of the two arcs. Note, a value of 1.0 
     means the control polygon lengths for both arcs will be the same.`
          }
        ],
        returns: 'The arc blend curve, or None on error.'
      },
      {
        signature: 'static Curve CreateBlendCurve(Curve curveA,Curve curveB,BlendContinuity continuity)',
        summary: 'Create a Blend curve between two existing curves.',
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'Curve to blend from (blending will occur at curve end point).'
          },
          {
            name: 'curveB',
            summary: 'Curve to blend to (blending will occur at curve start point).'
          },
          {
            name: 'continuity',
            summary: 'Continuity of blend.'
          }
        ],
        returns: 'A curve representing the blend between A and B or None on failure.'
      },
      {
        signature: 'static Curve CreateBlendCurve(Curve curveA,Curve curveB,BlendContinuity continuity,double bulgeA,double bulgeB)',
        summary: 'Create a Blend curve between two existing curves.',
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'Curve to blend from (blending will occur at curve end point).'
          },
          {
            name: 'curveB',
            summary: 'Curve to blend to (blending will occur at curve start point).'
          },
          {
            name: 'continuity',
            summary: 'Continuity of blend.'
          },
          {
            name: 'bulgeA',
            summary: 'Bulge factor at curveA end of blend. Values near 1.0 work best.'
          },
          {
            name: 'bulgeB',
            summary: 'Bulge factor at curveB end of blend. Values near 1.0 work best.'
          }
        ],
        returns: 'A curve representing the blend between A and B or None on failure.'
      },
      {
        signature: 'static Curve CreateBlendCurve(Curve curve0,double t0,bool reverse0,BlendContinuity continuity0,Curve curve1,double t1,bool reverse1,BlendContinuity continuity1)',
        summary: `Makes a curve blend between 2 curves at the parameters specified
     with the directions and continuities specified`,
        since: 5,
        parameters: [
          {
            name: 'curve0',
            summary: 'First curve to blend from'
          },
          {
            name: 't0',
            summary: 'Parameter on first curve for blend endpoint'
          },
          {
            name: 'reverse0',
            summary: `If false, the blend will go in the natural direction of the curve.
     If true, the blend will go in the opposite direction to the curve`
          },
          {
            name: 'continuity0',
            summary: 'Continuity for the blend at the start'
          },
          {
            name: 'curve1',
            summary: 'Second curve to blend from'
          },
          {
            name: 't1',
            summary: 'Parameter on second curve for blend endpoint'
          },
          {
            name: 'reverse1',
            summary: `If false, the blend will go in the natural direction of the curve.
     If true, the blend will go in the opposite direction to the curve`
          },
          {
            name: 'continuity1',
            summary: 'Continuity for the blend at the end'
          }
        ],
        returns: 'The blend curve on success. None on failure'
      },
      {
        signature: 'static Curve[] CreateBooleanDifference(Curve curveA,Curve curveB)',
        summary: `Calculates the boolean difference between two closed, planar curves. 
     Note, curves must be co-planar.`,
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'The first closed, planar curve.'
          },
          {
            name: 'curveB',
            summary: 'The second closed, planar curve.'
          }
        ],
        returns: 'Result curves on success, empty array if no difference could be calculated.'
      },
      {
        signature: 'static Curve[] CreateBooleanDifference(Curve curveA,Curve curveB,double tolerance)',
        summary: `Calculates the boolean difference between two closed, planar curves. 
     Note, curves must be co-planar.`,
        since: 6,
        parameters: [
          {
            name: 'curveA',
            summary: 'The first closed, planar curve.'
          },
          {
            name: 'curveB',
            summary: 'The second closed, planar curve.'
          },
          {
            name: 'tolerance',
            summary: ''
          }
        ],
        returns: 'Result curves on success, empty array if no difference could be calculated.'
      },
      {
        signature: 'static Curve[] CreateBooleanDifference(Curve curveA,IEnumerable<Curve> subtractors)',
        summary: `Calculates the boolean difference between a closed planar curve, and a list of closed planar curves. 
     Note, curves must be co-planar.`,
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'The first closed, planar curve.'
          },
          {
            name: 'subtractors',
            summary: 'curves to subtract from the first closed curve.'
          }
        ],
        returns: 'Result curves on success, empty array if no difference could be calculated.'
      },
      {
        signature: 'static Curve[] CreateBooleanDifference(Curve curveA,IEnumerable<Curve> subtractors,double tolerance)',
        summary: `Calculates the boolean difference between a closed planar curve, and a list of closed planar curves. 
     Note, curves must be co-planar.`,
        since: 6,
        parameters: [
          {
            name: 'curveA',
            summary: 'The first closed, planar curve.'
          },
          {
            name: 'subtractors',
            summary: 'curves to subtract from the first closed curve.'
          },
          {
            name: 'tolerance',
            summary: ''
          }
        ],
        returns: 'Result curves on success, empty array if no difference could be calculated.'
      },
      {
        signature: 'static Curve[] CreateBooleanIntersection(Curve curveA,Curve curveB)',
        summary: `Calculates the boolean intersection of two closed, planar curves. 
     Note, curves must be co-planar.`,
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'The first closed, planar curve.'
          },
          {
            name: 'curveB',
            summary: 'The second closed, planar curve.'
          }
        ],
        returns: 'Result curves on success, empty array if no intersection could be calculated.'
      },
      {
        signature: 'static Curve[] CreateBooleanIntersection(Curve curveA,Curve curveB,double tolerance)',
        summary: `Calculates the boolean intersection of two closed, planar curves. 
     Note, curves must be co-planar.`,
        since: 6,
        parameters: [
          {
            name: 'curveA',
            summary: 'The first closed, planar curve.'
          },
          {
            name: 'curveB',
            summary: 'The second closed, planar curve.'
          },
          {
            name: 'tolerance',
            summary: ''
          }
        ],
        returns: 'Result curves on success, empty array if no intersection could be calculated.'
      },
      {
        signature: 'static CurveBooleanRegions CreateBooleanRegions(IEnumerable<Curve> curves,Plane plane,bool combineRegions,double tolerance)',
        summary: 'Calculates curve Boolean regions, which trims and splits curves based on their overlapping regions.',
        since: 7,
        parameters: [
          {
            name: 'curves',
            summary: 'The input curves.'
          },
          {
            name: 'plane',
            summary: 'Regions will be found in the projection of the curves to this plane.'
          },
          {
            name: 'combineRegions',
            summary: 'If true, then adjacent regions will be combined.'
          },
          {
            name: 'tolerance',
            summary: 'Function tolerance. When in doubt, use the document\'s model absolute tolerance.'
          }
        ],
        returns: 'The curve Boolean regions if successful, None of no successful.'
      },
      {
        signature: 'static CurveBooleanRegions CreateBooleanRegions(IEnumerable<Curve> curves,Plane plane,IEnumerable<Point3d> points,bool combineRegions,double tolerance)',
        summary: 'Curve Boolean method, which trims and splits curves based on their overlapping regions.',
        since: 7,
        parameters: [
          {
            name: 'curves',
            summary: 'The input curves.'
          },
          {
            name: 'plane',
            summary: 'Regions will be found in the projection of the curves to this plane.'
          },
          {
            name: 'points',
            summary: 'These points will be projected to plane. All regions that contain at least one of these points will be found.'
          },
          {
            name: 'combineRegions',
            summary: 'If true, then adjacent regions will be combined.'
          },
          {
            name: 'tolerance',
            summary: 'Function tolerance. When in doubt, use the document\'s model absolute tolerance.'
          }
        ],
        returns: 'The curve Boolean regions if successful, None of no successful.'
      },
      {
        signature: 'static Curve[] CreateBooleanUnion(IEnumerable<Curve> curves)',
        summary: `Calculates the boolean union of two or more closed, planar curves. 
     Note, curves must be co-planar.`,
        since: 5,
        parameters: [
          {
            name: 'curves',
            summary: 'The co-planar curves to union.'
          }
        ],
        returns: 'Result curves on success, empty array if no union could be calculated.'
      },
      {
        signature: 'static Curve[] CreateBooleanUnion(IEnumerable<Curve> curves,double tolerance)',
        summary: `Calculates the boolean union of two or more closed, planar curves. 
     Note, curves must be co-planar.`,
        since: 6,
        parameters: [
          {
            name: 'curves',
            summary: 'The co-planar curves to union.'
          },
          {
            name: 'tolerance',
            summary: ''
          }
        ],
        returns: 'Result curves on success, empty array if no union could be calculated.'
      },
      {
        signature: 'static Curve CreateControlPointCurve(IEnumerable<Point3d> points)',
        summary: 'Constructs a control-point of degree=3 (or less).',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Control points of curve.'
          }
        ]
      },
      {
        signature: 'static Curve CreateControlPointCurve(IEnumerable<Point3d> points,int degree)',
        summary: 'Constructs a curve from a set of control-point locations.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Control points.'
          },
          {
            name: 'degree',
            summary: 'Degree of curve. The number of control points must be at least degree+1.'
          }
        ]
      },
      {
        signature: 'static Curve[] CreateCurve2View(Curve curveA,Curve curveB,Vector3d vectorA,Vector3d vectorB,double tolerance,double angleTolerance)',
        summary: `Creates a third curve from two curves that are planar in different construction planes. 
     The new curve looks the same as each of the original curves when viewed in each plane.`,
        since: 6,
        parameters: [
          {
            name: 'curveA',
            summary: 'The first curve.'
          },
          {
            name: 'curveB',
            summary: 'The second curve.'
          },
          {
            name: 'vectorA',
            summary: 'A vector defining the normal direction of the plane which the first curve is drawn upon.'
          },
          {
            name: 'vectorB',
            summary: 'A vector defining the normal direction of the plane which the seconf curve is drawn upon.'
          },
          {
            name: 'tolerance',
            summary: 'The tolerance for the operation.'
          },
          {
            name: 'angleTolerance',
            summary: 'The angle tolerance for the operation.'
          }
        ],
        returns: 'An array containing one or more curves if successful.'
      },
      {
        signature: 'static Arc CreateFillet(Curve curve0,Curve curve1,double radius,double t0Base,double t1Base)',
        summary: 'Computes the fillet arc for a curve filleting operation.',
        since: 5,
        parameters: [
          {
            name: 'curve0',
            summary: 'First curve to fillet.'
          },
          {
            name: 'curve1',
            summary: 'Second curve to fillet.'
          },
          {
            name: 'radius',
            summary: 'Fillet radius.'
          },
          {
            name: 't0Base',
            summary: 'Parameter on curve0 where the fillet ought to start (approximately).'
          },
          {
            name: 't1Base',
            summary: 'Parameter on curve1 where the fillet ought to end (approximately).'
          }
        ],
        returns: 'The fillet arc on success, or Arc.Unset on failure.'
      },
      {
        signature: 'static Curve CreateFilletCornersCurve(Curve curve,double radius,double tolerance,double angleTolerance)',
        summary: 'Rounds the corners of a kinked curve with arcs of a single, specified radius.',
        since: 6,
        parameters: [
          {
            name: 'curve',
            summary: 'The curve to fillet.'
          },
          {
            name: 'radius',
            summary: 'The fillet radius.'
          },
          {
            name: 'tolerance',
            summary: 'The tolerance. When in doubt, use the document\'s model space absolute tolerance.'
          },
          {
            name: 'angleTolerance',
            summary: 'The angle tolerance in radians. When in doubt, use the document\'s model space angle tolerance.'
          }
        ],
        returns: 'The filleted curve if successful. None on failure.'
      },
      {
        signature: 'static Curve[] CreateFilletCurves(Curve curve0,Point3d point0,Curve curve1,Point3d point1,double radius,bool join,bool trim,bool arcExtension,double tolerance,double angleTolerance)',
        summary: 'Creates a tangent arc between two curves and trims or extends the curves to the arc.',
        since: 5.1,
        parameters: [
          {
            name: 'curve0',
            summary: 'The first curve to fillet.'
          },
          {
            name: 'point0',
            summary: `A point on the first curve that is near the end where the fillet will
     be created.`
          },
          {
            name: 'curve1',
            summary: 'The second curve to fillet.'
          },
          {
            name: 'point1',
            summary: `A point on the second curve that is near the end where the fillet will
     be created.`
          },
          {
            name: 'radius',
            summary: 'The radius of the fillet.'
          },
          {
            name: 'join',
            summary: 'Join the output curves.'
          },
          {
            name: 'trim',
            summary: 'Trim copies of the input curves to the output fillet curve.'
          },
          {
            name: 'arcExtension',
            summary: `Applies when arcs are filleted but need to be extended to meet the
     fillet curve or chamfer line. If true, then the arc is extended
     maintaining its validity. If false, then the arc is extended with a
     line segment, which is joined to the arc converting it to a polycurve.`
          },
          {
            name: 'tolerance',
            summary: 'The tolerance, generally the document\'s absolute tolerance.'
          },
          {
            name: 'angleTolerance',
            summary: ''
          }
        ],
        returns: `The results of the fillet operation. The number of output curves depends
     on the input curves and the values of the parameters that were used
     during the fillet operation. In most cases, the output array will contain
     either one or three curves, although two curves can be returned if the
     radius is zero and join = false.
     For example, if both join and trim = true, then the output curve
     will be a polycurve containing the fillet curve joined with trimmed copies
     of the input curves. If join = False and trim = true, then three curves,
     the fillet curve and trimmed copies of the input curves, will be returned.
     If both join and trim = false, then just the fillet curve is returned.`
      },
      {
        signature: 'static Curve CreateInterpolatedCurve(IEnumerable<Point3d> points,int degree)',
        summary: `Interpolates a sequence of points. Used by InterpCurve Command
     This routine works best when degree=3.`,
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to interpolate (Count must be >= 2)'
          },
          {
            name: 'degree',
            summary: 'The degree of the curve >=1.  Degree must be odd.'
          }
        ],
        returns: 'interpolated curve on success. None on failure.'
      },
      {
        signature: 'static Curve CreateInterpolatedCurve(IEnumerable<Point3d> points,int degree,CurveKnotStyle knots)',
        summary: `Interpolates a sequence of points. Used by InterpCurve Command
     This routine works best when degree=3.`,
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: `Points to interpolate. For periodic curves if the final point is a
     duplicate of the initial point it is  ignored. (Count must be >=2)`
          },
          {
            name: 'degree',
            summary: 'The degree of the curve >=1.  Degree must be odd.'
          },
          {
            name: 'knots',
            summary: 'Knot-style to use  and specifies if the curve should be periodic.'
          }
        ],
        returns: 'interpolated curve on success. None on failure.'
      },
      {
        signature: 'static Curve CreateInterpolatedCurve(IEnumerable<Point3d> points,int degree,CurveKnotStyle knots,Vector3d startTangent,Vector3d endTangent)',
        summary: `Interpolates a sequence of points. Used by InterpCurve Command
     This routine works best when degree=3.`,
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: `Points to interpolate. For periodic curves if the final point is a
     duplicate of the initial point it is  ignored. (Count must be >=2)`
          },
          {
            name: 'degree',
            summary: 'The degree of the curve >=1.  Degree must be odd.'
          },
          {
            name: 'knots',
            summary: 'Knot-style to use  and specifies if the curve should be periodic.'
          },
          {
            name: 'startTangent',
            summary: 'A starting tangent.'
          },
          {
            name: 'endTangent',
            summary: 'An ending tangent.'
          }
        ],
        returns: 'interpolated curve on success. None on failure.'
      },
      {
        signature: 'static Curve CreateMeanCurve(Curve curveA,Curve curveB)',
        summary: 'Constructs a mean, or average, curve from two curves.',
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'A first curve.'
          },
          {
            name: 'curveB',
            summary: 'A second curve.'
          }
        ],
        returns: 'The average curve, or None on error.'
      },
      {
        signature: 'static Curve CreateMeanCurve(Curve curveA,Curve curveB,double angleToleranceRadians)',
        summary: 'Constructs a mean, or average, curve from two curves.',
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'A first curve.'
          },
          {
            name: 'curveB',
            summary: 'A second curve.'
          },
          {
            name: 'angleToleranceRadians',
            summary: `The angle tolerance, in radians, used to match kinks between curves.
     If you are unsure how to set this parameter, then either use the
     document's angle tolerance RhinoDoc.AngleToleranceRadians,
     or the default value (RhinoMath.UnsetValue)`
          }
        ],
        returns: 'The average curve, or None on error.'
      },
      {
        signature: 'static Curve CreatePeriodicCurve(Curve curve)',
        summary: 'Removes kinks from a curve. Periodic curves deform smoothly without kinks.',
        since: 6,
        parameters: [
          {
            name: 'curve',
            summary: 'The curve to make periodic. Curve must have degree >= 2.'
          }
        ],
        returns: 'The resulting curve if successful, None otherwise.'
      },
      {
        signature: 'static Curve CreatePeriodicCurve(Curve curve,bool smooth)',
        summary: 'Removes kinks from a curve. Periodic curves deform smoothly without kinks.',
        since: 6,
        parameters: [
          {
            name: 'curve',
            summary: 'The curve to make periodic. Curve must have degree >= 2.'
          },
          {
            name: 'smooth',
            summary: `If true, smooths any kinks in the curve and moves control points to make a smooth curve. 
     If false, control point locations are not changed or changed minimally (only one point may move) and only the knot vector is altered.`
          }
        ],
        returns: 'The resulting curve if successful, None otherwise.'
      },
      {
        signature: 'static Curve CreateSoftEditCurve(Curve curve,double t,Vector3d delta,double length,bool fixEnds)',
        summary: 'Creates a soft edited curve from an exising curve using a smooth field of influence.',
        since: 6,
        parameters: [
          {
            name: 'curve',
            summary: 'The curve to soft edit.'
          },
          {
            name: 't',
            summary: `A parameter on the curve to move from. This location on the curve is moved, and the move
      is smoothly tapered off with increasing distance along the curve from this parameter.`
          },
          {
            name: 'delta',
            summary: 'The direction and magitude, or maximum distance, of the move.'
          },
          {
            name: 'length',
            summary: `The distance along the curve from the editing point over which the strength 
     of the editing falls off smoothly.`
          },
          {
            name: 'fixEnds',
            summary: ''
          }
        ],
        returns: 'The soft edited curve if successful. None on failure.'
      },
      {
        signature: 'static Curve[] CreateTextOutlines(string text,string font,double textHeight,int textStyle,bool closeLoops,Plane plane,double smallCapsScale,double tolerance)',
        summary: 'Creates outline curves created from a text string. The functionality is similar to what you find in Rhino\'s TextObject command or TextEntity.Explode() in RhinoCommon.',
        since: 6,
        parameters: [
          {
            name: 'text',
            summary: 'The text from which to create outline curves.'
          },
          {
            name: 'font',
            summary: 'The text font.'
          },
          {
            name: 'textHeight',
            summary: 'The text height.'
          },
          {
            name: 'textStyle',
            summary: 'The font style. The font style can be any number of the following: 0 - Normal, 1 - Bold, 2 - Italic'
          },
          {
            name: 'closeLoops',
            summary: 'Set this value to True when dealing with normal fonts and when you expect closed loops. You may want to set this to False when specifying a single-stroke font where you don\'t want closed loops.'
          },
          {
            name: 'plane',
            summary: 'The plane on which the outline curves will lie.'
          },
          {
            name: 'smallCapsScale',
            summary: 'Displays lower-case letters as small caps. Set the relative text size to a percentage of the normal text.'
          },
          {
            name: 'tolerance',
            summary: 'The tolerance for the operation.'
          }
        ],
        returns: 'An array containing one or more curves if successful.'
      },
      {
        signature: 'static Curve[] CreateTweenCurves(Curve curve0,Curve curve1,int numCurves)',
        summary: `Creates curves between two open or closed input curves. Uses the control points of the curves for finding tween curves.
     That means the first control point of first curve is matched to first control point of the second curve and so on.
     There is no matching of curves direction. Caller must match input curves direction before calling the function.`,
        since: 5.2,
        parameters: [
          {
            name: 'curve0',
            summary: 'The first, or starting, curve.'
          },
          {
            name: 'curve1',
            summary: 'The second, or ending, curve.'
          },
          {
            name: 'numCurves',
            summary: 'Number of tween curves to create.'
          }
        ],
        returns: 'An array of joint curves. This array can be empty.'
      },
      {
        signature: 'static Curve[] CreateTweenCurves(Curve curve0,Curve curve1,int numCurves,double tolerance)',
        summary: `Creates curves between two open or closed input curves. Uses the control points of the curves for finding tween curves.
     That means the first control point of first curve is matched to first control point of the second curve and so on.
     There is no matching of curves direction. Caller must match input curves direction before calling the function.`,
        since: 6,
        parameters: [
          {
            name: 'curve0',
            summary: 'The first, or starting, curve.'
          },
          {
            name: 'curve1',
            summary: 'The second, or ending, curve.'
          },
          {
            name: 'numCurves',
            summary: 'Number of tween curves to create.'
          },
          {
            name: 'tolerance',
            summary: ''
          }
        ],
        returns: 'An array of joint curves. This array can be empty.'
      },
      {
        signature: 'static Curve[] CreateTweenCurvesWithMatching(Curve curve0,Curve curve1,int numCurves)',
        summary: `Creates curves between two open or closed input curves. Make the structure of input curves compatible if needed.
     Refits the input curves to have the same structure. The resulting curves are usually more complex than input unless
     input curves are compatible and no refit is needed. There is no matching of curves direction.
     Caller must match input curves direction before calling the function.`,
        since: 5.2,
        parameters: [
          {
            name: 'curve0',
            summary: 'The first, or starting, curve.'
          },
          {
            name: 'curve1',
            summary: 'The second, or ending, curve.'
          },
          {
            name: 'numCurves',
            summary: 'Number of tween curves to create.'
          }
        ],
        returns: 'An array of joint curves. This array can be empty.'
      },
      {
        signature: 'static Curve[] CreateTweenCurvesWithMatching(Curve curve0,Curve curve1,int numCurves,double tolerance)',
        summary: `Creates curves between two open or closed input curves. Make the structure of input curves compatible if needed.
     Refits the input curves to have the same structure. The resulting curves are usually more complex than input unless
     input curves are compatible and no refit is needed. There is no matching of curves direction.
     Caller must match input curves direction before calling the function.`,
        since: 6,
        parameters: [
          {
            name: 'curve0',
            summary: 'The first, or starting, curve.'
          },
          {
            name: 'curve1',
            summary: 'The second, or ending, curve.'
          },
          {
            name: 'numCurves',
            summary: 'Number of tween curves to create.'
          },
          {
            name: 'tolerance',
            summary: ''
          }
        ],
        returns: 'An array of joint curves. This array can be empty.'
      },
      {
        signature: 'static Curve[] CreateTweenCurvesWithSampling(Curve curve0,Curve curve1,int numCurves,int numSamples)',
        summary: `Creates curves between two open or closed input curves. Use sample points method to make curves compatible.
     This is how the algorithm workd: Divides the two curves into an equal number of points, finds the midpoint between the 
     corresponding points on the curves and interpolates the tween curve through those points. There is no matching of curves
     direction. Caller must match input curves direction before calling the function.`,
        since: 5.2,
        parameters: [
          {
            name: 'curve0',
            summary: 'The first, or starting, curve.'
          },
          {
            name: 'curve1',
            summary: 'The second, or ending, curve.'
          },
          {
            name: 'numCurves',
            summary: 'Number of tween curves to create.'
          },
          {
            name: 'numSamples',
            summary: 'Number of sample points along input curves.'
          }
        ],
        returns: '>An array of joint curves. This array can be empty.'
      },
      {
        signature: 'static Curve[] CreateTweenCurvesWithSampling(Curve curve0,Curve curve1,int numCurves,int numSamples,double tolerance)',
        summary: `Creates curves between two open or closed input curves. Use sample points method to make curves compatible.
     This is how the algorithm workd: Divides the two curves into an equal number of points, finds the midpoint between the 
     corresponding points on the curves and interpolates the tween curve through those points. There is no matching of curves
     direction. Caller must match input curves direction before calling the function.`,
        since: 6,
        parameters: [
          {
            name: 'curve0',
            summary: 'The first, or starting, curve.'
          },
          {
            name: 'curve1',
            summary: 'The second, or ending, curve.'
          },
          {
            name: 'numCurves',
            summary: 'Number of tween curves to create.'
          },
          {
            name: 'numSamples',
            summary: 'Number of sample points along input curves.'
          },
          {
            name: 'tolerance',
            summary: ''
          }
        ],
        returns: '>An array of joint curves. This array can be empty.'
      },
      {
        signature: 'static bool DoDirectionsMatch(Curve curveA,Curve curveB)',
        summary: 'Determines whether two curves travel more or less in the same direction.',
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'First curve to test.'
          },
          {
            name: 'curveB',
            summary: 'Second curve to test.'
          }
        ],
        returns: `True if both curves more or less point in the same direction, 
     False if they point in the opposite directions.`
      },
      {
        signature: 'static bool GetDistancesBetweenCurves(Curve curveA,Curve curveB,double tolerance,double maxDistance,double maxDistanceParameterA,double maxDistanceParameterB,double minDistance,double minDistanceParameterA,double minDistanceParameterB)',
        summary: 'Computes the distances between two arbitrary curves that overlap.',
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'A curve.'
          },
          {
            name: 'curveB',
            summary: 'Another curve.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value.'
          },
          {
            name: 'maxDistance',
            summary: 'The maximum distance value. This is an out reference argument.'
          },
          {
            name: 'maxDistanceParameterA',
            summary: 'The maximum distance parameter on curve A. This is an out reference argument.'
          },
          {
            name: 'maxDistanceParameterB',
            summary: 'The maximum distance parameter on curve B. This is an out reference argument.'
          },
          {
            name: 'minDistance',
            summary: 'The minimum distance value. This is an out reference argument.'
          },
          {
            name: 'minDistanceParameterA',
            summary: 'The minimum distance parameter on curve A. This is an out reference argument.'
          },
          {
            name: 'minDistanceParameterB',
            summary: 'The minimum distance parameter on curve B. This is an out reference argument.'
          }
        ],
        returns: 'True if the operation succeeded; otherwise false.'
      },
      {
        signature: 'static bool GetFilletPoints(Curve curve0,Curve curve1,double radius,double t0Base,double t1Base,double t0,double t1,Plane filletPlane)',
        summary: 'Finds points at which to cut a pair of curves so that a fillet of given radius can be inserted.',
        since: 5,
        parameters: [
          {
            name: 'curve0',
            summary: 'First curve to fillet.'
          },
          {
            name: 'curve1',
            summary: 'Second curve to fillet.'
          },
          {
            name: 'radius',
            summary: 'Fillet radius.'
          },
          {
            name: 't0Base',
            summary: 'Parameter value for base point on curve0.'
          },
          {
            name: 't1Base',
            summary: 'Parameter value for base point on curve1.'
          },
          {
            name: 't0',
            summary: 'Parameter value of fillet point on curve 0.'
          },
          {
            name: 't1',
            summary: 'Parameter value of fillet point on curve 1.'
          },
          {
            name: 'filletPlane',
            summary: 'The fillet is contained in this plane with the fillet center at the plane origin.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'static Curve[] JoinCurves(IEnumerable<Curve> inputCurves)',
        summary: 'Joins a collection of curve segments together.',
        since: 5,
        parameters: [
          {
            name: 'inputCurves',
            summary: 'Curve segments to join.'
          }
        ],
        returns: 'An array of curves which contains.'
      },
      {
        signature: 'static Curve[] JoinCurves(IEnumerable<Curve> inputCurves,double joinTolerance)',
        summary: 'Joins a collection of curve segments together.',
        since: 5,
        parameters: [
          {
            name: 'inputCurves',
            summary: 'An array, a list or any enumerable set of curve segments to join.'
          },
          {
            name: 'joinTolerance',
            summary: `Joining tolerance, 
     i.e. the distance between segment end-points that is allowed.`
          }
        ],
        returns: 'An array of joint curves. This array can be empty.'
      },
      {
        signature: 'static Curve[] JoinCurves(IEnumerable<Curve> inputCurves,double joinTolerance,bool preserveDirection)',
        summary: 'Joins a collection of curve segments together.',
        since: 5,
        parameters: [
          {
            name: 'inputCurves',
            summary: 'An array, a list or any enumerable set of curve segments to join.'
          },
          {
            name: 'joinTolerance',
            summary: `Joining tolerance, 
     i.e. the distance between segment end-points that is allowed.`
          },
          {
            name: 'preserveDirection',
            summary: 'If true, curve endpoints will be compared to curve startpoints.If false, all start and endpoints will be compared and copies of input curves may be reversed in output.'
          }
        ],
        returns: 'An array of joint curves. This array can be empty.'
      },
      {
        signature: 'static bool MakeEndsMeet(Curve curveA,bool adjustStartCurveA,Curve curveB,bool adjustStartCurveB)',
        summary: 'Makes adjustments to the ends of one or both input curves so that they meet at a point.',
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: '1st curve to adjust.'
          },
          {
            name: 'adjustStartCurveA',
            summary: 'Which end of the 1st curve to adjust: True is start, False is end.'
          },
          {
            name: 'curveB',
            summary: '2nd curve to adjust.'
          },
          {
            name: 'adjustStartCurveB',
            summary: 'which end of the 2nd curve to adjust true==start, false==end.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'static RegionContainment PlanarClosedCurveRelationship(Curve curveA,Curve curveB,Plane testPlane,double tolerance)',
        summary: `Determines whether two coplanar simple closed curves are disjoint or intersect;
     otherwise, if the regions have a containment relationship, discovers
     which curve encloses the other.`,
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'A first curve.'
          },
          {
            name: 'curveB',
            summary: 'A second curve.'
          },
          {
            name: 'testPlane',
            summary: 'A plane.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value.'
          }
        ],
        returns: 'A value indicating the relationship between the first and the second curve.'
      },
      {
        signature: 'static bool PlanarCurveCollision(Curve curveA,Curve curveB,Plane testPlane,double tolerance)',
        summary: 'Determines if two coplanar curves collide (intersect).',
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'A curve.'
          },
          {
            name: 'curveB',
            summary: 'Another curve.'
          },
          {
            name: 'testPlane',
            summary: 'A valid plane containing the curves.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value for intersection.'
          }
        ],
        returns: 'True if the curves intersect, otherwise false'
      },
      {
        signature: 'static Curve[] ProjectToBrep(Curve curve,Brep brep,Vector3d direction,double tolerance)',
        summary: 'Projects a Curve onto a Brep along a given direction.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve to project.'
          },
          {
            name: 'brep',
            summary: 'Brep to project onto.'
          },
          {
            name: 'direction',
            summary: 'Direction of projection.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for projection.'
          }
        ],
        returns: 'An array of projected curves or empty array if the projection set is empty.'
      },
      {
        signature: 'static Curve[] ProjectToBrep(Curve curve,IEnumerable<Brep> breps,Vector3d direction,double tolerance)',
        summary: 'Projects a Curve onto a collection of Breps along a given direction.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve to project.'
          },
          {
            name: 'breps',
            summary: 'Breps to project onto.'
          },
          {
            name: 'direction',
            summary: 'Direction of projection.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for projection.'
          }
        ],
        returns: 'An array of projected curves or empty array if the projection set is empty.'
      },
      {
        signature: 'static Curve[] ProjectToBrep(Curve curve,IEnumerable<Brep> breps,Vector3d direction,double tolerance,int[] brepIndices)',
        summary: 'Projects a Curve onto a collection of Breps along a given direction.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve to project.'
          },
          {
            name: 'breps',
            summary: 'Breps to project onto.'
          },
          {
            name: 'direction',
            summary: 'Direction of projection.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for projection.'
          },
          {
            name: 'brepIndices',
            summary: '(out) Integers that identify for each resulting curve which Brep it was projected onto.'
          }
        ],
        returns: 'An array of projected curves or None if the projection set is empty.'
      },
      {
        signature: 'static Curve[] ProjectToBrep(IEnumerable<Curve> curves,IEnumerable<Brep> breps,Vector3d direction,double tolerance)',
        summary: 'Projects a collection of Curves onto a collection of Breps along a given direction.',
        since: 5,
        parameters: [
          {
            name: 'curves',
            summary: 'Curves to project.'
          },
          {
            name: 'breps',
            summary: 'Breps to project onto.'
          },
          {
            name: 'direction',
            summary: 'Direction of projection.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for projection.'
          }
        ],
        returns: 'An array of projected curves or empty array if the projection set is empty.'
      },
      {
        signature: 'static Curve[] ProjectToBrep(IEnumerable<Curve> curves,IEnumerable<Brep> breps,Vector3d direction,double tolerance,int[] curveIndices,int[] brepIndices)',
        summary: 'Projects a collection of Curves onto a collection of Breps along a given direction.',
        since: 5,
        parameters: [
          {
            name: 'curves',
            summary: 'Curves to project.'
          },
          {
            name: 'breps',
            summary: 'Breps to project onto.'
          },
          {
            name: 'direction',
            summary: 'Direction of projection.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for projection.'
          },
          {
            name: 'curveIndices',
            summary: 'Index of which curve in the input list was the source for a curve in the return array.'
          },
          {
            name: 'brepIndices',
            summary: 'Index of which brep was used to generate a curve in the return array.'
          }
        ],
        returns: 'An array of projected curves. Array is empty if the projection set is empty.'
      },
      {
        signature: 'static Curve[] ProjectToMesh(Curve curve,IEnumerable<Mesh> meshes,Vector3d direction,double tolerance)',
        summary: 'Projects a curve to a set of meshes using a direction and tolerance.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'A curve.'
          },
          {
            name: 'meshes',
            summary: 'A list, an array or any enumerable of meshes.'
          },
          {
            name: 'direction',
            summary: 'A direction vector.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value.'
          }
        ],
        returns: 'A curve array.'
      },
      {
        signature: 'static Curve[] ProjectToMesh(Curve curve,Mesh mesh,Vector3d direction,double tolerance)',
        summary: 'Projects a curve to a mesh using a direction and tolerance.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'A curve.'
          },
          {
            name: 'mesh',
            summary: 'A mesh.'
          },
          {
            name: 'direction',
            summary: 'A direction vector.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value.'
          }
        ],
        returns: 'A curve array.'
      },
      {
        signature: 'static Curve[] ProjectToMesh(IEnumerable<Curve> curves,IEnumerable<Mesh> meshes,Vector3d direction,double tolerance)',
        summary: 'Projects a curve to a set of meshes using a direction and tolerance.',
        since: 5,
        parameters: [
          {
            name: 'curves',
            summary: 'A list, an array or any enumerable of curves.'
          },
          {
            name: 'meshes',
            summary: 'A list, an array or any enumerable of meshes.'
          },
          {
            name: 'direction',
            summary: 'A direction vector.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value.'
          }
        ],
        returns: 'A curve array.'
      },
      {
        signature: 'static Curve ProjectToPlane(Curve curve,Plane plane)',
        summary: 'Constructs a curve by projecting an existing curve to a plane.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'A curve.'
          },
          {
            name: 'plane',
            summary: 'A plane.'
          }
        ],
        returns: 'The projected curve on success; None on failure.'
      },
      {
        signature: 'static Curve[] PullToBrepFace(Curve curve,BrepFace face,double tolerance)',
        summary: 'Pull a curve to a BrepFace using closest point projection.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve to pull.'
          },
          {
            name: 'face',
            summary: 'Brepface that pulls.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for pulling.'
          }
        ],
        returns: 'An array of pulled curves, or an empty array on failure.'
      },
      {
        signature: 'bool ChangeClosedCurveSeam(double t)',
        summary: 'If this curve is closed, then modify it so that the start/end point is at curve parameter t.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Curve parameter of new start/end point. The returned curves domain will start at t.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool ChangeDimension(int desiredDimension)',
        summary: 'Changes the dimension of a curve.',
        since: 5,
        parameters: [
          {
            name: 'desiredDimension',
            summary: 'The desired dimension.'
          }
        ],
        returns: `True if the curve's dimension was already desiredDimension
     or if the curve's dimension was successfully changed to desiredDimension;
     otherwise false.`
      },
      {
        signature: 'CurveOrientation ClosedCurveOrientation()',
        summary: `Determines the orientation (counterclockwise or clockwise) of a closed, planar curve in the world xy plane.
     Only works with simple (no self intersections) closed, planar curves.`,
        since: 6,
        returns: 'The orientation of this curve with respect to world xy plane.'
      },
      {
        signature: 'CurveOrientation ClosedCurveOrientation(Plane plane)',
        summary: `Determines the orientation (counterclockwise or clockwise) of a closed, planar curve in a given plane.
     Only works with simple (no self intersections) closed, planar curves.`,
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'The plane in which to solve the orientation.'
          }
        ],
        returns: 'The orientation of this curve in the given plane.'
      },
      {
        signature: 'CurveOrientation ClosedCurveOrientation(Transform xform)',
        summary: `Determines the orientation (counterclockwise or clockwise) of a closed, planar curve.
     Only works with simple (no self intersections) closed, planar curves.`,
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation to map the curve to the world xy plane.'
          }
        ],
        returns: 'The orientation of this curve in the world xy-plane.'
      },
      {
        signature: 'CurveOrientation ClosedCurveOrientation(Vector3d upDirection)',
        summary: `Determines the orientation (counterclockwise or clockwise) of a closed, planar curve in a given plane.
     Only works with simple (no self intersections) closed, planar curves.`,
        since: 5,
        parameters: [
          {
            name: 'upDirection',
            summary: 'A vector that is considered "up".'
          }
        ],
        returns: 'The orientation of this curve with respect to a defined up direction.'
      },
      {
        signature: 'bool ClosestPoint(Point3d testPoint,double t)',
        summary: `Finds parameter of the point on a curve that is closest to testPoint.
     If the maximumDistance parameter is > 0, then only points whose distance
     to the given point is <= maximumDistance will be returned.  Using a 
     positive value of maximumDistance can substantially speed up the search.`,
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to search from.'
          },
          {
            name: 't',
            summary: 'Parameter of local closest point.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool ClosestPoint(Point3d testPoint,double t,double maximumDistance)',
        summary: `Finds the parameter of the point on a curve that is closest to testPoint.
     If the maximumDistance parameter is > 0, then only points whose distance
     to the given point is <= maximumDistance will be returned.  Using a 
     positive value of maximumDistance can substantially speed up the search.`,
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to project.'
          },
          {
            name: 't',
            summary: 'parameter of local closest point returned here.'
          },
          {
            name: 'maximumDistance',
            summary: `The maximum allowed distance.
     Past this distance, the search is given up and False is returned.Use 0 to turn off this parameter.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool ClosestPoints(Curve otherCurve,Point3d pointOnThisCurve,Point3d pointOnOtherCurve)',
        summary: 'Gets closest points between this and another curves.',
        since: 5,
        parameters: [
          {
            name: 'otherCurve',
            summary: 'The other curve.'
          },
          {
            name: 'pointOnThisCurve',
            summary: 'The point on this curve. This out parameter is assigned during this call.'
          },
          {
            name: 'pointOnOtherCurve',
            summary: 'The point on other curve. This out parameter is assigned during this call.'
          }
        ],
        returns: 'True on success; False on error.'
      },
      {
        signature: 'bool ClosestPoints(IEnumerable<GeometryBase> geometry,Point3d pointOnCurve,Point3d pointOnObject,int whichGeometry)',
        summary: `Finds the object (and the closest point in that object) that is closest to
     this curve. Breps, surfaces,
     curves and point clouds are examples of
     objects that can be passed to this function.`,
        since: 5,
        parameters: [
          {
            name: 'geometry',
            summary: 'A list, an array or any enumerable set of geometry to search.'
          },
          {
            name: 'pointOnCurve',
            summary: 'The point on curve. This out parameter is assigned during this call.'
          },
          {
            name: 'pointOnObject',
            summary: 'The point on geometry. This out parameter is assigned during this call.'
          },
          {
            name: 'whichGeometry',
            summary: 'The index of the geometry. This out parameter is assigned during this call.'
          }
        ],
        returns: 'True on success; False if no object was found or selected.'
      },
      {
        signature: 'bool ClosestPoints(IEnumerable<GeometryBase> geometry,Point3d pointOnCurve,Point3d pointOnObject,int whichGeometry,double maximumDistance)',
        summary: `Finds the object (and the closest point in that object) that is closest to
     this curve. Breps, surfaces,
     curves and point clouds are examples of
     objects that can be passed to this function.`,
        since: 5,
        parameters: [
          {
            name: 'geometry',
            summary: 'A list, an array or any enumerable set of geometry to search.'
          },
          {
            name: 'pointOnCurve',
            summary: 'The point on curve. This out parameter is assigned during this call.'
          },
          {
            name: 'pointOnObject',
            summary: 'The point on geometry. This out parameter is assigned during this call.'
          },
          {
            name: 'whichGeometry',
            summary: 'The index of the geometry. This out parameter is assigned during this call.'
          },
          {
            name: 'maximumDistance',
            summary: 'Maximum allowable distance. Past this distance, the research is given up and False is returned.'
          }
        ],
        returns: 'True on success; False if no object was found or selected.'
      },
      {
        signature: 'PointContainment Contains(Point3d testPoint)',
        summary: `Computes the relationship between a point and a closed curve region. 
     This curve must be closed or the return value will be Unset.
     Both curve and point are projected to the World XY plane.`,
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to test.'
          }
        ],
        returns: 'Relationship between point and curve region.'
      },
      {
        signature: 'PointContainment Contains(Point3d testPoint,Plane plane)',
        summary: `Computes the relationship between a point and a closed curve region. 
     This curve must be closed or the return value will be Unset.`,
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to test.'
          },
          {
            name: 'plane',
            summary: 'Plane in in which to compare point and region.'
          }
        ],
        returns: 'Relationship between point and curve region.'
      },
      {
        signature: 'PointContainment Contains(Point3d testPoint,Plane plane,double tolerance)',
        summary: `Computes the relationship between a point and a closed curve region. 
     This curve must be closed or the return value will be Unset.`,
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to test.'
          },
          {
            name: 'plane',
            summary: 'Plane in in which to compare point and region.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use during comparison.'
          }
        ],
        returns: 'Relationship between point and curve region.'
      },
      {
        signature: 'Vector3d CurvatureAt(double t)',
        summary: 'Evaluate the curvature vector at a curve parameter.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Evaluation parameter.'
          }
        ],
        returns: 'Curvature vector of the curve at the parameter t.'
      },
      {
        signature: 'Vector3d[] DerivativeAt(double t,int derivativeCount)',
        summary: 'Evaluate the derivatives at the specified curve parameter.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Curve parameter to evaluate.'
          },
          {
            name: 'derivativeCount',
            summary: 'Number of derivatives to evaluate, must be at least 0.'
          }
        ],
        returns: 'An array of vectors that represents all the derivatives starting at zero.'
      },
      {
        signature: 'Vector3d[] DerivativeAt(double t,int derivativeCount,CurveEvaluationSide side)',
        summary: 'Evaluate the derivatives at the specified curve parameter.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Curve parameter to evaluate.'
          },
          {
            name: 'derivativeCount',
            summary: 'Number of derivatives to evaluate, must be at least 0.'
          },
          {
            name: 'side',
            summary: `Side of parameter to evaluate. If the parameter is at a kink, 
     it makes a big difference whether the evaluation is from below or above.`
          }
        ],
        returns: 'An array of vectors that represents all the derivatives starting at zero.'
      },
      {
        signature: 'Point3d[] DivideAsContour(Point3d contourStart,Point3d contourEnd,double interval)',
        summary: 'Divides this curve at fixed steps along a defined contour line.',
        since: 5,
        parameters: [
          {
            name: 'contourStart',
            summary: 'The start of the contouring line.'
          },
          {
            name: 'contourEnd',
            summary: 'The end of the contouring line.'
          },
          {
            name: 'interval',
            summary: 'A distance to measure on the contouring axis.'
          }
        ],
        returns: 'An array of points; or None on error.'
      },
      {
        signature: 'double[] DivideByCount(int segmentCount,bool includeEnds)',
        summary: 'Divide the curve into a number of equal-length segments.',
        since: 5,
        parameters: [
          {
            name: 'segmentCount',
            summary: 'Segment count. Note that the number of division points may differ from the segment count.'
          },
          {
            name: 'includeEnds',
            summary: 'If true, then the point at the start of the first division segment is returned.'
          }
        ],
        returns: 'List of curve parameters at the division points on success, None on failure.'
      },
      {
        signature: 'double[] DivideByCount(int segmentCount,bool includeEnds,Point3d[] points)',
        summary: 'Divide the curve into a number of equal-length segments.',
        since: 5,
        parameters: [
          {
            name: 'segmentCount',
            summary: 'Segment count. Note that the number of division points may differ from the segment count.'
          },
          {
            name: 'includeEnds',
            summary: 'If true, then the point at the start of the first division segment is returned.'
          },
          {
            name: 'points',
            summary: 'A list of division points. If the function returns successfully, this point-array will be filled in.'
          }
        ],
        returns: 'Array containing division curve parameters on success, None on failure.'
      },
      {
        signature: 'double[] DivideByLength(double segmentLength,bool includeEnds)',
        summary: 'Divide the curve into specific length segments.',
        since: 5,
        parameters: [
          {
            name: 'segmentLength',
            summary: 'The length of each and every segment (except potentially the last one).'
          },
          {
            name: 'includeEnds',
            summary: 'If true, then the point at the start of the first division segment is returned.'
          }
        ],
        returns: 'Array containing division curve parameters if successful, None on failure.'
      },
      {
        signature: 'double[] DivideByLength(double segmentLength,bool includeEnds,bool reverse)',
        summary: 'Divide the curve into specific length segments.',
        since: 6,
        parameters: [
          {
            name: 'segmentLength',
            summary: 'The length of each and every segment (except potentially the last one).'
          },
          {
            name: 'includeEnds',
            summary: 'If true, then the point at the start of the first division segment is returned.'
          },
          {
            name: 'reverse',
            summary: 'If true, then the divisions start from the end of the curve.'
          }
        ],
        returns: 'Array containing division curve parameters if successful, None on failure.'
      },
      {
        signature: 'double[] DivideByLength(double segmentLength,bool includeEnds,bool reverse,Point3d[] points)',
        summary: 'Divide the curve into specific length segments.',
        since: 6,
        parameters: [
          {
            name: 'segmentLength',
            summary: 'The length of each and every segment (except potentially the last one).'
          },
          {
            name: 'includeEnds',
            summary: 'If true, then the point at the start of the first division segment is returned.'
          },
          {
            name: 'reverse',
            summary: 'If true, then the divisions start from the end of the curve.'
          },
          {
            name: 'points',
            summary: 'If function is successful, points at each parameter value are returned in points.'
          }
        ],
        returns: 'Array containing division curve parameters if successful, None on failure.'
      },
      {
        signature: 'double[] DivideByLength(double segmentLength,bool includeEnds,Point3d[] points)',
        summary: 'Divide the curve into specific length segments.',
        since: 5,
        parameters: [
          {
            name: 'segmentLength',
            summary: 'The length of each and every segment (except potentially the last one).'
          },
          {
            name: 'includeEnds',
            summary: 'If true, then the point at the start of the first division segment is returned.'
          },
          {
            name: 'points',
            summary: 'If function is successful, points at each parameter value are returned in points.'
          }
        ],
        returns: 'Array containing division curve parameters if successful, None on failure.'
      },
      {
        signature: 'Point3d[] DivideEquidistant(double distance)',
        summary: 'Calculates 3d points on a curve where the linear distance between the points is equal.',
        since: 5,
        parameters: [
          {
            name: 'distance',
            summary: 'The distance betwen division points.'
          }
        ],
        returns: 'An array of equidistant points, or None on error.'
      },
      {
        signature: 'GeometryBase Duplicate()',
        summary: 'Constructs an exact duplicate of this Curve.',
        since: 5
      },
      {
        signature: 'Curve DuplicateCurve()',
        summary: 'Constructs an exact duplicate of this curve.',
        since: 5,
        returns: 'An exact copy of this curve.'
      },
      {
        signature: 'Curve[] DuplicateSegments()',
        summary: `Polylines will be exploded into line segments. ExplodeCurves will
     return the curves in topological order.`,
        since: 5,
        returns: 'An array of all the segments that make up this curve.'
      },
      {
        signature: 'Curve Extend(CurveEnd side,CurveExtensionStyle style,IEnumerable<GeometryBase> geometry)',
        summary: 'Extends a curve until it intersects a collection of objects.',
        since: 5,
        parameters: [
          {
            name: 'side',
            summary: 'The end of the curve to extend.'
          },
          {
            name: 'style',
            summary: 'The style or type of extension to use.'
          },
          {
            name: 'geometry',
            summary: 'A collection of objects. Allowable object types are Curve, Surface, Brep.'
          }
        ],
        returns: 'New extended curve result on success, None on failure.'
      },
      {
        signature: 'Curve Extend(CurveEnd side,CurveExtensionStyle style,Point3d endPoint)',
        summary: 'Extends a curve to a point.',
        since: 5,
        parameters: [
          {
            name: 'side',
            summary: 'The end of the curve to extend.'
          },
          {
            name: 'style',
            summary: 'The style or type of extension to use.'
          },
          {
            name: 'endPoint',
            summary: 'A new end point.'
          }
        ],
        returns: 'New extended curve result on success, None on failure.'
      },
      {
        signature: 'Curve Extend(CurveEnd side,double length,CurveExtensionStyle style)',
        summary: 'Extends a curve by a specific length.',
        since: 5,
        parameters: [
          {
            name: 'side',
            summary: 'Curve end to extend.'
          },
          {
            name: 'length',
            summary: 'Length to add to the curve end.'
          },
          {
            name: 'style',
            summary: 'Extension style.'
          }
        ],
        returns: 'A curve with extended ends or None on failure.'
      },
      {
        signature: 'Curve Extend(double t0,double t1)',
        summary: `Where possible, analytically extends curve to include the given domain. 
     This will not work on closed curves. The original curve will be identical to the 
     restriction of the resulting curve to the original curve domain.`,
        since: 5,
        parameters: [
          {
            name: 't0',
            summary: `Start of extension domain, if the start is not inside the 
     Domain of this curve, an attempt will be made to extend the curve.`
          },
          {
            name: 't1',
            summary: `End of extension domain, if the end is not inside the 
     Domain of this curve, an attempt will be made to extend the curve.`
          }
        ],
        returns: 'Extended curve on success, None on failure.'
      },
      {
        signature: 'Curve Extend(Interval domain)',
        summary: `Where possible, analytically extends curve to include the given domain. 
     This will not work on closed curves. The original curve will be identical to the 
     restriction of the resulting curve to the original curve domain.`,
        since: 5,
        parameters: [
          {
            name: 'domain',
            summary: 'Extension domain.'
          }
        ],
        returns: 'Extended curve on success, None on failure.'
      },
      {
        signature: 'Curve ExtendByArc(CurveEnd side,IEnumerable<GeometryBase> geometry)',
        summary: 'Extends a curve by an Arc until it intersects a collection of objects.',
        since: 5,
        parameters: [
          {
            name: 'side',
            summary: 'The end of the curve to extend.'
          },
          {
            name: 'geometry',
            summary: 'A collection of objects. Allowable object types are Curve, Surface, Brep.'
          }
        ],
        returns: 'New extended curve result on success, None on failure.'
      },
      {
        signature: 'Curve ExtendByLine(CurveEnd side,IEnumerable<GeometryBase> geometry)',
        summary: 'Extends a curve by a line until it intersects a collection of objects.',
        since: 5,
        parameters: [
          {
            name: 'side',
            summary: 'The end of the curve to extend.'
          },
          {
            name: 'geometry',
            summary: 'A collection of objects. Allowable object types are Curve, Surface, Brep.'
          }
        ],
        returns: 'New extended curve result on success, None on failure.'
      },
      {
        signature: 'Curve ExtendOnSurface(CurveEnd side,BrepFace face)',
        summary: 'Extends a curve on a surface.',
        since: 5,
        parameters: [
          {
            name: 'side',
            summary: 'The end of the curve to extend.'
          },
          {
            name: 'face',
            summary: 'BrepFace that contains the curve.'
          }
        ],
        returns: 'New extended curve result on success, None on failure.'
      },
      {
        signature: 'Curve ExtendOnSurface(CurveEnd side,Surface surface)',
        summary: 'Extends a curve on a surface.',
        since: 5,
        parameters: [
          {
            name: 'side',
            summary: 'The end of the curve to extend.'
          },
          {
            name: 'surface',
            summary: 'Surface that contains the curve.'
          }
        ],
        returns: 'New extended curve result on success, None on failure.'
      },
      {
        signature: 'double[] ExtremeParameters(Vector3d direction)',
        summary: `Returns the parameter values of all local extrema. 
     Parameter values are in increasing order so consecutive extrema 
     define an interval on which each component of the curve is monotone. 
     Note, non-periodic curves always return the end points.`,
        since: 6,
        parameters: [
          {
            name: 'direction',
            summary: 'The direction in which to perform the calculation.'
          }
        ],
        returns: 'The parameter values of all local extrema.'
      },
      {
        signature: 'Curve Fair(double distanceTolerance,double angleTolerance,int clampStart,int clampEnd,int iterations)',
        summary: `Fairs a curve object. Fair works best on degree 3 (cubic) curves. Attempts to 
     remove large curvature variations while limiting the geometry changes to be no 
     more than the specified tolerance.`,
        since: 5,
        parameters: [
          {
            name: 'distanceTolerance',
            summary: 'Maximum allowed distance the faired curve is allowed to deviate from the input.'
          },
          {
            name: 'angleTolerance',
            summary: '(in radians) kinks with angles <= angleTolerance are smoothed out 0.05 is a good default.'
          },
          {
            name: 'clampStart',
            summary: `The number of (control vertices-1) to preserve at start. 
     0 = preserve start point1 = preserve start point and 1st derivative2 = preserve start point, 1st and 2nd derivative`
          },
          {
            name: 'clampEnd',
            summary: 'Same as clampStart.'
          },
          {
            name: 'iterations',
            summary: 'The number of iteratoins to use in adjusting the curve.'
          }
        ],
        returns: 'Returns new faired Curve on success, None on failure.'
      },
      {
        signature: 'Curve Fit(int degree,double fitTolerance,double angleTolerance)',
        summary: 'Fits a new curve through an existing curve.',
        since: 5,
        parameters: [
          {
            name: 'degree',
            summary: 'The degree of the returned Curve. Must be bigger than 1.'
          },
          {
            name: 'fitTolerance',
            summary: `The fitting tolerance. If fitTolerance is RhinoMath.UnsetValue or <=0.0,
     the document absolute tolerance is used.`
          },
          {
            name: 'angleTolerance',
            summary: `The kink smoothing tolerance in radians.
     If angleTolerance is 0.0, all kinks are smoothedIf angleTolerance is >0.0, kinks smaller than angleTolerance are smoothedIf angleTolerance is RhinoMath.UnsetValue or <0.0, the document angle tolerance is used for the kink smoothing`
          }
        ],
        returns: 'Returns a new fitted Curve if successful, None on failure.'
      },
      {
        signature: 'bool FrameAt(double t,Plane plane)',
        summary: 'Returns a 3d frame at a parameter.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Evaluation parameter.'
          },
          {
            name: 'plane',
            summary: 'The frame is returned here.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'ConicSectionType GetConicSectionType()',
        summary: 'Returns the type of conic section based on the curve\'s shape.',
        since: 6
      },
      {
        signature: 'ConicSectionType GetConicSectionType(Point3d focus1,Point3d focus2,Point3d center)',
        summary: 'Returns the type of conic section based on the curve\'s shape.',
        since: 6,
        parameters: [
          {
            name: 'focus1',
            summary: 'The first focus point, if applicable.'
          },
          {
            name: 'focus2',
            summary: 'The second focus point, if applicable.'
          },
          {
            name: 'center',
            summary: 'The center point, if applicable.'
          }
        ]
      },
      {
        signature: 'bool GetCurveParameterFromNurbsFormParameter(double nurbsParameter,double curveParameter)',
        summary: 'Convert a NURBS curve parameter to a curve parameter.',
        since: 5,
        parameters: [
          {
            name: 'nurbsParameter',
            summary: 'Nurbs form parameter.'
          },
          {
            name: 'curveParameter',
            summary: 'Curve parameter.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'double GetLength()',
        summary: 'Gets the length of the curve with a fractional tolerance of 1.0e-8.',
        since: 5,
        returns: 'The length of the curve on success, or zero on failure.'
      },
      {
        signature: 'double GetLength(double fractionalTolerance)',
        summary: 'Get the length of the curve.',
        since: 5,
        parameters: [
          {
            name: 'fractionalTolerance',
            summary: `Desired fractional precision. 
     fabs(("exact" length from start to t) - arc_length)/arc_length <= fractionalTolerance.`
          }
        ],
        returns: 'The length of the curve on success, or zero on failure.'
      },
      {
        signature: 'double GetLength(double fractionalTolerance,Interval subdomain)',
        summary: 'Get the length of a sub-section of the curve.',
        since: 5,
        parameters: [
          {
            name: 'fractionalTolerance',
            summary: `Desired fractional precision. 
     fabs(("exact" length from start to t) - arc_length)/arc_length <= fractionalTolerance.`
          },
          {
            name: 'subdomain',
            summary: 'The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).'
          }
        ],
        returns: 'The length of the sub-curve on success, or zero on failure.'
      },
      {
        signature: 'double GetLength(Interval subdomain)',
        summary: 'Get the length of a sub-section of the curve with a fractional tolerance of 1e-8.',
        since: 5,
        parameters: [
          {
            name: 'subdomain',
            summary: 'The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).'
          }
        ],
        returns: 'The length of the sub-curve on success, or zero on failure.'
      },
      {
        signature: 'bool GetLocalPerpPoint(Point3d testPoint,double seedParmameter,double curveParameter)',
        summary: 'Search for a location on the curve, near seedParmameter, that is perpendicular to a test point.',
        since: 6,
        parameters: [
          {
            name: 'testPoint',
            summary: 'The test point.'
          },
          {
            name: 'seedParmameter',
            summary: 'A "seed" parameter on the curve.'
          },
          {
            name: 'curveParameter',
            summary: 'The parameter value at the perpendicular point'
          }
        ],
        returns: 'True if a solution is found, False otherwise.'
      },
      {
        signature: 'bool GetLocalPerpPoint(Point3d testPoint,double seedParmameter,Interval subDomain,double curveParameter)',
        summary: 'Search for a location on the curve, near seedParmameter, that is perpendicular to a test point.',
        since: 6,
        parameters: [
          {
            name: 'testPoint',
            summary: 'The test point.'
          },
          {
            name: 'seedParmameter',
            summary: 'A "seed" parameter on the curve.'
          },
          {
            name: 'subDomain',
            summary: 'The sub-domain of the curve to search.'
          },
          {
            name: 'curveParameter',
            summary: 'The parameter value at the perpendicular point'
          }
        ],
        returns: 'True if a solution is found, False otherwise.'
      },
      {
        signature: 'bool GetLocalTangentPoint(Point3d testPoint,double seedParmameter,double curveParameter)',
        summary: 'Search for a location on the curve, near seedParmameter, that is tangent to a test point.',
        since: 6,
        parameters: [
          {
            name: 'testPoint',
            summary: 'The test point.'
          },
          {
            name: 'seedParmameter',
            summary: 'A "seed" parameter on the curve.'
          },
          {
            name: 'curveParameter',
            summary: 'The parameter value at the tangent point'
          }
        ],
        returns: 'True if a solution is found, False otherwise.'
      },
      {
        signature: 'bool GetLocalTangentPoint(Point3d testPoint,double seedParmameter,Interval subDomain,double curveParameter)',
        summary: 'Search for a location on the curve, near seedParmameter, that is tangent to a test point.',
        since: 6,
        parameters: [
          {
            name: 'testPoint',
            summary: 'The test point.'
          },
          {
            name: 'seedParmameter',
            summary: 'A "seed" parameter on the curve.'
          },
          {
            name: 'subDomain',
            summary: 'The sub-domain of the curve to search.'
          },
          {
            name: 'curveParameter',
            summary: 'The parameter value at the tangent point'
          }
        ],
        returns: 'True if a solution is found, False otherwise.'
      },
      {
        signature: 'bool GetNextDiscontinuity(Continuity continuityType,double t0,double t1,double t)',
        summary: 'Searches for a derivative, tangent, or curvature discontinuity.',
        since: 5,
        parameters: [
          {
            name: 'continuityType',
            summary: 'Type of continuity to search for.'
          },
          {
            name: 't0',
            summary: `Search begins at t0. If there is a discontinuity at t0, it will be ignored. This makes it
     possible to repeatedly call GetNextDiscontinuity() and step through the discontinuities.`
          },
          {
            name: 't1',
            summary: `(t0 != t1)  If there is a discontinuity at t1 it will be ignored unless continuityType is
     a locus discontinuity type and t1 is at the start or end of the curve.`
          },
          {
            name: 't',
            summary: 'If a discontinuity is found, then t reports the parameter at the discontinuity.'
          }
        ],
        returns: `Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
      True if a parametric discontinuity was found strictly between t0 and t1. Note well that
      all curves are parametrically continuous at the ends of their domains.
     
     Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
      True if a locus discontinuity was found strictly between t0 and t1 or at t1 is the at the end
      of a curve. Note well that all open curves (IsClosed()=false) are locus discontinuous at the
      ends of their domains.  All closed curves (IsClosed()=true) are at least C0_locus_continuous at 
      the ends of their domains.`
      },
      {
        signature: 'bool GetNurbsFormParameterFromCurveParameter(double curveParameter,double nurbsParameter)',
        summary: 'Convert a curve parameter to a NURBS curve parameter.',
        since: 5,
        parameters: [
          {
            name: 'curveParameter',
            summary: 'Curve parameter.'
          },
          {
            name: 'nurbsParameter',
            summary: 'Nurbs form parameter.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'Plane[] GetPerpendicularFrames(IEnumerable<double> parameters)',
        summary: `Gets a collection of perpendicular frames along the curve. Perpendicular frames 
     are also known as 'Zero-twisting frames' and they minimize rotation from one frame to the next.`,
        since: 5,
        parameters: [
          {
            name: 'parameters',
            summary: 'A collection of strictly increasing curve parameters to place perpendicular frames on.'
          }
        ],
        returns: 'An array of perpendicular frames on success or None on failure.'
      },
      {
        signature: 'int HasNurbsForm()',
        summary: 'Does a NURBS curve representation of this curve exist?',
        since: 5,
        returns: `0   unable to create NURBS representation with desired accuracy.
     1   success - NURBS parameterization matches the curve's to the desired accuracy
     2   success - NURBS point locus matches the curve's and the domain of the NURBS
                   curve is correct. However, This curve's parameterization and the
                   NURBS curve parameterization may not match. This situation happens
                   when getting NURBS representations of curves that have a
                   transendental parameterization like circles.`
      },
      {
        signature: 'Point3d[] InflectionPoints()',
        summary: `Returns a curve's inflection points. An inflection point is a location on
     a curve at which the sign of the curvature (i.e., the concavity) changes. 
     The curvature at these locations is always 0.`,
        since: 7,
        returns: 'An array of points if successful, None if not successful or on error.'
      },
      {
        signature: 'bool IsArc()',
        summary: 'Test a curve to see if it can be represented by an arc or circle within RhinoMath.ZeroTolerance.',
        since: 5,
        returns: 'True if the curve can be represented by an arc or a circle within tolerance.'
      },
      {
        signature: 'bool IsArc(double tolerance)',
        summary: 'Test a curve to see if it can be represented by an arc or circle within the given tolerance.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'Tolerance to use when checking.'
          }
        ],
        returns: 'True if the curve can be represented by an arc or a circle within tolerance.'
      },
      {
        signature: 'bool IsCircle()',
        summary: 'Test a curve to see if it can be represented by a circle within RhinoMath.ZeroTolerance.',
        since: 5,
        returns: 'True if the Curve can be represented by a circle within tolerance.'
      },
      {
        signature: 'bool IsCircle(double tolerance)',
        summary: 'Test a curve to see if it can be represented by a circle within the given tolerance.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'Tolerance to use when checking.'
          }
        ],
        returns: 'True if the curve can be represented by a circle to within tolerance.'
      },
      {
        signature: 'bool IsClosable(double tolerance)',
        summary: `Decide if it makes sense to close off this curve by moving the endpoint 
     to the start based on start-end gap size and length of curve as 
     approximated by chord defined by 6 points.`,
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: `Maximum allowable distance between start and end. 
     If start - end gap is greater than tolerance, this function will return false.`
          }
        ],
        returns: 'True if start and end points are close enough based on above conditions.'
      },
      {
        signature: 'bool IsClosable(double tolerance,double minimumAbsoluteSize,double minimumRelativeSize)',
        summary: `Decide if it makes sense to close off this curve by moving the endpoint
     to the start based on start-end gap size and length of curve as
     approximated by chord defined by 6 points.`,
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: `Maximum allowable distance between start and end. 
     If start - end gap is greater than tolerance, this function will return false.`
          },
          {
            name: 'minimumAbsoluteSize',
            summary: `If greater than 0.0 and none of the interior sampled points are at
     least minimumAbsoluteSize from start, this function will return false.`
          },
          {
            name: 'minimumRelativeSize',
            summary: `If greater than 1.0 and chord length is less than 
     minimumRelativeSize*gap, this function will return false.`
          }
        ],
        returns: 'True if start and end points are close enough based on above conditions.'
      },
      {
        signature: 'bool IsContinuous(Continuity continuityType,double t)',
        summary: 'Test continuity at a curve parameter value.',
        since: 5,
        parameters: [
          {
            name: 'continuityType',
            summary: 'Type of continuity to test for.'
          },
          {
            name: 't',
            summary: 'Parameter to test.'
          }
        ],
        returns: 'True if the curve has at least the c type continuity at the parameter t.'
      },
      {
        signature: 'bool IsEllipse()',
        summary: 'Test a curve to see if it can be represented by an ellipse within RhinoMath.ZeroTolerance.',
        since: 5,
        returns: 'True if the Curve can be represented by an ellipse within tolerance.'
      },
      {
        signature: 'bool IsEllipse(double tolerance)',
        summary: 'Test a curve to see if it can be represented by an ellipse within a given tolerance.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'Tolerance to use for checking.'
          }
        ],
        returns: 'True if the Curve can be represented by an ellipse within tolerance.'
      },
      {
        signature: 'bool IsInPlane(Plane testPlane)',
        summary: 'Test a curve to see if it lies in a specific plane.',
        since: 5,
        parameters: [
          {
            name: 'testPlane',
            summary: 'Plane to test for.'
          }
        ],
        returns: 'True if the maximum distance from the curve to the testPlane is <= RhinoMath.ZeroTolerance.'
      },
      {
        signature: 'bool IsInPlane(Plane testPlane,double tolerance)',
        summary: 'Test a curve to see if it lies in a specific plane.',
        since: 5,
        parameters: [
          {
            name: 'testPlane',
            summary: 'Plane to test for.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use when checking.'
          }
        ],
        returns: 'True if the maximum distance from the curve to the testPlane is <= tolerance.'
      },
      {
        signature: 'bool IsLinear()',
        summary: 'Test a curve to see if it is linear to within RhinoMath.ZeroTolerance units (1e-12).',
        since: 5,
        returns: 'True if the curve is linear.'
      },
      {
        signature: 'bool IsLinear(double tolerance)',
        summary: 'Test a curve to see if it is linear to within the custom tolerance.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'Tolerance to use when checking linearity.'
          }
        ],
        returns: `True if the ends of the curve are farther than tolerance apart
     and the maximum distance from any point on the curve to
     the line segment connecting the curve ends is <= tolerance.`
      },
      {
        signature: 'bool IsPlanar()',
        summary: 'Test a curve for planarity.',
        since: 5,
        returns: 'True if the curve is planar (flat) to within RhinoMath.ZeroTolerance units (1e-12).'
      },
      {
        signature: 'bool IsPlanar(double tolerance)',
        summary: 'Test a curve for planarity.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'Tolerance to use when checking.'
          }
        ],
        returns: 'True if there is a plane such that the maximum distance from the curve to the plane is <= tolerance.'
      },
      {
        signature: 'bool IsPolyline()',
        summary: `Several types of Curve can have the form of a polyline
     including a degree 1 NurbsCurve, a PolylineCurve,
     and a PolyCurve all of whose segments are some form of
     polyline. IsPolyline tests a curve to see if it can be
     represented as a polyline.`,
        since: 5,
        returns: 'True if this curve can be represented as a polyline; otherwise, false.'
      },
      {
        signature: 'bool IsShort(double tolerance)',
        summary: 'Used to quickly find short curves.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'Length threshold value for "shortness".'
          }
        ],
        returns: 'True if the length of the curve is <= tolerance.'
      },
      {
        signature: 'bool IsShort(double tolerance,Interval subdomain)',
        summary: 'Used to quickly find short curves.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'Length threshold value for "shortness".'
          },
          {
            name: 'subdomain',
            summary: 'The test is performed on the interval that is the intersection of subdomain with Domain()'
          }
        ],
        returns: 'True if the length of the curve is <= tolerance.'
      },
      {
        signature: 'bool LcoalClosestPoint(Point3d testPoint,double seed,double t)',
        summary: `Find parameter of the point on a curve that is locally closest to 
     the testPoint.  The search for a local close point starts at
     a seed parameter.`,
        since: 6.3,
        parameters: [
          {
            name: 'testPoint',
            summary: 'A point to test against.'
          },
          {
            name: 'seed',
            summary: 'The seed parameter.'
          },
          {
            name: 't',
            summary: '>Parameter of the curve that is closest to testPoint.'
          }
        ],
        returns: 'True if the search is successful, False if the search fails.'
      },
      {
        signature: 'bool LengthParameter(double segmentLength,double t)',
        summary: `Gets the parameter along the curve which coincides with a given length along the curve. 
     A fractional tolerance of 1e-8 is used in this version of the function.`,
        since: 5,
        parameters: [
          {
            name: 'segmentLength',
            summary: 'Length of segment to measure. Must be less than or equal to the length of the curve.'
          },
          {
            name: 't',
            summary: 'Parameter such that the length of the curve from the curve start point to t equals length.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool LengthParameter(double segmentLength,double t,double fractionalTolerance)',
        summary: 'Gets the parameter along the curve which coincides with a given length along the curve.',
        since: 5,
        parameters: [
          {
            name: 'segmentLength',
            summary: 'Length of segment to measure. Must be less than or equal to the length of the curve.'
          },
          {
            name: 't',
            summary: 'Parameter such that the length of the curve from the curve start point to t equals s.'
          },
          {
            name: 'fractionalTolerance',
            summary: `Desired fractional precision.
     fabs(("exact" length from start to t) - arc_length)/arc_length <= fractionalTolerance.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool LengthParameter(double segmentLength,double t,double fractionalTolerance,Interval subdomain)',
        summary: 'Gets the parameter along the curve which coincides with a given length along the curve.',
        since: 5,
        parameters: [
          {
            name: 'segmentLength',
            summary: 'Length of segment to measure. Must be less than or equal to the length of the subdomain.'
          },
          {
            name: 't',
            summary: 'Parameter such that the length of the curve from the start of the subdomain to t is s.'
          },
          {
            name: 'fractionalTolerance',
            summary: `Desired fractional precision. 
     fabs(("exact" length from start to t) - arc_length)/arc_length <= fractionalTolerance.`
          },
          {
            name: 'subdomain',
            summary: 'The calculation is performed on the specified sub-domain of the curve rather than the whole curve.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool LengthParameter(double segmentLength,double t,Interval subdomain)',
        summary: `Gets the parameter along the curve which coincides with a given length along the curve. 
     A fractional tolerance of 1e-8 is used in this version of the function.`,
        since: 5,
        parameters: [
          {
            name: 'segmentLength',
            summary: 'Length of segment to measure. Must be less than or equal to the length of the subdomain.'
          },
          {
            name: 't',
            summary: 'Parameter such that the length of the curve from the start of the subdomain to t is s.'
          },
          {
            name: 'subdomain',
            summary: 'The calculation is performed on the specified sub-domain of the curve rather than the whole curve.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool LocalClosestPoint(Point3d testPoint,double seed,double t)',
        summary: `Find parameter of the point on a curve that is locally closest to 
     the testPoint.  The search for a local close point starts at
     a seed parameter.`,
        since: 6.18,
        parameters: [
          {
            name: 'testPoint',
            summary: 'A point to test against.'
          },
          {
            name: 'seed',
            summary: 'The seed parameter.'
          },
          {
            name: 't',
            summary: '>Parameter of the curve that is closest to testPoint.'
          }
        ],
        returns: 'True if the search is successful, False if the search fails.'
      },
      {
        signature: 'bool MakeClosed(double tolerance)',
        summary: `If IsClosed, just return true. Otherwise, decide if curve can be closed as 
     follows: Linear curves polylinear curves with 2 segments, Nurbs with 3 or less 
     control points cannot be made closed. Also, if tolerance > 0 and the gap between 
     start and end is larger than tolerance, curve cannot be made closed. 
     Adjust the curve's endpoint to match its start point.`,
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'If nonzero, and the gap is more than tolerance, curve cannot be made closed.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'Point3d[] MaxCurvaturePoints()',
        summary: `Returns a curve's maximum curvature points. The maximum curvature points identify
     where the curvature starts to decrease in both directions from the points.`,
        since: 7,
        returns: 'An array of points if successful, None if not successful or on error.'
      },
      {
        signature: 'bool NormalizedLengthParameter(double s,double t)',
        summary: `Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve. 
     A fractional tolerance of 1e-8 is used in this version of the function.`,
        since: 5,
        parameters: [
          {
            name: 's',
            summary: `Normalized arc length parameter. 
     E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.`
          },
          {
            name: 't',
            summary: 'Parameter such that the length of the curve from its start to t is arc_length.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool NormalizedLengthParameter(double s,double t,double fractionalTolerance)',
        summary: 'Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.',
        since: 5,
        parameters: [
          {
            name: 's',
            summary: `Normalized arc length parameter. 
     E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.`
          },
          {
            name: 't',
            summary: 'Parameter such that the length of the curve from its start to t is arc_length.'
          },
          {
            name: 'fractionalTolerance',
            summary: `Desired fractional precision. 
     fabs(("exact" length from start to t) - arc_length)/arc_length <= fractionalTolerance.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool NormalizedLengthParameter(double s,double t,double fractionalTolerance,Interval subdomain)',
        summary: 'Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.',
        since: 5,
        parameters: [
          {
            name: 's',
            summary: `Normalized arc length parameter. 
     E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.`
          },
          {
            name: 't',
            summary: 'Parameter such that the length of the curve from its start to t is arc_length.'
          },
          {
            name: 'fractionalTolerance',
            summary: `Desired fractional precision. 
     fabs(("exact" length from start to t) - arc_length)/arc_length <= fractionalTolerance.`
          },
          {
            name: 'subdomain',
            summary: 'The calculation is performed on the specified sub-domain of the curve.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool NormalizedLengthParameter(double s,double t,Interval subdomain)',
        summary: `Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve. 
     A fractional tolerance of 1e-8 is used in this version of the function.`,
        since: 5,
        parameters: [
          {
            name: 's',
            summary: `Normalized arc length parameter. 
     E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.`
          },
          {
            name: 't',
            summary: 'Parameter such that the length of the curve from its start to t is arc_length.'
          },
          {
            name: 'subdomain',
            summary: 'The calculation is performed on the specified sub-domain of the curve.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'double[] NormalizedLengthParameters(double[] s,double absoluteTolerance)',
        summary: `Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve. 
     A fractional tolerance of 1e-8 is used in this version of the function.`,
        since: 5,
        parameters: [
          {
            name: 's',
            summary: `Array of normalized arc length parameters. 
     E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.`
          },
          {
            name: 'absoluteTolerance',
            summary: `If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length 
     and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.`
          }
        ],
        returns: `If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length. 
     Null on failure.`
      },
      {
        signature: 'double[] NormalizedLengthParameters(double[] s,double absoluteTolerance,double fractionalTolerance)',
        summary: 'Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.',
        since: 5,
        parameters: [
          {
            name: 's',
            summary: `Array of normalized arc length parameters. 
     E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.`
          },
          {
            name: 'absoluteTolerance',
            summary: `If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length 
     and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.`
          },
          {
            name: 'fractionalTolerance',
            summary: `Desired fractional precision for each segment. 
     fabs("true" length - actual length)/(actual length) <= fractionalTolerance.`
          }
        ],
        returns: `If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length. 
     Null on failure.`
      },
      {
        signature: 'double[] NormalizedLengthParameters(double[] s,double absoluteTolerance,double fractionalTolerance,Interval subdomain)',
        summary: 'Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.',
        since: 5,
        parameters: [
          {
            name: 's',
            summary: `Array of normalized arc length parameters. 
     E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.`
          },
          {
            name: 'absoluteTolerance',
            summary: `If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length 
     and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.`
          },
          {
            name: 'fractionalTolerance',
            summary: `Desired fractional precision for each segment. 
     fabs("true" length - actual length)/(actual length) <= fractionalTolerance.`
          },
          {
            name: 'subdomain',
            summary: `The calculation is performed on the specified sub-domain of the curve. 
     A 0.0 s value corresponds to subdomain->Min() and a 1.0 s value corresponds to subdomain->Max().`
          }
        ],
        returns: `If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length. 
     Null on failure.`
      },
      {
        signature: 'double[] NormalizedLengthParameters(double[] s,double absoluteTolerance,Interval subdomain)',
        summary: `Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve. 
     A fractional tolerance of 1e-8 is used in this version of the function.`,
        since: 5,
        parameters: [
          {
            name: 's',
            summary: `Array of normalized arc length parameters. 
     E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.`
          },
          {
            name: 'absoluteTolerance',
            summary: `If absoluteTolerance > 0, then the difference between (s[i+1]-s[i])*curve_length 
     and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.`
          },
          {
            name: 'subdomain',
            summary: `The calculation is performed on the specified sub-domain of the curve. 
     A 0.0 s value corresponds to subdomain->Min() and a 1.0 s value corresponds to subdomain->Max().`
          }
        ],
        returns: `If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length. 
     Null on failure.`
      },
      {
        signature: 'Curve[] Offset(Plane plane,double distance,double tolerance,CurveOffsetCornerStyle cornerStyle)',
        summary: `Offsets this curve. If you have a nice offset, then there will be one entry in 
     the array. If the original curve had kinks or the offset curve had self 
     intersections, you will get multiple segments in the offset_curves[] array.`,
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Offset solution plane.'
          },
          {
            name: 'distance',
            summary: 'The positive or negative distance to offset.'
          },
          {
            name: 'tolerance',
            summary: 'The offset or fitting tolerance.'
          },
          {
            name: 'cornerStyle',
            summary: 'Corner style for offset kinks.'
          }
        ],
        returns: 'Offset curves on success, None on failure.'
      },
      {
        signature: 'Curve[] Offset(Point3d directionPoint,Vector3d normal,double distance,double tolerance,CurveOffsetCornerStyle cornerStyle)',
        summary: `Offsets this curve. If you have a nice offset, then there will be one entry in 
     the array. If the original curve had kinks or the offset curve had self 
     intersections, you will get multiple segments in the offset_curves[] array.`,
        since: 5,
        parameters: [
          {
            name: 'directionPoint',
            summary: 'A point that indicates the direction of the offset.'
          },
          {
            name: 'normal',
            summary: 'The normal to the offset plane.'
          },
          {
            name: 'distance',
            summary: 'The positive or negative distance to offset.'
          },
          {
            name: 'tolerance',
            summary: 'The offset or fitting tolerance.'
          },
          {
            name: 'cornerStyle',
            summary: 'Corner style for offset kinks.'
          }
        ],
        returns: 'Offset curves on success, None on failure.'
      },
      {
        signature: 'Curve OffsetNormalToSurface(Surface surface,double height)',
        summary: `Finds a curve by offsetting an existing curve normal to a surface.
     The caller is responsible for ensuring that the curve lies on the input surface.`,
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'Surface from which normals are calculated.'
          },
          {
            name: 'height',
            summary: 'offset distance (distance from surface to result curve)'
          }
        ],
        returns: `Offset curve at distance height from the surface.  The offset curve is
     interpolated through a small number of points so if the surface is irregular
     or complicated, the result will not be a very accurate offset.`
      },
      {
        signature: 'Curve[] OffsetOnSurface(BrepFace face,double distance,double fittingTolerance)',
        summary: 'Offset this curve on a brep face surface. This curve must lie on the surface.',
        since: 5,
        parameters: [
          {
            name: 'face',
            summary: 'The brep face on which to offset.'
          },
          {
            name: 'distance',
            summary: 'A distance to offset (+)left, (-)right.'
          },
          {
            name: 'fittingTolerance',
            summary: 'A fitting tolerance.'
          }
        ],
        returns: 'Offset curves on success, or None on failure.'
      },
      {
        signature: 'Curve[] OffsetOnSurface(BrepFace face,double[] curveParameters,double[] offsetDistances,double fittingTolerance)',
        summary: `Offset a curve on a brep face surface. This curve must lie on the surface.
     This overload allows to specify different offsets for different curve parameters.`,
        since: 5,
        parameters: [
          {
            name: 'face',
            summary: 'The brep face on which to offset.'
          },
          {
            name: 'curveParameters',
            summary: 'Curve parameters corresponding to the offset distances.'
          },
          {
            name: 'offsetDistances',
            summary: 'distances to offset (+)left, (-)right.'
          },
          {
            name: 'fittingTolerance',
            summary: 'A fitting tolerance.'
          }
        ],
        returns: 'Offset curves on success, or None on failure.'
      },
      {
        signature: 'Curve[] OffsetOnSurface(BrepFace face,Point2d throughPoint,double fittingTolerance)',
        summary: `Offset a curve on a brep face surface. This curve must lie on the surface.
     This overload allows to specify a surface point at which the offset will pass.`,
        since: 5,
        parameters: [
          {
            name: 'face',
            summary: 'The brep face on which to offset.'
          },
          {
            name: 'throughPoint',
            summary: '2d point on the brep face to offset through.'
          },
          {
            name: 'fittingTolerance',
            summary: 'A fitting tolerance.'
          }
        ],
        returns: 'Offset curves on success, or None on failure.'
      },
      {
        signature: 'Curve[] OffsetOnSurface(Surface surface,double distance,double fittingTolerance)',
        summary: 'Offset a curve on a surface. This curve must lie on the surface.',
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'A surface on which to offset.'
          },
          {
            name: 'distance',
            summary: 'A distance to offset (+)left, (-)right.'
          },
          {
            name: 'fittingTolerance',
            summary: 'A fitting tolerance.'
          }
        ],
        returns: 'Offset curves on success, or None on failure.'
      },
      {
        signature: 'Curve[] OffsetOnSurface(Surface surface,double[] curveParameters,double[] offsetDistances,double fittingTolerance)',
        summary: `Offset this curve on a surface. This curve must lie on the surface.
     This overload allows to specify different offsets for different curve parameters.`,
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'A surface on which to offset.'
          },
          {
            name: 'curveParameters',
            summary: 'Curve parameters corresponding to the offset distances.'
          },
          {
            name: 'offsetDistances',
            summary: 'Distances to offset (+)left, (-)right.'
          },
          {
            name: 'fittingTolerance',
            summary: 'A fitting tolerance.'
          }
        ],
        returns: 'Offset curves on success, or None on failure.'
      },
      {
        signature: 'Curve[] OffsetOnSurface(Surface surface,Point2d throughPoint,double fittingTolerance)',
        summary: `Offset a curve on a surface. This curve must lie on the surface.
     This overload allows to specify a surface point at which the offset will pass.`,
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'A surface on which to offset.'
          },
          {
            name: 'throughPoint',
            summary: '2d point on the brep face to offset through.'
          },
          {
            name: 'fittingTolerance',
            summary: 'A fitting tolerance.'
          }
        ],
        returns: 'Offset curves on success, or None on failure.'
      },
      {
        signature: 'bool PerpendicularFrameAt(double t,Plane plane)',
        summary: `Return a 3d frame at a parameter. This is slightly different than FrameAt in
     that the frame is computed in a way so there is minimal rotation from one
     frame to the next.`,
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Evaluation parameter.'
          },
          {
            name: 'plane',
            summary: 'The frame is returned here.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'Point3d PointAt(double t)',
        summary: 'Evaluates point at a curve parameter.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Evaluation parameter.'
          }
        ],
        returns: 'Point (location of curve at the parameter t).'
      },
      {
        signature: 'Point3d PointAtLength(double length)',
        summary: `Gets a point at a certain length along the curve. The length must be 
     non-negative and less than or equal to the length of the curve. 
     Lengths will not be wrapped when the curve is closed or periodic.`,
        since: 5,
        parameters: [
          {
            name: 'length',
            summary: 'Length along the curve between the start point and the returned point.'
          }
        ],
        returns: 'Point on the curve at the specified length from the start point or Poin3d.Unset on failure.'
      },
      {
        signature: 'Point3d PointAtNormalizedLength(double length)',
        summary: `Gets a point at a certain normalized length along the curve. The length must be 
     between or including 0.0 and 1.0, where 0.0 equals the start of the curve and 
     1.0 equals the end of the curve.`,
        since: 5,
        parameters: [
          {
            name: 'length',
            summary: 'Normalized length along the curve between the start point and the returned point.'
          }
        ],
        returns: 'Point on the curve at the specified normalized length from the start point or Poin3d.Unset on failure.'
      },
      {
        signature: 'Curve[] PullToBrepFace(BrepFace face,double tolerance)',
        summary: 'Pulls this curve to a brep face and returns the result of that operation.',
        since: 5,
        parameters: [
          {
            name: 'face',
            summary: 'A brep face.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value.'
          }
        ],
        returns: 'An array containing the resulting curves after pulling. This array could be empty.'
      },
      {
        signature: 'PolylineCurve PullToMesh(Mesh mesh,double tolerance)',
        summary: `Makes a polyline approximation of the curve and gets the closest point on the mesh for each point on the curve. 
     Then it "connects the points" so that you have a polyline on the mesh.`,
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh to project onto.'
          },
          {
            name: 'tolerance',
            summary: 'Input tolerance (RhinoDoc.ModelAbsoluteTolerance is a good default)'
          }
        ],
        returns: 'A polyline curve on success, None on failure.'
      },
      {
        signature: 'NurbsCurve Rebuild(int pointCount,int degree,bool preserveTangents)',
        summary: 'Rebuild a curve with a specific point count.',
        since: 5,
        parameters: [
          {
            name: 'pointCount',
            summary: 'Number of control points in the rebuild curve.'
          },
          {
            name: 'degree',
            summary: 'Degree of curve. Valid values are between and including 1 and 11.'
          },
          {
            name: 'preserveTangents',
            summary: 'If true, the end tangents of the input curve will be preserved.'
          }
        ],
        returns: 'A Nurbs curve on success or None on failure.'
      },
      {
        signature: 'bool RemoveShortSegments(double tolerance)',
        summary: `Looks for segments that are shorter than tolerance that can be removed. 
     Does not change the domain, but it will change the relative parameterization.`,
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'Tolerance which defines "short" segments.'
          }
        ],
        returns: `True if removable short segments were found. 
     False if no removable short segments were found.`
      },
      {
        signature: 'bool Reverse()',
        summary: 'Reverses the direction of the curve.',
        since: 5,
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'Curve RibbonOffset(double distance,double blendRadius,Point3d directionPoint,Vector3d normal,double tolerance)',
        summary: `Offsets a closed curve in the following way: pProject the curve to a plane with given normal.
     Then, loose Offset the projection by distance + blend_radius and trim off self-intersection.
     THen, Offset the remaining curve back in the opposite direction by blend_radius, filling gaps with blends.
     Finally, use the elevations of the input curve to get the correct elevations of the result.`,
        since: 7,
        parameters: [
          {
            name: 'distance',
            summary: 'The positive distance to offset the curve.'
          },
          {
            name: 'blendRadius',
            summary: `Positive, typically the same as distance. When the offset results in a self-intersection
     that gets trimmed off at a kink, the kink will be blended out using this radius.`
          },
          {
            name: 'directionPoint',
            summary: `A point that indicates the direction of the offset. If the offset is inward,
     the point's projection to the plane should be well within the curve.
     It will be used to decide which part of the offset to keep if there are self-intersections.`
          },
          {
            name: 'normal',
            summary: 'A vector that indicates the normal of the plane in which the offset will occur.'
          },
          {
            name: 'tolerance',
            summary: 'Used to determine self-intersections, not offset error.'
          }
        ],
        returns: 'The offset curve if successful.'
      },
      {
        signature: 'Curve RibbonOffset(double distance,double blendRadius,Point3d directionPoint,Vector3d normal,double tolerance,Curve[] crossSections,Surface[] ruledSurfaces)',
        summary: `Offsets a closed curve in the following way: pProject the curve to a plane with given normal.
     Then, loose Offset the projection by distance + blend_radius and trim off self-intersection.
     THen, Offset the remaining curve back in the opposite direction by blend_radius, filling gaps with blends.
     Finally, use the elevations of the input curve to get the correct elevations of the result.`,
        since: 7,
        parameters: [
          {
            name: 'distance',
            summary: 'The positive distance to offset the curve.'
          },
          {
            name: 'blendRadius',
            summary: `Positive, typically the same as distance. When the offset results in a self-intersection
     that gets trimmed off at a kink, the kink will be blended out using this radius.`
          },
          {
            name: 'directionPoint',
            summary: `A point that indicates the direction of the offset. If the offset is inward,
     the point's projection to the plane should be well within the curve.
     It will be used to decide which part of the offset to keep if there are self-intersections.`
          },
          {
            name: 'normal',
            summary: 'A vector that indicates the normal of the plane in which the offset will occur.'
          },
          {
            name: 'tolerance',
            summary: 'Used to determine self-intersections, not offset error.'
          },
          {
            name: 'crossSections',
            summary: `Contains lines between input and the offset theat might be useful
     as input to Brep.CreateFromSweep or some other surface creation tool.`
          },
          {
            name: 'ruledSurfaces',
            summary: `Contain ruled surfaces between the input and the parts of the offset that correspond exactly.
     Note, there will be gaps between these at blends.`
          }
        ],
        returns: 'The offset curve if successful.'
      },
      {
        signature: 'Curve RibbonOffset(double distance,double blendRadius,Point3d directionPoint,Vector3d normal,double tolerance,double[] outputParameters,double[] curveParameters)',
        summary: `Offsets a closed curve in the following way: pProject the curve to a plane with given normal.
     Then, loose Offset the projection by distance + blend_radius and trim off self-intersection.
     THen, Offset the remaining curve back in the opposite direction by blend_radius, filling gaps with blends.
     Finally, use the elevations of the input curve to get the correct elevations of the result.`,
        since: 7,
        parameters: [
          {
            name: 'distance',
            summary: 'The positive distance to offset the curve.'
          },
          {
            name: 'blendRadius',
            summary: `Positive, typically the same as distance. When the offset results in a self-intersection
     that gets trimmed off at a kink, the kink will be blended out using this radius.`
          },
          {
            name: 'directionPoint',
            summary: `A point that indicates the direction of the offset. If the offset is inward,
     the point's projection to the plane should be well within the curve.
     It will be used to decide which part of the offset to keep if there are self-intersections.`
          },
          {
            name: 'normal',
            summary: 'A vector that indicates the normal of the plane in which the offset will occur.'
          },
          {
            name: 'tolerance',
            summary: 'Used to determine self-intersections, not offset error.'
          },
          {
            name: 'outputParameters',
            summary: 'A list of parameter, paired with curveParameters, from the output curve for creating cross sections.'
          },
          {
            name: 'curveParameters',
            summary: 'A list of parameter, paired with outputParameters, from the input curve for creating cross sections.'
          }
        ],
        returns: 'The offset curve if successful.'
      },
      {
        signature: 'bool SetEndPoint(Point3d point)',
        summary: `Forces the curve to end at a specified point. 
     Not all curve types support this operation.`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'New end point of curve.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetStartPoint(Point3d point)',
        summary: `Forces the curve to start at a specified point. 
     Not all curve types support this operation.`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'New start point of curve.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'Curve Simplify(CurveSimplifyOptions options,double distanceTolerance,double angleToleranceRadians)',
        summary: `Returns a geometrically equivalent PolyCurve.
     The PolyCurve has the following properties
     1. All the PolyCurve segments are LineCurve, PolylineCurve, ArcCurve, or NurbsCurve.
     
     2. The Nurbs Curves segments do not have fully multiple interior knots.
     
     3. Rational Nurbs curves do not have constant weights.
     
     4. Any segment for which IsLinear() or IsArc() is True is a Line, 
        Polyline segment, or an Arc.
     
     5. Adjacent Colinear or Cocircular segments are combined.
     
     6. Segments that meet with G1-continuity have there ends tuned up so
        that they meet with G1-continuity to within machine precision.`,
        since: 5,
        parameters: [
          {
            name: 'options',
            summary: 'Simplification options.'
          },
          {
            name: 'distanceTolerance',
            summary: 'A distance tolerance for the simplification.'
          },
          {
            name: 'angleToleranceRadians',
            summary: 'An angle tolerance for the simplification.'
          }
        ],
        returns: 'New simplified curve on success, None on failure.'
      },
      {
        signature: 'Curve SimplifyEnd(CurveEnd end,CurveSimplifyOptions options,double distanceTolerance,double angleToleranceRadians)',
        summary: 'Same as SimplifyCurve, but simplifies only the last two segments at "side" end.',
        since: 5,
        parameters: [
          {
            name: 'end',
            summary: `If CurveEnd.Start the function simplifies the last two start 
     side segments, otherwise if CurveEnd.End the last two end side segments are simplified.`
          },
          {
            name: 'options',
            summary: 'Simplification options.'
          },
          {
            name: 'distanceTolerance',
            summary: 'A distance tolerance for the simplification.'
          },
          {
            name: 'angleToleranceRadians',
            summary: 'An angle tolerance for the simplification.'
          }
        ],
        returns: 'New simplified curve on success, None on failure.'
      },
      {
        signature: 'Curve Smooth(double smoothFactor,bool bXSmooth,bool bYSmooth,bool bZSmooth,bool bFixBoundaries,SmoothingCoordinateSystem coordinateSystem)',
        summary: 'Smooths a curve by averaging the positions of control points in a specified region.',
        since: 6,
        parameters: [
          {
            name: 'smoothFactor',
            summary: 'The smoothing factor, which controls how much control points move towards the average of the neighboring control points.'
          },
          {
            name: 'bXSmooth',
            summary: 'When True control points move in X axis direction.'
          },
          {
            name: 'bYSmooth',
            summary: 'When True control points move in Y axis direction.'
          },
          {
            name: 'bZSmooth',
            summary: 'When True control points move in Z axis direction.'
          },
          {
            name: 'bFixBoundaries',
            summary: 'When True the curve ends don\'t move.'
          },
          {
            name: 'coordinateSystem',
            summary: 'The coordinates to determine the direction of the smoothing.'
          }
        ],
        returns: 'The smoothed curve if successful, None otherwise.'
      },
      {
        signature: 'Curve Smooth(double smoothFactor,bool bXSmooth,bool bYSmooth,bool bZSmooth,bool bFixBoundaries,SmoothingCoordinateSystem coordinateSystem,Plane plane)',
        summary: 'Smooths a curve by averaging the positions of control points in a specified region.',
        since: 6,
        parameters: [
          {
            name: 'smoothFactor',
            summary: 'The smoothing factor, which controls how much control points move towards the average of the neighboring control points.'
          },
          {
            name: 'bXSmooth',
            summary: 'When True control points move in X axis direction.'
          },
          {
            name: 'bYSmooth',
            summary: 'When True control points move in Y axis direction.'
          },
          {
            name: 'bZSmooth',
            summary: 'When True control points move in Z axis direction.'
          },
          {
            name: 'bFixBoundaries',
            summary: 'When True the curve ends don\'t move.'
          },
          {
            name: 'coordinateSystem',
            summary: 'The coordinates to determine the direction of the smoothing.'
          },
          {
            name: 'plane',
            summary: 'If SmoothingCoordinateSystem.CPlane specified, then the construction plane.'
          }
        ],
        returns: 'The smoothed curve if successful, None otherwise.'
      },
      {
        signature: 'Interval SpanDomain(int spanIndex)',
        summary: `Get the domain of the curve span with the given index. 
     Use the SpanCount property to test how many spans there are.`,
        since: 5,
        parameters: [
          {
            name: 'spanIndex',
            summary: 'Index of span.'
          }
        ],
        returns: 'Interval of the span with the given index.'
      },
      {
        signature: 'Curve[] Split(Brep cutter,double tolerance)',
        summary: 'Splits a curve into pieces using a polysurface.',
        since: 5,
        parameters: [
          {
            name: 'cutter',
            summary: 'A cutting surface or polysurface.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance for computing intersections.'
          }
        ],
        returns: 'An array of curves. This array can be empty.'
      },
      {
        signature: 'Curve[] Split(Brep cutter,double tolerance,double angleToleranceRadians)',
        summary: 'Splits a curve into pieces using a polysurface.',
        since: 6,
        parameters: [
          {
            name: 'cutter',
            summary: 'A cutting surface or polysurface.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance for computing intersections.'
          },
          {
            name: 'angleToleranceRadians',
            summary: ''
          }
        ],
        returns: 'An array of curves. This array can be empty.'
      },
      {
        signature: 'Curve[] Split(double t)',
        summary: `Splits (divides) the curve at the specified parameter. 
     The parameter must be in the interior of the curve's domain.`,
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Parameter to split the curve at in the interval returned by Domain().'
          }
        ],
        returns: 'Two curves on success, None on failure.'
      },
      {
        signature: 'Curve[] Split(IEnumerable<double> t)',
        summary: `Splits (divides) the curve at a series of specified parameters. 
     The parameter must be in the interior of the curve domain.`,
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Parameters to split the curve at in the interval returned by Domain().'
          }
        ],
        returns: 'Multiple curves on success, None on failure.'
      },
      {
        signature: 'Curve[] Split(Surface cutter,double tolerance)',
        summary: 'Splits a curve into pieces using a surface.',
        since: 5,
        parameters: [
          {
            name: 'cutter',
            summary: 'A cutting surface or polysurface.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance for computing intersections.'
          }
        ],
        returns: 'An array of curves. This array can be empty.'
      },
      {
        signature: 'Curve[] Split(Surface cutter,double tolerance,double angleToleranceRadians)',
        summary: 'Splits a curve into pieces using a surface.',
        since: 6,
        parameters: [
          {
            name: 'cutter',
            summary: 'A cutting surface or polysurface.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance for computing intersections.'
          },
          {
            name: 'angleToleranceRadians',
            summary: ''
          }
        ],
        returns: 'An array of curves. This array can be empty.'
      },
      {
        signature: 'Vector3d TangentAt(double t)',
        summary: 'Evaluates the unit tangent vector at a curve parameter.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Evaluation parameter.'
          }
        ],
        returns: 'Unit tangent vector of the curve at the parameter t.'
      },
      {
        signature: 'PolyCurve ToArcsAndLines(double tolerance,double angleTolerance,double minimumLength,double maximumLength)',
        summary: 'Converts a curve into polycurve consisting of arc segments. Sections of the input curves that are nearly straight are converted to straight-line segments.',
        since: 6,
        parameters: [
          {
            name: 'tolerance',
            summary: 'The tolerance. This is the maximum deviation from arc midpoints to the curve. When in doubt, use the document\'s model space absolute tolerance.'
          },
          {
            name: 'angleTolerance',
            summary: 'The angle tolerance in radians. This is the maximum deviation of the arc end directions from the curve direction. When in doubt, use the document\'s model space angle tolerance.'
          },
          {
            name: 'minimumLength',
            summary: 'The minimum segment length.'
          },
          {
            name: 'maximumLength',
            summary: 'The maximum segment length.'
          }
        ],
        returns: 'PolyCurve on success, None on error.'
      },
      {
        signature: 'NurbsCurve ToNurbsCurve()',
        summary: 'Constructs a NURBS curve representation of this curve.',
        since: 5,
        returns: 'NURBS representation of the curve on success, None on failure.'
      },
      {
        signature: 'NurbsCurve ToNurbsCurve(Interval subdomain)',
        summary: 'Constructs a NURBS curve representation of this curve.',
        since: 5,
        parameters: [
          {
            name: 'subdomain',
            summary: 'The NURBS representation for this portion of the curve is returned.'
          }
        ],
        returns: 'NURBS representation of the curve on success, None on failure.'
      },
      {
        signature: 'PolylineCurve ToPolyline(double tolerance,double angleTolerance,double minimumLength,double maximumLength)',
        summary: 'Gets a polyline approximation of a curve.',
        since: 6,
        parameters: [
          {
            name: 'tolerance',
            summary: 'The tolerance. This is the maximum deviation from line midpoints to the curve. When in doubt, use the document\'s model space absolute tolerance.'
          },
          {
            name: 'angleTolerance',
            summary: 'The angle tolerance in radians. This is the maximum deviation of the line directions. When in doubt, use the document\'s model space angle tolerance.'
          },
          {
            name: 'minimumLength',
            summary: 'The minimum segment length.'
          },
          {
            name: 'maximumLength',
            summary: 'The maximum segment length.'
          }
        ],
        returns: 'PolyCurve on success, None on error.'
      },
      {
        signature: 'PolylineCurve ToPolyline(int mainSegmentCount,int subSegmentCount,double maxAngleRadians,double maxChordLengthRatio,double maxAspectRatio,double tolerance,double minEdgeLength,double maxEdgeLength,bool keepStartPoint)',
        summary: 'Gets a polyline approximation of a curve.',
        since: 5,
        parameters: [
          {
            name: 'mainSegmentCount',
            summary: `If mainSegmentCount <= 0, then both subSegmentCount and mainSegmentCount are ignored. 
     If mainSegmentCount > 0, then subSegmentCount must be >= 1. In this 
     case the nurb will be broken into mainSegmentCount equally spaced 
     chords. If needed, each of these chords can be split into as many 
     subSegmentCount sub-parts if the subdivision is necessary for the 
     mesh to meet the other meshing constraints. In particular, if 
     subSegmentCount = 0, then the curve is broken into mainSegmentCount 
     pieces and no further testing is performed.`
          },
          {
            name: 'subSegmentCount',
            summary: 'An amount of subsegments.'
          },
          {
            name: 'maxAngleRadians',
            summary: `( 0 to pi ) Maximum angle (in radians) between unit tangents at 
     adjacent vertices.`
          },
          {
            name: 'maxChordLengthRatio',
            summary: `Maximum permitted value of 
     (distance chord midpoint to curve) / (length of chord).`
          },
          {
            name: 'maxAspectRatio',
            summary: `If maxAspectRatio < 1.0, the parameter is ignored. 
     If 1 <= maxAspectRatio < sqrt(2), it is treated as if maxAspectRatio = sqrt(2). 
     This parameter controls the maximum permitted value of 
     (length of longest chord) / (length of shortest chord).`
          },
          {
            name: 'tolerance',
            summary: `If tolerance = 0, the parameter is ignored. 
     This parameter controls the maximum permitted value of the 
     distance from the curve to the polyline.`
          },
          {
            name: 'minEdgeLength',
            summary: 'The minimum permitted edge length.'
          },
          {
            name: 'maxEdgeLength',
            summary: `If maxEdgeLength = 0, the parameter 
     is ignored. This parameter controls the maximum permitted edge length.`
          },
          {
            name: 'keepStartPoint',
            summary: `If True the starting point of the curve 
     is added to the polyline. If False the starting point of the curve is 
     not added to the polyline.`
          }
        ],
        returns: 'PolylineCurve on success, None on error.'
      },
      {
        signature: 'PolylineCurve ToPolyline(int mainSegmentCount,int subSegmentCount,double maxAngleRadians,double maxChordLengthRatio,double maxAspectRatio,double tolerance,double minEdgeLength,double maxEdgeLength,bool keepStartPoint,Interval curveDomain)',
        summary: 'Gets a polyline approximation of a curve.',
        since: 5,
        parameters: [
          {
            name: 'mainSegmentCount',
            summary: `If mainSegmentCount <= 0, then both subSegmentCount and mainSegmentCount are ignored. 
     If mainSegmentCount > 0, then subSegmentCount must be >= 1. In this 
     case the nurb will be broken into mainSegmentCount equally spaced 
     chords. If needed, each of these chords can be split into as many 
     subSegmentCount sub-parts if the subdivision is necessary for the 
     mesh to meet the other meshing constraints. In particular, if 
     subSegmentCount = 0, then the curve is broken into mainSegmentCount 
     pieces and no further testing is performed.`
          },
          {
            name: 'subSegmentCount',
            summary: 'An amount of subsegments.'
          },
          {
            name: 'maxAngleRadians',
            summary: `( 0 to pi ) Maximum angle (in radians) between unit tangents at 
     adjacent vertices.`
          },
          {
            name: 'maxChordLengthRatio',
            summary: `Maximum permitted value of 
     (distance chord midpoint to curve) / (length of chord).`
          },
          {
            name: 'maxAspectRatio',
            summary: `If maxAspectRatio < 1.0, the parameter is ignored. 
     If 1 <= maxAspectRatio < sqrt(2), it is treated as if maxAspectRatio = sqrt(2). 
     This parameter controls the maximum permitted value of 
     (length of longest chord) / (length of shortest chord).`
          },
          {
            name: 'tolerance',
            summary: `If tolerance = 0, the parameter is ignored. 
     This parameter controls the maximum permitted value of the 
     distance from the curve to the polyline.`
          },
          {
            name: 'minEdgeLength',
            summary: 'The minimum permitted edge length.'
          },
          {
            name: 'maxEdgeLength',
            summary: `If maxEdgeLength = 0, the parameter 
     is ignored. This parameter controls the maximum permitted edge length.`
          },
          {
            name: 'keepStartPoint',
            summary: `If True the starting point of the curve 
     is added to the polyline. If False the starting point of the curve is 
     not added to the polyline.`
          },
          {
            name: 'curveDomain',
            summary: 'This subdomain of the NURBS curve is approximated.'
          }
        ],
        returns: 'PolylineCurve on success, None on error.'
      },
      {
        signature: 'Curve Trim(CurveEnd side,double length)',
        summary: 'Shortens a curve by a given length',
        since: 5.1,
        returns: 'Trimmed curve if successful, None on failure.'
      },
      {
        signature: 'Curve Trim(double t0,double t1)',
        summary: 'Removes portions of the curve outside the specified interval.',
        since: 5,
        parameters: [
          {
            name: 't0',
            summary: 'Start of the trimming interval. Portions of the curve before curve(t0) are removed.'
          },
          {
            name: 't1',
            summary: 'End of the trimming interval. Portions of the curve after curve(t1) are removed.'
          }
        ],
        returns: 'Trimmed portion of this curve is successfull, None on failure.'
      },
      {
        signature: 'Curve Trim(Interval domain)',
        summary: 'Removes portions of the curve outside the specified interval.',
        since: 5,
        parameters: [
          {
            name: 'domain',
            summary: `Trimming interval. Portions of the curve before curve(domain[0])
     and after curve(domain[1]) are removed.`
          }
        ],
        returns: 'Trimmed curve if successful, None on failure.'
      },
      {
        signature: 'bool TryGetArc(Arc arc)',
        summary: 'Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'On success, the Arc will be filled in.'
          }
        ],
        returns: 'True if the curve could be converted into an arc.'
      },
      {
        signature: 'bool TryGetArc(Arc arc,double tolerance)',
        summary: 'Try to convert this curve into an Arc using a custom tolerance.',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'On success, the Arc will be filled in.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use when checking.'
          }
        ],
        returns: 'True if the curve could be converted into an arc.'
      },
      {
        signature: 'bool TryGetArc(Plane plane,Arc arc)',
        summary: 'Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane in which the comparison is performed.'
          },
          {
            name: 'arc',
            summary: 'On success, the Arc will be filled in.'
          }
        ],
        returns: 'True if the curve could be converted into an arc within the given plane.'
      },
      {
        signature: 'bool TryGetArc(Plane plane,Arc arc,double tolerance)',
        summary: 'Try to convert this curve into an Arc using a custom tolerance.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane in which the comparison is performed.'
          },
          {
            name: 'arc',
            summary: 'On success, the Arc will be filled in.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use when checking.'
          }
        ],
        returns: 'True if the curve could be converted into an arc within the given plane.'
      },
      {
        signature: 'bool TryGetCircle(Circle circle)',
        summary: 'Try to convert this curve into a circle using RhinoMath.ZeroTolerance.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'On success, the Circle will be filled in.'
          }
        ],
        returns: 'True if the curve could be converted into a Circle.'
      },
      {
        signature: 'bool TryGetCircle(Circle circle,double tolerance)',
        summary: 'Try to convert this curve into a Circle using a custom tolerance.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'On success, the Circle will be filled in.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use when checking.'
          }
        ],
        returns: 'True if the curve could be converted into a Circle within tolerance.'
      },
      {
        signature: 'bool TryGetEllipse(Ellipse ellipse)',
        summary: 'Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.',
        since: 5,
        parameters: [
          {
            name: 'ellipse',
            summary: 'On success, the Ellipse will be filled in.'
          }
        ],
        returns: 'True if the curve could be converted into an Ellipse.'
      },
      {
        signature: 'bool TryGetEllipse(Ellipse ellipse,double tolerance)',
        summary: 'Try to convert this curve into an Ellipse using a custom tolerance.',
        since: 5,
        parameters: [
          {
            name: 'ellipse',
            summary: 'On success, the Ellipse will be filled in.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use when checking.'
          }
        ],
        returns: 'True if the curve could be converted into an Ellipse.'
      },
      {
        signature: 'bool TryGetEllipse(Plane plane,Ellipse ellipse)',
        summary: 'Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane in which the comparison is performed.'
          },
          {
            name: 'ellipse',
            summary: 'On success, the Ellipse will be filled in.'
          }
        ],
        returns: 'True if the curve could be converted into an Ellipse within the given plane.'
      },
      {
        signature: 'bool TryGetEllipse(Plane plane,Ellipse ellipse,double tolerance)',
        summary: 'Try to convert this curve into an Ellipse using a custom tolerance.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane in which the comparison is performed.'
          },
          {
            name: 'ellipse',
            summary: 'On success, the Ellipse will be filled in.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use when checking.'
          }
        ],
        returns: 'True if the curve could be converted into an Ellipse within the given plane.'
      },
      {
        signature: 'bool TryGetPlane(Plane plane)',
        summary: 'Test a curve for planarity and return the plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'On success, the plane parameters are filled in.'
          }
        ],
        returns: 'True if there is a plane such that the maximum distance from the curve to the plane is <= RhinoMath.ZeroTolerance.'
      },
      {
        signature: 'bool TryGetPlane(Plane plane,double tolerance)',
        summary: 'Test a curve for planarity and return the plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'On success, the plane parameters are filled in.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use when checking.'
          }
        ],
        returns: 'True if there is a plane such that the maximum distance from the curve to the plane is <= tolerance.'
      },
      {
        signature: 'bool TryGetPolyline(Polyline polyline)',
        summary: `Several types of Curve can have the form of a polyline 
     including a degree 1 NurbsCurve, a PolylineCurve, 
     and a PolyCurve all of whose segments are some form of 
     polyline. IsPolyline tests a curve to see if it can be 
     represented as a polyline.`,
        since: 5,
        parameters: [
          {
            name: 'polyline',
            summary: 'If True is returned, then the polyline form is returned here.'
          }
        ],
        returns: 'True if this curve can be represented as a polyline; otherwise, false.'
      },
      {
        signature: 'bool TryGetPolyline(Polyline polyline,double[] parameters)',
        summary: `Several types of Curve can have the form of a polyline 
     including a degree 1 NurbsCurve, a PolylineCurve, 
     and a PolyCurve all of whose segments are some form of 
     polyline. IsPolyline tests a curve to see if it can be 
     represented as a polyline.`,
        since: 5,
        parameters: [
          {
            name: 'polyline',
            summary: 'If True is returned, then the polyline form is returned here.'
          },
          {
            name: 'parameters',
            summary: `if True is returned, then the parameters of the polyline
     points are returned here.`
          }
        ],
        returns: 'True if this curve can be represented as a polyline; otherwise, false.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'CurveBooleanRegions',
    dataType: 1,
    summary: 'Represents the results of a Curve.CreateBooleanRegions calculation.',
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'int PlanarCurveCount',
        summary: 'Returns number of planar curves that were calculated by Curve.CreateBooleanRegions.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int PointCount',
        summary: `If this object were created using the Curve.CreateBooleanRegions override that
     accepts a collection of points as input, then this value will be equal to the length
     of the points collection.`,
        since: 7,
        property: ['get']
      },
      {
        signature: 'int RegionCount',
        summary: `Returns the number of curve regions. A curve region is a collection of
     curves that bound a single connected region of the plane.`,
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int BoundaryCount(int regionIndex)',
        summary: 'Returns the number of boundary curves in a curve region.',
        since: 7,
        parameters: [
          {
            name: 'regionIndex',
            summary: 'The curve region index.'
          }
        ],
        returns: 'The number of boundary curves in the curve region.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 7
      },
      {
        signature: 'Curve PlanarCurve(int planarCurveIndex)',
        summary: 'Returns a planar curve that was calculated by Curve.CreateBooleanRegions.',
        since: 7,
        returns: 'The planar curve if succesful, None if not successful.'
      },
      {
        signature: 'Curve[] RegionCurves(int regionIndex)',
        summary: `Returns the boundary curves in a curve region. A curve region is a collection of
     curves that bound a single connected region of the plane. Note, the first curve
     is always the outer boundary.`,
        since: 7,
        parameters: [
          {
            name: 'regionIndex',
            summary: 'The curve region index.'
          }
        ],
        returns: 'An array of boundary curves if successful, an empty array if not successful.'
      },
      {
        signature: 'int RegionPointIndex(int pointIndex)',
        summary: `If this object were created using the Curve.CreateBooleanRegions override that
     accepts a collection of points as input, then you this method to retrieve the
     index of the point contained in a curve region.
     If this.RegionPointIndex(i) = n, then points[i] is contained in this.RegionCurves(n).
     If points[i] is not in any region, then this.RegionPointIndex(i) = -1.`,
        since: 7,
        parameters: [
          {
            name: 'pointIndex',
            summary: 'The point index.'
          }
        ],
        returns: `The index of the input point contained in the specified region if successful,
     or -1 if points[i] was not used in any region or if not successful.`
      },
      {
        signature: 'int SegmentCount(int regionIndex,int boundaryIndex)',
        summary: 'Returns the number of segments in a boundary curve in a curve region.',
        since: 7,
        parameters: [
          {
            name: 'regionIndex',
            summary: 'The curve region index.'
          },
          {
            name: 'boundaryIndex',
            summary: 'The boundary curve index.'
          }
        ],
        returns: 'The number of curve segments in th boundary curves.'
      },
      {
        signature: 'int SegmentDetails(int regionIndex,int boundaryIndex,int segmmentIndex,Interval subDomain,bool reversed)',
        summary: 'Returns the details of a segment in a boundary curve in a curve region.',
        since: 7,
        parameters: [
          {
            name: 'regionIndex',
            summary: 'The curve region index.'
          },
          {
            name: 'boundaryIndex',
            summary: 'The boundary curve index.'
          },
          {
            name: 'segmmentIndex',
            summary: 'The segment index.'
          },
          {
            name: 'subDomain',
            summary: 'The subdomain of the planar curve used by the segmment.'
          },
          {
            name: 'reversed',
            summary: 'True if the piece of the planar curve should be reversed.'
          }
        ],
        returns: 'The index of the planar curve used by the specified segment if successful, -1 if not successful.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'CurveEnd',
    dataType: 3,
    summary: 'Defines the extremes of a curve through a flagged enumeration.',
    values: [
      {
        signature: 'None = 0',
        summary: 'Not the start nor the end.'
      },
      {
        signature: 'Start = 1',
        summary: 'The frontal part of the curve.'
      },
      {
        signature: 'End = 2',
        summary: 'The tail part of the curve.'
      },
      {
        signature: 'Both = 3',
        summary: 'Both the start and the end of the curve.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'CurveEvaluationSide',
    dataType: 3,
    summary: 'Defines enumerated values for the options that defines a curve evaluation side when evaluating kinks.',
    values: [
      {
        signature: 'Default = 0',
        summary: 'The default evaluation side.'
      },
      {
        signature: 'Below = -1',
        summary: 'The below evaluation side.'
      },
      {
        signature: 'Above = +1',
        summary: 'The above evaluation side.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'CurveExtensionStyle',
    dataType: 3,
    summary: 'Defines enumerated values for styles to use during curve extension, such as "Line", "Arc" or "Smooth".',
    values: [
      {
        signature: 'Line = 0',
        summary: 'Curve ends will be propagated linearly according to tangents.'
      },
      {
        signature: 'Arc = 1',
        summary: 'Curve ends will be propagated arc-wise according to curvature.'
      },
      {
        signature: 'Smooth = 2',
        summary: 'Curve ends will be propagated smoothly according to curvature.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'CurveKnotStyle',
    dataType: 3,
    summary: 'Defines enumerated values for knot spacing styles in interpolated curves.',
    values: [
      {
        signature: 'Uniform = 0',
        summary: 'Parameter spacing between consecutive knots is 1.0.'
      },
      {
        signature: 'Chord = 1',
        summary: 'Chord length spacing, requires degree=3 with CV1 and CVn1 specified.'
      },
      {
        signature: 'ChordSquareRoot = 2',
        summary: 'Square root of chord length, requires degree=3 with CV1 and CVn1 specified.'
      },
      {
        signature: 'UniformPeriodic = 3',
        summary: 'Periodic with uniform spacing.'
      },
      {
        signature: 'ChordPeriodic = 4',
        summary: 'Periodic with chord length spacing.'
      },
      {
        signature: 'ChordSquareRootPeriodic = 5',
        summary: 'Periodic with square roor of chord length spacing.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'CurveOffsetCornerStyle',
    dataType: 3,
    summary: 'Defines enumerated values for all implemented corner styles in curve offsets.',
    values: [
      {
        signature: 'None = 0',
        summary: 'The dafault value.'
      },
      {
        signature: 'Sharp = 1',
        summary: 'Offsets and extends curves with a straight line until they intersect.'
      },
      {
        signature: 'Round = 2',
        summary: 'Offsets and fillets curves with an arc of radius equal to the offset distance.'
      },
      {
        signature: 'Smooth = 3',
        summary: 'Offsets and connects curves with a smooth (G1 continuity) curve.'
      },
      {
        signature: 'Chamfer = 4',
        summary: 'Offsets and connects curves with a straight line between their endpoints.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'CurveOrientation',
    dataType: 3,
    summary: 'Defines enumerated values for closed curve orientations.',
    values: [
      {
        signature: 'Undefined = 0',
        summary: 'Unable to compute the curve\'s orientation.'
      },
      {
        signature: 'Clockwise = -1',
        summary: 'The curve\'s orientation is clockwise in the xy plane.'
      },
      {
        signature: 'CounterClockwise = +1',
        summary: 'The curve\'s orientation is counter clockwise in the xy plane.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'CurveProxy',
    dataType: 1,
    summary: 'Provides strongly-typed access to Brep edges.',
    baseclass: 'Rhino.Geometry.Curve',
    properties: [
      {
        signature: 'bool ProxyCurveIsReversed',
        summary: 'True if "this" is a curve is reversed from the "real" curve geometry',
        since: 5.1,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'CurveSimplifyOptions',
    dataType: 3,
    summary: 'Enumerates the options to use when simplifying a curve.',
    values: [
      {
        signature: 'None = 0',
        summary: 'No option is specified.'
      },
      {
        signature: 'SplitAtFullyMultipleKnots = 1',
        summary: `Split NurbsCurves at fully multiple knots. 
     Effectively turning single nurbs segments with kinks into multiple segments.`
      },
      {
        signature: 'RebuildLines = 2',
        summary: 'Replace linear segments with LineCurves.'
      },
      {
        signature: 'RebuildArcs = 4',
        summary: 'Replace partially circular segments with ArcCurves.'
      },
      {
        signature: 'RebuildRationals = 8',
        summary: `Replace rational nurbscurves with constant weights 
     with an equivalent non-rational NurbsCurve.`
      },
      {
        signature: 'AdjustG1 = 16',
        summary: 'Adjust Curves at G1-joins.'
      },
      {
        signature: 'Merge = 32',
        summary: `Merge adjacent co-linear lines or co-circular arcs 
     or combine consecutive line segments into a polyline.`
      },
      {
        signature: 'All = SplitAtFullyMultipleKnots | RebuildLines | RebuildArcs | RebuildRationals | AdjustG1 | Merge',
        summary: 'Implies all of the simplification functions will be used.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Cylinder',
    dataType: 2,
    summary: `Represents the values of a plane, a radius and two heights -on top and beneath-
   that define a right circular cylinder.`,
    constructors: [
      {
        signature: 'Cylinder(Circle baseCircle)',
        summary: 'Constructs a new cylinder with infinite height.',
        since: 5,
        parameters: [
          {
            name: 'baseCircle',
            summary: 'Base circle for infinite cylinder.'
          }
        ]
      },
      {
        signature: 'Cylinder(Circle baseCircle,double height)',
        summary: 'Constructs a new cylinder with a finite height.',
        since: 5,
        parameters: [
          {
            name: 'baseCircle',
            summary: 'Base circle for cylinder.'
          },
          {
            name: 'height',
            summary: 'Height of cylinder (zero for infinite cylinder).'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Cylinder Unset',
        summary: 'Gets an invalid Cylinder.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d Axis',
        summary: 'Gets the axis direction of the cylinder.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Plane BasePlane',
        summary: 'Gets or sets the base plane of the cylinder.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d Center',
        summary: 'Gets the center point of the defining circle.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Height1',
        summary: `Gets or sets the start height of the cylinder.
     The center of bottom cap is: BasePlane.Origin + Height1 * BasePlane.ZAxis.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Height2',
        summary: `Gets or sets the end height of the cylinder. 
     If the end height equals the start height, the cylinder is 
     presumed to be infinite.
     The center of top cap is: BasePlane.Origin + Height2 * BasePlane.ZAxis.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsFinite',
        summary: `True if the cylinder is finite (Height0 != Height1)
     False if the cylinder is infinite.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: `Gets a boolean value indicating whether this cylinder is valid.
     A valid cylinder is represented by a valid circle and two valid heights.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Radius',
        summary: 'Gets or sets the radius of the cylinder.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double TotalHeight',
        summary: `Gets the height of the cylinder. 
     Infinite cylinders have a height of zero, not Double.PositiveInfinity.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Circle CircleAt(double linearParameter)',
        summary: 'Compute the circle at the given elevation parameter.',
        since: 5,
        parameters: [
          {
            name: 'linearParameter',
            summary: 'Height parameter for circle section.'
          }
        ]
      },
      {
        signature: 'bool EpsilonEquals(Cylinder other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'Line LineAt(double angularParameter)',
        summary: 'Compute the line at the given angle parameter. This line will be degenerate if the cylinder is infite.',
        since: 5,
        parameters: [
          {
            name: 'angularParameter',
            summary: 'Angle parameter for line section.'
          }
        ]
      },
      {
        signature: 'Brep ToBrep(bool capBottom,bool capTop)',
        summary: `Constructs a Brep representation of this Cylinder. 
     This is synonymous with calling NurbsSurface.CreateFromCylinder().`,
        since: 5,
        parameters: [
          {
            name: 'capBottom',
            summary: 'If true, the bottom of the cylinder will be capped.'
          },
          {
            name: 'capTop',
            summary: 'If true, the top of the cylinder will be capped.'
          }
        ],
        returns: 'A Brep representation of the cylinder or null.'
      },
      {
        signature: 'NurbsSurface ToNurbsSurface()',
        summary: `Constructs a Nurbs surface representation of this cylinder. 
     This is synonymous with calling NurbsSurface.CreateFromCylinder().`,
        since: 5,
        returns: 'A Nurbs surface representation of the cylinder or null.'
      },
      {
        signature: 'RevSurface ToRevSurface()',
        summary: `Constructs a RevSurface representation of this Cylinder. 
     This is synonymous with calling RevSurface.CreateFromCylinder().`,
        since: 5,
        returns: 'A RevSurface representation of the cylinder or null.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'DetailView',
    dataType: 1,
    summary: 'Represents a view of the model placed on a page layout.',
    baseclass: 'Rhino.Geometry.GeometryBase',
    properties: [
      {
        signature: 'bool IsParallelProjection',
        summary: 'Gets or sets whether the view is parallel.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsPerspectiveProjection',
        summary: 'Gets or sets whether the view is perspective.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsProjectionLocked',
        summary: 'Gets or sets whether the view projection is locked.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PageToModelRatio',
        summary: 'Gets the page units/model units quotient.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool SetScale(double modelLength,UnitSystem modelUnits,double pageLength,UnitSystem pageUnits)',
        summary: 'Sets the detail viewport\'s projection so geometry is displayed at a certain scale.',
        since: 5,
        parameters: [
          {
            name: 'modelLength',
            summary: 'Reference model length.'
          },
          {
            name: 'modelUnits',
            summary: 'Units for model length.'
          },
          {
            name: 'pageLength',
            summary: 'Length on page that the modelLength should equal.'
          },
          {
            name: 'pageUnits',
            summary: 'Units for page length.'
          }
        ],
        returns: 'True on success. False if the DetailView projection is perspective or input values are incongruous.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'DevelopableSrf',
    dataType: 1,
    summary: 'Helpers for developable surface functions',
    methods: [
      {
        signature: 'static int GetLocalDevopableRuling(NurbsCurve rail0,double t0,Interval dom0,NurbsCurve rail1,double t1,Interval dom1,double t0_out,double t1_out)',
        summary: 'Finds minimum twist ruling between 2 curves at local domains',
        since: 6,
        parameters: [
          {
            name: 'rail0',
            summary: 'First rail'
          },
          {
            name: 't0',
            summary: 'Seed param on first rail'
          },
          {
            name: 'dom0',
            summary: 'Param subdomain to adjust in on first rail'
          },
          {
            name: 'rail1',
            summary: 'Second rail'
          },
          {
            name: 't1',
            summary: 'Seed param on second rail'
          },
          {
            name: 'dom1',
            summary: 'Param subdomain to adjust in on second rail'
          },
          {
            name: 't0_out',
            summary: 'Result ruling on first rail'
          },
          {
            name: 't1_out',
            summary: 'Result ruling on second rail'
          }
        ],
        returns: `-1: Error
      0: Exact non-twisting ruling found between t0_out and t1_out
      1: Ruling found between t0_out and t1_out that has less twist 
           the ruling between t0 and t1`
      },
      {
        signature: 'static bool RulingMinTwist(NurbsCurve rail0,double t0,Interval dom0,NurbsCurve rail1,double t1,Interval dom1,double t0_out,double t1_out,double cos_twist_out)',
        summary: `Find a ruling from rail0(t0_out) to rail1(t1_out) that has the least twist
     across the ruling with t0_out in domain0 and t1_out in domain1.
     max_cos_twist is cos(twist) for the returned ruling`,
        since: 6
      },
      {
        signature: 'static bool RulingMinTwist(NurbsCurve rail0,double t0,NurbsCurve rail1,double t1,Interval dom1,double t1_out,double cos_twist_out)',
        summary: `Find a ruling from rail0(t0) to rail1(t1_out) that has the least twist
     across the ruling with t1_out in domain1.
     max_cos_twist is cos(twist) for the returned ruling`,
        since: 6
      },
      {
        signature: 'static bool UntwistRulings(NurbsCurve rail0,NurbsCurve rail1,IEnumerable<Point2d> rulings)'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Dimension.ForceArrow',
    dataType: 3,
    summary: 'OBSOLETE enum do not use.',
    values: [
      {
        signature: 'Auto = 0'
      },
      {
        signature: 'Inside = 1'
      },
      {
        signature: 'Outside = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Dimension.ForceText',
    dataType: 3,
    summary: 'OBSOLETE enum do not use.',
    values: [
      {
        signature: 'Auto = 0'
      },
      {
        signature: 'Inside = 1'
      },
      {
        signature: 'Right = 2'
      },
      {
        signature: 'Left = 3'
      },
      {
        signature: 'HintRight = 4'
      },
      {
        signature: 'HintLeft = 5'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'DistancingMode',
    dataType: 3,
    summary: 'Defines how offset and similar operations should work.',
    values: [
      {
        signature: 'Undefined',
        summary: 'Nothing is defined. This serves as null.'
      },
      {
        signature: 'Linear',
        summary: 'When geometrically possible, offsets with a linear distance.'
      },
      {
        signature: 'LinearFromEnd',
        summary: 'When geometrically possible and an opposite side exists, offsets with a linear distance from that side.'
      },
      {
        signature: 'Ratio',
        summary: `When geometrically possible, uses a percentage of respective neighbours to
     compute offsets.`
      },
      {
        signature: 'RatioFromEnd',
        summary: `When geometrically possible and an opposite side exists, uses a percentage of respective neighbours to
     compute offsets.`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'EdgeAdjacency',
    dataType: 3,
    summary: 'Enumerates all possible Topological Edge adjacency types.',
    values: [
      {
        signature: 'None = 0',
        summary: 'Edge is not used by any faces and is therefore superfluous.'
      },
      {
        signature: 'Naked = 1',
        summary: 'Edge is used by a single face.'
      },
      {
        signature: 'Interior = 2',
        summary: 'Edge is used by two adjacent faces.'
      },
      {
        signature: 'NonManifold = 3',
        summary: 'Edge is used by three or more adjacent faces.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Ellipse',
    dataType: 2,
    summary: 'Represents the values of a plane and the two semiaxes radii in an ellipse.',
    constructors: [
      {
        signature: 'Ellipse(Plane plane,double radius1,double radius2)',
        summary: 'Initializes a new ellipse from base plane and both principal radii.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Base plane of ellipse.'
          },
          {
            name: 'radius1',
            summary: 'Ellipse radius along base plane X direction.'
          },
          {
            name: 'radius2',
            summary: 'Ellipse radius along base plane Y direction.'
          }
        ]
      },
      {
        signature: 'Ellipse(Point3d center,Point3d second,Point3d third)',
        summary: 'Initializes a new ellipse from a center point and the two semiaxes intersections.',
        since: 5,
        parameters: [
          {
            name: 'center',
            summary: 'A center for the ellipse. The avarage of the foci.'
          },
          {
            name: 'second',
            summary: 'The intersection of the ellipse X axis with the ellipse itself.'
          },
          {
            name: 'third',
            summary: `A point that determines the radius along the Y semiaxis.
     If the point is at right angle with the (center - second point) vector,
     it will be the intersection of the ellipse Y axis with the ellipse itself.`
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool IsValid',
        summary: 'Returns an indication of the validity of this ellipse.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Plane Plane',
        summary: 'Gets or sets the base plane of the ellipse.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Radius1',
        summary: 'Gets or sets the radius of the ellipse along the base plane X semiaxis.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Radius2',
        summary: 'Gets or sets the radius of the ellipse along the base plane Y semiaxis.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'bool EpsilonEquals(Ellipse other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'NurbsCurve ToNurbsCurve()',
        summary: `Constructs a nurbs curve representation of this ellipse. 
     This is equivalent to calling NurbsCurve.CreateFromEllipse().`,
        since: 5,
        returns: 'A nurbs curve representation of this ellipse or None if no such representation could be made.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'ExtrudeCornerType',
    dataType: 3,
    summary: 'Corner types used for creating a tapered extrusion',
    values: [
      {
        signature: 'None = 0',
        summary: 'No Corner'
      },
      {
        signature: 'Sharp = 1'
      },
      {
        signature: 'Round = 2'
      },
      {
        signature: 'Smooth = 3'
      },
      {
        signature: 'Chamfer = 4'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Extrusion',
    dataType: 1,
    summary: `Represents an extrusion, or objects such as beams or linearly extruded elements,
   that can be represented by profile curves and two miter planes at the extremes.`,
    baseclass: 'Rhino.Geometry.Surface',
    constructors: [
      {
        signature: 'Extrusion()',
        summary: 'Initializes a new instance of the Extrusion class.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'int CapCount',
        summary: 'Gets the amount of capping surfaces.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsCappedAtBottom',
        summary: 'Gets a value indicating whether the surface that fills the bottom profile is existing.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsCappedAtTop',
        summary: 'Gets a value indicating whether the surface that fills the top profile is existing.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsMiteredAtEnd',
        summary: 'Gets a value indicating whether a miter plane at the end is defined.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsMiteredAtStart',
        summary: 'Returns a value indicating whether a miter plane at start is defined.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsSolid',
        summary: 'Gets a value indicating whether there is no gap among all surfaces constructing this object.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d MiterPlaneNormalAtEnd',
        summary: `Gets or sets the normal of the miter plane at the end in profile coordinates.
     In profile coordinates, 0,0,1 always maps to the extrusion axis`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d MiterPlaneNormalAtStart',
        summary: `Gets or sets the normal of the miter plane at the start in profile coordinates.
     In profile coordinates, 0,0,1 always maps to the extrusion axis`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d PathEnd',
        summary: 'Gets the end point of the path.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d PathStart',
        summary: 'Gets the start point of the path.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d PathTangent',
        summary: 'Gets the up vector of the path.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int ProfileCount',
        summary: 'Gets the amount of profile curves.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Extrusion Create(Curve planarCurve,double height,bool cap)',
        summary: 'Creates an extrusion of a 3d curve (which must be planar) and a height.',
        since: 5.1,
        parameters: [
          {
            name: 'planarCurve',
            summary: 'Planar curve used as profile'
          },
          {
            name: 'height',
            summary: `If the height > 0, the bottom of the extrusion will be in plane and
     the top will be height units above the plane.
     If the height < 0, the top of the extrusion will be in plane and
     the bottom will be height units below the plane.
     The plane used is the one that is returned from the curve's TryGetPlane function.`
          },
          {
            name: 'cap',
            summary: 'If the curve is closed and cap is true, then the resulting extrusion is capped.'
          }
        ],
        returns: 'If the input is valid, then a new extrusion is returned. Otherwise None is returned'
      },
      {
        signature: 'static Extrusion CreateBoxExtrusion(Box box,bool cap)',
        summary: 'Gets an extrusion from a box.',
        since: 6,
        parameters: [
          {
            name: 'box',
            summary: 'IsValid must be true.'
          },
          {
            name: 'cap',
            summary: 'If true, the base and the top of the box will be capped. Defaults to true.'
          }
        ],
        returns: 'Extrusion on success. None on failure.'
      },
      {
        signature: 'static Extrusion CreateCylinderExtrusion(Cylinder cylinder,bool capBottom,bool capTop)',
        summary: 'Gets an extrusion form of a cylinder.',
        since: 5,
        parameters: [
          {
            name: 'cylinder',
            summary: 'IsFinite must be true.'
          },
          {
            name: 'capBottom',
            summary: 'If true, the end at cylinder.Height1 will be capped.'
          },
          {
            name: 'capTop',
            summary: 'If true, the end at cylinder.Height2 will be capped.'
          }
        ],
        returns: 'Extrusion on success. None on failure.'
      },
      {
        signature: 'static Extrusion CreatePipeExtrusion(Cylinder cylinder,double otherRadius,bool capTop,bool capBottom)',
        summary: 'Gets an extrusion form of a pipe.',
        since: 5,
        parameters: [
          {
            name: 'cylinder',
            summary: 'IsFinite must be true.'
          },
          {
            name: 'otherRadius',
            summary: `If cylinder.Radius is less than other radius, then the cylinder will be the inside
     of the pipe.`
          },
          {
            name: 'capTop',
            summary: 'If true, the end at cylinder.Height2 will be capped.'
          },
          {
            name: 'capBottom',
            summary: 'If true, the end at cylinder.Height1 will be capped.'
          }
        ],
        returns: 'Extrusion on success. None on failure.'
      },
      {
        signature: 'bool AddInnerProfile(Curve innerProfile)',
        summary: 'Adds an inner profile.',
        since: 5,
        parameters: [
          {
            name: 'innerProfile',
            summary: 'Closed curve in the XY plane or a 2d curve.'
          }
        ],
        returns: 'True if the profile was set.'
      },
      {
        signature: 'Mesh GetMesh(MeshType meshType)',
        summary: 'Obtains a reference to a specified type of mesh for this extrusion.',
        since: 5.6,
        parameters: [
          {
            name: 'meshType',
            summary: 'The mesh type.'
          }
        ],
        returns: 'A mesh.'
      },
      {
        signature: 'Plane GetPathPlane(double s)',
        summary: 'Gets the 3D plane perpendicular to the path at a normalized path parameter.',
        since: 5,
        parameters: [
          {
            name: 's',
            summary: `0.0 = starting profile
     1.0 = ending profile.`
          }
        ],
        returns: 'A plane. The plane is Invalid on failure.'
      },
      {
        signature: 'Plane GetProfilePlane(double s)',
        summary: 'Gets the 3D plane containing the profile curve at a normalized path parameter.',
        since: 5,
        parameters: [
          {
            name: 's',
            summary: `0.0 = starting profile
     1.0 = ending profile.`
          }
        ],
        returns: 'A plane. The plane is Invalid on failure.'
      },
      {
        signature: 'Transform GetProfileTransformation(double s)',
        summary: 'Gets the transformation that maps the xy profile curve to its 3d location.',
        since: 5,
        parameters: [
          {
            name: 's',
            summary: `0.0 = starting profile
     1.0 = ending profile.`
          }
        ],
        returns: 'A Transformation. The transform is Invalid on failure.'
      },
      {
        signature: 'Curve[] GetWireframe()',
        summary: 'Constructs all the Wireframe curves for this Extrusion.',
        since: 5.6,
        returns: 'An array of Wireframe curves.'
      },
      {
        signature: 'LineCurve PathLineCurve()',
        summary: 'Gets the line-like curve that is the conceptual axis of the extrusion.',
        since: 5,
        returns: 'The path as a line curve.'
      },
      {
        signature: 'Curve Profile3d(ComponentIndex ci)',
        summary: 'Gets one of the profiles.',
        since: 5,
        parameters: [
          {
            name: 'ci',
            summary: 'The index of this profile.'
          }
        ],
        returns: 'The profile.'
      },
      {
        signature: 'Curve Profile3d(int profileIndex,double s)',
        summary: 'Gets a transversal isocurve of the extruded profile.',
        since: 5,
        parameters: [
          {
            name: 'profileIndex',
            summary: `0 <= profileIndex < ProfileCount
     The outer profile has index 0.`
          },
          {
            name: 's',
            summary: `0.0 <= s <= 1.0
     A relative parameter controling which profile is returned.
     0 = bottom profile and 1 = top profile.`
          }
        ],
        returns: 'The profile.'
      },
      {
        signature: 'int ProfileIndex(double profileParameter)',
        summary: 'Gets the index of the profile curve at a domain related to a parameter.',
        since: 5,
        parameters: [
          {
            name: 'profileParameter',
            summary: 'Parameter on profile curve.'
          }
        ],
        returns: `-1 if profileParameter does not correspond to a point on the profile curve.
     When the profileParameter corresponds to the end of one profile and the
     beginning of the next profile, the index of the next profile is returned.`
      },
      {
        signature: 'bool SetOuterProfile(Curve outerProfile,bool cap)',
        summary: 'Sets the outer profile of the extrusion.',
        since: 5,
        parameters: [
          {
            name: 'outerProfile',
            summary: 'curve in the XY plane or a 2D curve.'
          },
          {
            name: 'cap',
            summary: `If outerProfile is a closed curve, then cap determines if the extrusion
     has end caps. If outerProfile is an open curve, cap is ignored.`
          }
        ],
        returns: `True if the profile was set. If the outer profile is closed, then the
     extrusion may also have inner profiles. If the outer profile is open,
     the extrusion may not have inner profiles. If the extrusion already
     has a profile, the set will fail.`
      },
      {
        signature: 'bool SetPathAndUp(Point3d a,Point3d b,Vector3d up)',
        summary: 'Allows to set the two points at the extremes and the up vector.',
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'The start point.'
          },
          {
            name: 'b',
            summary: 'The end point.'
          },
          {
            name: 'up',
            summary: 'The up vector.'
          }
        ],
        returns: `True if the operation succeeded; otherwise false.
     Setting up=a-b will make the operation fail.`
      },
      {
        signature: 'Brep ToBrep(bool splitKinkyFaces)',
        summary: `Constructs a brep form of the extrusion. The outer profile is always the first face of the brep.
     If there are inner profiles, additional brep faces are created for each profile. If the
     outer profile is closed, then end caps are added as the last two faces of the brep.`,
        since: 5,
        parameters: [
          {
            name: 'splitKinkyFaces',
            summary: `If True and the profiles have kinks, then the faces corresponding to those profiles are split
     so they will be G1.`
          }
        ],
        returns: 'A brep with a similar shape like this extrustion, or None on error.'
      },
      {
        signature: 'Curve WallEdge(ComponentIndex ci)',
        summary: 'Gets one of the longitudinal curves along the beam or extrusion.',
        since: 5,
        parameters: [
          {
            name: 'ci',
            summary: 'The index of this profile.'
          }
        ],
        returns: 'The profile.'
      },
      {
        signature: 'Surface WallSurface(ComponentIndex ci)',
        summary: 'Gets one of the longitudinal surfaces of the extrusion.',
        since: 5,
        parameters: [
          {
            name: 'ci',
            summary: 'The index specifying which precise item to retrieve.'
          }
        ],
        returns: 'The surface.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'GeometryBase',
    dataType: 1,
    summary: 'Provides a common base for most geometric classes. This class is abstract.',
    baseclass: 'Rhino.Runtime.CommonObject',
    properties: [
      {
        signature: 'bool HasBrepForm',
        summary: 'Returns True if the Brep.TryConvertBrep function will be successful for this object',
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'bool IsDeformable',
        summary: `True if object can be accurately modified with "squishy" transformations like
     projections, shears, and non-uniform scaling.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsDocumentControlled',
        summary: `If True this object may not be modified. Any properties or functions that attempt
     to modify this object when it is set to "IsReadOnly" will throw a NotSupportedException.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'ObjectType ObjectType',
        summary: `Useful for switch statements that need to differentiate between
     basic object types like points, curves, surfaces, and so on.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'int UserStringCount',
        summary: 'Gets the amount of user strings.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static bool GeometryEquals(GeometryBase first,GeometryBase second)',
        summary: `Determines if two geometries equal one another, in pure geometrical shape.
     This version only compares the geometry itself and does not include any user
     data comparisons.
     This is a comparison by value: for two identical items it will be true, no matter
     where in memory they may be stored.`,
        since: 6,
        parameters: [
          {
            name: 'first',
            summary: 'The first geometry'
          },
          {
            name: 'second',
            summary: 'The second geometry'
          }
        ],
        returns: 'The indication of equality'
      },
      {
        signature: 'ComponentIndex ComponentIndex()',
        summary: `If this piece of geometry is a component in something larger, like a BrepEdge
     in a Brep, then this function returns the component index.`,
        since: 5,
        returns: `This object's component index.  If this object is not a sub-piece of a larger
     geometric entity, then the returned index has 
     m_type = ComponentIndex.InvalidType
     and m_index = -1.`
      },
      {
        signature: 'GeometryBase Duplicate()',
        summary: 'Constructs a deep (full) copy of this object.',
        since: 5,
        returns: 'An object of the same type as this, with the same properties and behavior.'
      },
      {
        signature: 'GeometryBase DuplicateShallow()',
        summary: `Constructs a light copy of this object. By "light", it is meant that the same
     underlying data is used until something is done to attempt to change it. For example,
     you could have a shallow copy of a very heavy mesh object and the same underlying
     data will be used when doing things like inspecting the number of faces on the mesh.
     If you modify the location of one of the mesh vertices, the shallow copy will create
     a full duplicate of the underlying mesh data and the shallow copy will become a
     deep copy.`,
        since: 5,
        returns: `An object of the same type as this object.
     This behavior is overridden by implementing classes.`
      },
      {
        signature: 'BoundingBox GetBoundingBox(bool accurate)',
        summary: 'Boundingbox solver. Gets the world axis aligned boundingbox for the geometry.',
        since: 5,
        parameters: [
          {
            name: 'accurate',
            summary: `If true, a physically accurate boundingbox will be computed. 
     If not, a boundingbox estimate will be computed. For some geometry types there is no 
     difference between the estimate and the accurate boundingbox. Estimated boundingboxes 
     can be computed much (much) faster than accurate (or "tight") bounding boxes. 
     Estimated bounding boxes are always similar to or larger than accurate bounding boxes.`
          }
        ],
        returns: `The boundingbox of the geometry in world coordinates or BoundingBox.Empty 
     if not bounding box could be found.`
      },
      {
        signature: 'BoundingBox GetBoundingBox(Plane plane)',
        summary: 'Aligned Boundingbox solver. Gets the plane aligned boundingbox.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Orientation plane for BoundingBox.'
          }
        ],
        returns: 'A BoundingBox in plane coordinates.'
      },
      {
        signature: 'BoundingBox GetBoundingBox(Plane plane,Box worldBox)',
        summary: 'Aligned Boundingbox solver. Gets the plane aligned boundingbox.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Orientation plane for BoundingBox.'
          },
          {
            name: 'worldBox',
            summary: 'Aligned box in World coordinates.'
          }
        ],
        returns: 'A BoundingBox in plane coordinates.'
      },
      {
        signature: 'BoundingBox GetBoundingBox(Transform xform)',
        summary: 'Aligned Boundingbox solver. Gets the world axis aligned boundingbox for the transformed geometry.',
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: `Transformation to apply to object prior to the BoundingBox computation. 
     The geometry itself is not modified.`
          }
        ],
        returns: `The accurate boundingbox of the transformed geometry in world coordinates 
     or BoundingBox.Empty if not bounding box could be found.`
      },
      {
        signature: 'string GetUserString(string key)',
        summary: 'Gets user string from this geometry.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'id used to retrieve the string.'
          }
        ],
        returns: 'string associated with the key if successful. None if no key was found.'
      },
      {
        signature: 'System.Collections.Specialized.NameValueCollection GetUserStrings()',
        summary: 'Gets a copy of all (user key string, user value string) pairs attached to this geometry.',
        since: 5,
        returns: 'A new collection.'
      },
      {
        signature: 'bool MakeDeformable()',
        summary: `If possible, converts the object into a form that can be accurately modified
     with "squishy" transformations like projections, shears, an non-uniform scaling.`,
        since: 5,
        returns: `False if object cannot be converted to a deformable object. True if object was
     already deformable or was converted into a deformable object.`
      },
      {
        signature: 'uint MemoryEstimate()',
        summary: 'Computes an estimate of the number of bytes that this object is using in memory.',
        since: 5,
        returns: 'An estimated memory footprint.'
      },
      {
        signature: 'bool Rotate(double angleRadians,Vector3d rotationAxis,Point3d rotationCenter)',
        summary: `Rotates the object about the specified axis. A positive rotation 
     angle results in a counter-clockwise rotation about the axis (right hand rule).`,
        since: 5,
        parameters: [
          {
            name: 'angleRadians',
            summary: 'Angle of rotation in radians.'
          },
          {
            name: 'rotationAxis',
            summary: 'Direction of the axis of rotation.'
          },
          {
            name: 'rotationCenter',
            summary: 'Point on the axis of rotation.'
          }
        ],
        returns: 'True if geometry successfully rotated.'
      },
      {
        signature: 'bool Scale(double scaleFactor)',
        summary: 'Scales the object by the specified factor. The scale is centered at the origin.',
        since: 5,
        parameters: [
          {
            name: 'scaleFactor',
            summary: 'The uniform scaling factor.'
          }
        ],
        returns: 'True if geometry successfully scaled.'
      },
      {
        signature: 'bool SetUserString(string key,string value)',
        summary: 'Attach a user string (key,value combination) to this geometry.',
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'id used to retrieve this string.'
          },
          {
            name: 'value',
            summary: 'string associated with key.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'bool Transform(Transform xform)',
        summary: `Transforms the geometry. If the input Transform has a SimilarityType of
     OrientationReversing, you may want to consider flipping the transformed
     geometry after calling this function when it makes sense. For example,
     you may want to call Flip() on a Brep after transforming it.`,
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation to apply to geometry.'
          }
        ],
        returns: 'True if geometry successfully transformed.'
      },
      {
        signature: 'bool Translate(double x,double y,double z)',
        summary: 'Translates the object along the specified vector.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'The X component.'
          },
          {
            name: 'y',
            summary: 'The Y component.'
          },
          {
            name: 'z',
            summary: 'The Z component.'
          }
        ],
        returns: 'True if geometry successfully translated.'
      },
      {
        signature: 'bool Translate(Vector3d translationVector)',
        summary: 'Translates the object along the specified vector.',
        since: 5,
        parameters: [
          {
            name: 'translationVector',
            summary: 'A moving vector.'
          }
        ],
        returns: 'True if geometry successfully translated.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Hatch',
    dataType: 1,
    summary: `Represents a hatch in planar boundary loop or loops.
   This is a 2d entity with a plane defining a local coordinate system.
   The loops, patterns, angles, etc are all in this local coordinate system.
   The Hatch object manages the plane and loop array
   Fill definitions are in the HatchPattern or class derived from HatchPattern
   Hatch has an index to get the pattern definition from the pattern table.`,
    baseclass: 'Rhino.Geometry.GeometryBase',
    properties: [
      {
        signature: 'Point3d BasePoint',
        summary: 'Gets or sets the hatchpattern basepoint',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'int PatternIndex',
        summary: 'Gets or sets the index of the pattern in the document hatch pattern table.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PatternRotation',
        summary: 'Gets or sets the relative rotation of the pattern.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PatternScale',
        summary: 'Gets or sets the scaling factor of the pattern.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Plane Plane',
        summary: 'Gets or sets the hatch plane',
        since: 6.11,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Hatch[] Create(Curve curve,int hatchPatternIndex,double rotationRadians,double scale)',
        summary: 'Constructs an array of Hatch from one curve.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'A Curve.'
          },
          {
            name: 'hatchPatternIndex',
            summary: 'The index of the hatch pattern in the document hatch pattern table.'
          },
          {
            name: 'rotationRadians',
            summary: 'The relative rotation of the pattern.'
          },
          {
            name: 'scale',
            summary: 'A scaling factor.'
          }
        ],
        returns: 'An array of hatches. The array might be empty on error.'
      },
      {
        signature: 'static Hatch[] Create(Curve curve,int hatchPatternIndex,double rotationRadians,double scale,double tolerance)',
        summary: 'Constructs an array of Hatch from one curve.',
        since: 6,
        parameters: [
          {
            name: 'curve',
            summary: 'A Curve.'
          },
          {
            name: 'hatchPatternIndex',
            summary: 'The index of the hatch pattern in the document hatch pattern table.'
          },
          {
            name: 'rotationRadians',
            summary: 'The relative rotation of the pattern.'
          },
          {
            name: 'scale',
            summary: 'A scaling factor.'
          },
          {
            name: 'tolerance',
            summary: ''
          }
        ],
        returns: 'An array of hatches. The array might be empty on error.'
      },
      {
        signature: 'static Hatch[] Create(IEnumerable<Curve> curves,int hatchPatternIndex,double rotationRadians,double scale)',
        summary: 'Constructs an array of Hatch from a set of curves.',
        since: 5,
        parameters: [
          {
            name: 'curves',
            summary: 'An array, a list or any enumarable set of Curve.'
          },
          {
            name: 'hatchPatternIndex',
            summary: 'The index of the hatch pattern in the document hatch pattern table.'
          },
          {
            name: 'rotationRadians',
            summary: 'The relative rotation of the pattern.'
          },
          {
            name: 'scale',
            summary: 'A scaling factor.'
          }
        ],
        returns: 'An array of hatches. The array might be empty on error.'
      },
      {
        signature: 'static Hatch[] Create(IEnumerable<Curve> curves,int hatchPatternIndex,double rotationRadians,double scale,double tolerance)',
        summary: 'Constructs an array of Hatch from a set of curves.',
        since: 6,
        parameters: [
          {
            name: 'curves',
            summary: 'An array, a list or any enumarable set of Curve.'
          },
          {
            name: 'hatchPatternIndex',
            summary: 'The index of the hatch pattern in the document hatch pattern table.'
          },
          {
            name: 'rotationRadians',
            summary: 'The relative rotation of the pattern.'
          },
          {
            name: 'scale',
            summary: 'A scaling factor.'
          },
          {
            name: 'tolerance',
            summary: ''
          }
        ],
        returns: 'An array of hatches. The array might be empty on error.'
      },
      {
        signature: 'void CreateDisplayGeometry(HatchPattern pattern,double patternScale,Curve[] bounds,Line[] lines,Brep solidBrep)',
        summary: 'Generate geometry that would be used to draw the hatch with a given hatch pattern',
        since: 5.6
      },
      {
        signature: 'GeometryBase[] Explode()',
        summary: 'Decomposes the hatch pattern into an array of geometry.',
        since: 5,
        returns: 'An array of geometry that formed the appearance of the original elements.'
      },
      {
        signature: 'Curve[] Get3dCurves(bool outer)',
        summary: 'Gets 3d curves that define the boundaries of the hatch',
        since: 5,
        parameters: [
          {
            name: 'outer',
            summary: 'True to get the outer curves, False to get the inner curves'
          }
        ]
      },
      {
        signature: 'Rhino.Display.ColorGradient GetGradientFill()',
        summary: `Get gradient fill information for this hatch. If the "GradientType" for
     the fill is None, then this hatch doesn't have any gradient fill.`,
        since: 7
      },
      {
        signature: 'void ScalePattern(Transform xform)',
        summary: 'Scale the hatch\'s pattern',
        since: 6.11
      },
      {
        signature: 'void SetGradientFill(ColorGradient fill)',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'HermiteSurface',
    dataType: 1,
    summary: 'Create an ON_NurbsSurface satisfying Hermite interpolation conditions at a grid of points.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'HermiteSurface()',
        summary: 'Initializes a new HermiteSurface instance.',
        since: 7
      },
      {
        signature: 'HermiteSurface(int uCount,int vCount)',
        summary: 'Initializes a new HermiteSurface instance.',
        since: 7,
        parameters: [
          {
            name: 'uCount',
            summary: 'The number of parameters in the "u" direction.'
          },
          {
            name: 'vCount',
            summary: 'The number of parameters in the "v" direction.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool IsValid',
        summary: 'Returns True if the all of values in all of the internal data structues contain valid values, False otherwise.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int UCount',
        summary: 'Gets the number of parameters in the "u" direction.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int VCount',
        summary: 'Gets the number of parameters in the "v" direction.',
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this class.',
        since: 7,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 7
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this class.',
        since: 7,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'Point3d PointAt(int uIndex,int vIndex)',
        summary: 'Gets the interpolation point at the u,v parameter location.',
        since: 7,
        parameters: [
          {
            name: 'uIndex',
            summary: 'The "u" index.'
          },
          {
            name: 'vIndex',
            summary: 'The "v" index.'
          }
        ],
        returns: 'The point location.'
      },
      {
        signature: 'void SetPointAt(int uIndex,int vIndex,Point3d point)',
        summary: 'Sets the interpolation point at the u,v parameter location.',
        since: 7,
        parameters: [
          {
            name: 'uIndex',
            summary: 'The "u" index.'
          },
          {
            name: 'vIndex',
            summary: 'The "v" index.'
          },
          {
            name: 'point',
            summary: 'The point location.'
          }
        ]
      },
      {
        signature: 'void SetTwistAt(int uIndex,int vIndex,Vector3d twist)',
        summary: 'Set the twist direction (mixed second partial derivative) to intepolate at the u,v parameter location.',
        since: 7,
        parameters: [
          {
            name: 'uIndex',
            summary: 'The "u" index.'
          },
          {
            name: 'vIndex',
            summary: 'The "v" index.'
          },
          {
            name: 'twist',
            summary: 'The twist direction.'
          }
        ]
      },
      {
        signature: 'void SetUParameterAt(int index,double parameter)',
        summary: 'Sets the "u" parameter at an index. These parameters are strictly increasing.',
        since: 7,
        parameters: [
          {
            name: 'index',
            summary: 'The index.'
          },
          {
            name: 'parameter',
            summary: 'The parameter value.'
          }
        ]
      },
      {
        signature: 'void SetUTangentAt(int uIndex,int vIndex,Vector3d tangent)',
        summary: 'Set the "u" tangent direction (actually first derivative) to intepolate at the u,v parameter location.',
        since: 7,
        parameters: [
          {
            name: 'uIndex',
            summary: 'The "u" index.'
          },
          {
            name: 'vIndex',
            summary: 'The "v" index.'
          },
          {
            name: 'tangent',
            summary: 'The tangent direction.'
          }
        ]
      },
      {
        signature: 'void SetVParameterAt(int index,double parameter)',
        summary: 'Sets the "v" parameter at an index. These parameters are strictly increasing.',
        since: 7,
        parameters: [
          {
            name: 'index',
            summary: 'The index.'
          },
          {
            name: 'parameter',
            summary: 'The parameter value.'
          }
        ]
      },
      {
        signature: 'void SetVTangentAt(int uIndex,int vIndex,Vector3d tangent)',
        summary: 'Set the "v" tangent direction (actually first derivative) to intepolate at the u,v parameter location.',
        since: 7,
        parameters: [
          {
            name: 'uIndex',
            summary: 'The "u" index.'
          },
          {
            name: 'vIndex',
            summary: 'The "v" index.'
          },
          {
            name: 'tangent',
            summary: 'The tangent direction.'
          }
        ]
      },
      {
        signature: 'NurbsSurface ToNurbsSurface()',
        summary: 'Constructs a NURBS surface satisfying the Hermite interpolation conditions.',
        since: 7,
        returns: 'A NURBS surface is successful, None otherwise.'
      },
      {
        signature: 'Vector3d TwistAt(int uIndex,int vIndex)',
        summary: 'Get the twist direction (mixed second partial derivative) to intepolate at the u,v parameter location.',
        since: 7,
        parameters: [
          {
            name: 'uIndex',
            summary: 'The "u" index.'
          },
          {
            name: 'vIndex',
            summary: 'The "v" index.'
          }
        ],
        returns: 'The twist direction.'
      },
      {
        signature: 'double UParameterAt(int index)',
        summary: 'Gets the "u" parameter at an index. These parameters are strictly increasing.',
        since: 7,
        parameters: [
          {
            name: 'index',
            summary: 'The index.'
          }
        ],
        returns: 'The parameter.'
      },
      {
        signature: 'Vector3d UTangentAt(int uIndex,int vIndex)',
        summary: 'Get the "u" tangent direction (actually first derivative) to intepolate at the u,v parameter location.',
        since: 7,
        parameters: [
          {
            name: 'uIndex',
            summary: 'The "u" index.'
          },
          {
            name: 'vIndex',
            summary: 'The "v" index.'
          }
        ],
        returns: 'The tangent direction.'
      },
      {
        signature: 'double VParameterAt(int index)',
        summary: 'Gets the "v" parameter at an index. These parameters are strictly increasing.',
        since: 7,
        parameters: [
          {
            name: 'index',
            summary: 'The index.'
          }
        ],
        returns: 'The parameter.'
      },
      {
        signature: 'Vector3d VTangentAt(int uIndex,int vIndex)',
        summary: 'Get the "v" tangent direction (actually first derivative) to intepolate at the u,v parameter location.',
        since: 7,
        parameters: [
          {
            name: 'uIndex',
            summary: 'The "u" index.'
          },
          {
            name: 'vIndex',
            summary: 'The "v" index.'
          }
        ],
        returns: 'The tangent direction.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'HiddenLineDrawing',
    dataType: 1,
    summary: `Represents a hidden line drawing object.
   A hidden line drawing consists of curves generated from source objects.
   The curves correspond to edges, and silhouettes of  source objects and
   intersections with cutting planes.`,
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'IEnumerable<HiddenLineDrawingPoint> Points',
        summary: 'Point objects calculated by the hidden line drawing.',
        since: 6.8,
        property: ['get']
      },
      {
        signature: 'IEnumerable<HiddenLineDrawingSegment> Segments',
        summary: 'Subcurve objects calculated by the hidden line drawing.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'ViewportInfo Viewport',
        summary: 'Returns the ViewportInfo used by the hidden line drawing.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Transform WorldToHiddenLine',
        summary: 'Returns the world-coordinate system to HLD-coordinate system transformation.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static HiddenLineDrawing Compute(HiddenLineDrawingParameters parameters,bool multipleThreads)',
        summary: 'Perform the hidden line drawing calculation based on input parameters',
        since: 6,
        returns: 'Results of calculation on success, None on failure'
      },
      {
        signature: 'static HiddenLineDrawing Compute(HiddenLineDrawingParameters parameters,bool multipleThreads,IProgress<double> progress,CancellationToken cancelToken)',
        summary: 'Perform the hidden line drawing calculation based on input parameters',
        since: 6,
        returns: 'Results of calculation on success, None on failure or cancellation'
      },
      {
        signature: 'BoundingBox BoundingBox(bool includeHidden)',
        summary: 'Get tight bounding box of the hidden line drawing.',
        since: 6,
        parameters: [
          {
            name: 'includeHidden',
            summary: 'Include hidden objects.'
          }
        ],
        returns: 'The tight bounding box.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'HiddenLineDrawingObject',
    dataType: 1,
    summary: 'Represents an object added to a HiddenLineDrawing',
    properties: [
      {
        signature: 'GeometryBase Geometry',
        summary: `Returns the geometry in world coordinates if UseXform is false. 
     Otherwise, the geometry in object space coordinates is returned.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'object Tag',
        summary: `Returns the extra data used to cross-reference the object specified in
     HiddenLineDrawing.AddObject.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'Transform Transform',
        summary: `Returns the transformation passed into the Add... function
     when setting up the hidden line drawing parameters.`,
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'HiddenLineDrawingObjectCurve',
    dataType: 1,
    summary: `Curves generated from source objects which correspond to edges, and
   silhouettes of source objects and intersections with cutting planes. A
   HiddenLineDrawingObjectCurve is partitioned into hidden and visible
   segments called HiddenLineDrawingSegment`,
    properties: [
      {
        signature: 'int ClippingPlaneIndex',
        summary: 'Index into HiddenLineDrawing.ClippingPlanes when SilhouetteType == SilhouetteType.SectionCut.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int Index',
        summary: 'Index of this object in HiddenLineDrawing.FullCurves.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsProjecting',
        summary: 'Returns True if all the non clipped portions of this curve are projecting.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: 'Verifies the object is valid.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'double OriginalDomainStart',
        summary: `Initialized to RhinoMath.UnsetValue. Valid if the full curve is closed.
     Rejoin can reparmeterize the curve by moving the seam.  When this has been
      done the original domain start is stored here.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'double[] Parameters',
        summary: 'Increasing, partition of curve.Domain.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'HiddenLineDrawingSegment[] Segments',
        summary: 'The HiddenLineDrawingCurve objects that make up this full curve.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'SilhouetteType SilhouetteType',
        summary: 'The silhouette event type',
        since: 6,
        property: ['get']
      },
      {
        signature: 'HiddenLineDrawingObject SourceObject',
        summary: 'Return the source object that this curve came from',
        since: 6,
        property: ['get']
      },
      {
        signature: 'ComponentIndex SourceObjectComponentIndex',
        summary: 'Component of source object part that generated this curve.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'HiddenLineDrawingSegment Curve(double t)',
        summary: 'Returns the HiddenLineDrawingCurve object containing parameter \'t\'.',
        since: 6,
        parameters: [
          {
            name: 't',
            summary: 'The parameter.'
          }
        ],
        returns: 'The HiddenLineDrawingCurve object if successful.'
      },
      {
        signature: 'HiddenLineDrawingSegment Curve(double t,int side)',
        summary: 'Returns the HiddenLineDrawingCurve object containing parameter \'t\'.',
        since: 6,
        parameters: [
          {
            name: 't',
            summary: 'The parameter.'
          },
          {
            name: 'side',
            summary: `Determines which side to return at breakpoints, where: 
     0 - default,
     <0 - curve that contains an interval [t-, t], for some t- < t,
     >0 - curve that contains an interval [t, t+], for some t+ > t.`
          }
        ],
        returns: 'The HiddenLineDrawingCurve object if successful.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'HiddenLineDrawingParameters',
    dataType: 1,
    summary: 'Input used for computing a hidden line drawing',
    constructors: [
      {
        signature: 'HiddenLineDrawingParameters()',
        summary: 'default constructor',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'double AbsoluteTolerance',
        summary: `Absolute tolerance is used to decide if curves overlap or intersect.
     A suggested value is to use RhinoDoc.AbsoluteTolerance`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool Flatten',
        summary: 'Flatten the computed geometry',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool IncludeHiddenCurves',
        summary: 'Include hidden curves in hidden line drawing (default is true)',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool IncludeTangentEdges',
        summary: 'Include tangent edges in hidden line drawing (default is true)',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool IncludeTangentSeams',
        summary: 'Include tangent seams in hidden line drawing (default is true)',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void AddClippingPlane(Plane plane)',
        summary: 'Specify clipping planes that are active for this view.',
        since: 6
      },
      {
        signature: 'bool AddGeometry(GeometryBase geometry,object tag)',
        summary: 'Add geometry that should be included in the calculation',
        since: 6,
        parameters: [
          {
            name: 'geometry',
            summary: 'Currently only curves, meshes, breps, surfaces, and extrusions are supported'
          },
          {
            name: 'tag',
            summary: 'arbitrary data to be associated with this geometry'
          }
        ],
        returns: `True if the type of geometry can be added for calculations.
     Currently only curves, meshes, breps, surfaces and extrusions are supported`
      },
      {
        signature: 'bool AddGeometry(GeometryBase geometry,Transform xform,object tag)',
        summary: 'Add geometry that should be included in the calculation',
        since: 6,
        parameters: [
          {
            name: 'geometry',
            summary: 'Currently only points, point clouds, curves, meshes, breps, surfaces, and extrusions are supported'
          },
          {
            name: 'xform',
            summary: ''
          },
          {
            name: 'tag',
            summary: 'arbitrary data to be associated with this geometry'
          }
        ],
        returns: `True if the type of geometry can be added for calculations.
     Currently only points, point clouds, curves, meshes, breps, surfaces and extrusions are supported`
      },
      {
        signature: 'void SetViewport(RhinoViewport viewport)',
        summary: `Set the viewport for the hidden line drawing (HLD). The viewport supplies
     the projection that determinest he visibility of curves, and the HLD 
     coordinate system in which the resulting curves are represented. The
     HLD-coordinate system is a right handed system for 3-D model space, in 
     which the 3rd coordinate direction is the projection direction. In particular
     the z-coordinate direction points from the scene toward the camera.`,
        since: 6,
        parameters: [
          {
            name: 'viewport',
            summary: 'A copy of rhinoViewport is made inside of HiddenLineDrawing.'
          }
        ],
        returns: 'True if the viewport has been set.'
      },
      {
        signature: 'void SetViewport(ViewportInfo viewport)',
        summary: `Set the viewport for the hidden line drawing (HLD). The viewport supplies
     the projection that determines the visibility of curves, and the HLD 
     coordinate system in which the resulting curves are represented. The
     HLD-coordinate system is a right handed system for 3-D model space, in 
     which the 3rd coordinate direction is the projection direction. In particular
     the z-coordinate direction points from the scene toward the camera.`,
        since: 6,
        parameters: [
          {
            name: 'viewport',
            summary: 'A copy of viewportInfo is made inside of HiddenLineDrawing.'
          }
        ],
        returns: 'True if the viewport has been set.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'HiddenLineDrawingPoint',
    dataType: 1,
    summary: 'Points generated from source objects which coorespond to point and point cloud source objects.',
    properties: [
      {
        signature: 'int ClippingPlaneIndex',
        summary: 'Index into HiddenLineDrawing.ClippingPlanes when SilhouetteType == SilhouetteType.SectionCut.',
        since: 6.8,
        property: ['get']
      },
      {
        signature: 'int Index',
        summary: 'Index of this object in HiddenLineDrawing.Points.',
        since: 6.8,
        property: ['get']
      },
      {
        signature: 'Point3d Location',
        summary: 'Returns the location of this object in HiddenLineDrawing coordinates.',
        since: 6.8,
        property: ['get']
      },
      {
        signature: 'Visibility PointVisibility',
        summary: 'Returns the point\'s visibility',
        since: 6.8,
        property: ['get']
      },
      {
        signature: 'HiddenLineDrawingObject SourceObject',
        summary: 'Return the source object that this point came from.',
        since: 6.8,
        property: ['get']
      },
      {
        signature: 'ComponentIndex SourceObjectComponentIndex',
        summary: 'Component of source object part that generated this curve.',
        since: 6.8,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'HiddenLineDrawingPoint.Visibility',
    dataType: 3,
    summary: 'The different types of HiddenLineObjectPoint visiblity',
    values: [
      {
        signature: 'Unset = UnsafeNativeMethods.HldPointVisibility.PointUnset',
        summary: 'Unset value'
      },
      {
        signature: 'Visible = UnsafeNativeMethods.HldPointVisibility.PointVisible',
        summary: 'Visible'
      },
      {
        signature: 'Hidden = UnsafeNativeMethods.HldPointVisibility.PointHidden',
        summary: 'Hidden'
      },
      {
        signature: 'Duplicate = UnsafeNativeMethods.HldPointVisibility.PointDuplicate',
        summary: 'Duplicate'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'HiddenLineDrawingSegment',
    dataType: 1,
    summary: `The results of HiddenLineDrawing calculation are a collection of segments.
   A segment is a subcurve of a HiddenLineDrawingObjectCurve.`,
    properties: [
      {
        signature: 'Curve CurveGeometry',
        summary: 'The actual curve geometry',
        since: 6,
        property: ['get']
      },
      {
        signature: 'SideFill[] CurveSideFills',
        summary: `The SideFill fields are only valid for visible curves.
     With respect to the HiddenLineDrawing, the region to the left (or right respecively) of this curve is
     described by CurveSideFills[0] or CurveSideFills[1], respectively.  If exactly one of these regions is empty 
     this is a scene silhouette. If this region conains a surface it is either a surface which in 3-D is adjacent 
     to this edge or it an surface that is further away from the camera, we call this a shadow surface.  
     unknown is used for unset values and for projecting curves`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'int Index',
        summary: 'Index of this curve in HiddenLineDrawing.Curves.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsSceneSilhouette',
        summary: 'Returns True if this curve is a scene silhoutte.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'HiddenLineDrawingObjectCurve ParentCurve',
        summary: 'This curve is a subcurve of the returned HiddenLineDrawingFullCurve object.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Visibility SegmentVisibility',
        summary: 'Returns the segment\'s visibility',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'HiddenLineDrawingSegment.SideFill',
    dataType: 3,
    summary: `When a silhouette is projected on the image plane (determined by the camera location or direction),
     and projects to a curve (not a point), the image area to the left or right of a projected silhouette
     curve is filled with either the surface or a void.`,
    values: [
      {
        signature: 'SideUnset = UnsafeNativeMethods.HldSilhouetteSideFill.SideUnset',
        summary: 'Unset'
      },
      {
        signature: 'SideSurface = UnsafeNativeMethods.HldSilhouetteSideFill.SideSurface',
        summary: 'Surface'
      },
      {
        signature: 'SideVoid = UnsafeNativeMethods.HldSilhouetteSideFill.SideVoid',
        summary: 'Void'
      },
      {
        signature: 'OtherSurface = UnsafeNativeMethods.HldSilhouetteSideFill.SideOtherSurface',
        summary: 'Other Surface'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'HiddenLineDrawingSegment.Visibility',
    dataType: 3,
    summary: 'The different types of HiddenLineDrawingSegment visiblity',
    values: [
      {
        signature: 'Unset = UnsafeNativeMethods.HldCurveVisibility.Unset',
        summary: 'Unset value'
      },
      {
        signature: 'Visible = UnsafeNativeMethods.HldCurveVisibility.Visible',
        summary: 'Visible'
      },
      {
        signature: 'Hidden = UnsafeNativeMethods.HldCurveVisibility.Hidden',
        summary: 'Hidden'
      },
      {
        signature: 'Duplicate = UnsafeNativeMethods.HldCurveVisibility.Duplicate',
        summary: 'Duplicate'
      },
      {
        signature: 'Projecting = UnsafeNativeMethods.HldCurveVisibility.Projecting',
        summary: 'Projects to a point (smaller than tolerance)'
      },
      {
        signature: 'Clipped = UnsafeNativeMethods.HldCurveVisibility.Clipped',
        summary: 'Clipped by clipping planes'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'InstanceDefinitionGeometry',
    dataType: 1,
    summary: `Represents a block definition in a File3dm. This is the same as
   Rhino.DocObjects.InstanceDefinition, but not associated with a RhinoDoc.`,
    baseclass: 'Rhino.DocObjects.ModelComponent',
    constructors: [
      {
        signature: 'InstanceDefinitionGeometry()',
        summary: 'Initializes a new block definition.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.InstanceDefinition.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Description',
        summary: 'Gets or sets the description of the definition.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'Guid[] GetObjectIds()',
        summary: 'list of object ids in the instance geometry table',
        since: 5.6
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'InstanceReferenceGeometry',
    dataType: 1,
    summary: 'Represents a reference to the geometry in a block definition.',
    baseclass: 'Rhino.Geometry.GeometryBase',
    constructors: [
      {
        signature: 'InstanceReferenceGeometry(Guid instanceDefinitionId,Transform transform)',
        summary: 'Constructor used when creating nested instance references.',
        since: 5.1
      }
    ],
    properties: [
      {
        signature: 'Guid ParentIdefId',
        summary: 'The unique id for the parent instance definition of this instance reference.',
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'Transform Xform',
        summary: 'Transformation for this reference.',
        since: 5.6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Interpolator',
    dataType: 1,
    summary: 'Exposes a set of standard numeric interpolation algorithms.',
    baseclass: 'RhinoList<double>',
    constructors: [
      {
        signature: 'Interpolator()',
        summary: 'Constructs a new, empty Interpolator.',
        since: 5
      },
      {
        signature: 'Interpolator(IEnumerable<double> collection)',
        summary: 'Constructs an Interpolator from a collection of numbers.',
        since: 5,
        parameters: [
          {
            name: 'collection',
            summary: 'Collection of numbers to duplicate.'
          }
        ]
      },
      {
        signature: 'Interpolator(int initialCapacity)',
        summary: 'Constructs an empty Interpolator with a certain capacity.',
        since: 5,
        parameters: [
          {
            name: 'initialCapacity',
            summary: 'Number of items this interpolator can store without resizing.'
          }
        ]
      },
      {
        signature: 'Interpolator(int amount,double defaultValue)',
        summary: 'Constructs a new Interpolator with a specified amount of numbers.',
        since: 5,
        parameters: [
          {
            name: 'amount',
            summary: 'Number of values to add to this Interpolator. Must be equal to or larger than zero.'
          },
          {
            name: 'defaultValue',
            summary: 'Number to add.'
          }
        ]
      },
      {
        signature: 'Interpolator(RhinoList<double> list)',
        summary: 'Copy all the numbers from an existing RhinoList.',
        since: 5,
        parameters: [
          {
            name: 'list',
            summary: 'List to mimic.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool Cyclical',
        summary: `Gets or sets a value indicating whether or not the values inside this Interpolator 
     are to be treated as cyclical (i.e. circular).`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'double InterpolateCatmullRom(double t)',
        summary: 'Sample the list of numbers with Catmull-Rom interpolation.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: `Parameter to sample at. The integer portion of the parameter 
     indicates the index of the left-hand value. If this Interpolator is cyclical, 
     parameters will be wrapped.`
          }
        ],
        returns: 'The sampled value at t.'
      },
      {
        signature: 'double InterpolateCosine(double t)',
        summary: 'Sample the list of numbers with cosine interpolation.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: `Parameter to sample at. The integer portion of the parameter 
     indicates the index of the left-hand value. If this Interpolator is cyclical, 
     parameters will be wrapped.`
          }
        ],
        returns: 'The sampled value at t.'
      },
      {
        signature: 'double InterpolateCubic(double t)',
        summary: 'Sample the list of numbers with cubic interpolation.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: `Parameter to sample at. The integer portion of the parameter 
     indicates the index of the left-hand value. If this Interpolator is cyclical, 
     parameters will be wrapped.`
          }
        ],
        returns: 'The sampled value at t.'
      },
      {
        signature: 'double InterpolateLinear(double t)',
        summary: 'Sample the list of numbers with linear interpolation.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: `Parameter to sample at. The integer portion of the parameter 
     indicates the index of the left-hand value. If this Interpolator is cyclical, 
     parameters will be wrapped.`
          }
        ],
        returns: 'The sampled value at t.'
      },
      {
        signature: 'double InterpolateNearestNeighbour(double t)',
        summary: 'Sample the list of numbers with Nearest Neighbour interpolation.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: `Parameter to sample at. The integer portion of the parameter 
     indicates the index of the left-hand value. If this Interpolator is cyclical, 
     parameters will be wrapped.`
          }
        ],
        returns: 'The sampled value at t.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Intersect',
    name: 'CurveIntersections',
    dataType: 1,
    summary: 'Maintains an ordered list of Curve Intersection results.',
    interfaces: ['IDisposable', 'IList<IntersectionEvent>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of recorded intersection events.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void CopyTo(IntersectionEvent[] array,int arrayIndex)',
        summary: 'Copies all intersection results into another array, departing at an index in the target array.',
        since: 5,
        parameters: [
          {
            name: 'array',
            summary: 'The target array. This value cannot be null.'
          },
          {
            name: 'arrayIndex',
            summary: 'Zero-based index in which to start the copy.'
          }
        ]
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'IEnumerator<IntersectionEvent> GetEnumerator()',
        summary: 'Returns an enumerator that is capable of yielding all IntersectionEvents in the collection.',
        since: 5,
        returns: 'The constructed enumerator.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Intersect',
    name: 'Intersection',
    dataType: 1,
    summary: 'Provides static methods for the computation of intersections, projections, sections and similar.',
    properties: [
      {
        signature: 'static double MeshIntersectionsTolerancesCoefficient',
        summary: `Offers a requested adjustment coefficient for mesh-mesh intersections tolerances.
     The value can be used to multiply the document absolute tolerance.This is only a UI value; it is up to developer to honor (or not) this request, depending on application needs.`,
        since: 7,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static bool BrepBrep(Brep brepA,Brep brepB,double tolerance,Curve[] intersectionCurves,Point3d[] intersectionPoints)',
        summary: 'Intersects two Breps.',
        since: 5,
        parameters: [
          {
            name: 'brepA',
            summary: 'First Brep for intersection.'
          },
          {
            name: 'brepB',
            summary: 'Second Brep for intersection.'
          },
          {
            name: 'tolerance',
            summary: 'Intersection tolerance.'
          },
          {
            name: 'intersectionCurves',
            summary: 'The intersection curves will be returned here.'
          },
          {
            name: 'intersectionPoints',
            summary: 'The intersection points will be returned here.'
          }
        ],
        returns: 'True on success; False on failure.'
      },
      {
        signature: 'static bool BrepPlane(Brep brep,Plane plane,double tolerance,Curve[] intersectionCurves,Point3d[] intersectionPoints)',
        summary: 'Intersects a Brep with an (infinite) plane.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'Brep to intersect.'
          },
          {
            name: 'plane',
            summary: 'Plane to intersect with.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use for intersections.'
          },
          {
            name: 'intersectionCurves',
            summary: 'The intersection curves will be returned here.'
          },
          {
            name: 'intersectionPoints',
            summary: 'The intersection points will be returned here.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'static bool BrepSurface(Brep brep,Surface surface,double tolerance,Curve[] intersectionCurves,Point3d[] intersectionPoints)',
        summary: 'Intersects a Brep and a Surface.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'A brep to be intersected.'
          },
          {
            name: 'surface',
            summary: 'A surface to be intersected.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value.'
          },
          {
            name: 'intersectionCurves',
            summary: 'The intersection curves array argument. This out reference is assigned during the call.'
          },
          {
            name: 'intersectionPoints',
            summary: 'The intersection points array argument. This out reference is assigned during the call.'
          }
        ],
        returns: 'True on success; False on failure.'
      },
      {
        signature: 'static bool CurveBrep(Curve curve,Brep brep,double tolerance,Curve[] overlapCurves,Point3d[] intersectionPoints)',
        summary: `Intersects a curve with a Brep. This function returns the 3D points of intersection
     and 3D overlap curves. If an error occurs while processing overlap curves, this function 
     will return false, but it will still provide partial results.`,
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve for intersection.'
          },
          {
            name: 'brep',
            summary: 'Brep for intersection.'
          },
          {
            name: 'tolerance',
            summary: 'Fitting and near miss tolerance.'
          },
          {
            name: 'overlapCurves',
            summary: 'The overlap curves will be returned here.'
          },
          {
            name: 'intersectionPoints',
            summary: 'The intersection points will be returned here.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'static bool CurveBrep(Curve curve,Brep brep,double tolerance,Curve[] overlapCurves,Point3d[] intersectionPoints,double[] curveParameters)',
        summary: `Intersects a curve with a Brep. This function returns the 3D points of intersection, curve parameters at the intersection locations,
     and 3D overlap curves. If an error occurs while processing overlap curves, this function 
     will return false, but it will still provide partial results.`,
        since: 6,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve for intersection.'
          },
          {
            name: 'brep',
            summary: 'Brep for intersection.'
          },
          {
            name: 'tolerance',
            summary: 'Fitting and near miss tolerance.'
          },
          {
            name: 'overlapCurves',
            summary: 'The overlap curves will be returned here.'
          },
          {
            name: 'intersectionPoints',
            summary: 'The intersection points will be returned here.'
          },
          {
            name: 'curveParameters',
            summary: 'The intersection curve parameters will be returned here.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'static bool CurveBrep(Curve curve,Brep brep,double tolerance,double angleTolerance,double[] t)',
        summary: 'Intersect a curve with a Brep. This function returns the intersection parameters on the curve.',
        since: 6,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve.'
          },
          {
            name: 'brep',
            summary: 'Brep.'
          },
          {
            name: 'tolerance',
            summary: 'Absolute tolerance for intersections.'
          },
          {
            name: 'angleTolerance',
            summary: 'Angle tolerance in radians.'
          },
          {
            name: 't',
            summary: 'Curve parameters at intersections.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'static bool CurveBrepFace(Curve curve,BrepFace face,double tolerance,Curve[] overlapCurves,Point3d[] intersectionPoints)',
        summary: 'Intersects a curve with a Brep face.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'A curve.'
          },
          {
            name: 'face',
            summary: 'A brep face.'
          },
          {
            name: 'tolerance',
            summary: 'Fitting and near miss tolerance.'
          },
          {
            name: 'overlapCurves',
            summary: 'A overlap curves array argument. This out reference is assigned during the call.'
          },
          {
            name: 'intersectionPoints',
            summary: 'A points array argument. This out reference is assigned during the call.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'static CurveIntersections CurveCurve(Curve curveA,Curve curveB,double tolerance,double overlapTolerance)',
        summary: 'Finds the intersections between two curves.',
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'First curve for intersection.'
          },
          {
            name: 'curveB',
            summary: 'Second curve for intersection.'
          },
          {
            name: 'tolerance',
            summary: 'Intersection tolerance. If the curves approach each other to within tolerance, an intersection is assumed.'
          },
          {
            name: 'overlapTolerance',
            summary: 'The tolerance with which the curves are tested.'
          }
        ],
        returns: 'A collection of intersection events.'
      },
      {
        signature: 'static CurveIntersections CurveCurveValidate(Curve curveA,Curve curveB,double tolerance,double overlapTolerance,int[] invalidIndices,TextLog textLog)',
        summary: 'Finds the intersections between two curves.',
        since: 7,
        parameters: [
          {
            name: 'curveA',
            summary: 'First curve for intersection.'
          },
          {
            name: 'curveB',
            summary: 'Second curve for intersection.'
          },
          {
            name: 'tolerance',
            summary: 'Intersection tolerance. If the curves approach each other to within tolerance, an intersection is assumed.'
          },
          {
            name: 'overlapTolerance',
            summary: 'The tolerance with which the curves are tested.'
          },
          {
            name: 'invalidIndices',
            summary: 'The indices in the resulting CurveIntersections collection that are invalid.'
          },
          {
            name: 'textLog',
            summary: 'A textlog that contains tails about the invalid intersection events.'
          }
        ],
        returns: 'A collection of intersection events.'
      },
      {
        signature: 'static CurveIntersections CurveLine(Curve curve,Line line,double tolerance,double overlapTolerance)',
        summary: 'Intersects a curve and an infinite line.',
        since: 6,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve for intersection.'
          },
          {
            name: 'line',
            summary: 'Infinite line to intersect.'
          },
          {
            name: 'tolerance',
            summary: 'Intersection tolerance. If the curves approach each other to within tolerance, an intersection is assumed.'
          },
          {
            name: 'overlapTolerance',
            summary: 'The tolerance with which the curves are tested.'
          }
        ],
        returns: 'A collection of intersection events.'
      },
      {
        signature: 'static CurveIntersections CurvePlane(Curve curve,Plane plane,double tolerance)',
        summary: 'Intersects a curve with an (infinite) plane.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve to intersect.'
          },
          {
            name: 'plane',
            summary: 'Plane to intersect with.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use during intersection.'
          }
        ],
        returns: 'A list of intersection events or None if no intersections were recorded.'
      },
      {
        signature: 'static CurveIntersections CurveSelf(Curve curve,double tolerance)',
        summary: 'Finds the places where a curve intersects itself.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve for self-intersections.'
          },
          {
            name: 'tolerance',
            summary: `Intersection tolerance. If the curve approaches itself to within tolerance, 
     an intersection is assumed.`
          }
        ],
        returns: 'A collection of intersection events.'
      },
      {
        signature: 'static CurveIntersections CurveSurface(Curve curve,Interval curveDomain,Surface surface,double tolerance,double overlapTolerance)',
        summary: 'Intersects a sub-curve and a surface.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve for intersection.'
          },
          {
            name: 'curveDomain',
            summary: 'Domain of sub-curve to take into consideration for Intersections.'
          },
          {
            name: 'surface',
            summary: 'Surface for intersection.'
          },
          {
            name: 'tolerance',
            summary: 'Intersection tolerance. If the curve approaches the surface to within tolerance, an intersection is assumed.'
          },
          {
            name: 'overlapTolerance',
            summary: 'The tolerance with which the curves are tested.'
          }
        ],
        returns: 'A collection of intersection events.'
      },
      {
        signature: 'static CurveIntersections CurveSurface(Curve curve,Surface surface,double tolerance,double overlapTolerance)',
        summary: 'Intersects a curve and a surface.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve for intersection.'
          },
          {
            name: 'surface',
            summary: 'Surface for intersection.'
          },
          {
            name: 'tolerance',
            summary: 'Intersection tolerance. If the curve approaches the surface to within tolerance, an intersection is assumed.'
          },
          {
            name: 'overlapTolerance',
            summary: 'The tolerance with which the curves are tested.'
          }
        ],
        returns: 'A collection of intersection events.'
      },
      {
        signature: 'static CurveIntersections CurveSurfaceValidate(Curve curve,Interval curveDomain,Surface surface,double tolerance,double overlapTolerance,int[] invalidIndices,TextLog textLog)',
        summary: 'Intersects a sub-curve and a surface.',
        since: 7,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve for intersection.'
          },
          {
            name: 'curveDomain',
            summary: 'Domain of sub-curve to take into consideration for Intersections.'
          },
          {
            name: 'surface',
            summary: 'Surface for intersection.'
          },
          {
            name: 'tolerance',
            summary: 'Intersection tolerance. If the curve approaches the surface to within tolerance, an intersection is assumed.'
          },
          {
            name: 'overlapTolerance',
            summary: 'The tolerance with which the curves are tested.'
          },
          {
            name: 'invalidIndices',
            summary: 'The indices in the resulting CurveIntersections collection that are invalid.'
          },
          {
            name: 'textLog',
            summary: 'A textlog that contains tails about the invalid intersection events.'
          }
        ],
        returns: 'A collection of intersection events.'
      },
      {
        signature: 'static CurveIntersections CurveSurfaceValidate(Curve curve,Surface surface,double tolerance,double overlapTolerance,int[] invalidIndices,TextLog textLog)',
        summary: 'Intersects a curve and a surface.',
        since: 7,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve for intersection.'
          },
          {
            name: 'surface',
            summary: 'Surface for intersection.'
          },
          {
            name: 'tolerance',
            summary: 'Intersection tolerance. If the curve approaches the surface to within tolerance, an intersection is assumed.'
          },
          {
            name: 'overlapTolerance',
            summary: 'The tolerance with which the curves are tested.'
          },
          {
            name: 'invalidIndices',
            summary: 'The indices in the resulting CurveIntersections collection that are invalid.'
          },
          {
            name: 'textLog',
            summary: 'A textlog that contains tails about the invalid intersection events.'
          }
        ],
        returns: 'A collection of intersection events.'
      },
      {
        signature: 'static bool LineBox(Line line,BoundingBox box,double tolerance,Interval lineParameters)',
        summary: 'Intersects an infinite line and an axis aligned bounding box.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line for intersection.'
          },
          {
            name: 'box',
            summary: 'BoundingBox to intersect.'
          },
          {
            name: 'tolerance',
            summary: `If tolerance > 0.0, then the intersection is performed against a box 
     that has each side moved out by tolerance.`
          },
          {
            name: 'lineParameters',
            summary: 'The chord from line.PointAt(lineParameters.T0) to line.PointAt(lineParameters.T1) is the intersection.'
          }
        ],
        returns: 'True if the line intersects the box, False if no intersection occurs.'
      },
      {
        signature: 'static bool LineBox(Line line,Box box,double tolerance,Interval lineParameters)',
        summary: 'Intersects an infinite line with a box volume.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line for intersection.'
          },
          {
            name: 'box',
            summary: 'Box to intersect.'
          },
          {
            name: 'tolerance',
            summary: `If tolerance > 0.0, then the intersection is performed against a box 
     that has each side moved out by tolerance.`
          },
          {
            name: 'lineParameters',
            summary: 'The chord from line.PointAt(lineParameters.T0) to line.PointAt(lineParameters.T1) is the intersection.'
          }
        ],
        returns: 'True if the line intersects the box, False if no intersection occurs.'
      },
      {
        signature: 'static LineCircleIntersection LineCircle(Line line,Circle circle,double t1,Point3d point1,double t2,Point3d point2)',
        summary: 'Intersects a line with a circle using exact calculations.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line for intersection.'
          },
          {
            name: 'circle',
            summary: 'Circle for intersection.'
          },
          {
            name: 't1',
            summary: 'Parameter on line for first intersection.'
          },
          {
            name: 'point1',
            summary: 'Point on circle closest to first intersection.'
          },
          {
            name: 't2',
            summary: 'Parameter on line for second intersection.'
          },
          {
            name: 'point2',
            summary: 'Point on circle closest to second intersection.'
          }
        ],
        returns: `If LineCircleIntersection.Single is returned, only t1 and point1 will have valid values. 
     If LineCircleIntersection.Multiple is returned, t2 and point2 will also be filled out.`
      },
      {
        signature: 'static LineCylinderIntersection LineCylinder(Line line,Cylinder cylinder,Point3d intersectionPoint1,Point3d intersectionPoint2)',
        summary: 'Intersects a line with a cylinder using exact calculations.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line for intersection.'
          },
          {
            name: 'cylinder',
            summary: 'Cylinder for intersection.'
          },
          {
            name: 'intersectionPoint1',
            summary: 'First intersection point.'
          },
          {
            name: 'intersectionPoint2',
            summary: 'Second intersection point.'
          }
        ],
        returns: `If None is returned, the first point is the point on the line closest
     to the cylinder and the second point is the point on the cylinder closest to
     the line. 
     If  is returned, the first point
     is the point on the line and the second point is the  same point on the
     cylinder.`
      },
      {
        signature: 'static bool LineLine(Line lineA,Line lineB,double a,double b)',
        summary: 'Finds the closest point between two infinite lines.',
        since: 5,
        parameters: [
          {
            name: 'lineA',
            summary: 'First line.'
          },
          {
            name: 'lineB',
            summary: 'Second line.'
          },
          {
            name: 'a',
            summary: `Parameter on lineA that is closest to lineB. 
     The shortest distance between the lines is the chord from lineA.PointAt(a) to lineB.PointAt(b)`
          },
          {
            name: 'b',
            summary: `Parameter on lineB that is closest to lineA. 
     The shortest distance between the lines is the chord from lineA.PointAt(a) to lineB.PointAt(b)`
          }
        ],
        returns: `True if points are found and False if the lines are numerically parallel. 
     Numerically parallel means the 2x2 matrix:
     +AoA  -AoB-AoB  +BoB
     is numerically singular, where A = (lineA.To - lineA.From) and B = (lineB.To-lineB.From)`
      },
      {
        signature: 'static bool LineLine(Line lineA,Line lineB,double a,double b,double tolerance,bool finiteSegments)',
        summary: 'Intersects two lines.',
        since: 5,
        parameters: [
          {
            name: 'lineA',
            summary: 'First line for intersection.'
          },
          {
            name: 'lineB',
            summary: 'Second line for intersection.'
          },
          {
            name: 'a',
            summary: `Parameter on lineA that is closest to LineB. 
     The shortest distance between the lines is the chord from lineA.PointAt(a) to lineB.PointAt(b)`
          },
          {
            name: 'b',
            summary: `Parameter on lineB that is closest to LineA. 
     The shortest distance between the lines is the chord from lineA.PointAt(a) to lineB.PointAt(b)`
          },
          {
            name: 'tolerance',
            summary: `If tolerance > 0.0, then an intersection is reported only if the distance between the points is <= tolerance. 
     If tolerance <= 0.0, then the closest point between the lines is reported.`
          },
          {
            name: 'finiteSegments',
            summary: `If true, the input lines are treated as finite segments. 
     If false, the input lines are treated as infinite lines.`
          }
        ],
        returns: 'True if a closest point can be calculated and the result passes the tolerance parameter test; otherwise false.'
      },
      {
        signature: 'static bool LinePlane(Line line,Plane plane,double lineParameter)',
        summary: `Intersects a line and a plane. This function only returns True if the 
     intersection result is a single point (i.e. if the line is coincident with 
     the plane then no intersection is assumed).`,
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line for intersection.'
          },
          {
            name: 'plane',
            summary: 'Plane to intersect.'
          },
          {
            name: 'lineParameter',
            summary: `Parameter on line where intersection occurs. 
     If the parameter is not within the {0, 1} Interval then the finite segment 
     does not intersect the plane.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'static LineSphereIntersection LineSphere(Line line,Sphere sphere,Point3d intersectionPoint1,Point3d intersectionPoint2)',
        summary: 'Intersects a line with a sphere using exact calculations.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line for intersection.'
          },
          {
            name: 'sphere',
            summary: 'Sphere for intersection.'
          },
          {
            name: 'intersectionPoint1',
            summary: 'First intersection point.'
          },
          {
            name: 'intersectionPoint2',
            summary: 'Second intersection point.'
          }
        ],
        returns: `If LineSphereIntersection.None is returned, the first point is the point on the line closest to the sphere and 
     the second point is the point on the sphere closest to the line. 
     If LineSphereIntersection.Single is returned, the first point is the point on the line and the second point is the 
     same point on the sphere.`
      },
      {
        signature: 'static Point3d[] MeshLine(Mesh mesh,Line line,int[] faceIds)',
        summary: 'Finds the intersection of a mesh and a line',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'A mesh to intersect'
          },
          {
            name: 'line',
            summary: 'The line to intersect with the mesh'
          },
          {
            name: 'faceIds',
            summary: 'The indices of the intersecting faces. This out reference is assigned during the call.'
          }
        ],
        returns: 'An array of points: one for each face that was passed by the faceIds out reference.'
      },
      {
        signature: 'static bool MeshMesh(IEnumerable<Mesh> meshes,double tolerance,Polyline[] intersections,bool overlapsPolylines,Polyline[] overlapsPolylinesResult,bool overlapsMesh,Mesh overlapsMeshResult,TextLog textLog,CancellationToken cancel,IProgress<double> progress)',
        summary: 'Intersects meshes. Overlaps and perforations are provided in the output list.',
        since: 7,
        parameters: [
          {
            name: 'meshes',
            summary: 'The mesh input list. This cannot be null. Null entries are tolerated.'
          },
          {
            name: 'tolerance',
            summary: `A tolerance value. If negative, the positive value will be used.
     WARNING! Good tolerance values are in the magnitude of 10^-7, or RhinoMath.SqrtEpsilon*10.`
          },
          {
            name: 'intersections',
            summary: 'Returns the intersections.'
          },
          {
            name: 'overlapsPolylines',
            summary: 'If true, overlaps are computed and returned.'
          },
          {
            name: 'overlapsPolylinesResult',
            summary: 'If requested, overlaps are returned here.'
          },
          {
            name: 'overlapsMesh',
            summary: 'If true, an overlaps mesh is computed and returned.'
          },
          {
            name: 'overlapsMeshResult',
            summary: 'If requested, overlaps are returned here.'
          },
          {
            name: 'textLog',
            summary: 'A text log, or null.'
          },
          {
            name: 'cancel',
            summary: 'A cancellation token to stop the computation at a given point.'
          },
          {
            name: 'progress',
            summary: 'A progress reporter to inform the user about progress, or null. The reported value is indicative.'
          }
        ],
        returns: 'True, if the operation succeeded, otherwise false.'
      },
      {
        signature: 'static Polyline[] MeshMeshAccurate(Mesh meshA,Mesh meshB,double tolerance)',
        summary: 'Intersects two meshes. Overlaps and near misses are handled. This is an old method kept for compatibility.',
        since: 5,
        parameters: [
          {
            name: 'meshA',
            summary: 'First mesh for intersection.'
          },
          {
            name: 'meshB',
            summary: 'Second mesh for intersection.'
          },
          {
            name: 'tolerance',
            summary: `A tolerance value. If negative, the positive value will be used.
     WARNING! Good tolerance values are in the magnitude of 10^-7, or RhinoMath.SqrtEpsilon*10.`
          }
        ],
        returns: 'An array of intersection and overlaps polylines.'
      },
      {
        signature: 'static Line[] MeshMeshFast(Mesh meshA,Mesh meshB)',
        summary: 'This is an old overload kept for compatibility. Overlaps and near misses are ignored.',
        since: 5,
        parameters: [
          {
            name: 'meshA',
            summary: 'First mesh for intersection.'
          },
          {
            name: 'meshB',
            summary: 'Second mesh for intersection.'
          }
        ],
        returns: 'An array of intersection line segments, or null.'
      },
      {
        signature: 'static Polyline[] MeshPlane(Mesh mesh,IEnumerable<Plane> planes)',
        summary: 'Intersects a mesh with a collection of (infinite) planes.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh to intersect.'
          },
          {
            name: 'planes',
            summary: 'Planes to intersect with.'
          }
        ],
        returns: 'An array of polylines describing the intersection loops or None (Nothing in Visual Basic) if no intersections could be found.'
      },
      {
        signature: 'static Polyline[] MeshPlane(Mesh mesh,Plane plane)',
        summary: 'Intersects a mesh with an (infinite) plane.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh to intersect.'
          },
          {
            name: 'plane',
            summary: 'Plane to intersect with.'
          }
        ],
        returns: 'An array of polylines describing the intersection loops or None (Nothing in Visual Basic) if no intersections could be found.'
      },
      {
        signature: 'static Point3d[] MeshPolyline(Mesh mesh,PolylineCurve curve,int[] faceIds)',
        summary: 'Finds the intersection of a mesh and a polyline.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'A mesh to intersect.'
          },
          {
            name: 'curve',
            summary: 'A polyline curves to intersect.'
          },
          {
            name: 'faceIds',
            summary: 'The indices of the intersecting faces. This out reference is assigned during the call.'
          }
        ],
        returns: 'An array of points: one for each face that was passed by the faceIds out reference.'
      },
      {
        signature: 'static double MeshRay(Mesh mesh,Ray3d ray)',
        summary: 'Finds the first intersection of a ray with a mesh.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'A mesh to intersect.'
          },
          {
            name: 'ray',
            summary: 'A ray to be casted.'
          }
        ],
        returns: `>= 0.0 parameter along ray if successful.
     < 0.0 if no intersection found.`
      },
      {
        signature: 'static double MeshRay(Mesh mesh,Ray3d ray,int[] meshFaceIndices)',
        summary: 'Finds the first intersection of a ray with a mesh.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'A mesh to intersect.'
          },
          {
            name: 'ray',
            summary: 'A ray to be casted.'
          },
          {
            name: 'meshFaceIndices',
            summary: 'faces on mesh that ray intersects.'
          }
        ],
        returns: `>= 0.0 parameter along ray if successful.
     < 0.0 if no intersection found.`
      },
      {
        signature: 'static PlaneCircleIntersection PlaneCircle(Plane plane,Circle circle,double firstCircleParameter,double secondCircleParameter)',
        summary: 'Intersects a plane with a circle using exact calculations.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane to intersect.'
          },
          {
            name: 'circle',
            summary: 'Circe to intersect.'
          },
          {
            name: 'firstCircleParameter',
            summary: 'First intersection parameter on circle if successful or RhinoMath.UnsetValue if not.'
          },
          {
            name: 'secondCircleParameter',
            summary: 'Second intersection parameter on circle if successful or RhinoMath.UnsetValue if not.'
          }
        ],
        returns: 'The type of intersection that occured.'
      },
      {
        signature: 'static bool PlanePlane(Plane planeA,Plane planeB,Line intersectionLine)',
        summary: `Intersects two planes and return the intersection line. If the planes are 
     parallel or coincident, no intersection is assumed.`,
        since: 5,
        parameters: [
          {
            name: 'planeA',
            summary: 'First plane for intersection.'
          },
          {
            name: 'planeB',
            summary: 'Second plane for intersection.'
          },
          {
            name: 'intersectionLine',
            summary: `If this function returns true, 
     the intersectionLine parameter will return the line where the planes intersect.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'static bool PlanePlanePlane(Plane planeA,Plane planeB,Plane planeC,Point3d intersectionPoint)',
        summary: 'Intersects three planes to find the single point they all share.',
        since: 5,
        parameters: [
          {
            name: 'planeA',
            summary: 'First plane for intersection.'
          },
          {
            name: 'planeB',
            summary: 'Second plane for intersection.'
          },
          {
            name: 'planeC',
            summary: 'Third plane for intersection.'
          },
          {
            name: 'intersectionPoint',
            summary: 'Point where all three planes converge.'
          }
        ],
        returns: `True on success, False on failure. If at least two out of the three planes 
     are parallel or coincident, failure is assumed.`
      },
      {
        signature: 'static PlaneSphereIntersection PlaneSphere(Plane plane,Sphere sphere,Circle intersectionCircle)',
        summary: 'Intersects a plane with a sphere using exact calculations.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane to intersect.'
          },
          {
            name: 'sphere',
            summary: 'Sphere to intersect.'
          },
          {
            name: 'intersectionCircle',
            summary: 'Intersection result.'
          }
        ],
        returns: `If PlaneSphereIntersection.None is returned, the intersectionCircle has a radius of zero and the center point 
     is the point on the plane closest to the sphere.`
      },
      {
        signature: 'static Point3d[] ProjectPointsToBreps(IEnumerable<Brep> breps,IEnumerable<Point3d> points,Vector3d direction,double tolerance)',
        summary: 'Projects points onto breps.',
        since: 5,
        parameters: [
          {
            name: 'breps',
            summary: 'The breps projection targets.'
          },
          {
            name: 'points',
            summary: 'The points to project.'
          },
          {
            name: 'direction',
            summary: 'The direction to project.'
          },
          {
            name: 'tolerance',
            summary: 'The tolerance used for intersections.'
          }
        ],
        returns: 'Array of projected points, or None in case of any error or invalid input.'
      },
      {
        signature: 'static Point3d[] ProjectPointsToBrepsEx(IEnumerable<Brep> breps,IEnumerable<Point3d> points,Vector3d direction,double tolerance,int[] indices)',
        summary: 'Projects points onto breps.',
        since: 5.1,
        parameters: [
          {
            name: 'breps',
            summary: 'The breps projection targets.'
          },
          {
            name: 'points',
            summary: 'The points to project.'
          },
          {
            name: 'direction',
            summary: 'The direction to project.'
          },
          {
            name: 'tolerance',
            summary: 'The tolerance used for intersections.'
          },
          {
            name: 'indices',
            summary: 'Return points[i] is a projection of points[indices[i]]'
          }
        ],
        returns: 'Array of projected points, or None in case of any error or invalid input.'
      },
      {
        signature: 'static Point3d[] ProjectPointsToMeshes(IEnumerable<Mesh> meshes,IEnumerable<Point3d> points,Vector3d direction,double tolerance)',
        summary: 'Projects points onto meshes.',
        since: 5,
        parameters: [
          {
            name: 'meshes',
            summary: 'the meshes to project on to.'
          },
          {
            name: 'points',
            summary: 'the points to project.'
          },
          {
            name: 'direction',
            summary: 'the direction to project.'
          },
          {
            name: 'tolerance',
            summary: 'Projection tolerances used for culling close points and for line-mesh intersection.'
          }
        ],
        returns: 'Array of projected points, or None in case of any error or invalid input.'
      },
      {
        signature: 'static Point3d[] ProjectPointsToMeshesEx(IEnumerable<Mesh> meshes,IEnumerable<Point3d> points,Vector3d direction,double tolerance,int[] indices)',
        summary: 'Projects points onto meshes.',
        since: 5.1,
        parameters: [
          {
            name: 'meshes',
            summary: 'the meshes to project on to.'
          },
          {
            name: 'points',
            summary: 'the points to project.'
          },
          {
            name: 'direction',
            summary: 'the direction to project.'
          },
          {
            name: 'tolerance',
            summary: 'Projection tolerances used for culling close points and for line-mesh intersection.'
          },
          {
            name: 'indices',
            summary: 'Return points[i] is a projection of points[indices[i]]'
          }
        ],
        returns: 'Array of projected points, or None in case of any error or invalid input.'
      },
      {
        signature: 'static Point3d[] RayShoot(Ray3d ray,IEnumerable<GeometryBase> geometry,int maxReflections)',
        summary: 'Computes point intersections that occur when shooting a ray to a collection of surfaces.',
        since: 5,
        parameters: [
          {
            name: 'ray',
            summary: 'A ray used in intersection.'
          },
          {
            name: 'geometry',
            summary: 'Only Surface and Brep objects are currently supported. Trims are ignored on Breps.'
          },
          {
            name: 'maxReflections',
            summary: 'The maximum number of reflections. This value should be any value between 1 and 1000, inclusive.'
          }
        ],
        returns: 'An array of points: one for each face that was passed by the faceIds out reference.'
      },
      {
        signature: 'static SphereSphereIntersection SphereSphere(Sphere sphereA,Sphere sphereB,Circle intersectionCircle)',
        summary: 'Intersects two spheres using exact calculations.',
        since: 5,
        parameters: [
          {
            name: 'sphereA',
            summary: 'First sphere to intersect.'
          },
          {
            name: 'sphereB',
            summary: 'Second sphere to intersect.'
          },
          {
            name: 'intersectionCircle',
            summary: 'If intersection is a point, then that point will be the center, radius 0.'
          }
        ],
        returns: 'The intersection type.'
      },
      {
        signature: 'static bool SurfaceSurface(Surface surfaceA,Surface surfaceB,double tolerance,Curve[] intersectionCurves,Point3d[] intersectionPoints)',
        summary: 'Intersects two Surfaces.',
        since: 5,
        parameters: [
          {
            name: 'surfaceA',
            summary: 'First Surface for intersection.'
          },
          {
            name: 'surfaceB',
            summary: 'Second Surface for intersection.'
          },
          {
            name: 'tolerance',
            summary: 'Intersection tolerance.'
          },
          {
            name: 'intersectionCurves',
            summary: 'The intersection curves will be returned here.'
          },
          {
            name: 'intersectionPoints',
            summary: 'The intersection points will be returned here.'
          }
        ],
        returns: 'True on success, False on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Intersect',
    name: 'IntersectionEvent',
    dataType: 1,
    summary: 'Provides all the information for a single Curve Intersection event.',
    properties: [
      {
        signature: 'bool IsOverlap',
        summary: 'All curve intersection events are either a single point or an overlap.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsPoint',
        summary: 'All curve intersection events are either a single point or an overlap.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Interval OverlapA',
        summary: `Gets the interval on curve A where the overlap occurs. 
     If the intersection type is not overlap, this value is meaningless.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Interval OverlapB',
        summary: `Gets the interval on curve B where the overlap occurs. 
     If the intersection type is not overlap, this value is meaningless.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double ParameterA',
        summary: `Gets the parameter on Curve A where the intersection occured. 
     If the intersection type is overlap, then this will return the 
     start of the overlap region.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double ParameterB',
        summary: `Gets the parameter on Curve B where the intersection occured. 
     If the intersection type is overlap, then this will return the 
     start of the overlap region.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d PointA',
        summary: `Gets the point on Curve A where the intersection occured. 
     If the intersection type is overlap, then this will return the 
     start of the overlap region.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d PointA2',
        summary: `Gets the end point of the overlap on Curve A. 
     If the intersection type is not overlap, this value is meaningless.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d PointB',
        summary: `Gets the point on Curve B (or Surface B) where the intersection occured. 
     If the intersection type is overlap, then this will return the 
     start of the overlap region.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d PointB2',
        summary: `Gets the end point of the overlap on Curve B (or Surface B). 
     If the intersection type is not overlap, this value is meaningless.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static bool CompareEquivalent(IntersectionEvent eventA,IntersectionEvent eventB,double relativePointTolerance)',
        summary: 'Compare intersection events.',
        since: 7,
        parameters: [
          {
            name: 'eventA',
            summary: 'The first intersection event to compare.'
          },
          {
            name: 'eventB',
            summary: 'The second intersection event to compare.'
          },
          {
            name: 'relativePointTolerance',
            summary: 'The comparison tolerance. If RhinoMath.UnsetValue, then RhinoMath.SqrtEpsilon is used.'
          }
        ],
        returns: 'True if the two inputs represent the same intersection, False otherwise.'
      },
      {
        signature: 'static bool CompareEquivalent(IntersectionEvent eventA,IntersectionEvent eventB,double relativePointTolerance,TextLog log)',
        summary: 'Compare intersection events.',
        since: 7,
        parameters: [
          {
            name: 'eventA',
            summary: 'The first intersection event to compare.'
          },
          {
            name: 'eventB',
            summary: 'The second intersection event to compare.'
          },
          {
            name: 'relativePointTolerance',
            summary: 'The comparison tolerance. If RhinoMath.UnsetValue, then RhinoMath.SqrtEpsilon is used.'
          },
          {
            name: 'log',
            summary: 'If not None and False is returned, then a description of the error is appended to log.'
          }
        ]
      },
      {
        signature: 'void SurfaceOverlapParameter(Interval uDomain,Interval vDomain)',
        summary: `If this instance records a Curve|Surface intersection event, 
     and the intersection type if overlap, then use this function 
     to get the U and V domains on the surface where the overlap occurs.`,
        since: 5,
        parameters: [
          {
            name: 'uDomain',
            summary: 'Domain along surface U direction for overlap event.'
          },
          {
            name: 'vDomain',
            summary: 'Domain along surface V direction for overlap event.'
          }
        ]
      },
      {
        signature: 'void SurfacePointParameter(double u,double v)',
        summary: `If this instance records a Curve|Surface intersection event, 
     and the intersection type is point, then use this function 
     to get the U and V parameters on the surface where the intersection occurs.`,
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'Parameter on surface u direction where the intersection occurs.'
          },
          {
            name: 'v',
            summary: 'Parameter on surface v direction where the intersection occurs.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Intersect',
    name: 'LineCircleIntersection',
    dataType: 3,
    summary: 'Represents all possible cases of a Line|Circle intersection event.',
    values: [
      {
        signature: 'None = 0',
        summary: 'No intersections.'
      },
      {
        signature: 'Single = 1',
        summary: 'One intersection.'
      },
      {
        signature: 'Multiple = 2',
        summary: 'Two intersections.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Intersect',
    name: 'LineCylinderIntersection',
    dataType: 3,
    summary: 'Represents all possible cases of a Line|Cylinder intersection event.',
    values: [
      {
        signature: 'None = 0',
        summary: 'No intersections.'
      },
      {
        signature: 'Single = 1',
        summary: 'One intersection.'
      },
      {
        signature: 'Multiple = 2',
        summary: 'Two intersections.'
      },
      {
        signature: 'Overlap = 3',
        summary: 'Line lies on cylinder.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Intersect',
    name: 'LineSphereIntersection',
    dataType: 3,
    summary: 'Represents all possible cases of a Line|Sphere intersection event.',
    values: [
      {
        signature: 'None = 0',
        summary: 'No intersections.'
      },
      {
        signature: 'Single = 1',
        summary: 'One intersection.'
      },
      {
        signature: 'Multiple = 2',
        summary: 'Two intersections.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Intersect',
    name: 'MeshClash',
    dataType: 1,
    summary: 'Represents a particular instance of a clash or intersection between two meshes.',
    properties: [
      {
        signature: 'Point3d ClashPoint',
        summary: `If valid, then the sphere centered at ClashPoint of ClashRadius
     distance intersects the clashing meshes.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double ClashRadius',
        summary: 'Gets the clash, or intersection, radius.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Mesh MeshA',
        summary: 'Gets the first mesh.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Mesh MeshB',
        summary: 'Gets the second mesh.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Mesh[] FindDetail(RhinoObject objA,RhinoObject objB,double distance)',
        summary: `Finds all of the mesh faces on each of two Rhino objects that interfere within a clash distance.
     This function uses the object's mesh to calculate the interferences.
     Acceptable object types include: BrepObject, ExtrusionObject, MeshObject, and SubDObject.`,
        since: 7,
        parameters: [
          {
            name: 'objA',
            summary: 'The first Rhino object.'
          },
          {
            name: 'objB',
            summary: 'The second Rhino object.'
          },
          {
            name: 'distance',
            summary: 'The largest distance at which a clash can occur.'
          }
        ],
        returns: 'The resulting meshes are sub-meshes of the input meshes if successful, or an empty array on error.'
      },
      {
        signature: 'static Mesh[] FindDetail(RhinoObject objA,RhinoObject objB,double distance,MeshType meshType,MeshingParameters meshingParameters)',
        summary: `Finds all of the mesh faces on each of two Rhino objects that interfere within a clash distance.
     This function uses the object's mesh to calculate the interferences.
     Acceptable object types include: BrepObject, ExtrusionObject, MeshObject, and SubDObject.`,
        since: 7,
        parameters: [
          {
            name: 'objA',
            summary: 'The first Rhino object.'
          },
          {
            name: 'objB',
            summary: 'The second Rhino object.'
          },
          {
            name: 'distance',
            summary: 'The largest distance at which a clash can occur.'
          },
          {
            name: 'meshType',
            summary: 'The type of mesh to be used for the calculation.'
          },
          {
            name: 'meshingParameters',
            summary: 'The meshing parameters used to generate meshes for the calculation.'
          }
        ],
        returns: 'The resulting meshes are sub-meshes of the input meshes if successful, or an empty array on error.'
      },
      {
        signature: 'static MeshClash[] Search(IEnumerable<Mesh> setA,IEnumerable<Mesh> setB,double distance,int maxEventCount)',
        summary: `Searches for locations where the distance from a mesh in one set of meshes
     is less than distance to another mesh in a second set of meshes.`,
        since: 5,
        parameters: [
          {
            name: 'setA',
            summary: 'The first set of meshes.'
          },
          {
            name: 'setB',
            summary: 'The second set of meshes.'
          },
          {
            name: 'distance',
            summary: `The largest distance at which there is a clash.
     All values smaller than this cause a clash as well.`
          },
          {
            name: 'maxEventCount',
            summary: 'The maximum number of clash objects.'
          }
        ],
        returns: 'An array of clash objects.'
      },
      {
        signature: 'static MeshInterference[] Search(IEnumerable<RhinoObject> setA,IEnumerable<RhinoObject> setB,double distance)',
        summary: `Searches for locations where the distance from a RhinoObject, in one set of objects,
     is less than the specified distance to another RhinoObject in a second set of objects.
     This function uses the object's mesh to calculate the interferences.
     Acceptable object types include: BrepObject, ExtrusionObject, MeshObject, and SubDObject.`,
        since: 7,
        parameters: [
          {
            name: 'setA',
            summary: 'The first set of Rhino objects.'
          },
          {
            name: 'setB',
            summary: 'The second set of Rhino objects.'
          },
          {
            name: 'distance',
            summary: 'The largest distance at which a clash can occur.'
          }
        ],
        returns: 'An array of mesh interference object if successful, or an empty array on failure.'
      },
      {
        signature: 'static MeshInterference[] Search(IEnumerable<RhinoObject> setA,IEnumerable<RhinoObject> setB,double distance,MeshType meshType,MeshingParameters meshingParameters)',
        summary: `Searches for locations where the distance from a RhinoObject, in one set of objects,
     is less than the specified distance to another RhinoObject in a second set of objects.
     This function uses the object's mesh to calculate the interferences.
     Acceptable object types include: BrepObject, ExtrusionObject, MeshObject, and SubDObject.`,
        since: 7,
        parameters: [
          {
            name: 'setA',
            summary: 'The first set of Rhino objects.'
          },
          {
            name: 'setB',
            summary: 'The second set of Rhino objects.'
          },
          {
            name: 'distance',
            summary: 'The largest distance at which a clash can occur.'
          },
          {
            name: 'meshType',
            summary: 'The type of mesh to be used for the calculation.'
          },
          {
            name: 'meshingParameters',
            summary: 'The meshing parameters used to generate meshes for the calculation.'
          }
        ],
        returns: 'An array of mesh interference object if successful, or an empty array on failure.'
      },
      {
        signature: 'static MeshClash[] Search(Mesh meshA,IEnumerable<Mesh> setB,double distance,int maxEventCount)',
        summary: `Searches the locations where the distance from the first mesh to a mesh in the second set of meshes
     is less than the provided value.`,
        since: 5,
        parameters: [
          {
            name: 'meshA',
            summary: 'The first mesh.'
          },
          {
            name: 'setB',
            summary: 'The second set of meshes.'
          },
          {
            name: 'distance',
            summary: `The largest distance at which there is a clash.
     All values smaller than this cause a clash as well.`
          },
          {
            name: 'maxEventCount',
            summary: 'The maximum number of clash objects.'
          }
        ],
        returns: 'An array of clash objects.'
      },
      {
        signature: 'static MeshClash[] Search(Mesh meshA,Mesh meshB,double distance,int maxEventCount)',
        summary: `Searches the locations where the distance from the first mesh to the second mesh
     is less than the provided value.`,
        since: 5,
        parameters: [
          {
            name: 'meshA',
            summary: 'The first mesh.'
          },
          {
            name: 'meshB',
            summary: 'The second mesh.'
          },
          {
            name: 'distance',
            summary: `The largest distance at which there is a clash.
     All values smaller than this cause a clash as well.`
          },
          {
            name: 'maxEventCount',
            summary: 'The maximum number of clash objects.'
          }
        ],
        returns: 'An array of clash objects.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Intersect',
    name: 'MeshInterference',
    dataType: 2,
    summary: 'Represents an element which is part of a curve region boundary.',
    properties: [
      {
        signature: 'Point3d[] HitPoints',
        summary: 'Array of hit points where the objects of IndexA and IndexB interfere.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'int IndexA',
        summary: 'The index of the first clashing, or interfering object.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'int IndexB',
        summary: 'The index of the second clashing, or interfering object.',
        since: 7,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Intersect',
    name: 'PlaneCircleIntersection',
    dataType: 3,
    summary: 'Represents all possible cases of a Plane|Circle intersection event.',
    values: [
      {
        signature: 'None = 0',
        summary: 'No intersections. Either because radius is too small or because circle plane is parallel but not coincident with the intersection plane.'
      },
      {
        signature: 'Tangent = 1',
        summary: 'Tangent (one point) intersection.'
      },
      {
        signature: 'Secant = 2',
        summary: 'Secant (two point) intersection.'
      },
      {
        signature: 'Parallel = 3',
        summary: `Circle and plane are planar but not coincident. 
     Parallel indicates no intersection took place.`
      },
      {
        signature: 'Coincident = 4',
        summary: 'Circle and plane are co-planar, they intersect everywhere.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Intersect',
    name: 'PlaneSphereIntersection',
    dataType: 3,
    summary: 'Represents all possible cases of a Plane|Sphere intersection event.',
    values: [
      {
        signature: 'None = 0',
        summary: 'No intersections.'
      },
      {
        signature: 'Point = 1',
        summary: 'Tangent intersection.'
      },
      {
        signature: 'Circle = 2',
        summary: 'Circular intersection.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Intersect',
    name: 'SphereSphereIntersection',
    dataType: 3,
    summary: 'Represents all possible cases of a Sphere|Sphere intersection event.',
    values: [
      {
        signature: 'None = 0',
        summary: 'Spheres do not intersect.'
      },
      {
        signature: 'Point = 1',
        summary: 'Spheres touch at a single point.'
      },
      {
        signature: 'Circle = 2',
        summary: 'Spheres intersect at a circle.'
      },
      {
        signature: 'Overlap = 3',
        summary: 'Spheres are identical.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Interval',
    dataType: 2,
    summary: `Represents an interval in one-dimensional space,
   that is defined as two extrema or bounds.`,
    constructors: [
      {
        signature: 'Interval(double t0,double t1)',
        summary: 'Initializes a new instance of the Rhino.Geometry.Interval class.',
        since: 5,
        parameters: [
          {
            name: 't0',
            summary: 'The first value.'
          },
          {
            name: 't1',
            summary: 'The second value.'
          }
        ]
      },
      {
        signature: 'Interval(Interval other)',
        summary: 'Initializes a new instance copying the other instance values.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The Rhino.Geometry.Interval to use as a base.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Interval Unset',
        summary: 'Gets an Interval whose limits are RhinoMath.UnsetValue.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsDecreasing',
        summary: 'Returns True if T[0] > T[1].',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsIncreasing',
        summary: 'Returns True if T0 < T1.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsSingleton',
        summary: 'Returns True if T0 == T1 != ON.UnsetValue.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: `Gets a value indicating whether or not this Interval is valid. 
     Valid intervals must contain valid numbers.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Length',
        summary: `Gets the signed length of the numeric range. 
     If the interval is decreasing, a negative length will be returned.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Max',
        summary: 'Gets the larger of T0 and T1.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Mid',
        summary: 'Gets the average of T0 and T1.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Min',
        summary: 'Gets the smaller of T0 and T1.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double T0',
        summary: 'Gets or sets the lower bound of the Interval.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double T1',
        summary: 'Gets or sets the upper bound of the Interval.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Interval FromIntersection(Interval a,Interval b)',
        summary: 'Returns a new Interval that is the Intersection of the two input Intervals.',
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'The first input interval.'
          },
          {
            name: 'b',
            summary: 'The second input interval.'
          }
        ],
        returns: `If the intersection is not empty, then 
     intersection = [max(a.Min(),b.Min()), min(a.Max(),b.Max())]
     The interval [ON.UnsetValue,ON.UnsetValue] is considered to be
     the empty set interval.  The result of any intersection involving an
     empty set interval or disjoint intervals is the empty set interval.`
      },
      {
        signature: 'static Interval FromUnion(Interval a,Interval b)',
        summary: 'Returns a new Interval which contains both inputs.',
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'The first input interval.'
          },
          {
            name: 'b',
            summary: 'The second input interval.'
          }
        ],
        returns: `The union of an empty set and an increasing interval is the increasing interval.
     The union of two empty sets is empty.The union of an empty set an a non-empty interval is the non-empty interval.The union of two non-empty intervals is [min(a.Min(),b.Min()), max(a.Max(),b.Max())]`
      },
      {
        signature: 'int CompareTo(Interval other)',
        summary: `Compares this Interval with another interval.
     The lower bound has first evaluation priority.`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The other Interval to compare with.'
          }
        ],
        returns: '0: if this is identical to other-1: if this[0] < other[0]+1: if this[0] > other[0]-1: if this[0] == other[0] and this[1] < other[1]+1: if this[0] == other[0] and this[1] > other[1].'
      },
      {
        signature: 'bool EpsilonEquals(Interval other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(Interval other)',
        summary: `Determines whether the specified Interval is equal to the current Interval,
     comparing by value.`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The other interval to compare with.'
          }
        ],
        returns: 'True if obj is an Interval and has the same bounds; False otherwise.'
      },
      {
        signature: 'bool Equals(object obj)',
        summary: `Determines whether the specified object is equal to the current Interval,
     comparing by value.`,
        parameters: [
          {
            name: 'obj',
            summary: 'The other object to compare with.'
          }
        ],
        returns: 'True if obj is an Interval and has the same bounds; False otherwise.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Computes the hash code for this Interval object.',
        returns: 'A hash value that might be equal for two different Interval values.'
      },
      {
        signature: 'void Grow(double value)',
        summary: 'Grows the Interval to include the given number.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'Number to include in this interval.'
          }
        ]
      },
      {
        signature: 'bool IncludesInterval(Interval interval)',
        summary: 'Tests another interval for Interval inclusion.',
        since: 5,
        parameters: [
          {
            name: 'interval',
            summary: 'Interval to test.'
          }
        ],
        returns: 'True if the other interval is contained within or is coincident with the limits of this Interval; otherwise false.'
      },
      {
        signature: 'bool IncludesInterval(Interval interval,bool strict)',
        summary: 'Tests another interval for Interval inclusion.',
        since: 5,
        parameters: [
          {
            name: 'interval',
            summary: 'Interval to test.'
          },
          {
            name: 'strict',
            summary: 'If true, the other interval must be fully on the inside of the Interval.'
          }
        ],
        returns: 'True if the other interval is contained within the limits of this Interval; otherwise false.'
      },
      {
        signature: 'bool IncludesParameter(double t)',
        summary: 'Tests a parameter for Interval inclusion.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Parameter to test.'
          }
        ],
        returns: 'True if t is contained within or is coincident with the limits of this Interval.'
      },
      {
        signature: 'bool IncludesParameter(double t,bool strict)',
        summary: 'Tests a parameter for Interval inclusion.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Parameter to test.'
          },
          {
            name: 'strict',
            summary: 'If true, the parameter must be fully on the inside of the Interval.'
          }
        ],
        returns: 'True if t is contained within the limits of this Interval.'
      },
      {
        signature: 'void MakeIncreasing()',
        summary: 'Ensures this Interval is either singleton or increasing.',
        since: 5
      },
      {
        signature: 'Interval NormalizedIntervalAt(Interval intervalParameter)',
        summary: 'Converts interval value, or pair of values, to normalized parameter.',
        since: 5,
        returns: 'Normalized parameter x so that min*(1.0-x) + max*x = intervalParameter.'
      },
      {
        signature: 'double NormalizedParameterAt(double intervalParameter)',
        summary: 'Converts interval value, or pair of values, to normalized parameter.',
        since: 5,
        returns: 'Normalized parameter x so that min*(1.0-x) + max*x = intervalParameter.'
      },
      {
        signature: 'double ParameterAt(double normalizedParameter)',
        summary: 'Converts normalized parameter to interval value, or pair of values.',
        since: 5,
        returns: 'Interval parameter min*(1.0-normalizedParameter) + max*normalizedParameter.'
      },
      {
        signature: 'Interval ParameterIntervalAt(Interval normalizedInterval)',
        summary: 'Converts normalized parameter to interval value, or pair of values.',
        since: 5,
        returns: 'Interval parameter min*(1.0-normalizedParameter) + max*normalized_paramete.'
      },
      {
        signature: 'void Reverse()',
        summary: 'Changes interval to [-T1, -T0].',
        since: 5
      },
      {
        signature: 'void Swap()',
        summary: 'Exchanges T0 and T1.',
        since: 5
      },
      {
        signature: 'string ToString()',
        summary: 'Returns a string representation of this Interval.',
        returns: 'A string with T0,T1.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'InvalidDimensionStyleIdException',
    dataType: 1,
    summary: 'General exception that can be thrown by annotations',
    baseclass: 'InvalidOperationException',
    constructors: [
      {
        signature: 'InvalidDimensionStyleIdException(string msg)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'IsoStatus',
    dataType: 3,
    summary: `Defines enumerated values for isoparametric curve direction on a surface, such as X or Y,
   and curve sides, such as North or West boundary.
   Note: odd values are all x-constant; even values > 0 are all y-constant.`,
    values: [
      {
        signature: 'None = 0',
        summary: 'curve is not an isoparameteric curve.'
      },
      {
        signature: 'X = 1',
        summary: 'curve is a "x" = constant (vertical) isoparametric curve in the interior of the surface\'s domain.'
      },
      {
        signature: 'Y = 2',
        summary: 'curve is a "y" = constant (horizontal) isoparametric curve in the interior of the surface\'s domain.'
      },
      {
        signature: 'West = 3',
        summary: 'curve is a "x" = constant isoparametric curve along the west side of the surface\'s domain.'
      },
      {
        signature: 'South = 4',
        summary: 'curve is a "y" = constant isoparametric curve along the south side of the surface\'s domain.'
      },
      {
        signature: 'East = 5',
        summary: 'curve is a "x" = constant isoparametric curve along the east side of the surface\'s domain.'
      },
      {
        signature: 'North = 6',
        summary: 'curve is a "y" = constant isoparametric curve along the north side of the surface\'s domain.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Leader',
    dataType: 1,
    summary: 'Leader geometry class',
    baseclass: 'Rhino.Geometry.AnnotationBase',
    constructors: [
      {
        signature: 'Leader()',
        summary: 'Constructor',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'NurbsCurve Curve',
        summary: 'Gets the curve used by this leader',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid LeaderArrowBlockId',
        summary: 'Id of the block used as the arrow for the leader when the arrow type is \'User arrow\'',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double LeaderArrowSize',
        summary: 'The size of the leader arrow',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ArrowType LeaderArrowType',
        summary: 'The arrowhead type for the leader',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'LeaderContentAngleStyle LeaderContentAngleStyle',
        summary: 'Angle for text of leader text',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'LeaderCurveStyle LeaderCurveStyle',
        summary: 'The style of the leader curve: polyline or spline',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool LeaderHasLanding',
        summary: 'Returns True if the leader has a landing line',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double LeaderLandingLength',
        summary: 'Gets or sets the length of the landing line',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'TextHorizontalAlignment LeaderTextHorizontalAlignment',
        summary: 'Gets or sets the horizontal alignment of the leader\'s text',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'TextVerticalAlignment LeaderTextVerticalAlignment',
        summary: 'Gets or sets the vertical alignment of the leader\'s text',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Point2d[] Points2D',
        summary: 'Get or set the 2d points defining the curve used by this leader',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d[] Points3D',
        summary: 'Get or set the 3d points defining the curve used by this leader',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Leader Create(string text,Plane plane,DimensionStyle dimstyle,Point3d[] points)',
        summary: 'Creates a Leader geometry object',
        since: 6
      },
      {
        signature: 'static Leader CreateWithRichText(string richText,Plane plane,DimensionStyle dimstyle,Point3d[] points)',
        summary: 'Creates a Leader geometry object',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Light',
    dataType: 1,
    summary: 'Represents a light that shines in the modeling space.',
    baseclass: 'Rhino.Geometry.GeometryBase',
    constructors: [
      {
        signature: 'Light()',
        summary: 'Initializes a new light.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'Color Ambient',
        summary: 'Gets or sets the ambient color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Attenuation AttenuationType',
        summary: 'Get the type of attenuation for this light.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d AttenuationVector',
        summary: 'Gets or Sets the attenuation vector.',
        since: 5.7,
        property: ['get', 'set']
      },
      {
        signature: 'CoordinateSystem CoordinateSystem',
        summary: `Gets a value, determined by LightStyle, that explains whether
     the camera directions are relative to World or Camera spaces.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Color Diffuse',
        summary: 'Gets or sets the diffuse color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d Direction',
        summary: 'Gets or sets the vector direction of the camera.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double HotSpot',
        summary: `The hot spot setting runs from 0.0 to 1.0 and is used to
     provides a linear interface for controling the focus or 
     concentration of a spotlight.
     A hot spot setting of 0.0 corresponds to a spot exponent of 128.
     A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Guid Id',
        summary: 'Gets the ID of this light.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double Intensity',
        summary: 'Gets or sets the light intensity.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsDirectionalLight',
        summary: `Gets a value indicating whether the light style
     is LightStyle CameraDirectional or WorldDirectional.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsEnabled',
        summary: 'Gets or sets a value that defines if the light is turned on (true) or off (false).',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsLinearLight',
        summary: `Gets a value indicating whether the light style
     is LightStyle WorldLinear.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsPointLight',
        summary: `Gets a value indicating whether the light style
     is LightStyle CameraPoint or WorldPoint.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsRectangularLight',
        summary: `Gets a value indicating whether the light style
     is LightStyle WorldRectangular.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsSpotLight',
        summary: `Gets a value indicating whether the light style
     is LightStyle CameraSpot or WorldSpot.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsSunLight',
        summary: 'Gets a value indicating whether this object is a Sun light.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d Length',
        summary: `Gets or sets the height in linear and rectangular lights.
     (ignored for non-linear/rectangular lights.)`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'LightStyle LightStyle',
        summary: 'Gets or sets a light style on this camera.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d Location',
        summary: 'Gets or sets the light or 3D position or location.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Name',
        summary: 'Gets or sets the spot light name.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d PerpendicularDirection',
        summary: 'Gets a perpendicular vector to the camera direction.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double PowerCandela',
        summary: 'Gets or sets the light power in candelas (cd).',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PowerLumens',
        summary: 'Gets or sets the light power in lumens (lm).',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PowerWatts',
        summary: 'Gets or sets the light power in watts (W).',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double ShadowIntensity',
        summary: 'Gets or sets the shadow intensity for the light.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Color Specular',
        summary: 'Gets or sets the specular color.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double SpotAngleRadians',
        summary: `Gets or sets the spot angle in radians.
     Ignored for non-spot lights.angle = 0 to pi/2  (0 to 90 degrees).`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double SpotExponent',
        summary: `The spot exponent varies from 0.0 to 128.0 and provides
     an exponential interface for controling the focus or 
     concentration of a spotlight (like the 
     OpenGL GL_SPOT_EXPONENT parameter).  The spot exponent
     and hot spot parameters are linked; changing one will
     change the other.
     A hot spot setting of 0.0 corresponds to a spot exponent of 128.
     A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double SpotLightShadowIntensity',
        summary: `Gets or sets the spot light shadow intensity.
     (ignored for non-spot lights.)`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d Width',
        summary: `Gets or sets the width in linear and rectangular lights.
     (ignored for non-linear/rectangular lights.)`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Light CreateSunLight(double northAngleDegrees,DateTime when,double latitudeDegrees,double longitudeDegrees)',
        summary: 'Constructs a light which simulates the Sun based on a given time and location on Earth.',
        since: 5,
        parameters: [
          {
            name: 'northAngleDegrees',
            summary: 'The angle of North in degrees. North is the angle between positive World Y axis and model North, as measured on World XY plane.'
          },
          {
            name: 'when',
            summary: `The time of the measurement. The Kind property of DateTime specifies whether this is in local or universal time.
     Local and Undefined daytime kinds in this argument are considered local.`
          },
          {
            name: 'latitudeDegrees',
            summary: 'The latitude, in degrees, of the location on Earth.'
          },
          {
            name: 'longitudeDegrees',
            summary: 'The longitude, in degrees, of the location on Earth.'
          }
        ],
        returns: 'A newly constructed light object.'
      },
      {
        signature: 'static Light CreateSunLight(double northAngleDegrees,double azimuthDegrees,double altitudeDegrees)',
        summary: 'Constructs a light that represents the Sun.',
        since: 5,
        parameters: [
          {
            name: 'northAngleDegrees',
            summary: 'The angle of North in degrees. North is the angle between positive World Y axis and model North, as measured on World XY plane.'
          },
          {
            name: 'azimuthDegrees',
            summary: 'The Azimuth angle value in degrees. Azimuth is the compass angle from North.'
          },
          {
            name: 'altitudeDegrees',
            summary: 'The Altitude angle in degrees. Altitude is the angle above the ground plane.'
          }
        ],
        returns: 'A new sun light.'
      },
      {
        signature: 'static Light CreateSunLight(Sun sun)',
        summary: 'Constructs a light which simulates a Rhino.Render.Sun.',
        since: 5,
        parameters: [
          {
            name: 'sun',
            summary: 'A Sun object from the Rhino.Render namespace.'
          }
        ],
        returns: 'A light.'
      },
      {
        signature: 'double GetAttenuation(double d)',
        summary: `Gets the attenuation settings (ignored for "directional" and "ambient" lights).
     attenuation = 1/(a0 + d*a1 + d^2*a2) where d = distance to light.`,
        since: 5,
        parameters: [
          {
            name: 'd',
            summary: 'The distance to evaluate.'
          }
        ],
        returns: '0 if a0 + d*a1 + d^2*a2 <= 0.'
      },
      {
        signature: 'bool GetSpotLightRadii(double innerRadius,double outerRadius)',
        summary: 'Gets the spot light radii.',
        since: 5,
        parameters: [
          {
            name: 'innerRadius',
            summary: 'The inner radius. This out parameter is assigned during this call.'
          },
          {
            name: 'outerRadius',
            summary: 'The outer radius. This out parameter is assigned during this call.'
          }
        ],
        returns: 'True if operation succeeded; otherwise, false.'
      },
      {
        signature: 'void SetAttenuation(double a0,double a1,double a2)',
        summary: `Sets the attenuation settings (ignored for "directional" and "ambient" lights).
     attenuation = 1/(a0 + d*a1 + d^2*a2) where d = distance to light.`,
        since: 5,
        parameters: [
          {
            name: 'a0',
            summary: 'The new constant attenuation divisor term.'
          },
          {
            name: 'a1',
            summary: 'The new reverse linear attenuation divisor term.'
          },
          {
            name: 'a2',
            summary: 'The new reverse quadratic attenuation divisor term.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Light.Attenuation',
    dataType: 3,
    summary: 'Types of light attenuation available.',
    values: [
      {
        signature: 'Constant',
        summary: 'Constant light attenuation, meaning no light energy fall-off.'
      },
      {
        signature: 'Linear',
        summary: 'Linear light attenuation, meaning linear light energy fall-off.'
      },
      {
        signature: 'InverseSquared',
        summary: 'Inverse squared light attenuation, meaning light energy falls off in spherical order.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'LightStyle',
    dataType: 3,
    summary: 'Defines enumerated values to represent light styles or types, such as directional or spotlight.',
    values: [
      {
        signature: 'None = 0',
        summary: 'No light type. This is the default value of the enumeration type.'
      },
      {
        signature: 'CameraDirectional = 4',
        summary: `Light location and direction in camera coordinates.
     +x points to right, +y points up, +z points towards camera.`
      },
      {
        signature: 'CameraPoint = 5',
        summary: `Light location and direction in camera coordinates.
     +x points to right, +y points up, +z points towards camera.`
      },
      {
        signature: 'CameraSpot = 6',
        summary: `Light location and direction in camera coordinates.
     +x points to right, +y points up, +z points towards camera.`
      },
      {
        signature: 'WorldDirectional = 7',
        summary: 'Light location and direction in world coordinates.'
      },
      {
        signature: 'WorldPoint = 8',
        summary: 'Light location and direction in world coordinates.'
      },
      {
        signature: 'WorldSpot = 9',
        summary: 'Light location and direction in world coordinates.'
      },
      {
        signature: 'Ambient = 10',
        summary: 'Ambient light.'
      },
      {
        signature: 'WorldLinear = 11',
        summary: 'Linear light in world coordinates.'
      },
      {
        signature: 'WorldRectangular = 12',
        summary: 'Rectangular light in world coordinates.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Line',
    dataType: 2,
    summary: 'Represents the value of start and end points in a single line segment.',
    constructors: [
      {
        signature: 'Line(double x0,double y0,double z0,double x1,double y1,double z1)',
        summary: 'Constructs a new line segment between two points.',
        since: 5,
        parameters: [
          {
            name: 'x0',
            summary: 'The X coordinate of the first point.'
          },
          {
            name: 'y0',
            summary: 'The Y coordinate of the first point.'
          },
          {
            name: 'z0',
            summary: 'The Z coordinate of the first point.'
          },
          {
            name: 'x1',
            summary: 'The X coordinate of the second point.'
          },
          {
            name: 'y1',
            summary: 'The Y coordinate of the second point.'
          },
          {
            name: 'z1',
            summary: 'The Z coordinate of the second point.'
          }
        ]
      },
      {
        signature: 'Line(Point3d from,Point3d to)',
        summary: 'Constructs a new line segment between two points.',
        since: 5,
        parameters: [
          {
            name: 'from',
            summary: 'Start point of line.'
          },
          {
            name: 'to',
            summary: 'End point of line.'
          }
        ]
      },
      {
        signature: 'Line(Point3d start,Vector3d span)',
        summary: 'Constructs a new line segment from start point and span vector.',
        since: 5,
        parameters: [
          {
            name: 'start',
            summary: 'Start point of line segment.'
          },
          {
            name: 'span',
            summary: 'Direction and length of line segment.'
          }
        ]
      },
      {
        signature: 'Line(Point3d start,Vector3d direction,double length)',
        summary: 'Constructs a new line segment from start point, direction and length.',
        since: 5,
        parameters: [
          {
            name: 'start',
            summary: 'Start point of line segment.'
          },
          {
            name: 'direction',
            summary: 'Direction of line segment.'
          },
          {
            name: 'length',
            summary: 'Length of line segment.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Line Unset',
        summary: 'Gets a line segment which has Point3d.Unset end points.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BoundingBox BoundingBox',
        summary: 'Gets the line\'s 3d axis aligned bounding box.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d Direction',
        summary: `Gets the direction of this line segment. 
     The length of the direction vector equals the length of 
     the line segment.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d From',
        summary: 'Start point of line segment.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double FromX',
        summary: 'Gets or sets the X coordinate of the line From point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double FromY',
        summary: 'Gets or sets the Y coordinate of the line From point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double FromZ',
        summary: 'Gets or sets the Z coordinate of the line From point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsValid',
        summary: `Gets a value indicating whether or not this line is valid. 
     Valid lines must have valid start and end points.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Length',
        summary: `Gets or sets the length of this line segment. 
     Note that a negative length will invert the line segment without 
     making the actual length negative. The line From point will remain fixed 
     when a new Length is set.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d To',
        summary: 'End point of line segment.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double ToX',
        summary: 'Gets or sets the X coordinate of the line To point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double ToY',
        summary: 'Gets or sets the Y coordinate of the line To point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double ToZ',
        summary: 'Gets or sets the Z coordinate of the line To point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d UnitTangent',
        summary: `Gets the tangent of the line segment. 
     Note that tangent vectors are always unit vectors.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static bool TryCreateBetweenCurves(Curve curve0,Curve curve1,double t0,double t1,bool perpendicular0,bool perpendicular1,Line line)',
        summary: 'Creates a line segment between a pair of curves such that the line segment is either tangent or perpendicular to each of the curves.',
        since: 5.2,
        parameters: [
          {
            name: 'curve0',
            summary: 'The first curve.'
          },
          {
            name: 'curve1',
            summary: 'The second curve.'
          },
          {
            name: 't0',
            summary: 'Parameter value of point on curve0. Seed value at input and solution at output.'
          },
          {
            name: 't1',
            summary: 'Parameter value of point on curve 0.  Seed value at input and solution at output.'
          },
          {
            name: 'perpendicular0',
            summary: 'Find line Perpendicuar to (true) or tangent to (false) curve0.'
          },
          {
            name: 'perpendicular1',
            summary: 'Find line Perpendicuar to (true) or tangent to (false) curve1.'
          },
          {
            name: 'line',
            summary: 'The line segment if successful.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'static bool TryFitLineToPoints(IEnumerable<Point3d> points,Line fitLine)',
        summary: 'Attempt to fit a line through a set of points.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'The points through which to fit.'
          },
          {
            name: 'fitLine',
            summary: 'The resulting line on success.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'double ClosestParameter(Point3d testPoint)',
        summary: 'Finds the parameter on the infinite line segment that is closest to a test point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to project onto the line.'
          }
        ],
        returns: 'The parameter on the line that is closest to testPoint.'
      },
      {
        signature: 'Point3d ClosestPoint(Point3d testPoint,bool limitToFiniteSegment)',
        summary: 'Finds the point on the (in)finite line segment that is closest to a test point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to project onto the line.'
          },
          {
            name: 'limitToFiniteSegment',
            summary: 'If true, the projection is limited to the finite line segment.'
          }
        ],
        returns: 'The point on the (in)finite line that is closest to testPoint.'
      },
      {
        signature: 'double DistanceTo(Point3d testPoint,bool limitToFiniteSegment)',
        summary: 'Compute the shortest distance between this line segment and a test point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point for distance computation.'
          },
          {
            name: 'limitToFiniteSegment',
            summary: 'If true, the distance is limited to the finite line segment.'
          }
        ],
        returns: 'The shortest distance between this line segment and testPoint.'
      },
      {
        signature: 'bool EpsilonEquals(Line other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(Line other)',
        summary: 'Determines whether a line has the same value as this line.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'A line.'
          }
        ],
        returns: 'True if other has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines whether an object is a line that has the same value as this line.',
        parameters: [
          {
            name: 'obj',
            summary: 'An object.'
          }
        ],
        returns: 'True if obj is a Line and has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'bool Extend(double startLength,double endLength)',
        summary: 'Extend the line by custom distances on both sides.',
        since: 5,
        parameters: [
          {
            name: 'startLength',
            summary: `Distance to extend the line at the start point. 
     Positive distance result in longer lines.`
          },
          {
            name: 'endLength',
            summary: `Distance to extend the line at the end point. 
     Positive distance result in longer lines.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool ExtendThroughBox(BoundingBox box)',
        summary: `Ensure the line extends all the way through a box. 
     Note, this does not result in the shortest possible line 
     that overlaps the box.`,
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to extend through.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool ExtendThroughBox(BoundingBox box,double additionalLength)',
        summary: `Ensure the line extends all the way through a box. 
     Note, this does not result in the shortest possible line that overlaps the box.`,
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to extend through.'
          },
          {
            name: 'additionalLength',
            summary: 'Additional length to append at both sides of the line.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool ExtendThroughBox(Box box)',
        summary: `Ensure the line extends all the way through a box. 
     Note, this does not result in the shortest possible line that overlaps the box.`,
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to extend through.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool ExtendThroughBox(Box box,double additionalLength)',
        summary: `Ensure the line extends all the way through a box. 
     Note, this does not result in the shortest possible line that overlaps the box.`,
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'Box to extend through.'
          },
          {
            name: 'additionalLength',
            summary: 'Additional length to append at both sides of the line.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'void Flip()',
        summary: 'Flip the endpoints of the line segment.',
        since: 5
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Computes a hash number that represents this line.',
        returns: 'A number that is not unique to the value of this line.'
      },
      {
        signature: 'double MaximumDistanceTo(Line testLine)',
        summary: `Finds the largest distance between this line as a finite segment
     and another finite segment.`,
        since: 5,
        parameters: [
          {
            name: 'testLine',
            summary: 'A line to test.'
          }
        ],
        returns: 'The maximum distance.'
      },
      {
        signature: 'double MaximumDistanceTo(Point3d testPoint)',
        summary: `Finds the largest distance between this line as a finite segment
     and a test point.`,
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'A point to test.'
          }
        ],
        returns: 'The maximum distance.'
      },
      {
        signature: 'double MinimumDistanceTo(Line testLine)',
        summary: `Finds the shortest distance between this line as a finite segment
     and another finite segment.`,
        since: 5,
        parameters: [
          {
            name: 'testLine',
            summary: 'A line to test.'
          }
        ],
        returns: 'The minimum distance.'
      },
      {
        signature: 'double MinimumDistanceTo(Point3d testPoint)',
        summary: `Finds the shortest distance between this line as a finite segment
     and a test point.`,
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'A point to test.'
          }
        ],
        returns: 'The minimum distance.'
      },
      {
        signature: 'Point3d PointAt(double t)',
        summary: 'Evaluates the line at the specified parameter.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Parameter to evaluate line segment at. Line parameters are normalised parameters.'
          }
        ],
        returns: 'The point at the specified parameter.'
      },
      {
        signature: 'Point3d PointAtLength(double distance)',
        summary: `Computes a point located at a specific metric distance from the line origin (From).
     If line start and end coincide, then the start point is always returned.`,
        since: 6,
        parameters: [
          {
            name: 'distance',
            summary: 'A positive, 0, or a negative value that will be the distance from From.'
          }
        ],
        returns: 'The newly found point.'
      },
      {
        signature: 'NurbsCurve ToNurbsCurve()',
        summary: `Constructs a nurbs curve representation of this line. 
     This amounts to the same as calling NurbsCurve.CreateFromLine().`,
        since: 5,
        returns: 'A nurbs curve representation of this line or None if no such representation could be made.'
      },
      {
        signature: 'string ToString()',
        summary: 'Constructs the string representation of this line, in the form "From,To".',
        returns: 'A text string.'
      },
      {
        signature: 'string ToString(string format,IFormatProvider formatProvider)',
        since: 7
      },
      {
        signature: 'bool Transform(Transform xform)',
        summary: 'Transform the line using a Transformation matrix.',
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'Transform to apply to this line.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool TryGetPlane(Plane plane)',
        summary: `Gets a plane that contains the line. The origin of the plane is at the start of the line.
     If possible, a plane parallel to the world xy, yz, or zx plane is returned.`,
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'If the return value is true, the plane out parameter is assigned during this call.'
          }
        ],
        returns: 'True on success.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'LinearDimension',
    dataType: 1,
    summary: 'Represents a linear dimension',
    baseclass: 'Dimension',
    constructors: [
      {
        signature: 'LinearDimension()',
        since: 5
      },
      {
        signature: 'LinearDimension(Plane dimensionPlane,Point2d extensionLine1End,Point2d extensionLine2End,Point2d pointOnDimensionLine)',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'bool Aligned',
        summary: 'Gets or sets a value indicating whether this annotation is aligned.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'AnnotationType AnnotationType',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Point2d Arrowhead1End',
        summary: 'Gets the arrow head end of the first extension line.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point2d Arrowhead2End',
        summary: 'Gets the arrow head end of the second extension line.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point2d DimensionLinePoint',
        summary: 'Point on annotation plane where dimension line starts',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double DistanceBetweenArrowTips',
        summary: 'Gets the distance between arrow tips.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point2d ExtensionLine1End',
        summary: 'End of the first extension line.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point2d ExtensionLine2End',
        summary: 'End of the second extension line.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static LinearDimension Create(AnnotationType dimtype,DimensionStyle dimStyle,Plane plane,Vector3d horizontal,Point3d defpoint1,Point3d defpoint2,Point3d dimlinepoint,double rotationInPlane)',
        summary: 'Initialize Dimension parameters',
        since: 6,
        parameters: [
          {
            name: 'dimtype',
            summary: 'AnnotationType.Rotated or AnnotationType.Aligned'
          },
          {
            name: 'dimStyle',
            summary: 'Dimension\'s DimensionStyle'
          },
          {
            name: 'plane',
            summary: 'Dimension\'s plane'
          },
          {
            name: 'horizontal',
            summary: 'Horizontal reference direction'
          },
          {
            name: 'defpoint1',
            summary: 'First definition point'
          },
          {
            name: 'defpoint2',
            summary: 'Second definition point'
          },
          {
            name: 'dimlinepoint',
            summary: 'Point on dimension line'
          },
          {
            name: 'rotationInPlane',
            summary: 'For Rotated style'
          }
        ]
      },
      {
        signature: 'static LinearDimension FromPoints(Point3d extensionLine1End,Point3d extensionLine2End,Point3d pointOnDimensionLine)',
        summary: 'Initializes a new instance of the LinearDimension class, based on three points.',
        since: 5
      },
      {
        signature: 'bool Get3dPoints(Point3d extensionLine1End,Point3d extensionLine2End,Point3d arrowhead1End,Point3d arrowhead2End,Point3d dimlinepoint,Point3d textpoint)',
        summary: 'Get locations of dimension\'s 3d points',
        since: 6,
        parameters: [
          {
            name: 'extensionLine1End',
            summary: 'First definition point'
          },
          {
            name: 'extensionLine2End',
            summary: 'Second definition point'
          },
          {
            name: 'arrowhead1End',
            summary: 'First arrowhead point'
          },
          {
            name: 'arrowhead2End',
            summary: 'Second Arrowhead point'
          },
          {
            name: 'dimlinepoint',
            summary: 'Point on dimension line'
          },
          {
            name: 'textpoint',
            summary: 'Text location'
          }
        ],
        returns: 'True = success'
      },
      {
        signature: 'bool GetDisplayLines(DimensionStyle style,double scale,IEnumerable<Line> lines)'
      },
      {
        signature: 'string GetDistanceDisplayText(UnitSystem unitsystem,DimensionStyle style)',
        since: 6
      },
      {
        signature: 'bool GetTextRectangle(Point3d[] corners)',
        since: 6
      },
      {
        signature: 'void SetLocations(Point2d extensionLine1End,Point2d extensionLine2End,Point2d pointOnDimensionLine)',
        summary: `Sets the three locations of the point, using two-dimensional points
     that refer to the plane of the annotation.`,
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'LineCurve',
    dataType: 1,
    summary: 'Represents a linear curve.',
    baseclass: 'Rhino.Geometry.Curve',
    constructors: [
      {
        signature: 'LineCurve()',
        summary: 'Initializes a new instance of the LineCurve class.',
        since: 5
      },
      {
        signature: 'LineCurve(Line line)',
        summary: `Initializes a new instance of the LineCurve class, by
     retrieving its value from a Line.`,
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'A line to use as model.'
          }
        ]
      },
      {
        signature: 'LineCurve(Line line,double t0,double t1)',
        summary: `Initializes a new instance of the LineCurve class, by
     retrieving its value from a Line and setting the domain.`,
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'A line to use as model.'
          },
          {
            name: 't0',
            summary: 'The new domain start.'
          },
          {
            name: 't1',
            summary: 'The new domain end.'
          }
        ]
      },
      {
        signature: 'LineCurve(LineCurve other)',
        summary: `Initializes a new instance of the LineCurve class, by
     copying values from another linear curve.`,
        since: 5
      },
      {
        signature: 'LineCurve(Point2d from,Point2d to)',
        summary: `Initializes a new instance of the LineCurve class, by
     setting start and end point from two Point2d.`,
        since: 5,
        parameters: [
          {
            name: 'from',
            summary: 'A start point.'
          },
          {
            name: 'to',
            summary: 'An end point.'
          }
        ]
      },
      {
        signature: 'LineCurve(Point3d from,Point3d to)',
        summary: `Initializes a new instance of the LineCurve class, by
     setting start and end point from two Point3d.`,
        since: 5,
        parameters: [
          {
            name: 'from',
            summary: 'A start point.'
          },
          {
            name: 'to',
            summary: 'An end point.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'Line Line',
        summary: 'Gets or sets the Line value inside this curve.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'LoftType',
    dataType: 3,
    summary: 'Specifies enumerated constants for all supported loft types.',
    values: [
      {
        signature: 'Normal = 0',
        summary: 'Uses chord-length parameterization in the loft direction.'
      },
      {
        signature: 'Loose = 1',
        summary: `The surface is allowed to move away from the original curves to make a smoother surface.
     The surface control points are created at the same locations as the control points
     of the loft input curves.`
      },
      {
        signature: 'Tight = 2',
        summary: `The surface sticks closely to the original curves. Uses square root of chord-length
     parameterization in the loft direction.`
      },
      {
        signature: 'Straight = 3',
        summary: 'The sections between the curves are straight. This is also known as a ruled surface.'
      },
      {
        signature: '    Developable = 4',
        summary: 'Obsolete, do not use.'
      },
      {
        signature: 'Uniform = 5',
        summary: 'Constructs a uniform loft. The object knot vectors will be uniform.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Matrix',
    dataType: 1,
    summary: `Represents an arbitrarily sized matrix of double-precision
   floating point numbers. If you are working with a 4x4 matrix, then you may want
   to use the Transform class instead.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'Matrix(int rowCount,int columnCount)',
        summary: 'Initializes a new instance of the matrix.',
        since: 5,
        parameters: [
          {
            name: 'rowCount',
            summary: 'A positive integer, or 0, for the number of rows.'
          },
          {
            name: 'columnCount',
            summary: 'A positive integer, or 0, for the number of columns.'
          }
        ]
      },
      {
        signature: 'Matrix(Transform xform)',
        summary: 'Initializes a new instance of the matrix based on a 4x4 matrix Transform.',
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'A 4x4 matrix to copy from.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int ColumnCount',
        summary: 'Gets the amount of columns.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsColumnOrthogonal',
        summary: 'Gets a value indicating whether the matrix is column orthogonal.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsColumnOrthoNormal',
        summary: 'Gets a value indicating whether the matrix is column orthonormal.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsRowOrthogonal',
        summary: 'Gets a value indicating whether the matrix is row orthogonal.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsRowOrthoNormal',
        summary: 'Gets a value indicating whether the matrix is row orthonormal.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsSquare',
        summary: `Gets a value indicating whether this matrix has the same number of rows
     and columns. 0x0 matrices are not considered square.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: 'Gets a value indicating whether this matrix is valid.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int RowCount',
        summary: 'Gets the amount of rows.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'double[] BackSolve(double zeroTolerance,double[] b)',
        summary: `Solves M*x=b where M is upper triangular with a unit diagonal and
     b is a column of values.`,
        since: 5,
        parameters: [
          {
            name: 'zeroTolerance',
            summary: `(>=0.0) used to test for "zero" values in b
     in underdetermined systems of equations.`
          },
          {
            name: 'b',
            summary: `The values in B[RowCount],...,B[B.Length-1] are tested to
     make sure they are within "zeroTolerance".`
          }
        ],
        returns: 'Array of length ColumnCount on success. None on error.'
      },
      {
        signature: 'Point3d[] BackSolvePoints(double zeroTolerance,Point3d[] b)',
        summary: `Solves M*x=b where M is upper triangular with a unit diagonal and
     b is a column of 3d points.`,
        since: 5,
        parameters: [
          {
            name: 'zeroTolerance',
            summary: `(>=0.0) used to test for "zero" values in b
     in underdetermined systems of equations.`
          },
          {
            name: 'b',
            summary: `The values in B[RowCount],...,B[B.Length-1] are tested to
     make sure they are "zero".`
          }
        ],
        returns: 'Array of length ColumnCount on success. None on error.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'Matrix Duplicate()',
        summary: 'Create a duplicate of this matrix.',
        since: 5.1,
        returns: 'An exact duplicate of this matrix.'
      },
      {
        signature: 'int GetHashCode()',
        summary: `Gets the hash code for this matrix. The hash code will change 
     when the matrix changes so you cannot change matrices while they are stored in 
     hash tables.`,
        returns: 'Hash code.'
      },
      {
        signature: 'bool Invert(double zeroTolerance)',
        summary: `Modifies this matrix to become its own inverse.
     Matrix might be non-invertible (singular) and the return value will be false.`,
        since: 5,
        parameters: [
          {
            name: 'zeroTolerance',
            summary: 'The admitted tolerance for 0.'
          }
        ],
        returns: 'True if operation succeeded; otherwise false.'
      },
      {
        signature: 'int RowReduce(double zeroTolerance,double determinant,double pivot)',
        summary: 'Row reduces a matrix to calculate rank and determinant.',
        since: 5,
        parameters: [
          {
            name: 'zeroTolerance',
            summary: `(>=0.0) zero tolerance for pivot test.  If a the absolute value of
     a pivot is <= zeroTolerance, then the pivot is assumed to be zero.`
          },
          {
            name: 'determinant',
            summary: 'value of determinant is returned here.'
          },
          {
            name: 'pivot',
            summary: 'value of the smallest pivot is returned here.'
          }
        ],
        returns: 'Rank of the matrix.'
      },
      {
        signature: 'int RowReduce(double zeroTolerance,double[] b,double pivot)',
        summary: `Row reduces a matrix as the first step in solving M*X=b where
     b is a column of values.`,
        since: 5,
        parameters: [
          {
            name: 'zeroTolerance',
            summary: `(>=0.0) zero tolerance for pivot test. If the absolute value of a pivot
     is <= zero_tolerance, then the pivot is assumed to be zero.`
          },
          {
            name: 'b',
            summary: 'an array of RowCount values that is row reduced with the matrix.'
          },
          {
            name: 'pivot',
            summary: 'the value of the smallest pivot is returned here.'
          }
        ],
        returns: 'Rank of the matrix.'
      },
      {
        signature: 'int RowReduce(double zeroTolerance,Point3d[] b,double pivot)',
        summary: `Row reduces a matrix as the first step in solving M*X=b where
     b is a column of 3d points.`,
        since: 5,
        parameters: [
          {
            name: 'zeroTolerance',
            summary: `(>=0.0) zero tolerance for pivot test. If the absolute value of a pivot
     is <= zero_tolerance, then the pivot is assumed to be zero.`
          },
          {
            name: 'b',
            summary: 'An array of RowCount 3d points that is row reduced with the matrix.'
          },
          {
            name: 'pivot',
            summary: 'The value of the smallest pivot is returned here.'
          }
        ],
        returns: 'Rank of the matrix.'
      },
      {
        signature: 'void Scale(double s)',
        summary: 'Modifies the current matrix by multiplying its values by a number.',
        since: 5,
        parameters: [
          {
            name: 's',
            summary: 'A scale factor.'
          }
        ]
      },
      {
        signature: 'void SetDiagonal(double d)',
        summary: 'Sets diagonal value and zeros off all non-diagonal values.',
        since: 5,
        parameters: [
          {
            name: 'd',
            summary: 'The new diagonal value.'
          }
        ]
      },
      {
        signature: 'bool SwapColumns(int columnA,int columnB)',
        summary: 'Exchanges two columns.',
        since: 5,
        parameters: [
          {
            name: 'columnA',
            summary: 'A first column.'
          },
          {
            name: 'columnB',
            summary: 'Another column.'
          }
        ],
        returns: 'True if operation succeeded; otherwise false.'
      },
      {
        signature: 'bool SwapRows(int rowA,int rowB)',
        summary: 'Exchanges two rows.',
        since: 5,
        parameters: [
          {
            name: 'rowA',
            summary: 'A first row.'
          },
          {
            name: 'rowB',
            summary: 'Another row.'
          }
        ],
        returns: 'True if operation succeeded; otherwise false.'
      },
      {
        signature: 'bool Transpose()',
        summary: `Modifies this matrix to be its transpose.
     This is like swapping rows with columns.http://en.wikipedia.org/wiki/Transpose`,
        since: 5,
        returns: 'True if operation succeeded; otherwise false.'
      },
      {
        signature: 'void Zero()',
        summary: 'Sets all values inside the matrix to zero.',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Mesh',
    dataType: 1,
    summary: `Represents a geometry type that is defined by vertices and faces.
   This is often called a face-vertex mesh.`,
    baseclass: 'Rhino.Geometry.GeometryBase',
    constructors: [
      {
        signature: 'Mesh()',
        summary: 'Initializes a new empty mesh.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'MeshVertexStatusList ComponentStates',
        summary: `Gets access to the vertex hidden/visibility collection in this mesh.
     This is a runtime property and it is not saved in the 3dm file.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'int DisjointMeshCount',
        summary: 'Gets the number of disjoint (topologically unconnected) pieces in this mesh.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'MeshFaceNormalList FaceNormals',
        summary: 'Gets access to the face normal collection in this mesh.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'MeshFaceList Faces',
        summary: 'Gets access to the mesh face list.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool HasCachedTextureCoordinates',
        summary: `Will return True if SetCachedTextureCoordinates has been called;
     otherwise will return false.`,
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'bool HasPrincipalCurvatures',
        summary: 'HasPrincipalCurvatures',
        since: 7,
        property: ['get']
      },
      {
        signature: 'bool IsClosed',
        summary: `Gets a value indicating whether a mesh is considered to be closed (solid).
     A mesh is considered solid when every mesh edge borders two or more faces.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'MeshNgonList Ngons',
        summary: `Gets access to the mesh ngon list.
     Ngons represent groups of Faces (triangles + quads).Faces are used to tessellate an Ngon internally.When a triangle or quad is referenced in the Ngon list, it is no longer visualized and
     conceived as a single entity, but takes part of the Ngon.If you need to get access to both Ngons and the faces that are not referenced by Ngons,
     that is, all polygons that are visible in the mesh, then use the
      helper method.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'MeshVertexNormalList Normals',
        summary: 'Gets access to the vertex normal collection in this mesh.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int PartitionCount',
        summary: `Number of partition information chunks stored on this mesh based
     on the last call to CreatePartitions`,
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'MeshTextureCoordinateList TextureCoordinates',
        summary: 'Gets access to the vertex texture coordinate collection in this mesh.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'MeshTopologyEdgeList TopologyEdges',
        summary: `Gets the Rhino.Geometry.Collections.MeshTopologyEdgeList object associated with this mesh.
     This object stores edge connectivity.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'MeshTopologyVertexList TopologyVertices',
        summary: `Gets the Rhino.Geometry.Collections.MeshTopologyVertexList object associated with this mesh.
     This object stores vertex connectivity and the indices of vertices
     that were unified while computing the edge topology.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'MeshVertexColorList VertexColors',
        summary: 'Gets access to the (optional) vertex color collection in this mesh.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'MeshVertexList Vertices',
        summary: 'Gets access to the vertices set of this mesh.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static MeshThicknessMeasurement[] ComputeThickness(IEnumerable<Mesh> meshes,double maximumThickness)',
        summary: 'Compute thickness metrics for this mesh.',
        since: 6,
        parameters: [
          {
            name: 'meshes',
            summary: 'Meshes to include in thickness analysis.'
          },
          {
            name: 'maximumThickness',
            summary: 'Maximum thickness to consider. Use as small a thickness as possible to speed up the solver.'
          }
        ],
        returns: 'Array of thickness measurements.'
      },
      {
        signature: 'static MeshThicknessMeasurement[] ComputeThickness(IEnumerable<Mesh> meshes,double maximumThickness,CancellationToken cancelToken)',
        summary: 'Compute thickness metrics for this mesh.',
        since: 6,
        parameters: [
          {
            name: 'meshes',
            summary: 'Meshes to include in thickness analysis.'
          },
          {
            name: 'maximumThickness',
            summary: 'Maximum thickness to consider. Use as small a thickness as possible to speed up the solver.'
          },
          {
            name: 'cancelToken',
            summary: 'Computation cancellation token.'
          }
        ],
        returns: 'Array of thickness measurements.'
      },
      {
        signature: 'static MeshThicknessMeasurement[] ComputeThickness(IEnumerable<Mesh> meshes,double maximumThickness,double sharpAngle,CancellationToken cancelToken)',
        summary: 'Compute thickness metrics for this mesh.',
        since: 6,
        parameters: [
          {
            name: 'meshes',
            summary: 'Meshes to include in thickness analysis.'
          },
          {
            name: 'maximumThickness',
            summary: 'Maximum thickness to consider. Use as small a thickness as possible to speed up the solver.'
          },
          {
            name: 'sharpAngle',
            summary: 'Sharpness angle in radians.'
          },
          {
            name: 'cancelToken',
            summary: 'Computation cancellation token.'
          }
        ],
        returns: 'Array of thickness measurements.'
      },
      {
        signature: 'static Mesh[] CreateBooleanDifference(IEnumerable<Mesh> firstSet,IEnumerable<Mesh> secondSet)',
        summary: 'Computes the solid difference of two sets of Meshes.',
        since: 5,
        parameters: [
          {
            name: 'firstSet',
            summary: 'First set of Meshes (the set to subtract from).'
          },
          {
            name: 'secondSet',
            summary: 'Second set of Meshes (the set to subtract).'
          }
        ],
        returns: 'An array of Mesh results or None on failure.'
      },
      {
        signature: 'static Mesh[] CreateBooleanIntersection(IEnumerable<Mesh> firstSet,IEnumerable<Mesh> secondSet)',
        summary: 'Computes the solid intersection of two sets of meshes.',
        since: 5,
        parameters: [
          {
            name: 'firstSet',
            summary: 'First set of Meshes.'
          },
          {
            name: 'secondSet',
            summary: 'Second set of Meshes.'
          }
        ],
        returns: 'An array of Mesh results or None on failure.'
      },
      {
        signature: 'static Mesh[] CreateBooleanSplit(IEnumerable<Mesh> meshesToSplit,IEnumerable<Mesh> meshSplitters)',
        summary: 'Splits a set of meshes with another set.',
        since: 5,
        parameters: [
          {
            name: 'meshesToSplit',
            summary: 'A list, an array, or any enumerable set of meshes to be split. If this is null, None will be returned.'
          },
          {
            name: 'meshSplitters',
            summary: 'A list, an array, or any enumerable set of meshes that cut. If this is null, None will be returned.'
          }
        ],
        returns: 'A new mesh array, or None on error.'
      },
      {
        signature: 'static Mesh[] CreateBooleanUnion(IEnumerable<Mesh> meshes)',
        summary: 'Computes the solid union of a set of meshes.',
        since: 5,
        parameters: [
          {
            name: 'meshes',
            summary: 'Meshes to union.'
          }
        ],
        returns: 'An array of Mesh results or None on failure.'
      },
      {
        signature: 'static Curve[] CreateContourCurves(Mesh meshToContour,Plane sectionPlane)',
        summary: 'Constructs contour curves for a mesh, sectioned at a plane.',
        since: 5,
        parameters: [
          {
            name: 'meshToContour',
            summary: 'A mesh to contour.'
          },
          {
            name: 'sectionPlane',
            summary: 'A cutting plane.'
          }
        ],
        returns: 'An array of curves. This array can be empty.'
      },
      {
        signature: 'static Curve[] CreateContourCurves(Mesh meshToContour,Point3d contourStart,Point3d contourEnd,double interval)',
        summary: 'Constructs contour curves for a mesh, sectioned along a linear axis.',
        since: 5,
        parameters: [
          {
            name: 'meshToContour',
            summary: 'A mesh to contour.'
          },
          {
            name: 'contourStart',
            summary: 'A start point of the contouring axis.'
          },
          {
            name: 'contourEnd',
            summary: 'An end point of the contouring axis.'
          },
          {
            name: 'interval',
            summary: 'An interval distance.'
          }
        ],
        returns: 'An array of curves. This array can be empty.'
      },
      {
        signature: 'static Mesh CreateFromBox(BoundingBox box,int xCount,int yCount,int zCount)',
        summary: 'Constructs new mesh that matches a bounding box.',
        since: 5.6,
        parameters: [
          {
            name: 'box',
            summary: 'A box to use for creation.'
          },
          {
            name: 'xCount',
            summary: 'Number of faces in x-direction.'
          },
          {
            name: 'yCount',
            summary: 'Number of faces in y-direction.'
          },
          {
            name: 'zCount',
            summary: 'Number of faces in z-direction.'
          }
        ],
        returns: 'A new brep, or None on failure.'
      },
      {
        signature: 'static Mesh CreateFromBox(Box box,int xCount,int yCount,int zCount)',
        summary: 'Constructs new mesh that matches an aligned box.',
        since: 5.3,
        parameters: [
          {
            name: 'box',
            summary: 'Box to match.'
          },
          {
            name: 'xCount',
            summary: 'Number of faces in x-direction.'
          },
          {
            name: 'yCount',
            summary: 'Number of faces in y-direction.'
          },
          {
            name: 'zCount',
            summary: 'Number of faces in z-direction.'
          }
        ]
      },
      {
        signature: 'static Mesh CreateFromBox(IEnumerable<Point3d> corners,int xCount,int yCount,int zCount)',
        summary: 'Constructs new mesh from 8 corner points.',
        since: 5.3,
        parameters: [
          {
            name: 'corners',
            summary: `8 points defining the box corners arranged as the vN labels indicate.
     v7_____________v6|\\             |\\| \\            | \\|  \\ _____________\\|   v4         |   v5|   |          |   ||   |          |   |v3--|----------v2  | \\  |           \\  |  \\ |            \\ |   \\|             \\|    v0_____________v1`
          },
          {
            name: 'xCount',
            summary: 'Number of faces in x-direction.'
          },
          {
            name: 'yCount',
            summary: 'Number of faces in y-direction.'
          },
          {
            name: 'zCount',
            summary: 'Number of faces in z-direction.'
          }
        ],
        returns: 'A new brep, or None on failure.'
      },
      {
        signature: 'static Mesh[] CreateFromBrep(Brep brep)',
        summary: 'Constructs a mesh from a brep.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'Brep to approximate.'
          }
        ],
        returns: 'An array of meshes.'
      },
      {
        signature: 'static Mesh[] CreateFromBrep(Brep brep,MeshingParameters meshingParameters)',
        summary: 'Constructs a mesh from a brep.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'Brep to approximate.'
          },
          {
            name: 'meshingParameters',
            summary: 'Parameters to use during meshing.'
          }
        ],
        returns: 'An array of meshes.'
      },
      {
        signature: 'static Mesh CreateFromClosedPolyline(Polyline polyline)',
        summary: 'Attempts to create a Mesh that is a triangulation of a simple closed polyline that projects onto a plane.',
        since: 5,
        parameters: [
          {
            name: 'polyline',
            summary: 'must be closed'
          }
        ],
        returns: 'New mesh on success or None on failure.'
      },
      {
        signature: 'static Mesh CreateFromCone(Cone cone,int vertical,int around)',
        summary: 'Constructs a solid mesh cone.',
        since: 5,
        parameters: [
          {
            name: 'cone',
            summary: ''
          },
          {
            name: 'vertical',
            summary: 'Number of faces in the top-to-bottom direction.'
          },
          {
            name: 'around',
            summary: 'Number of faces around the cone.'
          }
        ],
        returns: 'A valid mesh if successful.'
      },
      {
        signature: 'static Mesh CreateFromCone(Cone cone,int vertical,int around,bool solid)',
        summary: 'Constructs a mesh cone.',
        since: 6.8,
        parameters: [
          {
            name: 'cone',
            summary: ''
          },
          {
            name: 'vertical',
            summary: 'Number of faces in the top-to-bottom direction.'
          },
          {
            name: 'around',
            summary: 'Number of faces around the cone.'
          },
          {
            name: 'solid',
            summary: 'If False the mesh will be open with no faces on the circular planar portion.'
          }
        ],
        returns: 'A valid mesh if successful.'
      },
      {
        signature: 'static Mesh CreateFromCone(Cone cone,int vertical,int around,bool solid,bool quadCaps)',
        summary: 'Constructs a mesh cone.',
        since: 7,
        parameters: [
          {
            name: 'cone',
            summary: ''
          },
          {
            name: 'vertical',
            summary: 'Number of faces in the top-to-bottom direction.'
          },
          {
            name: 'around',
            summary: 'Number of faces around the cone.'
          },
          {
            name: 'solid',
            summary: 'If False the mesh will be open with no faces on the circular planar portion.'
          },
          {
            name: 'quadCaps',
            summary: 'If True and it\'s possible to make quad caps, ie. around is even, then caps will have quad faces.'
          }
        ],
        returns: 'A valid mesh if successful.'
      },
      {
        signature: 'static Mesh CreateFromCurveExtrusion(Curve curve,Vector3d direction,MeshingParameters parameters,BoundingBox boundingBox)',
        summary: 'Constructs a new extrusion from a curve.',
        since: 7,
        parameters: [
          {
            name: 'curve',
            summary: 'A curve to extrude.'
          },
          {
            name: 'direction',
            summary: 'The direction of extrusion.'
          },
          {
            name: 'parameters',
            summary: 'The parameters of meshing.'
          },
          {
            name: 'boundingBox',
            summary: 'The bounding box controls the length of the estrusion.'
          }
        ],
        returns: 'A new mesh, or None on failure.'
      },
      {
        signature: 'static Mesh CreateFromCurvePipe(Curve curve,double radius,int segments,int accuracy,MeshPipeCapStyle capType,bool faceted,IEnumerable<Interval> intervals)',
        summary: 'Constructs a new mesh pipe from a curve.',
        since: 6,
        parameters: [
          {
            name: 'curve',
            summary: 'A curve to pipe.'
          },
          {
            name: 'radius',
            summary: 'The radius of the pipe.'
          },
          {
            name: 'segments',
            summary: 'The number of segments in the pipe.'
          },
          {
            name: 'accuracy',
            summary: 'The accuracy of the pipe.'
          },
          {
            name: 'capType',
            summary: 'The type of cap to be created at the end of the pipe.'
          },
          {
            name: 'faceted',
            summary: 'Specifies whether the pipe is faceted, or not.'
          },
          {
            name: 'intervals',
            summary: 'A series of intervals to pipe. This value can be null.'
          }
        ],
        returns: 'A new mesh, or None on failure.'
      },
      {
        signature: 'static Mesh CreateFromCylinder(Cylinder cylinder,int vertical,int around)',
        summary: 'Constructs a capped mesh cylinder.',
        since: 5,
        parameters: [
          {
            name: 'cylinder',
            summary: ''
          },
          {
            name: 'vertical',
            summary: 'Number of faces in the top-to-bottom direction.'
          },
          {
            name: 'around',
            summary: 'Number of faces around the cylinder.'
          }
        ],
        returns: 'Returns a mesh cylinder if successful, None otherwise.'
      },
      {
        signature: 'static Mesh CreateFromCylinder(Cylinder cylinder,int vertical,int around,bool capBottom,bool capTop)',
        summary: 'Constructs a mesh cylinder.',
        since: 7,
        parameters: [
          {
            name: 'cylinder',
            summary: ''
          },
          {
            name: 'vertical',
            summary: 'Number of faces in the top-to-bottom direction.'
          },
          {
            name: 'around',
            summary: 'Number of faces around the cylinder.'
          },
          {
            name: 'capBottom',
            summary: 'If True end at Cylinder.Height1 should be capped.'
          },
          {
            name: 'capTop',
            summary: 'If True end at Cylinder.Height2 should be capped.'
          }
        ],
        returns: 'Returns a mesh cylinder if successful, None otherwise.'
      },
      {
        signature: 'static Mesh CreateFromCylinder(Cylinder cylinder,int vertical,int around,bool capBottom,bool capTop,bool quadCaps)',
        summary: 'Constructs a mesh cylinder.',
        since: 7,
        parameters: [
          {
            name: 'cylinder',
            summary: ''
          },
          {
            name: 'vertical',
            summary: 'Number of faces in the top-to-bottom direction.'
          },
          {
            name: 'around',
            summary: 'Number of faces around the cylinder.'
          },
          {
            name: 'capBottom',
            summary: 'If True end at Cylinder.Height1 should be capped.'
          },
          {
            name: 'capTop',
            summary: 'If True end at Cylinder.Height2 should be capped.'
          },
          {
            name: 'quadCaps',
            summary: 'If True and it\'s possible to make quad caps, ie. around is even, then caps will have quad faces.'
          }
        ],
        returns: 'Returns a mesh cylinder if successful, None otherwise.'
      },
      {
        signature: 'static Mesh[] CreateFromIterativeCleanup(IEnumerable<Mesh> meshes,double tolerance)',
        summary: 'Repairs meshes with vertices that are too near, using a tolerance value.',
        since: 7,
        parameters: [
          {
            name: 'meshes',
            summary: 'The meshes to be repared.'
          },
          {
            name: 'tolerance',
            summary: 'A minimum distance for clean vertices.'
          }
        ],
        returns: 'A valid meshes array if successful. If no change was required, some meshes can be null. Otherwise, null, when no changes were done.'
      },
      {
        signature: 'static Mesh CreateFromLines(Curve[] lines,int maxFaceValence,double tolerance)',
        summary: `Creates a mesh by analizing the edge structure. Input lines could be from the extraction
     of edges from an original mesh.`,
        since: 6,
        parameters: [
          {
            name: 'lines',
            summary: 'Lines to use for computation. If curve is non-linear, curve ends are used'
          },
          {
            name: 'maxFaceValence',
            summary: 'The maximum number of edges per face.'
          },
          {
            name: 'tolerance',
            summary: `The distance after which two end points of lines are considered
     coincident.`
          }
        ],
        returns: 'A new mesh, or None if no mesh is constructed.'
      },
      {
        signature: 'static Mesh CreateFromPlanarBoundary(Curve boundary,MeshingParameters parameters)',
        summary: 'Do not use this overload. Use version that takes a tolerance parameter instead.',
        since: 5,
        parameters: [
          {
            name: 'boundary',
            summary: 'Do not use.'
          },
          {
            name: 'parameters',
            summary: 'Do not use.'
          }
        ],
        returns: 'Do not use.'
      },
      {
        signature: 'static Mesh CreateFromPlanarBoundary(Curve boundary,MeshingParameters parameters,double tolerance)',
        summary: 'Attempts to construct a mesh from a closed planar curve.RhinoMakePlanarMeshes',
        since: 6,
        parameters: [
          {
            name: 'boundary',
            summary: 'must be a closed planar curve.'
          },
          {
            name: 'parameters',
            summary: 'parameters used for creating the mesh.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance to use during operation.'
          }
        ],
        returns: 'New mesh on success or None on failure.'
      },
      {
        signature: 'static Mesh CreateFromPlane(Plane plane,Interval xInterval,Interval yInterval,int xCount,int yCount)',
        summary: 'Constructs a planar mesh grid.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane of mesh.'
          },
          {
            name: 'xInterval',
            summary: 'Interval describing size and extends of mesh along plane x-direction.'
          },
          {
            name: 'yInterval',
            summary: 'Interval describing size and extends of mesh along plane y-direction.'
          },
          {
            name: 'xCount',
            summary: 'Number of faces in x-direction.'
          },
          {
            name: 'yCount',
            summary: 'Number of faces in y-direction.'
          }
        ]
      },
      {
        signature: 'static Mesh CreateFromSphere(Sphere sphere,int xCount,int yCount)',
        summary: 'Constructs a mesh sphere.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'Base sphere for mesh.'
          },
          {
            name: 'xCount',
            summary: 'Number of faces in the around direction.'
          },
          {
            name: 'yCount',
            summary: 'Number of faces in the top-to-bottom direction.'
          }
        ]
      },
      {
        signature: 'static Mesh CreateFromSubD(SubD subd,int displayDensity)',
        summary: 'Create a mesh from a SubD limit surface',
        since: 7
      },
      {
        signature: 'static Mesh CreateFromSubDControlNet(SubD subd)',
        summary: 'Create a mesh from a SubD control net',
        since: 7
      },
      {
        signature: 'static Mesh CreateFromSurface(Surface surface)',
        summary: 'Constructs a mesh from a surface',
        since: 6.5,
        parameters: [
          {
            name: 'surface',
            summary: 'Surface to approximate'
          }
        ],
        returns: 'New mesh representing the surface'
      },
      {
        signature: 'static Mesh CreateFromSurface(Surface surface,MeshingParameters meshingParameters)',
        summary: 'Constructs a mesh from a surface',
        since: 6.5,
        parameters: [
          {
            name: 'surface',
            summary: 'Surface to approximate'
          },
          {
            name: 'meshingParameters',
            summary: 'settings used to create the mesh'
          }
        ],
        returns: 'New mesh representing the surface'
      },
      {
        signature: 'static Mesh CreateFromTessellation(IEnumerable<Point3d> points,IEnumerable<IEnumerable<Point3d>> edges,Plane plane,bool allowNewVertices)',
        summary: `Attempts to create a mesh that is a triangulation of a list of points, projected on a plane,
     including its holes and fixed edges.`,
        parameters: [
          {
            name: 'points',
            summary: 'A list, an array or any enumerable of points.'
          },
          {
            name: 'edges',
            summary: `A list of polylines, or other lists of points representing edges.
     This can be null. If nested enumerable items are null, they will be discarded.`
          },
          {
            name: 'plane',
            summary: 'A plane.'
          },
          {
            name: 'allowNewVertices',
            summary: `If true, the mesh might have more vertices than the list of input points,
     if doing so will improve long thin triangles.`
          }
        ],
        returns: 'A new mesh, or None if not successful.'
      },
      {
        signature: 'static Mesh CreateFromTorus(Torus torus,int vertical,int around)',
        summary: 'Constructs a mesh torus.',
        since: 7,
        parameters: [
          {
            name: 'torus',
            summary: 'The torus.'
          },
          {
            name: 'vertical',
            summary: 'Number of faces in the top-to-bottom direction.'
          },
          {
            name: 'around',
            summary: 'Number of faces around the torus.'
          }
        ],
        returns: 'Returns a mesh torus if successful, None otherwise.'
      },
      {
        signature: 'static Mesh CreateIcoSphere(Sphere sphere,int subdivisions)',
        summary: `Constructs a icospherical mesh. A mesh icosphere differs from a standard
     UV mesh sphere in that it's vertices are evenly distributed. A mesh icosphere
     starts from an icosahedron (a regular polyhedron with 20 equilateral triangles).
     It is then refined by splitting each triangle into 4 smaller triangles.
     This splitting can be done several times.`,
        since: 6,
        parameters: [
          {
            name: 'sphere',
            summary: 'The input sphere provides the orienting plane and radius.'
          },
          {
            name: 'subdivisions',
            summary: `The number of times you want the faces split, where 0  <= subdivisions <= 7. 
     Note, the total number of mesh faces produces is: 20 * (4 ^ subdivisions)`
          }
        ],
        returns: 'A welded mesh icosphere if successful, or None on failure.'
      },
      {
        signature: 'static Mesh CreatePatch(Polyline outerBoundary,double angleToleranceRadians,Surface pullbackSurface,IEnumerable<Curve> innerBoundaryCurves,IEnumerable<Curve> innerBothSideCurves,IEnumerable<Point3d> innerPoints,bool trimback,int divisions)',
        summary: 'Construct a mesh patch from a variety of input geometry.',
        since: 6,
        parameters: [
          {
            name: 'outerBoundary',
            summary: `(optional: can be null) Outer boundary
     polyline, if provided this will become the outer boundary of the
     resulting mesh. Any of the input that is completely outside the outer
     boundary will be ignored and have no impact on the result. If any of
     the input intersects the outer boundary the result will be
     unpredictable and is likely to not include the entire outer boundary.`
          },
          {
            name: 'angleToleranceRadians',
            summary: `Maximum angle between unit tangents and adjacent verticies. Used to
     divide curve inputs that cannot otherwise be represented as a polyline.`
          },
          {
            name: 'pullbackSurface',
            summary: `(optional: can be null) Initial surface where 3d input will be pulled
     to make a 2d representation used by the function that generates the mesh.
     Providing a pullbackSurface can be helpful when it is similar in shape
     to the pattern of the input, the pulled 2d points will be a better
     representation of the 3d points. If all of the input is more or less
     coplanar to start with, providing pullbackSurface has no real benefit.`
          },
          {
            name: 'innerBoundaryCurves',
            summary: `(optional: can be null) Polylines to create holes in the output mesh.
     If innerBoundaryCurves are the only input then the result may be null
     if trimback is set to False (see comments for trimback) because the
     resulting mesh could be invalid (all faces created contained vertexes
     from the perimeter boundary).`
          },
          {
            name: 'innerBothSideCurves',
            summary: `(optional: can be null) These polylines will create faces on both sides
     of the edge. If there are only input points(innerPoints) there is no
     way to guarantee a triangulation that will create an edge between two
     particular points. Adding a line, or polyline, to innerBothsideCurves
     that includes points from innerPoints will help guide the triangulation.`
          },
          {
            name: 'innerPoints',
            summary: `(optional: can be null) Points to be used to generate the mesh. If
     outerBoundary is not null, points outside of that boundary after it has
     been pulled to pullbackSurface (or the best plane through the input if
     pullbackSurface is null) will be ignored.`
          },
          {
            name: 'trimback',
            summary: `Only used when a outerBoundary has not been provided. When that is the
     case, the function uses the perimeter of the surface as the outer boundary
     instead. If true, any face of the resulting triangulated mesh that
     contains a vertex of the perimeter boundary will be removed.`
          },
          {
            name: 'divisions',
            summary: `Only used when a outerBoundary has not been provided. When that is the
     case, division becomes the number of divisions each side of the surface's
     perimeter will be divided into to create an outer boundary to work with.`
          }
        ],
        returns: 'mesh on success; None on failure'
      },
      {
        signature: 'static Mesh CreateQuadSphere(Sphere sphere,int subdivisions)',
        summary: `Constructs a quad mesh sphere. A quad mesh sphere differs from a standard
     UV mesh sphere in that it's vertices are evenly distributed. A quad mesh sphere
     starts from a cube (a regular polyhedron with 6 square sides).
     It is then refined by splitting each quad into 4 smaller quads.
     This splitting can be done several times.`,
        since: 6,
        parameters: [
          {
            name: 'sphere',
            summary: 'The input sphere provides the orienting plane and radius.'
          },
          {
            name: 'subdivisions',
            summary: `The number of times you want the faces split, where 0  <= subdivisions <= 8. 
     Note, the total number of mesh faces produces is: 6 * (4 ^ subdivisions)`
          }
        ],
        returns: 'A welded quad mesh sphere if successful, or None on failure.'
      },
      {
        signature: 'static Mesh CreateRefinedCatmullClarkMesh(Mesh mesh,RefinementSettings settings)',
        summary: 'Instantiates a new mesh that represents a Catmull-Clark subdivision of the mesh.',
        since: 6,
        parameters: [
          {
            name: 'mesh',
            summary: 'The mesh to subdivide.'
          },
          {
            name: 'settings',
            summary: 'An instance of the settings class, or None for defaults.'
          }
        ],
        returns: 'A new mesh. None is never returned.'
      },
      {
        signature: 'static Mesh CreateRefinedLoopMesh(Mesh mesh,LoopFormula formula,RefinementSettings settings)',
        summary: 'Instantiates a new mesh that represents a Loop subdivision of the mesh.',
        since: 6,
        parameters: [
          {
            name: 'mesh',
            summary: 'The mesh to subdivide.'
          },
          {
            name: 'formula',
            summary: 'The Loop subdivision formula.'
          },
          {
            name: 'settings',
            summary: 'An instance of the settings class, or None for defaults.'
          }
        ],
        returns: 'A new mesh. None is never returned.'
      },
      {
        signature: 'static Mesh QuadRemeshBrep(Brep brep,QuadRemeshParameters parameters)',
        summary: `Create QuadRemesh from a Brep
     Set Brep Face Mode by setting QuadRemeshParameters.PreserveMeshArrayEdgesMode`,
        since: 7
      },
      {
        signature: 'static Mesh QuadRemeshBrep(Brep brep,QuadRemeshParameters parameters,IEnumerable<Curve> guideCurves)',
        summary: 'Create Quad Remesh from a Brep',
        since: 7,
        parameters: [
          {
            name: 'brep',
            summary: 'Set Brep Face Mode by setting QuadRemeshParameters.PreserveMeshArrayEdgesMode'
          },
          {
            name: 'parameters',
            summary: ''
          },
          {
            name: 'guideCurves',
            summary: `A curve array used to influence mesh face layout
     The curves should touch the input mesh
     Set Guide Curve Influence by using QuadRemeshParameters.GuideCurveInfluence`
          }
        ]
      },
      {
        signature: 'static Task<Mesh> QuadRemeshBrepAsync(Brep brep,QuadRemeshParameters parameters,IEnumerable<Curve> guideCurves,IProgress<int> progress,CancellationToken cancelToken)',
        summary: 'Quad remesh this brep async',
        since: 7,
        parameters: [
          {
            name: 'brep',
            summary: 'Set Brep Face Mode by setting QuadRemeshParameters.PreserveMeshArrayEdgesMode'
          },
          {
            name: 'parameters',
            summary: ''
          },
          {
            name: 'guideCurves',
            summary: `A curve array used to influence mesh face layout
     The curves should touch the input mesh
     Set Guide Curve Influence by using QuadRemeshParameters.GuideCurveInfluence`
          },
          {
            name: 'progress',
            summary: ''
          },
          {
            name: 'cancelToken',
            summary: ''
          }
        ]
      },
      {
        signature: 'static Task<Mesh> QuadRemeshBrepAsync(Brep brep,QuadRemeshParameters parameters,IProgress<int> progress,CancellationToken cancelToken)',
        summary: 'Quad remesh this brep async',
        since: 7,
        parameters: [
          {
            name: 'brep',
            summary: 'Set Brep Face Mode by setting QuadRemeshParameters.PreserveMeshArrayEdgesMode'
          },
          {
            name: 'parameters',
            summary: ''
          },
          {
            name: 'progress',
            summary: ''
          },
          {
            name: 'cancelToken',
            summary: ''
          }
        ]
      },
      {
        signature: 'static bool RequireIterativeCleanup(IEnumerable<Mesh> meshes,double tolerance)',
        summary: `Analyzes some meshes, and determines if a pass of CreateFromIterativeCleanup would change the array.
     All available cleanup steps are used. Currently available cleanup steps are:- mending of single precision coincidence even though double precision vertices differ.- union of nearly identical vertices, irrespectively of their origin.- removal of t-joints along edges.`,
        since: 7,
        parameters: [
          {
            name: 'meshes',
            summary: 'A list, and array or any enumerable of meshes.'
          },
          {
            name: 'tolerance',
            summary: 'A 3d distance. This is usually a value of about 10e-7 magnitude.'
          }
        ],
        returns: 'True if meshes would be changed, otherwise false.'
      },
      {
        signature: 'void Append(IEnumerable<Mesh> meshes)',
        summary: `Append a list of meshes. This function is much more efficient than making
     repeated calls to Mesh.Append(Mesh) when lots of meshes are being joined
     into a single large mesh.`,
        since: 6.8,
        parameters: [
          {
            name: 'meshes',
            summary: 'Meshes to append to this one.'
          }
        ]
      },
      {
        signature: 'void Append(Mesh other)',
        summary: 'Appends a copy of another mesh to this one and updates indices of appended mesh parts.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Mesh to append to this one.'
          }
        ]
      },
      {
        signature: 'bool Check(TextLog textLog,MeshCheckParameters parameters)',
        summary: `Examines the mesh and logs a description of what it finds right or wrong.
     The various properties the function checks for are described in MeshCheckParameters.`,
        since: 7,
        parameters: [
          {
            name: 'textLog',
            summary: 'The text log'
          },
          {
            name: 'parameters',
            summary: 'The mesh checking parameter and results.'
          }
        ],
        returns: 'Returns True if the mesh is valid, False otherwise.'
      },
      {
        signature: 'void ClearSurfaceData()',
        summary: 'Removes surface parameters, curvature parameters and surface statistics from the mesh.',
        since: 6
      },
      {
        signature: 'void ClearTextureData()',
        summary: 'Removes all texture coordinate information from this mesh.',
        since: 5
      },
      {
        signature: 'MeshPoint ClosestMeshPoint(Point3d testPoint,double maximumDistance)',
        summary: `Gets the point on the mesh that is closest to a given test point. Similar to the 
     ClosestPoint function except this returns a MeshPoint class which includes
     extra information beyond just the location of the closest point.`,
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'The source of the search.'
          },
          {
            name: 'maximumDistance',
            summary: `Optional upper bound on the distance from test point to the mesh. 
     If you are only interested in finding a point Q on the mesh when 
     testPoint.DistanceTo(Q) < maximumDistance, 
     then set maximumDistance to that value. 
     This parameter is ignored if you pass 0.0 for a maximumDistance.`
          }
        ],
        returns: 'closest point information on success. None on failure.'
      },
      {
        signature: 'Point3d ClosestPoint(Point3d testPoint)',
        summary: 'Gets the point on the mesh that is closest to a given test point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to seach for.'
          }
        ],
        returns: 'The point on the mesh closest to testPoint, or Point3d.Unset on failure.'
      },
      {
        signature: 'int ClosestPoint(Point3d testPoint,Point3d pointOnMesh,double maximumDistance)',
        summary: 'Gets the point on the mesh that is closest to a given test point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to seach for.'
          },
          {
            name: 'pointOnMesh',
            summary: 'Point on the mesh closest to testPoint.'
          },
          {
            name: 'maximumDistance',
            summary: `Optional upper bound on the distance from test point to the mesh. 
     If you are only interested in finding a point Q on the mesh when 
     testPoint.DistanceTo(Q) < maximumDistance, 
     then set maximumDistance to that value. 
     This parameter is ignored if you pass 0.0 for a maximumDistance.`
          }
        ],
        returns: `Index of face that the closest point lies on if successful. 
     -1 if not successful; the value of pointOnMesh is undefined.`
      },
      {
        signature: 'int ClosestPoint(Point3d testPoint,Point3d pointOnMesh,Vector3d normalAtPoint,double maximumDistance)',
        summary: 'Gets the point on the mesh that is closest to a given test point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to seach for.'
          },
          {
            name: 'pointOnMesh',
            summary: 'Point on the mesh closest to testPoint.'
          },
          {
            name: 'normalAtPoint',
            summary: 'The normal vector of the mesh at the closest point.'
          },
          {
            name: 'maximumDistance',
            summary: `Optional upper bound on the distance from test point to the mesh. 
     If you are only interested in finding a point Q on the mesh when 
     testPoint.DistanceTo(Q) < maximumDistance, 
     then set maximumDistance to that value. 
     This parameter is ignored if you pass 0.0 for a maximumDistance.`
          }
        ],
        returns: `Index of face that the closest point lies on if successful. 
     -1 if not successful; the value of pointOnMesh is undefined.`
      },
      {
        signature: 'int CollapseFacesByArea(double lessThanArea,double greaterThanArea)',
        summary: `Collapses multiple mesh faces, with areas less than LessThanArea and greater than GreaterThanArea, 
     based on the principles found in Stan Melax's mesh reduction PDF, 
     see http://pomax.nihongoresources.com/downloads/PolygonReduction.pdf`,
        since: 6,
        parameters: [
          {
            name: 'lessThanArea',
            summary: 'Area in which faces are selected if their area is less than or equal to.'
          },
          {
            name: 'greaterThanArea',
            summary: 'Area in which faces are selected if their area is greater than or equal to.'
          }
        ],
        returns: 'Number of faces that were collapsed in the process.'
      },
      {
        signature: 'int CollapseFacesByByAspectRatio(double aspectRatio)',
        summary: `Collapses a multiple mesh faces, determined by face aspect ratio, based on criteria found in Stan Melax's polygon reduction,
     see http://pomax.nihongoresources.com/downloads/PolygonReduction.pdf`,
        since: 6,
        parameters: [
          {
            name: 'aspectRatio',
            summary: 'Faces with an aspect ratio less than aspectRatio are considered as candidates.'
          }
        ],
        returns: 'Number of faces that were collapsed in the process.'
      },
      {
        signature: 'int CollapseFacesByEdgeLength(bool bGreaterThan,double edgeLength)',
        summary: `Collapses multiple mesh faces, with greater/less than edge length, based on the principles 
     found in Stan Melax's mesh reduction PDF, 
     see http://pomax.nihongoresources.com/downloads/PolygonReduction.pdf`,
        since: 6,
        parameters: [
          {
            name: 'bGreaterThan',
            summary: 'Determines whether edge with lengths greater than or less than edgeLength are collapsed.'
          },
          {
            name: 'edgeLength',
            summary: 'Length with which to compare to edge lengths.'
          }
        ],
        returns: 'Number of edges (faces) that were collapsed.'
      },
      {
        signature: 'Color ColorAt(int faceIndex,double t0,double t1,double t2,double t3)',
        summary: `Evaluate a mesh normal at a set of barycentric coordinates. Barycentric coordinates must 
     be assigned in accordance with the rules as defined by MeshPoint.T.`,
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'Index of triangle or quad to evaluate.'
          },
          {
            name: 't0',
            summary: 'First barycentric coordinate.'
          },
          {
            name: 't1',
            summary: 'Second barycentric coordinate.'
          },
          {
            name: 't2',
            summary: 'Third barycentric coordinate.'
          },
          {
            name: 't3',
            summary: 'Fourth barycentric coordinate. If the face is a triangle, this coordinate will be ignored.'
          }
        ],
        returns: `The interpolated vertex color on the mesh or Color.Transparent if the faceIndex is not valid, 
     if the barycentric coordinates could not be evaluated, or if there are no colors defined on the mesh.`
      },
      {
        signature: 'Color ColorAt(MeshPoint meshPoint)',
        summary: 'Evaluate a mesh color at a set of barycentric coordinates.',
        since: 5,
        parameters: [
          {
            name: 'meshPoint',
            summary: 'MeshPoint instance contiaining a valid Face Index and Barycentric coordinates.'
          }
        ],
        returns: `The interpolated vertex color on the mesh or Color.Transparent if the faceIndex is not valid, 
     if the barycentric coordinates could not be evaluated, or if there are no colors defined on the mesh.`
      },
      {
        signature: 'bool Compact()',
        summary: `Removes any unreferenced objects from arrays, reindexes as needed 
     and shrinks arrays to minimum required size.`,
        since: 5,
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'byte[] ComputeAutoCreaseInformation()',
        summary: `Do not use this method.
     Length: top.Mesh.Vertices.Count`,
        since: 6,
        returns: 'An array that is bound to change.'
      },
      {
        signature: 'void CopyFrom(Mesh other)',
        summary: 'Copies mesh values into this mesh from another mesh.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The other mesh to copy from.'
          }
        ]
      },
      {
        signature: 'bool CreatePartitions(int maximumVertexCount,int maximumTriangleCount)',
        summary: `In ancient times (or modern smartphone times), some rendering engines
     were only able to process small batches of triangles and the
     CreatePartitions() function was provided to partition the mesh into
     subsets of vertices and faces that those rendering engines could handle.`,
        since: 5.6,
        returns: 'True on success'
      },
      {
        signature: 'void DestroyPartition()',
        summary: 'Destroys mesh partition.',
        since: 6
      },
      {
        signature: 'void DestroyTopology()',
        summary: 'Removes topology data, forcing all topology information to be recomputed.',
        since: 6
      },
      {
        signature: 'void DestroyTree()',
        summary: 'Destroys the mesh vertex access tree.',
        since: 6
      },
      {
        signature: 'GeometryBase Duplicate()',
        summary: `Constructs a copy of this mesh.
     This is the same as DuplicateMesh.`,
        since: 5,
        returns: 'A mesh.'
      },
      {
        signature: 'Mesh DuplicateMesh()',
        summary: `Constructs a copy of this mesh.
     This is the same as Duplicate.`,
        since: 5
      },
      {
        signature: 'bool EvaluateMeshGeometry(Surface surface)',
        summary: `If the mesh has SurfaceParameters, the surface is evaluated at
     these parameters and the mesh geometry is updated.`,
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'An input surface.'
          }
        ],
        returns: 'True if the operation succceeded; False otherwise.'
      },
      {
        signature: 'Mesh[] ExplodeAtUnweldedEdges()',
        summary: `Explode the mesh into submeshes where a submesh is a collection of faces that are contained
     within a closed loop of "unwelded" edges. Unwelded edges are edges where the faces that share
     the edge have unique mesh vertexes (not mesh topology vertexes) at both ends of the edge.`,
        since: 5,
        returns: `Array of submeshes on success; None on error. If the count in the returned array is 1, then
     nothing happened and the ouput is essentially a copy of the input.`
      },
      {
        signature: 'int[] ExtendSelectionByEdgeRidge(int[] preselectedEdges,int newEdge,bool iterative)',
        summary: 'Suggests an extension of a selection set by using information related with topology and alignment.',
        since: 6,
        parameters: [
          {
            name: 'preselectedEdges',
            summary: 'An array of edges that were already selected.'
          },
          {
            name: 'newEdge',
            summary: 'A new edge index.'
          },
          {
            name: 'iterative',
            summary: ''
          }
        ],
        returns: 'An array of edges that are in a visual relationship with newEdge.'
      },
      {
        signature: 'int[] ExtendSelectionByFaceLoop(int[] preselectedFaces,int newFace,bool iterative)',
        summary: 'Suggests an extension of a face selection set by using information related with topology and alignment.',
        since: 6,
        parameters: [
          {
            name: 'preselectedFaces',
            summary: 'An array of faces that were already selected.'
          },
          {
            name: 'newFace',
            summary: 'A new face index. If this index is already part of the selection, no extension is suggested.'
          },
          {
            name: 'iterative',
            summary: ''
          }
        ],
        returns: 'An array of faces that are in a visual relationship with newFace.'
      },
      {
        signature: 'Mesh ExtractNonManifoldEdges(bool selective)',
        summary: 'Extracts, or removes, non-manifold mesh edges.',
        since: 6,
        parameters: [
          {
            name: 'selective',
            summary: 'If true, then extract hanging faces only.'
          }
        ],
        returns: 'A mesh containing the extracted non-manifold parts if successful, None otherwise.'
      },
      {
        signature: 'bool FileHole(int topologyEdgeIndex)',
        summary: `Given a starting "naked" edge index, this function attempts to determine a "hole"
     by chaining additional naked edges together until if returns to the start index.
     Then it triangulates the closed polygon and either adds the faces to the mesh.`,
        since: 6,
        parameters: [
          {
            name: 'topologyEdgeIndex',
            summary: 'Starting naked edge index.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool FillHoles()',
        summary: `Attempts to determine "holes" in the mesh by chaining naked edges together. 
     Then it triangulates the closed polygons adds the faces to the mesh.`,
        since: 6,
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'void Flip(bool vertexNormals,bool faceNormals,bool faceOrientation)',
        summary: 'Reverses the direction of the mesh.',
        since: 5,
        parameters: [
          {
            name: 'vertexNormals',
            summary: 'If true, vertex normals will be reversed.'
          },
          {
            name: 'faceNormals',
            summary: 'If true, face normals will be reversed.'
          },
          {
            name: 'faceOrientation',
            summary: 'If true, face orientations will be reversed.'
          }
        ]
      },
      {
        signature: 'void Flip(bool vertexNormals,bool faceNormals,bool faceOrientation,bool ngonsBoundaryDirection)',
        summary: 'Reverses the direction of the mesh.',
        since: 7,
        parameters: [
          {
            name: 'vertexNormals',
            summary: 'If true, vertex normals will be reversed.'
          },
          {
            name: 'faceNormals',
            summary: 'If true, face normals will be reversed.'
          },
          {
            name: 'faceOrientation',
            summary: 'If true, face orientations will be reversed.'
          },
          {
            name: 'ngonsBoundaryDirection',
            summary: 'If true, ngon boundaries will be reversed'
          }
        ]
      },
      {
        signature: 'CachedTextureCoordinates GetCachedTextureCoordinates(Guid textureMappingId)',
        summary: `Call this method to get cached texture coordinates for a texture
     mapping with the specified Id.`,
        since: 5.1,
        parameters: [
          {
            name: 'textureMappingId',
            summary: 'Texture mapping Id'
          }
        ],
        returns: 'Object which allows access to coordinates and other props.'
      },
      {
        signature: 'bool[] GetNakedEdgePointStatus()',
        summary: `Returns an array of bool values equal in length to the number of vertices in this
     mesh. Each value corresponds to a mesh vertex and is set to True if the vertex is
     not completely surrounded by faces.`,
        since: 5,
        returns: `An array of true/False flags that, at each index, reveals if the corresponding
     vertex is completely surrounded by faces.`
      },
      {
        signature: 'Polyline[] GetNakedEdges()',
        summary: `Returns all edges of a mesh that are considered "naked" in the
     sense that the edge only has one face.`,
        since: 5,
        returns: 'An array of polylines, or None on error.'
      },
      {
        signature: 'int GetNgonAndFacesCount()',
        summary: 'Retrieves the count of items that GetNgonAndFacesEnumerable will provide.',
        since: 6,
        returns: 'The amount of faces that are not part of an ngon + the amount of ngons.'
      },
      {
        signature: 'IEnumerable<MeshNgon> GetNgonAndFacesEnumerable()',
        summary: `Retrieves a complete enumerable, i.e., one that provides an iterator over every face that is present,
     no matter if defined as a triangle, a quad, or a strictly over-four-sided ngon.`,
        since: 6,
        returns: 'The enumerator capable of enumerating through Mesh.Ngons> Mesh.Ngons and Faces'
      },
      {
        signature: 'Polyline[] GetOutlines(Plane plane)',
        summary: 'Constructs the outlines of a mesh projected against a plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'A plane to project against.'
          }
        ],
        returns: 'An array of polylines, or None on error.'
      },
      {
        signature: 'Polyline[] GetOutlines(RhinoViewport viewport)',
        summary: `Constructs the outlines of a mesh. The projection information in the
     viewport is used to determine how the outlines are projected.`,
        since: 5,
        parameters: [
          {
            name: 'viewport',
            summary: 'A viewport to determine projection direction.'
          }
        ],
        returns: 'An array of polylines, or None on error.'
      },
      {
        signature: 'Polyline[] GetOutlines(ViewportInfo viewportInfo,Plane plane)',
        summary: 'Constructs the outlines of a mesh.',
        since: 6,
        parameters: [
          {
            name: 'viewportInfo',
            summary: 'The viewport info that provides the outline direction.'
          },
          {
            name: 'plane',
            summary: 'Usually the view\'s construction plane. If a parallel projection and view plane is parallel to this, then project the results to the plane.'
          }
        ],
        returns: 'An array of polylines, or None on error.'
      },
      {
        signature: 'MeshPart GetPartition(int which)',
        summary: 'Retrieves a partition. See CreatePartitions for details.',
        since: 5.6,
        parameters: [
          {
            name: 'which',
            summary: 'The partition index.'
          }
        ]
      },
      {
        signature: 'bool GetSelfIntersections(double tolerance,Polyline[] intersections,bool overlapsPolylines,Polyline[] overlapsPolylinesResult,bool overlapsMesh,Mesh overlapsMeshResult,TextLog textLog,CancellationToken cancel,IProgress<double> progress)',
        summary: 'Gets the self intersections of this mesh.',
        since: 7
      },
      {
        signature: 'MeshUnsafeLock GetUnsafeLock(bool writable)',
        summary: 'Allows to obtain unsafe pointers to the underlying unmanaged data structures of the mesh.',
        since: 6,
        parameters: [
          {
            name: 'writable',
            summary: 'True if user will need to write onto the structure. False otherwise.'
          }
        ],
        returns: 'A lock that needs to be released.'
      },
      {
        signature: 'bool HealNakedEdges(double distance)',
        summary: `Attempts to "heal" naked edges in a mesh based on a given distance.  
     First attempts to move vertexes to neighboring vertexes that are within that
     distance away. Then it finds edges that have a closest point to the vertex within
     the distance and splits the edge. When it finds one it splits the edge and
     makes two new edges using that point.`,
        since: 6,
        parameters: [
          {
            name: 'distance',
            summary: 'Distance to not exceed when modifying the mesh.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool IsManifold(bool topologicalTest,bool isOriented,bool hasBoundary)',
        summary: `Gets a value indicating whether or not the mesh is manifold. 
     A manifold mesh does not have any edge that borders more than two faces.`,
        since: 5,
        parameters: [
          {
            name: 'topologicalTest',
            summary: 'If true, the query treats coincident vertices as the same.'
          },
          {
            name: 'isOriented',
            summary: `isOriented will be set to True if the mesh is a manifold 
     and adjacent faces have compatible face normals.`
          },
          {
            name: 'hasBoundary',
            summary: `hasBoundary will be set to True if the mesh is a manifold 
     and there is at least one "edge" with no more than one adjacent face.`
          }
        ],
        returns: 'True if every mesh "edge" has at most two adjacent faces.'
      },
      {
        signature: 'bool IsPointInside(Point3d point,double tolerance,bool strictlyIn)',
        summary: 'Determines if a point is inside a solid mesh.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: '3d point to test.'
          },
          {
            name: 'tolerance',
            summary: `(>=0) 3d distance tolerance used for ray-mesh intersection
     and determining strict inclusion.`
          },
          {
            name: 'strictlyIn',
            summary: `If strictlyIn is true, then point must be inside mesh by at least
     tolerance in order for this function to return true.
     If strictlyIn is false, then this function will return True if
     point is inside or the distance from point to a mesh face is <= tolerance.`
          }
        ],
        returns: 'True if point is inside the solid mesh, False if not.'
      },
      {
        signature: 'Vector3d NormalAt(int faceIndex,double t0,double t1,double t2,double t3)',
        summary: `Evaluate a mesh normal at a set of barycentric coordinates. Barycentric coordinates must 
     be assigned in accordance with the rules as defined by MeshPoint.T.`,
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'Index of triangle or quad to evaluate.'
          },
          {
            name: 't0',
            summary: 'First barycentric coordinate.'
          },
          {
            name: 't1',
            summary: 'Second barycentric coordinate.'
          },
          {
            name: 't2',
            summary: 'Third barycentric coordinate.'
          },
          {
            name: 't3',
            summary: 'Fourth barycentric coordinate. If the face is a triangle, this coordinate will be ignored.'
          }
        ],
        returns: 'A Normal vector to the mesh or Vector3d.Unset if the faceIndex is not valid or if the barycentric coordinates could not be evaluated.'
      },
      {
        signature: 'Vector3d NormalAt(MeshPoint meshPoint)',
        summary: 'Evaluate a mesh normal at a set of barycentric coordinates.',
        since: 5,
        parameters: [
          {
            name: 'meshPoint',
            summary: 'MeshPoint instance contiaining a valid Face Index and Barycentric coordinates.'
          }
        ],
        returns: 'A Normal vector to the mesh or Vector3d.Unset if the faceIndex is not valid or if the barycentric coordinates could not be evaluated.'
      },
      {
        signature: 'Mesh Offset(double distance)',
        summary: `Makes a new mesh with vertices offset a distance in the opposite direction of the existing vertex normals.
     Same as Mesh.Offset(distance, false)`,
        since: 5,
        parameters: [
          {
            name: 'distance',
            summary: 'A distance value to use for offsetting.'
          }
        ],
        returns: 'A new mesh on success, or None on failure.'
      },
      {
        signature: 'Mesh Offset(double distance,bool solidify)',
        summary: `Makes a new mesh with vertices offset a distance in the opposite direction of the existing vertex normals.
     Optionally, based on the value of solidify, adds the input mesh and a ribbon of faces along any naked edges.
     If solidify is False it acts exactly as the Offset(distance) function.`,
        since: 5,
        parameters: [
          {
            name: 'distance',
            summary: 'A distance value.'
          },
          {
            name: 'solidify',
            summary: 'True if the mesh should be solidified.'
          }
        ],
        returns: 'A new mesh on success, or None on failure.'
      },
      {
        signature: 'Mesh Offset(double distance,bool solidify,Vector3d direction)',
        summary: `Makes a new mesh with vertices offset a distance along the direction parameter.
     Optionally, based on the value of solidify, adds the input mesh and a ribbon of faces along any naked edges.
     If solidify is False it acts exactly as the Offset(distance) function.`,
        since: 6.2,
        parameters: [
          {
            name: 'distance',
            summary: 'A distance value.'
          },
          {
            name: 'solidify',
            summary: 'True if the mesh should be solidified.'
          },
          {
            name: 'direction',
            summary: 'Direction of offset for all vertices.'
          }
        ],
        returns: 'A new mesh on success, or None on failure.'
      },
      {
        signature: 'Mesh Offset(double distance,bool solidify,Vector3d direction,List<int> wallFacesOut)',
        summary: `Makes a new mesh with vertices offset a distance along the direction parameter.
     Optionally, based on the value of solidify, adds the input mesh and a ribbon of faces along any naked edges.
     If solidify is False it acts exactly as the Offset(distance) function. Returns list of wall faces, i.e. the
     faces that connect original and offset mesh when solidified.`,
        parameters: [
          {
            name: 'distance',
            summary: 'A distance value.'
          },
          {
            name: 'solidify',
            summary: 'True if the mesh should be solidified.'
          },
          {
            name: 'direction',
            summary: 'Direction of offset for all vertices.'
          },
          {
            name: 'wallFacesOut',
            summary: 'Returns list of wall faces.'
          }
        ],
        returns: 'A new mesh on success, or None on failure.'
      },
      {
        signature: 'Point3d PointAt(int faceIndex,double t0,double t1,double t2,double t3)',
        summary: `Evaluates a mesh at a set of barycentric coordinates. Barycentric coordinates must 
     be assigned in accordance with the rules as defined by MeshPoint.T.`,
        since: 5,
        parameters: [
          {
            name: 'faceIndex',
            summary: 'Index of triangle or quad to evaluate.'
          },
          {
            name: 't0',
            summary: 'First barycentric coordinate.'
          },
          {
            name: 't1',
            summary: 'Second barycentric coordinate.'
          },
          {
            name: 't2',
            summary: 'Third barycentric coordinate.'
          },
          {
            name: 't3',
            summary: 'Fourth barycentric coordinate. If the face is a triangle, this coordinate will be ignored.'
          }
        ],
        returns: 'A Point on the mesh or Point3d.Unset if the faceIndex is not valid or if the barycentric coordinates could not be evaluated.'
      },
      {
        signature: 'Point3d PointAt(MeshPoint meshPoint)',
        summary: 'Evaluate a mesh at a set of barycentric coordinates.',
        since: 5,
        parameters: [
          {
            name: 'meshPoint',
            summary: 'MeshPoint instance contiaining a valid Face Index and Barycentric coordinates.'
          }
        ],
        returns: 'A Point on the mesh or Point3d.Unset if the faceIndex is not valid or if the barycentric coordinates could not be evaluated.'
      },
      {
        signature: 'PolylineCurve PullCurve(Curve curve,double tolerance)',
        summary: `Gets a polyline approximation of the input curve and then moves its control points to the closest point on the mesh.
     Then it "connects the points" over edges so that a polyline on the mesh is formed.`,
        since: 7,
        parameters: [
          {
            name: 'curve',
            summary: 'A curve to pull.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value.'
          }
        ],
        returns: 'A polyline curve, or None if none could be constructed.'
      },
      {
        signature: 'Point3d[] PullPointsToMesh(IEnumerable<Point3d> points)',
        summary: 'Pulls a collection of points to a mesh.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'An array, a list or any enumerable set of points.'
          }
        ],
        returns: 'An array of points. This can be empty.'
      },
      {
        signature: 'Mesh QuadRemesh(QuadRemeshParameters parameters)',
        summary: 'Quad remesh this mesh',
        since: 7
      },
      {
        signature: 'Mesh QuadRemesh(QuadRemeshParameters parameters,IEnumerable<Curve> guideCurves)',
        summary: 'Quad remesh this mesh',
        since: 7,
        parameters: [
          {
            name: 'parameters',
            summary: ''
          },
          {
            name: 'guideCurves',
            summary: `A curve array used to influence mesh face layout
     The curves should touch the input mesh
     Set Guide Curve Influence by using QuadRemeshParameters.GuideCurveInfluence`
          }
        ]
      },
      {
        signature: 'Task<Mesh> QuadRemeshAsync(IEnumerable<int> faceBlocks,QuadRemeshParameters parameters,IEnumerable<Curve> guideCurves,IProgress<int> progress,CancellationToken cancelToken)',
        summary: 'Quad remesh this mesh async',
        since: 7,
        parameters: [
          {
            name: 'faceBlocks',
            summary: ''
          },
          {
            name: 'parameters',
            summary: ''
          },
          {
            name: 'guideCurves',
            summary: `A curve array used to influence mesh face layout
     The curves should touch the input mesh
     Set Guide Curve Influence by using QuadRemeshParameters.GuideCurveInfluence`
          },
          {
            name: 'progress',
            summary: ''
          },
          {
            name: 'cancelToken',
            summary: ''
          }
        ]
      },
      {
        signature: 'Task<Mesh> QuadRemeshAsync(QuadRemeshParameters parameters,IEnumerable<Curve> guideCurves,IProgress<int> progress,CancellationToken cancelToken)',
        summary: 'Quad remesh this mesh async',
        since: 7,
        parameters: [
          {
            name: 'parameters',
            summary: ''
          },
          {
            name: 'guideCurves',
            summary: `A curve array used to influence mesh face layout
     The curves should touch the input mesh
     Set Guide Curve Influence by using QuadRemeshParameters.GuideCurveInfluence`
          },
          {
            name: 'progress',
            summary: ''
          },
          {
            name: 'cancelToken',
            summary: ''
          }
        ]
      },
      {
        signature: 'Task<Mesh> QuadRemeshAsync(QuadRemeshParameters parameters,IProgress<int> progress,CancellationToken cancelToken)',
        summary: 'Quad remesh this mesh async',
        since: 7
      },
      {
        signature: 'void RebuildNormals()',
        summary: `Removes mesh normals and reconstructs the face and vertex normals based
     on the orientation of the faces.`,
        since: 6
      },
      {
        signature: 'bool Reduce(int desiredPolygonCount,bool allowDistortion,int accuracy,bool normalizeSize)',
        summary: 'Reduce polygon count',
        since: 5.1,
        parameters: [
          {
            name: 'desiredPolygonCount',
            summary: 'desired or target number of faces'
          },
          {
            name: 'allowDistortion',
            summary: 'If True mesh appearance is not changed even if the target polygon count is not reached'
          },
          {
            name: 'accuracy',
            summary: `Integer from 1 to 10 telling how accurate reduction algorithm
      to use. Greater number gives more accurate results`
          },
          {
            name: 'normalizeSize',
            summary: 'If True mesh is fitted to an axis aligned unit cube until reduction is complete'
          }
        ],
        returns: 'True if mesh is successfully reduced and False if mesh could not be reduced for some reason.'
      },
      {
        signature: 'bool Reduce(int desiredPolygonCount,bool allowDistortion,int accuracy,bool normalizeSize,bool threaded)',
        summary: 'Reduce polygon count',
        since: 6.15,
        parameters: [
          {
            name: 'desiredPolygonCount',
            summary: 'desired or target number of faces'
          },
          {
            name: 'allowDistortion',
            summary: 'If True mesh appearance is not changed even if the target polygon count is not reached'
          },
          {
            name: 'accuracy',
            summary: `Integer from 1 to 10 telling how accurate reduction algorithm
      to use. Greater number gives more accurate results`
          },
          {
            name: 'normalizeSize',
            summary: 'If True mesh is fitted to an axis aligned unit cube until reduction is complete'
          },
          {
            name: 'threaded',
            summary: `If True then will run computation inside a worker thread and ignore any provided CancellationTokens and ProgressReporters.
     If False then will run on main thread.`
          }
        ],
        returns: 'True if mesh is successfully reduced and False if mesh could not be reduced for some reason.'
      },
      {
        signature: 'bool Reduce(int desiredPolygonCount,bool allowDistortion,int accuracy,bool normalizeSize,CancellationToken cancelToken,IProgress<double> progress,string problemDescription)',
        summary: 'Reduce polygon count',
        since: 6,
        parameters: [
          {
            name: 'desiredPolygonCount',
            summary: 'desired or target number of faces'
          },
          {
            name: 'allowDistortion',
            summary: 'If True mesh appearance is not changed even if the target polygon count is not reached'
          },
          {
            name: 'accuracy',
            summary: `Integer from 1 to 10 telling how accurate reduction algorithm
      to use. Greater number gives more accurate results`
          },
          {
            name: 'normalizeSize',
            summary: 'If True mesh is fitted to an axis aligned unit cube until reduction is complete'
          },
          {
            name: 'cancelToken',
            summary: ''
          },
          {
            name: 'progress',
            summary: ''
          },
          {
            name: 'problemDescription',
            summary: ''
          }
        ],
        returns: 'True if mesh is successfully reduced and False if mesh could not be reduced for some reason.'
      },
      {
        signature: 'bool Reduce(int desiredPolygonCount,bool allowDistortion,int accuracy,bool normalizeSize,CancellationToken cancelToken,IProgress<double> progress,string problemDescription,bool threaded)',
        summary: 'Reduce polygon count',
        since: 6.15,
        parameters: [
          {
            name: 'desiredPolygonCount',
            summary: 'desired or target number of faces'
          },
          {
            name: 'allowDistortion',
            summary: 'If True mesh appearance is not changed even if the target polygon count is not reached'
          },
          {
            name: 'accuracy',
            summary: `Integer from 1 to 10 telling how accurate reduction algorithm
      to use. Greater number gives more accurate results`
          },
          {
            name: 'normalizeSize',
            summary: 'If True mesh is fitted to an axis aligned unit cube until reduction is complete'
          },
          {
            name: 'cancelToken',
            summary: ''
          },
          {
            name: 'progress',
            summary: ''
          },
          {
            name: 'problemDescription',
            summary: ''
          },
          {
            name: 'threaded',
            summary: `If True then will run computation inside a worker thread and ignore any provided CancellationTokens and ProgressReporters.
     If False then will run on main thread.`
          }
        ],
        returns: 'True if mesh is successfully reduced and False if mesh could not be reduced for some reason.'
      },
      {
        signature: 'bool Reduce(ReduceMeshParameters parameters)',
        summary: 'Reduce polygon count',
        since: 6,
        parameters: [
          {
            name: 'parameters',
            summary: 'Parameters'
          }
        ],
        returns: 'True if mesh is successfully reduced and False if mesh could not be reduced for some reason.'
      },
      {
        signature: 'bool Reduce(ReduceMeshParameters parameters,bool threaded)',
        summary: 'Reduce polygon count',
        since: 6.15,
        parameters: [
          {
            name: 'parameters',
            summary: 'Parameters'
          },
          {
            name: 'threaded',
            summary: `If True then will run computation inside a worker thread and ignore any provided CancellationTokens and ProgressReporters.
     If False then will run on main thread.`
          }
        ],
        returns: 'True if mesh is successfully reduced and False if mesh could not be reduced for some reason.'
      },
      {
        signature: 'void ReleaseUnsafeLock(MeshUnsafeLock meshData)',
        summary: 'Updates the Mesh data with the information that was stored via the MeshUnsafeLock.',
        parameters: [
          {
            name: 'meshData',
            summary: 'The data that will be unlocked.'
          }
        ]
      },
      {
        signature: 'void SetCachedTextureCoordinates(TextureMapping tm,Transform xf)',
        summary: 'Set cached texture coordinates using the specified mapping.',
        since: 5.1
      },
      {
        signature: 'void SetTextureCoordinates(TextureMapping tm,Transform xf,bool lazy)',
        summary: `Set texture coordinates using given mapping and applying given transform.
     
     Set lazy to False to generate texture coordinates right away.`,
        since: 6,
        parameters: [
          {
            name: 'tm',
            summary: 'Texture mapping'
          },
          {
            name: 'xf',
            summary: 'Transform to apply to the texture mapping'
          },
          {
            name: 'lazy',
            summary: 'Whether to generate lazily (true) or right away (false)'
          }
        ]
      },
      {
        signature: 'bool Smooth(double smoothFactor,bool bXSmooth,bool bYSmooth,bool bZSmooth,bool bFixBoundaries,SmoothingCoordinateSystem coordinateSystem)',
        summary: 'Smooths a mesh by averaging the positions of mesh vertices in a specified region.',
        since: 6,
        parameters: [
          {
            name: 'smoothFactor',
            summary: 'The smoothing factor, which controls how much vertices move towards the average of the neighboring vertices.'
          },
          {
            name: 'bXSmooth',
            summary: 'When True vertices move in X axis direction.'
          },
          {
            name: 'bYSmooth',
            summary: 'When True vertices move in Y axis direction.'
          },
          {
            name: 'bZSmooth',
            summary: 'When True vertices move in Z axis direction.'
          },
          {
            name: 'bFixBoundaries',
            summary: 'When True vertices along naked edges will not be modified.'
          },
          {
            name: 'coordinateSystem',
            summary: 'The coordinates to determine the direction of the smoothing.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool Smooth(double smoothFactor,bool bXSmooth,bool bYSmooth,bool bZSmooth,bool bFixBoundaries,SmoothingCoordinateSystem coordinateSystem,Plane plane)',
        summary: 'Smooths a mesh by averaging the positions of mesh vertices in a specified region.',
        since: 6,
        parameters: [
          {
            name: 'smoothFactor',
            summary: 'The smoothing factor, which controls how much vertices move towards the average of the neighboring vertices.'
          },
          {
            name: 'bXSmooth',
            summary: 'When True vertices move in X axis direction.'
          },
          {
            name: 'bYSmooth',
            summary: 'When True vertices move in Y axis direction.'
          },
          {
            name: 'bZSmooth',
            summary: 'When True vertices move in Z axis direction.'
          },
          {
            name: 'bFixBoundaries',
            summary: 'When True vertices along naked edges will not be modified.'
          },
          {
            name: 'coordinateSystem',
            summary: 'The coordinates to determine the direction of the smoothing.'
          },
          {
            name: 'plane',
            summary: 'If SmoothingCoordinateSystem.CPlane specified, then the construction plane.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool Smooth(IEnumerable<int> vertexIndices,double smoothFactor,bool bXSmooth,bool bYSmooth,bool bZSmooth,bool bFixBoundaries,SmoothingCoordinateSystem coordinateSystem,Plane plane)',
        summary: 'Smooths part of a mesh by averaging the positions of mesh vertices in a specified region.',
        since: 6.8,
        parameters: [
          {
            name: 'vertexIndices',
            summary: 'The mesh vertex indices that specify the part of the mesh to smooth.'
          },
          {
            name: 'smoothFactor',
            summary: 'The smoothing factor, which controls how much vertices move towards the average of the neighboring vertices.'
          },
          {
            name: 'bXSmooth',
            summary: 'When True vertices move in X axis direction.'
          },
          {
            name: 'bYSmooth',
            summary: 'When True vertices move in Y axis direction.'
          },
          {
            name: 'bZSmooth',
            summary: 'When True vertices move in Z axis direction.'
          },
          {
            name: 'bFixBoundaries',
            summary: 'When True vertices along naked edges will not be modified.'
          },
          {
            name: 'coordinateSystem',
            summary: 'The coordinates to determine the direction of the smoothing.'
          },
          {
            name: 'plane',
            summary: 'If SmoothingCoordinateSystem.CPlane specified, then the construction plane.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'int SolidOrientation()',
        summary: 'Determines orientation of a "solid" mesh.',
        since: 5,
        returns: '+1 = mesh is solid with outward facing normals.-1 = mesh is solid with inward facing normals.0 = mesh is not solid.'
      },
      {
        signature: 'Mesh[] Split(IEnumerable<Mesh> meshes)',
        summary: `Split a mesh with a collection of meshes.
     Does not split at coplanar intersections.`,
        since: 5,
        parameters: [
          {
            name: 'meshes',
            summary: 'Meshes to split with.'
          }
        ],
        returns: 'An array of mesh segments representing the split result.'
      },
      {
        signature: 'Mesh[] Split(IEnumerable<Mesh> meshes,double tolerance,bool splitAtCoplanar,TextLog textLog,CancellationToken cancel,IProgress<double> progress)',
        summary: 'Split a mesh with a collection of meshes.',
        since: 7,
        parameters: [
          {
            name: 'meshes',
            summary: 'Meshes to split with.'
          },
          {
            name: 'tolerance',
            summary: `A value for intersection tolerance.
     WARNING! Correct values are typically in the (10e-8 - 10e-4) range.An option is to use the document tolerance diminished by a few orders or magnitude.`
          },
          {
            name: 'splitAtCoplanar',
            summary: 'If false, coplanar areas will not be separated.'
          },
          {
            name: 'textLog',
            summary: 'A text log to write onto.'
          },
          {
            name: 'cancel',
            summary: 'A cancellation token.'
          },
          {
            name: 'progress',
            summary: 'A progress reporter item. This can be null.'
          }
        ],
        returns: 'An array of mesh parts representing the split result, or null: when no mesh intersected, or if a cancel stopped the computation.'
      },
      {
        signature: 'Mesh[] Split(Mesh mesh)',
        summary: 'Split a mesh with another mesh.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh to split with.'
          }
        ],
        returns: 'An array of mesh segments representing the split result.'
      },
      {
        signature: 'Mesh[] Split(Plane plane)',
        summary: 'Split a mesh by an infinite plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'The splitting plane.'
          }
        ],
        returns: 'A new mesh array with the split result. This can be None if no result was found.'
      },
      {
        signature: 'Mesh[] SplitDisjointPieces()',
        summary: 'Splits up the mesh into its unconnected pieces.',
        since: 5,
        returns: 'An array containing all the disjoint pieces that make up this Mesh.'
      },
      {
        signature: 'Mesh[] SplitWithProjectedPolylines(IEnumerable<PolylineCurve> curves,double tolerance)',
        summary: `Splits a mesh by adding edges in correspondance with input polylines, and divides the mesh at partitioned areas.
     Polyline segments that are measured not to be on the mesh will be ignored.`,
        since: 7,
        parameters: [
          {
            name: 'curves',
            summary: 'An array, a list or any enumerable of polyline curves.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value.'
          }
        ],
        returns: 'An array of meshes, or None if no change would happen.'
      },
      {
        signature: 'Mesh[] SplitWithProjectedPolylines(IEnumerable<PolylineCurve> curves,double tolerance,TextLog textLog,CancellationToken cancel,IProgress<double> progress)',
        summary: `Splits a mesh by adding edges in correspondance with input polylines, and divides the mesh at partitioned areas.
     Polyline segments that are measured not to be on the mesh will be ignored.`,
        since: 7,
        parameters: [
          {
            name: 'curves',
            summary: 'An array, a list or any enumerable of polyline curves.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value.'
          },
          {
            name: 'textLog',
            summary: 'A text log, or null.'
          },
          {
            name: 'cancel',
            summary: 'A cancellation token to stop the computation at a given point.'
          },
          {
            name: 'progress',
            summary: 'A progress reporter to inform the user about progress. The reported value is indicative.'
          }
        ],
        returns: 'An array of meshes, or None if no change would happen.'
      },
      {
        signature: 'int UnifyNormals()',
        summary: `Attempts to fix inconsistencies in the directions of mesh faces in a mesh. This function
     does not modify mesh vertex normals, it rearranges the mesh face winding and face
     normals to make them all consistent. Note, you may want to call Mesh.Normals.ComputeNormals()
     to recompute vertex normals after calling this functions.`,
        since: 5,
        returns: 'number of faces that were modified.'
      },
      {
        signature: 'int UnifyNormals(bool countOnly)',
        summary: `Attempts to fix inconsistencies in the directions of mesh faces in a mesh. This function
     does not modify mesh vertex normals, it rearranges the mesh face winding and face
     normals to make them all consistent. Note, you may want to call Mesh.Normals.ComputeNormals()
     to recompute vertex normals after calling this functions.`,
        since: 6,
        parameters: [
          {
            name: 'countOnly',
            summary: 'If true, then only the number of faces that would be modified is determined.'
          }
        ],
        returns: 'If countOnly=false, the number of faces that were modified. If countOnly=true, the number of faces that would be modified.'
      },
      {
        signature: 'void Unweld(double angleToleranceRadians,bool modifyNormals)',
        summary: `Makes sure that faces sharing an edge and having a difference of normal greater
     than or equal to angleToleranceRadians have unique vertexes along that edge,
     adding vertices if necessary.`,
        since: 5,
        parameters: [
          {
            name: 'angleToleranceRadians',
            summary: 'Angle at which to make unique vertices.'
          },
          {
            name: 'modifyNormals',
            summary: `Determines whether new vertex normals will have the same vertex normal as the original (false)
     or vertex normals made from the corrsponding face normals (true)`
          }
        ]
      },
      {
        signature: 'bool UnweldEdge(IEnumerable<int> edgeIndices,bool modifyNormals)',
        summary: 'Adds creases to a smooth mesh by creating coincident vertices along selected edges.',
        since: 6.3,
        parameters: [
          {
            name: 'edgeIndices',
            summary: 'An array of mesh topology edge indices.'
          },
          {
            name: 'modifyNormals',
            summary: `If true, the vertex normals on each side of the edge take the same value as the face to which they belong, giving the mesh a hard edge look.
     If false, each of the vertex normals on either side of the edge is assigned the same value as the original normal that the pair is replacing, keeping a smooth look.`
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'double Volume()',
        summary: 'Compute volume of the mesh.',
        since: 6,
        returns: 'Volume of the mesh.'
      },
      {
        signature: 'void Weld(double angleToleranceRadians)',
        summary: `Makes sure that faces sharing an edge and having a difference of normal greater
     than or equal to angleToleranceRadians share vertexes along that edge, vertex normals
     are averaged.`,
        since: 5,
        parameters: [
          {
            name: 'angleToleranceRadians',
            summary: 'Angle at which to weld vertices.'
          }
        ]
      },
      {
        signature: 'Mesh WithDisplacement(MeshDisplacementInfo displacement)',
        summary: 'Constructs new mesh from the current one, with displacement applied to it.',
        since: 6,
        parameters: [
          {
            name: 'displacement',
            summary: 'Information on mesh displacement.'
          }
        ],
        returns: 'A new mesh with shutlining.'
      },
      {
        signature: 'Mesh WithEdgeSoftening(double softeningRadius,bool chamfer,bool faceted,bool force,double angleThreshold)',
        summary: 'Constructs new mesh from the current one, with edge softening applied to it.',
        since: 6,
        parameters: [
          {
            name: 'softeningRadius',
            summary: 'The softening radius.'
          },
          {
            name: 'chamfer',
            summary: 'Specifies whether to chamfer the edges.'
          },
          {
            name: 'faceted',
            summary: 'Specifies whether the edges are faceted.'
          },
          {
            name: 'force',
            summary: 'Specifies whether to soften edges despite too large a radius.'
          },
          {
            name: 'angleThreshold',
            summary: `Threshold angle (in degrees) which controls whether an edge is softened or not.
     The angle refers to the angles between the adjacent faces of an edge.`
          }
        ],
        returns: 'A new mesh with soft edges.'
      },
      {
        signature: 'Mesh WithShutLining(bool faceted,double tolerance,IEnumerable<ShutLiningCurveInfo> curves)',
        summary: 'Constructs new mesh from the current one, with shut lining applied to it.',
        since: 6,
        parameters: [
          {
            name: 'faceted',
            summary: 'Specifies whether the shutline is faceted.'
          },
          {
            name: 'tolerance',
            summary: 'The tolerance of the shutline.'
          },
          {
            name: 'curves',
            summary: 'A collection of curve arguments.'
          }
        ],
        returns: 'A new mesh with shutlining. Null on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshCheckParameters',
    dataType: 2,
    summary: 'Output of a mesh checking operations.',
    properties: [
      {
        signature: 'bool CheckForBadNormals',
        summary: `If true, then then look for vertex normals that are not unit vectors,
     are zero length or vary greatly from the general direction of the
     face normals.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool CheckForDegenerateFaces',
        summary: `If true, then look for triangles and quads that have zero area and quads
     where one sub triangle has zero area.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool CheckForDisjointMeshes',
        summary: `If true, then look for faces in the mesh that are totally isolated from other faces in the mesh.  
     (i.e. an island of faces, or many islands, that have a boundary of naked edges)`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool CheckForDuplicateFaces',
        summary: 'If true, then look for faces that have vertexes (not necessarily vertex indexes) that are identical.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool CheckForExtremelyShortEdges',
        summary: `If true, then look for topological edges where the distance between the
     endpoints is less than ExtremelyShortEdgeDistance.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool CheckForInvalidNgons',
        summary: 'If true, then look for ngons that have invalid information.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool CheckForNakedEdges',
        summary: `If true, then look for topological edges in the mesh topology where the
     face count is 1. Note, this check is also made if CheckForDuplicateFaces
     is True but the output is not shown if CheckForNakedEdges is false.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool CheckForNonManifoldEdges',
        summary: `If true, then look for topological edges in the mesh topology where the
     face count is greater than 2. Note, this check is also made if
     CheckForDuplicateFaces is True but the output is not shown if 
     CheckForNonManifoldEdges is false.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool CheckForRandomFaceNormals',
        summary: `If true, then look for adjacent faces that have the same edge orientation.
     This typically means that clockwise/counterclockwise orientation, and face normal
     are not in sync.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool CheckForSelfIntersection',
        summary: 'If true, then look for self intersections.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool CheckForUnusedVertices',
        summary: 'If true, then look for vertices that are not referenced by any face in the mesh.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'int DegenerateFaceCount',
        summary: 'Gets the total degenerate face count for all meshes.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int DisjointMeshCount',
        summary: 'Gets the total count of disjoint pieces for all meshes.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int DuplicateFaceCount',
        summary: 'Gets the total count of duplicate faces for all meshes.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int ExtremelyShortEdgeCount',
        summary: 'Gets the total number of extremely short edges for all meshes.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int InvalidNgonCount',
        summary: 'Gets the total number of invalid ngons for all meshes.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int NakedEdgeCount',
        summary: 'Gets the total number of naked edges for all meshes.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int NonManifoldEdgeCount',
        summary: 'Gets the total number of non-manifold edges for all meshes.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int NonUnitVectorNormalCount',
        summary: 'Get the total count of normals that are not unit vectors for all meshes.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int RandomFaceNormalCount',
        summary: 'Gets the total count of random face normals for all meshes.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int SelfIntersectingPairsCount',
        summary: 'Gets the total count of self intersections for all meshes.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int UnusedVertexCount',
        summary: 'Gets the total count of unused vertices for all meshes.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int VertexFaceNormalsDifferCount',
        summary: `Gets the total count of vertex normals that differ greatly from face 
     normals for all meshes.`,
        since: 7,
        property: ['get']
      },
      {
        signature: 'int ZeroLengthNormalCount',
        summary: 'Gets the total count of zero length normals for all meshes.',
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static MeshCheckParameters Defaults()',
        summary: 'Gets the default mesh check parameters.',
        since: 7,
        returns: 'The default mesh check parameters.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshDisplacementInfo',
    dataType: 1,
    summary: 'Contains mesh displacement information.',
    constructors: [
      {
        signature: 'MeshDisplacementInfo(RenderTexture texture,TextureMapping mapping)',
        summary: `Constructs a displacement information instance with default values.
     Users of this class should not rely on default values to stay constant
     across service releases.`,
        since: 6
      }
    ],
    properties: [
      {
        signature: 'double Black',
        summary: 'Value considered lowest point in the displacement.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double BlackMove',
        summary: 'The amount of displacement for the black color in the texture.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int ChannelNumber',
        summary: 'Mapping channel number for the displacement mapping.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int FaceLimit',
        summary: `Runs a mesh reduction as a post process o simplify the result of
     displacement to meet the specified number of faces.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int FairingAmount',
        summary: `Straightens rough feature edges.
     The value specifies the number of passes.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Transform InstanceTransform',
        summary: 'Instance transformation of the mesh.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'TextureMapping Mapping',
        summary: 'The texture mapping of the mesh.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Transform MappingTransform',
        summary: 'Texture mapping transform.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int MemoryLimit',
        summary: `Specifies how much memory can be allocated for use by the
     displacement mesh. Value in megabytes.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double PostWeldAngle',
        summary: `Specifies the maximum angle between face normals of adjacent faces
     that will get welded together.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double RefineSensitivity',
        summary: `Specifies how sensitive the divider for contrasts is on the
     displacement texture.Specify 1 to split all mesh edges on each refine step.Specify 0.99 to make even slight contrasts on the displacement
     texture cause edges to be split.Specifying 0.01 only splits edges where heavy contrast
     exists.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int RefineStepCount',
        summary: 'Specifies the number of refinement passes.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double SweepPitch',
        summary: `Specifies how densely the object is initially subdivided.
     The lower the value, the higher the resolution of the displaced mesh.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'RenderTexture Texture',
        summary: 'The texture used as displacement.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double White',
        summary: 'Value considered highest point of the displacement texture.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double WhiteMove',
        summary: 'The amount of displacement for the white color in the texture.',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshExtruder',
    dataType: 1,
    summary: 'Extrudes a mesh and provides preview',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'MeshExtruder(Mesh inputMesh,IEnumerable<ComponentIndex> componentIndices)',
        summary: 'Construct object to extrude given mesh faces, edges and ngons.',
        since: 6.3,
        parameters: [
          {
            name: 'inputMesh',
            summary: 'Mesh to use as starting point. Will not be modified.'
          },
          {
            name: 'componentIndices',
            summary: 'Mesh faces, edges and ngons to extrude.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool EdgeBasedUVN',
        summary: 'Edge based UVN defines UVN directions according to boundary edge directions',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'MeshExtruderFaceDirectionMode FaceDirectionMode',
        summary: 'Face direction mode determines how faces are oriented',
        since: 6.3,
        property: ['get', 'set']
      },
      {
        signature: 'bool KeepOriginalFaces',
        summary: 'Whether or not to keep original faces.',
        since: 6.3,
        property: ['get', 'set']
      },
      {
        signature: 'Line[] PreviewLines',
        summary: 'Gets Line objects to preview extruded mesh.',
        since: 6.3,
        property: ['get']
      },
      {
        signature: 'MeshExtruderParameterMode SurfaceParameterMode',
        summary: 'Mode for creating surface parameters for extruded areas',
        since: 6.3,
        property: ['get', 'set']
      },
      {
        signature: 'MeshExtruderParameterMode TextureCoordinateMode',
        summary: 'Mode for creating texture coordinates for extruded areas',
        since: 6.3,
        property: ['get', 'set']
      },
      {
        signature: 'Transform Transform',
        summary: 'Transform of extrusion',
        since: 6.3,
        property: ['get', 'set']
      },
      {
        signature: 'bool UVN',
        summary: 'Whether or not to perform extrude in UVN basis.',
        since: 6.3,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Dispose of this object and any unmanaged memory associated with it.',
        since: 6.3
      },
      {
        signature: 'bool ExtrudedMesh(Mesh extrudedMeshOut)',
        summary: 'Creates new extruded mesh. Returns True if any edges or faces were extruded.',
        since: 6.3,
        parameters: [
          {
            name: 'extrudedMeshOut',
            summary: 'Extruded mesh'
          }
        ]
      },
      {
        signature: 'bool ExtrudedMesh(Mesh extrudedMeshOut,List<ComponentIndex> componentIndicesOut)',
        summary: 'Creates new extruded mesh. Returns True if any edges or faces were extruded.',
        parameters: [
          {
            name: 'extrudedMeshOut',
            summary: 'Extruded mesh'
          },
          {
            name: 'componentIndicesOut',
            summary: 'Component indices of extruded faces and vertices'
          }
        ]
      },
      {
        signature: 'List<int> GetWallFaces()',
        summary: 'Return list of faces that were added to connect transformed edges/faces to non-transformed edges/faces.',
        since: 6.16,
        returns: 'List of wall faces'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshExtruderFaceDirectionMode',
    dataType: 3,
    summary: 'Defines how mesh extruder decides orients faces',
    values: [
      {
        signature: 'Keep = 0',
        summary: 'Maintain all face directions'
      },
      {
        signature: 'OrientClosedFrontOut = 1',
        summary: 'Orient closed meshes front face out'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshExtruderParameterMode',
    dataType: 3,
    summary: 'Parameter mode for creating texture coordinates and surface parameters',
    values: [
      {
        signature: 'CoverWalls = 0',
        summary: 'Stretch parameters slightly on extruded faces to cover walls'
      },
      {
        signature: 'KeepAndStretch = 1',
        summary: 'Keep parameters on extruded faces and stretch on walls'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshFace',
    dataType: 2,
    summary: `Represents the values of the four indices of a mesh face quad.
   If the third and fourth values are the same, this face represents a
   triangle.`,
    constructors: [
      {
        signature: 'MeshFace(int a,int b,int c)',
        summary: 'Constructs a new triangular Mesh face.',
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'Index of first corner.'
          },
          {
            name: 'b',
            summary: 'Index of second corner.'
          },
          {
            name: 'c',
            summary: 'Index of third corner.'
          }
        ]
      },
      {
        signature: 'MeshFace(int a,int b,int c,int d)',
        summary: 'Constructs a new quadrangular Mesh face.',
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'Index of first corner.'
          },
          {
            name: 'b',
            summary: 'Index of second corner.'
          },
          {
            name: 'c',
            summary: 'Index of third corner.'
          },
          {
            name: 'd',
            summary: 'Index of fourth corner.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static MeshFace Unset',
        summary: 'Gets an Unset MeshFace. Unset faces have Int32.MinValue for all corner indices.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int A',
        summary: 'Gets or sets the first corner index of the mesh face.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int B',
        summary: 'Gets or sets the second corner index of the mesh face.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int C',
        summary: 'Gets or sets the third corner index of the mesh face.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int D',
        summary: `Gets or sets the fourth corner index of the mesh face. 
     If D equals C, the mesh face is considered to be a triangle 
     rather than a quad.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsQuad',
        summary: `Gets a value indicating whether or not this mesh face is a quad. 
     A mesh face is considered to be a triangle when C does not equal D, 
     thus it is possible for an Invalid mesh face to also be a quad.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsTriangle',
        summary: `Gets a value indicating whether or not this mesh face is a triangle. 
     A mesh face is considered to be a triangle when C equals D, thus it is 
     possible for an Invalid mesh face to also be a triangle.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'int CompareTo(MeshFace other)',
        summary: `Compares this MeshFace with another MeshFace
     and returns a value of 1, 0, or -1, referring to dictionary order.
     Index evaluation priority is first A, then B, then C, then D.`,
        since: 6,
        parameters: [
          {
            name: 'other',
            summary: 'The other MeshFace to use in comparison.'
          }
        ],
        returns: '0: if this is identical to other-1: if this < other. Priority is for index of corner A first, then B, then C, then D.+1: otherwise.'
      },
      {
        signature: 'bool Equals(MeshFace other)',
        summary: `Returns a value indicating whether the other mesh face
     has precisely the same value as the current one.`,
        since: 6,
        parameters: [
          {
            name: 'other',
            summary: 'The other mesh face for comparison.'
          }
        ],
        returns: `True if the other face is, also orderly, equal
     to the present one; otherwise false.`
      },
      {
        signature: 'bool Equals(object obj)',
        summary: `Returns a value indicating whether the other object obj
     has precisely the same value as the current one.`,
        parameters: [
          {
            name: 'obj',
            summary: 'Any object the represents the other mesh face for comparison.'
          }
        ],
        returns: `True if obj is a mesh face that, also orderly, equals
     to the present one; otherwise false.`
      },
      {
        signature: 'MeshFace Flip()',
        summary: `Reverses the orientation of the face by swapping corners. 
     The first corner is always maintained.`,
        since: 5
      },
      {
        signature: 'int GetHashCode()',
        summary: `Returns a runtime-stable hashcode for the current mesh face.
     You are not allowed to rely on persistance of this hashcode in
     serialization, but for each version of RhinoCommon, this hashcode
     will be the same for each mesh face.`,
        returns: 'A non-unique integer that represents this mesh face.'
      },
      {
        signature: 'bool IsValid()',
        summary: `Gets a value indicating whether or not this mesh face 
     is considered to be valid. Note that even valid mesh faces 
     could potentially be invalid in the context of a specific Mesh, 
     if one or more of the corner indices exceeds the number of 
     vertices on the mesh. If you want to perform a complete 
     validity check, use IsValid(int) instead.`,
        since: 5
      },
      {
        signature: 'bool IsValid(int vertexCount)',
        summary: `Gets a value indicating whether or not this mesh face 
     is considered to be valid. Unlike the simple IsValid function, 
     this function takes upper bound indices into account.`,
        since: 5,
        parameters: [
          {
            name: 'vertexCount',
            summary: 'Number of vertices in the mesh that this face is a part of.'
          }
        ],
        returns: 'True if the face is considered valid, False if not.'
      },
      {
        signature: 'bool IsValid(Point3d[] points)',
        summary: `Gets a value indicating whether or not this mesh face 
     is considered to be valid. Unlike the simple IsValid function, 
     this function takes actual point locations into account.`,
        since: 6,
        parameters: [
          {
            name: 'points',
            summary: 'Array of vertices with which to validate the face.'
          }
        ],
        returns: 'True if the face is considered valid, False if not.'
      },
      {
        signature: 'bool IsValidEx(Point3d[] points)',
        summary: `Gets a value indicating whether or not this mesh face 
     is considered to be valid. Unlike the simple IsValid function, 
     this function takes actual point locations into account.`,
        since: 6.5,
        parameters: [
          {
            name: 'points',
            summary: 'Array of vertices with which to validate the face.'
          }
        ],
        returns: 'True if the face is considered valid, False if not.'
      },
      {
        signature: 'bool Repair(Point3d[] points)',
        summary: `Attempts to repair this mesh face by taking both face indexes and 
     actual vertex locations into account.`,
        since: 6,
        parameters: [
          {
            name: 'points',
            summary: 'Array of vertices with which to consider when repairing the face.'
          }
        ],
        returns: 'True if the face was repaired, False if not.'
      },
      {
        signature: 'bool RepairEx(Point3d[] points)',
        summary: `Attempts to repair this mesh face by taking both face indexes and 
     actual vertex locations into account.`,
        since: 6.5,
        parameters: [
          {
            name: 'points',
            summary: 'Array of vertices with which to consider when repairing the face.'
          }
        ],
        returns: 'True if the face was repaired, False if not.'
      },
      {
        signature: 'void Set(int a,int b,int c)',
        summary: 'Sets all the corners for this face as a triangle.',
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'Index of first corner.'
          },
          {
            name: 'b',
            summary: 'Index of second corner.'
          },
          {
            name: 'c',
            summary: 'Index of third corner.'
          }
        ]
      },
      {
        signature: 'void Set(int a,int b,int c,int d)',
        summary: 'Sets all the corners for this face as a quad.',
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'Index of first corner.'
          },
          {
            name: 'b',
            summary: 'Index of second corner.'
          },
          {
            name: 'c',
            summary: 'Index of third corner.'
          },
          {
            name: 'd',
            summary: 'Index of fourth corner.'
          }
        ]
      },
      {
        signature: 'string ToString()',
        summary: `Returns a string representation for this MeshFace.
     This is to provide a meaningful visualization of this structure
     and is subject to change in newer releases.`,
        returns: 'The string representation.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshingParameters',
    dataType: 1,
    summary: 'Represents settings used for creating a mesh representation of a brep or surface.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'MeshingParameters()',
        summary: `Initializes a new instance with default values.
     Initial values are same as .`,
        since: 5
      },
      {
        signature: 'MeshingParameters(double density)',
        summary: `Initializes a new instance with simple values, 
     similar to that of Rhino's meshing slider interface.`,
        since: 6,
        parameters: [
          {
            name: 'density',
            summary: `The density and number of mesh polygons, where 0.0 <= density <= 1.0,
     where 0 quickly creates coarse meshes, and 1 slowly creates dense meshes.`
          }
        ]
      },
      {
        signature: 'MeshingParameters(double density,double minimumEdgeLength)',
        summary: `Initializes a new instance with simple values, 
     similar to that of Rhino's meshing slider interface.`,
        since: 6,
        parameters: [
          {
            name: 'density',
            summary: `The density and number of mesh polygons, where 0.0 <= density <= 1.0,
     where 0 quickly creates coarse meshes, and 1 slowly creates dense meshes.`
          },
          {
            name: 'minimumEdgeLength',
            summary: 'The minimum allowed mesh edge length.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static MeshingParameters Coarse',
        summary: `Gets mesh creation parameters for coarse meshing. 
     This corresponds with the "Jagged and Faster" default in Rhino.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'static MeshingParameters Default',
        summary: `Gets mesh creation parameters to create the default render mesh.
     Only use this if you plan on specifying your own custom meshing
     parameters.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'static MeshingParameters DefaultAnalysisMesh',
        summary: 'Gets mesh creation parameters to create the default analysis mesh.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static MeshingParameters FastRenderMesh',
        summary: `Gets mesh creation parameters to create the a render mesh when 
     meshing speed is prefered over mesh quality.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static MeshingParameters Minimal',
        summary: 'Gets minimal meshing parameters.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static MeshingParameters QualityRenderMesh',
        summary: `Gets mesh creation parameters to create the a render mesh when mesh 
     quality is prefered over meshing speed.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static MeshingParameters Smooth',
        summary: `Gets mesh creation parameters for smooth meshing. 
     This corresponds with the "Smooth and Slower" default in Rhino.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool ClosedObjectPostProcess',
        summary: `Gets or sets a value indicating whether or not to post process non-closed meshes
     that should be closed. If the Brep being meshed is closed, JaggedSeams = false, 
     and ClosedObjectPostProcess = true, and the resulting mesh is not closed, then a
     post meshing process is applied to find and close gaps in the mesh. Typically the
     resulting mesh is not closed because the input Brep has a geometric flaw, like
     loops in trimming curve.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ComputeCurvature',
        summary: `Gets or sets a value indicating whether or not surface curvature 
     data will be embedded in the mesh.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double GridAmplification',
        summary: `Gets or sets the grid amplification factor. 
     Values lower than 1.0 will decrease the number of initial quads, 
     values higher than 1.0 will increase the number of initial quads.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double GridAngle',
        summary: `Gets or sets the maximum allowed angle difference (in radians) 
     for a single sampling quad. The angle pertains to the surface normals.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double GridAspectRatio',
        summary: 'Gets or sets the maximum allowed aspect ratio of sampling quads.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int GridMaxCount',
        summary: 'Gets or sets the maximum number of grid quads in the initial sampling grid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int GridMinCount',
        summary: 'Gets or sets the minimum number of grid quads in the initial sampling grid.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool JaggedSeams',
        summary: `Gets or sets whether or not the mesh is allowed to have jagged seams. 
     When this flag is set to true, meshes on either side of a Brep Edge will not match up.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double MaximumEdgeLength',
        summary: 'Gets or sets the maximum allowed mesh edge length.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double MinimumEdgeLength',
        summary: 'Gets or sets the minimum allowed mesh edge length.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double MinimumTolerance',
        summary: 'Gets or sets the minimum tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double RefineAngle',
        summary: 'Gets or sets the mesh parameter refine angle.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool RefineGrid',
        summary: `Gets or sets a value indicating whether or not the sampling grid can be refined 
     when certain tolerances are not met.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double RelativeTolerance',
        summary: 'Gets or sets the relative tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool SimplePlanes',
        summary: `Gets or sets a value indicating whether or not planar areas are allowed 
     to be meshed in a simplified manner.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'MeshingParameterTextureRange TextureRange',
        summary: 'Gets or sets how and if textures will be packed.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double Tolerance',
        summary: `Gets or sets the maximum allowed edge deviation. 
     This tolerance is measured between the center of the mesh edge and the surface.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static MeshingParameters DocumentCurrentSetting(RhinoDoc doc)',
        summary: `Gets the MeshingParameters that are currently set for a document.
     These are the same settings that are shown in the DocumentProperties
     "mesh settings" user interface.`,
        since: 5,
        parameters: [
          {
            name: 'doc',
            summary: 'A Rhino document to query.'
          }
        ],
        returns: 'Meshing parameters of the document.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshingParameterStyle',
    dataType: 3,
    summary: 'Type of Mesh Parameters used by the RhinoDoc for meshing objects',
    values: [
      {
        signature: 'None = 0',
        summary: 'No style'
      },
      {
        signature: 'Fast = 1'
      },
      {
        signature: 'Quality = 2'
      },
      {
        signature: 'Custom = 9'
      },
      {
        signature: 'PerObject = 10'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshingParameterTextureRange',
    dataType: 3,
    summary: 'Defines how to pack render/meshes textures.',
    values: [
      {
        signature: 'Unset = 0',
        summary: 'This value is not set.'
      },
      {
        signature: 'UnpackedUnscaledNormalized = 1',
        summary: `Rach face has a normalized texture range [0,1]x[0,1].
     The normalized coordinate is calculated using the
     entire surface domain.  For meshes of trimmed
     surfaces when the active area is a small subset of
     the entire surface, there will be large regions of
     unused texture space in [0,1]x[0,1].  When the 3d region
     being meshed is far from being square-ish, there will be
     a substantual amount of distortion mapping [0,1]x[0,1]
     texture space to the 3d mesh.`
      },
      {
        signature: 'PackedScaledNormalized = 2',
        summary: `Each face is assigned a texture range that is a 
     subrectangle of [0,1]x[0,1].  The subrectangles are 
     mutually disjoint and packed into into [0,1]x[0,1]
     in a way that minimizes distortion and maximizes the
     coverage of [0,1]x[0,1].
     When the surface or surfaces being meshed are trimmed,
     this option takes into account only the region of the
     base surface the mesh covers and uses as much of 
     [0,1]x[0,1] as possible. (default)`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshNgon',
    dataType: 1,
    summary: `Represents a mesh ngon.
   When retrieved from the Ngon property of a mesh,
   this contains faces that have edge valence strictly higher than 4.When retrieving Ngons from ,
   this might contain also triangles and quads.`,
    interfaces: ['IEquatable<MeshNgon>', 'IComparable<MeshNgon>', 'IComparable'],
    properties: [
      {
        signature: 'static MeshNgon Empty',
        summary: 'Gets an empty MeshNgon.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int BoundaryVertexCount',
        summary: `Get the number of vertices in this ngon.
     MeshNgon about length information.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'int FaceCount',
        summary: 'Get the number of faces in this ngon.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static MeshNgon Create(IList<int> meshVertexIndexList,IList<int> meshFaceIndexList)',
        summary: 'Constructs an ngon from lists of mesh vertex and face indexes.',
        since: 6,
        parameters: [
          {
            name: 'meshVertexIndexList',
            summary: 'A list of mesh vertex indexes that define the outer boundary of the ngon. The mesh vertex indexes must be in the correct order.'
          },
          {
            name: 'meshFaceIndexList',
            summary: `A list of mesh face indexes that define the interior of the ngon. The mesh face indexes
     may be in any order.`
          }
        ]
      },
      {
        signature: 'uint[] BoundaryVertexIndexList()',
        summary: `Get the outer boundary mesh vertex list of the ngon.
     Vertices are sorted counterclockwise with respect to the direction of the face,
     although the degree by which vertex normals will respect this might vary.`,
        since: 6,
        returns: 'A list of mesh vertex indexes.'
      },
      {
        signature: 'int CompareTo(MeshNgon otherNgon)',
        summary: `Compares this MeshNgon with otherNgon
     and returns a value of 1, 0, or -1.
     Priority is for vertex count, then face count,
     then vertex index list values, then face index list values.`,
        since: 6,
        parameters: [
          {
            name: 'otherNgon',
            summary: 'The other MeshNgon to use in comparison.'
          }
        ],
        returns: '0: if this is identical to otherNgon-1: if this < otherNgon. +1: if this > otherNgon.'
      },
      {
        signature: 'bool Equals(MeshNgon otherNgon)',
        summary: 'Determines if this ngon and otherNgon are identical.',
        since: 6,
        parameters: [
          {
            name: 'otherNgon',
            summary: 'The other ngon for comparison.'
          }
        ],
        returns: 'True if otherNgon is identical to this ngon; otherwise false.'
      },
      {
        signature: 'bool Equals(object otherObj)',
        summary: 'Determines if otherObj is a MeshNgon and is identical to this ngon.',
        parameters: [
          {
            name: 'otherObj',
            summary: 'Any object the represents the other mesh face for comparison.'
          }
        ],
        returns: 'True if otherObj is a MeshNgon and is identical to this ngon; otherwise false.'
      },
      {
        signature: 'uint[] FaceIndexList()',
        summary: 'Get the ngon\'s mesh face index list.',
        since: 6,
        returns: 'A list of mesh face indexes.'
      },
      {
        signature: 'int GetHashCode()',
        summary: `Returns a runtime-stable hashcode for the current mesh ngon.
     You are not allowed to rely on persistance of this hashcode in
     serialization, but for each instance of the application, this hashcode
     will be the same for ngons with identical vertex and face lists.`,
        returns: 'A non-unique integer that represents this mesh ngon.'
      },
      {
        signature: 'void Set(IList<int> meshVertexIndexList,IList<int> meshFaceIndexList)',
        summary: 'Set the ngon vertex and face index lists.',
        since: 6,
        parameters: [
          {
            name: 'meshVertexIndexList',
            summary: 'A list of mesh vertex indexes that define the outer boundary of the ngon. The mesh vertex indexes must be in the correct order.'
          },
          {
            name: 'meshFaceIndexList',
            summary: `A list of mesh face indexes that define the interior of the ngon. The mesh face indexes
     may be in any order.`
          }
        ]
      },
      {
        signature: 'string ToString()',
        summary: `Returns a string representation for this MeshNgon.
     This is to provide a meaningful visualization of this structure
     and is subject to change in newer releases.`,
        returns: 'The string representation.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshPart',
    dataType: 1,
    summary: 'Represents a portion of a mesh for partitioning',
    properties: [
      {
        signature: 'int EndFaceIndex',
        summary: 'End of subinterval of parent mesh face array',
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'int EndVertexIndex',
        summary: 'End of subinterval of parent mesh vertex array',
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'int StartFaceIndex',
        summary: 'Start of subinterval of parent mesh face array',
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'int StartVertexIndex',
        summary: 'Start of subinterval of parent mesh vertex array',
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'int TriangleCount',
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'int VertexCount',
        summary: 'EndVertexIndex - StartVertexIndex',
        since: 5.6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshPipeCapStyle',
    dataType: 3,
    summary: 'Enumerates methods to end a mesh pipe.',
    values: [
      {
        signature: 'None = 0',
        summary: 'Capping is skipped. The resulting object will be simpler.'
      },
      {
        signature: 'Flat = 1',
        summary: 'A flat surface will cap the pipe.'
      },
      {
        signature: 'Box = 2',
        summary: 'A simple construction will cap the pipe.'
      },
      {
        signature: 'Dome = 3',
        summary: 'A meridians-and-parallels hemisphere construction will cap the pipe.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshPoint',
    dataType: 1,
    summary: 'Represents a point that is found on a mesh.',
    properties: [
      {
        signature: 'ComponentIndex ComponentIndex',
        summary: 'Gets the component index of the intersecting element in the mesh.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int EdgeIndex',
        summary: 'When set, EdgeIndex is an index of an edge in the mesh\'s edge list.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double EdgeParameter',
        summary: 'Edge parameter when found.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int FaceIndex',
        summary: `FaceIndex is an index of a face in mesh.Faces.
     When ComponentIndex refers to a vertex, any face that uses the vertex
     may appear as FaceIndex.  When ComponenctIndex refers to an Edge or
     EdgeIndex is set, then any face that uses that edge may appear as FaceIndex.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Mesh Mesh',
        summary: 'The mesh that is ralated to this point.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d Point',
        summary: 'Gets the location (position) of this point.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double[] T',
        summary: `Barycentric quad coordinates for the point on the mesh
     face mesh.Faces[FaceIndex].  If the face is a triangle
     disregard T[3] (it should be set to 0.0). If the face is
     a quad and is split between vertexes 0 and 2, then T[3]
     will be 0.0 when point is on the triangle defined by vi[0],
     vi[1], vi[2], and T[1] will be 0.0 when point is on the
     triangle defined by vi[0], vi[2], vi[3]. If the face is a
     quad and is split between vertexes 1 and 3, then T[2] will
     be 0.0 when point is on the triangle defined by vi[0],
     vi[1], vi[3], and m_t[0] will be 0.0 when point is on the
     triangle defined by vi[1], vi[2], vi[3].`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'char Triangle',
        summary: `Face triangle where the intersection takes place:
     0 is unsetA is 0,1,2B is 0,2,3C is 0,1,3D is 1,2,3`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool GetTriangle(int a,int b,int c)',
        summary: `Gets the mesh face indices of the triangle where the
     intersection is on the face takes into consideration
     the way the quad was split during the intersection.`,
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.MeshRefinements',
    name: 'CreaseEdges',
    dataType: 3,
    summary: 'Defines the way naked edges are handled.',
    values: [
      {
        signature: '    NakedFixed',
        summary: 'Naked edges will not move or be modified.'
      },
      {
        signature: '    NakedSmooth',
        summary: 'The naked edge will tend toward a spline.'
      },
      {
        signature: '    CornerFixedOtherCreased',
        summary: 'Corners (2-sided vertices) will be fixed, while other naked vertices will tend toward a spline.'
      },
      {
        signature: '    Auto = 3',
        summary: 'Unwelded vertices become creases, and welded are smooth.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.MeshRefinements',
    name: 'LoopFormula',
    dataType: 3,
    summary: 'Enumerates the alternative Loop implementations.',
    values: [
      {
        signature: 'Loop = 0',
        summary: 'The original Loop formula.'
      },
      {
        signature: 'Warren = 1',
        summary: 'Warren\'s improved formula.'
      },
      {
        signature: 'WarrenWeimer = 2',
        summary: 'The formula as explained by Weimer, improving over Warren\'s.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.MeshRefinements',
    name: 'RefinementSettings',
    dataType: 1,
    summary: 'Defines the way a mesh refinement modifier works.',
    constructors: [
      {
        signature: 'RefinementSettings()',
        summary: 'Creates a default operation settings object.',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'CancellationToken ContinueRequest',
        summary: 'A token to request computation termination.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool HasPull',
        summary: 'Gets a value indicating whether this subdivision should create a result on a specific surface.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int Level',
        summary: 'The level of subdivision to achieve.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'CreaseEdges NakedEdgeMode',
        summary: 'Set this property to define how naked edges should be treated.',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshThicknessMeasurement',
    dataType: 2,
    summary: 'Thickness measurement used in the mesh thickness solver.',
    constructors: [
      {
        signature: 'MeshThicknessMeasurement(int meshIndex,int vertexIndex,double thickness,Point3d point,Point3d oppositePoint)',
        summary: 'Create a new thickness measurement.',
        since: 6,
        parameters: [
          {
            name: 'meshIndex',
            summary: 'Index of mesh within collection of meshes.'
          },
          {
            name: 'vertexIndex',
            summary: 'Index of mesh vertex.'
          },
          {
            name: 'thickness',
            summary: 'Thickness of mesh at vertex.'
          },
          {
            name: 'point',
            summary: 'Vertex location.'
          },
          {
            name: 'oppositePoint',
            summary: 'Opposite location.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int MeshIndex',
        summary: 'Gets the index of the mesh associated with this thickness measurement.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Point3d OppositePoint',
        summary: 'Gets the point opposite to the measurement point.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Point3d Point',
        summary: 'Gets the location of the thickness measurement.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'double Thickness',
        summary: 'Gets the local thickness of the mesh.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int VertexIndex',
        summary: 'Gets the index of the vertex associated with this thickness measurement.',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshType',
    dataType: 3,
    summary: 'Defines enumerated values for various mesh types.',
    values: [
      {
        signature: 'Default = 0',
        summary: 'The default mesh.'
      },
      {
        signature: 'Render = 1',
        summary: 'The render mesh.'
      },
      {
        signature: 'Analysis = 2',
        summary: 'The analysis mesh.'
      },
      {
        signature: 'Preview = 3',
        summary: 'The preview mesh.'
      },
      {
        signature: 'Any = 4',
        summary: 'Any mesh that is available.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MeshUnsafeLock',
    dataType: 1,
    summary: 'Permits access to the underlying mesh raw data structures in an unsafe way.',
    interfaces: ['IDisposable'],
    methods: [
      {
        signature: 'MeshFace* FacesArray(int length)',
        summary: `Retrieves a pointer to the raw faces array, which uses 4 integers for each face.
     MeshFace.`,
        since: 6.2,
        parameters: [
          {
            name: 'length',
            summary: 'The length of the array. This value is returned by reference (out in C#).'
          }
        ],
        returns: `The beginning of the vertex array. Item 0 is the first vertex,
     and item length-1 is the last valid one.`
      },
      {
        signature: 'Vector3f* NormalVector3fArray(int length)',
        summary: `Retrieves a pointer to the raw mesh vertex normal array, which uses vectors
     defined with single precision floating point numbers, or throws an exception if none is available.`,
        since: 6.2,
        parameters: [
          {
            name: 'length',
            summary: 'The length of the array. This value is returned by reference (out in C#).'
          }
        ],
        returns: `The beginning of the vertex array. Item 0 is the first vertex,
     and item length-1 is the last valid one.`
      },
      {
        signature: 'void Release()',
        summary: 'Releases the lock and updates the underlying unmanaged data structures.',
        since: 6
      },
      {
        signature: 'Point3d* VertexPoint3dArray(int length)',
        summary: `Retrieves a pointer to the raw mesh vertex array, which uses coordinates
     defined with double precision floating point numbers, or throws an exception if none is available.`,
        since: 6.2,
        parameters: [
          {
            name: 'length',
            summary: 'The length of the array. This value is returned by reference (out in C#).'
          }
        ],
        returns: `The beginning of the vertex array. Item 0 is the first vertex,
     and item length-1 is the last valid one. If no array is available, None is returned.`
      },
      {
        signature: 'Point3f* VertexPoint3fArray(int length)',
        summary: `Retrieves a pointer to the raw mesh vertex array, which uses coordinates
     defined with single precision floating point numbers, or None if none is available.`,
        since: 6,
        parameters: [
          {
            name: 'length',
            summary: `The length of the array. This value is returned by reference (out in C#).
     0 is returned when there is no single precision array.`
          }
        ],
        returns: `The beginning of the vertex array. Item 0 is the first vertex,
     and item length-1 is the last valid one. If no array is available, None is returned.`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'MorphControl',
    dataType: 1,
    summary: 'Represents a geometry that is able to control the morphing behaviour of some other geometry.',
    baseclass: 'Rhino.Geometry.GeometryBase',
    constructors: [
      {
        signature: 'MorphControl(NurbsCurve originCurve,NurbsCurve targetCurve)',
        summary: 'Constructs a MorphControl that allows for morphing between two curves.',
        since: 5,
        parameters: [
          {
            name: 'originCurve',
            summary: 'The origin curve for morphing.'
          },
          {
            name: 'targetCurve',
            summary: 'The target curve for morphing.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'NurbsCurve Curve',
        summary: `Returns the morph control's curve.  While this should never be null, the 
     calling function should check.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool PreserveStructure',
        summary: `True if the morph should be done in a way that preserves the structure
     of the geometry.  In particular, for NURBS objects, True  eans that
     only the control points are moved.  The PreserveStructure value does not
     affect the way meshes and points are morphed. The default is false.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool QuickPreview',
        summary: `True if the morph should be done as quickly as possible because the
     result is being used for some type of dynamic preview.  If QuickPreview
     is true, the tolerance may be ignored. The QuickPreview value does not
     affect the way meshes and points are morphed. The default is false.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double SpaceMorphTolerance',
        summary: `The 3d fitting tolerance used when morphing surfaces and breps.
     The default is 0.0 and any value <= 0.0 is ignored by morphing functions.
     The value returned by Tolerance does not affect the way meshes and points are morphed.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'NurbsSurface Surface',
        summary: `Returns the morph control's surface.  While this should never be null, the 
     calling function should check.`,
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool Morph(GeometryBase geometry)',
        summary: 'Applies the space morph to geometry.',
        since: 5,
        parameters: [
          {
            name: 'geometry',
            summary: 'The geometry to be morphed.'
          }
        ],
        returns: 'True on success, False on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Morphs',
    name: 'BendSpaceMorph',
    dataType: 1,
    summary: 'Deforms objects by bending along a spine arc.',
    baseclass: 'Rhino.Geometry.SpaceMorph',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'BendSpaceMorph(Point3d start,Point3d end,Point3d point,bool straight,bool symmetric)',
        summary: 'Constructs a bend space morph.',
        since: 5.9,
        parameters: [
          {
            name: 'start',
            summary: 'Start of spine that represents the original orientation of the object.'
          },
          {
            name: 'end',
            summary: 'End of spine.'
          },
          {
            name: 'point',
            summary: 'Point to bend through.'
          },
          {
            name: 'straight',
            summary: 'If false, then point determines the region to bend. If true, only the spine region is bent.'
          },
          {
            name: 'symmetric',
            summary: 'If false, then only one end of the object bends. If true, then the object will bend symmetrically around the center if you start the spine in the middle of the object.'
          }
        ]
      },
      {
        signature: 'BendSpaceMorph(Point3d start,Point3d end,Point3d point,double angle,bool straight,bool symmetric)',
        summary: 'Constructs a bend space morph.',
        since: 5.9,
        parameters: [
          {
            name: 'start',
            summary: 'Start of spine that represents the original orientation of the object.'
          },
          {
            name: 'end',
            summary: 'End of spine.'
          },
          {
            name: 'point',
            summary: 'Used for bend direction.'
          },
          {
            name: 'angle',
            summary: 'Bend angle in radians.'
          },
          {
            name: 'straight',
            summary: 'If false, then point determines the region to bend. If true, only the spine region is bent.'
          },
          {
            name: 'symmetric',
            summary: 'If false, then only one end of the object bends. If true, then the object will bend symmetrically around the center if you start the spine in the middle of the object.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool IsValid',
        summary: 'Returns True if the space morph definition is valid, False otherwise.',
        since: 5.9,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5.9
      },
      {
        signature: 'Point3d MorphPoint(Point3d point)',
        summary: 'Morphs an Euclidean point.',
        since: 5.9,
        parameters: [
          {
            name: 'point',
            summary: 'A point that will be morphed by this object.'
          }
        ],
        returns: 'Resulting morphed point.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Morphs',
    name: 'FlowSpaceMorph',
    dataType: 1,
    summary: 'Re-aligns objects from a base curve to a target curve.',
    baseclass: 'Rhino.Geometry.SpaceMorph',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'FlowSpaceMorph(Curve curve0,Curve curve1,bool preventStretching)',
        summary: 'Constructs a flow space morph.',
        since: 5.9,
        parameters: [
          {
            name: 'curve0',
            summary: 'Base curve.'
          },
          {
            name: 'curve1',
            summary: 'Target curve.'
          },
          {
            name: 'preventStretching',
            summary: ''
          }
        ]
      },
      {
        signature: 'FlowSpaceMorph(Curve curve0,Curve curve1,bool reverseCurve0,bool reverseCurve1,bool preventStretching)',
        summary: 'Constructs a flow space morph.',
        since: 5.9,
        parameters: [
          {
            name: 'curve0',
            summary: 'Base curve.'
          },
          {
            name: 'curve1',
            summary: 'Target curve.'
          },
          {
            name: 'reverseCurve0',
            summary: 'If true, then direction of curve0 is reversed.'
          },
          {
            name: 'reverseCurve1',
            summary: 'If true, then direction of curve1 is reversed.'
          },
          {
            name: 'preventStretching',
            summary: 'If true, the length of the objects along the curve directions are not changed. If false, objects are stretched or compressed in the curve direction so that the relationship to the target curve is the same as it is to the base curve.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool IsValid',
        summary: 'Returns True if the space morph definition is valid, False otherwise.',
        since: 5.9,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5.9
      },
      {
        signature: 'Point3d MorphPoint(Point3d point)',
        summary: 'Morphs an Euclidean point.',
        since: 5.9,
        parameters: [
          {
            name: 'point',
            summary: 'A point that will be morphed by this object.'
          }
        ],
        returns: 'Resulting morphed point.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Morphs',
    name: 'MaelstromSpaceMorph',
    dataType: 1,
    summary: 'Deforms objects in a spiral as if they were caught in a whirlpool.',
    baseclass: 'Rhino.Geometry.SpaceMorph',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'MaelstromSpaceMorph(Plane plane,double radius0,double radius1,double angle)',
        summary: 'Constructs a maelstrom space morph.',
        since: 5.9,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane on which the base circle will lie. Origin of the plane will be the center point of the circle.'
          },
          {
            name: 'radius0',
            summary: 'First radius.'
          },
          {
            name: 'radius1',
            summary: 'Second radius.'
          },
          {
            name: 'angle',
            summary: 'Coil angle in radians.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool IsValid',
        summary: 'Returns True if the space morph definition is valid, False otherwise.',
        since: 5.9,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5.9
      },
      {
        signature: 'Point3d MorphPoint(Point3d point)',
        summary: 'Morphs an Euclidean point.',
        since: 5.9,
        parameters: [
          {
            name: 'point',
            summary: 'A point that will be morphed by this object.'
          }
        ],
        returns: 'Resulting morphed point.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Morphs',
    name: 'SplopSpaceMorph',
    dataType: 1,
    summary: 'Rotates, scales, and wraps objects on a surface.',
    baseclass: 'Rhino.Geometry.SpaceMorph',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SplopSpaceMorph(Plane plane,Surface surface,Point2d surfaceParam)',
        summary: 'Constructs a flow space morph.',
        since: 5.9,
        parameters: [
          {
            name: 'plane',
            summary: 'Source plane of deformation.'
          },
          {
            name: 'surface',
            summary: 'Surface to wrap objects onto.'
          },
          {
            name: 'surfaceParam',
            summary: 'U,V parameter on surface used for orienting.'
          }
        ]
      },
      {
        signature: 'SplopSpaceMorph(Plane plane,Surface surface,Point2d surfaceParam,double scale)',
        summary: 'Constructs a flow space morph.',
        since: 5.9,
        parameters: [
          {
            name: 'plane',
            summary: 'Source plane of deformation.'
          },
          {
            name: 'surface',
            summary: 'Surface to wrap objects onto.'
          },
          {
            name: 'surfaceParam',
            summary: 'U,V parameter on surface used for orienting.'
          },
          {
            name: 'scale',
            summary: 'Scale factor.'
          }
        ]
      },
      {
        signature: 'SplopSpaceMorph(Plane plane,Surface surface,Point2d surfaceParam,double scale,double angle)',
        summary: 'Constructs a flow space morph.',
        since: 5.9,
        parameters: [
          {
            name: 'plane',
            summary: 'Source plane of deformation.'
          },
          {
            name: 'surface',
            summary: 'Surface to wrap objects onto.'
          },
          {
            name: 'surfaceParam',
            summary: 'U,V parameter on surface used for orienting.'
          },
          {
            name: 'scale',
            summary: 'Scale factor. To ignore, use Rhino.RhinoMath.UnsetValue.'
          },
          {
            name: 'angle',
            summary: 'Rotation angle in radians. To ignore, use Rhino.RhinoMath.UnsetValue.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool IsValid',
        summary: 'Returns True if the space morph definition is valid, False otherwise.',
        since: 5.9,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5.9
      },
      {
        signature: 'Point3d MorphPoint(Point3d point)',
        summary: 'Morphs an Euclidean point.',
        since: 5.9,
        parameters: [
          {
            name: 'point',
            summary: 'A point that will be morphed by this object.'
          }
        ],
        returns: 'Resulting morphed point.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Morphs',
    name: 'SporphSpaceMorph',
    dataType: 1,
    summary: 'Deforms an object from a source surface to a target surface.',
    baseclass: 'Rhino.Geometry.SpaceMorph',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SporphSpaceMorph(Surface surface0,Surface surface1)',
        summary: 'Constructs a sporph space morph.',
        since: 5.9,
        parameters: [
          {
            name: 'surface0',
            summary: 'Base surface.'
          },
          {
            name: 'surface1',
            summary: 'Target surface.'
          }
        ]
      },
      {
        signature: 'SporphSpaceMorph(Surface surface0,Surface surface1,Point2d surface0Param,Point2d surface1Param)',
        summary: 'Constructs a sporph space morph.',
        since: 5.9,
        parameters: [
          {
            name: 'surface0',
            summary: 'Base surface.'
          },
          {
            name: 'surface1',
            summary: 'Target surface.'
          },
          {
            name: 'surface0Param',
            summary: 'U,V parameter on surface0 used for orienting.'
          },
          {
            name: 'surface1Param',
            summary: 'U,V parameter on surface1 used for orienting.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool IsValid',
        summary: 'Returns True if the space morph definition is valid, False otherwise.',
        since: 5.9,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5.9
      },
      {
        signature: 'Point3d MorphPoint(Point3d point)',
        summary: 'Morphs an Euclidean point.',
        since: 5.9,
        parameters: [
          {
            name: 'point',
            summary: 'A point that will be morphed by this object.'
          }
        ],
        returns: 'Resulting morphed point.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Morphs',
    name: 'StretchSpaceMorph',
    dataType: 1,
    summary: 'Deforms objects toward or away from a specified axis.',
    baseclass: 'Rhino.Geometry.SpaceMorph',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'StretchSpaceMorph(Point3d start,Point3d end,double length)',
        summary: 'Constructs a stretch space morph.',
        since: 5.9,
        parameters: [
          {
            name: 'start',
            summary: 'Start of stretch axis.'
          },
          {
            name: 'end',
            summary: 'End of stretch axis.>'
          },
          {
            name: 'length',
            summary: 'Length of new stretch axis.'
          }
        ]
      },
      {
        signature: 'StretchSpaceMorph(Point3d start,Point3d end,Point3d point)',
        summary: 'Constructs a stretch space morph.',
        since: 5.9,
        parameters: [
          {
            name: 'start',
            summary: 'Start of stretch axis.'
          },
          {
            name: 'end',
            summary: 'End of stretch axis.>'
          },
          {
            name: 'point',
            summary: 'End of new stretch axis.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool IsValid',
        summary: 'Returns True if the space morph definition is valid, False otherwise.',
        since: 5.9,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5.9
      },
      {
        signature: 'Point3d MorphPoint(Point3d point)',
        summary: 'Morphs an Euclidean point.',
        since: 5.9,
        parameters: [
          {
            name: 'point',
            summary: 'A point that will be morphed by this object.'
          }
        ],
        returns: 'Resulting morphed point.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Morphs',
    name: 'TaperSpaceMorph',
    dataType: 1,
    summary: 'Deforms objects toward or away from a specified axis.',
    baseclass: 'Rhino.Geometry.SpaceMorph',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'TaperSpaceMorph(Point3d start,Point3d end,double startRadius,double endRadius,bool bFlat,bool infiniteTaper)',
        summary: 'Constructs a taper space morph.',
        since: 5.9,
        parameters: [
          {
            name: 'start',
            summary: 'Start of the taper axis.'
          },
          {
            name: 'end',
            summary: 'End of the taper axis.'
          },
          {
            name: 'startRadius',
            summary: 'Radius at start point.'
          },
          {
            name: 'endRadius',
            summary: 'Radius at end point.'
          },
          {
            name: 'bFlat',
            summary: 'If true, then a one-directional, one-dimensional taper is created.'
          },
          {
            name: 'infiniteTaper',
            summary: 'If false, the deformation takes place only the length of the axis. If true, the deformation happens throughout the object, even if the axis is shorter.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool IsValid',
        summary: 'Returns True if the space morph definition is valid, False otherwise.',
        since: 5.9,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5.9
      },
      {
        signature: 'Point3d MorphPoint(Point3d point)',
        summary: 'Morphs an Euclidean point.',
        since: 5.9,
        parameters: [
          {
            name: 'point',
            summary: 'A point that will be morphed by this object.'
          }
        ],
        returns: 'Resulting morphed point.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry.Morphs',
    name: 'TwistSpaceMorph',
    dataType: 1,
    summary: 'Deforms objects by rotating them around an axis.',
    baseclass: 'Rhino.Geometry.SpaceMorph',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'TwistSpaceMorph()',
        summary: 'Constructs a twist space morph.',
        since: 5.1
      }
    ],
    properties: [
      {
        signature: 'bool InfiniteTwist',
        summary: `If true, the deformation is constant throughout the object, even if the axis is shorter than the object. 
     If false, the deformation takes place only the length of the axis.`,
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'double TwistAngleRadians',
        summary: 'Twist angle in radians.',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Line TwistAxis',
        summary: 'Axis to rotate about.',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5.1
      },
      {
        signature: 'Point3d MorphPoint(Point3d point)',
        summary: 'Morphs an Euclidean point. This method is abstract.',
        since: 5.1,
        parameters: [
          {
            name: 'point',
            summary: 'A point that will be morphed by this function.'
          }
        ],
        returns: 'Resulting morphed point.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'NurbsCurve',
    dataType: 1,
    summary: 'Represents a Non Uniform Rational B-Splines (NURBS) curve.',
    baseclass: 'Rhino.Geometry.Curve',
    interfaces: ['IEpsilonComparable<NurbsCurve>'],
    constructors: [
      {
        signature: 'NurbsCurve(int dimension,bool rational,int order,int pointCount)',
        summary: 'Constructs a new NURBS curve with knot and CV memory allocated.',
        since: 5,
        parameters: [
          {
            name: 'dimension',
            summary: '>=1.'
          },
          {
            name: 'rational',
            summary: 'True to make a rational NURBS.'
          },
          {
            name: 'order',
            summary: '(>= 2) The order=degree+1.'
          },
          {
            name: 'pointCount',
            summary: '(>= order) number of control vertices.'
          }
        ]
      },
      {
        signature: 'NurbsCurve(int degree,int pointCount)',
        summary: 'Constructs a new NURBS curve with a specific degree and control point count.',
        since: 5,
        parameters: [
          {
            name: 'degree',
            summary: 'Degree of curve. Must be equal to or larger than 1 and smaller than or equal to 11.'
          },
          {
            name: 'pointCount',
            summary: 'Number of control-points.'
          }
        ]
      },
      {
        signature: 'NurbsCurve(NurbsCurve other)',
        summary: 'Initializes a NURBS curve by copying its values from another NURBS curve.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The other curve. This value can be null.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool HasBezierSpans',
        summary: 'Returns True if the NURBS curve has bezier spans (all distinct knots have multiplitity = degree)',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsRational',
        summary: `Gets a value indicating whether or not the curve is rational. 
     Rational curves have control-points with custom weights.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'NurbsCurveKnotList Knots',
        summary: 'Gets access to the knots (or "knot vector") of this nurbs curve.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Order',
        summary: 'Gets the order of the curve. Order = Degree + 1.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'NurbsCurvePointList Points',
        summary: 'Gets access to the control points of this nurbs curve.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static NurbsCurve Create(bool periodic,int degree,IEnumerable<Point3d> points)',
        summary: 'Constructs a 3D NURBS curve from a list of control points.',
        since: 5,
        parameters: [
          {
            name: 'periodic',
            summary: 'If true, create a periodic uniform curve. If false, create a clamped uniform curve.'
          },
          {
            name: 'degree',
            summary: '(>=1) degree=order-1.'
          },
          {
            name: 'points',
            summary: 'control vertex locations.'
          }
        ],
        returns: `new NURBS curve on success
     None on error.`
      },
      {
        signature: 'static NurbsCurve CreateFromArc(Arc arc)',
        summary: `Gets a rational degree 2 NURBS curve representation
     of the arc. Note that the parameterization of NURBS curve
     does not match arc's transcendental paramaterization.`,
        since: 5,
        returns: 'Curve on success, None on failure.'
      },
      {
        signature: 'static NurbsCurve CreateFromArc(Arc arc,int degree,int cvCount)',
        summary: 'Create a uniform non-ratonal cubic NURBS approximation of an arc.',
        since: 6,
        parameters: [
          {
            name: 'arc',
            summary: ''
          },
          {
            name: 'degree',
            summary: '>=1'
          },
          {
            name: 'cvCount',
            summary: 'cv count >=5'
          }
        ],
        returns: 'NURBS curve approximation of an arc on success'
      },
      {
        signature: 'static NurbsCurve CreateFromCircle(Circle circle)',
        summary: `Gets a rational degree 2 NURBS curve representation
     of the circle. Note that the parameterization of NURBS curve
     does not match circle's transcendental paramaterization.  
     Use GetRadianFromNurbFormParameter() and
     GetParameterFromRadian() to convert between the NURBS curve 
     parameter and the transcendental parameter.`,
        since: 5,
        returns: 'Curve on success, None on failure.'
      },
      {
        signature: 'static NurbsCurve CreateFromCircle(Circle circle,int degree,int cvCount)',
        summary: 'Create a uniform non-ratonal cubic NURBS approximation of a circle.',
        since: 6,
        parameters: [
          {
            name: 'circle',
            summary: ''
          },
          {
            name: 'degree',
            summary: '>=1'
          },
          {
            name: 'cvCount',
            summary: 'cv count >=5'
          }
        ],
        returns: 'NURBS curve approximation of a circle on success'
      },
      {
        signature: 'static NurbsCurve CreateFromEllipse(Ellipse ellipse)',
        summary: `Gets a rational degree 2 NURBS curve representation of the ellipse.
     Note that the parameterization of the NURBS curve does not match
     with the transcendental paramaterization of the ellipsis.`,
        since: 5,
        returns: 'A nurbs curve representation of this ellipse or None if no such representation could be made.'
      },
      {
        signature: 'static NurbsCurve CreateFromLine(Line line)',
        summary: 'Gets a non-rational, degree 1 Nurbs curve representation of the line.',
        since: 5,
        returns: 'Curve on success, None on failure.'
      },
      {
        signature: 'static NurbsCurve CreateHSpline(IEnumerable<Point3d> points)',
        summary: 'Construct an H-spline from a sequence of interpolation points',
        since: 7,
        parameters: [
          {
            name: 'points',
            summary: 'Points to interpolate'
          }
        ]
      },
      {
        signature: 'static NurbsCurve CreateHSpline(IEnumerable<Point3d> points,Vector3d startTangent,Vector3d endTangent)',
        summary: `Construct an H-spline from a sequence of interpolation points and
     optional start and end derivative information`,
        since: 7,
        parameters: [
          {
            name: 'points',
            summary: 'Points to interpolate'
          },
          {
            name: 'startTangent',
            summary: 'Unit tangent vector or Unset'
          },
          {
            name: 'endTangent',
            summary: 'Unit tangent vector or Unset'
          }
        ]
      },
      {
        signature: 'static NurbsCurve CreateParabolaFromFocus(Point3d focus,Point3d startPoint,Point3d endPoint)',
        summary: 'Creates a parabola from focus and end points.',
        since: 6,
        parameters: [
          {
            name: 'focus',
            summary: 'The focal point.'
          },
          {
            name: 'startPoint',
            summary: 'The start point.'
          },
          {
            name: 'endPoint',
            summary: 'The end point'
          }
        ],
        returns: 'A 2 degree NURBS curve if successful, False otherwise.'
      },
      {
        signature: 'static NurbsCurve CreateParabolaFromVertex(Point3d vertex,Point3d startPoint,Point3d endPoint)',
        summary: 'Createsa a parabola from vertex and end points.',
        since: 6,
        parameters: [
          {
            name: 'vertex',
            summary: 'The vertex point.'
          },
          {
            name: 'startPoint',
            summary: 'The start point.'
          },
          {
            name: 'endPoint',
            summary: 'The end point'
          }
        ],
        returns: 'A 2 degree NURBS curve if successful, False otherwise.'
      },
      {
        signature: 'static NurbsCurve CreateSpiral(Curve railCurve,double t0,double t1,Point3d radiusPoint,double pitch,double turnCount,double radius0,double radius1,int pointsPerTurn)',
        summary: 'Create a C2 non-rational uniform cubic NURBS approximation of a swept helix or spiral.',
        since: 5.2,
        parameters: [
          {
            name: 'railCurve',
            summary: 'The rail curve.'
          },
          {
            name: 't0',
            summary: 'Starting portion of rail curve\'s domain to sweep along.'
          },
          {
            name: 't1',
            summary: 'Ending portion of rail curve\'s domain to sweep along.'
          },
          {
            name: 'radiusPoint',
            summary: `Point used only to get a vector that is perpedicular to the axis. In
     particular, this vector must not be (anti)parallel to the axis vector.`
          },
          {
            name: 'pitch',
            summary: `The pitch. Positive values produce counter-clockwise orientation,
     negative values produce clockwise orientation.`
          },
          {
            name: 'turnCount',
            summary: `The turn count. If != 0, then the resulting helix will have this many
     turns. If = 0, then pitch must be != 0 and the approximate distance
     between turns will be set to pitch. Positive values produce counter-clockwise
     orientation, negitive values produce clockwise orientation.`
          },
          {
            name: 'radius0',
            summary: `The starting radius. At least one radii must benonzero. Negative values
     are allowed.`
          },
          {
            name: 'radius1',
            summary: `The ending radius. At least ont radii must be nonzero. Negative values
     are allowed.`
          },
          {
            name: 'pointsPerTurn',
            summary: `Number of points to intepolate per turn. Must be greater than 4.
     When in doubt, use 12.`
          }
        ],
        returns: 'NurbsCurve on success, None on failure.'
      },
      {
        signature: 'static NurbsCurve CreateSpiral(Point3d axisStart,Vector3d axisDir,Point3d radiusPoint,double pitch,double turnCount,double radius0,double radius1)',
        summary: `Creates a C1 cubic NURBS approximation of a helix or spiral. For a helix,
     you may have radius0 == radius1. For a spiral radius0 == radius0 produces
     a circle. Zero and negative radii are permissible.`,
        since: 5.2,
        parameters: [
          {
            name: 'axisStart',
            summary: 'Helix\'s axis starting point or center of spiral.'
          },
          {
            name: 'axisDir',
            summary: 'Helix\'s axis vector or normal to spiral\'s plane.'
          },
          {
            name: 'radiusPoint',
            summary: `Point used only to get a vector that is perpedicular to the axis. In
     particular, this vector must not be (anti)parallel to the axis vector.`
          },
          {
            name: 'pitch',
            summary: `The pitch, where a spiral has a pitch = 0, and pitch > 0 is the distance
     between the helix's "threads".`
          },
          {
            name: 'turnCount',
            summary: `The number of turns in spiral or helix. Positive
     values produce counter-clockwise orientation, negitive values produce
     clockwise orientation. Note, for a helix, turnCount * pitch = length of
     the helix's axis.`
          },
          {
            name: 'radius0',
            summary: 'The starting radius.'
          },
          {
            name: 'radius1',
            summary: 'The ending radius.'
          }
        ],
        returns: 'NurbsCurve on success, None on failure.'
      },
      {
        signature: 'static bool IsDuplicate(NurbsCurve curveA,NurbsCurve curveB,bool ignoreParameterization,double tolerance)',
        summary: 'Determines if two curves are similar.',
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'First curve used in comparison.'
          },
          {
            name: 'curveB',
            summary: 'Second curve used in comparison.'
          },
          {
            name: 'ignoreParameterization',
            summary: 'if true, parameterization and orientaion are ignored.'
          },
          {
            name: 'tolerance',
            summary: 'tolerance to use when comparing control points.'
          }
        ],
        returns: 'True if curves are similar within tolerance.'
      },
      {
        signature: 'static NurbsCurve[] MakeCompatible(IEnumerable<Curve> curves,Point3d startPt,Point3d endPt,int simplifyMethod,int numPoints,double refitTolerance,double angleTolerance)',
        summary: 'For expert use only. From the input curves, make an array of compatible NURBS curves.',
        since: 6,
        parameters: [
          {
            name: 'curves',
            summary: 'The input curves.'
          },
          {
            name: 'startPt',
            summary: 'The start point. To omit, specify Point3d.Unset.'
          },
          {
            name: 'endPt',
            summary: 'The end point. To omit, specify Point3d.Unset.'
          },
          {
            name: 'simplifyMethod',
            summary: 'The simplify method.'
          },
          {
            name: 'numPoints',
            summary: 'The number of rebuild points.'
          },
          {
            name: 'refitTolerance',
            summary: 'The refit tolerance.'
          },
          {
            name: 'angleTolerance',
            summary: 'The angle tolerance in radians.'
          }
        ],
        returns: 'The output NURBS surfaces if successful.'
      },
      {
        signature: 'bool EpsilonEquals(NurbsCurve other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'double GrevilleParameter(int index)',
        summary: `Gets the greville (edit point) parameter that belongs 
     to the control point at the specified index.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of Greville (Edit) point.'
          }
        ]
      },
      {
        signature: 'double[] GrevilleParameters()',
        summary: 'Gets all Greville parameters for this curve.',
        since: 5
      },
      {
        signature: 'Point3d GrevillePoint(int index)',
        summary: `Gets the Greville parameter that belongs 
     to the control point at the specified index.`,
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of Greville point.'
          }
        ]
      },
      {
        signature: 'Point3dList GrevillePoints()',
        summary: 'Gets all Greville points for this curve.',
        since: 5
      },
      {
        signature: 'Point3dList GrevillePoints(bool all)',
        summary: 'Gets Greville points for this curve.',
        since: 6.18,
        parameters: [
          {
            name: 'all',
            summary: 'If true, then all Greville points are returnd. If false, only edit points are returned.'
          }
        ],
        returns: 'A list of points if successful, None otherwise.'
      },
      {
        signature: 'bool IncreaseDegree(int desiredDegree)',
        summary: 'Increase the degree of this curve.',
        since: 5,
        parameters: [
          {
            name: 'desiredDegree',
            summary: `The desired degree. 
     Degrees should be number between and including 1 and 11.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool MakePiecewiseBezier(bool setEndWeightsToOne)',
        summary: `Clamps ends and adds knots so the NURBS curve has bezier spans 
     (all distinct knots have multiplitity = degree).`,
        since: 5,
        parameters: [
          {
            name: 'setEndWeightsToOne',
            summary: `If True and the first or last weight is not one, then the first and
     last spans are reparameterized so that the end weights are one.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Reparameterize(double c)',
        summary: `Use a linear fractional transformation to reparameterize the NURBS curve.
     This does not change the curve's domain.`,
        since: 5,
        parameters: [
          {
            name: 'c',
            summary: `reparameterization constant (generally speaking, c should be > 0). The
     control points and knots are adjusted so that
     output_nurbs(t) = input_nurbs(lambda(t)), where lambda(t) = c*t/( (c-1)*t + 1 ).
     Note that lambda(0) = 0, lambda(1) = 1, lambda'(t) > 0, 
     lambda'(0) = c and lambda'(1) = 1/c.`
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'bool SetEndCondition(bool bSetEnd,NurbsCurveEndConditionType continuity,Point3d point,Vector3d tangent)',
        summary: 'Set end condition of a nurbs curve to point, tangent and curvature.',
        since: 6,
        parameters: [
          {
            name: 'bSetEnd',
            summary: 'true: set end of curve, false: set start of curve'
          },
          {
            name: 'continuity',
            summary: 'Position: set strart or end point, Tangency: set point and tangent, Curvature: set point, tangent and curvature'
          },
          {
            name: 'point',
            summary: 'point to set'
          },
          {
            name: 'tangent',
            summary: 'tangent to set'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetEndCondition(bool bSetEnd,NurbsCurveEndConditionType continuity,Point3d point,Vector3d tangent,Vector3d curvature)',
        summary: 'Set end condition of a nurbs curve to point, tangent and curvature.',
        since: 6,
        parameters: [
          {
            name: 'bSetEnd',
            summary: 'true: set end of curve, false: set start of curve'
          },
          {
            name: 'continuity',
            summary: 'Position: set strart or end point, Tangency: set point and tangent, Curvature: set point, tangent and curvature'
          },
          {
            name: 'point',
            summary: 'point to set'
          },
          {
            name: 'tangent',
            summary: 'tangent to set'
          },
          {
            name: 'curvature',
            summary: 'curvature to set'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool SetGrevillePoints(IEnumerable<Point3d> points)',
        summary: 'Sets all Greville edit points for this curve.',
        since: 6.4,
        parameters: [
          {
            name: 'points',
            summary: `The new point locations. The number of points should match 
     the number of point returned by NurbsCurve.GrevillePoints(false).`
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool UVNDirectionsAt(double t,Vector3d uDir,Vector3d vDir,Vector3d nDir)',
        summary: 'Calculates the u, V, and N directions of a NURBS curve at a parameter similar to the method used by Rhino\'s MoveUVN command.',
        since: 7,
        parameters: [
          {
            name: 't',
            summary: 'The evalaution parameter.'
          },
          {
            name: 'uDir',
            summary: 'The U direction.'
          },
          {
            name: 'vDir',
            summary: 'The V direction.'
          },
          {
            name: 'nDir',
            summary: 'The N direction.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'NurbsCurve.NurbsCurveEndConditionType',
    dataType: 3,
    summary: 'What end conditions to set',
    values: [
      {
        signature: 'Nothing = UnsafeNativeMethods.NurbsCurveEndConditionType.Nothing',
        summary: 'Set nothing'
      },
      {
        signature: 'Position = UnsafeNativeMethods.NurbsCurveEndConditionType.Position',
        summary: 'Set endpoint'
      },
      {
        signature: 'Tangency = UnsafeNativeMethods.NurbsCurveEndConditionType.Tangency',
        summary: 'Set tangent'
      },
      {
        signature: 'Curvature = UnsafeNativeMethods.NurbsCurveEndConditionType.Curvature',
        summary: 'Set curvature'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'NurbsSurface',
    dataType: 1,
    summary: 'Represents a Non Uniform Rational B-Splines (NURBS) surface.',
    baseclass: 'Rhino.Geometry.Surface',
    interfaces: ['IEpsilonComparable<NurbsSurface>'],
    constructors: [
      {
        signature: 'NurbsSurface(NurbsSurface other)',
        summary: 'Initializes a new NURBS surface by copying the values from another surface.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Another surface.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool IsRational',
        summary: 'Gets a value indicating whether or not the nurbs surface is rational.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'NurbsSurfaceKnotList KnotsU',
        summary: 'The U direction knot vector.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'NurbsSurfaceKnotList KnotsV',
        summary: 'The V direction knot vector.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int OrderU',
        summary: 'Gets the order in the U direction.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int OrderV',
        summary: 'Gets the order in the V direction.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'NurbsSurfacePointList Points',
        summary: 'Gets a collection of surface control points that form this surface.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static NurbsSurface Create(int dimension,bool isRational,int order0,int order1,int controlPointCount0,int controlPointCount1)',
        summary: 'Constructs a new NURBS surface with internal uninitialized arrays.',
        since: 5,
        parameters: [
          {
            name: 'dimension',
            summary: 'The number of dimensions.>= 1. This value is usually 3.'
          },
          {
            name: 'isRational',
            summary: 'True to make a rational NURBS.'
          },
          {
            name: 'order0',
            summary: 'The order in U direction.>= 2.'
          },
          {
            name: 'order1',
            summary: 'The order in V direction.>= 2.'
          },
          {
            name: 'controlPointCount0',
            summary: 'Control point count in U direction.>= order0.'
          },
          {
            name: 'controlPointCount1',
            summary: 'Control point count in V direction.>= order1.'
          }
        ],
        returns: 'A new NURBS surface, or None on error.'
      },
      {
        signature: 'static NurbsCurve CreateCurveOnSurface(Surface surface,IEnumerable<Point2d> points,double tolerance,bool periodic)',
        summary: 'Fit a sequence of 2d points on a surface to make a curve on the surface.',
        since: 6.3,
        parameters: [
          {
            name: 'surface',
            summary: 'Surface on which to construct curve.'
          },
          {
            name: 'points',
            summary: 'Parameter space coodinates of the points to interpolate.'
          },
          {
            name: 'tolerance',
            summary: 'Curve should be within tolerance of surface and points.'
          },
          {
            name: 'periodic',
            summary: 'When True make a periodic curve.'
          }
        ],
        returns: 'A curve interpolating the points if successful, None on error.'
      },
      {
        signature: 'static Point2d[] CreateCurveOnSurfacePoints(Surface surface,IEnumerable<Point2d> fixedPoints,double tolerance,bool periodic,int initCount,int levels)',
        summary: `Computes a discrete spline curve on the surface. In other words, computes a sequence 
     of points on the surface, each with a corresponding parameter value.`,
        since: 6.3,
        parameters: [
          {
            name: 'surface',
            summary: `The surface on which the curve is constructed. The surface should be G1 continuous. 
     If the surface is closed in the u or v direction and is G1 at the seam, the
     function will construct point sequences that cross over the seam.`
          },
          {
            name: 'fixedPoints',
            summary: 'Surface points to interpolate given by parameters. These must be distinct.'
          },
          {
            name: 'tolerance',
            summary: 'Relative tolerance used by the solver. When in doubt, use a tolerance of 0.0.'
          },
          {
            name: 'periodic',
            summary: 'When True constructs a smoothly closed curve.'
          },
          {
            name: 'initCount',
            summary: 'Maximum number of points to insert beteween fixed points on the first level.'
          },
          {
            name: 'levels',
            summary: 'The number of levels (between 1 and 3) to be used in multi-level solver. Use 1 for single level solve.'
          }
        ],
        returns: `A sequence of surface points, given by surface parameters, if successful.
     The number of output points is approximatelely: 2 ^ (level-1) * initCount * fixedPoints.Count.`
      },
      {
        signature: 'static NurbsSurface CreateFromCone(Cone cone)',
        summary: 'Constructs a new NURBS surfaces from cone data.',
        since: 5,
        parameters: [
          {
            name: 'cone',
            summary: 'A cone value.'
          }
        ],
        returns: 'A new NURBS surface, or None on error.'
      },
      {
        signature: 'static NurbsSurface CreateFromCorners(Point3d corner1,Point3d corner2,Point3d corner3)',
        summary: 'Makes a surface from 3 corner points.',
        since: 5,
        parameters: [
          {
            name: 'corner1',
            summary: 'The first corner.'
          },
          {
            name: 'corner2',
            summary: 'The second corner.'
          },
          {
            name: 'corner3',
            summary: 'The third corner.'
          }
        ],
        returns: 'The resulting surface or None on error.'
      },
      {
        signature: 'static NurbsSurface CreateFromCorners(Point3d corner1,Point3d corner2,Point3d corner3,Point3d corner4)',
        summary: `Makes a surface from 4 corner points.
     This is the same as calling  with tolerance 0.`,
        since: 5,
        parameters: [
          {
            name: 'corner1',
            summary: 'The first corner.'
          },
          {
            name: 'corner2',
            summary: 'The second corner.'
          },
          {
            name: 'corner3',
            summary: 'The third corner.'
          },
          {
            name: 'corner4',
            summary: 'The fourth corner.'
          }
        ],
        returns: 'the resulting surface or None on error.'
      },
      {
        signature: 'static NurbsSurface CreateFromCorners(Point3d corner1,Point3d corner2,Point3d corner3,Point3d corner4,double tolerance)',
        summary: 'Makes a surface from 4 corner points.',
        since: 5,
        parameters: [
          {
            name: 'corner1',
            summary: 'The first corner.'
          },
          {
            name: 'corner2',
            summary: 'The second corner.'
          },
          {
            name: 'corner3',
            summary: 'The third corner.'
          },
          {
            name: 'corner4',
            summary: 'The fourth corner.'
          },
          {
            name: 'tolerance',
            summary: 'Minimum edge length without collapsing to a singularity.'
          }
        ],
        returns: 'The resulting surface or None on error.'
      },
      {
        signature: 'static NurbsSurface CreateFromCylinder(Cylinder cylinder)',
        summary: 'Constructs a new NURBS surfaces from cylinder data.',
        since: 5,
        parameters: [
          {
            name: 'cylinder',
            summary: 'A cylinder value.'
          }
        ],
        returns: 'A new NURBS surface, or None on error.'
      },
      {
        signature: 'static NurbsSurface CreateFromPoints(IEnumerable<Point3d> points,int uCount,int vCount,int uDegree,int vDegree)',
        summary: 'Constructs a NURBS surface from a 2D grid of control points.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Control point locations.'
          },
          {
            name: 'uCount',
            summary: 'Number of points in U direction.'
          },
          {
            name: 'vCount',
            summary: 'Number of points in V direction.'
          },
          {
            name: 'uDegree',
            summary: 'Degree of surface in U direction.'
          },
          {
            name: 'vDegree',
            summary: 'Degree of surface in V direction.'
          }
        ],
        returns: 'A NurbsSurface on success or None on failure.'
      },
      {
        signature: 'static NurbsSurface CreateFromSphere(Sphere sphere)',
        summary: 'Constructs a new NURBS surfaces from sphere data.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'A sphere value.'
          }
        ],
        returns: 'A new NURBS surface, or None on error.'
      },
      {
        signature: 'static NurbsSurface CreateFromTorus(Torus torus)',
        summary: 'Constructs a new NURBS surfaces from torus data.',
        since: 5,
        parameters: [
          {
            name: 'torus',
            summary: 'A torus value.'
          }
        ],
        returns: 'A new NURBS surface, or None on error.'
      },
      {
        signature: 'static NurbsSurface CreateNetworkSurface(IEnumerable<Curve> curves,int continuity,double edgeTolerance,double interiorTolerance,double angleTolerance,int error)',
        summary: 'Builds a surface from an autosorted network of curves/edges.',
        since: 5,
        parameters: [
          {
            name: 'curves',
            summary: 'An array, a list or any enumerable set of curves/edges, sorted automatically into U and V curves.'
          },
          {
            name: 'continuity',
            summary: 'continuity along edges, 0 = loose, 1 = pos, 2 = tan, 3 = curvature.'
          },
          {
            name: 'edgeTolerance',
            summary: 'tolerance to use along network surface edge.'
          },
          {
            name: 'interiorTolerance',
            summary: 'tolerance to use for the interior curves.'
          },
          {
            name: 'angleTolerance',
            summary: 'angle tolerance to use.'
          },
          {
            name: 'error',
            summary: `If the NurbsSurface could not be created, the error value describes where
     the failure occured.  0 = success,  1 = curve sorter failed, 2 = network initializing failed,
     3 = failed to build surface, 4 = network surface is not valid.`
          }
        ],
        returns: 'A NurbsSurface or None on failure.'
      },
      {
        signature: 'static NurbsSurface CreateNetworkSurface(IEnumerable<Curve> uCurves,int uContinuityStart,int uContinuityEnd,IEnumerable<Curve> vCurves,int vContinuityStart,int vContinuityEnd,double edgeTolerance,double interiorTolerance,double angleTolerance,int error)',
        summary: 'Builds a surface from an ordered network of curves/edges.',
        since: 5,
        parameters: [
          {
            name: 'uCurves',
            summary: 'An array, a list or any enumerable set of U curves.'
          },
          {
            name: 'uContinuityStart',
            summary: 'continuity at first U segment, 0 = loose, 1 = pos, 2 = tan, 3 = curvature.'
          },
          {
            name: 'uContinuityEnd',
            summary: 'continuity at last U segment, 0 = loose, 1 = pos, 2 = tan, 3 = curvature.'
          },
          {
            name: 'vCurves',
            summary: 'An array, a list or any enumerable set of V curves.'
          },
          {
            name: 'vContinuityStart',
            summary: 'continuity at first V segment, 0 = loose, 1 = pos, 2 = tan, 3 = curvature.'
          },
          {
            name: 'vContinuityEnd',
            summary: 'continuity at last V segment, 0 = loose, 1 = pos, 2 = tan, 3 = curvature.'
          },
          {
            name: 'edgeTolerance',
            summary: 'tolerance to use along network surface edge.'
          },
          {
            name: 'interiorTolerance',
            summary: 'tolerance to use for the interior curves.'
          },
          {
            name: 'angleTolerance',
            summary: 'angle tolerance to use.'
          },
          {
            name: 'error',
            summary: `If the NurbsSurface could not be created, the error value describes where
     the failure occured.  0 = success,  1 = curve sorter failed, 2 = network initializing failed,
     3 = failed to build surface, 4 = network surface is not valid.`
          }
        ],
        returns: 'A NurbsSurface or None on failure.'
      },
      {
        signature: 'static NurbsSurface CreateRailRevolvedSurface(Curve profile,Curve rail,Line axis,bool scaleHeight)',
        summary: 'Constructs a railed Surface-of-Revolution.',
        since: 5,
        parameters: [
          {
            name: 'profile',
            summary: 'Profile curve for revolution.'
          },
          {
            name: 'rail',
            summary: 'Rail curve for revolution.'
          },
          {
            name: 'axis',
            summary: 'Axis of revolution.'
          },
          {
            name: 'scaleHeight',
            summary: 'If true, surface will be locally scaled.'
          }
        ],
        returns: 'A NurbsSurface or None on failure.'
      },
      {
        signature: 'static NurbsSurface CreateRuledSurface(Curve curveA,Curve curveB)',
        summary: 'Constructs a ruled surface between two curves. Curves must share the same knot-vector.',
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'First curve.'
          },
          {
            name: 'curveB',
            summary: 'Second curve.'
          }
        ],
        returns: 'A ruled surface on success or None on failure.'
      },
      {
        signature: 'static NurbsSurface CreateThroughPoints(IEnumerable<Point3d> points,int uCount,int vCount,int uDegree,int vDegree,bool uClosed,bool vClosed)',
        summary: 'Constructs a NURBS surface from a 2D grid of points.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Control point locations.'
          },
          {
            name: 'uCount',
            summary: 'Number of points in U direction.'
          },
          {
            name: 'vCount',
            summary: 'Number of points in V direction.'
          },
          {
            name: 'uDegree',
            summary: 'Degree of surface in U direction.'
          },
          {
            name: 'vDegree',
            summary: 'Degree of surface in V direction.'
          },
          {
            name: 'uClosed',
            summary: 'True if the surface should be closed in the U direction.'
          },
          {
            name: 'vClosed',
            summary: 'True if the surface should be closed in the V direction.'
          }
        ],
        returns: 'A NurbsSurface on success or None on failure.'
      },
      {
        signature: 'static bool MakeCompatible(Surface surface0,Surface surface1,NurbsSurface nurb0,NurbsSurface nurb1)',
        summary: 'For expert use only. Makes a pair of compatible NURBS surfaces based on two input surfaces.',
        since: 6,
        parameters: [
          {
            name: 'surface0',
            summary: 'The first surface.'
          },
          {
            name: 'surface1',
            summary: 'The second surface.'
          },
          {
            name: 'nurb0',
            summary: 'The first output NURBS surface.'
          },
          {
            name: 'nurb1',
            summary: 'The second output NURBS surface.'
          }
        ],
        returns: 'True if successsful, False on failure.'
      },
      {
        signature: 'void CopyFrom(NurbsSurface other)',
        summary: 'Copies this NURBS surface from another NURBS surface.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The other NURBS surface to use as source.'
          }
        ]
      },
      {
        signature: 'bool EpsilonEquals(NurbsSurface other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool IncreaseDegreeU(int desiredDegree)',
        summary: 'Increase the degree of this surface in U direction.',
        since: 5.1,
        parameters: [
          {
            name: 'desiredDegree',
            summary: `The desired degree. 
     Degrees should be number between and including 1 and 11.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool IncreaseDegreeV(int desiredDegree)',
        summary: 'Increase the degree of this surface in V direction.',
        since: 5.1,
        parameters: [
          {
            name: 'desiredDegree',
            summary: `The desired degree. 
     Degrees should be number between and including 1 and 11.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool MakeNonRational()',
        summary: 'Makes this surface non-rational.',
        since: 5,
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool MakeRational()',
        summary: 'Makes this surface rational.',
        since: 5,
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool UVNDirectionsAt(double u,double v,Vector3d uDir,Vector3d vDir,Vector3d nDir)',
        summary: 'Calculates the U, V, and N directions of a NURBS surface at a u,v parameter similar to the method used by Rhino\'s MoveUVN command.',
        since: 7,
        parameters: [
          {
            name: 'u',
            summary: 'The u evalaution parameter.'
          },
          {
            name: 'v',
            summary: 'The v evalaution parameter.'
          },
          {
            name: 'uDir',
            summary: 'The U direction.'
          },
          {
            name: 'vDir',
            summary: 'The V direction.'
          },
          {
            name: 'nDir',
            summary: 'The N direction.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'OrdinateDimension.MeasuredDirection',
    dataType: 3,
    summary: 'Ordinate dimension measures x or y direction',
    values: [
      {
        signature: 'Unset = 0'
      },
      {
        signature: 'Xaxis = 1',
        summary: 'Measures horizontal distance'
      },
      {
        signature: 'Yaxis = 2',
        summary: 'Measures vertical distance'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Particle',
    dataType: 1,
    summary: `Represents a simple particle.
   This base class only defines position and display properties (size, color, bitmap id).
   You will most likely create a class that derives from this particle class to perform some
   sort of physical simulation (movement over time or frames).`,
    constructors: [
      {
        signature: 'Particle()',
        summary: 'Initializes a new instance of the Particle class.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'Color Color',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int DisplayBitmapIndex',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int Index',
        summary: `Index in ParentSystem for this Particle. Can change when the particle
     system is modified.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d Location',
        summary: '3d Location of the Particle.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ParticleSystem ParentSystem',
        summary: 'Gets the parent particle system of this particle.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'float Size',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Update()',
        summary: 'Base class implementation does nothing.',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'ParticleSystem',
    dataType: 1,
    interfaces: ['IEnumerable<Particle>'],
    properties: [
      {
        signature: 'BoundingBox BoundingBox',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool DisplaySizesInWorldUnits',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DrawRequiresDepthSorting',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'bool Add(Particle particle)',
        summary: `Adds a particle to this ParticleSystem. A Particle can only be in one system
     at a time.  If the Particle already exists in a different system, this function
     will return false. You should remove the particle from the other system first
     before adding it.`,
        since: 5,
        parameters: [
          {
            name: 'particle',
            summary: 'A particle to be added.'
          }
        ],
        returns: `True if this particle was added to the system or if is already in the system.
     False if the particle already exists in a different system.`
      },
      {
        signature: 'void Clear()',
        summary: 'Remove all Particles from this system.',
        since: 5
      },
      {
        signature: 'IEnumerator<Particle> GetEnumerator()',
        since: 5
      },
      {
        signature: 'void Remove(Particle particle)',
        summary: 'Removes a single particle from this system.',
        since: 5,
        parameters: [
          {
            name: 'particle',
            summary: 'The particle to be removed.'
          }
        ]
      },
      {
        signature: 'void Update()',
        summary: 'Calls Update on every particle in the system.',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'PipeCapMode',
    dataType: 3,
    summary: 'Defines styles used for creating Brep pipes.',
    values: [
      {
        signature: 'None = 0',
        summary: 'No cap.'
      },
      {
        signature: 'Flat = 1',
        summary: 'Caps with planar surface.'
      },
      {
        signature: 'Round = 2',
        summary: 'Caps with hemispherical surface.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Plane',
    dataType: 2,
    summary: 'Represents the value of a center point and two axes in a plane in three dimensions.',
    constructors: [
      {
        signature: 'Plane(double a,double b,double c,double d)',
        summary: `Constructs a plane from an equation
     Ax+By+Cz+D=0.`,
        since: 5
      },
      {
        signature: 'Plane(Plane other)',
        summary: `Copy constructor.
     This is nothing special and performs the same as assigning to another variable.`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The source plane value.'
          }
        ]
      },
      {
        signature: 'Plane(Point3d origin,Point3d xPoint,Point3d yPoint)',
        summary: 'Initializes a plane from three non-colinear points.',
        since: 5,
        parameters: [
          {
            name: 'origin',
            summary: 'Origin point of the plane.'
          },
          {
            name: 'xPoint',
            summary: 'Second point in the plane. The x-axis will be parallel to x_point-origin.'
          },
          {
            name: 'yPoint',
            summary: `Third point on the plane that is not colinear with the first two points.
     yaxis*(y_point-origin) will be > 0.`
          }
        ]
      },
      {
        signature: 'Plane(Point3d origin,Vector3d normal)',
        summary: 'Constructs a plane from a point and a normal vector.',
        since: 5,
        parameters: [
          {
            name: 'origin',
            summary: 'Origin point of the plane.'
          },
          {
            name: 'normal',
            summary: 'Non-zero normal to the plane.'
          }
        ]
      },
      {
        signature: 'Plane(Point3d origin,Vector3d xDirection,Vector3d yDirection)',
        summary: 'Constructs a plane from a point and two vectors in the plane.',
        since: 5,
        parameters: [
          {
            name: 'origin',
            summary: 'Origin point of the plane.'
          },
          {
            name: 'xDirection',
            summary: 'Non-zero vector in the plane that determines the x-axis direction.'
          },
          {
            name: 'yDirection',
            summary: `Non-zero vector not parallel to x_dir that is used to determine the
     yaxis direction. y_dir does not need to be perpendicular to x_dir.`
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Plane Unset',
        summary: 'Gets a plane that contains Unset origin and axis vectors.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Plane WorldXY',
        summary: 'plane coincident with the World XY plane.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Plane WorldYZ',
        summary: 'plane coincident with the World YZ plane.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Plane WorldZX',
        summary: 'plane coincident with the World ZX plane.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: `Gets a value indicating whether or not this is a valid plane. 
     A plane is considered to be valid when all fields contain reasonable 
     information and the equation jibes with point and zaxis.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d Normal',
        summary: 'Gets the normal of this plane. This is essentially the ZAxis of the plane.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d Origin',
        summary: 'Gets or sets the origin point of this plane.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double OriginX',
        summary: 'Gets or sets the X coordinate of the origin of this plane.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double OriginY',
        summary: 'Gets or sets the Y coordinate of the origin of this plane.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double OriginZ',
        summary: 'Gets or sets the Z coordinate of the origin of this plane.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d XAxis',
        summary: 'Gets or sets the X axis vector of this plane.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d YAxis',
        summary: 'Gets or sets the Y axis vector of this plane.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d ZAxis',
        summary: 'Gets or sets the Z axis vector of this plane.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static PlaneFitResult FitPlaneToPoints(IEnumerable<Point3d> points,Plane plane)',
        summary: 'Fit a plane through a collection of points.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to fit to.'
          },
          {
            name: 'plane',
            summary: 'Resulting plane.'
          }
        ],
        returns: 'A value indicating the result of the operation.'
      },
      {
        signature: 'static PlaneFitResult FitPlaneToPoints(IEnumerable<Point3d> points,Plane plane,double maximumDeviation)',
        summary: 'Fit a plane through a collection of points.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to fit to.'
          },
          {
            name: 'plane',
            summary: 'Resulting plane.'
          },
          {
            name: 'maximumDeviation',
            summary: 'The distance from the furthest point to the plane.'
          }
        ],
        returns: 'A value indicating the result of the operation.'
      },
      {
        signature: 'Plane Clone()',
        summary: 'Returns a deep of this instance.',
        since: 6,
        returns: 'A plane with the same values as this item.'
      },
      {
        signature: 'bool ClosestParameter(Point3d testPoint,double s,double t)',
        summary: 'Gets the parameters of the point on the plane closest to a test point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to get close to.'
          },
          {
            name: 's',
            summary: 'Parameter along plane X-direction.'
          },
          {
            name: 't',
            summary: 'Parameter along plane Y-direction.'
          }
        ],
        returns: `True if a parameter could be found, 
     False if the point could not be projected successfully.`
      },
      {
        signature: 'Point3d ClosestPoint(Point3d testPoint)',
        summary: 'Gets the point on the plane closest to a test point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to get close to.'
          }
        ],
        returns: `The point on the plane that is closest to testPoint, 
     or Point3d.Unset on failure.`
      },
      {
        signature: 'bool DistanceTo(BoundingBox bbox,double min,double max)',
        summary: 'Returns the signed minimum and maximum distances from bbox to this plane.',
        since: 6,
        parameters: [
          {
            name: 'bbox',
            summary: 'bounding box to get distances from'
          },
          {
            name: 'min',
            summary: 'minimum signed distance from plane to box'
          },
          {
            name: 'max',
            summary: 'maximum signed distance from plane to box'
          }
        ],
        returns: 'False if plane has zero length normal'
      },
      {
        signature: 'double DistanceTo(Point3d testPoint)',
        summary: `Returns the signed distance from testPoint to its projection onto this plane. 
     If the point is below the plane, a negative distance is returned.`,
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to test.'
          }
        ],
        returns: 'Signed distance from this plane to testPoint.'
      },
      {
        signature: 'bool EpsilonEquals(Plane other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines if an object is a plane and has the same components as this plane.',
        parameters: [
          {
            name: 'obj',
            summary: 'An object.'
          }
        ],
        returns: 'True if obj is a plane and has the same components as this plane; False otherwise.'
      },
      {
        signature: 'bool Equals(Plane plane)',
        summary: 'Determines if another plane has the same components as this plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'A plane.'
          }
        ],
        returns: 'True if plane has the same components as this plane; False otherwise.'
      },
      {
        signature: 'bool ExtendThroughBox(BoundingBox box,Interval s,Interval t)',
        summary: 'Extends this plane through a bounding box.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'A box to use as minimal extension boundary.'
          },
          {
            name: 's',
            summary: `If this function returns true, 
     the s parameter returns the Interval on the plane along the X direction that will 
     encompass the Box.`
          },
          {
            name: 't',
            summary: `If this function returns true, 
     the t parameter returns the Interval on the plane along the Y direction that will 
     encompass the Box.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool ExtendThroughBox(Box box,Interval s,Interval t)',
        summary: 'Extend this plane through a Box.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'A box to use for extension.'
          },
          {
            name: 's',
            summary: `If this function returns true, 
     the s parameter returns the Interval on the plane along the X direction that will 
     encompass the Box.`
          },
          {
            name: 't',
            summary: `If this function returns true, 
     the t parameter returns the Interval on the plane along the Y direction that will 
     encompass the Box.`
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'void Flip()',
        summary: 'Flip this plane by swapping out the X and Y axes and inverting the Z axis.',
        since: 5
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Gets a non-unique hashing code for this entity.',
        returns: 'A particular number for a specific instance of plane.'
      },
      {
        signature: 'double[] GetPlaneEquation()',
        summary: 'Gets the plane equation for this plane in the format of Ax+By+Cz+D=0.',
        since: 5,
        returns: 'Array of four values.'
      },
      {
        signature: 'Point3d PointAt(double u,double v)',
        summary: 'Evaluate a point on the plane.',
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'evaulation parameter.'
          },
          {
            name: 'v',
            summary: 'evaulation parameter.'
          }
        ],
        returns: 'plane.origin + u*plane.xaxis + v*plane.yaxis.'
      },
      {
        signature: 'Point3d PointAt(double u,double v,double w)',
        summary: 'Evaluate a point on the plane.',
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'evaulation parameter.'
          },
          {
            name: 'v',
            summary: 'evaulation parameter.'
          },
          {
            name: 'w',
            summary: 'evaulation parameter.'
          }
        ],
        returns: 'plane.origin + u*plane.xaxis + v*plane.yaxis + z*plane.zaxis.'
      },
      {
        signature: 'bool RemapToPlaneSpace(Point3d ptSample,Point3d ptPlane)',
        summary: 'Convert a point from World space coordinates into Plane space coordinates.',
        since: 5,
        parameters: [
          {
            name: 'ptSample',
            summary: 'World point to remap.'
          },
          {
            name: 'ptPlane',
            summary: 'Point in plane (s,t,d) coordinates.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Rotate(double sinAngle,double cosAngle,Vector3d axis)',
        summary: 'Rotate the plane about its origin point.',
        since: 5,
        parameters: [
          {
            name: 'sinAngle',
            summary: 'Sin(angle).'
          },
          {
            name: 'cosAngle',
            summary: 'Cos(angle).'
          },
          {
            name: 'axis',
            summary: 'Axis of rotation.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Rotate(double sinAngle,double cosAngle,Vector3d axis,Point3d centerOfRotation)',
        summary: 'Rotate the plane about a custom anchor point.',
        since: 5,
        parameters: [
          {
            name: 'sinAngle',
            summary: 'Sin(angle)'
          },
          {
            name: 'cosAngle',
            summary: 'Cos(angle)'
          },
          {
            name: 'axis',
            summary: 'Axis of rotation.'
          },
          {
            name: 'centerOfRotation',
            summary: 'Center of rotation.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Rotate(double angle,Vector3d axis)',
        summary: 'Rotate the plane about its origin point.',
        since: 5,
        parameters: [
          {
            name: 'angle',
            summary: 'Angle in radians.'
          },
          {
            name: 'axis',
            summary: 'Axis of rotation.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Rotate(double angle,Vector3d axis,Point3d centerOfRotation)',
        summary: 'Rotate the plane about a custom anchor point.',
        since: 5,
        parameters: [
          {
            name: 'angle',
            summary: 'Angle in radians.'
          },
          {
            name: 'axis',
            summary: 'Axis of rotation.'
          },
          {
            name: 'centerOfRotation',
            summary: 'Center of rotation.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'string ToString()',
        summary: 'Constructs the string representation of this plane.',
        returns: 'Text.'
      },
      {
        signature: 'string ToString(string format,IFormatProvider formatProvider)',
        since: 7
      },
      {
        signature: 'bool Transform(Transform xform)',
        summary: 'Transform the plane with a Transformation matrix.',
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation to apply to plane.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Translate(Vector3d delta)',
        summary: 'Translate (move) the plane along a vector.',
        since: 5,
        parameters: [
          {
            name: 'delta',
            summary: 'Translation (motion) vector.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool UpdateEquation()',
        summary: 'Update Equations',
        since: 6,
        returns: 'bool'
      },
      {
        signature: 'double ValueAt(Point3d p)',
        summary: 'Get the value of the plane equation at the point.',
        since: 5.7,
        parameters: [
          {
            name: 'p',
            summary: 'evaulation point.'
          }
        ],
        returns: `returns pe[0]*p.X + pe[1]*p.Y + pe[2]*p.Z + pe[3] where
     pe[0], pe[1], pe[2] and pe[3] are the coeeficients of the plane equation.`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'PlaneFitResult',
    dataType: 3,
    summary: 'Enumerates all possible outcomes of a Least-Squares plane fitting operation.',
    values: [
      {
        signature: 'Failure = -1',
        summary: 'No plane could be found.'
      },
      {
        signature: 'Success = 0',
        summary: 'A plane was successfully fitted.'
      },
      {
        signature: 'Inconclusive = 1',
        summary: `A valid plane was found, but it is an inconclusive result. 
     This might happen with co-linear points for example.`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'PlaneSurface',
    dataType: 1,
    summary: 'Represents a plane surface, with plane and two intervals.',
    baseclass: 'Rhino.Geometry.Surface',
    constructors: [
      {
        signature: 'PlaneSurface(Plane plane,Interval xExtents,Interval yExtents)',
        summary: 'Initializes a plane surface with x and y intervals.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'The plane.'
          },
          {
            name: 'xExtents',
            summary: `The x interval of the plane that defines the rectangle.
     The corresponding evaluation interval domain is set so that it matches the
     extents interval.`
          },
          {
            name: 'yExtents',
            summary: `The y interval of the plane that defines the rectangle.
     The corresponding evaluation interval domain is set so that it matches the
     extents interval.`
          }
        ]
      }
    ],
    methods: [
      {
        signature: 'static PlaneSurface CreateThroughBox(Line lineInPlane,Vector3d vectorInPlane,BoundingBox box)',
        summary: 'Makes a plane that includes a line and a vector and goes through a bounding box.',
        since: 5,
        parameters: [
          {
            name: 'lineInPlane',
            summary: 'A line that will lie on the plane.'
          },
          {
            name: 'vectorInPlane',
            summary: 'A vector the direction of which will be in plane.'
          },
          {
            name: 'box',
            summary: 'A box to cut through.'
          }
        ],
        returns: 'A new plane surface on success, or None on error.'
      },
      {
        signature: 'static PlaneSurface CreateThroughBox(Plane plane,BoundingBox box)',
        summary: 'Extends a plane into a plane surface so that the latter goes through a bounding box.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'An original plane value.'
          },
          {
            name: 'box',
            summary: 'A box to use for extension boundary.'
          }
        ],
        returns: 'A new plane surface on success, or None on error.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Point',
    dataType: 1,
    summary: `Represents a geometric point.
   This is fundamentally a class that derives from
    and contains a single  location.`,
    baseclass: 'Rhino.Geometry.GeometryBase',
    constructors: [
      {
        signature: 'Point(Point3d location)',
        summary: 'Initializes a new point instance with a location.',
        since: 5,
        parameters: [
          {
            name: 'location',
            summary: 'A position in 3D space.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'Point3d Location',
        summary: 'Gets or sets the location (position) of this point.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Point2d',
    dataType: 2,
    summary: `Represents the two coordinates of a point in two-dimensional space,
   using double-precision floating point numbers.`,
    constructors: [
      {
        signature: 'Point2d(double x,double y)',
        summary: 'Initializes a new instance of Point2d from coordinates.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'The X (first) coordinate.'
          },
          {
            name: 'y',
            summary: 'The Y (second) coordinate.'
          }
        ]
      },
      {
        signature: 'Point2d(Point2d point)',
        summary: 'Initializes a new instance of Point2d by copying another Point2d.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'The point that will be copied.'
          }
        ]
      },
      {
        signature: 'Point2d(Point3d point)',
        summary: 'Initializes a new instance of Point3d by copying the first two coordiantes of a Point3d.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'The point that will be used: the Z (third) coordinate is discarded.'
          }
        ]
      },
      {
        signature: 'Point2d(Vector2d vector)',
        summary: 'Initializes a new instance of Point2d by converting a vector.',
        since: 5,
        parameters: [
          {
            name: 'vector',
            summary: 'The vector that will be copied.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Point2d Origin',
        summary: 'Gets a point at 0,0.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Point2d Unset',
        summary: 'Gets a point at RhinoMath.UnsetValue,RhinoMath.UnsetValue.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: 'If any coordinate of a point is UnsetValue, then the point is not valid.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double MaximumCoordinate',
        summary: 'Gets the largest valid coordinate, or RhinoMath.UnsetValue if no coordinate is valid.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double MinimumCoordinate',
        summary: 'Gets the smallest (both positive and negative) valid coordinate, or RhinoMath.UnsetValue if no coordinate is valid.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double X',
        summary: 'Gets or sets the X (first) coordinate of the point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Y',
        summary: 'Gets or sets the Y (second) coordinate of the point.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Point2d Add(Point2d point1,Point2d point2)',
        summary: `Adds a point with a point.
     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point1',
            summary: 'A point.'
          },
          {
            name: 'point2',
            summary: 'A point.'
          }
        ],
        returns: 'A new point that is coordinatewise summed with the other point.'
      },
      {
        signature: 'static Point2d Add(Point2d point,Vector2d vector)',
        summary: `Adds a point with a vector.
     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 'vector',
            summary: 'A vector.'
          }
        ],
        returns: 'A new point that is coordinatewise summed with the vector.'
      },
      {
        signature: 'static Point2d Add(Vector2d vector,Point2d point)',
        summary: `Adds a vector with a point.
     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'vector',
            summary: 'A vector.'
          },
          {
            name: 'point',
            summary: 'A point.'
          }
        ],
        returns: 'A new point that is coordinatewise summed with the vector.'
      },
      {
        signature: 'static Point2d Divide(Point2d point,double t)',
        summary: `Divides a Point2d by a number.
     (Provided for languages that do not support operator overloading. You can use the / operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 't',
            summary: 'A number.'
          }
        ],
        returns: 'A new point that is coordinatewise divided by t.'
      },
      {
        signature: 'static Point2d Multiply(double t,Point2d point)',
        summary: `Multiplies a Point2d by a number.
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'A number.'
          },
          {
            name: 'point',
            summary: 'A point.'
          }
        ],
        returns: 'A new point that is coordinatewise multiplied by t.'
      },
      {
        signature: 'static Point2d Multiply(Point2d point,double t)',
        summary: `Multiplies a Point2d by a number.
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 't',
            summary: 'A number.'
          }
        ],
        returns: 'A new point that is coordinatewise multiplied by t.'
      },
      {
        signature: 'static Vector2d Subtract(Point2d point1,Point2d point2)',
        summary: `Subtracts the second point from the first point.
     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point1',
            summary: 'A point (minuend).'
          },
          {
            name: 'point2',
            summary: 'A point (subtrahend).'
          }
        ],
        returns: 'A new vector that is point1 coordinatewise subtracted by point2.'
      },
      {
        signature: 'static Point2d Subtract(Point2d point,Vector2d vector)',
        summary: `Subtracts a vector from a point.
     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 'vector',
            summary: 'A vector.'
          }
        ],
        returns: 'A new point that is coordinatewise subtracted by vector.'
      },
      {
        signature: 'int CompareTo(Point2d other)',
        summary: `Compares this Point2d with another Point2d.
     Coordinates evaluation priority is first X, then Y.`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The other Point2d to use in comparison.'
          }
        ],
        returns: '0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y+1: otherwise.'
      },
      {
        signature: 'double DistanceTo(Point2d other)',
        summary: 'Computes the distance between two points.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Another point.'
          }
        ],
        returns: 'The length of the line between the two points, or 0 if either point is invalid.'
      },
      {
        signature: 'bool EpsilonEquals(Point2d other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines whether the specified System.Object is a Point2d and has the same values as the present point.',
        parameters: [
          {
            name: 'obj',
            summary: 'The specified object.'
          }
        ],
        returns: 'True if obj is a Point2d and has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'bool Equals(Point2d point)',
        summary: 'Determines whether the specified Point2d has the same values as the present point.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'The specified point.'
          }
        ],
        returns: 'True if point has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Computes a hash number that represents the current point.',
        returns: 'A hash code that is not unique for each point.'
      },
      {
        signature: 'string ToString()',
        summary: 'Constructs the string representation for the current point.',
        returns: 'The point representation in the form X,Y.'
      },
      {
        signature: 'string ToString(string format,IFormatProvider formatProvider)',
        since: 7
      },
      {
        signature: 'void Transform(Transform xform)',
        summary: `Transforms the present point in place. The transformation matrix acts on the left of the point. i.e.,
     result = transformation*point`,
        since: 5.1,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation to apply.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Point2f',
    dataType: 2,
    summary: `Represents the two coordinates of a point in two-dimensional space,
   using Single-precision floating point numbers.`,
    constructors: [
      {
        signature: 'Point2f(double x,double y)',
        summary: `Initializes a new two-dimensional point from two double-precision floating point numbers as coordinates.
     Coordinates will be internally converted to floating point numbers. This might cause precision loss.`,
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X component of vector.'
          },
          {
            name: 'y',
            summary: 'Y component of vector.'
          }
        ]
      },
      {
        signature: 'Point2f(float x,float y)',
        summary: 'Initializes a new two-dimensional point from two components.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X component of vector.'
          },
          {
            name: 'y',
            summary: 'Y component of vector.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Point2f Unset',
        summary: 'Gets the standard unset point.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: 'Gets a value indicating whether this point is considered valid.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'float X',
        summary: 'Gets or sets the X (first) component of the vector.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'float Y',
        summary: 'Gets or sets the Y (second) component of the vector.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'int CompareTo(Point2f other)',
        summary: `Compares this Point2f with another Point2f.
     Coordinates evaluation priority is first X, then Y.`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The other Point2f to use in comparison.'
          }
        ],
        returns: '0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y+1: otherwise.'
      },
      {
        signature: 'bool EpsilonEquals(Point2f other,float epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines whether the specified System.Object is a Point2f and has the same values as the present point.',
        parameters: [
          {
            name: 'obj',
            summary: 'The specified object.'
          }
        ],
        returns: 'True if obj is Point2f and has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'bool Equals(Point2f point)',
        summary: 'Determines whether the specified Point2f has the same values as the present point.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'The specified point.'
          }
        ],
        returns: 'True if point has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Computes a hash number that represents the current point.',
        returns: 'A hash code that is not unique for each point.'
      },
      {
        signature: 'string ToString()',
        summary: 'Constructs the string representation for the current point.',
        returns: 'The point representation in the form X,Y.'
      },
      {
        signature: 'string ToString(string format,IFormatProvider formatProvider)',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Point3d',
    dataType: 2,
    summary: `Represents the three coordinates of a point in three-dimensional space,
   using double-precision floating point values.`,
    constructors: [
      {
        signature: 'Point3d(double x,double y,double z)',
        summary: 'Initializes a new point by defining the X, Y and Z coordinates.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'The value of the X (first) coordinate.'
          },
          {
            name: 'y',
            summary: 'The value of the Y (second) coordinate.'
          },
          {
            name: 'z',
            summary: 'The value of the Z (third) coordinate.'
          }
        ]
      },
      {
        signature: 'Point3d(Point3d point)',
        summary: 'Initializes a new point by copying coordinates from another point.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          }
        ]
      },
      {
        signature: 'Point3d(Point3f point)',
        summary: 'Initializes a new point by copying coordinates from a single-precision point.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          }
        ]
      },
      {
        signature: 'Point3d(Point4d point)',
        summary: `Initializes a new point by copying coordinates from a four-dimensional point.
     The first three coordinates are divided by the last one.
     If the W (fourth) dimension of the input point is zero, then it will be just discarded.`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          }
        ]
      },
      {
        signature: 'Point3d(Vector3d vector)',
        summary: 'Initializes a new point by copying coordinates from the components of a vector.',
        since: 5,
        parameters: [
          {
            name: 'vector',
            summary: 'A vector.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Point3d Origin',
        summary: 'Gets the value of a point at location 0,0,0.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Point3d Unset',
        summary: 'Gets the value of a point at location RhinoMath.UnsetValue,RhinoMath.UnsetValue,RhinoMath.UnsetValue.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: 'Each coordinate of the point must pass the RhinoMath.IsValidDouble test.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double MaximumCoordinate',
        summary: `Gets the largest (both positive and negative) valid coordinate in this point,
     or RhinoMath.UnsetValue if no coordinate is valid.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double MinimumCoordinate',
        summary: 'Gets the smallest (both positive and negative) coordinate value in this point.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double X',
        summary: 'Gets or sets the X (first) coordinate of this point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Y',
        summary: 'Gets or sets the Y (second) coordinate of this point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Z',
        summary: 'Gets or sets the Z (third) coordinate of this point.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Point3d Add(Point3d point1,Point3d point2)',
        summary: `Sums two Point3d instances.
     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point1',
            summary: 'A point.'
          },
          {
            name: 'point2',
            summary: 'A point.'
          }
        ],
        returns: 'A new point that results from the addition of point1 and point2.'
      },
      {
        signature: 'static Point3d Add(Point3d point,Vector3d vector)',
        summary: `Sums up a point and a vector, and returns a new point.
     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 'vector',
            summary: 'A vector.'
          }
        ],
        returns: 'A new point that results from the addition of point and vector.'
      },
      {
        signature: 'static Point3d Add(Point3d point,Vector3f vector)',
        summary: `Sums up a point and a vector, and returns a new point.
     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 'vector',
            summary: 'A vector.'
          }
        ],
        returns: 'A new point that results from the addition of point and vector.'
      },
      {
        signature: 'static Point3d Add(Vector3d vector,Point3d point)',
        summary: `Sums up a point and a vector, and returns a new point.
     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'vector',
            summary: 'A vector.'
          },
          {
            name: 'point',
            summary: 'A point.'
          }
        ],
        returns: 'A new point that results from the addition of point and vector.'
      },
      {
        signature: 'static bool ArePointsCoplanar(IEnumerable<Point3d> points,double tolerance)',
        summary: 'Determines whether a set of points is coplanar within a given tolerance.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A list, an array or any enumerable of Point3d.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value. A default might be RhinoMath.ZeroTolerance.'
          }
        ],
        returns: 'True if points are on the same plane; False otherwise.'
      },
      {
        signature: 'static Point3d[] CullDuplicates(IEnumerable<Point3d> points,double tolerance)',
        summary: 'Removes duplicates in the supplied set of points.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A list, an array or any enumerable of Point3d.'
          },
          {
            name: 'tolerance',
            summary: `The minimum distance between points.
     Points that fall within this tolerance will be discarded.
     .`
          }
        ],
        returns: 'An array of points without duplicates; or None on error.'
      },
      {
        signature: 'static Point3d Divide(Point3d point,double t)',
        summary: `Divides a Point3d by a number.
     (Provided for languages that do not support operator overloading. You can use the / operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 't',
            summary: 'A number.'
          }
        ],
        returns: 'A new point that is coordinatewise divided by t.'
      },
      {
        signature: 'static Point3d FromPoint3f(Point3f point)',
        summary: 'Converts a single-precision point in a double-precision point.',
        since: 6,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          }
        ],
        returns: 'The resulting point.'
      },
      {
        signature: 'static Point3d Multiply(double t,Point3d point)',
        summary: `Multiplies a Point3d by a number.
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'A number.'
          },
          {
            name: 'point',
            summary: 'A point.'
          }
        ],
        returns: 'A new point that is coordinatewise multiplied by t.'
      },
      {
        signature: 'static Point3d Multiply(Point3d point,double t)',
        summary: `Multiplies a Point3d by a number.
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 't',
            summary: 'A number.'
          }
        ],
        returns: 'A new point that is coordinatewise multiplied by t.'
      },
      {
        signature: 'static Point3d[] SortAndCullPointList(IEnumerable<Point3d> points,double minimumDistance)',
        summary: `Orders a set of points so they will be connected in a "reasonable polyline" order.
     Also, removes points from the list if their common distance exceeds a specified threshold.`,
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A list, an array or any enumerable of Point3d.'
          },
          {
            name: 'minimumDistance',
            summary: 'Minimum allowed distance among a pair of points. If points are closer than this, only one of them will be kept.'
          }
        ],
        returns: 'The new array of sorted and culled points.'
      },
      {
        signature: 'static Vector3d Subtract(Point3d point1,Point3d point2)',
        summary: `Subtracts a point from another point.
     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point1',
            summary: 'A point.'
          },
          {
            name: 'point2',
            summary: 'Another point.'
          }
        ],
        returns: 'A new vector that is the difference of point minus vector.'
      },
      {
        signature: 'static Point3d Subtract(Point3d point,Vector3d vector)',
        summary: `Subtracts a vector from a point.
     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 'vector',
            summary: 'A vector.'
          }
        ],
        returns: 'A new point that is the difference of point minus vector.'
      },
      {
        signature: 'static bool TryParse(string input,Point3d result)',
        summary: 'Converts the string representation of a point to the equivalent Point3d structure.',
        since: 6.12,
        parameters: [
          {
            name: 'input',
            summary: 'The point to convert.'
          },
          {
            name: 'result',
            summary: 'The structure that will contain the parsed value.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'int CompareTo(Point3d other)',
        summary: `Compares this Point3d with another Point3d.
     Component evaluation priority is first X, then Y, then Z.`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The other Point3d to use in comparison.'
          }
        ],
        returns: '0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y-1: if this.X == other.X and this.Y == other.Y and this.Z < other.Z+1: otherwise.'
      },
      {
        signature: 'double DistanceTo(Point3d other)',
        summary: 'Computes the distance between two points.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Other point for distance measurement.'
          }
        ],
        returns: 'The length of the line between this and the other point; or 0 if any of the points is not valid.'
      },
      {
        signature: 'double DistanceToSquared(Point3d other)',
        summary: `Computes the square of the distance between two points.
     This method is usually largely faster than DistanceTo().`,
        since: 6,
        parameters: [
          {
            name: 'other',
            summary: 'Other point for squared distance measurement.'
          }
        ],
        returns: 'The squared length of the line between this and the other point; or 0 if any of the points is not valid.'
      },
      {
        signature: 'bool EpsilonEquals(Point3d other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines whether the specified object is a Point3d and has the same values as the present point.',
        parameters: [
          {
            name: 'obj',
            summary: 'The specified object.'
          }
        ],
        returns: 'True if obj is a Point3d and has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'bool Equals(Point3d point)',
        summary: 'Determines whether the specified Point3d has the same values as the present point.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'The specified point.'
          }
        ],
        returns: 'True if point has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Computes a hash code for the present point.',
        returns: 'A non-unique integer that represents this point.'
      },
      {
        signature: 'void Interpolate(Point3d pA,Point3d pB,double t)',
        summary: 'Interpolate between two points.',
        since: 5,
        parameters: [
          {
            name: 'pA',
            summary: 'First point.'
          },
          {
            name: 'pB',
            summary: 'Second point.'
          },
          {
            name: 't',
            summary: `Interpolation parameter. 
     If t=0 then this point is set to pA. 
     If t=1 then this point is set to pB. 
     Values of t in between 0.0 and 1.0 result in points between pA and pB.`
          }
        ]
      },
      {
        signature: 'string ToString()',
        summary: 'Constructs the string representation for the current point.',
        returns: 'The point representation in the form X,Y,Z.'
      },
      {
        signature: 'string ToString(string format,IFormatProvider formatProvider)',
        since: 7
      },
      {
        signature: 'void Transform(Transform xform)',
        summary: `Transforms the present point in place. The transformation matrix acts on the left of the point. i.e.,
     result = transformation*point`,
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation to apply.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Point3dGrid',
    dataType: 1,
    summary: 'Represents a rectangular grid of 3D points.',
    baseclass: 'Rhino.Geometry.GeometryBase',
    constructors: [
      {
        signature: 'Point3dGrid()',
        summary: 'Initializes a rectangular grid of points, with no points in it.',
        since: 5
      },
      {
        signature: 'Point3dGrid(int rows,int columns)',
        summary: 'Initializes a rectangular grid of points with a given number of columns and rows.',
        since: 5,
        parameters: [
          {
            name: 'rows',
            summary: 'An amount of rows.'
          },
          {
            name: 'columns',
            summary: 'An amount of columns.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Point3f',
    dataType: 2,
    summary: `Represents the three coordinates of a point in three-dimensional space,
   using Single-precision floating point numbers.`,
    constructors: [
      {
        signature: 'Point3f(float x,float y,float z)',
        summary: 'Initializes a new two-dimensional vector from two components.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X component of vector.'
          },
          {
            name: 'y',
            summary: 'Y component of vector.'
          },
          {
            name: 'z',
            summary: 'Z component of vector.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Point3f Origin',
        summary: 'Gets the value of a point at location 0,0,0.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Point3f Unset',
        summary: 'Gets the value of a point at location RhinoMath.UnsetValue,RhinoMath.UnsetValue,RhinoMath.UnsetValue.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: 'Each coordinate of the point must pass the RhinoMath.IsValidSingle test.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'float X',
        summary: 'Gets or sets the X (first) component of the vector.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'float Y',
        summary: 'Gets or sets the Y (second) component of the vector.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'float Z',
        summary: 'Gets or sets the Z (third) component of the vector.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Vector3f Subtract(Point3f point1,Point3f point2)',
        summary: `Subtracts a point from another point.
     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point1',
            summary: 'A point.'
          },
          {
            name: 'point2',
            summary: 'Another point.'
          }
        ],
        returns: 'A new vector that is the difference of point minus vector.'
      },
      {
        signature: 'int CompareTo(Point3f other)',
        summary: `Compares this Point3f with another Point3f.
     Component evaluation priority is first X, then Y, then Z.`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The other Point3d to use in comparison.'
          }
        ],
        returns: '0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y-1: if this.X == other.X and this.Y == other.Y and this.Z < other.Z+1: otherwise.'
      },
      {
        signature: 'double DistanceTo(Point3f other)',
        summary: 'Computes the distance between two points.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Other point for distance measurement.'
          }
        ],
        returns: 'The length of the line between this and the other point; or 0 if any of the points is not valid.'
      },
      {
        signature: 'bool EpsilonEquals(Point3f other,float epsilon)',
        summary: 'Check that all values in other are withing epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines whether the specified System.Object is a Point3f and has the same values as the present point.',
        parameters: [
          {
            name: 'obj',
            summary: 'The specified object.'
          }
        ],
        returns: 'True if obj is Point3f and has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'bool Equals(Point3f point)',
        summary: 'Determines whether the specified Point3f has the same values as the present point.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'The specified point.'
          }
        ],
        returns: 'True if point has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Computes a hash code for the present point.',
        returns: 'A non-unique integer that represents this point.'
      },
      {
        signature: 'string ToString()',
        summary: 'Constructs the string representation for the current point.',
        returns: 'The point representation in the form X,Y,Z.'
      },
      {
        signature: 'string ToString(string format,IFormatProvider formatProvider)',
        since: 7
      },
      {
        signature: 'void Transform(Transform xform)',
        summary: `Transforms the present point in place. The transformation matrix acts on the left of the point. i.e.,
     result = transformation*point`,
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation to apply.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Point4d',
    dataType: 2,
    summary: `Represents the four coordinates of a point in four-dimensional space.
   The W (fourth) dimension is often considered the weight of the point as seen in 3D space.`,
    constructors: [
      {
        signature: 'Point4d(double x,double y,double z,double w)',
        summary: 'Initializes a new instance of the Point4d class based on coordinates.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'The X (first) dimension.'
          },
          {
            name: 'y',
            summary: 'The Y (second) dimension.'
          },
          {
            name: 'z',
            summary: 'The Z (third) dimension.'
          },
          {
            name: 'w',
            summary: 'The W (fourth) dimension, or weight.'
          }
        ]
      },
      {
        signature: 'Point4d(Point3d point)',
        summary: 'Initializes a new instance of the Point4d class from the coordinates of a point.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: '.'
          }
        ]
      },
      {
        signature: 'Point4d(Point4d point)',
        summary: 'Initializes a new point by copying coordinates from another point.',
        since: 6,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Point4d Unset',
        summary: 'Gets the value of a point with all coordinates set as RhinoMath.UnsetValue.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: 'Returns an indication regarding the validity of this point.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'double W',
        summary: 'Gets or sets the W (fourth) coordinate -or weight- of this point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double X',
        summary: 'Gets or sets the X (first) coordinate of this point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Y',
        summary: 'Gets or sets the Y (second) coordinate of this point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Z',
        summary: 'Gets or sets the Z (third) coordinate of this point.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Point4d Add(Point4d point1,Point4d point2)',
        summary: `Sums two Point4d together.
     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point1',
            summary: 'First point.'
          },
          {
            name: 'point2',
            summary: 'Second point.'
          }
        ],
        returns: 'A new point that results from the weighted addition of point1 and point2.'
      },
      {
        signature: 'static Point4d Multiply(Point4d point,double d)',
        summary: `Multiplies a point by a number.
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 'd',
            summary: 'A number.'
          }
        ],
        returns: 'A new point that results from the coordinatewise multiplication of point with d.'
      },
      {
        signature: 'static Point4d Subtract(Point4d point1,Point4d point2)',
        summary: `Subtracts the second point from the first point.
     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point1',
            summary: 'First point.'
          },
          {
            name: 'point2',
            summary: 'Second point.'
          }
        ],
        returns: 'A new point that results from the weighted subtraction of point2 from point1.'
      },
      {
        signature: 'bool EpsilonEquals(Point4d other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines whether the specified System.Object is Point4d and has same coordinates as the present point.',
        parameters: [
          {
            name: 'obj',
            summary: 'The specified object.'
          }
        ],
        returns: 'True if obj is Point4d and has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'bool Equals(Point4d point)',
        summary: 'Determines whether the specified point has same value as the present point.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'The specified point.'
          }
        ],
        returns: 'True if point has the same value as this; otherwise false.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Computes the hash code for the present point.',
        returns: 'A non-unique hash code, which uses all coordiantes of this object.'
      },
      {
        signature: 'string ToString()'
      },
      {
        signature: 'string ToString(string format,IFormatProvider formatProvider)',
        since: 7
      },
      {
        signature: 'void Transform(Transform xform)',
        summary: `Transforms the present point in place. The transformation matrix acts on the left of the point. i.e.,
     result = transformation*point`,
        since: 6,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation to apply.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'PointCloud',
    dataType: 1,
    summary: 'Represents a collection of coordinates with optional normal vectors and colors.',
    baseclass: 'Rhino.Geometry.GeometryBase',
    interfaces: ['IEnumerable<PointCloudItem>'],
    constructors: [
      {
        signature: 'PointCloud()',
        summary: `Initializes a new instance of the PointCloud class
     that is empty.`,
        since: 5
      },
      {
        signature: 'PointCloud(IEnumerable<Point3d> points)',
        summary: `Initializes a new instance of the PointCloud class,
     copying the content from a set of points.`,
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A list or an array of Point3d, or any object that implements IEnumerable{Point3d}.'
          }
        ]
      },
      {
        signature: 'PointCloud(PointCloud other)',
        summary: `Initializes a new instance of the PointCloud class,
     copying (Merge) the content of another pointcloud.`,
        since: 5
      }
    ],
    properties: [
      {
        signature: 'bool ContainsColors',
        summary: `Gets a value indicating whether or not the points in this 
     pointcloud have colors assigned to them.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool ContainsHiddenFlags',
        summary: `Gets a value indicating whether or not the points in this 
     pointcloud have hidden flags assigned to them.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool ContainsNormals',
        summary: `Gets a value indicating whether or not the points in this 
     pointcloud have normals assigned to them.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Count',
        summary: 'Gets the number of points in this pointcloud.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int HiddenPointCount',
        summary: 'Gets the number of points that have their Hidden flag set.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(Point3d point)',
        summary: 'Append a new point to the end of the list.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to append.'
          }
        ]
      },
      {
        signature: 'void Add(Point3d point,Color color)',
        summary: 'Append a new point to the end of the list.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to append.'
          },
          {
            name: 'color',
            summary: 'Color of new point.'
          }
        ]
      },
      {
        signature: 'void Add(Point3d point,Vector3d normal)',
        summary: 'Append a new point to the end of the list.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to append.'
          },
          {
            name: 'normal',
            summary: 'Normal vector of new point.'
          }
        ]
      },
      {
        signature: 'void Add(Point3d point,Vector3d normal,Color color)',
        summary: 'Append a new point to the end of the list.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to append.'
          },
          {
            name: 'normal',
            summary: 'Normal vector of new point.'
          },
          {
            name: 'color',
            summary: 'Color of new point.'
          }
        ]
      },
      {
        signature: 'void AddRange(IEnumerable<Point3d> points)',
        summary: 'Appends a collection of points to this point cloud.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to append.'
          }
        ]
      },
      {
        signature: 'void AddRange(IEnumerable<Point3d> points,IEnumerable<Color> colors)',
        summary: 'Appends a collection of points and normal vectors to this point cloud.',
        since: 6,
        parameters: [
          {
            name: 'points',
            summary: 'Points to append.'
          },
          {
            name: 'colors',
            summary: 'Colors to append.'
          }
        ]
      },
      {
        signature: 'void AddRange(IEnumerable<Point3d> points,IEnumerable<Vector3d> normals)',
        summary: 'Appends a collection of points and normal vectors to this point cloud.',
        since: 6,
        parameters: [
          {
            name: 'points',
            summary: 'Points to append.'
          },
          {
            name: 'normals',
            summary: 'Normal Vectors to append.'
          }
        ]
      },
      {
        signature: 'void AddRange(IEnumerable<Point3d> points,IEnumerable<Vector3d> normals,IEnumerable<Color> colors)',
        summary: 'Appends a collection of points and normal vectors to this point cloud.',
        since: 6,
        parameters: [
          {
            name: 'points',
            summary: 'Points to append.'
          },
          {
            name: 'normals',
            summary: 'Normal Vectors to append.'
          },
          {
            name: 'colors',
            summary: 'Colors to append.'
          }
        ]
      },
      {
        signature: 'PointCloudItem AppendNew()',
        summary: 'Appends a new PointCloudItem to the end of this point cloud.',
        since: 5,
        returns: 'The newly appended item.'
      },
      {
        signature: 'IReadOnlyList<Point3d> AsReadOnlyListOfPoints()',
        summary: 'Returns an enumerator and list indexer over point cloud locations.',
        since: 6,
        returns: 'The read-only list. This is a reference to the present point cloud.'
      },
      {
        signature: 'void ClearColors()',
        summary: 'Destroys the color information in this point cloud.',
        since: 5
      },
      {
        signature: 'void ClearHiddenFlags()',
        summary: 'Destroys the hidden flag information in this point cloud.',
        since: 5
      },
      {
        signature: 'void ClearNormals()',
        summary: 'Destroys the normal vector information in this point cloud.',
        since: 5
      },
      {
        signature: 'int ClosestPoint(Point3d testPoint)',
        summary: 'Returns index of the closest point in the point cloud to a given test point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: '.'
          }
        ],
        returns: 'Index of point in the point cloud on success. -1 on failure.'
      },
      {
        signature: 'Color[] GetColors()',
        summary: 'Copy all the point colors in this point cloud to an array.',
        since: 5,
        returns: 'An array containing all the colors in this point cloud.'
      },
      {
        signature: 'IEnumerator<PointCloudItem> GetEnumerator()',
        summary: 'Gets an enumerator that allows to modify each pointcloud point.',
        since: 5,
        returns: 'A instance of IEnumerator{PointCloudItem}.'
      },
      {
        signature: 'Vector3d[] GetNormals()',
        summary: 'Copy all the normal vectors in this point cloud to an array.',
        since: 5,
        returns: 'An array containing all the normals in this point cloud.'
      },
      {
        signature: 'Point3d[] GetPoints()',
        summary: 'Copy all the point coordinates in this point cloud to an array.',
        since: 5,
        returns: 'An array containing all the points in this point cloud.'
      },
      {
        signature: 'void Insert(int index,Point3d point)',
        summary: 'Inserts a new point into the point list.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Insertion index.'
          },
          {
            name: 'point',
            summary: 'Point to append.'
          }
        ]
      },
      {
        signature: 'void Insert(int index,Point3d point,Color color)',
        summary: 'Inserts a new point into the point list.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Insertion index.'
          },
          {
            name: 'point',
            summary: 'Point to append.'
          },
          {
            name: 'color',
            summary: 'Color of new point.'
          }
        ]
      },
      {
        signature: 'void Insert(int index,Point3d point,Vector3d normal)',
        summary: 'Inserts a new point into the point list.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Insertion index.'
          },
          {
            name: 'point',
            summary: 'Point to append.'
          },
          {
            name: 'normal',
            summary: 'Normal vector of new point.'
          }
        ]
      },
      {
        signature: 'void Insert(int index,Point3d point,Vector3d normal,Color color)',
        summary: 'Inserts a new point into the point list.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Insertion index.'
          },
          {
            name: 'point',
            summary: 'Point to append.'
          },
          {
            name: 'normal',
            summary: 'Normal vector of new point.'
          },
          {
            name: 'color',
            summary: 'Color of new point.'
          }
        ]
      },
      {
        signature: 'PointCloudItem InsertNew(int index)',
        summary: 'Inserts a new PointCloudItem at a specific position of the point cloud.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of new item.'
          }
        ],
        returns: 'The newly inserted item.'
      },
      {
        signature: 'void InsertRange(int index,IEnumerable<Point3d> points)',
        summary: 'Append a collection of points to this point cloud.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index at which to insert the new collection.'
          },
          {
            name: 'points',
            summary: 'Points to append.'
          }
        ]
      },
      {
        signature: 'void Merge(PointCloud other)',
        summary: 'Copies the point values of another pointcloud into this one.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'PointCloud to merge with this one.'
          }
        ]
      },
      {
        signature: 'Point3d PointAt(int index)',
        summary: 'Returns the location of the point at a specific index.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'The index.'
          }
        ]
      },
      {
        signature: 'void RemoveAt(int index)',
        summary: 'Remove the point at the given index.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of point to remove.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'PointCloudItem',
    dataType: 1,
    summary: `Represents a single item in a pointcloud. A PointCloud item 
   always has a location, but it has an optional normal vector and color.`,
    properties: [
      {
        signature: 'Color Color',
        summary: 'Gets or sets the color of this point cloud item.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool Hidden',
        summary: 'Gets or sets the hidden flag of this point cloud item.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int Index',
        summary: 'Gets the index of this point cloud item.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d Location',
        summary: 'Gets or sets the location of this point cloud item.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d Normal',
        summary: 'Gets or sets the normal vector for this point cloud item.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double X',
        summary: 'Gets or sets the X component of this point cloud item location.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Y',
        summary: 'Gets or sets the Y component of this point cloud item location.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Z',
        summary: 'Gets or sets the Z component of this point cloud item location.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'PointContainment',
    dataType: 3,
    summary: 'Defines enumerated values for closed curve/point spatial relationships.',
    values: [
      {
        signature: 'Unset',
        summary: 'Relation is meaningless.'
      },
      {
        signature: 'Inside',
        summary: 'Point is on the interior of the region implied by the closed curve.'
      },
      {
        signature: 'Outside',
        summary: 'Point is on the exterior of the region implied by the closed curve.'
      },
      {
        signature: 'Coincident',
        summary: 'Point is coincident with the curve and therefor neither inside not outside.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'PointFaceRelation',
    dataType: 3,
    summary: 'Enumerates the possible point/BrepFace spatial relationships.',
    values: [
      {
        signature: 'Exterior = 0',
        summary: 'Point is on the exterior (the trimmed part) of the face.'
      },
      {
        signature: 'Interior = 1',
        summary: 'Point is on the interior (the existing part) of the face.'
      },
      {
        signature: 'Boundary = 2',
        summary: 'Point is in limbo.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'PolyCurve',
    dataType: 1,
    summary: `Represents a curve that is the result of joining several (possibly different)
   types of curves.`,
    baseclass: 'Rhino.Geometry.Curve',
    constructors: [
      {
        signature: 'PolyCurve()',
        summary: 'Initializes a new, empty polycurve.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'bool HasGap',
        summary: 'This is a quick way to see if the curve has gaps between the sub curve segments.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsNested',
        summary: 'Gets a value indicating whether or not a PolyCurve contains nested PolyCurves.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int SegmentCount',
        summary: 'Gets the number of segments that make up this Polycurve.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool Append(Arc arc)',
        summary: `Appends and matches the start of the arc to the end of polycurve. 
     This function will fail if the polycurve is closed or if SegmentCount > 0 and the arc is closed.`,
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'Arc segment to append.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Append(Curve curve)',
        summary: `Appends and matches the start of the curve to the end of polycurve. 
     This function will fail if the PolyCurve is closed or if SegmentCount > 0 and the new segment is closed.`,
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Segment to append.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Append(Line line)',
        summary: `Appends and matches the start of the line to the end of polycurve. 
     This function will fail if the polycurve is closed.`,
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'Line segment to append.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool AppendSegment(Curve curve)',
        summary: `Appends the curve to the polycurve without changing the new segment's geometry. 
     This function will fail if the PolyCurve is closed or if SegmentCount > 0 and the new segment is closed.`,
        since: 6,
        parameters: [
          {
            name: 'curve',
            summary: 'Segment to append.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'Curve CleanUp()',
        summary: `Removes any nesting of polycurves. If this polycurve has just a single segment, the segment is returned.
     If, after nest removal, there are adjacent segments which are polylines, they are combined into a single polyline.
     The new curve may have a different domain from this polycurve. If the start and end segments of a closed input are polylines,
     the result may have a different seam location since the start and end segments will be combined.`,
        since: 7,
        returns: 'A new curve that is not necessarily a polycurve if succesful, None otherwise.'
      },
      {
        signature: 'GeometryBase Duplicate()',
        summary: `Duplicates this polycurve.
     When not overridden in a derived class, this calls .`,
        since: 5,
        returns: 'An exact duplicate of this curve.'
      },
      {
        signature: 'PolyCurve DuplicatePolyCurve()',
        summary: `Duplicates this polycurve.
     This is the same as .`,
        since: 5,
        returns: 'An exact duplicate of this curve.'
      },
      {
        signature: 'Curve[] Explode()',
        summary: `Explodes this PolyCurve into a list of Curve segments. This will not explode nested polycurves. 
     Call RemoveNesting first if you need all individual segments.`,
        since: 5,
        returns: 'An array of polycurve segments.'
      },
      {
        signature: 'double PolyCurveParameter(int segmentIndex,double segmentCurveParameter)',
        summary: 'Converts a segment curve parameter to a polycurve parameter.',
        since: 5,
        parameters: [
          {
            name: 'segmentIndex',
            summary: 'Index of segment.'
          },
          {
            name: 'segmentCurveParameter',
            summary: 'Parameter on segment.'
          }
        ],
        returns: 'Polycurve evaluation parameter or UnsetValue if the polycurve curve parameter could not be computed.'
      },
      {
        signature: 'bool RemoveNesting()',
        summary: `Explodes nested polycurve segments and reconstructs this curve from the shattered remains. 
     The result will have not have any PolyCurves as segments but it will have identical 
     locus and parameterization.`,
        since: 5,
        returns: 'True if any nested PolyCurve was found and absorbed, False if no PolyCurve segments could be found.'
      },
      {
        signature: 'Curve SegmentCurve(int index)',
        summary: 'Gets the segment curve at the given index.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of segment to retrieve.'
          }
        ],
        returns: 'The segment at the given index or None on failure.'
      },
      {
        signature: 'double SegmentCurveParameter(double polycurveParameter)',
        summary: 'Converts a polycurve parameter to a segment curve parameter.',
        since: 5,
        parameters: [
          {
            name: 'polycurveParameter',
            summary: 'Parameter on PolyCurve to convert.'
          }
        ],
        returns: `Segment curve evaluation parameter or UnsetValue if the 
     segment curve parameter could not be computed.`
      },
      {
        signature: 'Interval SegmentDomain(int segmentIndex)',
        summary: 'Returns the polycurve subdomain assigned to a segment curve.',
        since: 5,
        parameters: [
          {
            name: 'segmentIndex',
            summary: 'Index of segment.'
          }
        ],
        returns: `The polycurve subdomain assigned to a segment curve. 
     Returns Interval.Unset if segment_index < 0 or segment_index >= Count().`
      },
      {
        signature: 'int SegmentIndex(double polycurveParameter)',
        summary: 'Finds the segment used for evaluation at polycurve_parameter.',
        since: 5,
        parameters: [
          {
            name: 'polycurveParameter',
            summary: 'Parameter on polycurve for segment lookup.'
          }
        ],
        returns: `Index of the segment used for evaluation at polycurve_parameter. 
     If polycurve_parameter < Domain.Min(), then 0 is returned. 
     If polycurve_parameter > Domain.Max(), then Count()-1 is returned.`
      },
      {
        signature: 'int SegmentIndexes(Interval subdomain,int segmentIndex0,int segmentIndex1)',
        summary: 'Finds the segments that overlap the Polycurve sub domain.',
        since: 5,
        parameters: [
          {
            name: 'subdomain',
            summary: 'Domain on this PolyCurve.'
          },
          {
            name: 'segmentIndex0',
            summary: 'Index of first segment that overlaps the subdomain.'
          },
          {
            name: 'segmentIndex1',
            summary: 'Index of last segment that overlaps the subdomain. Note that segmentIndex0 <= i < segmentIndex1.'
          }
        ],
        returns: 'Number of segments that overlap the subdomain.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Polyline',
    dataType: 1,
    summary: `Represents an ordered set of points connected by linear segments.
   Polylines are closed if start and end points coincide.`,
    baseclass: 'Rhino.Collections.Point3dList',
    interfaces: ['ICloneable'],
    constructors: [
      {
        signature: 'Polyline()',
        summary: 'Initializes a new empty polyline.',
        since: 5
      },
      {
        signature: 'Polyline(IEnumerable<Point3d> collection)',
        summary: 'Initializes a new polyline from a collection of points.',
        since: 5,
        parameters: [
          {
            name: 'collection',
            summary: 'Points to copy into the local vertex array.'
          }
        ]
      },
      {
        signature: 'Polyline(int initialCapacity)',
        summary: 'Initializes a new empty polyline with an initial capacity.',
        since: 5,
        parameters: [
          {
            name: 'initialCapacity',
            summary: 'Number of vertices this polyline can contain without resizing.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool IsClosed',
        summary: `Gets a value that indicates whether this polyline is closed. 
     The polyline is considered to be closed if its start is 
     identical to its endpoint.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: `Gets a value that indicates whether this polyline is valid. 
     Valid polylines have at least one segment, no Invalid points and no zero length segments.Closed polylines with only two segments are also not considered valid.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Length',
        summary: 'Gets the total length of the polyline.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int SegmentCount',
        summary: 'Gets the number of segments for this polyline.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Polyline CreateCircumscribedPolygon(Circle circle,int sideCount)',
        summary: 'Create a regular polygon circumscribe about a circle. The midpoints of the polygon\'s edges will be tanget to the circle.',
        since: 6.1,
        parameters: [
          {
            name: 'circle',
            summary: 'The circle.'
          },
          {
            name: 'sideCount',
            summary: 'The number of sides'
          }
        ],
        returns: 'A closed polyline if successful, None otherwise.'
      },
      {
        signature: 'static Polyline CreateInscribedPolygon(Circle circle,int sideCount)',
        summary: 'Create a regular polygon inscribed in a circle. The vertices of the polygon will be on the circle.',
        since: 6.1,
        parameters: [
          {
            name: 'circle',
            summary: 'The circle.'
          },
          {
            name: 'sideCount',
            summary: 'The number of sides'
          }
        ],
        returns: 'A closed polyline if successful, None otherwise.'
      },
      {
        signature: 'static Polyline CreateStarPolygon(Circle circle,double radius,int cornerCount)',
        summary: `Create a regular star polygon. The star begins at circle.PointAt(0) and the vertices
     alternate between being on circle and begin on a concentric circle of other_radius.`,
        since: 6.1,
        parameters: [
          {
            name: 'circle',
            summary: 'The circle.'
          },
          {
            name: 'radius',
            summary: 'The radius of other circle.'
          },
          {
            name: 'cornerCount',
            summary: 'The number of corners on the circle. There will be 2*cornerCount sides and 2*cornerCount vertices.'
          }
        ],
        returns: 'A closed polyline if successful, None otherwise.'
      },
      {
        signature: 'Polyline[] BreakAtAngles(double angle)',
        summary: `Breaks this polyline into sections at sharp kinks. 
     Closed polylines will also be broken at the first and last vertex.`,
        since: 5,
        parameters: [
          {
            name: 'angle',
            summary: 'Angle (in radians) between adjacent segments for a break to occur.'
          }
        ],
        returns: 'An array of polyline segments, or None on error.'
      },
      {
        signature: 'Point3d CenterPoint()',
        summary: 'Compute the center point of the polyline as the weighted average of all segments.',
        since: 5,
        returns: 'The weighted average of all segments.'
      },
      {
        signature: 'double ClosestParameter(Point3d testPoint)',
        summary: 'Gets the parameter along the polyline which is closest to a test-point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to approximate.'
          }
        ],
        returns: 'The parameter along the polyline closest to testPoint.'
      },
      {
        signature: 'Point3d ClosestPoint(Point3d testPoint)',
        summary: 'Gets the point on the polyline which is closest to a test-point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to approximate.'
          }
        ],
        returns: 'The point on the polyline closest to testPoint.'
      },
      {
        signature: 'int CollapseShortSegments(double tolerance)',
        summary: `Collapses all segments until none are shorter than tolerance. 
     This function is significantly slower than DeleteShortSegments, 
     since it recursively operates on the shortest segment. 
     When a segment is collapsed the end-points are placed in the center of the segment.`,
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'Tolerance to use during collapsing.'
          }
        ],
        returns: 'The number of segments that were collapsed.'
      },
      {
        signature: 'int DeleteShortSegments(double tolerance)',
        summary: `Removes all points that are closer than tolerance to the previous point. 
     Start and end points are left intact.`,
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'Vertices closer together than tolerance will be removed.'
          }
        ],
        returns: 'Number of points (and segments) removed.'
      },
      {
        signature: 'Polyline Duplicate()',
        summary: 'Returns a deep copy of this polyline instance.',
        since: 6,
        returns: 'The duplicated polyline.'
      },
      {
        signature: 'Line[] GetSegments()',
        summary: 'Constructs an array of line segments that make up the entire polyline.',
        since: 5,
        returns: 'An array of line segments or None if the polyline contains fewer than 2 points.'
      },
      {
        signature: 'bool IsClosedWithinTolerance(double tolerance)',
        summary: 'Determines whether the polyline is closed, provided a tolerance value.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: `If the distance between the start and end point of the polyline 
     is less than tolerance, the polyline is considered to be closed.`
          }
        ],
        returns: 'True if the polyline is closed to within tolerance, False otherwise.'
      },
      {
        signature: 'int MergeColinearSegments(double angleTolerance,bool includeSeam)',
        summary: `Merge co-linear consecutive segments in a polyline.
     This method will automatically remove any zero-length segments as well.`,
        since: 6.3,
        parameters: [
          {
            name: 'angleTolerance',
            summary: 'The angle tolerance between adjacent segments for co-linearlity test.'
          },
          {
            name: 'includeSeam',
            summary: 'If true, the seam point of a closed polyline will be moved forwards if it is colinear too.'
          }
        ],
        returns: 'Number of segments removed from the entire polyline.'
      },
      {
        signature: 'Point3d PointAt(double t)',
        summary: `Gets the point on the polyline at the given parameter. 
     The integer part of the parameter indicates the index of the segment.`,
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Polyline parameter.'
          }
        ],
        returns: 'The point on the polyline at t.'
      },
      {
        signature: 'int ReduceSegments(double tolerance)',
        summary: 'Constructs a reduction of this polyline by recursively removing the least significant segments.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: `Tolerance for reduction. Whenever a vertex of the polyline is more 
     significant than tolerance, it will be included in the reduction.`
          }
        ],
        returns: 'The number of vertices that disappeared due to reduction.'
      },
      {
        signature: 'Line SegmentAt(int index)',
        summary: 'Gets the line segment at the given index.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'Index of segment to retrieve.'
          }
        ],
        returns: 'Line segment at index or Line.Unset on failure.'
      },
      {
        signature: 'bool Smooth(double amount)',
        summary: `Smoothens the polyline segments by averaging adjacent vertices. 
     Smoothing requires a polyline with exclusively valid vertices.`,
        since: 5,
        parameters: [
          {
            name: 'amount',
            summary: 'Amount to smooth. Zero equals no smoothing, one equals complete smoothing.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'Vector3d TangentAt(double t)',
        summary: `Gets the unit tangent vector along the polyline at the given parameter. 
     The integer part of the parameter indicates the index of the segment.`,
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'Polyline parameter.'
          }
        ],
        returns: 'The tangent along the polyline at t.'
      },
      {
        signature: 'NurbsCurve ToNurbsCurve()',
        summary: 'Constructs a nurbs curve representation of this polyline.',
        since: 5,
        returns: 'A Nurbs curve shaped like this polyline or None on failure.'
      },
      {
        signature: 'PolylineCurve ToPolylineCurve()',
        summary: 'Constructs a polyline curve representation of this polyline.',
        since: 6,
        returns: 'A curve shaped like this polyline or None on failure.'
      },
      {
        signature: 'MeshFace[] TriangulateClosedPolyline()',
        summary: `Attempts to create a list of triangles which represent a
     triangulation of a closed polyline`,
        since: 5
      },
      {
        signature: 'Polyline Trim(Interval domain)',
        summary: 'Constructs a polyline out of a parameter subdomain in this curve.',
        since: 5,
        parameters: [
          {
            name: 'domain',
            summary: `The subdomain of the polyline. 
     The integer part of the domain parameters indicate the index of the segment.`
          }
        ],
        returns: 'The polyline as defined by the subdomain, or None on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'PolylineCurve',
    dataType: 1,
    summary: `Represents the geometry of a set of linked line segments.
   This is fundamentally a class that derives from 
   and internally contains a .`,
    baseclass: 'Rhino.Geometry.Curve',
    constructors: [
      {
        signature: 'PolylineCurve()',
        summary: 'Initializes a new empty polyline curve.',
        since: 5
      },
      {
        signature: 'PolylineCurve(IEnumerable<Point3d> points)',
        summary: 'Initializes a new polyline curve by copying its content from another set of points.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: `A list, an array or any enumerable set of points to copy from.
     This includes a Polyline object.`
          }
        ]
      },
      {
        signature: 'PolylineCurve(PolylineCurve other)',
        summary: 'Initializes a new polyline curve by copying its content from another polyline curve.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Another polyline curve.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int PointCount',
        summary: 'Gets the number of points in this polyline.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'double Parameter(int index)',
        summary: 'Gets a parameter at a specified index in the polyline curve.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'An index.'
          }
        ],
        returns: 'A parameter.'
      },
      {
        signature: 'Point3d Point(int index)',
        summary: 'Gets a point at a specified index in the polyline curve.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'An index.'
          }
        ],
        returns: 'A point.'
      },
      {
        signature: 'void SetParameter(int index,double parameter)',
        summary: 'Sets a parameter at a specified index in the polyline curve.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'An index.'
          },
          {
            name: 'parameter',
            summary: 'A parameter to set.'
          }
        ]
      },
      {
        signature: 'void SetPoint(int index,Point3d point)',
        summary: 'Sets a point at a specified index in the polyline curve.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: 'An index.'
          },
          {
            name: 'point',
            summary: 'A point location to set.'
          }
        ]
      },
      {
        signature: 'Polyline ToPolyline()',
        summary: 'Returns the underlying Polyline, or points.',
        since: 6,
        returns: 'The Polyline if successful, None of the curve has no points.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'QuadRemeshParameters',
    dataType: 1,
    summary: 'Parameters for QuadRemesh method',
    properties: [
      {
        signature: 'bool AdaptiveQuadCount',
        summary: `Respect the original Target Quad Count value as much as possible.
     True returns more quads than TargetQuadCount depending on amount of high-curvature areas.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double AdaptiveSize',
        summary: `Larger values results in for quad sizes that adjust to match input curvature.
     Smaller values results in more uniform quad sizes at the risk of less feature preservation.
     Range [0 - 100]`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool DetectHardEdges',
        summary: 'When enabled the hard edges in models will be retained.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'int GuideCurveInfluence',
        summary: `0 = Approximate
     1 = Interpolate Edge Ring
     2 = Interpolate Edge Loop
     This value is ignored if Guide Curves are not supplied`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'int PreserveMeshArrayEdgesMode',
        summary: `0=off, 1=On(Smart), 2=On(Strict) :
     Mesh array's created from Breps will have their brep face edge boundaries retained.
     Smart - Small or insignificant input faces are ignored.
     Strict - All input faces are factored in remeshed result.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'QuadRemeshSymmetryAxis SymmetryAxis',
        summary: 'Symmetry axis to use for symmetric remeshing',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'int TargetQuadCount',
        summary: 'The number of quads to try to achieve in the final remeshed object',
        since: 7,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'QuadRemeshSymmetryAxis',
    dataType: 3,
    summary: 'Symmetrical meshing axis',
    values: [
      {
        signature: 'None = 0',
        summary: 'No symmetric remeshing'
      },
      {
        signature: 'X = 1',
        summary: 'Symmetry across X axis'
      },
      {
        signature: 'Y = 2',
        summary: 'Symmetry across Y axis'
      },
      {
        signature: 'Z = 4',
        summary: 'Symmetry across Z axis'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Quaternion',
    dataType: 2,
    summary: `Represents the four coefficient values in a quaternion.
   The first value a is the real part,
   while the rest multipies i, j and k, that are imaginary.quaternion = a + bi + cj + dk`,
    constructors: [
      {
        signature: 'Quaternion(double a,double b,double c,double d)',
        summary: 'Initializes a new quaternion with the provided coefficients.',
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'A number. This is the real part.'
          },
          {
            name: 'b',
            summary: 'Another number. This is the first coefficient of the imaginary part.'
          },
          {
            name: 'c',
            summary: 'Another number. This is the second coefficient of the imaginary part.'
          },
          {
            name: 'd',
            summary: 'Another number. This is the third coefficient of the imaginary part.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Quaternion I',
        summary: 'Returns the (0,1,0,0) quaternion.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Quaternion Identity',
        summary: 'Returns the (1,0,0,0) quaternion.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Quaternion J',
        summary: 'Returns the (0,0,1,0) quaternion.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Quaternion K',
        summary: 'Returns the (0,0,0,1) quaternion.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Quaternion Zero',
        summary: 'Returns the dafault quaternion, where all coefficients are 0.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double A',
        summary: 'Gets or sets the real part of the quaternion.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double B',
        summary: 'Gets or sets the first imaginary coefficient of the quaternion.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double C',
        summary: 'Gets or sets the second imaginary coefficient of the quaternion.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Quaternion Conjugate',
        summary: `Gets a new quaternion that is the conjugate of this quaternion.
     This is (a,-b,-c,-d)`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double D',
        summary: 'Gets or sets the third imaginary coefficient of the quaternion.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Quaternion Inverse',
        summary: `Computes a new inverted quaternion,
     (a/L2, -b/L2, -c/L2, -d/L2),where L2 = length squared = (a*a + b*b + c*c + d*d).
     This is the multiplicative inverse, i.e.,
     (a,b,c,d)*(a/L2, -b/L2, -c/L2, -d/L2) = (1,0,0,0).
     If this is the zero quaternion, then the zero quaternion is returned.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsScalar',
        summary: 'True if b, c, and d are all zero.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: `Determines if the four coefficients are valid numbers within RhinoCommon.
     See .`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsVector',
        summary: 'True if a = 0 and at least one of b, c, or d is not zero.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsZero',
        summary: 'True if a, b, c, and d are all zero.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Length',
        summary: 'Returns the length or norm of the quaternion.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double LengthSquared',
        summary: 'Gets the result of (a^2 + b^2 + c^2 + d^2).',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Scalar',
        summary: `The real (scalar) part of the quaternion
     This is .`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d Vector',
        summary: `The imaginary part of the quaternion
     (B,C,D)`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Quaternion CrossProduct(Quaternion p,Quaternion q)',
        summary: `Computes the vector cross product of p and q = (0,x,y,z),
     where (x,y,z) = CrossProduct(p.Vector,q.Vector).This is not the same as the quaternion product p*q.`,
        since: 5,
        parameters: [
          {
            name: 'p',
            summary: 'A quaternion.'
          },
          {
            name: 'q',
            summary: 'Another quaternion.'
          }
        ],
        returns: 'A new quaternion.'
      },
      {
        signature: 'static double Distance(Quaternion p,Quaternion q)',
        summary: 'Returns the distance or norm of the difference between two quaternions.',
        since: 5,
        parameters: [
          {
            name: 'p',
            summary: 'A quaternion.'
          },
          {
            name: 'q',
            summary: 'Another quaternion.'
          }
        ],
        returns: '(p - q).Length()'
      },
      {
        signature: 'static Quaternion Product(Quaternion p,Quaternion q)',
        summary: 'The quaternion product of p and q.  This is the same value as p*q.',
        since: 5,
        parameters: [
          {
            name: 'p',
            summary: 'The first trasform.'
          },
          {
            name: 'q',
            summary: 'The second trasform.'
          }
        ],
        returns: 'A transform value.'
      },
      {
        signature: 'static Quaternion Rotation(double angle,Vector3d axisOfRotation)',
        summary: `Returns the unit quaternion
     cos(angle/2), sin(angle/2)*x, sin(angle/2)*y, sin(angle/2)*z
     where (x,y,z) is the unit vector parallel to axis.  This is the
     unit quaternion that represents the rotation of angle about axis.`,
        since: 5,
        parameters: [
          {
            name: 'angle',
            summary: 'An angle in radians.'
          },
          {
            name: 'axisOfRotation',
            summary: 'The axis of rotation.'
          }
        ],
        returns: 'A new quaternion.'
      },
      {
        signature: 'static Quaternion Rotation(Plane plane0,Plane plane1)',
        summary: `Returns the unit quaternion that represents the the rotation that maps
     plane0.xaxis to plane1.xaxis, plane0.yaxis to plane1.yaxis, and 
     plane0.zaxis to plane1.zaxis.`,
        since: 5,
        parameters: [
          {
            name: 'plane0',
            summary: 'The first plane.'
          },
          {
            name: 'plane1',
            summary: 'The second plane.'
          }
        ],
        returns: 'A quaternion value.'
      },
      {
        signature: 'double DistanceTo(Quaternion q)',
        summary: 'Computes the distance or norm of the difference between this and another quaternion.',
        since: 5,
        parameters: [
          {
            name: 'q',
            summary: 'Another quaternion.'
          }
        ],
        returns: '(this - q).Length.'
      },
      {
        signature: 'bool EpsilonEquals(Quaternion other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines whether an object is a quaternion and has the same value of this quaternion.',
        parameters: [
          {
            name: 'obj',
            summary: 'Another object to compare.'
          }
        ],
        returns: 'True if obj is a quaternion and has exactly equal coefficients; otherwise false.'
      },
      {
        signature: 'bool Equals(Quaternion other)',
        summary: 'Determines whether this quaternion has the same value of another quaternion.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Another quaternion to compare.'
          }
        ],
        returns: 'True if the quaternions have exactly equal coefficients; otherwise false.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Gets a non-unique but repeatable hashing code for this quaternion.',
        returns: 'A signed number.'
      },
      {
        signature: 'bool GetRotation(double angle,Vector3d axis)',
        summary: 'Returns the rotation defined by the quaternion.',
        since: 5,
        parameters: [
          {
            name: 'angle',
            summary: 'An angle in radians.'
          },
          {
            name: 'axis',
            summary: 'unit axis of rotation of 0 if (b,c,d) is the zero vector.'
          }
        ],
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool GetRotation(Plane plane)',
        summary: `Returns the frame created by applying the quaternion's rotation
     to the canonical world frame (1,0,0),(0,1,0),(0,0,1).`,
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'A plane. This out value will be assigned during this call.'
          }
        ],
        returns: 'True if the operation succeeded; otherwise, false.'
      },
      {
        signature: 'bool Invert()',
        summary: `Modifies this quaternion to become
     (a/L2, -b/L2, -c/L2, -d/L2),where L2 = length squared = (a*a + b*b + c*c + d*d).This is the multiplicative inverse, i.e.,
     (a,b,c,d)*(a/L2, -b/L2, -c/L2, -d/L2) = (1,0,0,0).`,
        since: 5,
        returns: 'True if successful. False if the quaternion is zero and cannot be inverted.'
      },
      {
        signature: 'Transform MatrixForm()',
        summary: `Returns 4x4 real valued matrix form of the quaternion
     a  b  c  d
     -b  a -d  c
     -c  d  a -b
     -d -c  b  a
     which has the same arithmetic properties as the quaternion.`,
        since: 5,
        returns: 'A transform value.'
      },
      {
        signature: 'Vector3d Rotate(Vector3d v)',
        summary: `Rotates a 3d vector. This operation is also called conjugation,
     because the result is the same as
     (q.Conjugate()*(0,x,y,x)*q/q.LengthSquared).Vector.`,
        since: 5,
        parameters: [
          {
            name: 'v',
            summary: 'The vector to be rotated.'
          }
        ],
        returns: `R*v, where R is the rotation defined by the unit quaternion.
     This is mathematically the same as the values
     (Inverse(q)*(0,x,y,z)*q).Vector
     and
     (q.Conjugate()*(0,x,y,x)*q/q.LengthSquared).Vector.`
      },
      {
        signature: 'void Set(double a,double b,double c,double d)',
        summary: 'Sets all coefficients of the quaternion.',
        since: 5
      },
      {
        signature: 'void SetRotation(double angle,Vector3d axisOfRotation)',
        summary: `Sets the quaternion to cos(angle/2), sin(angle/2)*x, sin(angle/2)*y, sin(angle/2)*z
     where (x,y,z) is the unit vector parallel to axis.  This is the unit quaternion
     that represents the rotation of angle about axis.`,
        since: 5,
        parameters: [
          {
            name: 'angle',
            summary: 'in radians.'
          },
          {
            name: 'axisOfRotation',
            summary: 'The direction of the axis of rotation.'
          }
        ]
      },
      {
        signature: 'void SetRotation(Plane plane0,Plane plane1)',
        summary: `Sets the quaternion to the unit quaternion which rotates
     plane0.xaxis to plane1.xaxis, plane0.yaxis to plane1.yaxis,
     and plane0.zaxis to plane1.zaxis.`,
        since: 5,
        parameters: [
          {
            name: 'plane0',
            summary: 'The "from" rotation plane. Origin point is ignored.'
          },
          {
            name: 'plane1',
            summary: 'The "to" rotation plane. Origin point is ignored.'
          }
        ]
      },
      {
        signature: 'bool Unitize()',
        summary: 'Scales the quaternion\'s coordinates so that a*a + b*b + c*c + d*d = 1.',
        since: 5,
        returns: 'True if successful.  False if the quaternion is zero and cannot be unitized.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'RadialDimension',
    dataType: 1,
    summary: 'Represents a dimension of a circular entity that can be measured with radius or diameter.',
    baseclass: 'Dimension',
    constructors: [
      {
        signature: 'RadialDimension()',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'AnnotationType AnnotationType',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Point2d CenterPoint',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Point2d DimlinePoint',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsDiameterDimension',
        summary: 'Gets a value indicating whether the value refers to the diameter, rather than the radius.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point2d KneePoint',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid LeaderArrowBlockId',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double LeaderArrowSize',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ArrowType LeaderArrowType',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'LeaderCurveStyle LeaderCurveStyle',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'TextHorizontalAlignment LeaderTextHorizontalAlignment',
        summary: 'Gets or sets the horizontal alignment of the radial dimension\'s text',
        since: 6.9,
        property: ['get', 'set']
      },
      {
        signature: 'Point2d RadiusPoint',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'LeaderContentAngleStyle TextAngleType',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'TextLocation TextLocation',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'TextOrientation TextOrientation',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static RadialDimension Create(DimensionStyle dimStyle,AnnotationType dimtype,Plane plane,Point3d centerpoint,Point3d radiuspoint,Point3d dimlinepoint)',
        summary: 'Initialize Dimension parameters',
        since: 6,
        parameters: [
          {
            name: 'dimStyle',
            summary: 'Dimension\'s dimstyle'
          },
          {
            name: 'dimtype',
            summary: 'AnnotationType.Diameter or AnnotationType.Radius'
          },
          {
            name: 'plane',
            summary: 'Dimension\'s plane'
          },
          {
            name: 'centerpoint',
            summary: 'Dimension\'s center point'
          },
          {
            name: 'radiuspoint',
            summary: 'Point on dimension radius'
          },
          {
            name: 'dimlinepoint',
            summary: 'Point on dimension line'
          }
        ]
      },
      {
        signature: 'bool AdjustFromPoints(Plane plane,Point3d centerpoint,Point3d radiuspoint,Point3d dimlinepoint,double rotationInPlane)',
        summary: 'Update Dimension geometry from point locations',
        since: 6,
        parameters: [
          {
            name: 'plane',
            summary: 'Dimension\'s plane'
          },
          {
            name: 'centerpoint',
            summary: 'Dimension\'s center point'
          },
          {
            name: 'radiuspoint',
            summary: 'Point on dimension radius'
          },
          {
            name: 'dimlinepoint',
            summary: 'Point on dimension line'
          },
          {
            name: 'rotationInPlane',
            summary: 'Rotation around plane origin'
          }
        ]
      },
      {
        signature: 'bool Get3dPoints(Point3d centerpoint,Point3d radiuspoint,Point3d dimlinepoint,Point3d kneepoint)',
        summary: 'Get locations of dimension\'s 3d points',
        since: 6,
        parameters: [
          {
            name: 'centerpoint',
            summary: 'Dimension\'s center point'
          },
          {
            name: 'radiuspoint',
            summary: 'Point on dimension\'s radius'
          },
          {
            name: 'dimlinepoint',
            summary: 'Point on dimension line'
          },
          {
            name: 'kneepoint',
            summary: 'Point where dimension line jogs'
          }
        ]
      },
      {
        signature: 'bool GetDisplayLines(DimensionStyle style,double scale,IEnumerable<Line> lines)'
      },
      {
        signature: 'string GetDistanceDisplayText(UnitSystem unitsystem,DimensionStyle style)',
        since: 6
      },
      {
        signature: 'bool GetTextRectangle(Point3d[] corners)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'RailType',
    dataType: 3,
    summary: 'Rail types used for creating filleted Brep edges',
    values: [
      {
        signature: 'DistanceFromEdge = 0',
        summary: 'The distance from the edge curves determines the intersection.'
      },
      {
        signature: 'RollingBall = 1',
        summary: 'The radius of a rolling ball determines the intersection.'
      },
      {
        signature: 'DistanceBetweenRails = 2',
        summary: 'The distance between the edge rails determines the intersection.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Ray3d',
    dataType: 2,
    summary: 'Represents an immutable ray in three dimensions, using position and direction.',
    constructors: [
      {
        signature: 'Ray3d(Point3d position,Vector3d direction)',
        summary: 'Initializes a new Ray3d instance.',
        since: 5,
        parameters: [
          {
            name: 'position',
            summary: 'The position.'
          },
          {
            name: 'direction',
            summary: 'The direction.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'Vector3d Direction',
        summary: 'Gets the direction vector of this ray.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d Position',
        summary: 'Gets the starting position of this ray.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool EpsilonEquals(Ray3d other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines whether the specified System.Object is a Ray3d and has the same values as the present ray.',
        parameters: [
          {
            name: 'obj',
            summary: 'The specified object.'
          }
        ],
        returns: 'True if obj is a Ray3d and has the same position and direction as this; otherwise false.'
      },
      {
        signature: 'bool Equals(Ray3d ray)',
        summary: 'Determines whether the specified Ray3d has the same value as the present ray.',
        since: 5,
        parameters: [
          {
            name: 'ray',
            summary: 'The specified ray.'
          }
        ],
        returns: 'True if ray has the same position and direction as this; otherwise false.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Computes a hashing number that represents the current ray.',
        returns: 'A signed integer that represents both postion and direction, but is not unique.'
      },
      {
        signature: 'Point3d PointAt(double t)',
        summary: 'Evaluates a point along the ray.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'The t parameter.'
          }
        ],
        returns: 'A point at (Direction*t + Position).'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Rectangle3d',
    dataType: 2,
    summary: `Represents the values of a plane and two intervals
   that form an oriented rectangle in three dimensions.`,
    constructors: [
      {
        signature: 'Rectangle3d(Plane plane,double width,double height)',
        summary: 'Initializes a new rectangle from width and height.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Base plane for Rectangle.'
          },
          {
            name: 'width',
            summary: 'Width (as measured along the base plane x-axis) of rectangle.'
          },
          {
            name: 'height',
            summary: 'Height (as measured along the base plane y-axis) of rectangle.'
          }
        ]
      },
      {
        signature: 'Rectangle3d(Plane plane,Interval width,Interval height)',
        summary: 'Initializes a new rectangle from dimensions.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Base plane for Rectangle.'
          },
          {
            name: 'width',
            summary: 'Dimension of rectangle along the base plane x-axis.'
          },
          {
            name: 'height',
            summary: 'Dimension of rectangle along the base plane y-axis.'
          }
        ]
      },
      {
        signature: 'Rectangle3d(Plane plane,Point3d cornerA,Point3d cornerB)',
        summary: 'Initializes a new rectangle from a base plane and two corner points.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Base plane for Rectangle.'
          },
          {
            name: 'cornerA',
            summary: 'First corner of Rectangle (will be projected onto plane).'
          },
          {
            name: 'cornerB',
            summary: 'Second corner of Rectangle (will be projected onto plane).'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Rectangle3d Unset',
        summary: 'Gets a rectangle with Unset components.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Area',
        summary: 'Gets the unsigned Area of the rectangle.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BoundingBox BoundingBox',
        summary: 'Gets the world aligned boundingbox for this rectangle.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d Center',
        summary: 'Gets the point in the center of the rectangle.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Circumference',
        summary: 'Gets the circumference of the rectangle.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Height',
        summary: 'Gets the signed height of the rectangle. If the Y dimension is decreasing, the height will be negative.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: `Gets a value indicating whether or not this is a valid rectangle. 
     A rectangle is considered to be valid when the base plane and both dimensions are valid.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Plane Plane',
        summary: 'Gets or sets the base plane of the rectangle.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Width',
        summary: 'Gets the signed width of the rectangle. If the X dimension is decreasing, the width will be negative.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Interval X',
        summary: 'Gets or sets the dimensions of the rectangle along the base plane X-Axis (i.e. the width).',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Interval Y',
        summary: 'Gets or sets the dimensions of the rectangle along the base plane Y-Axis (i.e. the height).',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Rectangle3d CreateFromPolyline(IEnumerable<Point3d> polyline)',
        summary: `Attempts to create a rectangle from a polyline. This method only works well for
     polylines that already closely resemble rectangles. If the polyline contains
     more than four vertices, the least significant ones will be ignored. If the
     polylines is non-orthogonal, the discrepancies will be averaged away.
     This method should not be used as a Rectangle fitter.`,
        since: 5,
        parameters: [
          {
            name: 'polyline',
            summary: 'Polyline to parse.'
          }
        ],
        returns: `A rectangle that is shaped similarly to the polyline or Rectangle3d.Unset 
     if the polyline does not represent a rectangle.`
      },
      {
        signature: 'static Rectangle3d CreateFromPolyline(IEnumerable<Point3d> polyline,double deviation,double angleDeviation)',
        summary: `Attempts to create a rectangle from a polyline. This method only works well for
     polylines that already closely resemble rectangles. If the polyline contains
     more than four vertices, the least significant ones will be ignored. If the
     polylines is non-orthogonal, the discrepancies will be averaged away.
     This method should not be used as a Rectangle fitter.`,
        since: 5,
        parameters: [
          {
            name: 'polyline',
            summary: 'Polyline to parse.'
          },
          {
            name: 'deviation',
            summary: 'On success, the deviation will contain the largest deviation between the polyline and the rectangle.'
          },
          {
            name: 'angleDeviation',
            summary: 'On success, the angleDeviation will contain the largest deviation (in radians) between the polyline edges and the rectangle edges.'
          }
        ],
        returns: `A rectangle that is shaped similarly to the polyline or Rectangle3d.Unset 
     if the polyline does not represent a rectangle.`
      },
      {
        signature: 'Point3d ClosestPoint(Point3d point)',
        summary: 'Gets the point on the rectangle that is closest to a test-point.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to project.'
          }
        ],
        returns: 'The point on or in the rectangle closest to the test point or Point3d.Unset on failure.'
      },
      {
        signature: 'Point3d ClosestPoint(Point3d point,bool includeInterior)',
        summary: 'Gets the point on the rectangle that is closest to a test-point.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'Point to project.'
          },
          {
            name: 'includeInterior',
            summary: `If false, the point is projected onto the boundary edge only, 
     otherwise the interior of the rectangle is also taken into consideration.`
          }
        ],
        returns: 'The point on the rectangle closest to the test point or Point3d.Unset on failure.'
      },
      {
        signature: 'PointContainment Contains(double x,double y)',
        summary: 'Determines if two plane parameters are included in this rectangle.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'Parameter along base plane X direction.'
          },
          {
            name: 'y',
            summary: 'Parameter along base plane Y direction.'
          }
        ],
        returns: 'Parameter Rectangle relationship.'
      },
      {
        signature: 'PointContainment Contains(Point3d pt)',
        summary: 'Determines if a point is included in this rectangle.',
        since: 5,
        parameters: [
          {
            name: 'pt',
            summary: 'Point to test. The point will be projected onto the Rectangle plane before inclusion is determined.'
          }
        ],
        returns: 'Point Rectangle relationship.'
      },
      {
        signature: 'Point3d Corner(int index)',
        summary: 'Gets the corner at the given index.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: `Index of corner, valid values are:
     0 = lower left (min-x, min-y)1 = lower right (max-x, min-y)2 = upper right (max-x, max-y)3 = upper left (min-x, max-y)`
          }
        ],
        returns: 'The point at the given corner index.'
      },
      {
        signature: 'bool EpsilonEquals(Rectangle3d other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'void MakeIncreasing()',
        summary: 'Ensures the X and Y dimensions are increasing or singleton intervals.',
        since: 5
      },
      {
        signature: 'Point3d PointAt(double t)',
        summary: 'Gets a point along the rectangle boundary.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: `Parameter along rectangle boundary. Valid values range from 0.0 to 4.0, 
     where each integer domain represents a single boundary edge.`
          }
        ],
        returns: 'The point at the given boundary parameter.'
      },
      {
        signature: 'Point3d PointAt(double x,double y)',
        summary: 'Gets a point in Rectangle space.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'Normalized parameter along Rectangle width.'
          },
          {
            name: 'y',
            summary: 'Normalized parameter along Rectangle height.'
          }
        ],
        returns: 'The point at the given x,y parameter.'
      },
      {
        signature: 'void RecenterPlane(int index)',
        summary: 'Recenters the base plane on one of the corners.',
        since: 5,
        parameters: [
          {
            name: 'index',
            summary: `Index of corner, valid values are:
     0 = lower left (min-x, min-y)1 = lower right (max-x, min-y)2 = upper right (max-x, max-y)3 = upper left (min-x, max-y)`
          }
        ]
      },
      {
        signature: 'void RecenterPlane(Point3d origin)',
        summary: 'Recenters the base plane on a new origin.',
        since: 5,
        parameters: [
          {
            name: 'origin',
            summary: 'New origin for plane.'
          }
        ]
      },
      {
        signature: 'NurbsCurve ToNurbsCurve()',
        summary: 'Constructs a nurbs curve representation of this rectangle.',
        since: 5,
        returns: 'A nurbs curve with the same shape as this rectangle.'
      },
      {
        signature: 'Polyline ToPolyline()',
        summary: 'Constructs a polyline from this rectangle.',
        since: 5,
        returns: 'A polyline with the same shape as this rectangle.'
      },
      {
        signature: 'bool Transform(Transform xform)',
        summary: 'Transforms this rectangle. Note that rectangles cannot be skewed or tapered.',
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation to apply.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'ReduceMeshParameters',
    dataType: 1,
    summary: 'Parameters for Reduce method',
    constructors: [
      {
        signature: 'ReduceMeshParameters()',
        summary: `Constructs a polygon reduction parameter object with default values.
     Users of this class should not rely on default values to stay constant
     across service releases.`,
        since: 6
      }
    ],
    properties: [
      {
        signature: 'int Accuracy',
        summary: `Integer from 1 to 10 telling how accurate reduction algorithm
     to use. Greater number gives more accurate results`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool AllowDistortion',
        summary: 'If True mesh appearance is not changed even if the target polygon count is not reached',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'CancellationToken CancelToken',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int DesiredPolygonCount',
        summary: 'Desired or target number of faces',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string Error',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int[] FaceTags',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ComponentIndex[] LockedComponents',
        summary: `List of topological mesh vertices and mesh vertices that will not be moved or deleted in reduction process.
     Each mesh vertex will lock the corresponding topological mesh vertex. In other words it is not possible to have a
     locked and non-locked mesh vertex at the same location.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool NormalizeMeshSize',
        summary: 'If True mesh is fitted to an axis aligned unit cube until reduction is complete',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'IProgress<double> ProgressReporter',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'RegionContainment',
    dataType: 3,
    summary: 'Defines enumerated values for closed curve/closed curve relationships.',
    values: [
      {
        signature: 'Disjoint = 0',
        summary: 'There is no common area between the two regions.'
      },
      {
        signature: 'MutualIntersection = 1',
        summary: 'The two curves intersect. There is therefore no full containment relationship either way.'
      },
      {
        signature: 'AInsideB = 2',
        summary: 'Region bounded by curveA (first curve) is inside of curveB (second curve).'
      },
      {
        signature: 'BInsideA = 3',
        summary: 'Region bounded by curveB (second curve) is inside of curveA (first curve).'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'RevSurface',
    dataType: 1,
    summary: `Represents a surface of revolution.
   Revolutions can be incomplete (they can form arcs).`,
    baseclass: 'Rhino.Geometry.Surface',
    properties: [
      {
        signature: 'Interval Angle',
        summary: `Gets the start and end angles of revolution in radians. 
     The interval angle must be increasing and satisfy 
     RhinoMath.ZeroTolerance < Angle.Length<= 2.0 * System.Math.PI.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'Line Axis',
        summary: 'Gets the axis of revolution.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Curve Curve',
        summary: 'Gets the revolute curve.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static RevSurface Create(Curve revoluteCurve,Line axisOfRevolution)',
        summary: 'Constructs a new surface of revolution from a generatrix curve and an axis.',
        since: 5,
        parameters: [
          {
            name: 'revoluteCurve',
            summary: 'A generatrix.'
          },
          {
            name: 'axisOfRevolution',
            summary: 'An axis.'
          }
        ],
        returns: 'A new surface of revolution, or None if any of the inputs is invalid or on error.'
      },
      {
        signature: 'static RevSurface Create(Curve revoluteCurve,Line axisOfRevolution,double startAngleRadians,double endAngleRadians)',
        summary: `Constructs a new surface of revolution from a generatrix curve and an axis.
     This overload accepts a slice start and end angles.`,
        since: 5,
        parameters: [
          {
            name: 'revoluteCurve',
            summary: 'A generatrix.'
          },
          {
            name: 'axisOfRevolution',
            summary: 'An axis.'
          },
          {
            name: 'startAngleRadians',
            summary: 'An angle in radias for the start.'
          },
          {
            name: 'endAngleRadians',
            summary: 'An angle in radias for the end.'
          }
        ],
        returns: 'A new surface of revolution, or None if any of the inputs is invalid or on error.'
      },
      {
        signature: 'static RevSurface Create(Line revoluteLine,Line axisOfRevolution)',
        summary: `Constructs a new surface of revolution from a generatrix line and an axis.
     If the operation succeeds, results can be (truncated) cones, cylinders and circular hyperboloids.`,
        since: 5,
        parameters: [
          {
            name: 'revoluteLine',
            summary: 'A generatrix.'
          },
          {
            name: 'axisOfRevolution',
            summary: 'An axis.'
          }
        ],
        returns: 'A new surface of revolution, or None if any of the inputs is invalid or on error.'
      },
      {
        signature: 'static RevSurface Create(Line revoluteLine,Line axisOfRevolution,double startAngleRadians,double endAngleRadians)',
        summary: `Constructs a new surface of revolution from a generatrix line and an axis.
     This overload accepts a slice start and end angles.Results can be (truncated) cones, cylinders and circular hyperboloids, or can fail.`,
        since: 5,
        parameters: [
          {
            name: 'revoluteLine',
            summary: 'A generatrix.'
          },
          {
            name: 'axisOfRevolution',
            summary: 'An axis.'
          },
          {
            name: 'startAngleRadians',
            summary: 'An angle in radias for the start.'
          },
          {
            name: 'endAngleRadians',
            summary: 'An angle in radias for the end.'
          }
        ],
        returns: 'A new surface of revolution, or None if any of the inputs is invalid or on error.'
      },
      {
        signature: 'static RevSurface Create(Polyline revolutePolyline,Line axisOfRevolution)',
        summary: 'Constructs a new surface of revolution from a generatrix polyline and an axis.',
        since: 5,
        parameters: [
          {
            name: 'revolutePolyline',
            summary: 'A generatrix.'
          },
          {
            name: 'axisOfRevolution',
            summary: 'An axis.'
          }
        ],
        returns: 'A new surface of revolution, or None if any of the inputs is invalid or on error.'
      },
      {
        signature: 'static RevSurface Create(Polyline revolutePolyline,Line axisOfRevolution,double startAngleRadians,double endAngleRadians)',
        summary: `Constructs a new surface of revolution from a generatrix polyline and an axis.
     This overload accepts a slice start and end angles.`,
        since: 5,
        parameters: [
          {
            name: 'revolutePolyline',
            summary: 'A generatrix.'
          },
          {
            name: 'axisOfRevolution',
            summary: 'An axis.'
          },
          {
            name: 'startAngleRadians',
            summary: 'An angle in radias for the start.'
          },
          {
            name: 'endAngleRadians',
            summary: 'An angle in radias for the end.'
          }
        ],
        returns: 'A new surface of revolution, or None if any of the inputs is invalid or on error.'
      },
      {
        signature: 'static RevSurface CreateFromCone(Cone cone)',
        summary: 'Constructs a new surface of revolution from the values of a cone.',
        since: 5,
        parameters: [
          {
            name: 'cone',
            summary: 'A cone.'
          }
        ],
        returns: 'A new surface of revolution, or None if any of the inputs is invalid or on error.'
      },
      {
        signature: 'static RevSurface CreateFromCylinder(Cylinder cylinder)',
        summary: 'Constructs a new surface of revolution from the values of a cylinder.',
        since: 5,
        parameters: [
          {
            name: 'cylinder',
            summary: 'A cylinder.'
          }
        ],
        returns: 'A new surface of revolution, or None if any of the inputs is invalid or on error.'
      },
      {
        signature: 'static RevSurface CreateFromSphere(Sphere sphere)',
        summary: 'Constructs a new surface of revolution from the values of a sphere.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'A sphere.'
          }
        ],
        returns: 'A new surface of revolution, or None if any of the inputs is invalid or on error.'
      },
      {
        signature: 'static RevSurface CreateFromTorus(Torus torus)',
        summary: 'Constructs a new surface of revolution from the values of a torus.',
        since: 5,
        parameters: [
          {
            name: 'torus',
            summary: 'A torus.'
          }
        ],
        returns: 'A new surface of revolution, or None if any of the inputs is invalid or on error.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'RTree',
    dataType: 1,
    summary: `Represents a spatial search structure based on implementations of the
   R-tree algorithm by Toni Gutman.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'RTree()',
        summary: 'Initializes a new, empty instance of the tree.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of items in this tree.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static RTree CreateFromPointArray(IEnumerable<Point3d> points)',
        summary: 'Constructs a new tree with an element for each pointcloud point.',
        since: 6,
        parameters: [
          {
            name: 'points',
            summary: 'Points.'
          }
        ],
        returns: 'A new tree, or None on error.'
      },
      {
        signature: 'static RTree CreateMeshFaceTree(Mesh mesh)',
        summary: `Constructs a new tree with an element for each face in the mesh.
     The element id is set to the index of the face.`,
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'A mesh.'
          }
        ],
        returns: 'A new tree, or None on error.'
      },
      {
        signature: 'static RTree CreatePointCloudTree(PointCloud cloud)',
        summary: 'Constructs a new tree with an element for each pointcloud point.',
        since: 5,
        parameters: [
          {
            name: 'cloud',
            summary: 'A pointcloud.'
          }
        ],
        returns: 'A new tree, or None on error.'
      },
      {
        signature: 'static IEnumerable<int[]> Point3dClosestPoints(IEnumerable<Point3d> hayPoints,IEnumerable<Point3d> needlePts,double limitDistance)',
        summary: 'Finds the point in a list of 3D points that is closest to a test point.',
        since: 6,
        parameters: [
          {
            name: 'hayPoints',
            summary: 'A series of points.'
          },
          {
            name: 'needlePts',
            summary: 'Points to search for.'
          },
          {
            name: 'limitDistance',
            summary: 'The maximum allowed distance.'
          }
        ],
        returns: 'An enumerable of arrays of indices; each array contains the indices for each of the needlePts.'
      },
      {
        signature: 'static IEnumerable<int[]> Point3dKNeighbors(IEnumerable<Point3d> hayPoints,IEnumerable<Point3d> needlePts,int amount)',
        summary: 'Finds a certain amout of points in a list of 3D points that are the k-closest to a test point.',
        since: 6,
        parameters: [
          {
            name: 'hayPoints',
            summary: 'A series of points.'
          },
          {
            name: 'needlePts',
            summary: 'Points to search for.'
          },
          {
            name: 'amount',
            summary: 'The required amount of closest neighbors to find.'
          }
        ],
        returns: 'An enumerable of arrays of indices; each array contains the indices for each of the needlePts.'
      },
      {
        signature: 'static IEnumerable<int[]> PointCloudClosestPoints(PointCloud pointcloud,IEnumerable<Point3d> needlePts,double limitDistance)',
        summary: 'Finds the point in a list of 3D points that is closest to a test point.',
        since: 6,
        parameters: [
          {
            name: 'pointcloud',
            summary: 'A point cloud to be searched.'
          },
          {
            name: 'needlePts',
            summary: 'Points to search for.'
          },
          {
            name: 'limitDistance',
            summary: 'The maximum allowed distance.'
          }
        ],
        returns: 'An enumerable of arrays of indices; each array contains the indices for each of the needlePts.'
      },
      {
        signature: 'static IEnumerable<int[]> PointCloudKNeighbors(PointCloud pointcloud,IEnumerable<Point3d> needlePts,int amount)',
        summary: 'Finds a certain amout of points in a list of 3D points that are the k-closest to a test point.',
        since: 6,
        parameters: [
          {
            name: 'pointcloud',
            summary: 'A point cloud to be searched.'
          },
          {
            name: 'needlePts',
            summary: 'Points to search for.'
          },
          {
            name: 'amount',
            summary: 'The required amount of closest neighbors to find.'
          }
        ],
        returns: 'An enumerable of arrays of indices; each array contains the indices for each of the needlePts.'
      },
      {
        signature: 'static bool SearchOverlaps(RTree treeA,RTree treeB,double tolerance,EventHandler<RTreeEventArgs> callback)',
        summary: 'Searches two R-trees for all pairs elements whose bounding boxes overlap.',
        since: 5,
        parameters: [
          {
            name: 'treeA',
            summary: 'A first tree.'
          },
          {
            name: 'treeB',
            summary: 'A second tree.'
          },
          {
            name: 'tolerance',
            summary: `If the distance between a pair of bounding boxes is less than tolerance,
     then callback is called.`
          },
          {
            name: 'callback',
            summary: 'A callback event handler.'
          }
        ],
        returns: 'True if entire tree was searched.  It is possible no results were found.'
      },
      {
        signature: 'void Clear()',
        summary: 'Removes all elements.',
        since: 5
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'bool Insert(BoundingBox box,int elementId)',
        summary: 'Inserts an element into the tree.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'A bounding box.'
          },
          {
            name: 'elementId',
            summary: 'A number.'
          }
        ],
        returns: 'True if element was successfully inserted.'
      },
      {
        signature: 'bool Insert(BoundingBox box,IntPtr elementId)',
        summary: 'Inserts an element into the tree.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'A bounding box.'
          },
          {
            name: 'elementId',
            summary: 'A pointer.'
          }
        ],
        returns: 'True if element was successfully inserted.'
      },
      {
        signature: 'bool Insert(Point2d point,int elementId)',
        summary: 'Inserts an element into the tree.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 'elementId',
            summary: 'A number.'
          }
        ],
        returns: 'True if element was successfully inserted.'
      },
      {
        signature: 'bool Insert(Point2d point,IntPtr elementId)',
        summary: 'Inserts an element into the tree.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 'elementId',
            summary: 'A pointer.'
          }
        ],
        returns: 'True if element was successfully inserted.'
      },
      {
        signature: 'bool Insert(Point3d point,int elementId)',
        summary: 'Inserts an element into the tree.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 'elementId',
            summary: 'A number.'
          }
        ],
        returns: 'True if element was successfully inserted.'
      },
      {
        signature: 'bool Insert(Point3d point,IntPtr elementId)',
        summary: 'Inserts an element into the tree.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 'elementId',
            summary: 'A pointer.'
          }
        ],
        returns: 'True if element was successfully inserted.'
      },
      {
        signature: 'bool Remove(BoundingBox box,int elementId)',
        summary: 'Removes an element from the tree.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'A bounding box.'
          },
          {
            name: 'elementId',
            summary: 'A number.'
          }
        ],
        returns: 'True if element was successfully removed.'
      },
      {
        signature: 'bool Remove(BoundingBox box,IntPtr elementId)',
        summary: 'Removes an element from the tree.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'A bounding box.'
          },
          {
            name: 'elementId',
            summary: 'A pointer.'
          }
        ],
        returns: 'True if element was successfully removed.'
      },
      {
        signature: 'bool Remove(Point2d point,int elementId)',
        summary: 'Removes an element from the tree.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 'elementId',
            summary: 'A number.'
          }
        ],
        returns: 'True if element was successfully removed.'
      },
      {
        signature: 'bool Remove(Point3d point,int elementId)',
        summary: 'Removes an element from the tree.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 'elementId',
            summary: 'A number.'
          }
        ],
        returns: 'True if element was successfully removed.'
      },
      {
        signature: 'bool Remove(Point3d point,IntPtr elementId)',
        summary: 'Removes an element from the tree.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 'elementId',
            summary: 'A pointer.'
          }
        ],
        returns: 'True if element was successfully removed.'
      },
      {
        signature: 'bool Search(BoundingBox box,EventHandler<RTreeEventArgs> callback)',
        summary: `Searches for items in a bounding box.
     The bounding box can be singular and contain exactly one single point.`,
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'A bounding box.'
          },
          {
            name: 'callback',
            summary: 'An event handler to be raised when items are found.'
          }
        ],
        returns: 'True if entire tree was searched. It is possible no results were found.'
      },
      {
        signature: 'bool Search(BoundingBox box,EventHandler<RTreeEventArgs> callback,object tag)',
        summary: `Searches for items in a bounding box.
     The bounding box can be singular and contain exactly one single point.`,
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'A bounding box.'
          },
          {
            name: 'callback',
            summary: 'An event handler to be raised when items are found.'
          },
          {
            name: 'tag',
            summary: 'State to be passed inside the RTreeEventArgs Tag property.'
          }
        ],
        returns: 'True if entire tree was searched. It is possible no results were found.'
      },
      {
        signature: 'bool Search(Sphere sphere,EventHandler<RTreeEventArgs> callback)',
        summary: 'Searches for items in a sphere.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'bounds used for searching.'
          },
          {
            name: 'callback',
            summary: 'An event handler to be raised when items are found.'
          }
        ],
        returns: 'True if entire tree was searched. It is possible no results were found.'
      },
      {
        signature: 'bool Search(Sphere sphere,EventHandler<RTreeEventArgs> callback,object tag)',
        summary: 'Searches for items in a sphere.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'bounds used for searching.'
          },
          {
            name: 'callback',
            summary: 'An event handler to be raised when items are found.'
          },
          {
            name: 'tag',
            summary: 'State to be passed inside the RTreeEventArgs Tag property.'
          }
        ],
        returns: 'True if entire tree was searched. It is possible no results were found.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'RTreeEventArgs',
    dataType: 1,
    summary: `Represents event data that is passed when when an item that meets certain 
   criteria is found and the passed RTree event is raised.`,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'bool Cancel',
        summary: 'Gets or sets a value that determines if the search should be conducted farther.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int Id',
        summary: 'Gets the identifier of the found item.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int IdB',
        summary: 'If search is using two r-trees, IdB is element b in the search.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'IntPtr IdBPtr',
        summary: 'If search is using two r-trees, IdB is the element b pointer in the search.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'IntPtr IdPtr',
        summary: 'Gets the identifier pointer of the found item.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BoundingBox SearchBoundingBox',
        summary: `Bounding box bounds used during a search. You may modify the box in a search callback
     to help reduce the bounds to search.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Sphere SearchSphere',
        summary: `Sphere bounds used during a search. You can modify the sphere in a search callback to
     help reduce the bounds to search.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'object Tag',
        summary: `Gets or sets an arbitrary object that can be attached to this event args.
     This object will "stick" through a single search and can represent user-defined state.`,
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'ShutLiningCurveInfo',
    dataType: 1,
    summary: 'Contains shutlining curve information. This is used in Mesh.WithShutLining.',
    constructors: [
      {
        signature: 'ShutLiningCurveInfo(Curve curve,double radius,int profile,bool pull,bool isBump,IEnumerable<Interval> curveIntervals,bool enabled)',
        summary: 'Creates a new instance of the ShutLining curve information class.',
        since: 6,
        parameters: [
          {
            name: 'curve',
            summary: 'The profile curve.'
          },
          {
            name: 'radius',
            summary: 'The profile radius.'
          },
          {
            name: 'profile',
            summary: 'The profile type.'
          },
          {
            name: 'pull',
            summary: 'True if the curve should be pulled.'
          },
          {
            name: 'isBump',
            summary: 'True if profile constitutes a bump. See Rhino\'s Help for more information.'
          },
          {
            name: 'curveIntervals',
            summary: 'The parts of the curve to use as profiles.'
          },
          {
            name: 'enabled',
            summary: 'If true, this curve is active.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'Curve Curve',
        summary: 'The profile curve.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'ReadOnlyCollection<Interval> CurveIntervals',
        summary: 'The parts of the curve to use as profiles.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool Enabled',
        summary: 'If true, this curve is active.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsBump',
        summary: 'True if profile constitutes a bump. See Rhino\'s Help for more information.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int Profile',
        summary: '>The profile type.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool Pull',
        summary: 'True if the curve should be pulled.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'double Radius',
        summary: 'The profile radius.',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Silhouette',
    dataType: 1,
    summary: `Information about silhouette curves that are generated from
   geometry (surfaces, brep faces, meshes)`,
    properties: [
      {
        signature: 'Curve Curve',
        summary: '3D curve representing the shape of the silhouette.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ComponentIndex GeometryComponentIndex',
        summary: `Gets the component index corresponding with this silhouette curve.
     This field is only set when the entire silhouette curve is part of some geometry component.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'SilhouetteType SilhouetteType',
        summary: 'Gets the type of this silhouette curve.',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Silhouette[] Compute(GeometryBase geometry,SilhouetteType silhouetteType,Point3d perspectiveCameraLocation,double tolerance,double angleToleranceRadians)',
        summary: 'Compute silhouettes of a shape for a perspective projection.',
        since: 6,
        parameters: [
          {
            name: 'geometry',
            summary: 'Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion.'
          },
          {
            name: 'silhouetteType',
            summary: 'Types of silhouette to compute.'
          },
          {
            name: 'perspectiveCameraLocation',
            summary: 'Location of perspective camera.'
          },
          {
            name: 'tolerance',
            summary: `Tolerance to use for determining projecting relationships. 
     Surfaces and curves that are closer than tolerance, may be treated as projecting. 
     When in doubt use RhinoDoc.ModelAbsoluteTolerance.`
          },
          {
            name: 'angleToleranceRadians',
            summary: `Angular tolerance to use for determining projecting relationships.
     A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. 
     When in doubt use RhinoDoc.ModelAngleToleranceRadians.`
          }
        ],
        returns: 'Array of silhouette curves.'
      },
      {
        signature: 'static Silhouette[] Compute(GeometryBase geometry,SilhouetteType silhouetteType,Point3d perspectiveCameraLocation,double tolerance,double angleToleranceRadians,IEnumerable<Plane> clippingPlanes,CancellationToken cancelToken)',
        summary: 'Compute silhouettes of a shape for a perspective projection.',
        since: 6,
        parameters: [
          {
            name: 'geometry',
            summary: 'Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion.'
          },
          {
            name: 'silhouetteType',
            summary: 'Types of silhouette to compute.'
          },
          {
            name: 'perspectiveCameraLocation',
            summary: 'Location of perspective camera.'
          },
          {
            name: 'tolerance',
            summary: `Tolerance to use for determining projecting relationships. 
     Surfaces and curves that are closer than tolerance, may be treated as projecting. 
     When in doubt use RhinoDoc.ModelAbsoluteTolerance.`
          },
          {
            name: 'angleToleranceRadians',
            summary: `Angular tolerance to use for determining projecting relationships.
     A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. 
     When in doubt use RhinoDoc.ModelAngleToleranceRadians.`
          },
          {
            name: 'clippingPlanes',
            summary: 'Optional collection of clipping planes.'
          },
          {
            name: 'cancelToken',
            summary: 'Computation cancellation token.'
          }
        ],
        returns: 'Array of silhouette curves.'
      },
      {
        signature: 'static Silhouette[] Compute(GeometryBase geometry,SilhouetteType silhouetteType,Vector3d parallelCameraDirection,double tolerance,double angleToleranceRadians)',
        summary: 'Compute silhouettes of a shape for a parallel projection.',
        since: 6,
        parameters: [
          {
            name: 'geometry',
            summary: 'Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion.'
          },
          {
            name: 'silhouetteType',
            summary: 'Types of silhouette to compute.'
          },
          {
            name: 'parallelCameraDirection',
            summary: 'Direction of parallel camera.'
          },
          {
            name: 'tolerance',
            summary: `Tolerance to use for determining projecting relationships. 
     Surfaces and curves that are closer than tolerance, may be treated as projecting. 
     When in doubt use RhinoDoc.ModelAbsoluteTolerance.`
          },
          {
            name: 'angleToleranceRadians',
            summary: `Angular tolerance to use for determining projecting relationships.
     A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. 
     When in doubt use RhinoDoc.ModelAngleToleranceRadians.`
          }
        ],
        returns: 'Array of silhouette curves.'
      },
      {
        signature: 'static Silhouette[] Compute(GeometryBase geometry,SilhouetteType silhouetteType,Vector3d parallelCameraDirection,double tolerance,double angleToleranceRadians,IEnumerable<Plane> clippingPlanes,CancellationToken cancelToken)',
        summary: 'Compute silhouettes of a shape for a parallel projection.',
        since: 6,
        parameters: [
          {
            name: 'geometry',
            summary: 'Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion.'
          },
          {
            name: 'silhouetteType',
            summary: 'Types of silhouette to compute.'
          },
          {
            name: 'parallelCameraDirection',
            summary: 'Direction of parallel camera.'
          },
          {
            name: 'tolerance',
            summary: `Tolerance to use for determining projecting relationships. 
     Surfaces and curves that are closer than tolerance, may be treated as projecting. 
     When in doubt use RhinoDoc.ModelAbsoluteTolerance.`
          },
          {
            name: 'angleToleranceRadians',
            summary: `Angular tolerance to use for determining projecting relationships.
     A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. 
     When in doubt use RhinoDoc.ModelAngleToleranceRadians.`
          },
          {
            name: 'clippingPlanes',
            summary: 'Optional collection of clipping planes.'
          },
          {
            name: 'cancelToken',
            summary: 'Computation cancellation token.'
          }
        ],
        returns: 'Array of silhouette curves.'
      },
      {
        signature: 'static Silhouette[] Compute(GeometryBase geometry,SilhouetteType silhouetteType,ViewportInfo viewport,double tolerance,double angleToleranceRadians)',
        summary: 'Compute silhouettes of a shape for a specified projection.',
        since: 6,
        parameters: [
          {
            name: 'geometry',
            summary: 'Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion.'
          },
          {
            name: 'silhouetteType',
            summary: 'Types of silhouette to compute.'
          },
          {
            name: 'viewport',
            summary: 'Projection.'
          },
          {
            name: 'tolerance',
            summary: `Tolerance to use for determining projecting relationships. 
     Surfaces and curves that are closer than tolerance, may be treated as projecting. 
     When in doubt use RhinoDoc.ModelAbsoluteTolerance.`
          },
          {
            name: 'angleToleranceRadians',
            summary: `Angular tolerance to use for determining projecting relationships.
     A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. 
     When in doubt use RhinoDoc.ModelAngleToleranceRadians.`
          }
        ],
        returns: 'Array of silhouette curves.'
      },
      {
        signature: 'static Silhouette[] Compute(GeometryBase geometry,SilhouetteType silhouetteType,ViewportInfo viewport,double tolerance,double angleToleranceRadians,IEnumerable<Plane> clippingPlanes,CancellationToken cancelToken)',
        summary: 'Compute silhouettes of a shape for a specified projection.',
        since: 6,
        parameters: [
          {
            name: 'geometry',
            summary: 'Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion.'
          },
          {
            name: 'silhouetteType',
            summary: 'Types of silhouette to compute.'
          },
          {
            name: 'viewport',
            summary: 'Projection.'
          },
          {
            name: 'tolerance',
            summary: `Tolerance to use for determining projecting relationships. 
     Surfaces and curves that are closer than tolerance, may be treated as projecting. 
     When in doubt use RhinoDoc.ModelAbsoluteTolerance.`
          },
          {
            name: 'angleToleranceRadians',
            summary: `Angular tolerance to use for determining projecting relationships.
     A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. 
     When in doubt use RhinoDoc.ModelAngleToleranceRadians.`
          },
          {
            name: 'clippingPlanes',
            summary: 'Optional collection of clipping planes.'
          },
          {
            name: 'cancelToken',
            summary: 'Computation cancellation token.'
          }
        ],
        returns: 'Array of silhouette curves.'
      },
      {
        signature: 'static Silhouette[] ComputeDraftCurve(GeometryBase geometry,double draftAngle,Vector3d pullDirection,double tolerance,double angleToleranceRadians)',
        summary: 'Computes draft curve silhouettes of a shape.',
        since: 7,
        parameters: [
          {
            name: 'geometry',
            summary: 'Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion.'
          },
          {
            name: 'draftAngle',
            summary: 'The draft angle in radians. Draft angle can be a positive or negative value.'
          },
          {
            name: 'pullDirection',
            summary: '3d direction for the mold to be pulled in, directed away from the object.'
          },
          {
            name: 'tolerance',
            summary: `Tolerance to use for determining projecting relationships. 
     Surfaces and curves that are closer than tolerance, may be treated as projecting. 
     When in doubt use RhinoDoc.ModelAbsoluteTolerance.`
          },
          {
            name: 'angleToleranceRadians',
            summary: `Angular tolerance to use for determining projecting relationships.
     A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. 
     When in doubt use RhinoDoc.ModelAngleToleranceRadians.`
          }
        ],
        returns: 'Array of silhouette curves.'
      },
      {
        signature: 'static Silhouette[] ComputeDraftCurve(GeometryBase geometry,double draftAngle,Vector3d pullDirection,double tolerance,double angleToleranceRadians,CancellationToken cancelToken)',
        summary: 'Computes draft curve silhouettes of a shape.',
        since: 7,
        parameters: [
          {
            name: 'geometry',
            summary: 'Geometry whose silhouettes need to be computed. Can be Brep, BrepFace, Mesh, or Extrusion.'
          },
          {
            name: 'draftAngle',
            summary: 'The draft angle in radians. Draft angle can be a positive or negative value.'
          },
          {
            name: 'pullDirection',
            summary: '3d direction for the mold to be pulled in, directed away from the object.'
          },
          {
            name: 'tolerance',
            summary: `Tolerance to use for determining projecting relationships. 
     Surfaces and curves that are closer than tolerance, may be treated as projecting. 
     When in doubt use RhinoDoc.ModelAbsoluteTolerance.`
          },
          {
            name: 'angleToleranceRadians',
            summary: `Angular tolerance to use for determining projecting relationships.
     A surface normal N that satisfies N o cameraDirection < Sin(angleToleranceRadians) may be considered projecting. 
     When in doubt use RhinoDoc.ModelAngleToleranceRadians.`
          },
          {
            name: 'cancelToken',
            summary: 'Computation cancellation token.'
          }
        ],
        returns: 'Array of silhouette curves.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SilhouetteType',
    dataType: 3,
    summary: 'Enumerates the different types of silhouettes and their origins.',
    values: [
      {
        signature: 'None = UnsafeNativeMethods.SilEventType.None',
        summary: 'None.'
      },
      {
        signature: 'Projecting = UnsafeNativeMethods.SilEventType.Projecting',
        summary: `Boundary of a region that projects to a curve.  
     The view direction is tangent to the surface over the entire region.`
      },
      {
        signature: 'TangentProjects = UnsafeNativeMethods.SilEventType.TanProjects',
        summary: `Tangent silhouette curve where the curve projects to a point (within tolerance).
     In this case side_fill[i] is meaningless so it's left unset.`
      },
      {
        signature: 'Tangent = UnsafeNativeMethods.SilEventType.Tangent',
        summary: 'Tangent silhouette curve. The view direction is tangent to the surface along the curve.'
      },
      {
        signature: 'Crease = UnsafeNativeMethods.SilEventType.Crease',
        summary: 'Crease on geometry that is a silhouette.'
      },
      {
        signature: 'Boundary = UnsafeNativeMethods.SilEventType.Boundary',
        summary: 'Boundary of geometry is always a silhouette.'
      },
      {
        signature: 'NonSilhouetteCrease = UnsafeNativeMethods.SilEventType.NonSilCrease',
        summary: 'A non-silhouette crease, meaning both sides are visible.'
      },
      {
        signature: 'NonSilhouetteTangent = UnsafeNativeMethods.SilEventType.NonSilTangent',
        summary: 'A non-silhouette tangent edge that is not a crease.'
      },
      {
        signature: 'NonSilhouetteSeam = UnsafeNativeMethods.SilEventType.NonSilSeam',
        summary: 'A non-silhouette surface seam.'
      },
      {
        signature: 'SectionCut = UnsafeNativeMethods.SilEventType.SectionCut',
        summary: 'Intersection with a clipping plane.'
      },
      {
        signature: 'MiscellaneousFeature = UnsafeNativeMethods.SilEventType.MiscFeature',
        summary: 'Miscellaneous curve feature.'
      },
      {
        signature: 'DraftCurve = UnsafeNativeMethods.SilEventType.DraftCurve',
        summary: 'Draft curve is a curve of constant draft angle.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SmoothingCoordinateSystem',
    dataType: 3,
    summary: 'The direction of the smoothing used by Curve, Surface, and Mesh Smooth.',
    values: [
      {
        signature: 'World = 0',
        summary: 'World coordinates'
      },
      {
        signature: 'CPlane = 1',
        summary: 'Construction plane coordinates'
      },
      {
        signature: 'Object = 2',
        summary: 'Object u, v, and n coordinates'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SpaceMorph',
    dataType: 1,
    summary: 'Represents a spacial, Euclidean morph.',
    properties: [
      {
        signature: 'bool PreserveStructure',
        summary: `True if the morph should be done in a way that preserves the structure of the geometry.
     In particular, for NURBS objects, True means that only the control points are moved.
     The PreserveStructure value does not affect the way meshes and points are morphed.
     The default is false.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool QuickPreview',
        summary: `True if the morph should be done as quickly as possible because the result
     is being used for some type of dynamic preview. If QuickPreview is true,
     the tolerance may be ignored.
     The QuickPreview value does not affect the way meshes and points are morphed.
     The default is false.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Tolerance',
        summary: `The desired accuracy of the morph. This value is primarily used for deforming
     surfaces and breps. The default is 0.0 and any value <= 0.0 is ignored by
     morphing functions. The Tolerance value does not affect the way meshes and points
     are morphed.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static bool IsMorphable(GeometryBase geometry)',
        summary: 'True if the geometry can be morphed by calling SpaceMorph.Morph(geometry)',
        since: 5
      },
      {
        signature: 'bool Morph(GeometryBase geometry)',
        summary: 'Apply the space morph to geometry.',
        since: 5,
        parameters: [
          {
            name: 'geometry',
            summary: 'Geometry to morph.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Morph(Plane plane)',
        summary: 'Apply the space morph to a plane.',
        since: 6,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane to morph.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'Point3d MorphPoint(Point3d point)',
        summary: 'Morphs an Euclidean point. This method is abstract.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point that will be morphed by this function.'
          }
        ],
        returns: 'Resulting morphed point.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Sphere',
    dataType: 2,
    summary: 'Represents the plane and radius values of a sphere.',
    constructors: [
      {
        signature: 'Sphere(Plane equatorialPlane,double radius)',
        summary: 'Initializes a new sphere given the plane of the equator circle and radius.',
        since: 5,
        parameters: [
          {
            name: 'equatorialPlane',
            summary: `A plane that will be intesecting
     the sphere at the same distance from both poles (parameterization
     singularieties).`
          },
          {
            name: 'radius',
            summary: 'A radius value.'
          }
        ]
      },
      {
        signature: 'Sphere(Point3d center,double radius)',
        summary: 'Initializes a new sphere given center point and radius.',
        since: 5,
        parameters: [
          {
            name: 'center',
            summary: 'A center point.'
          },
          {
            name: 'radius',
            summary: 'A radius value.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Sphere Unset',
        summary: 'Gets a sphere with invalid members.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'BoundingBox BoundingBox',
        summary: `Gets the world aligned boundingbox for this Sphere. 
     If the Sphere is Invalid, an empty box is returned.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d Center',
        summary: 'Gets or sets the center point of the sphere.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Diameter',
        summary: 'Gets or sets the diameter for this sphere.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Plane EquatorialPlane',
        summary: 'Gets or sets the Equatorial plane for this sphere.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Plane EquitorialPlane',
        summary: 'Gets or sets the Equatorial plane for this sphere.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsValid',
        summary: 'Gets a value that indicates whether the sphere is valid.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d NorthPole',
        summary: `Gets the point at the North Pole of the sphere.
     This is the parameterization singularity that can be obtained,
     at V value +Math.Pi/2.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Radius',
        summary: 'Gets or sets the Radius for this sphere.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d SouthPole',
        summary: `Gets the point at the South Pole of the sphere.
     This is the parameterization singularity that can be obtained,
     at V value -Math.Pi/2.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Sphere FitSphereToPoints(IEnumerable<Point3d> points)',
        summary: 'Attempts to fit a sphere to a collection of points.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'Points to fit. The collection must contain at least two points.'
          }
        ],
        returns: 'The Sphere that best approximates the points or Sphere.Unset on failure.'
      },
      {
        signature: 'bool ClosestParameter(Point3d testPoint,double longitudeRadians,double latitudeRadians)',
        summary: 'Finds the angle parameters on this sphere that are closest to a test point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to project onto the sphere.'
          },
          {
            name: 'longitudeRadians',
            summary: 'The longitudinal angle (in radians; 0.0 to 2pi) where the sphere approaches testPoint best.'
          },
          {
            name: 'latitudeRadians',
            summary: 'The latitudinal angle (in radians; -0.5pi to +0.5pi) where the sphere approaches testPoint best.'
          }
        ],
        returns: 'True on success, False on failure. This function will fail if the point it coincident with the sphere center.'
      },
      {
        signature: 'Point3d ClosestPoint(Point3d testPoint)',
        summary: 'Returns point on sphere that is closest to given point.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'Point to project onto Sphere.'
          }
        ],
        returns: 'Point on sphere surface closest to testPoint.'
      },
      {
        signature: 'bool EpsilonEquals(Sphere other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'Circle LatitudeDegrees(double degrees)',
        summary: `Computes the parallel at a specific latitude angle.
     The angle is specified in degrees.`,
        since: 5,
        parameters: [
          {
            name: 'degrees',
            summary: 'An angle in degrees for the meridian.'
          }
        ],
        returns: 'A circle.'
      },
      {
        signature: 'Circle LatitudeRadians(double radians)',
        summary: `Computes the parallel at a specific latitude angle.
     The angle is specified in radians.`,
        since: 5,
        parameters: [
          {
            name: 'radians',
            summary: 'An angle in radians for the parallel.'
          }
        ],
        returns: 'A circle.'
      },
      {
        signature: 'Circle LongitudeDegrees(double degrees)',
        summary: `Computes the meridian at a specific longitude angle.
     The angle is specified in degrees.`,
        since: 5,
        parameters: [
          {
            name: 'degrees',
            summary: 'An angle in degrees.'
          }
        ],
        returns: 'A circle.'
      },
      {
        signature: 'Circle LongitudeRadians(double radians)',
        summary: `Computes the meridian at a specific longitude angle.
     The angle is specified in radians.`,
        since: 5,
        parameters: [
          {
            name: 'radians',
            summary: 'An angle in radians.'
          }
        ],
        returns: 'A circle.'
      },
      {
        signature: 'Vector3d NormalAt(double longitudeRadians,double latitudeRadians)',
        summary: 'Computes the normal at a specific angular location on the sphere.',
        since: 5,
        parameters: [
          {
            name: 'longitudeRadians',
            summary: 'A number within the interval [0, 2pi].'
          },
          {
            name: 'latitudeRadians',
            summary: 'A number within the interval [-pi/2, pi/2].'
          }
        ],
        returns: 'A vector.'
      },
      {
        signature: 'Point3d PointAt(double longitudeRadians,double latitudeRadians)',
        summary: 'Evaluates the sphere at specific longitude and latitude angles.',
        since: 5,
        parameters: [
          {
            name: 'longitudeRadians',
            summary: 'A number within the interval [0, 2pi].'
          },
          {
            name: 'latitudeRadians',
            summary: 'A number within the interval [-pi/2,pi/2].'
          }
        ],
        returns: 'A point value.'
      },
      {
        signature: 'bool Rotate(double sinAngle,double cosAngle,Vector3d axisOfRotation)',
        summary: 'Rotates this sphere about the center point.',
        since: 5,
        parameters: [
          {
            name: 'sinAngle',
            summary: 'sin(angle)'
          },
          {
            name: 'cosAngle',
            summary: 'cos(angle)'
          },
          {
            name: 'axisOfRotation',
            summary: 'The direction of the axis of rotation.'
          }
        ],
        returns: 'True on success; False on failure.'
      },
      {
        signature: 'bool Rotate(double sinAngle,double cosAngle,Vector3d axisOfRotation,Point3d centerOfRotation)',
        summary: 'Rotates this sphere about a point and an axis.',
        since: 5,
        parameters: [
          {
            name: 'sinAngle',
            summary: 'sin(angle)'
          },
          {
            name: 'cosAngle',
            summary: 'cod(angle)'
          },
          {
            name: 'axisOfRotation',
            summary: 'Axis of rotation.'
          },
          {
            name: 'centerOfRotation',
            summary: 'Center of rotation.'
          }
        ],
        returns: 'True on success; False on failure.'
      },
      {
        signature: 'bool Rotate(double angleRadians,Vector3d axisOfRotation)',
        summary: 'Rotates the sphere about the center point.',
        since: 5,
        parameters: [
          {
            name: 'angleRadians',
            summary: 'Angle of rotation (in radians)'
          },
          {
            name: 'axisOfRotation',
            summary: 'Rotation axis.'
          }
        ],
        returns: 'True on success; False on failure.'
      },
      {
        signature: 'bool Rotate(double angleRadians,Vector3d axisOfRotation,Point3d centerOfRotation)',
        summary: 'Rotates this sphere about a point and an axis.',
        since: 5,
        parameters: [
          {
            name: 'angleRadians',
            summary: 'Rotation angle (in Radians)'
          },
          {
            name: 'axisOfRotation',
            summary: 'Axis of rotation.'
          },
          {
            name: 'centerOfRotation',
            summary: 'Center of rotation.'
          }
        ],
        returns: 'True on success; False on failure.'
      },
      {
        signature: 'Brep ToBrep()',
        summary: 'Converts this sphere is it Brep representation',
        since: 5
      },
      {
        signature: 'NurbsSurface ToNurbsSurface()',
        summary: `Converts this sphere to its NurbsSurface representation. 
     This is synonymous with calling NurbsSurface.CreateFromSphere().`,
        since: 5,
        returns: 'A nurbs surface representation of this sphere or null.'
      },
      {
        signature: 'RevSurface ToRevSurface()',
        summary: `Converts this Sphere to a RevSurface representation. 
     This is synonymous with calling RevSurface.CreateFromSphere().`,
        since: 5,
        returns: 'A surface of revolution representation of this sphere or null.'
      },
      {
        signature: 'bool Transform(Transform xform)',
        summary: `Transforms this sphere. Note that non-similarity preserving transformations 
     cannot be applied to a sphere as that would result in an ellipsoid.`,
        since: 5,
        parameters: [
          {
            name: 'xform',
            summary: 'Transformation matrix to apply.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'bool Translate(Vector3d delta)',
        summary: 'Moves this sphere along a motion vector.',
        since: 5,
        parameters: [
          {
            name: 'delta',
            summary: 'Motion vector.'
          }
        ],
        returns: 'True on success; False on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SubD.NurbsSurfaceType',
    dataType: 3,
    summary: 'ON_SubD::NurbsSurfaceType specifies what type of NURBS surfaces are returned by ON_SubD.GetSurfaceNurbsFragments()',
    values: [
      {
        signature: 'Unset = 0',
        summary: `Not a valid type. Used to indicate the type has not been set and to encourage developers to explicitly specify a type.
     When in doubt, specify NurbsSurfaceType::Large.`
      },
      {
        signature: 'Large = 1',
        summary: `A single NURBS surface will be created for each SubD quad. Near extraordinary vertices, the surfaces may
     have lots of knots.`
      },
      {
        signature: 'Medium = 2',
        summary: `NURBS surfaces will be as large as possible without the addition of extra knots. 
     Near extraordinary vertices, the surfaces may
     have lots of knots.
     This option is prefered when a user wants larger NURBS surfaces but not at the cost of addtional NURBS control points.`
      },
      {
        signature: 'Small = 3',
        summary: 'NURBS surfaces will not be merged and will have clamped knots.'
      },
      {
        signature: 'Unprocessed = 4',
        summary: `NURBS surfaces will not be merged and will have unclamped uniform knots.
     This is useful as a starting point for customized merging and modifying
     continuity at extraordinary vertices.`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SubDAutomaticMeshToSubDContext',
    dataType: 3,
    summary: `ON_SubD::AutomaticMeshToSubDContext indentifies a context where meshes can automatically
   be converted to subds.`,
    values: [
      {
        signature: 'Unset = 0',
        summary: 'Indicates the context has not been initialized.'
      },
      {
        signature: 'Rhino5BoxModeTSpline = 1',
        summary: `A mesh in a Rhino 5 3dm file that is a representation of a box mode T-spline.
     By default, these meshes are automatically converted to subds.`
      },
      {
        signature: 'FBXMeshWithDivisionLevels = 2',
        summary: `A mesh in an FBX file that has nonzero values for either preview division levels or render division levels.
     Some FBX files created by Maya save subdivision objects as meshes with nonzero division level values.
     By default, FBX division levels are ignored.`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SubDChainType',
    dataType: 3,
    summary: 'SubD::ChainType specifies what edge and vertex tag tests are used when creating edge chains.',
    values: [
      {
        signature: 'Unset = 0',
        summary: 'Unset.'
      },
      {
        signature: 'MixedTag = 1',
        summary: 'All types of edges and vertices can be in the chain.'
      },
      {
        signature: 'EqualEdgeTag = 2',
        summary: 'Every edge in an edge chain has the same smooth/crease property.'
      },
      {
        signature: 'EqualEdgeAndVertexTag = 3',
        summary: `Every edge in an edge chain has the same smooth/crease edge tag 
     and interior vertices have the corresponding smooth/crease vertex tag.`
      },
      {
        signature: 'EqualEdgeTagAndOrdinary = 4',
        summary: `Every edge in an edge chain has the same smooth/crease property
     and every edge has the same number of faces.
     If the edges have 1 face, then interior vertices have valence = 3.
     If the edges have 2 faces, then interior vertices have valence = 4.`
      },
      {
        signature: 'EqualEdgeAndVertexTagAndOrdinary = 5',
        summary: `Every edge in an edge chain has the same smooth/crease edge tag,
     every edge has the same number of faces,
     and interior vertices have the corresponding smooth/crease vertex tag.
     If the edges have 1 face, then interior vertices have valence = 3.
     If the edges have 2 faces, then interior vertices have valence = 4.`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SubDComponent',
    dataType: 1,
    summary: 'A part of SubD geometry. Common base class for vertices, faces, and edges',
    properties: [
      {
        signature: 'uint Id',
        summary: 'Unique id within the parent SubD for this item',
        since: 7,
        property: ['get']
      },
      {
        signature: 'SubD ParentSubD',
        summary: 'SubD that this component belonds to',
        since: 7,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SubDCreationOptions.ConvexCornerOption',
    dataType: 3,
    summary: 'Defines how convex corners are treated.',
    values: [
      {
        signature: 'Unset = 0',
        summary: 'The option is not set.'
      },
      {
        signature: 'None = 1',
        summary: 'No convex coners.'
      },
      {
        signature: 'AtMeshCorner = 2',
        summary: `A convext subd corner will appear at input mesh/ boundary vertices 
     where the corner angle <= MaximumConvexCornerAngleRadians() and
     the number of edges the end at the vertex is <= MaximumConvexCornerEdgeCount().`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SubDCreationOptions.InteriorCreaseOption',
    dataType: 3,
    summary: 'Defines how interior creases are treated.',
    values: [
      {
        signature: 'Unset = 0',
        summary: 'The interior creases option is not defined.'
      },
      {
        signature: 'None = 1',
        summary: 'No interior creases.'
      },
      {
        signature: 'AtMeshCrease = 2',
        summary: `An interior subd crease will appear along coincident
    mesh edges where the angle between coindident vertex
    normals >= MinimumCreaseAngleRadians().`
      },
      {
        signature: 'AtMeshEdge = 3',
        summary: `An interior subd crease will appear all coincident mesh edges.
    Input mesh vertex normals are ignored.`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SubDEdge',
    dataType: 1,
    summary: 'Single edge of a SubD',
    baseclass: 'Rhino.Geometry.SubDComponent',
    properties: [
      {
        signature: 'Line ControlNetLine',
        summary: 'Line representing the control net end points',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int FaceCount',
        summary: 'Number of faces for this edge',
        since: 7,
        property: ['get']
      },
      {
        signature: 'SubDEdgeTag Tag',
        summary: 'identifies the type of subdivision edge',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'SubDVertex VertexFrom',
        summary: 'Start vertex for this edge',
        since: 7,
        property: ['get']
      },
      {
        signature: 'SubDVertex VertexTo',
        summary: 'End vertex for this edge',
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'SubDFace FaceAt(int index)',
        summary: 'Retrieve a SubDFace from this edge',
        since: 7
      },
      {
        signature: 'NurbsCurve ToNurbsCurve(bool clampEnds)',
        summary: `Get a cubic, uniform, nonrational, NURBS curve that is on the
     edge's limit curve.`,
        since: 7,
        parameters: [
          {
            name: 'clampEnds',
            summary: `If true, the end knots are clamped.
     Otherwise the end knots are(-2,-1,0,...., k1, k1+1, k1+2).`
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SubDEdgeTag',
    dataType: 3,
    summary: `SubD::EdgeTag identifies the type of subdivision edge.  Different tags use
   different subdivision algorithms to calculate the subdivision point.`,
    values: [
      {
        signature: 'Unset = 0',
        summary: `Not a valid edge tag and the default value for ON_SubDEdge.m_edge_tag.
     This encourages developers to thoughtfully initialize ON_SubDEdge.m_edge_tag.
     or use ON_SubD.UpdateAllTagsAndSectorCoefficients() to automatically set the
     m_edge_tag values at an appropriate time.`
      },
      {
        signature: 'Smooth = 1',
        summary: `At least one the edge's vertices must be tagged as ON_SubD::VertexTag::Smooth.
     The edge must have exactly two faces.
     The edge's subdivision point is (A1 + A2 + S(f1) + S(f2))/4, where 
     Ai = ON_SubDEdge.Vertex(i)->ControlNetPoint() and
     S(fi) = ON_SubDEdge.Face(i)->SubdivisionPoint().`
      },
      {
        signature: 'Crease = 2',
        summary: `Both of the edge's vertices must be tagged as ON_SubD::VertexTag::Dart,
     ON_SubD::VertexTag::Crease, or ON_SubD::VertexTag::Corner. 
     (The vertex tags can be different.) The edge can have any number of faces.
     The edge's subdivision point is (A1+A2)/2 where Ai = ON_SubDEdge.Vertex(i)->ControlNetPoint().`
      },
      {
        signature: 'SmoothX = 4',
        summary: `This tag appears only on level 0 edges that have exactly two neighboring faces
     and both of the edge's vertices are tagged as ON_SubD::VertexTag::Dart,
     ON_SubD::VertexTag::Crease, or ON_SubD::VertexTag::Corner.
     The level 1 subdivision point for a level 0 edge tagged as ON_SubD::EdgeTag::SmoothX 
     is the standard smooth edge subdivision point.
     When subdivided, the new subdivision vertex will be tagged
     as ON_SubD::VertexTag::Smooth and the subdivided edges will
     be tagged as ON_SubD::EdgeTag::Smooth.  
     The tag ON_SubD::EdgeTag::SmoothX can only appear on a level 0 edge.
     This tag exists because the ON_SubD subdivision
     algorithm requires any edge with both end vertices
     tagged as not smooth must be subdivided at its midpoint.
     Sector iterators treat "SmoothX" edges as smooth.
     Both edge m_sector_coefficient[] values must be set so the smooth subdivided edges will be valid.`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SubDFace',
    dataType: 1,
    summary: 'Single face of a SubD',
    baseclass: 'Rhino.Geometry.SubDComponent',
    properties: [
      {
        signature: 'int EdgeCount',
        summary: `Number of edges for this face. Note that EdgeCount is always the same
     as VertexCount. Two properties are provided simply for clarity.`,
        since: 7,
        property: ['get']
      },
      {
        signature: 'Point3d LimitSurfaceCenterPoint',
        summary: 'Get the limit surface point location at the center of the face',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int VertexCount',
        summary: `Number of vertices for this face. Note that EdgeCount is always the same
     as VertexCount. Two properties are provided simply for clarity.`,
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'SubDEdge EdgeAt(int index)',
        summary: 'Get an edge at a given index',
        since: 7
      },
      {
        signature: 'bool EdgeDirectionMatchesFaceOrientation(int index)',
        summary: 'Check if a given edge in this face has the same direction as the face orientation',
        since: 7
      },
      {
        signature: 'SubDVertex VertexAt(int index)',
        summary: 'Get a vertex that this face uses by index',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SubDFriendlyKnotType',
    dataType: 3,
    summary: `ON_SubD::SubDFriendlyKnotType identifies the types of subd friendly NURBS knot vectors.
   SubD friendly NURBS curves and surfacaes are always cubic and nonrational.
   Any time there is a multiple knot, the 2nd derivative is zero at the corresponding parameter.
   SubD friendly NURBS curves are either periodic or have zero 2nd derivative at the ends.`,
    values: [
      {
        signature: 'Unset = 0',
        summary: 'Not a valid type. Used to indicate the type has not been set and to encourage developers to explicitly specify a type.'
      },
      {
        signature: 'UnclampedUniform = 1',
        summary: `NURBS knot vector is an unclamped uniform cubic knot vector. 
     Every knot interval has the same length.
     Every knot has multiplicity 1.`
      },
      {
        signature: 'ClampedUniform = 2',
        summary: `NURBS knot vector is a clamped uniform cubic knot vector. 
     Every interior knot interval has the same length.
     End knots have multiplicity 3 and interior knots have multiplicity 1.`
      },
      {
        signature: 'ClampedPiecewiseUniform = 4',
        summary: `NURBS knot vector is a clamped piecewise uniform cubic knot vector.
     All nonzero knot intervals have the same length.
     End knots have multiplicity 3 and interior knots have multiplicity 1 or 3.
     Interior knots with multiplicity 3 correspond to interior SubD creases.`
      },
      {
        signature: 'Unfriendly = 127',
        summary: 'NURBS knot vector is not subd friendly.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SubDPatchStyle',
    dataType: 3,
    summary: 'SubD::PatchStyle identifies the style of patch used to fill holes.',
    values: [
      {
        signature: 'Unset = 0',
        summary: `Not a valid style.
     This encourages developers to thoughtfully select a patch style and can 
     be used to indicate a UI control is not initialized.`
      },
      {
        signature: 'Automatic = 1',
        summary: `Automatically choose a patch style that will generally create a good looking result.
     If a hole boundary is not convex, it is triangulated. Otherwise:
     If a hole has 3 edges, a single triangle face is used.
     If a hole has 4 edges, a single quad face is used.
     If a hole has 5 or more edges and an odd number of edges, a triangle fan is used. 
     If a hole has 6 or more edges and an even number of edges, a quad fan is used.`
      },
      {
        signature: 'SingleFace = 2',
        summary: 'A single face is used under all conditions.'
      },
      {
        signature: 'TriangleFan = 3',
        summary: `A triangle fan used under all conditions. The center of the fan
     is the average of the hole boundary vertex control net points.`
      },
      {
        signature: 'QuadOrTriangleFan = 4',
        summary: `If the hole boundary has an even mumber of edges, a quad fan is used.
     Otherwise a triangle fan is used. The center of the fan
     is the average of the hole boundary vertex control net points.`
      },
      {
        signature: 'Triangulated = 5',
        summary: `The hole boundary is triangluated.
     Typically this style is selected when a boundary not convex 
     and the other styles produce faces with overlapping regions.`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SubDVertex',
    dataType: 1,
    summary: 'Single vertex of a SubD',
    baseclass: 'Rhino.Geometry.SubDComponent',
    properties: [
      {
        signature: 'Point3d ControlNetPoint',
        summary: 'Location of the "control net" point that this SubDVertex represents',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'int EdgeCount',
        summary: 'Number of edges for this vertex',
        since: 7,
        property: ['get']
      },
      {
        signature: 'IEnumerable<SubDEdge> Edges',
        summary: 'All edges that this vertex is part of',
        since: 7,
        property: ['get']
      },
      {
        signature: 'int FaceCount',
        summary: 'Number of faces for this vertex',
        since: 7,
        property: ['get']
      },
      {
        signature: 'SubDVertex Next',
        summary: 'Next vertex in linked list of vertices on this level',
        since: 7,
        property: ['get']
      },
      {
        signature: 'SubDVertex Previous',
        summary: 'Previous vertex in linked list of vertices on this level',
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'SubDEdge EdgeAt(int index)',
        summary: 'Retrieve a SubDEdge from this vertex',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SubDVertexFacetType',
    dataType: 3,
    summary: 'Summarizes the number of edges in faces in the whole object.',
    values: [
      {
        signature: 'Unset = 0',
        summary: 'Not a valid vertex face type.'
      },
      {
        signature: 'Tri = 3',
        summary: 'All faces are triangular.'
      },
      {
        signature: 'Quad = 4',
        summary: 'All faces are quads.'
      },
      {
        signature: 'Ngon = 5',
        summary: 'Edge count of faces is constant and > 4.'
      },
      {
        signature: 'Mixed = 0xFF',
        summary: 'Edge count of faces is not constant.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SubDVertexTag',
    dataType: 3,
    summary: `SubD::VertexTag identifies the type of subdivision vertex.  Different tags use
   different subdivision algorithms to determine where the subdivision point and
   limit point are located.  There are toplological constraints that restrict which
   tags can be assigned.`,
    values: [
      {
        signature: 'Unset = 0',
        summary: `Not a valid vertex tag and the default value for ON_SubDVertex.m_vertex_tag.
     This encourages developers to thoughtfully initialize ON_SubDVertex.m_vertex_tag
     or use ON_SubD.UpdateAllTagsAndSectorCoefficients() to automatically set the
     m_vertex_tag values at an appropriate time.`
      },
      {
        signature: 'Smooth = 1',
        summary: `Must be an interior vertex.
     All edges attached to a smooth vertex must be tagged as ON_SubD::EdgeTag::Smooth
     and must have 2 faces.`
      },
      {
        signature: 'Crease = 2',
        summary: `Can be an interior or a boundary vertex.
     Exactly two edges ending at a crease vertex must be tagged as ON_SubD::EdgeTag::Crease and may
     have 1 or 2 faces. 
     All other edges ending at a crease must be tagged as tagON_SubD::EdgeTag::Smooth and have 2 faces.
     Below P = ON_SubDVertex.ControlNetPoint() and Ai = ON_SubDVertex.Edge(i)->OtherEndVertex()->ControlNetPoint().
     A crease vertex subdivision point is (6*P + A1 + A2)/8.
     A crease vertex limit surface point is (4*P + A1 + A2)/6.`
      },
      {
        signature: 'Corner = 3',
        summary: `Can be an interior, boundary, nonmanifold, or isolated vertex.
     The location of a corner vertex is fixed. 
     The all subdivision points and the limit point are at the initial vertex location.
     The edges ending at a corner vertex can be smooth or crease edges.
     A corner vertex subdivision point is P where P = ON_SubDVertex.ControlNetPoint().
     A corner vertex limit surface point is P where P = ON_SubDVertex.ControlNetPoint().`
      },
      {
        signature: 'Dart = 4',
        summary: `Must be an interior vertex.  
     Every edge attached to a dart vertex must have 2 faces.
     Exactly one edge attached to a dart vertex must be tagged as ON_SubD::EdgeTag::Crease
     and every other attached edge must be tagged as tagON_SubD::EdgeTag::smooth.`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SumSurface',
    dataType: 1,
    summary: 'Represents a sum surface, or an extrusion of a curve along a curved path.',
    baseclass: 'Rhino.Geometry.Surface',
    methods: [
      {
        signature: 'static SumSurface Create(Curve curveA,Curve curveB)',
        summary: 'Constructs a new sum surface by extruding a curve A along a path B.',
        since: 5,
        parameters: [
          {
            name: 'curveA',
            summary: 'The curve used as extrusion profile.'
          },
          {
            name: 'curveB',
            summary: 'The curve used as path.'
          }
        ],
        returns: 'A new sum surface on success; None on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Surface',
    dataType: 1,
    summary: `Represents a base class that is common to most RhinoCommon surface types.
   A surface represents an entity that can be all visited by providing
   two independent parameters, usually called (u, v), or sometimes (s, t).`,
    baseclass: 'Rhino.Geometry.GeometryBase',
    properties: [
      {
        signature: 'bool IsSolid',
        summary: 'Gets a values indicating whether a surface is solid.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Surface CreateExtrusion(Curve profile,Vector3d direction)',
        summary: 'Constructs a surface by extruding a curve along a vector.',
        since: 5,
        parameters: [
          {
            name: 'profile',
            summary: 'Profile curve to extrude.'
          },
          {
            name: 'direction',
            summary: 'Direction and length of extrusion.'
          }
        ],
        returns: 'A surface on success or None on failure.'
      },
      {
        signature: 'static Surface CreateExtrusionToPoint(Curve profile,Point3d apexPoint)',
        summary: 'Constructs a surface by extruding a curve to a point.',
        since: 5,
        parameters: [
          {
            name: 'profile',
            summary: 'Profile curve to extrude.'
          },
          {
            name: 'apexPoint',
            summary: 'Apex point of extrusion.'
          }
        ],
        returns: 'A Surface on success or None on failure.'
      },
      {
        signature: 'static Surface CreatePeriodicSurface(Surface surface,int direction)',
        summary: 'Constructs a periodic surface from a base surface and a direction.',
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'The surface to make periodic.'
          },
          {
            name: 'direction',
            summary: 'The direction to make periodic, either 0 = U, or 1 = V.'
          }
        ],
        returns: 'A Surface on success or None on failure.'
      },
      {
        signature: 'static Surface CreatePeriodicSurface(Surface surface,int direction,bool bSmooth)',
        summary: 'Constructs a periodic surface from a base surface and a direction.',
        since: 6,
        parameters: [
          {
            name: 'surface',
            summary: 'The surface to make periodic.'
          },
          {
            name: 'direction',
            summary: 'The direction to make periodic, either 0 = U, or 1 = V.'
          },
          {
            name: 'bSmooth',
            summary: `Controls kink removal. If true, smooths any kinks in the surface and moves control points
     to make a smooth surface. If false, control point locations are not changed or changed minimally
     (only one point may move) and only the knot vector is altered.`
          }
        ],
        returns: 'A periodic surface if successful, None on failure.'
      },
      {
        signature: 'static Surface[] CreateRollingBallFillet(Surface surfaceA,bool flipA,Surface surfaceB,bool flipB,double radius,double tolerance)',
        summary: 'Constructs a rolling ball fillet between two surfaces.',
        since: 5,
        parameters: [
          {
            name: 'surfaceA',
            summary: 'A first surface.'
          },
          {
            name: 'flipA',
            summary: 'A value that indicates whether A should be used in flipped mode.'
          },
          {
            name: 'surfaceB',
            summary: 'A second surface.'
          },
          {
            name: 'flipB',
            summary: 'A value that indicates whether B should be used in flipped mode.'
          },
          {
            name: 'radius',
            summary: 'A radius value.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value.'
          }
        ],
        returns: 'A new array of rolling ball fillet surfaces; this array can be empty on failure.'
      },
      {
        signature: 'static Surface[] CreateRollingBallFillet(Surface surfaceA,Point2d uvA,Surface surfaceB,Point2d uvB,double radius,double tolerance)',
        summary: 'Constructs a rolling ball fillet between two surfaces.',
        since: 5,
        parameters: [
          {
            name: 'surfaceA',
            summary: 'A first surface.'
          },
          {
            name: 'uvA',
            summary: 'A point in the parameter space of FaceA near where the fillet is expected to hit the surface.'
          },
          {
            name: 'surfaceB',
            summary: 'A second surface.'
          },
          {
            name: 'uvB',
            summary: 'A point in the parameter space of FaceB near where the fillet is expected to hit the surface.'
          },
          {
            name: 'radius',
            summary: 'A radius value.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value used for approximating and intersecting offset surfaces.'
          }
        ],
        returns: 'A new array of rolling ball fillet surfaces; this array can be empty on failure.'
      },
      {
        signature: 'static Surface[] CreateRollingBallFillet(Surface surfaceA,Surface surfaceB,double radius,double tolerance)',
        summary: 'Constructs a rolling ball fillet between two surfaces.',
        since: 5,
        parameters: [
          {
            name: 'surfaceA',
            summary: 'A first surface.'
          },
          {
            name: 'surfaceB',
            summary: 'A second surface.'
          },
          {
            name: 'radius',
            summary: 'A radius value.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value.'
          }
        ],
        returns: 'A new array of rolling ball fillet surfaces; this array can be empty on failure.'
      },
      {
        signature: 'static Surface CreateSoftEditSurface(Surface surface,Point2d uv,Vector3d delta,double uLength,double vLength,double tolerance,bool fixEnds)',
        summary: 'Creates a soft edited surface from an exising surface using a smooth field of influence.',
        since: 6,
        parameters: [
          {
            name: 'surface',
            summary: 'The surface to soft edit.'
          },
          {
            name: 'uv',
            summary: `A point in the parameter space to move from. This location on the surface is moved, 
     and the move is smoothly tapered off with increasing distance along the surface from
     this parameter.`
          },
          {
            name: 'delta',
            summary: 'The direction and magitude, or maximum distance, of the move.'
          },
          {
            name: 'uLength',
            summary: `The distance along the surface's u-direction from the editing point over which the
     strength of the editing falls off smoothly.`
          },
          {
            name: 'vLength',
            summary: `The distance along the surface's v-direction from the editing point over which the
     strength of the editing falls off smoothly.`
          },
          {
            name: 'tolerance',
            summary: 'The active document\'s model absolute tolerance.'
          },
          {
            name: 'fixEnds',
            summary: 'Keeps edge locations fixed.'
          }
        ],
        returns: 'The soft edited surface if successful. None on failure.'
      },
      {
        signature: 'bool ClosestPoint(Point3d testPoint,double u,double v)',
        summary: 'Input the parameters of the point on the surface that is closest to testPoint.',
        since: 5,
        parameters: [
          {
            name: 'testPoint',
            summary: 'A point to test against.'
          },
          {
            name: 'u',
            summary: 'U parameter of the surface that is closest to testPoint.'
          },
          {
            name: 'v',
            summary: 'V parameter of the surface that is closest to testPoint.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'IsoStatus ClosestSide(double u,double v)',
        summary: 'Gets the side that is closest, in terms of 3D-distance, to a U and V parameter.',
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'A u parameter.'
          },
          {
            name: 'v',
            summary: 'A v parameter.'
          }
        ],
        returns: 'A side.'
      },
      {
        signature: 'SurfaceCurvature CurvatureAt(double u,double v)',
        summary: 'Computes the curvature at the given UV coordinate.',
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'U parameter for evaluation.'
          },
          {
            name: 'v',
            summary: 'V parameter for evaluation.'
          }
        ],
        returns: 'Surface Curvature data for the point at uv or None on failure.'
      },
      {
        signature: 'int Degree(int direction)',
        summary: `Returns the maximum algebraic degree of any span
     (or a good estimate if curve spans are not algebraic).`,
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: '0 gets first parameter\'s domain, 1 gets second parameter\'s domain.'
          }
        ],
        returns: 'The maximum degree.'
      },
      {
        signature: 'Interval Domain(int direction)',
        summary: 'Gets the domain in a direction.',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: '0 gets first parameter, 1 gets second parameter.'
          }
        ],
        returns: 'An interval value.'
      },
      {
        signature: 'bool Evaluate(double u,double v,int numberDerivatives,Point3d point,Vector3d[] derivatives)',
        summary: 'Evaluates a surface mathematically.',
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'A U parameter.'
          },
          {
            name: 'v',
            summary: 'A V parameter.'
          },
          {
            name: 'numberDerivatives',
            summary: 'The number of derivatives.'
          },
          {
            name: 'point',
            summary: 'A point. This out parameter will be assigned during this call.'
          },
          {
            name: 'derivatives',
            summary: 'A vector array. This out parameter will be assigned during this call. This can be null.'
          }
        ],
        returns: 'True if the operation succeeded; False otherwise.'
      },
      {
        signature: 'Surface Extend(IsoStatus edge,double extensionLength,bool smooth)',
        summary: 'Extends an untrimmed surface along one edge.',
        since: 5,
        parameters: [
          {
            name: 'edge',
            summary: 'Edge to extend.  Must be North, South, East, or West.'
          },
          {
            name: 'extensionLength',
            summary: 'distance to extend.'
          },
          {
            name: 'smooth',
            summary: `True for smooth (C-infinity) extension. 
     False for a C1- ruled extension.`
          }
        ],
        returns: 'New extended surface on success.'
      },
      {
        signature: 'Surface Fit(int uDegree,int vDegree,double fitTolerance)',
        summary: 'Fits a new surface through an existing surface.',
        since: 5,
        parameters: [
          {
            name: 'uDegree',
            summary: 'the output surface U degree. Must be bigger than 1.'
          },
          {
            name: 'vDegree',
            summary: 'the output surface V degree. Must be bigger than 1.'
          },
          {
            name: 'fitTolerance',
            summary: 'The fitting tolerance.'
          }
        ],
        returns: 'A surface, or None on error.'
      },
      {
        signature: 'bool FrameAt(double u,double v,Plane frame)',
        summary: `Computes the orient plane on a surface given a U and V parameter.
     This is the simple evaluation call with no error handling.`,
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'A first parameter.'
          },
          {
            name: 'v',
            summary: 'A second parameter.'
          },
          {
            name: 'frame',
            summary: 'A frame plane that will be computed during this call.'
          }
        ],
        returns: 'True if this operation succeeded; otherwise false.'
      },
      {
        signature: 'bool GetNextDiscontinuity(int direction,Continuity continuityType,double t0,double t1,double t)',
        summary: 'Searches for a derivative, tangent, or curvature discontinuity.',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: 'If 0, then "u" parameter is checked. If 1, then the "v" parameter is checked.'
          },
          {
            name: 'continuityType',
            summary: 'The desired continuity.'
          },
          {
            name: 't0',
            summary: `Search begins at t0. If there is a discontinuity at t0, it will be ignored. 
     This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.`
          },
          {
            name: 't1',
            summary: `(t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is a locus discontinuity
     type and t1 is at the start or end of the curve.`
          },
          {
            name: 't',
            summary: 'if a discontinuity is found, then t reports the parameter at the discontinuity.'
          }
        ],
        returns: `Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
     TRUE if a parametric discontinuity was found strictly between t0 and t1.
     Note well that all curves are parametrically continuous at the ends of their domains.
     
     Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
     TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1 is the
     at the end of a curve. Note well that all open curves (IsClosed()=false) are locus
     discontinuous at the ends of their domains.  All closed curves (IsClosed()=true) are
     at least C0_locus_continuous at the ends of their domains.`
      },
      {
        signature: 'bool GetNurbsFormParameterFromSurfaceParameter(double surfaceS,double surfaceT,double nurbsS,double nurbsT)',
        summary: 'Translates a parameter from the current surface to the parameter space of the surface returned by ToNurbsSurface().',
        since: 6,
        parameters: [
          {
            name: 'surfaceS',
            summary: 'The parameter in the S, or sometimes U, direction, of this surface.'
          },
          {
            name: 'surfaceT',
            summary: 'The parameter in the T, or sometimes V, direction of this surface.'
          },
          {
            name: 'nurbsS',
            summary: 'S on the NURBS form.'
          },
          {
            name: 'nurbsT',
            summary: 'T on the NURBS form.'
          }
        ],
        returns: 'True if the operation succeded; otherwise, false.'
      },
      {
        signature: 'double[] GetSpanVector(int direction)',
        summary: 'Gets array of span "knots".',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: '0 gets first parameter\'s domain, 1 gets second parameter\'s domain.'
          }
        ],
        returns: 'An array with span vectors; or None on error.'
      },
      {
        signature: 'bool GetSurfaceParameterFromNurbsFormParameter(double nurbsS,double nurbsT,double surfaceS,double surfaceT)',
        summary: 'Translates a parameter from a value on the surface returned by ToNurbsSurface() to the current surface.',
        since: 6,
        parameters: [
          {
            name: 'nurbsS',
            summary: 'The parameter in the S, or sometimes U, direction of the NURBS form surface.'
          },
          {
            name: 'nurbsT',
            summary: 'The parameter in the T, or sometimes V, direction of the NURBS form surface.'
          },
          {
            name: 'surfaceS',
            summary: 'S on this surface.'
          },
          {
            name: 'surfaceT',
            summary: 'T o n this surface.'
          }
        ],
        returns: 'True if the operation succeded; otherwise, false.'
      },
      {
        signature: 'bool GetSurfaceSize(double width,double height)',
        summary: `Gets an estimate of the size of the rectangle that would be created
     if the 3d surface where flattened into a rectangle.`,
        since: 5,
        parameters: [
          {
            name: 'width',
            summary: 'corresponds to the first surface parameter.'
          },
          {
            name: 'height',
            summary: 'corresponds to the second surface parameter.'
          }
        ],
        returns: 'True if successful.'
      },
      {
        signature: 'int HasNurbsForm()',
        summary: 'Is there a NURBS surface representation of this surface.',
        since: 5,
        returns: `0 unable to create NURBS representation with desired accuracy.
     1 success - NURBS parameterization matches the surface's
     2 success - NURBS point locus matches the surface's and the
     domain of the NURBS surface is correct. However, This surface's
     parameterization and the NURBS surface parameterization may not
     match.  This situation happens when getting NURBS representations
     of surfaces that have a transendental parameterization like spheres,
     cylinders, and cones.`
      },
      {
        signature: 'NurbsCurve InterpolatedCurveOnSurface(IEnumerable<Point3d> points,double tolerance)',
        summary: 'Constructs an interpolated curve on a surface, using 3D points.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of points.'
          },
          {
            name: 'tolerance',
            summary: 'A tolerance value.'
          }
        ],
        returns: 'A new nurbs curve, or None on error.'
      },
      {
        signature: 'NurbsCurve InterpolatedCurveOnSurfaceUV(IEnumerable<Point2d> points,double tolerance)',
        summary: 'Returns a curve that interpolates points on a surface. The interpolant lies on the surface.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'List of at least two UV parameter locations on the surface.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance used for the fit of the pushup curve. Generally, the resulting interpolating curve will be within tolerabce of the surface.'
          }
        ],
        returns: 'A new NURBS curve if successful, or None on error.'
      },
      {
        signature: 'NurbsCurve InterpolatedCurveOnSurfaceUV(IEnumerable<Point2d> points,double tolerance,bool closed,int closedSurfaceHandling)',
        summary: 'Returns a curve that interpolates points on a surface. The interpolant lies on the surface.',
        since: 6.18,
        parameters: [
          {
            name: 'points',
            summary: 'List of at least two UV parameter locations on the surface.'
          },
          {
            name: 'tolerance',
            summary: 'Tolerance used for the fit of the pushup curve. Generally, the resulting interpolating curve will be within tolerabce of the surface.'
          },
          {
            name: 'closed',
            summary: 'If false, the interpolating curve is not closed. If true, the interpolating curve is closed, and the last point and first point should generally not be equal.'
          },
          {
            name: 'closedSurfaceHandling',
            summary: `If 0, all points must be in the rectangular domain of the surface. If the surface is closed in some direction, 
     then this routine will interpret each point and place it at an appropriate location in the the covering space. 
     This is the simplest option and should give good results. 
     If 1, then more options for more control of handling curves going across seams are available.
     If the surface is closed in some direction, then the points are taken as points in the covering space. 
     Example, if srf.IsClosed(0)=True and srf.IsClosed(1)=False and srf.Domain(0)=srf.Domain(1)=Interval(0,1) 
     then if closedSurfaceHandling=1 a point(u, v) in points can have any value for the u coordinate, but must have 0<=v<=1.  
     In particular, if points = { (0.0,0.5), (2.0,0.5) } then the interpolating curve will wrap around the surface two times in the closed direction before ending at start of the curve.
     If closed=True the last point should equal the first point plus an integer multiple of the period on a closed direction.`
          }
        ],
        returns: 'A new NURBS curve if successful, or None on error.'
      },
      {
        signature: 'int IsAtSeam(double u,double v)',
        summary: 'Tests if a surface parameter value is at a seam.',
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'Surface u parameter to test.'
          },
          {
            name: 'v',
            summary: 'Surface v parameter to test.'
          }
        ],
        returns: `0 if not a seam,
     1 if u == Domain(0)[i] and srf(u, v) == srf(Domain(0)[1-i], v)
     2 if v == Domain(1)[i] and srf(u, v) == srf(u, Domain(1)[1-i])
     3 if 1 and 2 are true.`
      },
      {
        signature: 'bool IsAtSingularity(double u,double v,bool exact)',
        summary: 'Tests if a surface parameter value is at a singularity.',
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'Surface u parameter to test.'
          },
          {
            name: 'v',
            summary: 'Surface v parameter to test.'
          },
          {
            name: 'exact',
            summary: `If true, test if (u,v) is exactly at a singularity.
     If false, test if close enough to cause numerical problems.`
          }
        ],
        returns: 'True if surface is singular at (s,t)'
      },
      {
        signature: 'bool IsClosed(int direction)',
        summary: 'Gets a value indicating if the surface is closed in a direction.',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: '0 = U, 1 = V.'
          }
        ],
        returns: 'The indicating boolean value.'
      },
      {
        signature: 'bool IsCone()',
        summary: 'Determines if the surface is a portion of a cone within RhinoMath.ZeroTolerance.',
        since: 5,
        returns: 'True if the surface is a portion of a cone.'
      },
      {
        signature: 'bool IsCone(double tolerance)',
        summary: 'Determines if the surface is a portion of a cone within a given tolerance.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'tolerance to use when checking.'
          }
        ],
        returns: 'True if the surface is a portion of a cone.'
      },
      {
        signature: 'bool IsContinuous(Continuity continuityType,double u,double v)',
        summary: 'Tests continuity at a surface parameter value.',
        since: 5,
        parameters: [
          {
            name: 'continuityType',
            summary: 'The continuity type to sample.'
          },
          {
            name: 'u',
            summary: 'Surface u parameter to test.'
          },
          {
            name: 'v',
            summary: 'Surface v parameter to test.'
          }
        ],
        returns: 'True if the surface has at least the specified continuity at the (u,v) parameter.'
      },
      {
        signature: 'bool IsCylinder()',
        summary: 'Determines if the surface is a portion of a cylinder within RhinoMath.ZeroTolerance.',
        since: 5,
        returns: 'True if the surface is a portion of a cylinder.'
      },
      {
        signature: 'bool IsCylinder(double tolerance)',
        summary: 'Determines if the surface is a portion of a cylinder within a given tolerance.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'tolerance to use when checking.'
          }
        ],
        returns: 'True if the surface is a portion of a cylinder.'
      },
      {
        signature: 'IsoStatus IsIsoparametric(BoundingBox bbox)',
        summary: 'Determines if a 2d bounding box is iso-parameteric in the parameter space of this surface.',
        since: 5,
        parameters: [
          {
            name: 'bbox',
            summary: 'Bounding box to test.'
          }
        ],
        returns: 'IsoStatus flag describing the iso-parametric relationship between the surface and the bounding box.'
      },
      {
        signature: 'IsoStatus IsIsoparametric(Curve curve)',
        summary: 'Determines if a 2d curve is iso-parameteric in the parameter space of this surface.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve to test.'
          }
        ],
        returns: 'IsoStatus flag describing the iso-parametric relationship between the surface and the curve.'
      },
      {
        signature: 'IsoStatus IsIsoparametric(Curve curve,Interval curveDomain)',
        summary: 'Determines if a 2D curve is iso-parameteric in the parameter space of this surface.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'Curve to test.'
          },
          {
            name: 'curveDomain',
            summary: 'Sub domain of the curve.'
          }
        ],
        returns: 'IsoStatus flag describing the iso-parametric relationship between the surface and the curve.'
      },
      {
        signature: 'Curve IsoCurve(int direction,double constantParameter)',
        summary: 'Gets isoparametric curve.',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: `0 first parameter varies and second parameter is constant
     e.g., point on IsoCurve(0,c) at t is srf(t,c)
     This is a horizontal line from left to right
     
     1 first parameter is constant and second parameter varies
     e.g., point on IsoCurve(1,c) at t is srf(c,t
     This is a vertical line from bottom to top.`
          },
          {
            name: 'constantParameter',
            summary: 'The parameter that was constant on the original surface.'
          }
        ],
        returns: 'An isoparametric curve or None on error.'
      },
      {
        signature: 'bool IsPeriodic(int direction)',
        summary: 'Gets a value indicating if thr surface is periodic in a direction (default is false).',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: '0 = U, 1 = V.'
          }
        ],
        returns: 'The indicating boolean value.'
      },
      {
        signature: 'bool IsPlanar()',
        summary: 'Tests a surface to see if it is planar to zero tolerance.',
        since: 5,
        returns: 'True if the surface is planar (flat) to within RhinoMath.ZeroTolerance units (1e-12).'
      },
      {
        signature: 'bool IsPlanar(double tolerance)',
        summary: 'Tests a surface to see if it is planar to a given tolerance.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'tolerance to use when checking.'
          }
        ],
        returns: `True if there is a plane such that the maximum distance from
     the surface to the plane is <= tolerance.`
      },
      {
        signature: 'bool IsSingular(int side)',
        summary: 'True if surface side is collapsed to a point.',
        since: 5,
        parameters: [
          {
            name: 'side',
            summary: `side of parameter space to test
     0 = south, 1 = east, 2 = north, 3 = west.`
          }
        ],
        returns: 'True if this specific side of the surface is singular; otherwise, false.'
      },
      {
        signature: 'bool IsSphere()',
        summary: 'Determines if the surface is a portion of a sphere within RhinoMath.ZeroTolerance.',
        since: 5,
        returns: 'True if the surface is a portion of a sphere.'
      },
      {
        signature: 'bool IsSphere(double tolerance)',
        summary: 'Determines if the surface is a portion of a sphere within a given tolerance.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'tolerance to use when checking.'
          }
        ],
        returns: 'True if the surface is a portion of a sphere.'
      },
      {
        signature: 'bool IsTorus()',
        summary: 'Determines if the surface is a portion of a torus within RhinoMath.ZeroTolerance.',
        since: 5,
        returns: 'True if the surface is a portion of a torus.'
      },
      {
        signature: 'bool IsTorus(double tolerance)',
        summary: 'Determines if the surface is a portion of a torus within a given tolerance.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'tolerance to use when checking.'
          }
        ],
        returns: 'True if the surface is a portion of a torus.'
      },
      {
        signature: 'bool LocalClosestPoint(Point3d testPoint,double seedU,double seedV,double u,double v)',
        summary: `Find parameters of the point on a surface that is locally closest to
     the testPoint. The search for a local close point starts at seed parameters.`,
        since: 6.3,
        parameters: [
          {
            name: 'testPoint',
            summary: 'A point to test against.'
          },
          {
            name: 'seedU',
            summary: 'The seed parameter in the U direction.'
          },
          {
            name: 'seedV',
            summary: 'The seed parameter in the V direction.'
          },
          {
            name: 'u',
            summary: 'U parameter of the surface that is closest to testPoint.'
          },
          {
            name: 'v',
            summary: 'V parameter of the surface that is closest to testPoint.'
          }
        ],
        returns: 'True if the search is successful, False if the search fails.'
      },
      {
        signature: 'Vector3d NormalAt(double u,double v)',
        summary: `Computes the surface normal at a point.
     This is the simple evaluation call - it does not support error handling.`,
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'A U parameter.'
          },
          {
            name: 'v',
            summary: 'A V parameter.'
          }
        ],
        returns: 'The normal.'
      },
      {
        signature: 'Surface Offset(double distance,double tolerance)',
        summary: 'Constructs a new surface which is offset from the current surface.',
        since: 5,
        parameters: [
          {
            name: 'distance',
            summary: 'Distance (along surface normal) to offset.'
          },
          {
            name: 'tolerance',
            summary: 'Offset accuracy.'
          }
        ],
        returns: 'The offsetted surface or None on failure.'
      },
      {
        signature: 'Point3d PointAt(double u,double v)',
        summary: 'Evaluates a point at a given parameter.',
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'evaluation parameters.'
          },
          {
            name: 'v',
            summary: 'evaluation parameters.'
          }
        ],
        returns: 'Point3d.Unset on failure.'
      },
      {
        signature: 'Curve Pullback(Curve curve3d,double tolerance)',
        summary: 'Pulls a 3d curve back to the surface\'s parameter space.',
        since: 5,
        parameters: [
          {
            name: 'curve3d',
            summary: 'The curve to pull.'
          },
          {
            name: 'tolerance',
            summary: `the maximum acceptable 3d distance between from surface(curve_2d(t))
     to the locus of points on the surface that are closest to curve_3d.`
          }
        ],
        returns: '2d curve.'
      },
      {
        signature: 'Curve Pullback(Curve curve3d,double tolerance,Interval curve3dSubdomain)',
        summary: 'Pulls a 3d curve back to the surface\'s parameter space.',
        since: 5,
        parameters: [
          {
            name: 'curve3d',
            summary: 'A curve.'
          },
          {
            name: 'tolerance',
            summary: `the maximum acceptable 3d distance between from surface(curve_2d(t))
     to the locus of points on the surface that are closest to curve_3d.`
          },
          {
            name: 'curve3dSubdomain',
            summary: 'A subdomain of the curve to sample.'
          }
        ],
        returns: '2d curve.'
      },
      {
        signature: 'Curve Pushup(Curve curve2d,double tolerance)',
        summary: 'Computes a 3d curve that is the composite of a 2d curve and the surface map.',
        since: 5,
        parameters: [
          {
            name: 'curve2d',
            summary: 'a 2d curve whose image is in the surface\'s domain.'
          },
          {
            name: 'tolerance',
            summary: 'the maximum acceptable distance from the returned 3d curve to the image of curve_2d on the surface.'
          }
        ],
        returns: '3d curve.'
      },
      {
        signature: 'Curve Pushup(Curve curve2d,double tolerance,Interval curve2dSubdomain)',
        summary: 'Computes a 3d curve that is the composite of a 2d curve and the surface map.',
        since: 5,
        parameters: [
          {
            name: 'curve2d',
            summary: 'a 2d curve whose image is in the surface\'s domain.'
          },
          {
            name: 'tolerance',
            summary: 'the maximum acceptable distance from the returned 3d curve to the image of curve_2d on the surface.'
          },
          {
            name: 'curve2dSubdomain',
            summary: 'The curve interval (a sub-domain of the original curve) to use.'
          }
        ],
        returns: '3d curve.'
      },
      {
        signature: 'NurbsSurface Rebuild(int uDegree,int vDegree,int uPointCount,int vPointCount)',
        summary: 'Rebuilds an existing surface to a given degree and point count.',
        since: 5,
        parameters: [
          {
            name: 'uDegree',
            summary: 'the output surface u degree.'
          },
          {
            name: 'vDegree',
            summary: 'the output surface u degree.'
          },
          {
            name: 'uPointCount',
            summary: `The number of points in the output surface u direction. Must be bigger
     than uDegree (maximum value is 1000)`
          },
          {
            name: 'vPointCount',
            summary: `The number of points in the output surface v direction. Must be bigger
     than vDegree (maximum value is 1000)`
          }
        ],
        returns: 'new rebuilt surface on success. None on failure.'
      },
      {
        signature: 'NurbsSurface RebuildOneDirection(int direction,int pointCount,LoftType loftType,double refitTolerance)',
        summary: 'Rebuilds an existing surface with a new surface to a given point count in either the u or v directions independently.',
        since: 6.7,
        parameters: [
          {
            name: 'direction',
            summary: 'The direction (0 = U, 1 = V).'
          },
          {
            name: 'pointCount',
            summary: 'The number of points in the output surface in the "direction" direction.'
          },
          {
            name: 'loftType',
            summary: 'The loft type'
          },
          {
            name: 'refitTolerance',
            summary: 'The refit tolerance. When in doubt, use the document\'s model absolute tolerance.'
          }
        ],
        returns: 'new rebuilt surface on success. None on failure.'
      },
      {
        signature: 'Surface Reverse(int direction)',
        summary: 'Reverses parameterization Domain changes from [a,b] to [-b,-a]',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: '0 for first parameter\'s domain, 1 for second parameter\'s domain.'
          }
        ],
        returns: 'a new reversed surface on success.'
      },
      {
        signature: 'Surface Reverse(int direction,bool inPlace)',
        summary: `Same as Reverse, but if inPlace is set to True this Surface is modified
     instead of a new copy being created.`,
        since: 5.8,
        parameters: [
          {
            name: 'direction',
            summary: '0 for first parameter\'s domain, 1 for second parameter\'s domain.'
          },
          {
            name: 'inPlace',
            summary: ''
          }
        ],
        returns: `If inPlace is False, a new reversed surface on success. If inPlace is
     true, this surface instance is returned on success.`
      },
      {
        signature: 'bool SetDomain(int direction,Interval domain)',
        summary: 'Sets the domain in a direction.',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: '0 sets first parameter\'s domain, 1 sets second parameter\'s domain.'
          },
          {
            name: 'domain',
            summary: 'A new domain to be assigned.'
          }
        ],
        returns: 'True if setting succeeded, otherwise false.'
      },
      {
        signature: 'Curve ShortPath(Point2d start,Point2d end,double tolerance)',
        summary: 'Constructs a geodesic between 2 points, used by ShortPath command in Rhino.',
        since: 5,
        parameters: [
          {
            name: 'start',
            summary: 'start point of curve in parameter space. Points must be distinct in the domain of thie surface.'
          },
          {
            name: 'end',
            summary: 'end point of curve in parameter space. Points must be distinct in the domain of thie surface.'
          },
          {
            name: 'tolerance',
            summary: 'tolerance used in fitting discrete solution.'
          }
        ],
        returns: 'a geodesic curve on the surface on success. None on failure.'
      },
      {
        signature: 'Surface Smooth(double smoothFactor,bool bXSmooth,bool bYSmooth,bool bZSmooth,bool bFixBoundaries,SmoothingCoordinateSystem coordinateSystem)',
        summary: 'Smooths a surface by averaging the positions of control points in a specified region.',
        since: 6,
        parameters: [
          {
            name: 'smoothFactor',
            summary: 'The smoothing factor, which controls how much control points move towards the average of the neighboring control points.'
          },
          {
            name: 'bXSmooth',
            summary: 'When True control points move in X axis direction.'
          },
          {
            name: 'bYSmooth',
            summary: 'When True control points move in Y axis direction.'
          },
          {
            name: 'bZSmooth',
            summary: 'When True control points move in Z axis direction.'
          },
          {
            name: 'bFixBoundaries',
            summary: 'When True the surface edges don\'t move.'
          },
          {
            name: 'coordinateSystem',
            summary: 'The coordinates to determine the direction of the smoothing.'
          }
        ],
        returns: 'The smoothed surface if successful, None otherwise.'
      },
      {
        signature: 'Surface Smooth(double smoothFactor,bool bXSmooth,bool bYSmooth,bool bZSmooth,bool bFixBoundaries,SmoothingCoordinateSystem coordinateSystem,Plane plane)',
        summary: 'Smooths a surface by averaging the positions of control points in a specified region.',
        since: 6,
        parameters: [
          {
            name: 'smoothFactor',
            summary: 'The smoothing factor, which controls how much control points move towards the average of the neighboring control points.'
          },
          {
            name: 'bXSmooth',
            summary: 'When True control points move in X axis direction.'
          },
          {
            name: 'bYSmooth',
            summary: 'When True control points move in Y axis direction.'
          },
          {
            name: 'bZSmooth',
            summary: 'When True control points move in Z axis direction.'
          },
          {
            name: 'bFixBoundaries',
            summary: 'When True the surface edges don\'t move.'
          },
          {
            name: 'coordinateSystem',
            summary: 'The coordinates to determine the direction of the smoothing.'
          },
          {
            name: 'plane',
            summary: 'If SmoothingCoordinateSystem.CPlane specified, then the construction plane.'
          }
        ],
        returns: 'The smoothed surface if successful, None otherwise.'
      },
      {
        signature: 'int SpanCount(int direction)',
        summary: 'Gets number of smooth nonempty spans in the parameter direction.',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: '0 gets first parameter\'s domain, 1 gets second parameter\'s domain.'
          }
        ],
        returns: 'The span count.'
      },
      {
        signature: 'Surface[] Split(int direction,double parameter)',
        summary: 'Splits (divides) the surface into two parts at the specified parameter',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: `0 = The surface is split vertically. The "west" side is returned as the first
     surface in the array and the "east" side is returned as the second surface in
     the array.
     1 = The surface is split horizontally. The "south" side is returned as the first surface in the array and the "north"
     side is returned as the second surfae in the array`
          },
          {
            name: 'parameter',
            summary: 'value of constant parameter in interval returned by Domain(direction)'
          }
        ],
        returns: 'Array of two surfaces on success'
      },
      {
        signature: 'Brep ToBrep()',
        summary: 'Converts the surface into a Brep.',
        since: 5,
        returns: 'A Brep with a similar shape like this surface or null.'
      },
      {
        signature: 'NurbsSurface ToNurbsSurface()',
        summary: `Gets a NURBS surface representation of this surface. Default 
     tolerance of 0.0 is used.`,
        since: 5,
        returns: 'NurbsSurface on success, None on failure.'
      },
      {
        signature: 'NurbsSurface ToNurbsSurface(double tolerance,int accuracy)',
        summary: 'Gets a NURBS surface representation of this surface.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: 'tolerance to use when creating NURBS representation.'
          },
          {
            name: 'accuracy',
            summary: `0 = unable to create NURBS representation with desired accuracy.
     
     1 = success - returned NURBS parameterization matches the surface's
     to the desired accuracy.
     
     2 = success - returned NURBS point locus matches the surface's to the
     desired accuracy and the domain of the NURBS surface is correct. 
     However, this surface's parameterization and the NURBS surface
     parameterization may not match to the desired accuracy. This 
     situation happens when getting NURBS representations of surfaces
     that have a transendental parameterization like spheres, cylinders,
     and cones.`
          }
        ],
        returns: 'NurbsSurface on success, None on failure.'
      },
      {
        signature: 'Surface Transpose()',
        summary: 'Transposes surface parameterization (swap U and V)',
        since: 5,
        returns: 'New transposed surface on success, None on failure.'
      },
      {
        signature: 'Surface Transpose(bool inPlace)',
        summary: 'Transposes surface parameterization (swap U and V)',
        since: 5.8,
        returns: 'New transposed surface on success, None on failure.'
      },
      {
        signature: 'Surface Trim(Interval u,Interval v)',
        summary: 'Constructs a sub-surface that covers the specified UV trimming domain.',
        since: 5,
        parameters: [
          {
            name: 'u',
            summary: 'Domain of surface along U direction to include in the subsurface.'
          },
          {
            name: 'v',
            summary: 'Domain of surface along V direction to include in the subsurface.'
          }
        ],
        returns: 'SubSurface on success, None on failure.'
      },
      {
        signature: 'bool TryGetCone(Cone cone)',
        summary: 'Tests a surface to see if it is a portion of a cone within RhinoMath.ZeroTolerance and return the cone.',
        since: 5,
        parameters: [
          {
            name: 'cone',
            summary: 'On success, the cone parameters are filled in.'
          }
        ],
        returns: 'True if the surface is a portion of a cone.'
      },
      {
        signature: 'bool TryGetCone(Cone cone,double tolerance)',
        summary: 'Tests a surface to see if it is a portion of a cone and returns the cone.',
        since: 5,
        parameters: [
          {
            name: 'cone',
            summary: 'On success, the cone parameters are filled in.'
          },
          {
            name: 'tolerance',
            summary: 'tolerance to use when checking.'
          }
        ],
        returns: 'True if the surface is a portion of a cone.'
      },
      {
        signature: 'bool TryGetCylinder(Cylinder cylinder)',
        summary: 'Tests a surface to see if it is a portion of a cylinder within RhinoMath.ZeroTolerance and return the cylinder.',
        since: 5,
        parameters: [
          {
            name: 'cylinder',
            summary: 'On success, the cylinder parameters are filled in.'
          }
        ],
        returns: 'True if the surface is a portion of a cylinder.'
      },
      {
        signature: 'bool TryGetCylinder(Cylinder cylinder,double tolerance)',
        summary: 'Tests a surface to see if it is a portion of a cylinder and return the infinite cylinder.',
        since: 5,
        parameters: [
          {
            name: 'cylinder',
            summary: 'On success, the cylinder parameters are filled in.'
          },
          {
            name: 'tolerance',
            summary: 'tolerance to use when checking.'
          }
        ],
        returns: 'True if the surface is a portion of a cylinder.'
      },
      {
        signature: 'bool TryGetFiniteCylinder(Cylinder cylinder,double tolerance)',
        summary: 'Tests a surface with the assumption that it might be a right circular cylinder and returns this geometry.',
        since: 6,
        parameters: [
          {
            name: 'cylinder',
            summary: 'On success, the cylinder parameters are filled in.'
          },
          {
            name: 'tolerance',
            summary: 'tolerance to use when checking.'
          }
        ],
        returns: 'True if the surface is a portion of a cylinder.'
      },
      {
        signature: 'bool TryGetPlane(Plane plane)',
        summary: 'Tests a surface for planarity and return the plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'On success, the plane parameters are filled in.'
          }
        ],
        returns: 'True if there is a plane such that the maximum distance from the surface to the plane is <= RhinoMath.ZeroTolerance.'
      },
      {
        signature: 'bool TryGetPlane(Plane plane,double tolerance)',
        summary: 'Tests a surface for planarity and return the plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'On success, the plane parameters are filled in.'
          },
          {
            name: 'tolerance',
            summary: 'tolerance to use when checking.'
          }
        ],
        returns: 'True if there is a plane such that the maximum distance from the surface to the plane is <= tolerance.'
      },
      {
        signature: 'bool TryGetSphere(Sphere sphere)',
        summary: 'Test a surface to see if it is a portion of a sphere and return the sphere.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'On success, the sphere parameters are filled in.'
          }
        ],
        returns: 'True if the surface is a portion of a sphere.'
      },
      {
        signature: 'bool TryGetSphere(Sphere sphere,double tolerance)',
        summary: 'Test a surface to see if it is a portion of a sphere and return the sphere.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'On success, the sphere parameters are filled in.'
          },
          {
            name: 'tolerance',
            summary: 'tolerance to use when checking.'
          }
        ],
        returns: 'True if the surface is a portion of a sphere.'
      },
      {
        signature: 'bool TryGetTorus(Torus torus)',
        summary: 'Tests a surface to see if it is a portion of a torus within RhinoMath.ZeroTolerance and returns the torus.',
        since: 5,
        parameters: [
          {
            name: 'torus',
            summary: 'On success, the torus parameters are filled in.'
          }
        ],
        returns: 'True if the surface is a portion of a torus.'
      },
      {
        signature: 'bool TryGetTorus(Torus torus,double tolerance)',
        summary: 'Tests a surface to see if it is a portion of a torus and returns the torus.',
        since: 5,
        parameters: [
          {
            name: 'torus',
            summary: 'On success, the torus parameters are filled in.'
          },
          {
            name: 'tolerance',
            summary: 'tolerance to use when checking.'
          }
        ],
        returns: 'True if the surface is a portion of a torus.'
      },
      {
        signature: 'Surface VariableOffset(double uMinvMin,double uMinvMax,double uMaxvMin,double uMaxvMax,double tolerance)',
        summary: 'Copies a surface so that all locations at the corners of the copied surface are specified distances from the original surface.',
        since: 6.13,
        parameters: [
          {
            name: 'uMinvMin',
            summary: 'Offset distance at Domain(0).Min, Domain(1).Min.'
          },
          {
            name: 'uMinvMax',
            summary: 'Offset distance at Domain(0).Min, Domain(1).Max.'
          },
          {
            name: 'uMaxvMin',
            summary: 'Offset distance at Domain(0).Max, Domain(1).Min.'
          },
          {
            name: 'uMaxvMax',
            summary: 'Offset distance at Domain(0).Max, Domain(1).Max.'
          },
          {
            name: 'tolerance',
            summary: 'The offset tolerance.'
          }
        ],
        returns: 'The offset surface if successful, None otherwise.'
      },
      {
        signature: 'Surface VariableOffset(double uMinvMin,double uMinvMax,double uMaxvMin,double uMaxvMax,IEnumerable<Point2d> interiorParameters,IEnumerable<double> interiorDistances,double tolerance)',
        summary: 'Copies a surface so that all locations at the corners, and from specified interior locations, of the copied surface are specified distances from the original surface.',
        since: 6.13,
        parameters: [
          {
            name: 'uMinvMin',
            summary: 'Offset distance at Domain(0).Min, Domain(1).Min.'
          },
          {
            name: 'uMinvMax',
            summary: 'Offset distance at Domain(0).Min, Domain(1).Max.'
          },
          {
            name: 'uMaxvMin',
            summary: 'Offset distance at Domain(0).Max, Domain(1).Min.'
          },
          {
            name: 'uMaxvMax',
            summary: 'Offset distance at Domain(0).Max, Domain(1).Max.'
          },
          {
            name: 'interiorParameters',
            summary: 'An array of interior uv parameters to offset from.'
          },
          {
            name: 'interiorDistances',
            summary: '>An array of offset distances at the interior uv parameters.'
          },
          {
            name: 'tolerance',
            summary: 'The offset tolerance.'
          }
        ],
        returns: 'The offset surface if successful, None otherwise.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SurfaceCurvature',
    dataType: 1,
    summary: 'Maintains computed information for surface curvature evaluation.',
    properties: [
      {
        signature: 'double Gaussian',
        summary: 'Gets the Gaussian curvature value at UV.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Mean',
        summary: 'Gets the Mean curvature value at UV.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d Normal',
        summary: 'Gets the surface normal at UV.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d Point',
        summary: 'Gets the surface point at UV.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point2d UVPoint',
        summary: 'Gets the UV location where the curvature was computed.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Vector3d Direction(int direction)',
        summary: 'Gets the principal curvature direction vector.',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: 'Direction index, valid values are 0 and 1.'
          }
        ],
        returns: 'The specified direction vector.'
      },
      {
        signature: 'double Kappa(int direction)',
        summary: 'Gets the Kappa curvature value.',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: 'Kappa index, valid values are 0 and 1.'
          }
        ],
        returns: 'The specified kappa value.'
      },
      {
        signature: 'Circle OsculatingCircle(int direction)',
        summary: 'Computes the osculating circle along the given direction.',
        since: 5,
        parameters: [
          {
            name: 'direction',
            summary: 'Direction index, valid values are 0 and 1.'
          }
        ],
        returns: 'The osculating circle in the given direction or Circle.Unset on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SurfaceProxy',
    dataType: 1,
    summary: 'Provides a base class to brep faces and other surface proxies.',
    baseclass: 'Rhino.Geometry.Surface'
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SweepOneRail',
    dataType: 1,
    summary: `Utility class for generating Breps by sweeping cross section curves over a single rail curve. 
   Note, this class has been superceeded by the Rhino.Geometry.Brep.CreateFromSweep static functions.`,
    constructors: [
      {
        signature: 'SweepOneRail()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'double AngleToleranceRadians',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ClosedSweep',
        summary: `If the input rail is closed, ClosedSweep determines if the swept breps will also
     be closed.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool GlobalShapeBlending',
        summary: `If true, the sweep is linearly blended from one end to the other,
     creating sweeps that taper from one cross-section curve to the other.
     If false, the sweep stays constant at the ends and changes more
     rapidly in the middle.`,
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsFreeform',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsRoadlike',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsRoadlikeFront',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsRoadlikeTop',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsRoadlineRight',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int MiterType',
        summary: '0: don\'t miter,  1: intersect surfaces and trim sweeps,  2: rotate shapes at kinks and don\'t trim.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double SweepTolerance',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'Brep[] PerformSweep(Curve rail,Curve crossSection)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweep(Curve rail,Curve crossSection,double crossSectionParameter)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweep(Curve rail,IEnumerable<Curve> crossSections)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweep(Curve rail,IEnumerable<Curve> crossSections,IEnumerable<double> crossSectionParameters)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweepRebuild(Curve rail,Curve crossSection,double crossSectionParameter,int rebuildCount)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweepRebuild(Curve rail,Curve crossSection,int rebuildCount)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweepRebuild(Curve rail,IEnumerable<Curve> crossSections,IEnumerable<double> crossSectionParameters,int rebuildCount)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweepRebuild(Curve rail,IEnumerable<Curve> crossSections,int rebuildCount)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweepRefit(Curve rail,Curve crossSection,double refitTolerance)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweepRefit(Curve rail,Curve crossSection,double crossSectionParameter,double refitTolerance)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweepRefit(Curve rail,IEnumerable<Curve> crossSections,double refitTolerance)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweepRefit(Curve rail,IEnumerable<Curve> crossSections,IEnumerable<double> crossSectionParameters,double refitTolerance)',
        since: 5
      },
      {
        signature: 'void SetRoadlikeUpDirection(Vector3d up)',
        since: 5
      },
      {
        signature: 'void SetToRoadlikeFront()',
        since: 5
      },
      {
        signature: 'void SetToRoadlikeRight()',
        since: 5
      },
      {
        signature: 'void SetToRoadlikeTop()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SweepRebuild',
    dataType: 3,
    summary: 'Rebuild types for creating swept surfaces',
    values: [
      {
        signature: 'None = 0',
        summary: 'Do not simplify cross section curves.'
      },
      {
        signature: 'Rebuild = 1',
        summary: 'Rebuild cross section curves through points.'
      },
      {
        signature: 'Refit = 2',
        summary: 'Refit cross section curves to tolerance.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'SweepTwoRail',
    dataType: 1,
    summary: `Utility class for generating Breps by sweeping cross section curves over two rail curves.
   Note, this class has been superceeded by the Rhino.Geometry.Brep.CreateFromSweep static functions.`,
    constructors: [
      {
        signature: 'SweepTwoRail()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'double AngleToleranceRadians',
        summary: 'Gets or sets the angle tolerance in radians.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ClosedSweep',
        summary: 'If the input rails are closed, ClosedSweep determines if the swept Breps will also be closed.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool MaintainHeight',
        summary: 'Removes the association between the height scaling from the width scaling.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double SweepTolerance',
        summary: 'Gets or sets the sweeping tolerance.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'Brep[] PerformSweep(Curve rail1,Curve rail2,Curve crossSection)',
        summary: `Sweep2 function that fits a surface through profile curves that define the surface cross-sections
     and two curves that defines a surface edge.`,
        since: 5,
        parameters: [
          {
            name: 'rail1',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'rail2',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'crossSection',
            summary: 'Shape curve'
          }
        ],
        returns: 'Array of Brep sweep results'
      },
      {
        signature: 'Brep[] PerformSweep(Curve rail1,Curve rail2,Curve crossSection,double crossSectionParameterRail1,double crossSectionParameterRail2)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweep(Curve rail1,Curve rail2,IEnumerable<Curve> crossSections)',
        summary: `Sweep2 function that fits a surface through profile curves that define the surface cross-sections
     and two curves that defines a surface edge.`,
        since: 5,
        parameters: [
          {
            name: 'rail1',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'rail2',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'crossSections',
            summary: 'Shape curves'
          }
        ],
        returns: 'Array of Brep sweep results'
      },
      {
        signature: 'Brep[] PerformSweep(Curve rail1,Curve rail2,IEnumerable<Curve> crossSections,IEnumerable<double> crossSectionParameters1,IEnumerable<double> crossSectionParameters2)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweepRebuild(Curve rail1,Curve rail2,Curve crossSection,double crossSectionParameterRail1,double crossSectionParameterRail2,int rebuildCount)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweepRebuild(Curve rail1,Curve rail2,Curve crossSection,int rebuildCount)',
        summary: `Sweep2 function that fits a surface through profile curves that define the surface cross-sections
     and two curves that defines a surface edge.`,
        since: 5,
        parameters: [
          {
            name: 'rail1',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'rail2',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'crossSection',
            summary: 'Shape curve'
          },
          {
            name: 'rebuildCount',
            summary: 'Rebuild point count'
          }
        ],
        returns: 'Array of Brep sweep results'
      },
      {
        signature: 'Brep[] PerformSweepRebuild(Curve rail1,Curve rail2,IEnumerable<Curve> crossSections,IEnumerable<double> crossSectionParametersRail1,IEnumerable<double> crossSectionParametersRail2,int rebuildCount)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweepRebuild(Curve rail1,Curve rail2,IEnumerable<Curve> crossSections,int rebuildCount)',
        summary: `Sweep2 function that fits a surface through profile curves that define the surface cross-sections
     and two curves that defines a surface edge.`,
        since: 5,
        parameters: [
          {
            name: 'rail1',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'rail2',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'crossSections',
            summary: 'Shape curves'
          },
          {
            name: 'rebuildCount',
            summary: 'Rebuild point count'
          }
        ],
        returns: 'Array of Brep sweep results'
      },
      {
        signature: 'Brep[] PerformSweepRefit(Curve rail1,Curve rail2,Curve crossSection,double refitTolerance)',
        summary: `Sweep2 function that fits a surface through profile curves that define the surface cross-sections
     and two curves that defines a surface edge.`,
        since: 5,
        parameters: [
          {
            name: 'rail1',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'rail2',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'crossSection',
            summary: 'Shape curve'
          },
          {
            name: 'refitTolerance',
            summary: 'Refit tolerance'
          }
        ],
        returns: 'Array of Brep sweep results'
      },
      {
        signature: 'Brep[] PerformSweepRefit(Curve rail1,Curve rail2,Curve crossSection,double crossSectionParameterRail1,double crossSectionParameterRail2,double refitTolerance)',
        since: 5
      },
      {
        signature: 'Brep[] PerformSweepRefit(Curve rail1,Curve rail2,IEnumerable<Curve> crossSections,double refitTolerance)',
        summary: `Sweep2 function that fits a surface through profile curves that define the surface cross-sections
     and two curves that defines a surface edge.`,
        since: 5,
        parameters: [
          {
            name: 'rail1',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'rail2',
            summary: 'Rail to sweep shapes along'
          },
          {
            name: 'crossSections',
            summary: 'Shape curves'
          },
          {
            name: 'refitTolerance',
            summary: 'Refit tolerance'
          }
        ],
        returns: 'Array of Brep sweep results'
      },
      {
        signature: 'Brep[] PerformSweepRefit(Curve rail1,Curve rail2,IEnumerable<Curve> crossSections,IEnumerable<double> crossSectionParametersRail1,IEnumerable<double> crossSectionParametersRail2,double refitTolerance)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'TextDot',
    dataType: 1,
    summary: `Represents a text dot, or an annotation entity with text that always faces the camera and always has the same size.
   This class refers to the geometric element that is independent from the document.`,
    baseclass: 'Rhino.Geometry.GeometryBase',
    constructors: [
      {
        signature: 'TextDot(string text,Point3d location)',
        summary: 'Initializes a new textdot based on the text and the location.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'Text.'
          },
          {
            name: 'location',
            summary: 'A position.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'string FontFace',
        summary: 'Font face used for displaying the dot',
        since: 5.2,
        property: ['get', 'set']
      },
      {
        signature: 'int FontHeight',
        summary: 'Height of font used for displaying the dot',
        since: 5.2,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d Point',
        summary: 'Gets or sets the position of the textdot.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string SecondaryText',
        summary: 'Gets or sets the secondary text of the textdot.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string Text',
        summary: 'Gets or sets the primiary text of the textdot.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'TextEntity',
    dataType: 1,
    baseclass: 'Rhino.Geometry.AnnotationBase',
    constructors: [
      {
        signature: 'TextEntity()',
        summary: 'Initializes a new instance of the TextEntity class.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'TextJustification Justification',
        summary: 'Gets or sets the justification of text in relation to its base point.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'TextHorizontalAlignment TextHorizontalAlignment',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'TextOrientation TextOrientation',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'TextVerticalAlignment TextVerticalAlignment',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static TextEntity Create(string text,Plane plane,DimensionStyle style,bool wrapped,double rectWidth,double rotationRadians)',
        summary: 'Create Text geometry or None if input is invalid',
        since: 6
      },
      {
        signature: 'static TextEntity CreateWithRichText(string richTextString,Plane plane,DimensionStyle style,bool wrapped,double rectWidth,double rotationRadians)',
        summary: 'Create RichText geometry or None if input is invalid',
        since: 6
      },
      {
        signature: 'Curve[] CreateCurves(DimensionStyle dimstyle,bool bAllowOpen,double smallCapsScale,double spacing)',
        summary: 'Returns the outline curves.',
        since: 6,
        parameters: [
          {
            name: 'dimstyle',
            summary: ''
          },
          {
            name: 'bAllowOpen',
            summary: 'Set to True to prevent forced closing of open curves retrieved from glyphs.'
          },
          {
            name: 'smallCapsScale',
            summary: 'Set to create small caps out of lower case letters.'
          },
          {
            name: 'spacing',
            summary: 'Set to add additional spacing between glyph output.'
          }
        ],
        returns: 'An array of curves that forms the outline or content of this text entity.'
      },
      {
        signature: 'Extrusion[] CreateExtrusions(DimensionStyle dimstyle,double height,double smallCapsScale,double spacing)',
        summary: 'Creates extrusions from the outline curves with specified height.',
        since: 6,
        parameters: [
          {
            name: 'dimstyle',
            summary: ''
          },
          {
            name: 'height',
            summary: 'Height in direction perpedicular to plane of text.'
          },
          {
            name: 'smallCapsScale',
            summary: 'Set to create small caps out of lower case letters.'
          },
          {
            name: 'spacing',
            summary: 'Set to add additional spacing between glyph output.'
          }
        ],
        returns: 'An array of planar breps.'
      },
      {
        signature: 'Brep[] CreatePolySurfaces(DimensionStyle dimstyle,double height,double smallCapsScale,double spacing)',
        summary: 'Creates breps from the outline curves with specified height.',
        since: 6,
        parameters: [
          {
            name: 'dimstyle',
            summary: ''
          },
          {
            name: 'height',
            summary: 'Height in direction perpedicular to plane of text.'
          },
          {
            name: 'smallCapsScale',
            summary: 'Set to create small caps out of lower case letters.'
          },
          {
            name: 'spacing',
            summary: 'Set to add additional spacing between glyph output.'
          }
        ],
        returns: 'An array of planar breps.'
      },
      {
        signature: 'Brep[] CreateSurfaces(DimensionStyle dimstyle,double smallCapsScale,double spacing)',
        summary: 'Creates planar breps from the outline curves.',
        since: 6,
        parameters: [
          {
            name: 'dimstyle',
            summary: ''
          },
          {
            name: 'smallCapsScale',
            summary: 'Set to create small caps out of lower case letters.'
          },
          {
            name: 'spacing',
            summary: 'Set to add additional spacing between glyph output.'
          }
        ],
        returns: 'An array of planar breps.'
      },
      {
        signature: 'Curve[] Explode()',
        summary: 'Explodes this text entity into an array of curves.',
        since: 5,
        returns: 'An array of curves that forms the outline or content of this text entity.'
      },
      {
        signature: 'Transform GetTextTransform(double textscale,DimensionStyle dimstyle)',
        summary: 'Get the transform for this text object\'s text geometry',
        since: 6
      },
      {
        signature: 'bool Transform(Transform transform,DimensionStyle style)',
        summary: `Transform the object by a 4x4 transform matrix and change text height
     override to accommodate scaling in the transform if necessary`,
        since: 6,
        parameters: [
          {
            name: 'transform',
            summary: 'An Transform with the transformation information'
          },
          {
            name: 'style',
            summary: ''
          }
        ],
        returns: 'Returns True on success otherwise returns false.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'TextJustification',
    dataType: 3,
    summary: 'Specifies enumerated constants used to indicate the internal alignment and justification of text.',
    values: [
      {
        signature: 'None = 0',
        summary: 'The default justification.'
      },
      {
        signature: 'Left = 1 << 0',
        summary: 'Left justification.'
      },
      {
        signature: 'Center = 1 << 1',
        summary: 'Center justification.'
      },
      {
        signature: 'Right = 1 << 2',
        summary: 'Right justification.'
      },
      {
        signature: 'Bottom = 1 << 16',
        summary: 'Bottom inner alignment.'
      },
      {
        signature: 'Middle = 1 << 17',
        summary: 'Middle inner alignment.'
      },
      {
        signature: 'Top = 1 << 18',
        summary: 'Top inner alignment.'
      },
      {
        signature: 'BottomLeft = Bottom | Left',
        summary: 'Combination of left justification and bottom alignment.'
      },
      {
        signature: 'BottomCenter = Bottom | Center',
        summary: 'Combination of center justification and bottom alignment.'
      },
      {
        signature: 'BottomRight = Bottom | Right',
        summary: 'Combination of right justification and bottom alignment.'
      },
      {
        signature: 'MiddleLeft = Middle | Left',
        summary: 'Combination of left justification and middle alignment.'
      },
      {
        signature: 'MiddleCenter = Middle | Center',
        summary: 'Combination of center justification and middle alignment.'
      },
      {
        signature: 'MiddleRight = Middle | Right',
        summary: 'Combination of right justification and middle alignment.'
      },
      {
        signature: 'TopLeft = Top | Left',
        summary: 'Combination of left justification and top alignment.'
      },
      {
        signature: 'TopCenter = Top | Center',
        summary: 'Combination of center justification and top alignment.'
      },
      {
        signature: 'TopRight = Top | Right',
        summary: 'Combination of right justification and top alignment.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'TextRunType',
    dataType: 3,
    values: [
      {
        signature: 'None = UnsafeNativeMethods.TextRunTypeConsts.None'
      },
      {
        signature: 'Text = UnsafeNativeMethods.TextRunTypeConsts.Text'
      },
      {
        signature: 'Newline = UnsafeNativeMethods.TextRunTypeConsts.Newline'
      },
      {
        signature: 'Paragraph = UnsafeNativeMethods.TextRunTypeConsts.Paragraph'
      },
      {
        signature: 'Column = UnsafeNativeMethods.TextRunTypeConsts.Column'
      },
      {
        signature: 'Field = UnsafeNativeMethods.TextRunTypeConsts.Field'
      },
      {
        signature: 'Fontdef = UnsafeNativeMethods.TextRunTypeConsts.Fontdef'
      },
      {
        signature: 'Header = UnsafeNativeMethods.TextRunTypeConsts.Header'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Torus',
    dataType: 2,
    summary: 'Represents the value of a plane and two radii in a torus that is oriented in three-dimensional space.',
    constructors: [
      {
        signature: 'Torus(Plane basePlane,double majorRadius,double minorRadius)',
        summary: 'Initializes a new Torus from base pane and two radii.',
        since: 5,
        parameters: [
          {
            name: 'basePlane',
            summary: 'Base plane for major radius circle.'
          },
          {
            name: 'majorRadius',
            summary: 'Radius of circle that lies at the heart of the torus.'
          },
          {
            name: 'minorRadius',
            summary: 'Radius of torus section.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Torus Unset',
        summary: 'Gets an invalid Torus.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: 'Gets a value indicating whether this torus is valid.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double MajorRadius',
        summary: 'Gets or sets the radius of the circle that lies at the heart of the torus.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double MinorRadius',
        summary: 'Gets or sets the radius of the torus section.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Plane Plane',
        summary: 'Gets or sets the plane for the torus large circle.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'bool EpsilonEquals(Torus other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'NurbsSurface ToNurbsSurface()',
        summary: `Converts this torus to its nurbs surface representation. 
     This is synonymous with calling NurbsSurface.CreateFromTorus().`,
        since: 5,
        returns: 'A nurbs surface representation of this torus, or None on error.'
      },
      {
        signature: 'RevSurface ToRevSurface()',
        summary: `Convert this torus to a surface of revolution representation. 
     This is synonymous with calling RevSurface.CreateFromTorus().`,
        since: 5,
        returns: 'A surface of revolution representation of this torus, or None on error.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Transform',
    dataType: 2,
    summary: `Represents the values in a 4x4 transform matrix.
   This is parallel to C++ ON_Xform.`,
    constructors: [
      {
        signature: 'Transform(double diagonalValue)',
        summary: 'Initializes a new transform matrix with a specified value along the diagonal.',
        since: 5,
        parameters: [
          {
            name: 'diagonalValue',
            summary: 'Value to assign to all diagonal cells except M33 which is set to 1.0.'
          }
        ]
      },
      {
        signature: 'Transform(Transform value)',
        summary: 'Initializes a new transform matrix with a specified value.',
        since: 6,
        parameters: [
          {
            name: 'value',
            summary: 'Value to assign to all cells.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Transform Identity',
        summary: 'Gets a new identity transform matrix. An identity matrix defines no transformation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Transform Unset',
        summary: 'Gets an XForm filled with RhinoMath.UnsetValue.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Transform ZeroTransformation',
        summary: 'ZeroTransformation diagonal = (0,0,0,1)',
        since: 6.1,
        property: ['get']
      },
      {
        signature: 'double Determinant',
        summary: 'The determinant of this 4x4 matrix.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsAffine',
        summary: `Tests for an affine transformation.
     An affine transformation can be broken into a linear transformation and a translation.`,
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'bool IsIdentity',
        summary: 'Return True if this Transform is the identity transform',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsLinear',
        summary: `Tests for a linear transformation.
     An affine transformation can be broken into a linear transformation and a translation.`,
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'bool IsRotation',
        summary: 'Returns True if this is a proper rotation.',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: `Gets a value indicating whether or not this Transform is a valid matrix. 
     A valid transform matrix is not allowed to have any invalid numbers.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsZero',
        summary: `True if matrix is Zero4x4, ZeroTransformation, or some other type of
     zero.The value xform[3][3] can be anything.`,
        since: 6.1,
        property: ['get']
      },
      {
        signature: 'bool IsZero4x4',
        summary: 'True if all values are 0',
        since: 6.1,
        property: ['get']
      },
      {
        signature: 'bool IsZeroTransformation',
        summary: 'True if all values are 0 and M33 is 1',
        since: 6.1,
        property: ['get']
      },
      {
        signature: 'double M00',
        summary: 'Gets or sets this[0,0].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M01',
        summary: 'Gets or sets this[0,1].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M02',
        summary: 'Gets or sets this[0,2].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M03',
        summary: 'Gets or sets this[0,3].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M10',
        summary: 'Gets or sets this[1,0].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M11',
        summary: 'Gets or sets this[1,1].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M12',
        summary: 'Gets or sets this[1,2].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M13',
        summary: 'Gets or sets this[1,3].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M20',
        summary: 'Gets or sets this[2,0].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M21',
        summary: 'Gets or sets this[2,1].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M22',
        summary: 'Gets or sets this[2,2].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M23',
        summary: 'Gets or sets this[2,3].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M30',
        summary: 'Gets or sets this[3,0].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M31',
        summary: 'Gets or sets this[3,1].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M32',
        summary: 'Gets or sets this[3,2].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double M33',
        summary: 'Gets or sets this[3,3].',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'TransformRigidType RigidType',
        summary: `Gets a value indicating whether or not the Transform is rigid. 
     A rigid transformation can be broken into  a proper rotation and a translation,
     while an isometry transformation could also include a reflection.`,
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'TransformSimilarityType SimilarityType',
        summary: `Gets a value indicating whether or not the Transform maintains similarity. 
     The easiest way to think of Similarity is that any circle, when transformed, 
     remains a circle. Whereas a non-similarity Transform deforms circles into ellipses.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Transform ChangeBasis(Plane plane0,Plane plane1)',
        summary: `Computes a change of basis transformation. A basis change is essentially a remapping 
     of geometry from one coordinate system to another.`,
        since: 5,
        parameters: [
          {
            name: 'plane0',
            summary: 'Coordinate system in which the geometry is currently described.'
          },
          {
            name: 'plane1',
            summary: 'Target coordinate system in which we want the geometry to be described.'
          }
        ],
        returns: `A transformation matrix which orients geometry from one coordinate system to another on success.
     Transform.Unset on failure.`
      },
      {
        signature: 'static Transform ChangeBasis(Vector3d initialBasisX,Vector3d initialBasisY,Vector3d initialBasisZ,Vector3d finalBasisX,Vector3d finalBasisY,Vector3d finalBasisZ)',
        summary: `Computes a change of basis transformation. A basis change is essentially a remapping 
     of geometry from one coordinate system to another.`,
        since: 5,
        parameters: [
          {
            name: 'initialBasisX',
            summary: 'can be any 3d basis.'
          },
          {
            name: 'initialBasisY',
            summary: 'can be any 3d basis.'
          },
          {
            name: 'initialBasisZ',
            summary: 'can be any 3d basis.'
          },
          {
            name: 'finalBasisX',
            summary: 'can be any 3d basis.'
          },
          {
            name: 'finalBasisY',
            summary: 'can be any 3d basis.'
          },
          {
            name: 'finalBasisZ',
            summary: 'can be any 3d basis.'
          }
        ],
        returns: `A transformation matrix which orients geometry from one coordinate system to another on success.
     Transform.Unset on failure.`
      },
      {
        signature: 'static Transform Diagonal(double d0,double d1,double d2)',
        summary: 'Constructs a new transformation with diagonal (d0,d1,d2,1.0).',
        since: 6.12,
        parameters: [
          {
            name: 'd0',
            summary: 'Transform.M00 value.'
          },
          {
            name: 'd1',
            summary: 'Transform.M11 value.'
          },
          {
            name: 'd2',
            summary: 'Transform.M22 value.'
          }
        ],
        returns: 'A transformation with diagonal (d0,d1,d2,1.0).'
      },
      {
        signature: 'static Transform Diagonal(Vector3d diagonal)',
        summary: 'Constructs a new transformation with diagonal (d0,d1,d2,1.0).',
        since: 6.12,
        parameters: [
          {
            name: 'diagonal',
            summary: 'The diagonal values.'
          }
        ],
        returns: 'A transformation with diagonal (d0,d1,d2,1.0).'
      },
      {
        signature: 'static Transform Mirror(Plane mirrorPlane)',
        summary: 'Constructs a new Mirror transformation.',
        since: 5,
        parameters: [
          {
            name: 'mirrorPlane',
            summary: 'Plane that defines the mirror orientation and position.'
          }
        ],
        returns: 'A transformation matrix which mirrors geometry in a specified plane.'
      },
      {
        signature: 'static Transform Mirror(Point3d pointOnMirrorPlane,Vector3d normalToMirrorPlane)',
        summary: `Create mirror transformation matrix
     The mirror transform maps a point Q to 
     Q - (2*(Q-P)oN)*N, where
     P = pointOnMirrorPlane and N = normalToMirrorPlane.`,
        since: 5,
        parameters: [
          {
            name: 'pointOnMirrorPlane',
            summary: 'Point on the mirror plane.'
          },
          {
            name: 'normalToMirrorPlane',
            summary: 'Normal vector to the mirror plane.'
          }
        ],
        returns: 'A transformation matrix which mirrors geometry in a specified plane.'
      },
      {
        signature: 'static Transform Multiply(Transform a,Transform b)',
        summary: `Multiplies (combines) two transformations.
     This is the same as the * operator between two transformations.`,
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'First transformation.'
          },
          {
            name: 'b',
            summary: 'Second transformation.'
          }
        ],
        returns: `A transformation matrix that combines the effect of both input transformations. 
     The resulting Transform gives the same result as though you'd first apply B then A.`
      },
      {
        signature: 'static Transform PlanarProjection(Plane plane)',
        summary: 'Constructs a projection transformation.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane onto which everything will be perpendicularly projected.'
          }
        ],
        returns: 'A transformation matrix which projects geometry onto a specified plane.'
      },
      {
        signature: 'static Transform PlaneToPlane(Plane plane0,Plane plane1)',
        summary: `Create a rotation transformation that orients plane0 to plane1. If you want to orient objects from
     one plane to another, use this form of transformation.`,
        since: 5,
        parameters: [
          {
            name: 'plane0',
            summary: 'The plane to orient from.'
          },
          {
            name: 'plane1',
            summary: 'the plane to orient to.'
          }
        ],
        returns: 'The translation transformation if successful, Transform.Unset on failure.'
      },
      {
        signature: 'static Transform ProjectAlong(Plane plane,Vector3d direction)',
        summary: 'Construct a projection onto a plane along a specific direction.',
        since: 6,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane to project onto.'
          },
          {
            name: 'direction',
            summary: 'Projection direction, must not be parallel to the plane.'
          }
        ],
        returns: 'Projection transformation or identity transformation if projection could not be calculated.'
      },
      {
        signature: 'static Transform Rotation(double sinAngle,double cosAngle,Vector3d rotationAxis,Point3d rotationCenter)',
        summary: 'Constructs a new rotation transformation with specified angle, rotation center and rotation axis.',
        since: 5,
        parameters: [
          {
            name: 'sinAngle',
            summary: 'Sin of the rotation angle.'
          },
          {
            name: 'cosAngle',
            summary: 'Cos of the rotation angle.'
          },
          {
            name: 'rotationAxis',
            summary: 'Axis direction of rotation.'
          },
          {
            name: 'rotationCenter',
            summary: 'Center point of rotation.'
          }
        ],
        returns: 'A transformation matrix which rotates geometry around an anchor point.'
      },
      {
        signature: 'static Transform Rotation(double angleRadians,Point3d rotationCenter)',
        summary: 'Constructs a new rotation transformation with specified angle and rotation center.',
        since: 5,
        parameters: [
          {
            name: 'angleRadians',
            summary: 'Angle (in Radians) of the rotation.'
          },
          {
            name: 'rotationCenter',
            summary: 'Center point of rotation. Rotation axis is vertical.'
          }
        ],
        returns: 'A transformation matrix which rotates geometry around an anchor point.'
      },
      {
        signature: 'static Transform Rotation(double angleRadians,Vector3d rotationAxis,Point3d rotationCenter)',
        summary: 'Constructs a new rotation transformation with specified angle, rotation center and rotation axis.',
        since: 5,
        parameters: [
          {
            name: 'angleRadians',
            summary: 'Angle (in Radians) of the rotation.'
          },
          {
            name: 'rotationAxis',
            summary: 'Axis direction of rotation operation.'
          },
          {
            name: 'rotationCenter',
            summary: 'Center point of rotation. Rotation axis is vertical.'
          }
        ],
        returns: 'A transformation matrix which rotates geometry around an anchor point.'
      },
      {
        signature: 'static Transform Rotation(Vector3d startDirection,Vector3d endDirection,Point3d rotationCenter)',
        summary: 'Constructs a new rotation transformation with start and end directions and rotation center.',
        since: 5,
        parameters: [
          {
            name: 'startDirection',
            summary: 'A start direction.'
          },
          {
            name: 'endDirection',
            summary: 'An end direction.'
          },
          {
            name: 'rotationCenter',
            summary: 'A rotation center.'
          }
        ],
        returns: 'A transformation matrix which rotates geometry around an anchor point.'
      },
      {
        signature: 'static Transform Rotation(Vector3d x0,Vector3d y0,Vector3d z0,Vector3d x1,Vector3d y1,Vector3d z1)',
        summary: 'Constructs a transformation that maps X0 to X1, Y0 to Y1, Z0 to Z1.',
        since: 5,
        parameters: [
          {
            name: 'x0',
            summary: 'First "from" vector.'
          },
          {
            name: 'y0',
            summary: 'Second "from" vector.'
          },
          {
            name: 'z0',
            summary: 'Third "from" vector.'
          },
          {
            name: 'x1',
            summary: 'First "to" vector.'
          },
          {
            name: 'y1',
            summary: 'Second "to" vector.'
          },
          {
            name: 'z1',
            summary: 'Third "to" vector.'
          }
        ],
        returns: 'A rotation transformation value.'
      },
      {
        signature: 'static Transform RotationZYX(double yaw,double pitch,double roll)',
        summary: 'Create rotation transformation From Tait-Byran angles (also loosely known as Euler angles).',
        since: 6.11,
        parameters: [
          {
            name: 'yaw',
            summary: 'Angle, in radians, to rotate about the Z axis.'
          },
          {
            name: 'pitch',
            summary: 'Angle, in radians, to rotate about the Y axis.'
          },
          {
            name: 'roll',
            summary: 'Angle, in radians, to rotate about the X axis.'
          }
        ],
        returns: 'A transform matrix from Tait-Byran angles.'
      },
      {
        signature: 'static Transform RotationZYZ(double alpha,double beta,double gamma)',
        summary: 'Create rotation transformation From Euler angles.',
        since: 6.11,
        parameters: [
          {
            name: 'alpha',
            summary: 'Angle, in radians, to rotate about the Z axis.'
          },
          {
            name: 'beta',
            summary: 'Angle, in radians, to rotate about the Y axis.'
          },
          {
            name: 'gamma',
            summary: 'Angle, in radians, to rotate about the X axis.'
          }
        ],
        returns: 'A transform matrix from Euler angles.'
      },
      {
        signature: 'static Transform Scale(Plane plane,double xScaleFactor,double yScaleFactor,double zScaleFactor)',
        summary: 'Constructs a new non-uniform scaling transformation with a specified scaling anchor point.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Defines the center and orientation of the scaling operation.'
          },
          {
            name: 'xScaleFactor',
            summary: 'Scaling factor along the anchor plane X-Axis direction.'
          },
          {
            name: 'yScaleFactor',
            summary: 'Scaling factor along the anchor plane Y-Axis direction.'
          },
          {
            name: 'zScaleFactor',
            summary: 'Scaling factor along the anchor plane Z-Axis direction.'
          }
        ],
        returns: 'A transformation matrix which scales geometry non-uniformly.'
      },
      {
        signature: 'static Transform Scale(Point3d anchor,double scaleFactor)',
        summary: 'Constructs a new uniform scaling transformation with a specified scaling anchor point.',
        since: 5,
        parameters: [
          {
            name: 'anchor',
            summary: 'Defines the anchor point of the scaling operation.'
          },
          {
            name: 'scaleFactor',
            summary: 'Scaling factor in all directions.'
          }
        ],
        returns: 'A transform matrix which scales geometry uniformly around the anchor point.'
      },
      {
        signature: 'static Transform Shear(Plane plane,Vector3d x,Vector3d y,Vector3d z)',
        summary: 'Constructs a Shear transformation.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'Base plane for shear.'
          },
          {
            name: 'x',
            summary: 'Shearing vector along plane x-axis.'
          },
          {
            name: 'y',
            summary: 'Shearing vector along plane y-axis.'
          },
          {
            name: 'z',
            summary: 'Shearing vector along plane z-axis.'
          }
        ],
        returns: 'A transformation matrix which shear geometry.'
      },
      {
        signature: 'static Transform Translation(double dx,double dy,double dz)',
        summary: `Constructs a new translation (move) tranformation. 
     Right column is (dx, dy, dz, 1.0).`,
        since: 5,
        parameters: [
          {
            name: 'dx',
            summary: 'Distance to translate (move) geometry along the world X axis.'
          },
          {
            name: 'dy',
            summary: 'Distance to translate (move) geometry along the world Y axis.'
          },
          {
            name: 'dz',
            summary: 'Distance to translate (move) geometry along the world Z axis.'
          }
        ],
        returns: 'A transform matrix which moves geometry with the specified distances.'
      },
      {
        signature: 'static Transform Translation(Vector3d motion)',
        summary: 'Constructs a new translation (move) transformation.',
        since: 5,
        parameters: [
          {
            name: 'motion',
            summary: 'Translation (motion) vector.'
          }
        ],
        returns: 'A transform matrix which moves geometry along the motion vector.'
      },
      {
        signature: 'void Affineize()',
        summary: 'Replaces the last row with (0 0 0 1), discarding any perspecive part of this transform',
        since: 6.12
      },
      {
        signature: 'Transform Clone()',
        summary: `Returns a deep copy of the transform. For languages that treat structures as value types, this can 
     be accomplished by a simple assignment.`,
        since: 6,
        returns: 'A deep copy of this data structure.'
      },
      {
        signature: 'int CompareTo(Transform other)',
        summary: `Compares this transform with another transform.
     M33 has highest value, then M32, etc..`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Another transform.'
          }
        ],
        returns: '-1 if this < other; 0 if both are equal; 1 otherwise.'
      },
      {
        signature: 'bool DecomposeAffine(Transform linear,Vector3d translation)',
        summary: `Decomposes an affine transformation.
     An affine transformation can be broken into a linear transformation and a translation.
     Note, a perspective transformation is not affine.`,
        since: 6.12,
        parameters: [
          {
            name: 'linear',
            summary: 'Linear transformation.'
          },
          {
            name: 'translation',
            summary: 'Translation vector.'
          }
        ],
        returns: 'True if successful decomposition.'
      },
      {
        signature: 'bool DecomposeAffine(Vector3d translation,Transform linear)',
        summary: `Decomposes an affine transformation.
     An affine transformation can be broken into a linear transformation and a translation.
     Note, a perspective transformation is not affine.`,
        since: 6.12,
        parameters: [
          {
            name: 'translation',
            summary: 'Translation vector.'
          },
          {
            name: 'linear',
            summary: 'Linear transformation.'
          }
        ],
        returns: 'True if successful decomposition.'
      },
      {
        signature: 'bool DecomposeAffine(Vector3d translation,Transform rotation,Transform orthogonal,Vector3d diagonal)',
        summary: `An affine transformation can be decomposed into a Symmetric, Rotation and Translation.
     Then the Symmetric component may be further decomposed as non-uniform scale in an orthonormal
     coordinate system.`,
        since: 6.12,
        parameters: [
          {
            name: 'translation',
            summary: 'Translation vector.'
          },
          {
            name: 'rotation',
            summary: 'Proper rotation transformation.'
          },
          {
            name: 'orthogonal',
            summary: 'Orthogonal basis.'
          },
          {
            name: 'diagonal',
            summary: 'Diagonal elements of a Diagonal transformation.'
          }
        ],
        returns: 'True if successful decomposition.'
      },
      {
        signature: 'TransformRigidType DecomposeRigid(Vector3d translation,Transform rotation,double tolerance)',
        summary: 'Decomposes a rigid transformation. The transfomration must be affine.',
        since: 6.12,
        parameters: [
          {
            name: 'translation',
            summary: 'Translation vector.'
          },
          {
            name: 'rotation',
            summary: 'Proper rotation transformation, where R*Transpose(R)=I and det(R)=1.'
          },
          {
            name: 'tolerance',
            summary: 'The evaluation tolerance.'
          }
        ],
        returns: 'The rigid type.'
      },
      {
        signature: 'TransformSimilarityType DecomposeSimilarity(Vector3d translation,double dilation,Transform rotation,double tolerance)',
        summary: `Decomposes a similarity transformation. The transformation must be affine.
     A similarity transformation can be broken into a sequence of a dialation, translation, rotation, and a reflection.`,
        since: 6.12,
        parameters: [
          {
            name: 'translation',
            summary: 'Translation vector.'
          },
          {
            name: 'dilation',
            summary: 'Dialation, where dilation lt; 0 if this is an orientation reversing similarity.'
          },
          {
            name: 'rotation',
            summary: 'A proper rotation transformation, where R*Transpose(R)=I and Determinant(R)=1.'
          },
          {
            name: 'tolerance',
            summary: 'The evaluation tolerance.'
          }
        ],
        returns: 'The similarity type.'
      },
      {
        signature: 'bool DecomposeSymmetric(Transform matrix,Vector3d diagonal)',
        summary: `A Symmetric linear transformation can be decomposed A = Q * Diag * Q ^ T, where Diag is a diagonal
     transformation. Diag[i][i] is an eigenvalue of A and the i-th coulmn of Q is a corresponding
     unit length eigenvector. Note, this transformation must be Linear and Symmetric.`,
        since: 6.12,
        parameters: [
          {
            name: 'matrix',
            summary: 'An orthonormal matrix of eigenvectors (Q).'
          },
          {
            name: 'diagonal',
            summary: 'A vector of eigenvalues.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines if another object is a transform and its value equals this transform value.',
        parameters: [
          {
            name: 'obj',
            summary: 'Another object.'
          }
        ],
        returns: 'True if obj is a transform and has the same value as this transform; otherwise, false.'
      },
      {
        signature: 'bool Equals(Transform other)',
        summary: 'Determines if another transform equals this transform value.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Another transform.'
          }
        ],
        returns: 'True if other has the same value as this transform; otherwise, false.'
      },
      {
        signature: 'bool GetEulerZYZ(double alpha,double beta,double gamma)',
        summary: 'Find the Euler angles for a rotation transformation.',
        since: 6.11,
        parameters: [
          {
            name: 'alpha',
            summary: 'Angle of rotation, in radians, about the Z axis.'
          },
          {
            name: 'beta',
            summary: 'Angle of rotation, in radians, about the Y axis.'
          },
          {
            name: 'gamma',
            summary: 'Angle of rotation, in radians, about the Z axis.'
          }
        ],
        returns: `If true, then RotationZYZ(alpha, beta, gamma) = R_z(alpha) * R_y(beta) * R_z(gamma)
     where R_*(angle) is rotation of angle radians about the corresponding *-world coordinate axis.
     If false, then this is not a rotation.`
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Gets a non-unique hashing code for this transform.',
        returns: 'A number that can be used to hash this transform in a dictionary.'
      },
      {
        signature: 'bool GetYawPitchRoll(double yaw,double pitch,double roll)',
        summary: 'Find the Tait-Byran angles (also loosely called Euler angles) for a rotation transformation.',
        since: 6.11,
        parameters: [
          {
            name: 'yaw',
            summary: 'Angle of rotation, in radians, about the Z axis.'
          },
          {
            name: 'pitch',
            summary: 'Angle of rotation, in radians, about the Y axis.'
          },
          {
            name: 'roll',
            summary: 'Angle of rotation, in radians, about the Z axis.'
          }
        ],
        returns: `If true, then RotationZYX(yaw, pitch, roll) = R_z(yaw) * R_y(pitch) * R_x(roll) 
     where R_*(angle) is rotation of angle radians about the corresponding world coordinate axis.
     If false, then this is not a rotation.`
      },
      {
        signature: 'TransformRigidType IsRigid(double tolerance)',
        summary: `Gets a value indicating whether or not the Transform is rigid. 
     A rigid transformation can be broken into  a proper rotation and a translation,
     while an isometry transformation could also include a reflection.`,
        since: 6.12,
        parameters: [
          {
            name: 'tolerance',
            summary: 'The evaluation tolerance.'
          }
        ],
        returns: 'The rigid type.'
      },
      {
        signature: 'TransformSimilarityType IsSimilarity(double tolerance)',
        summary: `Gets a value indicating whether or not the Transform maintains similarity. 
     A similarity transformation can be broken into a sequence of a dialation, translation, rotation, and a reflection.`,
        since: 6.12,
        parameters: [
          {
            name: 'tolerance',
            summary: 'The evaluation tolerance.'
          }
        ],
        returns: 'The similarity type.'
      },
      {
        signature: 'bool IsZeroTransformaton(double zeroTolerance)',
        summary: 'True if all values are 0 and M33 is 1 within tolerance.',
        since: 6.12,
        parameters: [
          {
            name: 'zeroTolerance',
            summary: 'The zero tolerance.'
          }
        ],
        returns: 'Returns True if all values are 0 and M33 is 1 within tolerance.'
      },
      {
        signature: 'void Linearize()',
        summary: 'Affineize() and replaces the last column with (0 0 0 1)^T, discarding any translation part of this transform.',
        since: 6.12
      },
      {
        signature: 'bool Orthogonalize(double tolerance)',
        summary: `Force the linear part of this transformation to be a rotation (or a rotation with reflection).
     Use DecomposeRigid(T,R) to find the nearest rotation.`,
        since: 6.12,
        parameters: [
          {
            name: 'tolerance',
            summary: 'The evaluation tolerance'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'float[] ToFloatArray(bool rowDominant)',
        summary: 'Return the matrix as a linear array of 16 float values',
        since: 5.9
      },
      {
        signature: 'string ToString()',
        summary: 'Returns a string representation of this transform.',
        returns: 'A textual representation.'
      },
      {
        signature: 'BoundingBox TransformBoundingBox(BoundingBox bbox)',
        summary: `Computes a new boundingbox that is the smallest axis aligned
     boundingbox that contains the transformed result of its 8 original corner
     points.`,
        since: 5,
        returns: 'A new bounding box.'
      },
      {
        signature: 'Point3d[] TransformList(IEnumerable<Point3d> points)',
        summary: 'Given a list, an array or any enumerable set of points, computes a new array of tranformed points.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'A list, an array or any enumerable set of points to be left untouched and copied.'
          }
        ],
        returns: 'A new array.'
      },
      {
        signature: 'Transform Transpose()',
        summary: 'Flip row/column values',
        since: 5.9
      },
      {
        signature: 'bool TryGetInverse(Transform inverseTransform)',
        summary: 'Attempts to get the inverse transform of this transform.',
        since: 5,
        parameters: [
          {
            name: 'inverseTransform',
            summary: 'The inverse transform. This out reference will be assigned during this call.'
          }
        ],
        returns: `True on success. 
     If False is returned and this Transform is Invalid, inserveTransform will be set to this Transform. 
     If False is returned and this Transform is Valid, inverseTransform will be set to a pseudo inverse.`
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'TransformRigidType',
    dataType: 3,
    summary: 'Lists all possible outcomes for rigid transformation.',
    values: [
      {
        signature: 'RigidReversing = -1',
        summary: 'Transformation is an orientation reversing isometry.'
      },
      {
        signature: 'NotRigid = 0',
        summary: 'Transformation is not an orthogonal transformation.'
      },
      {
        signature: 'Rigid = 1',
        summary: 'Transformation is an rigid transformation.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'TransformSimilarityType',
    dataType: 3,
    summary: 'Lists all possible outcomes for transform similarity.',
    values: [
      {
        signature: 'OrientationReversing = -1',
        summary: 'Similarity is preserved, but orientation is flipped.'
      },
      {
        signature: 'NotSimilarity = 0',
        summary: 'Similarity is not preserved. Geometry needs to be deformable for this Transform to operate correctly.'
      },
      {
        signature: 'OrientationPreserving = 1',
        summary: 'Similarity and orientation are preserved.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Unroller',
    dataType: 1,
    summary: 'Represents the operation of unrolling a single surface.',
    constructors: [
      {
        signature: 'Unroller(Brep brep)',
        summary: 'Initializes a new instance of the Unroller class with a brep.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'A brep to be unrolled.'
          }
        ]
      },
      {
        signature: 'Unroller(Surface surface)',
        summary: 'Initializes a new instance of the Unroller class with surface.',
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'A surface to be unrolled.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'double AbsoluteTolerance',
        summary: `Gets or sets the absolute tolerance for the unrolling operation.
     Absolute tolerance is used in the evaluation of new entities,
     such as intersections, reprojections and splits.In the current implementation, absolute tolerance is used 
     in tessellating rails, fitting curves and pulling back trims.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ExplodeOutput',
        summary: 'Gets or sets a value determining whether geometry should be exploded.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double ExplodeSpacing',
        summary: 'Gets or sets a value determining whether spacing should be exploded.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double RelativeTolerance',
        summary: `Gets or sets the relative tolerance for the unrolling operation.
     Relative tolerance is used in the evaluation of intrinsic properties,
     such as computations "along" the surface or brep.In the current implementation, relative tolerance is used to decide
     if a surface is flat enough to try to unroll. That helps ease the scale dependency.
     The surface has to be linear in one direction within (length * RelativeTolerance)
     to be considered linear for that purpose. Otherwise smash will ignore that tolerance and
     unroll anything.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void AddFollowingGeometry(Curve curve)',
        summary: 'Adds a curve that should be unrolled along with the surface/brep.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'The curve.'
          }
        ]
      },
      {
        signature: 'void AddFollowingGeometry(IEnumerable<Curve> curves)',
        summary: 'Adds curves that should be unrolled along with the surface/brep.',
        since: 5,
        parameters: [
          {
            name: 'curves',
            summary: 'An array, a list or any enumerable set of curves.'
          }
        ]
      },
      {
        signature: 'void AddFollowingGeometry(IEnumerable<Point3d> points)',
        summary: 'Adds points that should be unrolled along with the surface/brep.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'An array, a list or any enumerable set of points.'
          }
        ]
      },
      {
        signature: 'void AddFollowingGeometry(IEnumerable<Point3d> dotLocations,IEnumerable<string> dotText)',
        summary: 'Adds text dots that should be unrolled along with the surface/brep.',
        since: 5,
        parameters: [
          {
            name: 'dotLocations',
            summary: 'An array, a list, or any enumerable set of dot locations.'
          },
          {
            name: 'dotText',
            summary: 'An array, a list, or any enumerable set of dot strings.'
          }
        ]
      },
      {
        signature: 'void AddFollowingGeometry(IEnumerable<TextDot> dots)',
        summary: 'Adds text dots that should be unrolled along with the surface/brep.',
        since: 5,
        parameters: [
          {
            name: 'dots',
            summary: 'An array, a list or any enumerable set of text dots.'
          }
        ]
      },
      {
        signature: 'void AddFollowingGeometry(Point point)',
        summary: 'Adds a point that should be unrolled along with the surface/brep.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          }
        ]
      },
      {
        signature: 'void AddFollowingGeometry(Point3d point)',
        summary: 'Adds a point that should be unrolled along with the surface/brep.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          }
        ]
      },
      {
        signature: 'void AddFollowingGeometry(Point3d dotLocation,string dotText)',
        summary: 'Adds a text dot that should be unrolled along with the surface/brep.',
        since: 5,
        parameters: [
          {
            name: 'dotLocation',
            summary: 'A dot point.'
          },
          {
            name: 'dotText',
            summary: 'A dot text.'
          }
        ]
      },
      {
        signature: 'void AddFollowingGeometry(TextDot dot)',
        summary: 'Adds a text dot that should be unrolled along with the surface/brep.',
        since: 5,
        parameters: [
          {
            name: 'dot',
            summary: 'A text dot.'
          }
        ]
      },
      {
        signature: 'int FollowingGeometryIndex(Curve curve)',
        summary: 'Given an unrolled curve, returns the index of the source, or following curve.',
        since: 6,
        parameters: [
          {
            name: 'curve',
            summary: 'An unrolled curve returned by Unroller.PerformUnroll.'
          }
        ],
        returns: 'The index of the curve added by Unroller.AddFollowingGeometry if successful, otherwise -1.'
      },
      {
        signature: 'int FollowingGeometryIndex(TextDot dot)',
        summary: 'Given an unrolled text dot, returns the index of the source, or following text dot.',
        since: 6,
        parameters: [
          {
            name: 'dot',
            summary: 'An unrolled text dot returned by Unroller.PerformUnroll.'
          }
        ],
        returns: 'The index of the text dot added by Unroller.AddFollowingGeometry if successful, otherwise -1.'
      },
      {
        signature: 'Brep[] PerformUnroll(Curve[] unrolledCurves,Point3d[] unrolledPoints,TextDot[] unrolledDots)',
        summary: 'Executes unrolling operations.',
        since: 5,
        parameters: [
          {
            name: 'unrolledCurves',
            summary: 'An array of unrolled curves is assigned during the call in this out parameter.'
          },
          {
            name: 'unrolledPoints',
            summary: 'An array of unrolled points is assigned during the call in this out parameter.'
          },
          {
            name: 'unrolledDots',
            summary: 'An array of unrolled text dots is assigned during the call in this out parameter.'
          }
        ],
        returns: 'An array of breps. This array can be empty.'
      },
      {
        signature: 'int PerformUnroll(List<Brep> flatbreps)',
        summary: 'Executes unrolling operations.',
        since: 6,
        parameters: [
          {
            name: 'flatbreps',
            summary: 'List of breps containg flattened results.'
          }
        ],
        returns: 'Number of breps in result'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Vector2d',
    dataType: 2,
    summary: `Represents the two components of a vector in two-dimensional space,
   using double-precision floating point numbers.`,
    constructors: [
      {
        signature: 'Vector2d(double x,double y)',
        summary: 'Initializes a new instance of the vector based on two, X and Y, components.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'The X (first) component.'
          },
          {
            name: 'y',
            summary: 'The Y (second) component.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Vector2d Unset',
        summary: 'Gets the value of the vector with components set as RhinoMath.UnsetValue,RhinoMath.UnsetValue.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Vector2d Zero',
        summary: 'Gets the value of the vector with components 0,0.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: `Gets a value indicating whether this vector is valid. 
     A valid vector must be formed of valid component values for x, y and z.`,
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'double Length',
        summary: `Computes the length (or magnitude, or size) of this vector.
     This is an application of Pythagoras' theorem.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double SquareLength',
        summary: 'Returns the square of the length of the vector.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'double X',
        summary: 'Gets or sets the X (first) component of this vector.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Y',
        summary: 'Gets or sets the Y (second) component of this vector.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Vector2d Add(Vector2d vector1,Vector2d vector2)',
        summary: `Sums up two vectors.
     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)`,
        since: 6,
        parameters: [
          {
            name: 'vector1',
            summary: 'A vector.'
          },
          {
            name: 'vector2',
            summary: 'A second vector.'
          }
        ],
        returns: 'A new vector that results from the componentwise addition of the two vectors.'
      },
      {
        signature: 'static Vector2d Divide(Vector2d vector,double t)',
        summary: `Divides a Vector2d by a number, having the effect of shrinking it.
     (Provided for languages that do not support operator overloading. You can use the / operator otherwise)`,
        since: 6,
        parameters: [
          {
            name: 'vector',
            summary: 'A vector.'
          },
          {
            name: 't',
            summary: 'A number.'
          }
        ],
        returns: 'A new vector that is componentwise divided by t.'
      },
      {
        signature: 'static Vector2d Multiply(double t,Vector2d vector)',
        summary: `Multiplies a vector by a number, having the effect of scaling it.
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 6,
        parameters: [
          {
            name: 't',
            summary: 'A number.'
          },
          {
            name: 'vector',
            summary: 'A vector.'
          }
        ],
        returns: 'A new vector that is the original vector coordinatewise multiplied by t.'
      },
      {
        signature: 'static Vector2d Multiply(Vector2d vector,double t)',
        summary: `Multiplies a vector by a number, having the effect of scaling it.
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 6,
        parameters: [
          {
            name: 'vector',
            summary: 'A vector.'
          },
          {
            name: 't',
            summary: 'A number.'
          }
        ],
        returns: 'A new vector that is the original vector coordinatewise multiplied by t.'
      },
      {
        signature: 'static double Multiply(Vector2d vector1,Vector2d vector2)',
        summary: `Multiplies two vectors together, returning the dot product (or inner product).
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 6,
        parameters: [
          {
            name: 'vector1',
            summary: 'A vector.'
          },
          {
            name: 'vector2',
            summary: 'A second vector.'
          }
        ],
        returns: `A value that results from the evaluation of v1.X*v2.X + v1.Y*v2.Y.
     This value equals v1.Length * v2.Length * cos(alpha), where alpha is the angle between vectors.`
      },
      {
        signature: 'static Vector2d Negate(Vector2d vector)',
        summary: `Computes the reversed vector.
     (Provided for languages that do not support operator overloading. You can use the - unary operator otherwise)`,
        since: 6,
        parameters: [
          {
            name: 'vector',
            summary: 'A vector to negate.'
          }
        ],
        returns: 'A new vector where all components were multiplied by -1.'
      },
      {
        signature: 'static Vector2d Subtract(Vector2d vector1,Vector2d vector2)',
        summary: `Subtracts the second vector from the first one.
     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)`,
        since: 6,
        parameters: [
          {
            name: 'vector1',
            summary: 'A vector.'
          },
          {
            name: 'vector2',
            summary: 'A second vector.'
          }
        ],
        returns: 'A new vector that results from the componentwise difference of vector1 - vector2.'
      },
      {
        signature: 'int CompareTo(Vector2d other)',
        summary: `Compares this Vector2d with another Vector2d.
     Components evaluation priority is first X, then Y.`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The other Vector2d to use in comparison.'
          }
        ],
        returns: '0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y+1: otherwise.'
      },
      {
        signature: 'bool EpsilonEquals(Vector2d other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines whether the specified System.Object is a Vector2d and has the same value as the present vector.',
        parameters: [
          {
            name: 'obj',
            summary: 'The specified object.'
          }
        ],
        returns: 'True if obj is Vector2d and has the same components as this; otherwise false.'
      },
      {
        signature: 'bool Equals(Vector2d vector)',
        summary: 'Determines whether the specified vector has the same value as the present vector.',
        since: 5,
        parameters: [
          {
            name: 'vector',
            summary: 'The specified vector.'
          }
        ],
        returns: 'True if vector has the same components as this; otherwise false.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Provides a hashing value for the present vector.',
        returns: 'A non-unique number based on vector components.'
      },
      {
        signature: 'bool IsTiny()',
        summary: 'Uses RhinoMath.ZeroTolerance for IsTiny calculation.',
        since: 6,
        returns: 'True if vector is very small, otherwise false.'
      },
      {
        signature: 'bool IsTiny(double tolerance)',
        summary: 'Determines whether a vector is very short.',
        since: 6,
        parameters: [
          {
            name: 'tolerance',
            summary: `A nonzero value used as the coordinate zero tolerance.
     .`
          }
        ],
        returns: '(Math.Abs(X) <= tiny_tol) AND (Math.Abs(Y) <= tiny_tol) AND (Math.Abs(Z) <= tiny_tol).'
      },
      {
        signature: 'bool Rotate(double angleRadians)',
        summary: 'Rotates this vector.',
        since: 6,
        parameters: [
          {
            name: 'angleRadians',
            summary: 'Angle of rotation (in radians).'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'string ToString()',
        summary: 'Constructs a string representation of the current vector.',
        returns: 'A string in the form X,Y.'
      },
      {
        signature: 'string ToString(string format,IFormatProvider formatProvider)',
        since: 7
      },
      {
        signature: 'bool Unitize()',
        summary: `Unitizes the vector in place. A unit vector has length 1 unit. 
     An invalid or zero length vector cannot be unitized.`,
        since: 5.7,
        returns: 'True on success or False on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Vector2f',
    dataType: 2,
    summary: `Represents the two components of a vector in two-dimensional space,
   using Single-precision floating point numbers.`,
    constructors: [
      {
        signature: 'Vector2f(float x,float y)',
        summary: 'Creates an instance.',
        since: 6,
        parameters: [
          {
            name: 'x',
            summary: 'X component.'
          },
          {
            name: 'y',
            summary: 'Y component.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool IsValid',
        summary: 'Returns an indication regarding the validity of this vector.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'float SquareLength',
        summary: `Returns the square of the length of this vector.
     This method does not check for the validity of its inputs.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'float X',
        summary: 'Gets or sets the X (first) component of this vector.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'float Y',
        summary: 'Gets or sets the Y (second) component of this vector.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static double Multiply(Vector2f point1,Vector2f point2)',
        summary: `Multiplies two Vector2f together, returning the dot (internal) product of the two.
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 6,
        parameters: [
          {
            name: 'point1',
            summary: 'The first point.'
          },
          {
            name: 'point2',
            summary: 'The second point.'
          }
        ],
        returns: 'A value that results from the coordinatewise multiplication of point1 and point2.'
      },
      {
        signature: 'int CompareTo(Vector2f other)',
        summary: `Compares this Vector2f with another Vector2f.
     Components evaluation priority is first X, then Y.`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The other Vector2f to use in comparison.'
          }
        ],
        returns: '0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y+1: otherwise.'
      },
      {
        signature: 'bool EpsilonEquals(Vector2f other,float epsilon)',
        summary: 'Check that all values in other are withing epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines whether the specified System.Object is a Vector2f and has the same values as the present vector.',
        parameters: [
          {
            name: 'obj',
            summary: 'The specified object.'
          }
        ],
        returns: 'True if obj is Vector2f and has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'bool Equals(Vector2f vector)',
        summary: 'Determines whether the specified vector has the same values as the present vector.',
        since: 5,
        parameters: [
          {
            name: 'vector',
            summary: 'The specified vector.'
          }
        ],
        returns: 'True if obj is Vector2f and has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Computes a hash number that represents the current vector.',
        returns: 'A hash code that is not unique for each vector.'
      },
      {
        signature: 'string ToString()',
        summary: 'Constructs the string representation of the current vector.',
        returns: 'The vector representation in the form X,Y,Z.'
      },
      {
        signature: 'string ToString(string format,IFormatProvider formatProvider)',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Vector3d',
    dataType: 2,
    summary: `Represents the three components of a vector in three-dimensional space,
   using double-precision floating point numbers.`,
    constructors: [
      {
        signature: 'Vector3d(double x,double y,double z)',
        summary: 'Initializes a new instance of a vector, using its three components.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'The X (first) component.'
          },
          {
            name: 'y',
            summary: 'The Y (second) component.'
          },
          {
            name: 'z',
            summary: 'The Z (third) component.'
          }
        ]
      },
      {
        signature: 'Vector3d(Point3d point)',
        summary: 'Initializes a new instance of a vector, copying the three components from the three coordinates of a point.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'The point to copy from.'
          }
        ]
      },
      {
        signature: 'Vector3d(Vector3d vector)',
        summary: 'Initializes a new instance of a vector, copying the three components from a vector.',
        since: 5,
        parameters: [
          {
            name: 'vector',
            summary: 'A double-precision vector.'
          }
        ]
      },
      {
        signature: 'Vector3d(Vector3f vector)',
        summary: 'Initializes a new instance of a vector, copying the three components from a single-precision vector.',
        since: 5,
        parameters: [
          {
            name: 'vector',
            summary: 'A single-precision vector.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Vector3d Unset',
        summary: 'Gets the value of the vector with each component set to RhinoMath.UnsetValue.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Vector3d XAxis',
        summary: 'Gets the value of the vector with components 1,0,0.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Vector3d YAxis',
        summary: 'Gets the value of the vector with components 0,1,0.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Vector3d ZAxis',
        summary: 'Gets the value of the vector with components 0,0,1.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Vector3d Zero',
        summary: 'Gets the value of the vector with components 0,0,0.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsUnitVector',
        summary: `Gets a value indicating whether or not this is a unit vector. 
     A unit vector has length 1.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: `Gets a value indicating whether this vector is valid. 
     A valid vector must be formed of valid component values for x, y and z.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsZero',
        summary: 'Gets a value indicating whether the X, Y, and Z values are all equal to 0.0.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Length',
        summary: `Computes the length (or magnitude, or size) of this vector.
     This is an application of Pythagoras' theorem.
     If this vector is invalid, its length is considered 0.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double MaximumCoordinate',
        summary: 'Gets the largest (both positive and negative) component value in this vector.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double MinimumCoordinate',
        summary: 'Gets the smallest (both positive and negative) component value in this vector.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double SquareLength',
        summary: `Computes the squared length (or magnitude, or size) of this vector.
     This is an application of Pythagoras' theorem.
     While the Length property checks for input validity,
     this property does not. You should check validity in advance,
     if this vector can be invalid.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'double X',
        summary: 'Gets or sets the X (first) component of the vector.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Y',
        summary: 'Gets or sets the Y (second) component of the vector.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Z',
        summary: 'Gets or sets the Z (third) component of the vector.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Vector3d Add(Vector3d vector1,Vector3d vector2)',
        summary: `Sums up two vectors.
     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'vector1',
            summary: 'A vector.'
          },
          {
            name: 'vector2',
            summary: 'A second vector.'
          }
        ],
        returns: 'A new vector that results from the componentwise addition of the two vectors.'
      },
      {
        signature: 'static bool AreOrthogonal(Vector3d x,Vector3d y,Vector3d z)',
        summary: `Test whether three vectors describe an orthogonal axis system.
     All vectors must be mutually perpendicular this to be the case.`,
        since: 6.7,
        parameters: [
          {
            name: 'x',
            summary: 'X axis vector.'
          },
          {
            name: 'y',
            summary: 'Y axis vector.'
          },
          {
            name: 'z',
            summary: 'Z axis vector.'
          }
        ],
        returns: 'True if all vectors are non-zero and mutually perpendicular.'
      },
      {
        signature: 'static bool AreOrthonormal(Vector3d x,Vector3d y,Vector3d z)',
        summary: `Test whether three vectors describe an orthogonal, unit axis system.
     All vectors must be mutually perpendicular and have unit length for this to be the case.`,
        since: 6.7,
        parameters: [
          {
            name: 'x',
            summary: 'X axis vector.'
          },
          {
            name: 'y',
            summary: 'Y axis vector.'
          },
          {
            name: 'z',
            summary: 'Z axis vector.'
          }
        ],
        returns: 'True if all vectors are non-zero and mutually perpendicular.'
      },
      {
        signature: 'static bool AreRighthanded(Vector3d x,Vector3d y,Vector3d z)',
        summary: `Test whether three vectors describe a right-handed, orthogonal, unit axis system.
     The vectors must be orthonormal and follow the right-hand ordering; index-finger=x,
     middle-finger=y, thumb=z.`,
        since: 6.7,
        parameters: [
          {
            name: 'x',
            summary: 'X axis vector.'
          },
          {
            name: 'y',
            summary: 'Y axis vector.'
          },
          {
            name: 'z',
            summary: 'Z axis vector.'
          }
        ],
        returns: 'True if all vectors are non-zero and mutually perpendicular.'
      },
      {
        signature: 'static Vector3d CrossProduct(Vector3d a,Vector3d b)',
        summary: `Computes the cross product (or vector product, or exterior product) of two vectors.
     This operation is not commutative.`,
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'First vector.'
          },
          {
            name: 'b',
            summary: 'Second vector.'
          }
        ],
        returns: `A new vector that is perpendicular to both a and b,
     has Length == a.Length * b.Length * sin(theta) where theta is the angle between a and b.The resulting vector is oriented according to the right hand rule.`
      },
      {
        signature: 'static Vector3d Divide(Vector3d vector,double t)',
        summary: `Divides a Vector3d by a number, having the effect of shrinking it.
     (Provided for languages that do not support operator overloading. You can use the / operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'vector',
            summary: 'A vector.'
          },
          {
            name: 't',
            summary: 'A number.'
          }
        ],
        returns: 'A new vector that is componentwise divided by t.'
      },
      {
        signature: 'static Vector3d Multiply(double t,Vector3d vector)',
        summary: `Multiplies a vector by a number, having the effect of scaling it.
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'A number.'
          },
          {
            name: 'vector',
            summary: 'A vector.'
          }
        ],
        returns: 'A new vector that is the original vector coordinatewise multiplied by t.'
      },
      {
        signature: 'static Vector3d Multiply(Vector3d vector,double t)',
        summary: `Multiplies a vector by a number, having the effect of scaling it.
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'vector',
            summary: 'A vector.'
          },
          {
            name: 't',
            summary: 'A number.'
          }
        ],
        returns: 'A new vector that is the original vector coordinatewise multiplied by t.'
      },
      {
        signature: 'static double Multiply(Vector3d vector1,Vector3d vector2)',
        summary: `Multiplies two vectors together, returning the dot product (or inner product).
     This differs from the cross product.
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'vector1',
            summary: 'A vector.'
          },
          {
            name: 'vector2',
            summary: 'A second vector.'
          }
        ],
        returns: `A value that results from the evaluation of v1.X*v2.X + v1.Y*v2.Y + v1.Z*v2.Z.
     This value equals v1.Length * v2.Length * cos(alpha), where alpha is the angle between vectors.`
      },
      {
        signature: 'static Vector3d Negate(Vector3d vector)',
        summary: `Computes the reversed vector.
     (Provided for languages that do not support operator overloading. You can use the - unary operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'vector',
            summary: 'A vector to negate.'
          }
        ],
        returns: 'A new vector where all components were multiplied by -1.'
      },
      {
        signature: 'static Vector3d Subtract(Vector3d vector1,Vector3d vector2)',
        summary: `Subtracts the second vector from the first one.
     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'vector1',
            summary: 'A vector.'
          },
          {
            name: 'vector2',
            summary: 'A second vector.'
          }
        ],
        returns: 'A new vector that results from the componentwise difference of vector1 - vector2.'
      },
      {
        signature: 'static double VectorAngle(Vector3d a,Vector3d b)',
        summary: `Compute the angle between two vectors.
     This operation is commutative.`,
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'First vector for angle.'
          },
          {
            name: 'b',
            summary: 'Second vector for angle.'
          }
        ],
        returns: 'If the input is valid, the angle (in radians) between a and b; RhinoMath.UnsetValue otherwise.'
      },
      {
        signature: 'static double VectorAngle(Vector3d a,Vector3d b,Plane plane)',
        summary: 'Computes the angle on a plane between two vectors.',
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'First vector.'
          },
          {
            name: 'b',
            summary: 'Second vector.'
          },
          {
            name: 'plane',
            summary: 'Two-dimensional plane on which to perform the angle measurement.'
          }
        ],
        returns: 'On success, the angle (in radians) between a and b as projected onto the plane; RhinoMath.UnsetValue on failure.'
      },
      {
        signature: 'static double VectorAngle(Vector3d v1,Vector3d v2,Vector3d vNormal)',
        summary: 'Computes the angle of v1, v2 with a normal vector.',
        since: 6,
        parameters: [
          {
            name: 'v1',
            summary: 'First vector.'
          },
          {
            name: 'v2',
            summary: 'Second vector.'
          },
          {
            name: 'vNormal',
            summary: 'Normal vector.'
          }
        ],
        returns: 'On success, the angle (in radians) between a and b with respect of normal vector; RhinoMath.UnsetValue on failure.'
      },
      {
        signature: 'int CompareTo(Vector3d other)',
        summary: `Compares this Vector3d with another Vector3d.
     Component evaluation priority is first X, then Y, then Z.`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The other Vector3d to use in comparison.'
          }
        ],
        returns: '0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y-1: if this.X == other.X and this.Y == other.Y and this.Z < other.Z+1: otherwise.'
      },
      {
        signature: 'bool EpsilonEquals(Vector3d other,double epsilon)',
        summary: 'Check that all values in other are within epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines whether the specified System.Object is a Vector3d and has the same values as the present vector.',
        parameters: [
          {
            name: 'obj',
            summary: 'The specified object.'
          }
        ],
        returns: 'True if obj is a Vector3d and has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'bool Equals(Vector3d vector)',
        summary: 'Determines whether the specified vector has the same value as the present vector.',
        since: 5,
        parameters: [
          {
            name: 'vector',
            summary: 'The specified vector.'
          }
        ],
        returns: 'True if vector has the same coordinates as this; otherwise false.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Computes the hash code for the current vector.',
        returns: 'A non-unique number that represents the components of this vector.'
      },
      {
        signature: 'int IsParallelTo(Vector3d other)',
        summary: 'Determines whether this vector is parallel to another vector, within one degree (within Pi / 180).',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Vector to use for comparison.'
          }
        ],
        returns: `Parallel indicator:
     +1 = both vectors are parallel 0 = vectors are not parallel, or at least one of the vectors is zero-1 = vectors are anti-parallel.`
      },
      {
        signature: 'int IsParallelTo(Vector3d other,double angleTolerance)',
        summary: 'Determines whether this vector is parallel to another vector, within a provided tolerance.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Vector to use for comparison.'
          },
          {
            name: 'angleTolerance',
            summary: 'Angle tolerance (in radians).'
          }
        ],
        returns: `Parallel indicator:
     +1 = both vectors are parallel.0 = vectors are not parallel or at least one of the vectors is zero.-1 = vectors are anti-parallel.`
      },
      {
        signature: 'bool IsPerpendicularTo(Vector3d other)',
        summary: 'Test to see whether this vector is perpendicular to within one degree of another one.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Vector to compare to.'
          }
        ],
        returns: 'True if both vectors are perpendicular, False if otherwise.'
      },
      {
        signature: 'bool IsPerpendicularTo(Vector3d other,double angleTolerance)',
        summary: 'Determines whether this vector is perpendicular to another vector, within a provided angle tolerance.',
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Vector to use for comparison.'
          },
          {
            name: 'angleTolerance',
            summary: 'Angle tolerance (in radians).'
          }
        ],
        returns: 'True if vectors form Pi-radians (90-degree) angles with each other; otherwise false.'
      },
      {
        signature: 'bool IsTiny()',
        summary: 'Uses RhinoMath.ZeroTolerance for IsTiny calculation.',
        since: 5,
        returns: 'True if vector is very small, otherwise false.'
      },
      {
        signature: 'bool IsTiny(double tolerance)',
        summary: 'Determines whether a vector is very short.',
        since: 5,
        parameters: [
          {
            name: 'tolerance',
            summary: `A nonzero value used as the coordinate zero tolerance.
     .`
          }
        ],
        returns: '(Math.Abs(X) <= tiny_tol) AND (Math.Abs(Y) <= tiny_tol) AND (Math.Abs(Z) <= tiny_tol).'
      },
      {
        signature: 'bool PerpendicularTo(Vector3d other)',
        summary: `Sets this vector to be perpendicular to another vector. 
     Result is not unitized.`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Vector to use as guide.'
          }
        ],
        returns: 'True on success, False if input vector is zero or invalid.'
      },
      {
        signature: 'bool Reverse()',
        summary: `Reverses this vector in place (reverses the direction).
     If this vector is Invalid, no changes will occur and False will be returned.`,
        since: 5,
        returns: 'True on success or False if the vector is invalid.'
      },
      {
        signature: 'bool Rotate(double angleRadians,Vector3d rotationAxis)',
        summary: 'Rotates this vector around a given axis.',
        since: 5,
        parameters: [
          {
            name: 'angleRadians',
            summary: 'Angle of rotation (in radians).'
          },
          {
            name: 'rotationAxis',
            summary: 'Axis of rotation.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'string ToString()',
        summary: 'Returns the string representation of the current vector, in the form X,Y,Z.',
        returns: 'A string with the current location of the point.'
      },
      {
        signature: 'string ToString(string format,IFormatProvider formatProvider)',
        since: 7
      },
      {
        signature: 'void Transform(Transform transformation)',
        summary: `Transforms the vector in place.
     The transformation matrix acts on the left of the vector; i.e.,result = transformation*vector`,
        since: 5,
        parameters: [
          {
            name: 'transformation',
            summary: 'Transformation matrix to apply.'
          }
        ]
      },
      {
        signature: 'bool Unitize()',
        summary: `Unitizes the vector in place. A unit vector has length 1 unit. 
     An invalid or zero length vector cannot be unitized.`,
        since: 5,
        returns: 'True on success or False on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'Vector3f',
    dataType: 2,
    summary: `Represents the three components of a vector in three-dimensional space,
   using Single-precision floating point numbers.`,
    constructors: [
      {
        signature: 'Vector3f(float x,float y,float z)',
        summary: 'Constructs a new vector from 3 single precision numbers.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'X component of vector.'
          },
          {
            name: 'y',
            summary: 'Y component of vector.'
          },
          {
            name: 'z',
            summary: 'Z component of vector.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static Vector3f Unset',
        summary: 'Gets the value of the vector with each component set to RhinoMath.UnsetValue.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Vector3f XAxis',
        summary: 'Gets the value of the vector with components 1,0,0.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Vector3f YAxis',
        summary: 'Gets the value of the vector with components 0,1,0.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Vector3f ZAxis',
        summary: 'Gets the value of the vector with components 0,0,1.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Vector3f Zero',
        summary: 'Gets the value of the vector with components 0,0,0.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsUnitVector',
        summary: `Gets a value indicating whether or not this is a unit vector. 
     A unit vector has length 1.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: 'Returns an indication regarding the validity of this vector.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsZero',
        summary: 'Gets a value indicating whether the X, Y, and Z values are all equal to 0.0.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'float Length',
        summary: `Computes the length (or magnitude, or size) of this vector.
     This is an application of Pythagoras' theorem.
     If this vector is invalid, its length is considered 0.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'float SquareLength',
        summary: `Returns the square length of the vector.
     This property does not check for the validity of the inputs.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'float X',
        summary: 'Gets or sets the X (first) component of this vector.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'float Y',
        summary: 'Gets or sets the Y (second) component of this vector.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'float Z',
        summary: 'Gets or sets the Z (third) component of this vector.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static Point3f Add(Point3f point,Vector3f vector)',
        summary: `Sums up a point and a vector, and returns a new point.
     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          },
          {
            name: 'vector',
            summary: 'A vector.'
          }
        ],
        returns: 'A new point that results from the addition of point and vector.'
      },
      {
        signature: 'static Vector3f Add(Vector3f vector1,Vector3f vector2)',
        summary: `Sums up two vectors.
     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)`,
        since: 6,
        parameters: [
          {
            name: 'vector1',
            summary: 'A vector.'
          },
          {
            name: 'vector2',
            summary: 'A second vector.'
          }
        ],
        returns: 'A new vector that results from the componentwise addition of the two vectors.'
      },
      {
        signature: 'static Vector3f CrossProduct(Vector3f a,Vector3f b)',
        summary: `Computes the cross product (or vector product, or exterior product) of two vectors.
     This operation is not commutative.`,
        since: 5,
        parameters: [
          {
            name: 'a',
            summary: 'First vector.'
          },
          {
            name: 'b',
            summary: 'Second vector.'
          }
        ],
        returns: `A new vector that is perpendicular to both a and b,
     has Length == a.Length * b.Length andwith a result that is oriented following the right hand rule.`
      },
      {
        signature: 'static Vector3f Divide(Vector3f vector,double t)',
        summary: `Divides a Vector3f by a number, having the effect of shrinking it, t times.
     (Provided for languages that do not support operator overloading. You can use the / operator otherwise)`,
        since: 6,
        parameters: [
          {
            name: 'vector',
            summary: 'A vector.'
          },
          {
            name: 't',
            summary: 'A number.'
          }
        ],
        returns: 'A new vector that is componentwise divided by t.'
      },
      {
        signature: 'static Vector3f Divide(Vector3f vector,float t)',
        summary: `Divides a Vector3f by a number, having the effect of shrinking it, t times.
     (Provided for languages that do not support operator overloading. You can use the / operator otherwise)`,
        since: 6,
        parameters: [
          {
            name: 'vector',
            summary: 'A vector.'
          },
          {
            name: 't',
            summary: 'A number.'
          }
        ],
        returns: 'A new vector that is componentwise divided by t.'
      },
      {
        signature: 'static Vector3f Multiply(float t,Vector3f vector)',
        summary: `Multiplies a vector by a number, having the effect of scaling it.
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 't',
            summary: 'A number.'
          },
          {
            name: 'vector',
            summary: 'A vector.'
          }
        ],
        returns: 'A new vector that is the original vector coordinatewise multiplied by t.'
      },
      {
        signature: 'static Vector3f Multiply(Vector3f vector,float t)',
        summary: `Multiplies a vector by a number, having the effect of scaling it.
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 5,
        parameters: [
          {
            name: 'vector',
            summary: 'A vector.'
          },
          {
            name: 't',
            summary: 'A number.'
          }
        ],
        returns: 'A new vector that is the original vector coordinatewise multiplied by t.'
      },
      {
        signature: 'static double Multiply(Vector3f point1,Vector3f point2)',
        summary: `Multiplies two Vector3f together, returning the dot (internal) product of the two.
     This is not the cross product.
     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)`,
        since: 6,
        parameters: [
          {
            name: 'point1',
            summary: 'The first point.'
          },
          {
            name: 'point2',
            summary: 'The second point.'
          }
        ],
        returns: 'A value that results from the coordinatewise multiplication of point1 and point2.'
      },
      {
        signature: 'static Vector3f Negate(Vector3f vector)',
        summary: `Computes the reversed vector.
     (Provided for languages that do not support operator overloading. You can use the - unary operator otherwise)`,
        since: 6,
        parameters: [
          {
            name: 'vector',
            summary: 'A vector to negate.'
          }
        ],
        returns: 'A new vector where all components were multiplied by -1.'
      },
      {
        signature: 'static Vector3f Subtract(Vector3f vector1,Vector3f vector2)',
        summary: `Subtracts the second vector from the first one.
     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)`,
        since: 6,
        parameters: [
          {
            name: 'vector1',
            summary: 'A vector.'
          },
          {
            name: 'vector2',
            summary: 'A second vector.'
          }
        ],
        returns: 'A new vector that results from the componentwise difference of vector1 - vector2.'
      },
      {
        signature: 'int CompareTo(Vector3f other)',
        summary: `Compares this Vector3f with another Vector3f.
     Component evaluation priority is first X, then Y, then Z.`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'The other Vector3f to use in comparison.'
          }
        ],
        returns: '0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y-1: if this.X == other.X and this.Y == other.Y and this.Z < other.Z+1: otherwise.'
      },
      {
        signature: 'bool EpsilonEquals(Vector3f other,float epsilon)',
        summary: 'Check that all values in other are withing epsilon of the values in this',
        since: 5.4
      },
      {
        signature: 'bool Equals(object obj)',
        summary: 'Determines whether the specified System.Object is a Vector3f and has the same values as the present vector.',
        parameters: [
          {
            name: 'obj',
            summary: 'The specified object.'
          }
        ],
        returns: 'True if obj is Vector3f and has the same components as this; otherwise false.'
      },
      {
        signature: 'bool Equals(Vector3f vector)',
        summary: 'Determines whether the specified vector has the same values as the present vector.',
        since: 5,
        parameters: [
          {
            name: 'vector',
            summary: 'The specified vector.'
          }
        ],
        returns: 'True if vector has the same components as this; otherwise false.'
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Computes a hash number that represents the current vector.',
        returns: 'A hash code that is not unique for each vector.'
      },
      {
        signature: 'bool PerpendicularTo(Vector3f other)',
        summary: `Sets this vector to be perpendicular to another vector. 
     Result is not unitized.`,
        since: 5,
        parameters: [
          {
            name: 'other',
            summary: 'Vector to use as guide.'
          }
        ],
        returns: 'True on success, False if input vector is zero or invalid.'
      },
      {
        signature: 'bool Reverse()',
        summary: `Reverses this vector in place (reverses the direction).
     If this vector contains RhinoMath.UnsetValue, the 
     reverse will also be invalid and False will be returned.`,
        since: 5,
        returns: 'True on success or False if the vector is invalid.'
      },
      {
        signature: 'bool Rotate(double angleRadians,Vector3f rotationAxis)',
        summary: 'Rotates this vector around a given axis.',
        since: 5,
        parameters: [
          {
            name: 'angleRadians',
            summary: 'Angle of rotation (in radians).'
          },
          {
            name: 'rotationAxis',
            summary: 'Axis of rotation.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'string ToString()',
        summary: 'Constructs the string representation of the current vector.',
        returns: 'The vector representation in the form X,Y,Z.'
      },
      {
        signature: 'string ToString(string format,IFormatProvider formatProvider)',
        since: 7
      },
      {
        signature: 'void Transform(Transform transformation)',
        summary: `Transforms the vector in place.
     The transformation matrix acts on the left of the vector; i.e.,result = transformation*vector`,
        since: 5,
        parameters: [
          {
            name: 'transformation',
            summary: 'Transformation matrix to apply.'
          }
        ]
      },
      {
        signature: 'bool Unitize()',
        summary: `Unitizes the vector in place. A unit vector has length 1 unit. 
     An invalid or zero length vector cannot be unitized.`,
        since: 5,
        returns: 'True on success or False on failure.'
      }
    ]
  },
  {
    namespace: 'Rhino.Geometry',
    name: 'VolumeMassProperties',
    dataType: 1,
    summary: `Contains static initialization methods and allows access to the computed
   metrics of volume, volume centroid and volume moments in 
   in solid meshes, in solid surfaces and in solid (closed) boundary representations.`,
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'Point3d Centroid',
        summary: 'Gets the volume centroid in the world coordinate system.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CentroidCoordinatesMomentsOfInertia',
        summary: `Moments of inertia with respect to centroid coordinate system.
     X = integral of ((y-y0)^2 + (z-z0)^2) dm
     Y = integral of ((z-z0)^2 + (x-x0)^2) dm
     Z = integral of ((z-z0)^2 + (y-y0)^2) dm
     where (x0,y0,z0) = centroid.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CentroidCoordinatesMomentsOfInertiaError',
        summary: 'Uncertainty in centroid coordinates moments of inertia calculation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CentroidCoordinatesRadiiOfGyration',
        summary: `Radii of gyration with respect to centroid coordinate system.
     X = sqrt(integral of ((y-y0)^2 + (z-z0)^2) dm/M)
     Y = sqrt(integral of ((z-z0)^2 + (x-x0)^2) dm/M)
     Z = sqrt(integral of ((z-z0)^2 + (y-y0)^2) dm/M)
     where (x0,y0,z0) = centroid.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CentroidCoordinatesSecondMoments',
        summary: `Second moments with respect to centroid coordinate system.
     X = integral of (x-x0)^2 dm
     Y = integral of (y-y0)^2 dm
     Z = integral of (z-z0)^2 dm
     where (x0,y0,z0) = centroid.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CentroidCoordinatesSecondMomentsError',
        summary: 'Uncertainty in centroid coordinates second moments calculation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d CentroidError',
        summary: 'Gets the uncertainty in the Centroid calculation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Volume',
        summary: 'Gets the volume solution.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double VolumeError',
        summary: 'Gets the uncertainty in the volume calculation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesFirstMoments',
        summary: `Returns the world coordinate first moments if they were able to be calculated.
     X is integral of "x dm" over the volume
     Y is integral of "y dm" over the volume
     Z is integral of "z dm" over the volume.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesFirstMomentsError',
        summary: 'Uncertainty in world coordinates first moments calculation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesMomentsOfInertia',
        summary: `The moments of inertia about the world coordinate axes.
     X = integral of (y^2 + z^2) dm
     Y = integral of (z^2 + x^2) dm
     Z = integral of (z^2 + y^2) dm.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesMomentsOfInertiaError',
        summary: 'Uncertainty in world coordinates moments of inertia calculation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesProductMoments',
        summary: `Returns the world coordinate product moments if they were able to be calculated.
     X is integral of "xy dm" over the area
     Y is integral of "yz dm" over the area
     Z is integral of "zx dm" over the area.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesProductMomentsError',
        summary: 'Uncertainty in world coordinates second moments calculation.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesRadiiOfGyration',
        summary: `Radii of gyration with respect to world coordinate system.
     X = sqrt(integral of (y^2 + z^2) dm/M)
     Y = sqrt(integral of (z^2 + x^2) dm/M)
     Z = sqrt(integral of (z^2 + y^2) dm/M)`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesSecondMoments',
        summary: `Returns the world coordinate first moments if they were able to be calculated.
     X is integral of "xx dm" over the area
     Y is integral of "yy dm" over the area
     Z is integral of "zz dm" over the area.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Vector3d WorldCoordinatesSecondMomentsError',
        summary: 'Uncertainty in world coordinates second moments calculation.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static VolumeMassProperties Compute(Brep brep)',
        summary: 'Compute the VolumeMassProperties for a single Brep.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'Brep to measure.'
          }
        ],
        returns: 'The VolumeMassProperties for the given Brep or None on failure.'
      },
      {
        signature: 'static VolumeMassProperties Compute(Brep brep,bool volume,bool firstMoments,bool secondMoments,bool productMoments)',
        summary: 'Compute the VolumeMassProperties for a single Brep.',
        since: 6.3,
        parameters: [
          {
            name: 'brep',
            summary: 'Brep to measure.'
          },
          {
            name: 'volume',
            summary: 'True to calculate volume.'
          },
          {
            name: 'firstMoments',
            summary: 'True to calculate volume first moments, volume, and volume centroid.'
          },
          {
            name: 'secondMoments',
            summary: 'True to calculate volume second moments.'
          },
          {
            name: 'productMoments',
            summary: 'True to calculate volume product moments.'
          }
        ],
        returns: 'The VolumeMassProperties for the given Brep or None on failure.'
      },
      {
        signature: 'static VolumeMassProperties Compute(IEnumerable<GeometryBase> geometry)',
        summary: `Computes the VolumeMassProperties for a collection of geometric objects. 
     At present only Breps, Surfaces, and Meshes are supported.`,
        since: 6.3,
        parameters: [
          {
            name: 'geometry',
            summary: 'Objects to include in the area computation.'
          }
        ],
        returns: 'The VolumeMassProperties for the entire collection or None on failure.'
      },
      {
        signature: 'static VolumeMassProperties Compute(IEnumerable<GeometryBase> geometry,bool volume,bool firstMoments,bool secondMoments,bool productMoments)',
        summary: `Computes the VolumeMassProperties for a collection of geometric objects. 
     At present only Breps, Surfaces, Meshes and Planar Closed Curves are supported.`,
        since: 6.3,
        parameters: [
          {
            name: 'geometry',
            summary: 'Objects to include in the area computation.'
          },
          {
            name: 'volume',
            summary: 'True to calculate volume.'
          },
          {
            name: 'firstMoments',
            summary: 'True to calculate volume first moments, volume, and volume centroid.'
          },
          {
            name: 'secondMoments',
            summary: 'True to calculate volume second moments.'
          },
          {
            name: 'productMoments',
            summary: 'True to calculate volume product moments.'
          }
        ],
        returns: 'The VolumeMassProperties for the entire collection or None on failure.'
      },
      {
        signature: 'static VolumeMassProperties Compute(Mesh mesh)',
        summary: 'Compute the VolumeMassProperties for a single Mesh.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh to measure.'
          }
        ],
        returns: 'The VolumeMassProperties for the given Mesh or None on failure.'
      },
      {
        signature: 'static VolumeMassProperties Compute(Mesh mesh,bool volume,bool firstMoments,bool secondMoments,bool productMoments)',
        summary: 'Compute the VolumeMassProperties for a single Mesh.',
        since: 6.3,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh to measure.'
          },
          {
            name: 'volume',
            summary: 'True to calculate volume.'
          },
          {
            name: 'firstMoments',
            summary: 'True to calculate volume first moments, volume, and volume centroid.'
          },
          {
            name: 'secondMoments',
            summary: 'True to calculate volume second moments.'
          },
          {
            name: 'productMoments',
            summary: 'True to calculate volume product moments.'
          }
        ],
        returns: 'The VolumeMassProperties for the given Mesh or None on failure.'
      },
      {
        signature: 'static VolumeMassProperties Compute(Surface surface)',
        summary: 'Compute the VolumeMassProperties for a single Surface.',
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'Surface to measure.'
          }
        ],
        returns: 'The VolumeMassProperties for the given Surface or None on failure.'
      },
      {
        signature: 'static VolumeMassProperties Compute(Surface surface,bool volume,bool firstMoments,bool secondMoments,bool productMoments)',
        summary: 'Compute the VolumeMassProperties for a single Surface.',
        since: 6.3,
        parameters: [
          {
            name: 'surface',
            summary: 'Surface to measure.'
          },
          {
            name: 'volume',
            summary: 'True to calculate volume.'
          },
          {
            name: 'firstMoments',
            summary: 'True to calculate volume first moments, volume, and volume centroid.'
          },
          {
            name: 'secondMoments',
            summary: 'True to calculate volume second moments.'
          },
          {
            name: 'productMoments',
            summary: 'True to calculate volume product moments.'
          }
        ],
        returns: 'The VolumeMassProperties for the given Surface or None on failure.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'bool Sum(VolumeMassProperties summand)',
        summary: 'Sum mass properties together to get an aggregate mass.',
        since: 5,
        parameters: [
          {
            name: 'summand',
            summary: 'mass properties to add.'
          }
        ],
        returns: 'True if successful.'
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'IEpsilonComparable',
    dataType: 4
  },
  {
    namespace: 'Rhino',
    name: 'IEpsilonFComparable',
    dataType: 4
  },
  {
    namespace: 'Rhino',
    name: 'IndexPair',
    dataType: 2,
    summary: 'Represents two indices: I and J.',
    constructors: [
      {
        signature: 'IndexPair(int i,int j)',
        summary: 'Initializes a new instance of IndexPair with two indices.',
        since: 5,
        parameters: [
          {
            name: 'i',
            summary: 'A first index.'
          },
          {
            name: 'j',
            summary: 'A second index.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Returns the amount of elements in this pair of indices, which is always 2.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int I',
        summary: 'Gets or sets the first, I index.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int J',
        summary: 'Gets or sets the second, J index.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'bool Contains(int item)',
        summary: 'Determines whether the IndexPair contains a specific value.',
        since: 6,
        parameters: [
          {
            name: 'item',
            summary: 'The number to locate in the IndexPair.'
          }
        ],
        returns: 'True if  is found in the IndexPair; otherwise, false.'
      },
      {
        signature: 'void CopyTo(int[] array,int arrayIndex)',
        summary: 'Copies the elements of the IndexPair to an T:System.Array, starting at a particular T:System.Array index.',
        since: 6,
        parameters: [
          {
            name: 'array',
            summary: `The one-dimensional T:System.Array that is the destination of the elements copied
     from IndexPair.
     The T:System.Array must have zero-based indexing.`
          },
          {
            name: 'arrayIndex',
            summary: 'The zero-based index in  at which copying begins.'
          }
        ]
      },
      {
        signature: 'IEnumerator<int> GetEnumerator()',
        summary: 'Gets an enumerator that goes over I and J, in this order.',
        since: 6,
        returns: 'The needed enumerator.'
      },
      {
        signature: 'int IndexOf(int item)',
        summary: 'Determines the index of a specific item in IndexPair.',
        since: 6,
        parameters: [
          {
            name: 'item',
            summary: 'The object to locate in the T:System.Collections.Generic.IList`1.'
          }
        ],
        returns: 'The index, 0 for I or 1 for J of  if found in the list; otherwise, -1.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'CommandLineOption',
    dataType: 1,
    properties: [
      {
        signature: 'int CurrentListOptionIndex',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string EnglishName',
        summary: 'The English command option name',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Index',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string LocalName',
        summary: 'The localized command option name',
        since: 6.24,
        property: ['get']
      },
      {
        signature: 'string StringOptionValue',
        summary: 'Assigned by RhinoGet.Get if an option value is specified in a script or by a command window control.',
        since: 6.24,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static bool IsValidOptionName(string optionName)',
        summary: 'Test a string to see if it can be used as an option name in any of the RhinoGet::AddCommandOption...() functions.',
        since: 5,
        parameters: [
          {
            name: 'optionName',
            summary: 'The string to be tested.'
          }
        ],
        returns: 'True if string can be used as an option name.'
      },
      {
        signature: 'static bool IsValidOptionValueName(string optionValue)',
        summary: `Test a string to see if it can be used as an option value in RhinoGet::AddCommandOption,
     RhinoGet::AddCommandOptionToggle, or RhinoGet::AddCommandOptionList.`,
        since: 5,
        parameters: [
          {
            name: 'optionValue',
            summary: 'The string to be tested.'
          }
        ],
        returns: 'True if string can be used as an option value.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'ConeConstraint',
    dataType: 3,
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'Vertical = 1'
      },
      {
        signature: 'AroundCurve = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'CylinderConstraint',
    dataType: 3,
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'Vertical = 1'
      },
      {
        signature: 'AroundCurve = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GeometryAttributeFilter',
    dataType: 3,
    summary: `If an object passes the geometry TYPE filter, then the geometry ATTRIBUTE
   filter is applied.`,
    values: [
      {
        signature: 'WireCurve = 1<<0',
        summary: `3d wire curve
     If you want to accept only wire or edge curves, then
     specify wire_curve or edge_curve, otherwise both wire
     and edge curves will pass the attribute filter.`
      },
      {
        signature: 'EdgeCurve = 1 << 1',
        summary: `3d curve of a surface edge
     If you want to accept only wire or edge curves, then
     specify wire_curve or edge_curve, otherwise both wire
     and edge curves will pass the attribute filter.`
      },
      {
        signature: 'ClosedCurve = 1<<2',
        summary: `Closed Curves and Edges are acceptable
     If you want to accept only closed or open curves, then
     specify either closed_curve or open_curve.  Otherwise both
     closed and open curves will pass the attribute filter.`
      },
      {
        signature: 'OpenCurve = 1 << 3',
        summary: `Open Curves and Edges are acceptable
     If you want to accept only closed or open curves, then
     specify either closed_curve or open_curve.  Otherwise both
     closed and open curves will pass the attribute filter.`
      },
      {
        signature: 'SeamEdge = 1<<4',
        summary: `seam edges are acceptable
     attributes of acceptable trimming edge objects (associated with an ON_BrepTrim).
    
     If none of these attributes are explicitly specified, then
     any kind of trimming edge will pass the attribute filter.`
      },
      {
        signature: 'ManifoldEdge = 1 << 5',
        summary: `edges with 2 different surfaces pass
     attributes of acceptable trimming edge objects (associated with an ON_BrepTrim).
    
     If none of these attributes are explicitly specified, then
     any kind of trimming edge will pass the attribute filter.`
      },
      {
        signature: 'NonmanifoldEdge = 1 << 6',
        summary: `edges with 3 or more surfaces pass
     attributes of acceptable trimming edge objects (associated with an ON_BrepTrim).
    
     If none of these attributes are explicitly specified, then
     any kind of trimming edge will pass the attribute filter.`
      },
      {
        signature: 'MatedEdge = (1 << 4) | (1 << 5) | (1 << 6)',
        summary: `any mated edge passes
     attributes of acceptable trimming edge objects (associated with an ON_BrepTrim).
    
     If none of these attributes are explicitly specified, then
     any kind of trimming edge will pass the attribute filter.`
      },
      {
        signature: 'SurfaceBoundaryEdge = 1 << 7',
        summary: `boundary edges on surface sides pass
     attributes of acceptable trimming edge objects (associated with an ON_BrepTrim).
    
     If none of these attributes are explicitly specified, then
     any kind of trimming edge will pass the attribute filter.`
      },
      {
        signature: 'TrimmingBoundaryEdge = 1 << 8',
        summary: `boundary edges that trim a surface pass
     attributes of acceptable trimming edge objects (associated with an ON_BrepTrim).
    
     If none of these attributes are explicitly specified, then
     any kind of trimming edge will pass the attribute filter.`
      },
      {
        signature: 'BoundaryEdge = (1 << 7) | (1 << 8)',
        summary: `ant boundary edge passes
     attributes of acceptable trimming edge objects (associated with an ON_BrepTrim).
    
     If none of these attributes are explicitly specified, then
     any kind of trimming edge will pass the attribute filter.`
      },
      {
        signature: 'ClosedSurface = 1 << 9',
        summary: `If you want to accept only closed or open surfaces, then
     specify either closed_surface or open_surface.  Otherwise both
     closed and open surfaces will pass the attribute filter.`
      },
      {
        signature: 'OpenSurface = 1 << 10',
        summary: `If you want to accept only closed or open surfaces, then
     specify either closed_surface or open_surface.  Otherwise both
     closed and open surfaces will pass the attribute filter.`
      },
      {
        signature: 'TrimmedSurface = 1 << 11',
        summary: `If you want to accept only trimmed or untrimmed surfaces, then
     specify either trimmed_surface or untrimmed_surface.  Otherwise
     both trimmed and untrimmed surfaces will pass the attribute filter.`
      },
      {
        signature: 'UntrimmedSurface = 1 << 12',
        summary: `If you want to accept only trimmed or untrimmed surfaces, then
     specify either trimmed_surface or untrimmed_surface.  Otherwise
     both trimmed and untrimmed surfaces will pass the attribute filter.`
      },
      {
        signature: 'SubSurface = 1 << 13',
        summary: `If you want to accept only sub-surfaces of (multi-surface)
     polysrf, then specify sub_surface.  If you do not want to
     accept sub-surfaces, then specify top_surface.  Otherwise
     sub-surfaces and top surfaces will pass the attribute filter.`
      },
      {
        signature: 'TopSurface = 1 << 14',
        summary: `If you want to accept only sub-surfaces of (multi-surface)
     polysrf, then specify sub_surface.  If you do not want to
     accept sub-surfaces, then specify top_surface.  Otherwise
     sub-surfaces and top surfaces will pass the attribute filter.`
      },
      {
        signature: 'ManifoldPolysrf = 1 << 15',
        summary: `If you want to accept only manifold or nonmanifold polysrfs,
     then specify manifold_polysrf or nonmanifold_polysrf. Otherwise
     both manifold and nonmanifold polysrfs will pass the attribute
     filter.`
      },
      {
        signature: 'NonmanifoldPolysrf = 1 << 16',
        summary: `If you want to accept only manifold or nonmanifold polysrfs,
     then specify manifold_polysrf or nonmanifold_polysrf. Otherwise
     both manifold and nonmanifold polysrfs will pass the attribute
     filter.`
      },
      {
        signature: 'ClosedPolysrf = 1 << 17',
        summary: `If you want to accept only closed or open polysrfs, then
     specify either closed_polysrf or open_polysrf.  Otherwise both
     closed and open polysrfs will pass the attribute filter.`
      },
      {
        signature: 'OpenPolysrf = 1 << 18',
        summary: `If you want to accept only closed or open polysrfs, then
     specify either closed_polysrf or open_polysrf.  Otherwise both
     closed and open polysrfs will pass the attribute filter.`
      },
      {
        signature: 'ClosedMesh = 1 << 19',
        summary: `If you want to accept only closed or open meshs, then
     specify either closed_mesh or open_mesh.  Otherwise both
     closed and open meshs will pass the attribute filter.`
      },
      {
        signature: 'OpenMesh = 1 << 20',
        summary: `If you want to accept only closed or open meshs, then
     specify either closed_mesh or open_mesh.  Otherwise both
     closed and open meshs will pass the attribute filter.`
      },
      {
        signature: 'BoundaryInnerLoop = 1 << 21',
        summary: 'all trimming edges are boundary edges.'
      },
      {
        signature: 'MatedInnerLoop = 1 << 22',
        summary: 'all trimming edges are mated.'
      },
      {
        signature: 'InnerLoop = (1 << 21) | (1 << 22)',
        summary: 'any inner loop is acceptable.'
      },
      {
        signature: 'BoundaryOuterLoop = 1 << 23',
        summary: 'all trimming edges are boundary edges.'
      },
      {
        signature: 'MatedOuterLoop = 1 << 24',
        summary: 'all trimming edges are mated.'
      },
      {
        signature: 'OuterLoop = (1 << 23) | (1 << 24)',
        summary: 'any outer loop is acceptable.'
      },
      {
        signature: 'SpecialLoop = (1 << 25)',
        summary: 'slit, crvonsrf, ptonsrf, etc.'
      },
      {
        signature: 'AcceptAllAttributes = 0xffffffff'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetArc',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'GetArc()',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'bool AllowDeformable',
        summary: 'Allow for deformable options',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double DefaultRadius',
        summary: 'Default radius used for start and end radius',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool Deformable',
        summary: 'Is the deformable option set',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int DeformableDegree',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int DeformablePointCount',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      },
      {
        signature: 'Commands.Result Get(Arc arc)',
        summary: 'Perform the \'get\' operation.',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetBaseClass',
    dataType: 1,
    summary: `Base class for GetObject, GetPoint, GetSphere, etc.
   
   You will never directly create a GetBaseClass but you will use its member
   functions after calling GetObject.Gets(), GetPoint.Get(), and so on.
   
   Provides tools to set command prompt, set command options, and specify
   if the "get" can optionally accept numbers, nothing (pressing enter),
   and undo.`,
    interfaces: ['IDisposable'],
    methods: [
      {
        signature: 'static void PostCustomMessage(object messageData)',
        since: 5
      },
      {
        signature: 'void AcceptColor(bool enable)',
        summary: `If you want to allow the user to be able to type in a color r,g,b or name
     during GetPoint.Get(), GetObject::GetObjects(), etc., then call AcceptColor(true)
     before calling GetPoint()/GetObject(). If the user chooses to type in a color,
     then the result code GetResult.Color is returned and you can use RhinoGet.Color()
     to get the value of the color.  If the get accepts points, then the user will not
     be able to type in r,g,b colors but will be able to type color names.`,
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'True if user is able to type a color.'
          }
        ]
      },
      {
        signature: 'void AcceptCustomMessage(bool enable)',
        since: 5
      },
      {
        signature: 'void AcceptEnterWhenDone(bool enable)',
        summary: `There are instances of RhinoGet that prompt with "Press Enter when Done." yet do not call AcceptNothing().
     On the Mac, these instances need an additional call to AcceptEnterWhenDone() so the GetPointOptions dialog
     can correctly enable the Done button.`,
        since: 6
      },
      {
        signature: 'void AcceptNothing(bool enable)',
        summary: `If you want to allow the user to be able to press enter in order to
     skip selecting a something in GetPoint.Get(), GetObject::GetObjects(),
     etc., then call AcceptNothing( True ) beforehand.`,
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'True if user is able to press enter in order to skip selecting.'
          }
        ]
      },
      {
        signature: 'void AcceptNumber(bool enable,bool acceptZero)',
        summary: `If you want to allow the user to be able to type in a number during GetPoint.Get(),
     GetObject::GetObjects(), etc., then call AcceptNumber() beforehand.
     If the user chooses to type in a number, then the result code GetResult.Number is
     returned and you can use RhinoGet.Number() to get the value of the number. If you
     are using GetPoint and you want "0" to return (0,0,0) instead of the number zero, 
     then set acceptZero = false.`,
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'True if user is able to type a number.'
          },
          {
            name: 'acceptZero',
            summary: `If you are using GetPoint and you want "0" to return (0,0,0) instead of the number zero, 
     then set acceptZero = false.`
          }
        ]
      },
      {
        signature: 'void AcceptPoint(bool enable)',
        summary: `If you want to allow the user to be able to type in a point then call AcceptPoint(true)
     before calling GetPoint()/GetObject(). If the user chooses to type in a number, then
     the result code GetResult.Point is returned and you can use RhinoGet.Point()
     to get the value of the point.`,
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'True if user is able to type in a point.'
          }
        ]
      },
      {
        signature: 'void AcceptString(bool enable)',
        summary: `If you want to allow the user to be able to type in a string during GetPoint.Get(),
     GetObject::GetObjects(), etc., then call AcceptString(true) before calling
     GetPoint()/GetObject(). If the user chooses to type in a string, then the result code
     GetResult.String is returned and you can use RhinoGet.String() to get the value of the string.`,
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'True if user is able to type a string.'
          }
        ]
      },
      {
        signature: 'void AcceptUndo(bool enable)',
        summary: `If you want to allow the user to have an 'undo' option in GetPoint.Get(),
     GetObject.GetObjects(), etc., then call AcceptUndo(true) beforehand.`,
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'True if user is able to choose the \'Undo\' option.'
          }
        ]
      },
      {
        signature: 'int AddOption(LocalizeStringPair optionName)',
        summary: 'Adds a command line option.',
        since: 5,
        parameters: [
          {
            name: 'optionName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes).'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOption(LocalizeStringPair optionName,LocalizeStringPair optionValue)',
        summary: 'Adds a command line option.',
        since: 5,
        parameters: [
          {
            name: 'optionName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes).'
          },
          {
            name: 'optionValue',
            summary: 'The localized value visualized after an equality sign.'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOption(LocalizeStringPair optionName,LocalizeStringPair optionValue,bool hiddenOption)',
        summary: 'Adds a command line option.',
        since: 6.9,
        parameters: [
          {
            name: 'optionName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes).'
          },
          {
            name: 'optionValue',
            summary: 'The localized value visualized after an equality sign.'
          },
          {
            name: 'hiddenOption',
            summary: 'If true, the option is not displayed on the command line and the full option name must be typed in order to activate the option.'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOption(string englishOption)',
        summary: 'Adds a command line option.',
        since: 5,
        parameters: [
          {
            name: 'englishOption',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes).'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOption(string englishOption,string englishOptionValue)',
        summary: 'Adds a command line option.',
        since: 5,
        parameters: [
          {
            name: 'englishOption',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes).'
          },
          {
            name: 'englishOptionValue',
            summary: 'The option value in English, visualized after an equality sign.'
          }
        ],
        returns: 'Option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOption(string englishOption,string englishOptionValue,bool hiddenOption)',
        summary: 'Adds a command line option.',
        since: 6.9,
        parameters: [
          {
            name: 'englishOption',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes).'
          },
          {
            name: 'englishOptionValue',
            summary: 'The option value in English, visualized after an equality sign.'
          },
          {
            name: 'hiddenOption',
            summary: 'If true, the option is not displayed on the command line and the full option name must be typed in order to activate the option.'
          }
        ],
        returns: 'Option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionColor(LocalizeStringPair optionName,OptionColor colorValue)',
        summary: 'Add a command line option to get colors and automatically save the value.',
        since: 5,
        parameters: [
          {
            name: 'optionName',
            summary: 'option description'
          },
          {
            name: 'colorValue',
            summary: 'The current color value.'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionColor(LocalizeStringPair optionName,OptionColor colorValue,string prompt)',
        summary: 'Add a command line option to get colors and automatically save the value.',
        since: 5,
        parameters: [
          {
            name: 'optionName',
            summary: 'option description.'
          },
          {
            name: 'colorValue',
            summary: 'The current color value.'
          },
          {
            name: 'prompt',
            summary: 'option prompt shown if the user selects this option'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionColor(string englishName,OptionColor colorValue)',
        summary: 'Add a command line option to get colors and automatically save the value.',
        since: 5,
        parameters: [
          {
            name: 'englishName',
            summary: 'option description'
          },
          {
            name: 'colorValue',
            summary: 'The current color value.'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionColor(string englishName,OptionColor colorValue,string prompt)',
        summary: 'Add a command line option to get colors and automatically save the value.',
        since: 5,
        parameters: [
          {
            name: 'englishName',
            summary: 'option description'
          },
          {
            name: 'colorValue',
            summary: 'The current color value.'
          },
          {
            name: 'prompt',
            summary: 'The command prompt will show this during picking.'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionDouble(LocalizeStringPair optionName,OptionDouble numberValue)',
        summary: 'Adds a command line option to get numbers and automatically save the value.',
        since: 5,
        parameters: [
          {
            name: 'optionName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes)'
          },
          {
            name: 'numberValue',
            summary: 'The current number value.'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionDouble(LocalizeStringPair optionName,OptionDouble numberValue,string prompt)',
        summary: 'Adds a command line option to get numbers and automatically saves the value.',
        since: 5,
        parameters: [
          {
            name: 'optionName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes)'
          },
          {
            name: 'numberValue',
            summary: 'The current number value.'
          },
          {
            name: 'prompt',
            summary: `option prompt shown if the user selects this option.  If None or empty, then the
     option name is used as the get number prompt.`
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionDouble(string englishName,OptionDouble numberValue)',
        summary: 'Adds a command line option to get numbers and automatically save the value.',
        since: 5,
        parameters: [
          {
            name: 'englishName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes)'
          },
          {
            name: 'numberValue',
            summary: 'The current number value.'
          }
        ],
        returns: 'Option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionDouble(string englishName,OptionDouble numberValue,string prompt)',
        summary: 'Adds a command line option to get numbers and automatically save the value.',
        since: 5,
        parameters: [
          {
            name: 'englishName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes)'
          },
          {
            name: 'numberValue',
            summary: 'Current value.'
          },
          {
            name: 'prompt',
            summary: `option prompt shown if the user selects this option.  If None or empty, then the
     option name is used as the get number prompt.`
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionEnumList(string englishOptionName,T defaultValue)',
        summary: 'Adds a choice of enum values as list option',
        since: 5.4,
        parameters: [
          {
            name: 'englishOptionName',
            summary: 'The name of the option'
          },
          {
            name: 'defaultValue',
            summary: 'The default value'
          }
        ],
        returns: 'Option index'
      },
      {
        signature: 'int AddOptionEnumList(string englishOptionName,T defaultValue,T[] include)',
        summary: 'Adds a choice of enum values as list option. Allows to include only some enum values.',
        since: 6,
        parameters: [
          {
            name: 'englishOptionName',
            summary: 'The name of the option'
          },
          {
            name: 'defaultValue',
            summary: 'The default value'
          },
          {
            name: 'include',
            summary: 'An array of enum values to use. This argument can also be null; in this case, the whole enum is used.'
          }
        ],
        returns: 'Option index'
      },
      {
        signature: 'int AddOptionEnumSelectionList(string englishOptionName,IEnumerable<T> enumSelection,int listCurrentIndex)',
        summary: 'Adds a list of enum values as option list. Use enumSelection[go.Option.CurrentListOptionIndex] to retrieve selection.',
        since: 5.4
      },
      {
        signature: 'int AddOptionInteger(LocalizeStringPair optionName,OptionInteger intValue)',
        summary: 'Adds a command line option to get integers and automatically save the value.',
        since: 5,
        parameters: [
          {
            name: 'optionName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes)'
          },
          {
            name: 'intValue',
            summary: 'The current integer value.'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionInteger(LocalizeStringPair optionName,OptionInteger intValue,string prompt)',
        summary: 'Adds a command line option to get integers and automatically save the value.',
        since: 5,
        parameters: [
          {
            name: 'optionName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes)'
          },
          {
            name: 'intValue',
            summary: 'The current integer value.'
          },
          {
            name: 'prompt',
            summary: `option prompt shown if the user selects this option.  If None or empty, then the
     option name is used as the get number prompt.`
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionInteger(string englishName,OptionInteger intValue)',
        summary: 'Adds a command line option to get integers and automatically save the value.',
        since: 5,
        parameters: [
          {
            name: 'englishName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes)'
          },
          {
            name: 'intValue',
            summary: 'The current integer value.'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionInteger(string englishName,OptionInteger intValue,string prompt)',
        summary: 'Adds a command line option to get integers and automatically save the value.',
        since: 5,
        parameters: [
          {
            name: 'englishName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes)'
          },
          {
            name: 'intValue',
            summary: 'The current integer value.'
          },
          {
            name: 'prompt',
            summary: `option prompt shown if the user selects this option.  If None or empty, then the
     option name is used as the get number prompt.`
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionList(LocalizeStringPair optionName,IEnumerable<LocalizeStringPair> listValues,int listCurrentIndex)',
        summary: 'Adds a command line list option.',
        since: 5,
        parameters: [
          {
            name: 'optionName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes)'
          },
          {
            name: 'listValues',
            summary: 'The string values.'
          },
          {
            name: 'listCurrentIndex',
            summary: 'Zero based index of current option.'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionList(string englishOptionName,IEnumerable<string> listValues,int listCurrentIndex)',
        summary: 'Adds a command line list option.',
        since: 5,
        parameters: [
          {
            name: 'englishOptionName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes)'
          },
          {
            name: 'listValues',
            summary: 'The string values.'
          },
          {
            name: 'listCurrentIndex',
            summary: 'Zero based index of current option.'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionToggle(LocalizeStringPair optionName,OptionToggle toggleValue)',
        summary: 'Adds a command line option to toggle a setting.',
        since: 5,
        parameters: [
          {
            name: 'optionName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes)'
          },
          {
            name: 'toggleValue',
            summary: 'The current toggle value.'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'int AddOptionToggle(string englishName,OptionToggle toggleValue)',
        summary: 'Adds a command line option to toggle a setting.',
        since: 5,
        parameters: [
          {
            name: 'englishName',
            summary: 'Must only consist of letters and numbers (no characters list periods, spaces, or dashes)'
          },
          {
            name: 'toggleValue',
            summary: 'The current toggle value.'
          }
        ],
        returns: 'option index value (>0) or 0 if option cannot be added.'
      },
      {
        signature: 'void ClearCommandOptions()',
        summary: 'Clear all command options.',
        since: 5
      },
      {
        signature: 'void ClearDefault()',
        summary: 'Clears any defaults set using SetDefaultPoint, SetDefaultNumber, SetDefaultString, or SetCommandPromptDefault.',
        since: 5
      },
      {
        signature: 'Color Color()',
        summary: 'Gets a color if Get*() returns GetResult.Color.',
        since: 5,
        returns: 'The color chosen by the user.'
      },
      {
        signature: 'Result CommandResult()',
        summary: 'Helper method for getting command result value from getter results.',
        since: 5,
        returns: 'The converted command result.'
      },
      {
        signature: 'object CustomMessage()',
        since: 5
      },
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'void EnableTransparentCommands(bool enable)',
        summary: 'Control the availability of transparent commands during the get.',
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: `If true, then transparent commands can be run during the get.
     If false, then transparent commands cannot be run during the get.`
          }
        ]
      },
      {
        signature: 'T GetSelectedEnumValue()',
        summary: `Returns the selected enum value. Use this in combination with AddOptionEnumList{T}(string, T).
     This must be called directly after having called a Get method, and having obtained a  value.`,
        since: 5.4
      },
      {
        signature: 'T GetSelectedEnumValueFromSelectionList(IEnumerable<T> selectionList)',
        summary: `Returns the selected enum value by looking at the list of values from which to select.
     Use this in combination with AddOptionEnumSelectionList{T}`,
        since: 5.4
      },
      {
        signature: 'bool GotDefault()',
        summary: `Returns True if user pressed Enter to accept a default point, number,
     or string set using SetDefaultPoint, SetDefaultNumber, or SetDefaultString.`,
        since: 5,
        returns: 'True if the result if the default point, number or string set. Otherwise, false.'
      },
      {
        signature: 'System.Drawing.Point[] Line2d()',
        summary: `Returns two points defining the location in the view window of the 2d line selected
     in GetPoint::Get2dLine().
     (0,0) = upper left corner of window.`,
        since: 5,
        returns: 'An array with two 2D points.'
      },
      {
        signature: 'double Number()',
        summary: 'Gets a number if GetPoint.Get(), GetObject.GetObjects(), etc., returns GetResult.Number.',
        since: 5,
        returns: 'The number chosen by the user.'
      },
      {
        signature: 'CommandLineOption Option()',
        since: 5
      },
      {
        signature: 'int OptionIndex()',
        since: 5
      },
      {
        signature: 'Rectangle PickRectangle()',
        summary: `If the get was a GetObjects() and the mouse was used to select the objects,
     then the returned rect has left < right and top < bottom. This rect
     is the Windows GDI screen coordinates of the picking rectangle.
     RhinoViewport.GetPickXform( pick_rect, pick_xform )
     will calculate the picking transformation that was used.
     In all other cases, left=right=top=bottom=0;`,
        since: 5,
        returns: 'The picking rectangle; or 0 in the specified cases.'
      },
      {
        signature: 'Point3d Point()',
        summary: 'Gets a point if Get*() returns GetResult.Point.',
        since: 5,
        returns: 'The point chosen by the user.'
      },
      {
        signature: 'System.Drawing.Point Point2d()',
        summary: `Returns location in view of point in selected in GetPoint::Get() or GetPoint::Get2dPoint().
     (0,0) = upper left corner of window.`,
        since: 5,
        returns: 'The location.'
      },
      {
        signature: 'Rectangle Rectangle2d()',
        summary: `Returns the location in the view of the 2d rectangle selected in GetPoint::Get2dRectangle().
     rect.left < rect.right and rect.top < rect.bottom
     (0,0) = upper left corner of window.`,
        since: 5,
        returns: 'The rectangle.'
      },
      {
        signature: 'GetResult Result()',
        summary: 'Returns result of the Get*() call.',
        since: 5,
        returns: 'The result of the last Get*() call.'
      },
      {
        signature: 'void SetCommandPrompt(string prompt)',
        summary: 'Sets prompt message that appears in the command prompt window.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'command prompt message.'
          }
        ]
      },
      {
        signature: 'void SetCommandPromptDefault(string defaultValue)',
        summary: `Sets message that describes what default value will be used if the user presses enter.
     This description appears in angle brackets <> in the command prompt window. You do
     not need to provide a default value description unless you explicity enable AcceptNothing.`,
        since: 5,
        parameters: [
          {
            name: 'defaultValue',
            summary: 'description of default value.'
          }
        ]
      },
      {
        signature: 'void SetDefaultColor(Color defaultColor)',
        summary: 'Sets a color as default value that will be returned if the user presses ENTER key during the get.',
        since: 5,
        parameters: [
          {
            name: 'defaultColor',
            summary: 'value for default color.'
          }
        ]
      },
      {
        signature: 'void SetDefaultInteger(int defaultValue)',
        summary: 'Sets a number as default value that will be returned if the user presses ENTER key during the get.',
        since: 5,
        parameters: [
          {
            name: 'defaultValue',
            summary: 'value for default number.'
          }
        ]
      },
      {
        signature: 'void SetDefaultNumber(double defaultNumber)',
        summary: 'Sets a number as default value that will be returned if the user presses ENTER key during the get.',
        since: 5,
        parameters: [
          {
            name: 'defaultNumber',
            summary: 'value for default number.'
          }
        ]
      },
      {
        signature: 'void SetDefaultPoint(Point3d point)',
        summary: 'Sets a point as default value that will be returned if the user presses the ENTER key during the get.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'value for default point.'
          }
        ]
      },
      {
        signature: 'void SetDefaultString(string defaultValue)',
        summary: `Sets a string as default value that will be returned
     if the user presses ENTER key during the get.`,
        since: 5,
        parameters: [
          {
            name: 'defaultValue',
            summary: 'value for default string.'
          }
        ]
      },
      {
        signature: 'void SetWaitDuration(int milliseconds)',
        summary: `Sets the wait duration (in milliseconds) of the getter. If the duration passes without 
     the user making a decision, the GetResult.Timeout code is returned.`,
        since: 5,
        parameters: [
          {
            name: 'milliseconds',
            summary: 'Number of milliseconds to wait.'
          }
        ]
      },
      {
        signature: 'string StringResult()',
        summary: 'Gets a string if GetPoint.Get(), GetObject.GetObjects(), etc., returns GetResult.String.',
        since: 5,
        returns: 'The string chosen by the user.'
      },
      {
        signature: 'Vector3d Vector()',
        summary: 'Gets a direction if Get*() returns GetResult.Point (Set by some digitizers, but in general it\'s (0,0,0).',
        since: 5,
        returns: 'The vector chosen by the user.'
      },
      {
        signature: 'RhinoView View()',
        summary: 'Gets a view the user clicked in during GetPoint.Get(), GetObject.GetObjects(), etc.',
        since: 5,
        returns: 'The view chosen by the user.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetCancel',
    dataType: 1,
    baseclass: 'Rhino.Input.Custom.GetBaseClass',
    constructors: [
      {
        signature: 'GetCancel()',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IProgress<double> Progress',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string ProgressMessage',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ProgressReporting',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'CancellationToken Token',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Result Wait(Task task,RhinoDoc doc)',
        summary: 'Awaits a particular task to finish.',
        since: 7,
        parameters: [
          {
            name: 'task',
            summary: 'The task.'
          },
          {
            name: 'doc',
            summary: 'A document to set progress reporting.'
          }
        ],
        returns: 'A result enumeration.'
      },
      {
        signature: 'Result Wait(Task<TResult> task,RhinoDoc doc)',
        summary: 'Awaits a particular task to finish.',
        since: 6,
        parameters: [
          {
            name: 'task',
            summary: 'The task.'
          },
          {
            name: 'doc',
            summary: 'A document to set progress reporting.'
          }
        ],
        returns: 'A result enumeration.'
      },
      {
        signature: 'Result WaitAll(IEnumerable<Task<TResult>> tasks,RhinoDoc doc)',
        summary: 'Awaits some tasks to finish.',
        parameters: [
          {
            name: 'tasks',
            summary: 'The tasks.'
          },
          {
            name: 'doc',
            summary: 'A document to set progress reporting.'
          }
        ],
        returns: 'A result enumeration.'
      },
      {
        signature: 'Result WaitAll(IEnumerable<Task> tasks,RhinoDoc doc)',
        summary: 'Awaits some tasks to finish.',
        since: 7,
        parameters: [
          {
            name: 'tasks',
            summary: 'The tasks.'
          },
          {
            name: 'doc',
            summary: 'A document to set progress reporting.'
          }
        ],
        returns: 'A result enumeration.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetCircle',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'GetCircle()',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'bool AllowDeformable',
        summary: 'Allow for deformable options',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double DefaultSize',
        summary: 'Default radius or diameter (based on InDiameterMode)',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool Deformable',
        summary: 'Is the deformable option set',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int DeformableDegree',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int DeformablePointCount',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool InDiameterMode',
        summary: 'Determines if the "size" value is reperesenting a radius or diameter',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      },
      {
        signature: 'Commands.Result Get(Circle circle)',
        summary: 'Perform the \'get\' operation.',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetCone',
    dataType: 1,
    summary: 'Class provides user interface to define a cone.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'GetCone()',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'bool AllowInputAngle',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double ApexAngleDegrees',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double BaseAngleDegrees',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool Cap',
        summary: 'Gets or sets whether or not the output should be capped.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ConeConstraint ConeConstraint',
        summary: `State of the cone/cyl constraint option. When the cone/cyl option is
     selected, the circle is being made as a base for a cone/cyl.
     By default the vertical cone/cyl option not available but is not
     selected.  By default the "Vertical" option applies to VerticalCircle.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double DefaultSize',
        summary: 'Default radius or diameter (based on InDiameterMode)',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double Height',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool InDiameterMode',
        summary: 'Determines if the "size" value is reperesenting a radius or diameter',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      },
      {
        signature: 'Commands.Result Get(Cone cone)',
        summary: 'Prompt for the getting of a cone.',
        since: 6,
        parameters: [
          {
            name: 'cone',
            summary: 'The cone geometry defined by the user.'
          }
        ],
        returns: 'The result of the getting operation.'
      },
      {
        signature: 'Commands.Result GetMesh(int verticalFaces,int aroundFaces,Cone cone)',
        summary: 'Prompt for the getting of a mesh cone.',
        since: 7,
        parameters: [
          {
            name: 'verticalFaces',
            summary: 'The number of faces in the vertical direction.'
          },
          {
            name: 'aroundFaces',
            summary: 'The number of faces in the around direction'
          },
          {
            name: 'cone',
            summary: 'The cone geometry defined by the user.'
          }
        ],
        returns: 'The result of the getting operation.'
      },
      {
        signature: 'Commands.Result GetMesh(int verticalFaces,int aroundFaces,int capStyle,Cone cone)',
        summary: 'Prompt for the getting of a mesh cone.',
        since: 7,
        parameters: [
          {
            name: 'verticalFaces',
            summary: 'The number of faces in the vertical direction.'
          },
          {
            name: 'aroundFaces',
            summary: 'The number of faces in the around direction'
          },
          {
            name: 'capStyle',
            summary: 'Set to 0 if you don\'t want the prompt, 3 is tris, 4 is quads.'
          },
          {
            name: 'cone',
            summary: 'The cone geometry defined by the user.'
          }
        ],
        returns: 'The result of the getting operation.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetCylinder',
    dataType: 1,
    summary: 'Class provides user interface to define a cylinder.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'GetCylinder()',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'bool BothSidesOption',
        summary: 'Determine if the "both sides" option is enabled',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool Cap',
        summary: 'Gets or sets whether or not the output should be capped.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'CylinderConstraint CylinderConstraint',
        summary: `State of the cone/cyl constraint option. When the cone/cyl option is
     selected, the circle is being made as a base for a cone/cyl.
     By default the vertical cone/cyl option not available but is not
     selected.  By default the "Vertical" option applies to VerticalCircle.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double DefaultSize',
        summary: 'Default radius or diameter (based on InDiameterMode)',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double Height',
        summary: 'Height of cylinder',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool InDiameterMode',
        summary: 'Determines if the "size" value is reperesenting a radius or diameter',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      },
      {
        signature: 'Commands.Result Get(Cylinder cylinder)',
        summary: 'Prompt for the getting of a cylinder.',
        since: 6,
        parameters: [
          {
            name: 'cylinder',
            summary: 'The cylinder geometry defined by the user.'
          }
        ],
        returns: 'The result of the getting operation.'
      },
      {
        signature: 'Commands.Result GetMesh(int verticalFaces,int aroundFaces,Cylinder cylinder)',
        summary: 'Prompt for the getting of a mesh cylinder.',
        since: 7,
        parameters: [
          {
            name: 'verticalFaces',
            summary: 'The number of faces in the vertical direction.'
          },
          {
            name: 'aroundFaces',
            summary: 'The number of faces in the around direction'
          },
          {
            name: 'cylinder',
            summary: 'The cylinder geometry defined by the user.'
          }
        ],
        returns: 'The result of the getting operation.'
      },
      {
        signature: 'Commands.Result GetMesh(int verticalFaces,int aroundFaces,int capStyle,Cylinder cylinder)',
        summary: 'Prompt for the getting of a mesh cylinder.',
        since: 7,
        parameters: [
          {
            name: 'verticalFaces',
            summary: 'The number of faces in the vertical direction.'
          },
          {
            name: 'aroundFaces',
            summary: 'The number of faces in the around direction'
          },
          {
            name: 'capStyle',
            summary: 'Set to 0 if you don\'t want the prompt, 3 is tris, 4 is quads.'
          },
          {
            name: 'cylinder',
            summary: 'The cylinder geometry defined by the user.'
          }
        ],
        returns: 'The result of the getting operation.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetEllipsoid',
    dataType: 1,
    summary: 'Class provides user interface to define a truncated cone.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'GetEllipsoid()',
        since: 7
      }
    ],
    properties: [
      {
        signature: 'Point3d FirstPoint',
        summary: 'Returns the first point. If in "from foci" mode, then this is the first foci point.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'bool IsModeFromFoci',
        summary: 'Indicates the ellipsoid was created from foci.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'bool MarkFoci',
        summary: 'Indicates the user wants the ellipsoid foci marked with point objects.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d SecondPoint',
        summary: 'Returns the second point. If in "from foci" mode, then this is the second foci point.',
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 7
      },
      {
        signature: 'Commands.Result Get(NurbsSurface ellipsoid)',
        summary: 'Prompt for the getting of a ellipsoid.',
        since: 7,
        parameters: [
          {
            name: 'ellipsoid',
            summary: 'The truncated cone in NURB form.'
          }
        ],
        returns: 'The result of the getting operation.'
      },
      {
        signature: 'Commands.Result GetMesh(int verticalFaces,int aroundFaces,bool quadCaps,Mesh ellipsoid)',
        summary: 'Prompt for the getting of a mesh ellipsoid.',
        since: 7,
        parameters: [
          {
            name: 'verticalFaces',
            summary: 'The number of faces in the vertical direction.'
          },
          {
            name: 'aroundFaces',
            summary: 'The number of faces in the around direction'
          },
          {
            name: 'quadCaps',
            summary: 'Set True to create quad faces at the caps, False for triangles.'
          },
          {
            name: 'ellipsoid',
            summary: 'The ellipsoid in Mesh form.'
          }
        ],
        returns: 'The result of the getting operation.'
      },
      {
        signature: 'Commands.Result GetMesh(int verticalFaces,int aroundFaces,Mesh ellipsoid)',
        summary: 'Prompt for the getting of a mesh ellipsoid.',
        since: 7,
        parameters: [
          {
            name: 'verticalFaces',
            summary: 'The number of faces in the vertical direction.'
          },
          {
            name: 'aroundFaces',
            summary: 'The number of faces in the around direction'
          },
          {
            name: 'ellipsoid',
            summary: 'The ellipsoid in Mesh form.'
          }
        ],
        returns: 'The result of the getting operation.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetFileNameMode',
    dataType: 3,
    values: [
      {
        signature: 'Open = 0'
      },
      {
        signature: 'OpenTemplate = 1'
      },
      {
        signature: 'OpenImage = 2'
      },
      {
        signature: 'OpenRhinoOnly = 3'
      },
      {
        signature: 'OpenTextFile = 5'
      },
      {
        signature: 'OpenWorksession = 6'
      },
      {
        signature: 'Import = 7'
      },
      {
        signature: 'Attach = 8'
      },
      {
        signature: 'LoadPlugIn = 9'
      },
      {
        signature: 'Save = 10'
      },
      {
        signature: 'SaveSmall = 11'
      },
      {
        signature: 'SaveTemplate = 12'
      },
      {
        signature: 'SaveImage = 13'
      },
      {
        signature: 'Export = 14'
      },
      {
        signature: 'SaveTextFile = 17'
      },
      {
        signature: 'SaveWorksession = 18'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetInteger',
    dataType: 1,
    summary: 'Used to get integer numbers.',
    baseclass: 'Rhino.Input.Custom.GetBaseClass',
    constructors: [
      {
        signature: 'GetInteger()',
        since: 5
      }
    ],
    methods: [
      {
        signature: 'GetResult Get()',
        summary: 'Call to get an integer.',
        since: 5,
        returns: 'If the user chose a number, then GetResult.Number; another enumeration value otherwise.'
      },
      {
        signature: 'int Number()',
        since: 5
      },
      {
        signature: 'void SetLowerLimit(int lowerLimit,bool strictlyGreaterThan)',
        summary: `Sets a lower limit on the number that can be returned.
     By default there is no lower limit.`,
        since: 5,
        parameters: [
          {
            name: 'lowerLimit',
            summary: 'smallest acceptable number.'
          },
          {
            name: 'strictlyGreaterThan',
            summary: 'If true, then the returned number will be > lower_limit.'
          }
        ]
      },
      {
        signature: 'void SetUpperLimit(int upperLimit,bool strictlyLessThan)',
        summary: `Sets an upper limit on the number that can be returned.
     By default there is no upper limit.`,
        since: 5,
        parameters: [
          {
            name: 'upperLimit',
            summary: 'largest acceptable number.'
          },
          {
            name: 'strictlyLessThan',
            summary: 'If true, then the returned number will be < upper_limit.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetLine',
    dataType: 1,
    summary: 'Use to interactively get a line.  The Rhino "Line" command uses GetLine.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'GetLine()',
        since: 5.1
      }
    ],
    properties: [
      {
        signature: 'bool AcceptZeroLengthLine',
        summary: `Controls whether or not a zero length line is acceptable.
     The default is to require the user to keep picking the end
     point until we get a point different than the start point.`,
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Color FeedbackColor',
        summary: `If set, the feedback color is used to draw the dynamic
     line when the second point is begin picked.  If not set,
     the active layer color is used.`,
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'string FirstPointPrompt',
        summary: 'Prompt when getting first point',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'double FixedLength',
        summary: 'If FixedLength > 0, the line must have the specified length',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'GetLineMode GetLineMode',
        summary: 'Mode used',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool HaveFeedbackColor',
        summary: `If true, the feedback color is used to draw the dynamic
     line when the second point is begin picked.  If false,
     the active layer color is used.`,
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'string MidPointPrompt',
        summary: 'Prompt when getting midpoint',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'string SecondPointPrompt',
        summary: 'Prompt when getting second point',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5.1
      },
      {
        signature: 'void EnableAllVariations(bool on)',
        summary: 'If true, then all line variations are shown if the default line mode is used',
        since: 5.1
      },
      {
        signature: 'void EnableFromBothSidesOption(bool on)',
        summary: `If true, then the "BothSides" option shows up when the
     start point is inteactively picked.`,
        since: 5.1
      },
      {
        signature: 'void EnableFromMidPointOption(bool on)',
        summary: 'If true, the the "MidPoint" options shows up',
        since: 5.1
      },
      {
        signature: 'Commands.Result Get(Line line)',
        summary: 'Perform the \'get\' operation.',
        since: 5.1
      },
      {
        signature: 'void SetFirstPoint(Point3d point)',
        summary: `Use SetFirstPoint to specify the line's starting point and skip
     the start point interactive picking`,
        since: 5.1
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetLineMode',
    dataType: 3,
    values: [
      {
        signature: 'TwoPoint = 0'
      },
      {
        signature: 'SurfaceNormal = 1'
      },
      {
        signature: 'Angled = 2'
      },
      {
        signature: 'Vertical = 3'
      },
      {
        signature: 'FourPoint = 4'
      },
      {
        signature: 'Bisector = 5'
      },
      {
        signature: 'Perpendicular = 6'
      },
      {
        signature: 'Tangent = 7'
      },
      {
        signature: 'CurveEnd = 8'
      },
      {
        signature: 'CPlaneNormalVector = 9'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetNumber',
    dataType: 1,
    summary: 'Used to get double precision numbers.',
    baseclass: 'Rhino.Input.Custom.GetBaseClass',
    constructors: [
      {
        signature: 'GetNumber()',
        summary: 'Create a new GetNumber.',
        since: 5
      }
    ],
    methods: [
      {
        signature: 'GetResult Get()',
        summary: 'Call to get a number.',
        since: 5,
        returns: 'If the user chose a number, then GetResult.Number; another enumeration value otherwise.'
      },
      {
        signature: 'void SetLowerLimit(double lowerLimit,bool strictlyGreaterThan)',
        summary: `Sets a lower limit on the number that can be returned.
     By default there is no lower limit.`,
        since: 5,
        parameters: [
          {
            name: 'lowerLimit',
            summary: 'smallest acceptable number.'
          },
          {
            name: 'strictlyGreaterThan',
            summary: 'If true, then the returned number will be > lower_limit.'
          }
        ]
      },
      {
        signature: 'void SetUpperLimit(double upperLimit,bool strictlyLessThan)',
        summary: `Sets an upper limit on the number that can be returned.
     By default there is no upper limit.`,
        since: 5,
        parameters: [
          {
            name: 'upperLimit',
            summary: 'largest acceptable number.'
          },
          {
            name: 'strictlyLessThan',
            summary: 'If true, then the returned number will be < upper_limit.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetObject',
    dataType: 1,
    summary: 'The GetObject class is the tool commands use to interactively select objects.',
    baseclass: 'Rhino.Input.Custom.GetBaseClass',
    constructors: [
      {
        signature: 'GetObject()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'bool AlreadySelectedObjectSelect',
        summary: `Allow selecting objects that are already selected. By default, GetObjects() disallows
     selection of objects that are already selected to avoid putting the same object
     in the selection set more than once. Calling EnableAlreadySelectedObjectSelect = true
     overrides that restriction and allows selected objects to be selected and
     returned by GetObjects. This is useful because, coupled with the return immediately
     mode of GetObjects(1, -1), it is possible to select a selected object to deselect
     when the selected objects are being managed outside GetObjects() as in the case of
     CRhinoPolyEdge::GetEdge().`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool BottomObjectPreference',
        summary: `By default, if a call to Input is permitted to select different parts of
     the same object, like a polysurface, a surface and an edge, then the
     top-most object is prefered. (polysurface beats face beats edge). If
     you want the bottom most object to be prefered, then call 
     EnableBottomObjectPreference = True before calling GetObjects().`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ChooseOneQuestion',
        summary: `By default, if a call to Input is permitted to select different parts
     of the same object, like a polysurface and an edge of that polysurface,
     then the top-most object is automatically selected. If you want the
     choose-one-object mechanism to include pop up in these cases, then call
     EnableChooseOneQuestion = True before calling GetObjects().`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DeselectAllBeforePostSelect',
        summary: `True if pre-selected input will be deselected before
     post-selection begins when no pre-selected input is valid.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'GeometryAttributeFilter GeometryAttributeFilter',
        summary: `The geometry attribute filter provides a secondary filter that
     can be used to restrict which objects can be selected. Control
     of the type of geometry (points, curves, surfaces, meshes, etc.)
     is provided by GetObject.SetGeometryFilter. The geometry attribute
     filter is used to require the selected geometry to have certain
     attributes (open, closed, etc.). The default attribute filter
     permits selection of all types of geometry.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ObjectType GeometryFilter',
        summary: `The geometry type filter controls which types of geometry
     (points, curves, surfaces, meshes, etc.) can be selected.
     The default geometry type filter permits selection of all
     types of geometry.
     NOTE: the filter can be a bitwise combination of multiple ObjectTypes.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool GroupSelect',
        summary: `By default, groups are ignored in GetObject. If you want your call to
     GetObjects() to select every object in a group that has any objects
     selected, then enable group selection.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool InactiveDetailPickEnabled',
        summary: `By default, objects in inactive details are not permitted to be picked.
     In a few rare cases this is used (ex. picking circles during DimRadius)`,
        since: 5.8,
        property: ['get', 'set']
      },
      {
        signature: 'int ObjectCount',
        summary: 'Gets the number of objects that were selected.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool ObjectsWerePreselected',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool OneByOnePostSelect',
        summary: `In one-by-one post selection, the user is forced
     to select objects by post picking them one at a time.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ReferenceObjectSelect',
        summary: `By default, reference objects can be selected. If you do not want to be
     able to select reference objects, then call EnableReferenceObjectSelect=false.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'uint SerialNumber',
        summary: `Each instance of GetObject has a unique runtime serial number that
     is used to identify object selection events associated with that instance.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool SubObjectSelect',
        summary: `By default, GetObject.Input will permit a user to select
     sub-objects (like a curve in a b-rep or a curve in a group).
     If you only want the user to select "top" level objects,
     then call EnableSubObjectSelect = false.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static GetObject ActiveGetObject(RhinoDoc doc)',
        summary: 'Get the currently running GetObject for a given document',
        since: 6.3
      },
      {
        signature: 'void AppendToPickList(ObjRef objref)',
        since: 6.3
      },
      {
        signature: 'void ClearObjects()',
        summary: 'Clear possible special object drawing',
        since: 6.12
      },
      {
        signature: 'bool CustomGeometryFilter(RhinoObject rhObject,GeometryBase geometry,ComponentIndex componentIndex)',
        summary: `Checks geometry to see if it can be selected.
     Override to provide fancy filtering.`,
        since: 5,
        parameters: [
          {
            name: 'rhObject',
            summary: 'parent object being considered.'
          },
          {
            name: 'geometry',
            summary: 'geometry being considered.'
          },
          {
            name: 'componentIndex',
            summary: 'if >= 0, geometry is a proper sub-part of object->Geometry() with componentIndex.'
          }
        ],
        returns: `The default returns True unless you've set a custom geometry filter. If a custom
     filter has been set, that delegate is called.`
      },
      {
        signature: 'void DisablePreSelect()',
        since: 5
      },
      {
        signature: 'void EnableClearObjectsOnEntry(bool enable)',
        summary: `By default the picked object list is cleared when GetObject.GetObjects() is called.
     If you are reusing a GetObject class and do not want the existing object list
     cleared when you call Input, then call EnableClearObjectsOnEntry(false) before
     calling GetObjects().`,
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'The state to set.'
          }
        ]
      },
      {
        signature: 'void EnableHighlight(bool enable)',
        summary: `By default, any object post-pick selected by GetObjects() is highlighted.
     If you want to post-pick objects and not have them automatically highlight,
     then call EnableHighlight = false.`,
        since: 5
      },
      {
        signature: 'void EnableIgnoreGrips(bool enable)',
        summary: `By default, post selection will select objects with grips on. If you do
     not want to be able to post select objects with grips on, then call
     EnableIgnoreGrips = false. The ability to preselect an object with grips
     on is determined by the value returned by the virtual
     RhinoObject.IsSelectableWithGripsOn.`,
        since: 5
      },
      {
        signature: 'void EnablePostSelect(bool enable)',
        summary: 'Control the availability of post selection in GetObjects.',
        since: 5
      },
      {
        signature: 'void EnablePreSelect(bool enable,bool ignoreUnacceptablePreselectedObjects)',
        summary: 'Control the pre selection behavior GetObjects.',
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'if true, pre-selection is enabled.'
          },
          {
            name: 'ignoreUnacceptablePreselectedObjects',
            summary: `If True and some acceptable objects are pre-selected, then any unacceptable
     pre-selected objects are ignored. If False and any unacceptable are pre-selected,
     then the user is forced to post-select.`
          }
        ]
      },
      {
        signature: 'void EnablePressEnterWhenDonePrompt(bool enable)',
        summary: `By default, when GetObject.GetObjects is called with minimumNumber > 0
     and maximumNumber = 0, the command prompt automatically includes "Press Enter
     when done" after the user has selected at least minimumNumber of objects. If
     you want to prohibit the addition of the "Press Enter when done", then call
     EnablePressEnterWhenDonePrompt = false;`,
        since: 5
      },
      {
        signature: 'void EnableSelPrevious(bool enable)',
        summary: `By default, any object selected during a command becomes part of the
     "previous selection set" and can be reselected by the SelPrev command.
     If you need to select objects but do not want them to be selected by
     a subsquent call to SelPrev, then call EnableSelPrev = false.`,
        since: 5
      },
      {
        signature: 'void EnableUnselectObjectsOnExit(bool enable)',
        summary: `By default any objects in the object list are unselected when GetObject.GetObjects()
     exits with any return code besides Object. If you want to leave the objects
     selected when non-object input is returned, then call EnableUnselectObjectsOnExit(false)
     before calling GetObjects().`,
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'The state to set.'
          }
        ]
      },
      {
        signature: 'GetResult Get()',
        summary: 'Call to select a single object.',
        since: 5,
        returns: `GetResult.Object if an object was selected.
     GetResult.Cancel if the user pressed ESCAPE to cancel the selection.
     See GetResults for other possible values that may be returned when options, numbers,
     etc., are acceptable responses.`
      },
      {
        signature: 'GetResult GetMultiple(int minimumNumber,int maximumNumber)',
        summary: 'Call to select objects.',
        since: 5,
        parameters: [
          {
            name: 'minimumNumber',
            summary: 'minimum number of objects to select.'
          },
          {
            name: 'maximumNumber',
            summary: `maximum number of objects to select.
     If 0, then the user must press enter to finish object selection.
     If -1, then object selection stops as soon as there are at least minimumNumber of object selected.
     If >0, then the picking stops when there are maximumNumber objects.  If a window pick, crossing
     pick, or Sel* command attempts to add more than maximumNumber, then the attempt is ignored.`
          }
        ],
        returns: `GetResult.Object if one or more objects were selected.
     GetResult.Cancel if the user pressed ESCAPE to cancel the selection.
     See GetResults for other possible values that may be returned when options, numbers,
     etc., are acceptable responses.`
      },
      {
        signature: 'ObjRef Object(int index)',
        since: 5
      },
      {
        signature: 'ObjRef[] Objects()',
        since: 5
      },
      {
        signature: 'bool PassesGeometryAttributeFilter(RhinoObject rhObject,GeometryBase geometry,ComponentIndex componentIndex)',
        summary: 'Checks geometry to see if it passes the basic GeometryAttributeFilter.',
        since: 5,
        parameters: [
          {
            name: 'rhObject',
            summary: 'parent object being considered.'
          },
          {
            name: 'geometry',
            summary: 'geometry being considered.'
          },
          {
            name: 'componentIndex',
            summary: 'if >= 0, geometry is a proper sub-part of object->Geometry() with componentIndex.'
          }
        ],
        returns: 'True if the geometry passes the filter returned by GeometryAttributeFilter().'
      },
      {
        signature: 'void SetCustomGeometryFilter(GetObjectGeometryFilter filter)',
        summary: 'Set filter callback function that will be called by the CustomGeometryFilter',
        since: 5
      },
      {
        signature: 'void SetPressEnterWhenDonePrompt(string prompt)',
        summary: `The default prompt when EnablePressEnterWhenDonePrompt is enabled is "Press Enter
     when done". Use this function to specify a different string to be appended.`,
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: `The text that will be displayed just after the prompt,
     after the selection has been made.`
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetOption',
    dataType: 1,
    summary: `If you want to explicitly get string input, then use GetString class with
   options. If you only want to get options, then use this class (GetOption)`,
    baseclass: 'Rhino.Input.Custom.GetBaseClass',
    constructors: [
      {
        signature: 'GetOption()',
        since: 5
      }
    ],
    methods: [
      {
        signature: 'GetResult Get()',
        summary: `Call to get an option. A return value of "option" means the user selected
     a valid option. Use Option() the determine which option.`,
        since: 5,
        returns: 'If the user chose an option, then GetResult.Option; another enumeration value otherwise.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetPoint',
    dataType: 1,
    summary: 'Used to interactively get a point.',
    baseclass: 'Rhino.Input.Custom.GetBaseClass',
    constructors: [
      {
        signature: 'GetPoint()',
        summary: 'Create a new GetPoint.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'Color DynamicDrawColor',
        summary: `Color used by CRhinoGetPoint::DynamicDraw to draw the current point and
     the line from the base point to the current point.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool FullFrameRedrawDuringGet',
        summary: `In the "RARE" case that you need to draw some depth buffered geometry during
     a Get() operation, setting this value to True will force entire frames to be redrawn
     while the user moves the mouse. This allows DisplayPipeline events to be triggered
     as well as OnPostDrawObjects
     NOTE!! Setting this value to True comes with a significant performance penalty because the
     scene needs to be fully regenerated every frame where the standard
     DynamicDraw event draws temporary decorations (geometry) on top of a static scene.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'OsnapModes OsnapEventType',
        summary: 'Gets the type of object snap used to obtain the point.',
        since: 6.24,
        property: ['get']
      },
      {
        signature: 'object Tag',
        summary: `Gets or sets an arbitrary object that can be attached to this GetPoint instance.
     Useful for passing some/ information that you may need in a DynamicDraw event since you can get at this Tag from
     the GetPointDrawEventArgs.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'int AddConstructionPoint(Point3d point)',
        summary: 'Adds a point to the list of construction points.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point to be added.'
          }
        ],
        returns: 'Total number of construction points.'
      },
      {
        signature: 'int AddConstructionPoints(Point3d[] points)',
        summary: 'Adds points to the list of construction points.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'An array of points to be added.'
          }
        ],
        returns: 'Total number of construction points.'
      },
      {
        signature: 'int AddSnapPoint(Point3d point)',
        summary: 'Adds a point to the list of osnap points.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'A point.'
          }
        ],
        returns: 'Total number of snap points.'
      },
      {
        signature: 'int AddSnapPoints(Point3d[] points)',
        summary: 'Adds points to the list of osnap points.',
        since: 5,
        parameters: [
          {
            name: 'points',
            summary: 'An array of points to snap onto.'
          }
        ],
        returns: 'Total number of snap points.'
      },
      {
        signature: 'void ClearConstraints()',
        summary: `Removes any explicit constraints added by calls to GetPoint::Constraint() and enable
     the built-in constraint options.`,
        since: 5
      },
      {
        signature: 'void ClearConstructionPoints()',
        summary: 'Remove all construction points.',
        since: 5
      },
      {
        signature: 'void ClearSnapPoints()',
        summary: 'Remove all snap points.',
        since: 5
      },
      {
        signature: 'bool Constrain(Arc arc)',
        summary: 'Constrains the picked point to lie on an arc.',
        since: 5,
        parameters: [
          {
            name: 'arc',
            summary: 'An arc to use as constraint.'
          }
        ],
        returns: 'True if constraint could be applied.'
      },
      {
        signature: 'bool Constrain(Brep brep,int wireDensity,int faceIndex,bool allowPickingPointOffObject)',
        summary: 'Constrains the picked point to lie on a brep.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'A brep to use as constraint.'
          },
          {
            name: 'wireDensity',
            summary: `When wire_density<0, isocurve intersection snapping is turned off, when wire_density>=0, the value
     defines the isocurve density used for isocurve intersection snapping.`
          },
          {
            name: 'faceIndex',
            summary: 'When face_index <0, constrain to whole brep. When face_index >=0, constrain to individual face.'
          },
          {
            name: 'allowPickingPointOffObject',
            summary: `defines whether the point pick is allowed to happen off object. When false,
     a "no no" cursor is shown when the cursor is not on the object. When true,
     a normal point picking cursor is used and the marker is visible also when
     the cursor is not on the object.`
          }
        ],
        returns: 'True if constraint could be applied.'
      },
      {
        signature: 'bool Constrain(Circle circle)',
        summary: 'Constrains the picked point to lie on a circle.',
        since: 5,
        parameters: [
          {
            name: 'circle',
            summary: 'A circle to use as constraint.'
          }
        ],
        returns: 'True if constraint could be applied.'
      },
      {
        signature: 'bool Constrain(Curve curve,bool allowPickingPointOffObject)',
        summary: 'Constrains the picked point to lie on a curve.',
        since: 5,
        parameters: [
          {
            name: 'curve',
            summary: 'A curve to use as constraint.'
          },
          {
            name: 'allowPickingPointOffObject',
            summary: `defines whether the point pick is allowed to happen off object. When false,
     a "no no" cursor is shown when the cursor is not on the object. When true,
     a normal point picking cursor is used and the marker is visible also when
     the cursor is not on the object.`
          }
        ],
        returns: 'True if constraint could be applied.'
      },
      {
        signature: 'bool Constrain(Cylinder cylinder)',
        summary: 'Constrains the picked point to lie on a cylinder.',
        since: 5,
        parameters: [
          {
            name: 'cylinder',
            summary: 'A cylinder to use as constraint.'
          }
        ],
        returns: 'True if constraint could be applied.'
      },
      {
        signature: 'bool Constrain(Line line)',
        summary: 'Constrains the picked point to lie on a line.',
        since: 5,
        parameters: [
          {
            name: 'line',
            summary: 'A line to use as constraint.'
          }
        ],
        returns: 'True if constraint could be applied.'
      },
      {
        signature: 'bool Constrain(Mesh mesh,bool allowPickingPointOffObject)',
        summary: 'Constrains the picked point to lie on a mesh.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'A mesh to use as constraint.'
          },
          {
            name: 'allowPickingPointOffObject',
            summary: `defines whether the point pick is allowed to happen off object. When false,
     a "no no" cursor is shown when the cursor is not on the object. When true,
     a normal point picking cursor is used and the marker is visible also when
     the cursor is not on the object.`
          }
        ],
        returns: 'True if constraint could be applied.'
      },
      {
        signature: 'bool Constrain(Plane plane,bool allowElevator)',
        summary: 'constrain the picked point to lie on a plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'A plane to use as constraint.'
          },
          {
            name: 'allowElevator',
            summary: 'True if elevator mode should be allowed at user request.'
          }
        ],
        returns: 'True if constraint could be applied.'
      },
      {
        signature: 'bool Constrain(Point3d from,Point3d to)',
        summary: 'Constrains the picked point to lie on a line.',
        since: 5,
        parameters: [
          {
            name: 'from',
            summary: 'The start point of constraint.'
          },
          {
            name: 'to',
            summary: 'The end point of constraint.'
          }
        ],
        returns: 'True if constraint could be applied.'
      },
      {
        signature: 'bool Constrain(Sphere sphere)',
        summary: 'Constrains the picked point to lie on a sphere.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: 'A sphere to use as constraint.'
          }
        ],
        returns: 'True if constraint could be applied.'
      },
      {
        signature: 'bool Constrain(Surface surface,bool allowPickingPointOffObject)',
        summary: 'Constrains the picked point to lie on a surface.',
        since: 5,
        parameters: [
          {
            name: 'surface',
            summary: 'A surface to use as constraint.'
          },
          {
            name: 'allowPickingPointOffObject',
            summary: `defines whether the point pick is allowed to happen off object. When false,
     a "no no" cursor is shown when the cursor is not on the object. When true,
     a normal point picking cursor is used and the marker is visible also when
     the cursor is not on the object.`
          }
        ],
        returns: 'True if constraint could be applied.'
      },
      {
        signature: 'void ConstrainDistanceFromBasePoint(double distance)',
        summary: 'Sets distance constraint from base point.',
        since: 5,
        parameters: [
          {
            name: 'distance',
            summary: `pass UnsetValue to clear this constraint. Pass 0.0 to disable the
     ability to set this constraint by typing a number during GetPoint.`
          }
        ]
      },
      {
        signature: 'bool ConstrainToConstructionPlane(bool throughBasePoint)',
        summary: `If enabled, the picked point is constrained to be on the active construction plane.
     If the base point is set, then the point is constrained to be on the plane that contains
     the base point and is parallel to the active construction plane. By default this
     constraint is enabled.`,
        since: 5,
        parameters: [
          {
            name: 'throughBasePoint',
            summary: 'True if the base point should be used as compulsory level reference.'
          }
        ],
        returns: `If True and the base point is set, then the point is constrained to be on the plane parallel
     to the construction plane that passes through the base point, even when planar mode is off.
     If throughBasePoint is false, then the base point shift only happens if planar mode is on.`
      },
      {
        signature: 'void ConstrainToTargetPlane()',
        summary: `Constrains point to lie on a plane that is parallel to the
     viewing plane and passes through the view's target point.`,
        since: 5
      },
      {
        signature: 'bool ConstrainToVirtualCPlaneIntersection(Plane plane)',
        summary: `If enabled, the picked point is constrained to be on the 
     intersection of the plane and the virtual CPlane going through
     the plane origin.
     If the planes are parallel, the constraint works just like planar constraint.`,
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'The plane used for the plane - virtual CPlane intersection.'
          }
        ],
        returns: 'True if the operation succeeded; False otherwise.'
      },
      {
        signature: 'void DrawLineFromPoint(Point3d startPoint,bool showDistanceInStatusBar)',
        summary: 'Use DrawLineFromPoint() if you want a dynamic line drawn from a point to the point being picked.',
        since: 5,
        parameters: [
          {
            name: 'startPoint',
            summary: `The line is drawn from startPoint to the point being picked. If the base
     point has not been set, then it is set to startPoint.`
          },
          {
            name: 'showDistanceInStatusBar',
            summary: 'if true, the distance from the basePoint to the point begin picked is shown in the status bar.'
          }
        ]
      },
      {
        signature: 'void EnableCurveSnapArrow(bool drawDirectionArrowAtSnapPoint,bool reverseArrow)',
        summary: 'Controls display of the curve snap arrow icon.',
        since: 5,
        parameters: [
          {
            name: 'drawDirectionArrowAtSnapPoint',
            summary: 'True to draw arrow icon whenever GetPoint snaps to a curve.'
          },
          {
            name: 'reverseArrow',
            summary: 'True if arrow icon direction should be the reverse of the first derivative direction.'
          }
        ]
      },
      {
        signature: 'void EnableCurveSnapPerpBar(bool drawPerpBarAtSnapPoint,bool drawEndPoints)',
        summary: 'Controls display of the curve snap perpendicular bar icon.',
        since: 5,
        parameters: [
          {
            name: 'drawPerpBarAtSnapPoint',
            summary: 'True to draw a tangent bar icon  whenever GetPoint snaps to a curve.'
          },
          {
            name: 'drawEndPoints',
            summary: 'True to draw points at the end of the tangent bar.'
          }
        ]
      },
      {
        signature: 'void EnableCurveSnapTangentBar(bool drawTangentBarAtSnapPoint,bool drawEndPoints)',
        summary: 'Controls display of the curve snap tangent bar icon.',
        since: 5,
        parameters: [
          {
            name: 'drawTangentBarAtSnapPoint',
            summary: 'True to draw a tangent bar icon whenever GetPoint snaps to a curve.'
          },
          {
            name: 'drawEndPoints',
            summary: 'True to draw points at the end of the tangent bar.'
          }
        ]
      },
      {
        signature: 'void EnableDrawLineFromPoint(bool enable)',
        summary: 'Controls drawing of dynamic a line from the start point.',
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'if true, a dynamic line is drawn from the DrawLineFromPoint startPoint to the point being picked.'
          }
        ]
      },
      {
        signature: 'void EnableNoRedrawOnExit(bool noRedraw)',
        summary: `The default functionality of the getpoint operation is to perform a redraw on exit.
     Calling this function with True turns off automatic redraw at the end of GetPoint.
     May be needed in some commands for flicker free feedback.
     When set to true, the caller is responsible for cleaning up the screen
     after GetPoint.`,
        since: 6
      },
      {
        signature: 'void EnableObjectSnapCursors(bool enable)',
        summary: 'Enables or disables object snap cursors. By default, object snap cursors are enabled.',
        since: 6,
        parameters: [
          {
            name: 'enable',
            summary: `If True then object snap cursors (plus sign with "near", "end", etc.) 
     are used when the point snaps to a object.`
          }
        ]
      },
      {
        signature: 'void EnableSnapToCurves(bool enable)',
        summary: `If you want GetPoint() to try to snap to curves when the mouse is near a curve
     (like the center point in the Circle command when the AroundCurve option is on),
     then enable the snap to curves option.`,
        since: 5,
        parameters: [
          {
            name: 'enable',
            summary: 'Whether points should be enabled.'
          }
        ]
      },
      {
        signature: 'GetResult Get()',
        summary: `After setting up options and so on, call GetPoint::Get to get a 3d point. The
     point is retrieved when the mouse goes down.`,
        since: 5
      },
      {
        signature: 'GetResult Get(bool onMouseUp)',
        summary: 'After setting up options and so on, call this method to get a 3d point.',
        since: 5,
        parameters: [
          {
            name: 'onMouseUp',
            summary: `If false, the point is returned when the left mouse button goes down.
     If true, the point is returned when the left mouse button goes up.`
          }
        ],
        returns: 'GetResult.Point if the user chose a point; other enumeration value otherwise.'
      },
      {
        signature: 'GetResult Get(bool onMouseUp,bool get2DPoint)',
        summary: 'After setting up options and so on, call this method to get a 2d or 3d point.',
        since: 5.12,
        parameters: [
          {
            name: 'onMouseUp',
            summary: `If false, the point is returned when the left mouse button goes down.
     If true, the point is returned when the left mouse button goes up.`
          },
          {
            name: 'get2DPoint',
            summary: 'If True then get a 2d point otherwise get a 2d point'
          }
        ],
        returns: 'GetResult.Point if the user chose a 3d point; GetResult.Point2d if the user chose a 2d point; other enumeration value otherwise.'
      },
      {
        signature: 'Point3d[] GetConstructionPoints()',
        summary: 'Gets current construction points.',
        since: 5,
        returns: 'An array of points.'
      },
      {
        signature: 'bool GetPlanarConstraint(RhinoViewport vp,Plane plane)',
        since: 6
      },
      {
        signature: 'Point3d[] GetSnapPoints()',
        summary: 'Gets current snap points.',
        since: 5,
        returns: 'An array of points.'
      },
      {
        signature: 'bool InterruptMouseMove()',
        summary: `If you have lengthy computations in OnMouseMove() and/or DymanicDraw()
     overrides, then periodically call InterruptMouseMove() to see if you
     should interrupt your work because the mouse has moved again.`,
        since: 5,
        returns: 'True if you should interrupt your work; False otherwise.'
      },
      {
        signature: 'void PermitConstraintOptions(bool permit)',
        summary: `Control the availability of the built-in linear, planar, curve, and surface
     constraint options like "Along", "AlongPerp", "AlongTan", "AlongParallel",
     "Between", "OnCrv", "OnSrf", ".x", ".y", ".z", ".xy", etc.`,
        since: 5,
        parameters: [
          {
            name: 'permit',
            summary: 'if true, then the built-in contraint options are automatically avaiable in GetPoint.'
          }
        ]
      },
      {
        signature: 'void PermitElevatorMode(int permitMode)',
        summary: 'Permits the use of the control key to define a line constraint.',
        since: 5,
        parameters: [
          {
            name: 'permitMode',
            summary: `0: no elevator modes are permitted
     1: fixed plane elevator mode (like the Line command)
     2: cplane elevator mode (like object dragging)`
          }
        ]
      },
      {
        signature: 'void PermitFromOption(bool permit)',
        summary: 'Control the availability of the built-in "From" option. By default, the "From" option is enabled.',
        since: 5,
        parameters: [
          {
            name: 'permit',
            summary: 'if true, then the "From" option is automatically avaiable in GetPoint.'
          }
        ]
      },
      {
        signature: 'void PermitObjectSnap(bool permit)',
        summary: `By default, object snaps like "end", "near", etc. are controled by the user.
     If you want to disable this ability, then call PermitObjectSnap(false).`,
        since: 5,
        parameters: [
          {
            name: 'permit',
            summary: 'True to permit snapping to objects.'
          }
        ]
      },
      {
        signature: 'void PermitOrthoSnap(bool permit)',
        summary: 'Controls availability of ortho snap. Default is true.',
        since: 5,
        parameters: [
          {
            name: 'permit',
            summary: `if true, then GetPoint pays attention to the Rhino "ortho snap" and "planar snap" settings
     reported by ModelAidSettings.Ortho and ModelAidSettings.Planar.`
          }
        ]
      },
      {
        signature: 'void PermitTabMode(bool permit)',
        summary: 'Permits the use of the tab key to define a line constraint.',
        since: 5,
        parameters: [
          {
            name: 'permit',
            summary: 'If true, then the built-in tab key mode is available.'
          }
        ]
      },
      {
        signature: 'BrepFace PointOnBrep(double u,double v)',
        summary: `Use to determine if point was on a Brep face. If the point was on a Brep face, 
     then the (u,v) are the face parameters for the point.`,
        since: 6,
        parameters: [
          {
            name: 'u',
            summary: 'If the point was on a Brep face, then the u parameter.'
          },
          {
            name: 'v',
            summary: 'If the point was on a Brep face, then the v parameter.'
          }
        ],
        returns: 'The Brep face or None if the point was not on a Brep face.'
      },
      {
        signature: 'Curve PointOnCurve(double t)',
        summary: 'Use to determine is point was on a curve.',
        since: 5,
        parameters: [
          {
            name: 't',
            summary: `If the point was on a curve, then the t is the curve
     parameter for the point.  The point returned by Point()
     is the same as curve.PointAt(t).`
          }
        ],
        returns: 'A curve at a specified parameter value.'
      },
      {
        signature: 'DocObjects.ObjRef PointOnObject()',
        summary: `Call this function to see if the point was on an object. If the point was
     on an object an ObjRef is returned; otherwise None is returned.`,
        since: 5,
        returns: 'A point object reference.'
      },
      {
        signature: 'Surface PointOnSurface(double u,double v)',
        summary: `Use to determine if point was on a surface. If the point was on a surface, 
     then the (u,v) are the surface parameters for the point. The point returned
     by Point() is the same as surface.PointAt(u,v).`,
        since: 6,
        parameters: [
          {
            name: 'u',
            summary: 'If the point was on a surface, then the u parameter.'
          },
          {
            name: 'v',
            summary: 'If the point was on a surface, then the v parameter.'
          }
        ],
        returns: 'The surface or None if the point was not on a surface.'
      },
      {
        signature: 'void SetBasePoint(Point3d basePoint,bool showDistanceInStatusBar)',
        summary: 'Sets a base point used by ortho snap, from snap, planar snap, etc.',
        since: 5,
        parameters: [
          {
            name: 'basePoint',
            summary: 'The new base point.'
          },
          {
            name: 'showDistanceInStatusBar',
            summary: `If true, then the distance from base_point to the current point will be in the
     status bar distance pane.`
          }
        ]
      },
      {
        signature: 'void SetCursor(CursorStyle cursor)',
        summary: `Sets cursor that will be used when Get() is called and snap is not
     happening.`,
        since: 6
      },
      {
        signature: 'bool TryGetBasePoint(Point3d basePoint)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetPointDrawEventArgs',
    dataType: 1,
    summary: 'Arguments for drawing during point getting.',
    baseclass: 'Rhino.Display.DrawEventArgs',
    properties: [
      {
        signature: 'Point3d CurrentPoint',
        since: 5,
        property: ['get']
      },
      {
        signature: 'GetPoint Source',
        summary: 'GetPoint class that this draw event originated from.',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetPointMouseEventArgs',
    dataType: 1,
    summary: 'Arguments for mouse information during point getting.',
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'bool ControlKeyDown',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool LeftButtonDown',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool MiddleButtonDown',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point3d Point',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool RightButtonDown',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool ShiftKeyDown',
        since: 5,
        property: ['get']
      },
      {
        signature: 'GetPoint Source',
        since: 5,
        property: ['get']
      },
      {
        signature: 'RhinoViewport Viewport',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point WindowPoint',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetPolyline',
    dataType: 1,
    summary: 'Use to interactively get a polyline.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'GetPolyline()',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'string FirstPointPrompt',
        summary: 'Prompt when getting first point',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string FourthPointPrompt',
        summary: 'Prompt when getting fourth point',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int MaxPointCount',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int MinPointCount',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string SecondPointPrompt',
        summary: 'Prompt when getting second point',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string ThirdPointPrompt',
        summary: 'Prompt when getting third point',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      },
      {
        signature: 'Commands.Result Get(Polyline polyline)',
        summary: 'Perform the \'get\' operation.',
        since: 6
      },
      {
        signature: 'void SetFirstPoint(Point3d point)',
        summary: `Use SetFirstPoint to specify the line's starting point and skip
     the start point interactive picking`,
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetSphere.MeshSphereStyle',
    dataType: 3,
    summary: 'Mesh sphere styles enumeration.',
    values: [
      {
        signature: 'UV = 0',
        summary: 'UV Sphere.'
      },
      {
        signature: 'Triangle = 1',
        summary: 'Icosahedron Sphere.'
      },
      {
        signature: 'Quad = 2',
        summary: 'Quad Sphere.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetString',
    dataType: 1,
    summary: 'Used to get strings.',
    baseclass: 'Rhino.Input.Custom.GetBaseClass',
    constructors: [
      {
        signature: 'GetString()',
        summary: 'Constructs a new GetString.',
        since: 5
      }
    ],
    methods: [
      {
        signature: 'GetResult Get()',
        summary: 'Returns the string that the user typed. By default, space stops the string input.',
        since: 5,
        returns: 'The result type. If the user typed a string, this is GetResult.String.'
      },
      {
        signature: 'GetResult GetLiteralString()',
        summary: 'Returns the string that the user typed. By default, space does not stop input.',
        since: 5,
        returns: 'The result type. If the user typed a string, this is GetResult.String.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetTorus',
    dataType: 1,
    summary: 'Class provides user interface to define a torus.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'GetTorus()',
        since: 7
      }
    ],
    properties: [
      {
        signature: 'double DefaultSize',
        summary: 'Default radius or diameter (based on InDiameterMode)',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool FixInnerRadius',
        summary: 'Second radius opion. The first radius chosen sets the inner dimension of the torus and the second radius is constrained to be outside of the first radius.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool InDiameterMode',
        summary: 'Determines if the "size" value is reperesenting a radius or diameter',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool InSecondDiameterMode',
        summary: 'Second radius opion. Determines if the second "size" value is reperesenting a radius or diameter',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double SecondSize',
        summary: 'Second radius or diameter (based on InSecondDiameterMode)',
        since: 7,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 7
      },
      {
        signature: 'Commands.Result Get(Torus torus)',
        summary: 'Prompt for the getting of a torus.',
        since: 7,
        parameters: [
          {
            name: 'torus',
            summary: 'The torus geometry defined by the user.'
          }
        ],
        returns: 'The result of the getting operation.'
      },
      {
        signature: 'Commands.Result GetMesh(int verticalFaces,int aroundFaces,Torus torus)',
        summary: 'Prompt for the getting of a mesh torus.',
        since: 7,
        parameters: [
          {
            name: 'verticalFaces',
            summary: 'The number of faces in the vertical direction.'
          },
          {
            name: 'aroundFaces',
            summary: 'The number of faces in the around direction'
          },
          {
            name: 'torus',
            summary: 'The torus geometry defined by the user.'
          }
        ],
        returns: 'The result of the getting operation.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetTransform',
    dataType: 1,
    summary: 'Used for getting a Transform',
    baseclass: 'Rhino.Input.Custom.GetPoint',
    properties: [
      {
        signature: 'bool HaveTransform',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'TransformObjectList ObjectList',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Transform Transform',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void AddTransformObjects(TransformObjectList list)',
        summary: `Adds any objects you want transformed and grips you want transformed.
     Make sure no duplicates are in the list and that no grip ownwers are
     passed in as objects.`,
        since: 5,
        parameters: [
          {
            name: 'list',
            summary: 'A custom transform object list.'
          }
        ]
      },
      {
        signature: 'Transform CalculateTransform(RhinoViewport viewport,Point3d point)',
        summary: `Retrieves the final transformation.
     Override this virtual function to provide your own custom transformation method.`,
        since: 5,
        parameters: [
          {
            name: 'viewport',
            summary: 'A Rhino viewport that the user is using.'
          },
          {
            name: 'point',
            summary: 'A point that the user is selecting.'
          }
        ],
        returns: 'A transformation matrix value.'
      },
      {
        signature: 'GetResult GetXform()',
        summary: `Gets the Transformation.
     Call this after having set up options and so on.`,
        since: 5,
        returns: 'The result based on user choice.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'GetTruncatedCone',
    dataType: 1,
    summary: 'Class provides user interface to define a truncated cone.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'GetTruncatedCone()',
        since: 7
      }
    ],
    properties: [
      {
        signature: 'bool Cap',
        summary: 'Gets or sets whether or not the output should be capped.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'CylinderConstraint CylinderConstraint',
        summary: `State of the cone/cyl constraint option. When the cone/cyl option is
     selected, the circle is being made as a base for a cone/cyl.
     By default the vertical cone/cyl option not available but is not
     selected.  By default the "Vertical" option applies to VerticalCircle.`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double DefaultSize',
        summary: 'Default radius or diameter (based on InDiameterMode)',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double Height',
        summary: 'Height of truncated cone.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool InDiameterMode',
        summary: 'Determines if the "size" value is reperesenting a radius or diameter',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double SecondRadius',
        summary: 'Radius of second circle.',
        since: 7,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 7
      },
      {
        signature: 'Commands.Result Get(Brep truncatedCone)',
        summary: 'Prompt for the getting of a truncated cone.',
        since: 7,
        parameters: [
          {
            name: 'truncatedCone',
            summary: 'The truncated cone in Brep form.'
          }
        ],
        returns: 'The result of the getting operation.'
      },
      {
        signature: 'Commands.Result GetMesh(int verticalFaces,int aroundFaces,int capStyle,Mesh truncatedCone)',
        summary: 'Prompt for the getting of a mesh truncated cone.',
        since: 7,
        parameters: [
          {
            name: 'verticalFaces',
            summary: 'The number of faces in the vertical direction.'
          },
          {
            name: 'aroundFaces',
            summary: 'The number of faces in the around direction'
          },
          {
            name: 'capStyle',
            summary: 'Set to 0 if you don\'t want the prompt, 3 is tris, 4 is quads.'
          },
          {
            name: 'truncatedCone',
            summary: 'The truncated cone in Mesh form.'
          }
        ],
        returns: 'The result of the getting operation.'
      },
      {
        signature: 'Commands.Result GetMesh(int verticalFaces,int aroundFaces,Mesh truncatedCone)',
        summary: 'Prompt for the getting of a mesh truncated cone.',
        since: 7,
        parameters: [
          {
            name: 'verticalFaces',
            summary: 'The number of faces in the vertical direction.'
          },
          {
            name: 'aroundFaces',
            summary: 'The number of faces in the around direction'
          },
          {
            name: 'truncatedCone',
            summary: 'The truncated cone in Mesh form.'
          }
        ],
        returns: 'The result of the getting operation.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'OptionColor',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'OptionColor(Color initialValue)',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'Color CurrentValue',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color InitialValue',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'OptionDouble',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'OptionDouble(double initialValue)',
        since: 5
      },
      {
        signature: 'OptionDouble(double initialValue,bool setLowerLimit,double limit)',
        summary: 'Initializes a new instance of the double option class.',
        since: 5,
        parameters: [
          {
            name: 'initialValue',
            summary: 'The initial number .'
          },
          {
            name: 'setLowerLimit',
            summary: `If true, limit sets the lower limit and upper limit is undefined.
     If false, limit sets the upper limit and lower limit is undefined.`
          },
          {
            name: 'limit',
            summary: 'The lower limit if setLowerLimit is true; otherwise, the upper limit.'
          }
        ]
      },
      {
        signature: 'OptionDouble(double initialValue,double lowerLimit,double upperLimit)',
        summary: 'Initializes a new instance of the OptionDouble class with lower and upper limits.',
        since: 5,
        parameters: [
          {
            name: 'initialValue',
            summary: 'The initial number .'
          },
          {
            name: 'lowerLimit',
            summary: 'The minimum value.'
          },
          {
            name: 'upperLimit',
            summary: 'The maximum value.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'double CurrentValue',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double InitialValue',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'OptionInteger',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'OptionInteger(int initialValue)',
        since: 5
      },
      {
        signature: 'OptionInteger(int initialValue,bool setLowerLimit,int limit)',
        summary: 'Initializes a new instance of the OptionInteger class.',
        since: 5,
        parameters: [
          {
            name: 'initialValue',
            summary: 'The initial value.'
          },
          {
            name: 'setLowerLimit',
            summary: `If true, limit sets the lower limit and upper limit is undefined
     If false, limit sets the upper limit and lower limit is undefined.`
          },
          {
            name: 'limit',
            summary: `If setLowerLimit is true, then limit is the minimum value.
     Otherwise, it is the maximum.`
          }
        ]
      },
      {
        signature: 'OptionInteger(int initialValue,int lowerLimit,int upperLimit)',
        summary: 'Initializes a new instance of the OptionInteger class wiht both lower and upper limits.',
        since: 5,
        parameters: [
          {
            name: 'initialValue',
            summary: 'The initial value.'
          },
          {
            name: 'lowerLimit',
            summary: 'The minimum value.'
          },
          {
            name: 'upperLimit',
            summary: 'The maximum value.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int CurrentValue',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int InitialValue',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'OptionToggle',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'OptionToggle(bool initialValue,LocalizeStringPair offValue,LocalizeStringPair onValue)',
        since: 5
      },
      {
        signature: 'OptionToggle(bool initialValue,string offValue,string onValue)',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'bool CurrentValue',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool InitialValue',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'PickContext',
    dataType: 1,
    summary: 'Utility for determining if objects are picked',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'PickContext()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'GetObject GetObjectUsed',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool PickGroupsEnabled',
        summary: 'Thue if GroupObjects should be added to the pick list',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Line PickLine',
        summary: 'pick chord starts on near clipping plane and ends on far clipping plane.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'PickMode PickMode',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'PickStyle PickStyle',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool SubObjectSelectionEnabled',
        summary: 'True if the user had activated subobject selection',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'RhinoView View',
        summary: `This view can be a model view or a page view. When view is a page view,
     then you need to distingish between the viewports MainViewport() and
     ActiveViewport().  When m_view is a model view, both MainViewport() and
     ActiveViewport() return the world view's viewport.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'bool PickFrustumTest(BezierCurve bezier,double t,double depth,double distance)',
        since: 5
      },
      {
        signature: 'bool PickFrustumTest(BoundingBox box,bool boxCompletelyInFrustum)',
        summary: 'Fast test to check if a bounding box intersects a pick frustum.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: ''
          },
          {
            name: 'boxCompletelyInFrustum',
            summary: `Set to True if the box is completely contained in the pick frustum.
     When doing a window or crossing pick, you can immediately return a
     hit if the object's bounding box is completely inside of the pick frustum.`
          }
        ],
        returns: 'False if bbox is invalid or box does not intersect the pick frustum'
      },
      {
        signature: 'bool PickFrustumTest(Line line,double t,double depth,double distance)',
        since: 5
      },
      {
        signature: 'bool PickFrustumTest(Mesh mesh,MeshPickStyle pickStyle,Point3d hitPoint,double depth,double distance,MeshHitFlag hitFlag,int hitIndex)',
        summary: 'Utility for picking meshes',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'mesh to test'
          },
          {
            name: 'pickStyle',
            summary: 'mode used for pick test'
          },
          {
            name: 'hitPoint',
            summary: 'location returned here for point picks'
          },
          {
            name: 'depth',
            summary: `depth returned here for point picks
     LARGER values are NEARER to the camera.
     SMALLER values are FARTHER from the camera.`
          },
          {
            name: 'distance',
            summary: `planar distance returned here for point picks.
     SMALLER values are CLOSER to the pick point`
          },
          {
            name: 'hitFlag',
            summary: 'For point picks, How to interpret the hitIndex (vertex hit, edge hit, or face hit)'
          },
          {
            name: 'hitIndex',
            summary: `index of vertex/edge/face that was hit. Use hitFlag to determine what this index
     corresponds to`
          }
        ]
      },
      {
        signature: 'bool PickFrustumTest(Mesh mesh,MeshPickStyle pickStyle,Point3d hitPoint,Point2d hitSurfaceUV,Point2d hitTextureCoordinate,double depth,double distance,MeshHitFlag hitFlag,int hitIndex)',
        summary: 'Utility for picking meshes',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'mesh to test'
          },
          {
            name: 'pickStyle',
            summary: 'mode used for pick test'
          },
          {
            name: 'hitPoint',
            summary: 'location returned here for point picks'
          },
          {
            name: 'hitSurfaceUV',
            summary: 'If the mesh has surface parameters, set to the surface parameters of the hit point'
          },
          {
            name: 'hitTextureCoordinate',
            summary: `If the mesh has texture coordinates, set to the texture coordinate of the hit
     point.  Note that the texture coodinates can be set in many different ways
     and this information is useless unless you know how the texture coordinates
     are set on this particular mesh.`
          },
          {
            name: 'depth',
            summary: `depth returned here for point picks
     LARGER values are NEARER to the camera.
     SMALLER values are FARTHER from the camera.`
          },
          {
            name: 'distance',
            summary: `planar distance returned here for point picks.
     SMALLER values are CLOSER to the pick point`
          },
          {
            name: 'hitFlag',
            summary: 'For point picks, How to interpret the hitIndex (vertex hit, edge hit, or face hit)'
          },
          {
            name: 'hitIndex',
            summary: `index of vertex/edge/face that was hit. Use hitFlag to determine what this index
     corresponds to`
          }
        ]
      },
      {
        signature: 'bool PickFrustumTest(NurbsCurve curve,double t,double depth,double distance)',
        since: 5
      },
      {
        signature: 'bool PickFrustumTest(Point3d point,double depth,double distance)',
        summary: 'Utility for picking 3d point',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: ''
          },
          {
            name: 'depth',
            summary: `depth returned here for point picks.
     LARGER values are NEARER to the camera.
     SMALLER values are FARTHER from the camera.`
          },
          {
            name: 'distance',
            summary: `planar distance returned here for point picks.
     SMALLER values are CLOSER to the pick point`
          }
        ],
        returns: 'True if there is a hit'
      },
      {
        signature: 'bool PickFrustumTest(Point3d[] points,int pointIndex,double depth,double distance)',
        since: 5
      },
      {
        signature: 'bool PickFrustumTest(PointCloud cloud,int pointIndex,double depth,double distance)',
        since: 5
      },
      {
        signature: 'int[] PickMeshTopologyVertices(Mesh mesh)',
        summary: 'Utility for picking mesh vertices',
        since: 5,
        returns: 'indices of mesh topology vertices that were picked'
      },
      {
        signature: 'void SetPickTransform(Transform transform)',
        since: 5
      },
      {
        signature: 'void UpdateClippingPlanes()',
        summary: `Updates the clipping plane information in pick region. The
     SetClippingPlanes and View fields must be called before calling
     UpdateClippingPlanes().`,
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'PickContext.MeshHitFlag',
    dataType: 3,
    values: [
      {
        signature: 'Invalid = -1'
      },
      {
        signature: 'Vertex = 0'
      },
      {
        signature: 'Edge = 1'
      },
      {
        signature: 'Face = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'PickContext.MeshPickStyle',
    dataType: 3,
    values: [
      {
        signature: 'WireframePicking = 0',
        summary: 'Checks for vertex and edge hits'
      },
      {
        signature: 'ShadedModePicking = 1',
        summary: 'Checks for face hits'
      },
      {
        signature: 'VertexOnlyPicking = 2',
        summary: 'Returns False if no vertices are hit'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'PickMode',
    dataType: 3,
    summary: 'Picking can happen in wireframe or shaded display mode',
    values: [
      {
        signature: 'Wireframe = 1'
      },
      {
        signature: 'Shaded = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'PickStyle',
    dataType: 3,
    summary: 'Provides picking values that describe common CAD picking behavior.',
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'PointPick = 1'
      },
      {
        signature: 'WindowPick = 2'
      },
      {
        signature: 'CrossingPick = 3'
      }
    ]
  },
  {
    namespace: 'Rhino.Input.Custom',
    name: 'TaskCompleteEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    constructors: [
      {
        signature: 'TaskCompleteEventArgs(Task task,RhinoDoc doc)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'RhinoDoc Doc',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool Redraw',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Task Task',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Input',
    name: 'GetBoxMode',
    dataType: 3,
    summary: 'Enumerates all Box getter modes.',
    values: [
      {
        signature: 'All = 0',
        summary: 'All modes are allowed.'
      },
      {
        signature: 'Corner = 1',
        summary: 'The base rectangle is created by picking the two corner points.'
      },
      {
        signature: 'ThreePoint = 2',
        summary: 'The base rectangle is created by picking three points.'
      },
      {
        signature: 'Vertical = 3',
        summary: 'The base vertical rectangle is created by picking three points.'
      },
      {
        signature: 'Center = 4',
        summary: 'The base rectangle is created by picking a center point and a corner point.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input',
    name: 'GetResult',
    dataType: 3,
    summary: 'Possible results from GetObject.Get(), GetPoint.Get(), etc...',
    values: [
      {
        signature: 'NoResult = 0'
      },
      {
        signature: 'Cancel = 1',
        summary: 'User wants to cancel current command.'
      },
      {
        signature: 'Nothing = 2',
        summary: 'User pressed enter - typically used to accept defaults.'
      },
      {
        signature: 'Option = 3',
        summary: 'User specified an option - call Option() to get option index.'
      },
      {
        signature: 'Number = 4',
        summary: 'User entered a real number - call Number() to get value.'
      },
      {
        signature: 'Color = 5',
        summary: 'User entered a color - call Color() to get value.'
      },
      {
        signature: 'Undo = 6',
        summary: 'User pressed undo.'
      },
      {
        signature: 'Miss = 7',
        summary: 'User clicked and missed.'
      },
      {
        signature: 'Point = 8',
        summary: 'User picked 3d point - call Point() to get 3d point.'
      },
      {
        signature: 'Point2d = 9',
        summary: `User picked 2d window point in CRhinoGetPoint::Get2dPoint()
    call ON_2dPoint() to get the point and View() to get the view.`
      },
      {
        signature: 'Line2d = 10',
        summary: `User picked a 2d line in CRhinoGetPoint::Get2dLine() call Line2d()
    to get the line and View() to get the view.`
      },
      {
        signature: 'Rectangle2d = 11',
        summary: `User picked a 2d rectangle in CRhinoGetPoint::Get2dRectangle() call
    Rectangle2d() to get the rectangle and View() to get the view.`
      },
      {
        signature: 'Object = 12',
        summary: 'User selected an object - call Object() to get object.'
      },
      {
        signature: 'String = 13',
        summary: 'User typed a string - call String() to get the string.'
      },
      {
        signature: 'CustomMessage = 14',
        summary: 'A custom message was posted to the RhinoGet'
      },
      {
        signature: 'Timeout = 15',
        summary: `The getter waited for the amount of time specifed in RhinoGet::SetWaitDuration()
    and then gave up.`
      },
      {
        signature: 'Circle = 16',
        summary: 'call CRhinoGetCircle::GetCircle() to get the circle.'
      },
      {
        signature: 'Plane = 17',
        summary: 'call CRhinoGetPlane::GetPlane() to get the plane.'
      },
      {
        signature: 'Cylinder = 18',
        summary: 'call CRhinoGetCylinder::GetCylinder() to get the cylinder.'
      },
      {
        signature: 'Sphere = 19',
        summary: 'call CRhinoGetSphere::GetSphere() to get the sphere.'
      },
      {
        signature: 'Angle = 20',
        summary: 'call CRhinoGetAngle::Angle() to get the angle in radians (CRhinoGetAngle() returns this for typed number, too).'
      },
      {
        signature: 'Distance = 21',
        summary: 'call CRhinoGetDistance::Distance() to get the distance value.'
      },
      {
        signature: 'Direction = 22',
        summary: 'call CRhinoGetDirection::Direction() to get the direction vector.'
      },
      {
        signature: 'Frame = 23',
        summary: 'call CRhinoGetFrame::Frame() to get the frame that was picked.'
      },
      {
        signature: 'User1 = 0xFFFFFFFF'
      },
      {
        signature: 'User2 = 0xFFFFFFFE'
      },
      {
        signature: 'User3 = 0xFFFFFFFD'
      },
      {
        signature: 'User4 = 0xFFFFFFFC'
      },
      {
        signature: 'User5 = 0xFFFFFFFB'
      },
      {
        signature: 'ExitRhino = 0x0FFFFFFF',
        summary: 'Stop now, do not cleaup, just return ASAP.'
      }
    ]
  },
  {
    namespace: 'Rhino.Input',
    name: 'RhinoGet',
    dataType: 1,
    summary: `Base class for GetObject, GetPoint, GetSphere, etc.
   
   You will never directly create a RhinoGet but you will use its member
   functions after calling GetObject::GetObjects(), GetPoint::GetPoint(), and so on.
   
   Provides tools to set command prompt, set command options, and specify
   if the "get" can optionally accept numbers, nothing (pressing enter),
   and undo.`,
    properties: [
      {
        signature: 'static BitmapFileTypes AllBitmapFileTypes',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Result Get2dRectangle(bool solidPen,Rectangle rectangle,RhinoView rectView)',
        summary: 'Gets a rectangle in view window coordinates.',
        since: 5,
        parameters: [
          {
            name: 'solidPen',
            summary: `If true, a solid pen is used for drawing while the user selects a rectangle.
     If false, a dotted pen is used for drawing while the user selects a rectangle.`
          },
          {
            name: 'rectangle',
            summary: 'user selected rectangle in window coordinates.'
          },
          {
            name: 'rectView',
            summary: 'view that the user selected the window in.'
          }
        ],
        returns: 'Success or Cancel.'
      },
      {
        signature: 'static Result GetAngle(string commandPrompt,Point3d basePoint,Point3d referencePoint,double defaultAngleRadians,double angleRadians)',
        summary: 'Allows user to interactively pick an angle',
        since: 5.2,
        parameters: [
          {
            name: 'commandPrompt',
            summary: 'if null, a default prompt will be displayed'
          },
          {
            name: 'basePoint',
            summary: ''
          },
          {
            name: 'referencePoint',
            summary: ''
          },
          {
            name: 'defaultAngleRadians',
            summary: ''
          },
          {
            name: 'angleRadians',
            summary: ''
          }
        ]
      },
      {
        signature: 'static Result GetArc(Arc arc)',
        since: 5
      },
      {
        signature: 'static Result GetBool(string prompt,bool acceptNothing,string offPrompt,string onPrompt,bool boolValue)',
        summary: 'Easy to use bool getter.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'Command prompt.'
          },
          {
            name: 'acceptNothing',
            summary: 'If true, the user can press enter.'
          },
          {
            name: 'offPrompt',
            summary: 'The \'false/off\' message.'
          },
          {
            name: 'onPrompt',
            summary: 'The \'true/on\' message.'
          },
          {
            name: 'boolValue',
            summary: 'Default bool value set to this and returned here.'
          }
        ],
        returns: `The getter result based on user choice.
     Commands.Result.Success - got value.Commands.Result.Nothing - user pressed enter.Commands.Result.Cancel - user cancelled value getting.`
      },
      {
        signature: 'static Result GetBox(Box box)',
        summary: 'Asks the user to select a Box in the viewport.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'If the result is Success, this parameter will be filled out.'
          }
        ],
        returns: 'Commands.Result.Success if successful.'
      },
      {
        signature: 'static Result GetBox(Box box,GetBoxMode mode,Point3d basePoint,string prompt1,string prompt2,string prompt3)',
        summary: 'Asks the user to select a Box in the viewport.',
        since: 5,
        parameters: [
          {
            name: 'box',
            summary: 'If the result is Success, this parameter will be filled out.'
          },
          {
            name: 'mode',
            summary: 'A particular "get box" mode, or GetBoxMode.All.'
          },
          {
            name: 'basePoint',
            summary: 'Optional base point. Supply Point3d.Unset if you don\'t want to use this.'
          },
          {
            name: 'prompt1',
            summary: 'Optional first prompt. Supply None to use the default prompt.'
          },
          {
            name: 'prompt2',
            summary: 'Optional second prompt. Supply None to use the default prompt.'
          },
          {
            name: 'prompt3',
            summary: 'Optional third prompt. Supply None to use the default prompt.'
          }
        ],
        returns: 'Commands.Result.Success if successful.'
      },
      {
        signature: 'static Result GetBoxWithCounts(int xMin,int xCount,int yMin,int yCount,int zMin,int zCount,Point3d[] corners)',
        summary: 'Gets a 3d box with prompts for counts in X, Y and Z directions.',
        since: 6,
        parameters: [
          {
            name: 'xMin',
            summary: 'Minimum value allowed for count in the x direction.'
          },
          {
            name: 'xCount',
            summary: 'Count in the x direction.'
          },
          {
            name: 'yMin',
            summary: 'Minimum value allowed for count in the y direction.'
          },
          {
            name: 'yCount',
            summary: 'Count in the y direction.'
          },
          {
            name: 'zMin',
            summary: 'Minimum value allowed for count in the z direction.'
          },
          {
            name: 'zCount',
            summary: 'Count in the z direction.'
          },
          {
            name: 'corners',
            summary: 'corners of the bottom rectangle in counter-clockwise order, followed by top recatngle.'
          }
        ],
        returns: 'Commands.Result.Success if successful.'
      },
      {
        signature: 'static Result GetCircle(Circle circle)',
        since: 5
      },
      {
        signature: 'static Result GetColor(string prompt,bool acceptNothing,Color color)',
        summary: 'Easy to use color getter.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'Command prompt.'
          },
          {
            name: 'acceptNothing',
            summary: 'If true, the user can press enter.'
          },
          {
            name: 'color',
            summary: 'Color value returned here. also used as default color.'
          }
        ],
        returns: 'Commands.Result.Success - got color.Commands.Result.Nothing - user pressed enter.Commands.Result.Cancel - user cancel color getting.'
      },
      {
        signature: 'static string GetFileName(GetFileNameMode mode,string defaultName,string title,object parent)',
        since: 6
      },
      {
        signature: 'static string GetFileName(GetFileNameMode mode,string defaultName,string title,object parent,BitmapFileTypes fileTypes)',
        since: 6
      },
      {
        signature: 'static string GetFileNameScripted(GetFileNameMode mode,string defaultName)',
        since: 5
      },
      {
        signature: 'static Result GetGrip(GripObject grip,string prompt)',
        since: 5
      },
      {
        signature: 'static Result GetGrips(GripObject[] grips,string prompt)',
        since: 5
      },
      {
        signature: 'static Result GetHelix(NurbsCurve helix)',
        since: 5
      },
      {
        signature: 'static Result GetInteger(string prompt,bool acceptNothing,int outputNumber)',
        summary: 'Easy to use number getter.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'command prompt.'
          },
          {
            name: 'acceptNothing',
            summary: 'if true, the user can press enter.'
          },
          {
            name: 'outputNumber',
            summary: 'default number is set to this value and number value returned here.'
          }
        ],
        returns: `Commands.Result.Success - got number
     Commands.Result.Nothing - user pressed enter
     Commands.Result.Cancel - user cancel number getting.`
      },
      {
        signature: 'static Result GetInteger(string prompt,bool acceptNothing,int outputNumber,int lowerLimit,int upperLimit)',
        summary: 'Easy to use number getter.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'The command prompt.'
          },
          {
            name: 'acceptNothing',
            summary: 'If true, the user can press enter.'
          },
          {
            name: 'outputNumber',
            summary: 'default number is set to this value and number value returned here.'
          },
          {
            name: 'lowerLimit',
            summary: 'The minimum allowed value.'
          },
          {
            name: 'upperLimit',
            summary: 'The maximum allowed value.'
          }
        ],
        returns: `Commands.Result.Success - got number
     Commands.Result.Nothing - user pressed enter
     Commands.Result.Cancel - user cancel number getting.`
      },
      {
        signature: 'static Result GetLine(Line line)',
        since: 5
      },
      {
        signature: 'static Result GetLinearDimension(LinearDimension dimension)',
        since: 5
      },
      {
        signature: 'static Result GetMultipleObjects(string prompt,bool acceptNothing,GetObjectGeometryFilter filter,ObjRef[] rhObjects)',
        summary: 'Easy to use object getter for getting multiple objects.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'command prompt.'
          },
          {
            name: 'acceptNothing',
            summary: 'if true, the user can press enter.'
          },
          {
            name: 'filter',
            summary: 'geometry filter to use when getting objects.'
          },
          {
            name: 'rhObjects',
            summary: 'result of the get. may be null.'
          }
        ],
        returns: `Commands.Result.Success - got object
     Commands.Result.Nothing - user pressed enter
     Commands.Result.Cancel - user cancel object getting.`
      },
      {
        signature: 'static Result GetMultipleObjects(string prompt,bool acceptNothing,ObjectType filter,ObjRef[] rhObjects)',
        summary: 'Easy to use object getter for getting multiple objects.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'command prompt.'
          },
          {
            name: 'acceptNothing',
            summary: 'if true, the user can press enter.'
          },
          {
            name: 'filter',
            summary: 'geometry filter to use when getting objects.'
          },
          {
            name: 'rhObjects',
            summary: 'result of the get. may be null.'
          }
        ],
        returns: `Commands.Result.Success - got object
     Commands.Result.Nothing - user pressed enter
     Commands.Result.Cancel - user cancel object getting.`
      },
      {
        signature: 'static Result GetNumber(string prompt,bool acceptNothing,double outputNumber)',
        summary: 'Easy to use number getter.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'command prompt.'
          },
          {
            name: 'acceptNothing',
            summary: 'if true, the user can press enter.'
          },
          {
            name: 'outputNumber',
            summary: 'default number is set to this value and number value returned here.'
          }
        ],
        returns: `Commands.Result.Success - got number
     Commands.Result.Nothing - user pressed enter
     Commands.Result.Cancel - user cancel number getting.`
      },
      {
        signature: 'static Result GetNumber(string prompt,bool acceptNothing,double outputNumber,double lowerLimit,double upperLimit)',
        summary: 'Easy to use number getter.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'The command prompt.'
          },
          {
            name: 'acceptNothing',
            summary: 'If true, the user can press Enter.'
          },
          {
            name: 'outputNumber',
            summary: 'Default number is set to this value and the return number value is assigned to this variable during the call.'
          },
          {
            name: 'lowerLimit',
            summary: 'The minimum allowed value.'
          },
          {
            name: 'upperLimit',
            summary: 'The maximum allowed value.'
          }
        ],
        returns: 'Commands.Result.Success - got number.Commands.Result.Nothing - user pressed enter.Commands.Result.Cancel - user cancel number getting.'
      },
      {
        signature: 'static Result GetOneObject(string prompt,bool acceptNothing,GetObjectGeometryFilter filter,ObjRef objref)',
        summary: 'Easy to use object getter.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'command prompt.'
          },
          {
            name: 'acceptNothing',
            summary: 'if true, the user can press enter.'
          },
          {
            name: 'filter',
            summary: 'geometry filter to use when getting objects.'
          },
          {
            name: 'objref',
            summary: 'result of the get. may be null.'
          }
        ],
        returns: `Commands.Result.Success - got object
     Commands.Result.Nothing - user pressed enter
     Commands.Result.Cancel - user cancel object getting.`
      },
      {
        signature: 'static Result GetOneObject(string prompt,bool acceptNothing,ObjectType filter,ObjRef rhObject)',
        summary: 'Easy to use object getter.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'command prompt.'
          },
          {
            name: 'acceptNothing',
            summary: 'if true, the user can press enter.'
          },
          {
            name: 'filter',
            summary: 'geometry filter to use when getting objects.'
          },
          {
            name: 'rhObject',
            summary: 'result of the get. may be null.'
          }
        ],
        returns: `Commands.Result.Success - got object
     Commands.Result.Nothing - user pressed enter
     Commands.Result.Cancel - user cancel object getting.`
      },
      {
        signature: 'static Result GetPlane(Plane plane)',
        summary: 'Gets an oriented infinite plane.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'The plane result.'
          }
        ],
        returns: 'Commands.Result.Success - got plane.Commands.Result.Nothing - user pressed enter.Commands.Result.Cancel - user cancel number getting.'
      },
      {
        signature: 'static Result GetPoint(string prompt,bool acceptNothing,Point3d point)',
        summary: 'Gets a point coordinate from the document.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'Prompt to display in command line during the operation.'
          },
          {
            name: 'acceptNothing',
            summary: 'if true, the user can press enter.'
          },
          {
            name: 'point',
            summary: 'point value returned here.'
          }
        ],
        returns: `Commands.Result.Success - got point
     Commands.Result.Nothing - user pressed enter
     Commands.Result.Cancel - user cancel point getting.`
      },
      {
        signature: 'static Result GetPointOnMesh(Guid meshObjectId,string prompt,bool acceptNothing,Point3d point)',
        summary: 'Gets a point constrained to an existing mesh in the document.',
        since: 5,
        parameters: [
          {
            name: 'meshObjectId',
            summary: 'An ID of a mesh in the document.'
          },
          {
            name: 'prompt',
            summary: 'Text prompt.'
          },
          {
            name: 'acceptNothing',
            summary: 'True if nothing else should be accepted.'
          },
          {
            name: 'point',
            summary: 'A point value will be assigned to this out parameter during this call.'
          }
        ],
        returns: 'A command result based on user choice.'
      },
      {
        signature: 'static Result GetPointOnMesh(MeshObject meshObject,string prompt,bool acceptNothing,Point3d point)',
        summary: 'Gets a point constrained to an existing mesh in the document.',
        since: 5,
        parameters: [
          {
            name: 'meshObject',
            summary: 'An mesh object in the document.'
          },
          {
            name: 'prompt',
            summary: 'Text prompt.'
          },
          {
            name: 'acceptNothing',
            summary: 'True if nothing else should be accepted.'
          },
          {
            name: 'point',
            summary: 'A point value will be assigned to this out parameter during this call.'
          }
        ],
        returns: 'The command result based on user choice.'
      },
      {
        signature: 'static Result GetPolygon(int numberSides,bool inscribed,Polyline polyline)',
        since: 6
      },
      {
        signature: 'static Result GetPolyline(Polyline polyline)',
        since: 5.9
      },
      {
        signature: 'static Result GetPrintWindow(ViewCaptureSettings settings)',
        since: 6.1
      },
      {
        signature: 'static Result GetRectangle(GetBoxMode mode,Point3d firstPoint,IEnumerable<string> prompts,Point3d[] corners)',
        summary: 'Gets a 3d rectangle made up of four points.',
        since: 5,
        parameters: [
          {
            name: 'mode',
            summary: 'A get box mode.'
          },
          {
            name: 'firstPoint',
            summary: 'The first corner used. Pass Point3d.Unset if you do not want to set this.'
          },
          {
            name: 'prompts',
            summary: 'Optional prompts to display while getting points. May be null.'
          },
          {
            name: 'corners',
            summary: 'Corners of the rectangle in counter-clockwise order will be assigned to this out parameter during this call.'
          }
        ],
        returns: 'Commands.Result.Success if successful.'
      },
      {
        signature: 'static Result GetRectangle(Point3d[] corners)',
        summary: 'Gets a 3d rectangle.',
        since: 5,
        parameters: [
          {
            name: 'corners',
            summary: 'corners of the rectangle in counter-clockwise order.'
          }
        ],
        returns: 'Commands.Result.Success if successful.'
      },
      {
        signature: 'static Result GetRectangle(string firstPrompt,Point3d[] corners)',
        summary: 'Gets a 3d rectangle.',
        since: 6,
        parameters: [
          {
            name: 'firstPrompt',
            summary: ''
          },
          {
            name: 'corners',
            summary: 'corners of the rectangle in counter-clockwise order.'
          }
        ],
        returns: 'Commands.Result.Success if successful.'
      },
      {
        signature: 'static Result GetRectangleWithCounts(int xMin,int xCount,int yMin,int yCount,Point3d[] corners)',
        summary: 'Gets a 3d rectangle with prompts for counts in X and Y directions.',
        since: 6,
        parameters: [
          {
            name: 'xMin',
            summary: 'Minimum value allowed for count in the x direction.'
          },
          {
            name: 'xCount',
            summary: 'Count in the x direction.'
          },
          {
            name: 'yMin',
            summary: 'Minimum value allowed for count in the y direction.'
          },
          {
            name: 'yCount',
            summary: 'Count in the y direction.'
          },
          {
            name: 'corners',
            summary: 'corners of the rectangle in counter-clockwise order.'
          }
        ],
        returns: 'Commands.Result.Success if successful.'
      },
      {
        signature: 'static Result GetSpiral(NurbsCurve spiral)',
        since: 5
      },
      {
        signature: 'static Result GetString(string prompt,bool acceptNothing,string outputString)',
        summary: 'Easy to use string getter.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'command prompt.'
          },
          {
            name: 'acceptNothing',
            summary: 'if true, the user can press enter.'
          },
          {
            name: 'outputString',
            summary: 'default string set to this value and string value returned here.'
          }
        ],
        returns: `Commands.Result.Success - got string
     Commands.Result.Nothing - user pressed enter
     Commands.Result.Cancel - user cancel string getting.`
      },
      {
        signature: 'static Result GetView(string commandPrompt,RhinoView view)',
        summary: 'Allows the user to interactively pick a viewport.',
        since: 5,
        parameters: [
          {
            name: 'commandPrompt',
            summary: 'The command prompt during the request.'
          },
          {
            name: 'view',
            summary: `The view that the user picked.
     If the operation is successful, then this out parameter is assigned the correct view during this call.`
          }
        ],
        returns: 'The result based on user choice.'
      },
      {
        signature: 'static bool InGet(RhinoDoc doc)',
        summary: 'Returns True if the document is current in a "Get" operation.',
        since: 5,
        returns: 'True if a getter is currently active.'
      },
      {
        signature: 'static bool InGetObject(RhinoDoc doc)',
        summary: 'Returns True if currently in a GetObject.GetObjects()',
        since: 6
      },
      {
        signature: 'static bool InGetPoint(RhinoDoc doc)',
        summary: 'Returns True if currently in a GetPoint.Get()',
        since: 6
      },
      {
        signature: 'static string StringToCommandOptionName(string stringToConvert)',
        summary: `Convert some arbitrary string value to a valid command option name
     removing any invalid characters.`,
        since: 6,
        parameters: [
          {
            name: 'stringToConvert',
            summary: 'String to convert.'
          }
        ],
        returns: `Returns None if the string is None or empty or if it contains nothing
     but invalid characters.  If the converted string is one or more
     characters in length then the converted value is returned.`
      },
      {
        signature: 'static LocalizeStringPair StringToCommandOptionName(string englishString,string localizedString)',
        summary: `Convert some arbitrary string value to a valid command option name
     removing any invalid characters.`,
        since: 6,
        parameters: [
          {
            name: 'englishString',
            summary: 'English string to convert.'
          },
          {
            name: 'localizedString',
            summary: 'Optional localized string to convert.'
          }
        ],
        returns: `Returns None if the strings are None or empty or if they contain
     nothing but invalid characters.  If the converted string is one or more
     charcters in length then a LocalizeStringPair is returned
     characters the converted string values.  If the localized string is
     None or empty then the English string is used as the localized value.`
      }
    ]
  },
  {
    namespace: 'Rhino.Input',
    name: 'RhinoGet.BitmapFileTypes',
    dataType: 3,
    values: [
      {
        signature: 'bmp = 1'
      },
      {
        signature: 'jpg = 2'
      },
      {
        signature: 'pcx = 4'
      },
      {
        signature: 'png = 8'
      },
      {
        signature: 'tif = 16'
      },
      {
        signature: 'tga = 32'
      }
    ]
  },
  {
    namespace: 'Rhino.Input',
    name: 'StringParser',
    dataType: 1,
    summary: 'Parse strings to numbers, distances and angles',
    methods: [
      {
        signature: 'static int ParseAngleExpession(string expression,int start_offset,int expression_length,StringParserSettings parse_settings_in,AngleUnitSystem output_angle_unit_system,double value_out,StringParserSettings parse_results,AngleUnitSystem parsed_unit_system)',
        since: 6
      },
      {
        signature: 'static bool ParseAngleExpressionDegrees(string expression,double angle_degrees)',
        since: 6
      },
      {
        signature: 'static bool ParseAngleExpressionRadians(string expression,double angle_radians)',
        since: 6
      },
      {
        signature: 'static int ParseLengthExpession(string expression,int start_offset,int expression_length,StringParserSettings parse_settings_in,UnitSystem output_unit_system,double value_out,StringParserSettings parse_results,UnitSystem parsed_unit_system)',
        summary: `Parse a string for a length value.
     Expression can include complex expressions
     Most complex version of length parsing`,
        since: 6,
        parameters: [
          {
            name: 'expression',
            summary: '[In] The string to parse'
          },
          {
            name: 'start_offset',
            summary: '[In] Offset position in string to start parsing'
          },
          {
            name: 'expression_length',
            summary: `[In] Maximum length of string to parse.
      -1 means parse to a terminating character or end of string`
          },
          {
            name: 'parse_settings_in',
            summary: '[In] Determines what input will be parsed'
          },
          {
            name: 'output_unit_system',
            summary: '[In] Output value is returned in this unit system'
          },
          {
            name: 'value_out',
            summary: '[Out] The length value result'
          },
          {
            name: 'parse_results',
            summary: '[Out] Describes the results of the parse operation'
          },
          {
            name: 'parsed_unit_system',
            summary: `[Out] If a unit system name was found in the string, it is returned here.
      The output value is in the unit system specified in output_unit_system`
          }
        ],
        returns: 'Returns the count of characters that were parsed or 0 if the operation was unsuccesful'
      },
      {
        signature: 'static int ParseLengthExpession(string expression,StringParserSettings parse_settings_in,UnitSystem output_unit_system,double value_out)',
        summary: `Parse a string for a length value.
     Expression can include complex expressions
     Simplest version of Length parsing`,
        since: 6,
        parameters: [
          {
            name: 'expression',
            summary: '[In] The string to parse'
          },
          {
            name: 'parse_settings_in',
            summary: '[In] Determines what input will be parsed'
          },
          {
            name: 'output_unit_system',
            summary: '[In] Output value is in this unit system'
          },
          {
            name: 'value_out',
            summary: '[Out] The length value result'
          }
        ],
        returns: 'Count of characters parsed or 0 for failure'
      },
      {
        signature: 'static int ParseNumber(string expression,int max_count,StringParserSettings settings_in,StringParserSettings settings_out,double answer)',
        summary: 'Parse a string expression to get a number',
        since: 6,
        parameters: [
          {
            name: 'expression',
            summary: 'String to parse'
          },
          {
            name: 'max_count',
            summary: 'Maximum number of characters to parse'
          },
          {
            name: 'settings_in',
            summary: 'Determines what input will be parsed'
          },
          {
            name: 'settings_out',
            summary: 'Reports the results of the parse operation'
          },
          {
            name: 'answer',
            summary: 'The number result of the parse operation'
          }
        ],
        returns: `Count of characters in expression parsed
     if ParseNumber() returns 0, parse was unsuccesful`
      }
    ]
  },
  {
    namespace: 'Rhino.Input',
    name: 'StringParserSettings',
    dataType: 1,
    summary: 'Parameters for parsing strings',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'StringParserSettings()',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'static StringParserSettings DefaultParseSettings',
        summary: `- The default settings parse just about everything in
       a reasonable way.  
     - Any angle values with unspecified units will be
       treated as radians. Angles without units can be
       encountered while parsing formulas, lengths and 
       points and need to be thoughtfully considered in
       most parsing situations.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static StringParserSettings ParseSettingsDegrees',
        summary: `- The default settings parse just about everything in
       a reasonable way.
     - Any angle values with unspecified units will be
       treated as degrees.Angles without units can be
      encountered while parsing formulas, lengths and
      points and need to be thoughtfully considered in
       most parsing situations.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static StringParserSettings ParseSettingsDoubleNumber',
        summary: `- The double number settings parse and optional unary + or unary -
       and then parse a number that can be integer, decimal, or
       scientific e notation.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static StringParserSettings ParseSettingsEmpty',
        summary: `- ON_ParseSetting::FalseSettings has all parsing options
       set to false.
     - A common use of ON_ParseSettings FalseSettings is to intialize
       ON_ParseSettings classes that are used to report what happened
       during parsing.Any parsing results value set to True after
       parsing indicates that type of parsing occured.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static StringParserSettings ParseSettingsIntegerNumber',
        summary: `- The integer settings parse and optional unary + or unary - and
       then parses one or more digits.Parsing stops after the last digit.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static StringParserSettings ParseSettingsRadians',
        summary: `- The default settings parse just about everything in
       a reasonable way.
     - Any angle values with unspecified units will be
       treated as radians.Angles without units can be
       encountered while parsing formulas, lengths and
       points and need to be thoughtfully considered in
       most parsing situations.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static StringParserSettings ParseSettingsRationalNumber',
        summary: `- The rational number settings parse and optional unary + or unary -
       and then parse one or more digits.If a rational number fraction
       bar follows the last digit in the numerator, then it is parsed
       and an integer denominator is parsed.The denominator cannot
       have a unary + or - preceding the digits.Parsing stops after
       the last digit in the denominator.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static StringParserSettings ParseSettingsRealNumber',
        summary: `- The real number settings parse and optional unary + or unary -
       and then parse a number that can be integer, decimal, 
       scientific e notation or pi.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'AngleUnitSystem DefaultAngleUnitSystem',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'UnitSystem DefaultLengthUnitSystem',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseAddition',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseArcDegreesMinutesSeconds',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseArithmeticExpression',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseCommaAsDecimalPoint',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseCommaAsDigitSeparator',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseDAsExponentInScientificENotation',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseDivision',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseExplicitFormulaExpression',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseFeetInches',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseFullStopAsDecimalPoint',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseFullStopAsDigitSeparator',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseHyphenAsNumberDash',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseHyphenMinusAsNumberDash',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseIntegerDashFraction',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseLeadingWhiteSpace',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseMathFunctions',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseMultiplication',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParsePairedParentheses',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParsePi',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseRationalNumber',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseScientificENotation',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseSignificandDigitSeparators',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseSignificandFractionalPart',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseSignificandIntegerPart',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseSpaceAsDigitSeparator',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseSubtraction',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseSurveyorsNotation',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseUnaryMinus',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ParseUnaryPlus',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'uint PreferedLocaleId',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'void SetAllExpressionSettingsToFalse()',
        since: 6
      },
      {
        signature: 'void SetAllFieldsToFalse()',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'IRhinoDocObserver',
    dataType: 4,
    summary: `Implement this interface if you are a modeless interface to aid in
   handling multiple document implementations`
  },
  {
    namespace: 'Rhino',
    name: 'LengthValue.StringFormat',
    dataType: 3,
    summary: 'Formatting to apply when creating a length value from a double.',
    values: [
      {
        signature: 'ExactDecimal = 0',
        summary: 'Use exact decimal string.'
      },
      {
        signature: 'ExactProperFraction = 1',
        summary: 'If possible, use exact integer-fraction format (1.125 becomes 1-1/8).'
      },
      {
        signature: 'ExactImproperFraction = 2',
        summary: 'If possible, use exact fraction format (1.125 becomes 9/8).'
      },
      {
        signature: 'CleanDecimal = 3',
        summary: 'The value may be adjusted slightly to improve clarity (1.124999... becomes 1.125).'
      },
      {
        signature: 'CleanProperFraction = 4',
        summary: 'The value may be adjusted slightly to improve clarity (1.124999... becomes 1-1/8).'
      },
      {
        signature: 'CleanImproperFraction = 5',
        summary: 'The value may be adjusted slightly to improve clarity (1.124999... becomes 9/8).'
      }
    ]
  },
  {
    namespace: 'Rhino.NodeInCode',
    name: 'ComponentFunctionInfo',
    dataType: 1,
    summary: `Defines the base class for a function representing a component.
   This class is abstract.`,
    properties: [
      {
        signature: 'Guid ComponentGuid',
        summary: `The unique identifier of the Grasshopper component.
     It is the original developer's responsibility to ensure that this ID is unique.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Delegate Delegate',
        summary: `Returns a delegate that can be directly invoked using a list of arguments.
     This flattens trees.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'Delegate DelegateNoWarnings',
        summary: `Returns a delegate that can be directly invoked using a list of arguments.
     This flattens trees.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'Delegate DelegateTree',
        summary: `Returns a delegate that can be directly invoked using a list of arguments.
     This considers trees and simplifies single-output components.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'Delegate DelegateTreeNoWarnings',
        summary: `Returns a delegate that can be directly invoked using a list of arguments.
     This considers trees and simplifies single-output components.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Description',
        summary: 'The function description.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string FullName',
        summary: 'Returns the name of the component prefixed by, if existing, the namespace.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string FullScriptingName',
        summary: `Shows the full name of the component, including optional periods.
     Removes spaces and common operator signs.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'IReadOnlyList<string> InputDescriptions',
        summary: 'The function input parameter descriptions.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'IReadOnlyList<string> InputNames',
        summary: 'The function input parameter names.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'IReadOnlyList<bool> InputsOptional',
        summary: 'Indications for each function input parameter whether it is optional.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'IReadOnlyList<string> InputTypeNames',
        summary: 'The function input type names.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsDefault',
        summary: 'Determines if the component is a default one.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Name',
        summary: 'The function name.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Namespace',
        summary: 'The function namespace.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'IReadOnlyList<string> OutputDescriptions',
        summary: 'Grasshopper returns several items in general. This property returns the output descriptions.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'IReadOnlyList<string> OutputNames',
        summary: 'Grasshopper returns several items in general. This property returns the output names.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'IReadOnlyList<string> OutputTypeNames',
        summary: 'Grasshopper returns several items in general. This property returns the output type names.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'object[] Evaluate(IEnumerable args,bool keepTree,string[] warnings)',
        summary: `Evaluates the component with a set of arguments.
     There needs to be an argument for each input param, and each output param gives an entry in the output array.`,
        since: 6,
        parameters: [
          {
            name: 'args',
            summary: 'The arguments list. Each item is assigned to each input param, in order.'
          },
          {
            name: 'keepTree',
            summary: `A value indicating whether trees should be considered valid inputs, and should be returned.
     In this case, output variables are not simplified to common types.`
          },
          {
            name: 'warnings',
            summary: 'A possible list of warnings, or null.'
          }
        ],
        returns: 'An array of objects, each representing an output result.'
      },
      {
        signature: 'object[] Invoke(object[] args)',
        summary: `Runs Evaluate with keepTree equal to false,
     and raises an exception on the first warning.`,
        since: 7,
        parameters: [
          {
            name: 'args',
            summary: 'Arguments. One for each component input.'
          }
        ],
        returns: 'Items.'
      },
      {
        signature: 'object[] InvokeKeepTree(object[] args)',
        summary: 'Runs Evaluate with keepTree equal to True and raises an exception on the first warning.',
        since: 7,
        parameters: [
          {
            name: 'args',
            summary: 'Arguments. One for each component input.'
          }
        ],
        returns: 'Items.'
      },
      {
        signature: 'object[] InvokeKeepTreeSilenceWarnings(object[] args)',
        summary: `Runs Evaluate with keepTree equal to true,
     and discards warnings (this is a dangerous operation!).`,
        since: 7,
        parameters: [
          {
            name: 'args',
            summary: 'Arguments.'
          }
        ],
        returns: 'Array of items.'
      },
      {
        signature: 'object[] InvokeSilenceWarnings(object[] args)',
        summary: `Runs Evaluate with keepTree equal to false,
     then simplifies output with SimplifyTreeOutput and discards warnings (this is a dangerous operation!).`,
        since: 7,
        parameters: [
          {
            name: 'args',
            summary: 'Arguments. One for each component input.'
          }
        ],
        returns: 'Items.'
      },
      {
        signature: 'string ToString()',
        summary: 'Returns a string representing this function.',
        returns: 'The namespace and the name.'
      }
    ]
  },
  {
    namespace: 'Rhino.NodeInCode',
    name: 'Components',
    dataType: 1,
    summary: 'Provides access to all Grasshopper runtime components.',
    properties: [
      {
        signature: 'static NodeInCodeTable NodeInCodeFunctions',
        summary: 'Returns a collection with all component functions.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static ComponentFunctionInfo FindComponent(string fullName)',
        summary: 'Finds a component given its full name.',
        since: 6,
        parameters: [
          {
            name: 'fullName',
            summary: 'The name, including its library name and a period if it is made by a third-party.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.NodeInCode',
    name: 'NodeInCodeTable',
    dataType: 1,
    summary: 'Permits rapid access to references to all Grasshopper functions.',
    baseclass: 'DynamicObject',
    constructors: [
      {
        signature: 'NodeInCodeTable(IEnumerable<ComponentFunctionInfo> items)',
        summary: 'Instantiates the table. Users of RhinoCommon do not typically need to call this constructor.',
        since: 6,
        parameters: [
          {
            name: 'items',
            summary: 'Items.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Returns the amount of items in this table.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(ComponentFunctionInfo item)',
        summary: 'Adds, or replaces a new instance of component function information.',
        since: 6
      },
      {
        signature: 'IEnumerable<string> GetDynamicMemberNames()',
        summary: 'Returns all additional names in the table.',
        since: 6
      },
      {
        signature: 'bool TryGetIndex(GetIndexBinder binder,object[] indexes,object result)',
        summary: 'Gets the ComponentFunctionInfo at',
        since: 6,
        parameters: [
          {
            name: 'binder',
            summary: 'The binder.'
          },
          {
            name: 'indexes',
            summary: 'ONE string index.'
          },
          {
            name: 'result',
            summary: 'The bound info.'
          }
        ]
      },
      {
        signature: 'bool TryGetMember(GetMemberBinder binder,object result)',
        summary: 'Dynamically binds the table to property-like access via its item names.',
        since: 6,
        parameters: [
          {
            name: 'binder',
            summary: 'The dynamic binder.'
          },
          {
            name: 'result',
            summary: 'Returns the result.'
          }
        ]
      },
      {
        signature: 'bool TryInvokeMember(InvokeMemberBinder binder,object[] args,object result)',
        summary: 'Dynamically invokes a member of the table.',
        since: 6,
        parameters: [
          {
            name: 'binder',
            summary: 'The binder.'
          },
          {
            name: 'args',
            summary: 'The arguments.'
          },
          {
            name: 'result',
            summary: 'The result.'
          }
        ],
        returns: 'True on success.'
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'PersistentSettings',
    dataType: 1,
    summary: 'A dictionary of SettingValue items.',
    interfaces: ['ISerializable'],
    properties: [
      {
        signature: 'static PersistentSettings RhinoAppSettings',
        since: 6.14,
        property: ['get']
      },
      {
        signature: 'static string StringListRootKey',
        summary: `Adding this string to a string list when calling SetStringList will cause the ProgramData setting to
     get inserted at that location in the list.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'ICollection<string> ChildKeys',
        summary: 'Gets a collection containing the keys in the settings dictionary.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool HiddenFromUserInterface',
        summary: 'If False then values will appear in the EditOptions window',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ICollection<string> Keys',
        summary: 'Gets a collection containing the keys in the settings dictionary.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static PersistentSettings FromPlugInId(Guid pluginId)',
        since: 5
      },
      {
        signature: 'PersistentSettings AddChild(string key)',
        summary: `Call this method to add a new child key, if the key is exists then the
     existing key is returned otherwise a new empty PersistentSettings
     child key is added and the new settings are returned.`,
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: 'Key to add to the child dictionary.'
          }
        ],
        returns: `If the key is exists then the existing key is returned otherwise a new
     empty PersistentSettings child key is added and the new
     settings are returned.`
      },
      {
        signature: 'void ClearChangedFlag()',
        since: 6
      },
      {
        signature: 'bool ContainsChangedValues()',
        since: 6
      },
      {
        signature: 'bool ContainsModifiedValues(PersistentSettings allUserSettings)',
        since: 5
      },
      {
        signature: 'void DeleteChild(string key)',
        summary: 'Call this method to delete a child settings key.',
        since: 6
      },
      {
        signature: 'void DeleteItem(string key)',
        since: 5
      },
      {
        signature: 'bool GetBool(string key)',
        since: 5
      },
      {
        signature: 'bool GetBool(string key,bool defaultValue)',
        since: 5
      },
      {
        signature: 'bool GetBool(string key,bool defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'byte GetByte(string key)',
        since: 5
      },
      {
        signature: 'byte GetByte(string key,byte defaultValue)',
        since: 5
      },
      {
        signature: 'byte GetByte(string key,byte defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'char GetChar(string key)',
        since: 5
      },
      {
        signature: 'char GetChar(string key,char defaultValue)',
        since: 5
      },
      {
        signature: 'char GetChar(string key,char defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'PersistentSettings GetChild(string key)',
        summary: `Call this method to get a nested settings PersistentSettings
     instance, will throw a KeyNotFoundException exception if
     the key does not exist.`,
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: 'Key name'
          }
        ],
        returns: `Returns persistent settings for the specified key or throws an
     exception if the key is invalid.`
      },
      {
        signature: 'Color GetColor(string key)',
        since: 5
      },
      {
        signature: 'Color GetColor(string key,Color defaultValue)',
        since: 5
      },
      {
        signature: 'Color GetColor(string key,Color defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'DateTime GetDate(string key)',
        since: 5
      },
      {
        signature: 'DateTime GetDate(string key,DateTime defaultValue)',
        since: 5
      },
      {
        signature: 'DateTime GetDate(string key,DateTime defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'double GetDouble(string key)',
        since: 5
      },
      {
        signature: 'double GetDouble(string key,double defaultValue)',
        since: 5
      },
      {
        signature: 'double GetDouble(string key,double defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'T GetEnumValue(String key)',
        summary: 'Get a stored enum value using a custom key.',
        since: 5.4
      },
      {
        signature: 'T GetEnumValue(String key,T defaultValue)',
        summary: 'Gets a stored enum value using a custom key, or return default value if not found.',
        since: 5.4
      },
      {
        signature: 'T GetEnumValue(T defaultValue)',
        summary: 'Get a stored enum value, or return default value if not found',
        since: 5.4
      },
      {
        signature: 'Guid GetGuid(string key)',
        since: 6
      },
      {
        signature: 'Guid GetGuid(string key,Guid defaultValue)',
        since: 6
      },
      {
        signature: 'Guid GetGuid(string key,Guid defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'int GetInteger(string key)',
        since: 5
      },
      {
        signature: 'int GetInteger(string key,int defaultValue)',
        since: 5
      },
      {
        signature: 'int GetInteger(string key,int defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'int GetInteger(string key,int defaultValue,int bound,bool boundIsLower)',
        since: 6
      },
      {
        signature: 'int GetInteger(string key,int defaultValue,int lowerBound,int upperBound)',
        since: 6
      },
      {
        signature: 'System.Drawing.Point GetPoint(string key)',
        since: 5
      },
      {
        signature: 'System.Drawing.Point GetPoint(string key,Point defaultValue)',
        since: 5
      },
      {
        signature: 'System.Drawing.Point GetPoint(string key,Point defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'Point3d GetPoint3d(string key)',
        since: 5
      },
      {
        signature: 'Point3d GetPoint3d(string key,Point3d defaultValue)',
        since: 5
      },
      {
        signature: 'Point3d GetPoint3d(string key,Point3d defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'Rectangle GetRectangle(string key)',
        since: 5
      },
      {
        signature: 'Rectangle GetRectangle(string key,Rectangle defaultValue)',
        since: 5
      },
      {
        signature: 'Rectangle GetRectangle(string key,Rectangle defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool GetSettingIsHiddenFromUserInterface(string key)',
        summary: `Values read from all users settings files will be marked as read-only
     which will cause any future calls to Set... to fail.`,
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for which to search.'
          }
        ],
        returns: 'Returns True if the setting is read-only otherwise false.'
      },
      {
        signature: 'bool GetSettingIsHiddenFromUserInterface(string key,IEnumerable<string> legacyKeyList)',
        summary: `Values read from all users settings files will be marked as read-only
     which will cause any future calls to Set... to fail.`,
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for which to search.'
          },
          {
            name: 'legacyKeyList',
            summary: ''
          }
        ],
        returns: 'Returns True if the setting is read-only otherwise false.'
      },
      {
        signature: 'bool GetSettingIsReadOnly(string key)',
        summary: `Values read from all users settings files will be marked as read-only
     which will cause any future calls to Set... to fail.`,
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for which to search.'
          }
        ],
        returns: 'Returns True if the setting is read-only otherwise false.'
      },
      {
        signature: 'Type GetSettingType(string key)',
        summary: `Gets the type of the last value passed to Set... or Get... for the
     specified setting.`,
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for which to search.'
          }
        ],
        returns: `Type of the last value passed to Set... or Get... for the specified
     setting.`
      },
      {
        signature: 'Size GetSize(string key)',
        since: 5
      },
      {
        signature: 'Size GetSize(string key,Size defaultValue)',
        since: 5
      },
      {
        signature: 'Size GetSize(string key,Size defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'string GetString(string key)',
        since: 5
      },
      {
        signature: 'string GetString(string key,string defaultValue)',
        since: 5
      },
      {
        signature: 'string GetString(string key,string defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'KeyValuePair<string, string>[] GetStringDictionary(string key)',
        since: 6
      },
      {
        signature: 'KeyValuePair<string, string>[] GetStringDictionary(string key,KeyValuePair<string, string>[] defaultValue)'
      },
      {
        signature: 'KeyValuePair<string, string>[] GetStringDictionary(string key,KeyValuePair<string, string>[] defaultValue,IEnumerable<string> legacyKeyList)'
      },
      {
        signature: 'string[] GetStringList(string key)',
        since: 5
      },
      {
        signature: 'string[] GetStringList(string key,string[] defaultValue)',
        since: 5
      },
      {
        signature: 'string[] GetStringList(string key,string[] defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'uint GetUnsignedInteger(string key)',
        since: 5
      },
      {
        signature: 'uint GetUnsignedInteger(string key,uint defaultValue)',
        since: 5
      },
      {
        signature: 'uint GetUnsignedInteger(string key,uint defaultValue,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'EventHandler<PersistentSettingsEventArgs<T>> GetValidator(string key)',
        summary: `Provides a way to find a ready-to-use validator for the
     PersistentSetting class for the given the key, or obtaining null.`,
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The name of the setting key.'
          }
        ],
        returns: 'A valid validator, or None if no validator was found.'
      },
      {
        signature: 'void HideSettingFromUserInterface(string key)',
        since: 6
      },
      {
        signature: 'void RegisterSettingsValidator(string key,EventHandler<PersistentSettingsEventArgs<T>> validator)',
        summary: `Sets a validator for a given key.
     Note to implementers: parameter T should be one of the
     supported types for the PersistentSettings class and should match the type associated with the key.This method allows to use anonymous methods and lambda expressions.`,
        parameters: [
          {
            name: 'key',
            summary: 'The key to which to bind the validator.'
          },
          {
            name: 'validator',
            summary: 'A validator instance of your own class.'
          }
        ]
      },
      {
        signature: 'void SetBool(string key,bool value)',
        since: 5
      },
      {
        signature: 'void SetByte(string key,byte value)',
        since: 5
      },
      {
        signature: 'void SetChar(string key,char value)',
        since: 5
      },
      {
        signature: 'void SetColor(string key,Color value)',
        since: 5
      },
      {
        signature: 'void SetDate(string key,DateTime value)',
        since: 5
      },
      {
        signature: 'void SetDefault(string key,bool value)',
        since: 5
      },
      {
        signature: 'void SetDefault(string key,byte value)',
        since: 5
      },
      {
        signature: 'void SetDefault(string key,char value)',
        since: 5
      },
      {
        signature: 'void SetDefault(string key,Color value)',
        since: 5
      },
      {
        signature: 'void SetDefault(string key,DateTime value)',
        since: 5
      },
      {
        signature: 'void SetDefault(string key,double value)',
        since: 5
      },
      {
        signature: 'void SetDefault(string key,Guid value)',
        since: 6
      },
      {
        signature: 'void SetDefault(string key,int value)',
        since: 5
      },
      {
        signature: 'void SetDefault(string key,KeyValuePair<string, string>[] value)'
      },
      {
        signature: 'void SetDefault(string key,Point value)',
        since: 5
      },
      {
        signature: 'void SetDefault(string key,Point3d value)',
        since: 5
      },
      {
        signature: 'void SetDefault(string key,Rectangle value)',
        since: 5
      },
      {
        signature: 'void SetDefault(string key,Size value)',
        since: 5
      },
      {
        signature: 'void SetDefault(string key,string value)',
        since: 5
      },
      {
        signature: 'void SetDefault(string key,string[] value)',
        since: 5
      },
      {
        signature: 'void SetDouble(string key,double value)',
        since: 5
      },
      {
        signature: 'void SetEnumValue(String key,T value)',
        summary: 'Set an enum value in the settings using a custom key',
        since: 5.4
      },
      {
        signature: 'void SetEnumValue(T enumValue)',
        summary: 'Set an enum value in the settings.',
        since: 5.4
      },
      {
        signature: 'void SetGuid(string key,Guid value)',
        since: 6
      },
      {
        signature: 'void SetInteger(string key,int value)',
        since: 5
      },
      {
        signature: 'void SetPoint(string key,Point value)',
        since: 5
      },
      {
        signature: 'void SetPoint3d(string key,Point3d value)',
        since: 5
      },
      {
        signature: 'void SetRectangle(string key,Rectangle value)',
        since: 5
      },
      {
        signature: 'void SetSize(string key,Size value)',
        since: 5
      },
      {
        signature: 'void SetString(string key,string value)',
        since: 5
      },
      {
        signature: 'void SetStringDictionary(string key,KeyValuePair<string, string>[] value)'
      },
      {
        signature: 'void SetStringList(string key,string[] value)',
        summary: `Including a item with the value of StringListRootKey will cause the ProgramData value to get inserted at
     that location in the list when calling GetStringList.`,
        since: 5,
        parameters: [
          {
            name: 'key',
            summary: 'The string key.'
          },
          {
            name: 'value',
            summary: 'An array of values to set.'
          }
        ]
      },
      {
        signature: 'void SetUnsignedInteger(string key,uint value)',
        since: 5
      },
      {
        signature: 'bool TryGetBool(string key,bool value)',
        since: 5
      },
      {
        signature: 'bool TryGetBool(string key,bool value,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool TryGetByte(string key,byte value)',
        since: 5
      },
      {
        signature: 'bool TryGetByte(string key,byte value,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool TryGetChar(string key,char value)',
        since: 5
      },
      {
        signature: 'bool TryGetChar(string key,char value,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool TryGetChild(string key,PersistentSettings value)',
        summary: `Call this method to get a nested settings PersistentSettings
     instance, will return True if the key exists and value was set
     otherwise; will return False and value will be set to null.`,
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: '[in] Key name'
          },
          {
            name: 'value',
            summary: `[out] Will be set the the child settings if the key is valid otherwise
     it will be null.`
          }
        ],
        returns: `Returns True if the key exists and value was set otherwise; returns
     false.`
      },
      {
        signature: 'bool TryGetColor(string key,Color value)',
        since: 5
      },
      {
        signature: 'bool TryGetColor(string key,Color value,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool TryGetDate(string key,DateTime value)',
        since: 5
      },
      {
        signature: 'bool TryGetDate(string key,DateTime value,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool TryGetDefault(string key,bool value)',
        since: 5
      },
      {
        signature: 'bool TryGetDefault(string key,byte value)',
        since: 5
      },
      {
        signature: 'bool TryGetDefault(string key,char value)',
        since: 5
      },
      {
        signature: 'bool TryGetDefault(string key,Color value)',
        since: 5
      },
      {
        signature: 'bool TryGetDefault(string key,DateTime value)',
        since: 5
      },
      {
        signature: 'bool TryGetDefault(string key,double value)',
        since: 5
      },
      {
        signature: 'bool TryGetDefault(string key,int value)',
        since: 5
      },
      {
        signature: 'bool TryGetDefault(string key,Point3d value)',
        since: 5
      },
      {
        signature: 'bool TryGetDefault(string key,Rectangle value)',
        since: 5
      },
      {
        signature: 'bool TryGetDefault(string key,Size value)',
        since: 5
      },
      {
        signature: 'bool TryGetDefault(string key,string value)',
        since: 5
      },
      {
        signature: 'bool TryGetDefault(string key,string[] value)',
        since: 5
      },
      {
        signature: 'bool TryGetDouble(string key,double value)',
        since: 5
      },
      {
        signature: 'bool TryGetDouble(string key,double value,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool TryGetEnumValue(String key,T enumValue)',
        summary: `Attempt to get the stored value for an enum setting using a custom key. Note: the enum value ALWAYS gets assigned!
     Be sure to check for success of this method to prevent erroneous use of the value.`,
        since: 5.4,
        returns: 'True if successful'
      },
      {
        signature: 'bool TryGetGuid(string key,Guid value)',
        since: 6
      },
      {
        signature: 'bool TryGetGuid(string key,Guid value,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool TryGetInteger(string key,int value)',
        since: 5
      },
      {
        signature: 'bool TryGetInteger(string key,int value,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool TryGetPoint(string key,Point value)',
        since: 5
      },
      {
        signature: 'bool TryGetPoint(string key,Point value,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool TryGetPoint3d(string key,Point3d value)',
        since: 5
      },
      {
        signature: 'bool TryGetPoint3d(string key,Point3d value,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool TryGetRectangle(string key,Rectangle value)',
        since: 5
      },
      {
        signature: 'bool TryGetRectangle(string key,Rectangle value,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool TryGetSettingIsHiddenFromUserInterface(string key,bool value)',
        summary: `Values read from all users settings files will be marked as read-only
     which will cause any future calls to Set... to fail.`,
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for which to search.'
          },
          {
            name: 'value',
            summary: `Value will be True if the setting is read-only otherwise false.
     setting.`
          }
        ]
      },
      {
        signature: 'bool TryGetSettingIsHiddenFromUserInterface(string key,bool value,IEnumerable<string> legacyKeyList)',
        summary: `Values read from all users settings files will be marked as read-only
     which will cause any future calls to Set... to fail.`,
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for which to search.'
          },
          {
            name: 'value',
            summary: `Value will be True if the setting is read-only otherwise false.
     setting.`
          },
          {
            name: 'legacyKeyList',
            summary: ''
          }
        ]
      },
      {
        signature: 'bool TryGetSettingIsReadOnly(string key,bool value)',
        summary: `Values read from all users settings files will be marked as read-only
     which will cause any future calls to Set... to fail.`,
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for which to search.'
          },
          {
            name: 'value',
            summary: `Value will be True if the setting is read-only otherwise false.
     setting.`
          }
        ]
      },
      {
        signature: 'bool TryGetSettingType(string key,Type type)',
        summary: `Get the type of the last value passed to Set... or Get... for the
     specified setting.`,
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for which to search.'
          },
          {
            name: 'type',
            summary: `Type of the last value passed to Set... or Get... for the specified
     setting.`
          }
        ]
      },
      {
        signature: 'bool TryGetSize(string key,Size value)',
        since: 5
      },
      {
        signature: 'bool TryGetSize(string key,Size value,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool TryGetString(string key,string value)',
        since: 5
      },
      {
        signature: 'bool TryGetString(string key,string value,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool TryGetStringDictionary(string key,KeyValuePair<string, string>[] value)'
      },
      {
        signature: 'bool TryGetStringDictionary(string key,KeyValuePair<string, string>[] value,IEnumerable<string> legacyKeyList)'
      },
      {
        signature: 'bool TryGetStringList(string key,string[] value)',
        since: 5
      },
      {
        signature: 'bool TryGetStringList(string key,string[] value,IEnumerable<string> legacyKeyList)',
        since: 6
      },
      {
        signature: 'bool TryGetUnsignedInteger(string key,uint value)',
        since: 5
      },
      {
        signature: 'bool TryGetUnsignedInteger(string key,uint value,IEnumerable<string> legacyKeyList)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'PersistentSettingsConverter',
    dataType: 1,
    summary: `Used to convert string to string lists and string dictionaries and back
   to strings again.`,
    methods: [
      {
        signature: 'static bool IsStringDictionary(string s)',
        summary: `Determines if the string value is formatted as a key value pair
     string list.`,
        since: 6,
        parameters: [
          {
            name: 's',
            summary: 'String to check'
          }
        ],
        returns: 'Returns True if it is a XML key value pair list otherwise return false.'
      },
      {
        signature: 'static bool IsStringList(string s)',
        summary: 'Determines if the string value is formatted as a string list.',
        since: 6,
        parameters: [
          {
            name: 's',
            summary: 'String to check'
          }
        ],
        returns: 'Returns True if it is a XML string list otherwise return false.'
      },
      {
        signature: 'static string ToString(double value)',
        summary: 'Converts a double value to a string.',
        since: 6.1,
        parameters: [
          {
            name: 'value',
            summary: 'double value'
          }
        ],
        returns: 'Returns the double value as a settings file formatted string.'
      },
      {
        signature: 'static string ToString(KeyValuePair<string, string>[] value)',
        summary: `Converts a key value string pair array to a properly formatted string
     dictionary XML string.`,
        parameters: [
          {
            name: 'value',
            summary: 'List of string pairs to turn into a dictionary XML string.'
          }
        ],
        returns: `Returns a properly formatted XML string that represents the string
     dictionary.`
      },
      {
        signature: 'static string ToString(string[] values)',
        summary: 'Converts a string array to a properly formatted string list XML string.',
        since: 6,
        parameters: [
          {
            name: 'values',
            summary: 'List of strings to turn into a string list XML string.'
          }
        ],
        returns: `Returns a properly formatted XML string that represents the list of
     strings.`
      },
      {
        signature: 'static bool TryParseDouble(string s,double value)',
        summary: `Converts the string representation of a number to its double-precision
     floating-point number equivalent. A return value indicates whether the
     conversion succeeded or failed.
     system culture.`,
        since: 6.1,
        parameters: [
          {
            name: 's',
            summary: 'A string containing a number to convert.'
          },
          {
            name: 'value',
            summary: `When this method returns, contains the double-precision floating-point
     number equivalent of the s parameter, if the conversion succeeded, or
     zero if the conversion failed. The conversion fails if the s parameter
     is None or Empty, is not a number in a valid format, or represents a 
     number less than MinValue or greater than MaxValue. This parameter is
     passed uninitialized; any value originally supplied in result will be
     overwritten.`
          }
        ],
        returns: 'Returns True if s was converted successfully; otherwise, false..'
      },
      {
        signature: 'static bool TryParseEnum(Type type,string enumValueName,int value)',
        summary: `Converts an enum value name to its integer
     equivalent.`,
        since: 6,
        parameters: [
          {
            name: 'type',
            summary: 'The enum type'
          },
          {
            name: 'enumValueName',
            summary: 'Enum value name as string'
          },
          {
            name: 'value',
            summary: 'Output value, will get set to -1 on error'
          }
        ],
        returns: 'Returns True if the the successfully converted or False if not.'
      },
      {
        signature: 'static bool TryParseEnum(Type type,string intValueAsString,string value)',
        summary: `Converts an enum value string (integer as string) to
     a enum value name.`,
        since: 6,
        parameters: [
          {
            name: 'type',
            summary: 'The enum type'
          },
          {
            name: 'intValueAsString',
            summary: 'enum integer value as string'
          },
          {
            name: 'value',
            summary: 'Output value, will be None on error'
          }
        ],
        returns: 'Returns True if the the successfully converted or False if not.'
      },
      {
        signature: 'static bool TryParseStringDictionary(string s,KeyValuePair<string, string>[] value)',
        summary: 'Attempts to convert a string to a key value string pair array.',
        parameters: [
          {
            name: 's',
            summary: 'String to parse'
          },
          {
            name: 'value',
            summary: `Result will get copied here, if the string is None or empty then this
     will be an empty array, if there was an error parsing then this will be
     None otherwise it will be the string parsed as a key value string pair
     array.`
          }
        ],
        returns: `Returns True if the string is not empty and properly formatted as a
     key value string pair list otherwise returns false.`
      },
      {
        signature: 'static bool TryParseStringList(string s,string[] value)',
        summary: 'Attempts to convert a string to a string value list.',
        since: 6,
        parameters: [
          {
            name: 's',
            summary: 'String to parse'
          },
          {
            name: 'value',
            summary: `Result will get copied here, if the string is None or empty then this
     will be an empty list, if there was an error parsing then this will be
     None otherwise it will be the string parsed as a list.`
          }
        ],
        returns: `Returns True if the string is not empty and properly formatted as a
     string list otherwise returns false.`
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'PersistentSettingsEventArgs',
    dataType: 1,
    summary: 'Represents the persistent settings modification event arguments.',
    baseclass: 'EventArgs',
    constructors: [
      {
        signature: 'PersistentSettingsEventArgs(T currentValue,T newValue)'
      }
    ],
    properties: [
      {
        signature: 'bool Cancel',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'T CurrentValue',
        property: ['get', 'set']
      },
      {
        signature: 'T NewValue',
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'PersistentSettingsSavedEventArgs',
    dataType: 1,
    summary: 'Event argument passed to the Rhino.PlugIns.PlugIn.SettingsSaved event.',
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'PersistentSettings PlugInSettings',
        summary: 'The old PlugIn settings',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool SavedByThisRhino',
        summary: `Will be True if this instance of Rhino is writing the settings file
     or False if a different instance of Rhino has modified the settings
     file.`,
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'PersistentSettings CommandSettings(string englishCommandName)',
        summary: 'The new command settings',
        since: 6,
        parameters: [
          {
            name: 'englishCommandName',
            summary: 'English command to find settings for'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'CustomRenderSaveFileTypes',
    dataType: 1,
    methods: [
      {
        signature: 'void RegisterFileType(IEnumerable<string> extensions,string description,SaveFileHandler saveFileHandler)',
        summary: `Call this method to register a custom file save type with the render
     output window save dialog.`,
        since: 5.11,
        parameters: [
          {
            name: 'extensions',
            summary: `List of one or more file extension associated with this custom type,
     for example: hdr, hdri`
          },
          {
            name: 'description',
            summary: `File extension description which appears in the file save dialog file
     type combo box.`
          },
          {
            name: 'saveFileHandler',
            summary: ''
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'DescriptionType',
    dataType: 3,
    values: [
      {
        signature: 'Organization'
      },
      {
        signature: 'Address'
      },
      {
        signature: 'Country'
      },
      {
        signature: 'Phone'
      },
      {
        signature: 'WebSite'
      },
      {
        signature: 'Email'
      },
      {
        signature: 'UpdateUrl'
      },
      {
        signature: 'Fax'
      },
      {
        signature: 'Icon'
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'DigitizerPlugIn',
    dataType: 1,
    baseclass: 'Rhino.PlugIns.PlugIn',
    methods: [
      {
        signature: 'void SendPoint(Point3d point,MouseButton mousebuttons,bool shiftKey,bool controlKey)',
        summary: `If the digitizer is enabled, call this function to send a point to Rhino.
     Call this function as much as you like.  The digitizers that Rhino currently
     supports send a point every 15 milliseconds or so. This function should be
     called when users press or release any digitizer button.`,
        since: 6,
        parameters: [
          {
            name: 'point',
            summary: '3d point in digitizer coordinates.'
          },
          {
            name: 'mousebuttons',
            summary: 'corresponding digitizer button is down.'
          },
          {
            name: 'shiftKey',
            summary: 'True if the Shift keyboard key was pressed. Otherwise, false.'
          },
          {
            name: 'controlKey',
            summary: 'True if the Control keyboard key was pressed. Otherwise, false.'
          }
        ]
      },
      {
        signature: 'void SendRay(Ray3d ray,MouseButton mousebuttons,bool shiftKey,bool controlKey)',
        summary: `If the digitizer is enabled, call this function to send a point and direction to Rhino.
     Call this function as much as you like.  The digitizers that Rhino currently
     supports send a point every 15 milliseconds or so. This function should be
     called when users press or release any digitizer button.`,
        since: 6,
        parameters: [
          {
            name: 'ray',
            summary: '3d ray in digitizer coordinates.'
          },
          {
            name: 'mousebuttons',
            summary: 'corresponding digitizer button is down.'
          },
          {
            name: 'shiftKey',
            summary: 'True if the Shift keyboard key was pressed. Otherwise, false.'
          },
          {
            name: 'controlKey',
            summary: 'True if the Control keyboard key was pressed. Otherwise, false.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'FileExportPlugIn',
    dataType: 1,
    baseclass: 'Rhino.PlugIns.PlugIn'
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'FileImportPlugIn',
    dataType: 1,
    baseclass: 'Rhino.PlugIns.PlugIn'
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'FileTypeList',
    dataType: 1,
    constructors: [
      {
        signature: 'FileTypeList()',
        since: 5
      },
      {
        signature: 'FileTypeList(string description,string extension)',
        since: 6
      },
      {
        signature: 'FileTypeList(string description,string extension,bool showOptionsButtonInFileDialog)',
        since: 6
      }
    ],
    methods: [
      {
        signature: 'int AddFileType(string description,IEnumerable<string> extensions)',
        since: 5
      },
      {
        signature: 'int AddFileType(string description,IEnumerable<string> extensions,bool showOptionsButtonInFileDialog)',
        since: 6
      },
      {
        signature: 'int AddFileType(string description,string extension)',
        since: 5
      },
      {
        signature: 'int AddFileType(string description,string extension,bool showOptionsButtonInFileDialog)',
        since: 6
      },
      {
        signature: 'int AddFileType(string description,string extension1,string extension2)',
        since: 5
      },
      {
        signature: 'int AddFileType(string description,string extension1,string extension2,bool showOptionsButtonInFileDialog)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'LicenseBuildType',
    dataType: 3,
    summary: 'License build contentType enumerations.',
    values: [
      {
        signature: 'Unspecified = 0',
        summary: 'An unspecified build'
      },
      {
        signature: 'Release = 100',
        summary: 'A release build (e.g. commercial, education, nfr, etc.)'
      },
      {
        signature: 'Evaluation = 200',
        summary: 'A evaluation build'
      },
      {
        signature: 'Beta = 300',
        summary: 'A beta build (e.g. wip)'
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'LicenseCapabilities',
    dataType: 3,
    summary: `Controls the buttons that will appear on the license notification window
   that is displayed if a license for the requesting product is not found.
   Note, the "Close" button will always be displayed.`,
    values: [
      {
        signature: 'NoCapabilities = 0x0',
        summary: 'Only the "Close" button will be displayed'
      },
      {
        signature: 'CanBePurchased = 0x1',
        summary: 'Shows "Buy a license" button'
      },
      {
        signature: 'CanBeSpecified = 0x2',
        summary: 'OBSOLETE: Shows ""Enter a license" and "Use a Zoo" buttons. Use SupportsStandalone | SupportsZoo instead.'
      },
      {
        signature: 'CanBeEvaluated = 0x4',
        summary: 'Shows "Evaluate" button'
      },
      {
        signature: 'EvaluationIsExpired = 0x8',
        summary: 'Shows "Evaluate" button disabled'
      },
      {
        signature: 'SupportsRhinoAccounts = 0x10',
        summary: 'Supports getting a license from a Cloud Zoo / Rhino Account'
      },
      {
        signature: 'SupportsStandalone = 0x20',
        summary: 'Supports single-computer licensing'
      },
      {
        signature: 'SupportsZooPerUser = 0x40',
        summary: 'Supports getting a license from a Zoo server'
      },
      {
        signature: 'SupportsZooPerCore = 0x80',
        summary: 'Supports getting a license from a Zoo server'
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'LicenseChangedEventArgs',
    dataType: 1,
    baseclass: 'EventArgs'
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'LicenseData',
    dataType: 1,
    summary: 'Zoo plugin license data.',
    constructors: [
      {
        signature: 'LicenseData()',
        summary: 'Public constructor.',
        since: 5
      },
      {
        signature: 'LicenseData(string productLicense,string serialNumber,string licenseTitle)',
        summary: 'Public constructor',
        since: 5,
        parameters: [
          {
            name: 'productLicense',
            summary: 'License string to be saved by ZooClient'
          },
          {
            name: 'serialNumber',
            summary: 'Serial number to be displayed to end user'
          },
          {
            name: 'licenseTitle',
            summary: 'Title of license (Rhino 6.0 Evaluation)'
          }
        ]
      },
      {
        signature: 'LicenseData(string productLicense,string serialNumber,string licenseTitle,LicenseBuildType buildType)',
        summary: 'Public constructor',
        since: 5,
        parameters: [
          {
            name: 'productLicense',
            summary: 'License string to be saved by ZooClient'
          },
          {
            name: 'serialNumber',
            summary: 'Serial number to be displayed to end user'
          },
          {
            name: 'licenseTitle',
            summary: 'Title of license (Rhino 6.0 Evaluation)'
          },
          {
            name: 'buildType',
            summary: 'A LicenseBuildType value'
          }
        ]
      },
      {
        signature: 'LicenseData(string productLicense,string serialNumber,string licenseTitle,LicenseBuildType buildType,int licenseCount)',
        summary: 'Public constructor',
        since: 5,
        parameters: [
          {
            name: 'productLicense',
            summary: 'License string to be saved by ZooClient'
          },
          {
            name: 'serialNumber',
            summary: 'Serial number to be displayed to end user'
          },
          {
            name: 'licenseTitle',
            summary: 'Title of license (Rhino 6.0 Evaluation)'
          },
          {
            name: 'buildType',
            summary: 'A LicenseBuildType value'
          },
          {
            name: 'licenseCount',
            summary: 'Number of licenses represented by this string. Allows the Zoo to hand out multiple license keys when greater than 1.'
          }
        ]
      },
      {
        signature: 'LicenseData(string productLicense,string serialNumber,string licenseTitle,LicenseBuildType buildType,int licenseCount,DateTime? expirationDate)',
        summary: 'Public constructor',
        parameters: [
          {
            name: 'productLicense',
            summary: 'License string to be saved by ZooClient'
          },
          {
            name: 'serialNumber',
            summary: 'Serial number to be displayed to end user'
          },
          {
            name: 'licenseTitle',
            summary: 'Title of license (Rhino 6.0 Evaluation)'
          },
          {
            name: 'buildType',
            summary: 'A LicenseBuildType value'
          },
          {
            name: 'licenseCount',
            summary: 'Number of licenses represented by this string. Allows the Zoo to hand out multiple license keys when greater than 1.'
          },
          {
            name: 'expirationDate',
            summary: 'Date when license expires, None if license never expires.'
          }
        ]
      },
      {
        signature: 'LicenseData(string productLicense,string serialNumber,string licenseTitle,LicenseBuildType buildType,int licenseCount,DateTime? expirationDate,Icon productIcon)',
        summary: 'Public constructor',
        parameters: [
          {
            name: 'productLicense',
            summary: 'License string to be saved by ZooClient'
          },
          {
            name: 'serialNumber',
            summary: 'Serial number to be displayed to end user'
          },
          {
            name: 'licenseTitle',
            summary: 'Title of license (Rhino 6.0 Evaluation)'
          },
          {
            name: 'buildType',
            summary: 'A LicenseBuildType value'
          },
          {
            name: 'licenseCount',
            summary: 'Number of licenses represented by this string. Allows the Zoo to hand out multiple license keys when greater than 1.'
          },
          {
            name: 'expirationDate',
            summary: 'Date when license expires, None if license never expires.'
          },
          {
            name: 'productIcon',
            summary: 'Icon to display in Rhino License Options user interface when showing this license'
          }
        ]
      },
      {
        signature: 'LicenseData(string productLicense,string serialNumber,string licenseTitle,LicenseBuildType buildType,int licenseCount,DateTime? expirationDate,Icon productIcon,bool requiresOnlineValidation,bool isUpgradeFromPreviousVersion)',
        summary: 'Public constructor',
        parameters: [
          {
            name: 'productLicense',
            summary: 'License string to be saved by ZooClient'
          },
          {
            name: 'serialNumber',
            summary: 'Serial number to be displayed to end user'
          },
          {
            name: 'licenseTitle',
            summary: 'Title of license (Rhino 6.0 Evaluation)'
          },
          {
            name: 'buildType',
            summary: 'A LicenseBuildType value'
          },
          {
            name: 'licenseCount',
            summary: 'Number of licenses represented by this string. Allows the Zoo to hand out multiple license keys when greater than 1.'
          },
          {
            name: 'expirationDate',
            summary: 'Date when license expires, None if license never expires.'
          },
          {
            name: 'productIcon',
            summary: 'Icon to display in Rhino License Options user interface when showing this license'
          },
          {
            name: 'requiresOnlineValidation',
            summary: 'True if online validation server should be called with this license key; False otherwise. If true, caller must pass implementation of VerifyOnlineValidationCodeDelegate to GetLicense/AskUserForLicense'
          },
          {
            name: 'isUpgradeFromPreviousVersion',
            summary: 'True if this license key requires a previous version license; False otherwise. If true, caller must pass implementation of VerifyPreviousVersionLicenseDelegate to GetLicense/AskUserForLicense'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'LicenseBuildType BuildType',
        summary: `The build of the product that this license work with.
     When your product requests a license from the Zoo, it
     will specify one of these build types.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'DateTime? DateToExpire',
        summary: `The date and time the license is set to expire.
     This is provided by the plugin that validated the license.
     This time value should be in Coordinated Universal Time (UTC).`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string ErrorMessage',
        summary: 'Error message set by calls to callback functions',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsUpgradeFromPreviousVersion',
        summary: `Set to True if this license requires a previous version license to be entered.
     Caller must also pass VerifyPreviousVersionLicenseDelegate to GetLicense/AskUserForLicense.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int LicenseCount',
        summary: `The number of instances supported by this license.
     This is provided by the plugin that validated the license.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool LicenseExpires',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string LicenseTitle',
        summary: `The title of the license.
     This is provided by the plugin that validated the license.
     (e.g. "Rhinoceros 6.0 Commercial")`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Icon ProductIcon',
        summary: `The product's icon. This will displayed in the "license"
     page in the Options dialog. Note, this can be null.
     Note, LicenseData creates it's own copy of the icon.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string ProductLicense',
        summary: `The actual product license. 
     This is provided by the plugin that validated the license.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool RequiresOnlineValidation',
        summary: `Set to True if this license requires online validation.
     Caller must also pass VerifyOnlineValidationCodeDelegate to GetLicense/AskUserForLicense`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string SerialNumber',
        summary: `The "for display only" product license.
     This is provided by the plugin that validated the license.`,
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static bool IsNotValid(LicenseData data)',
        summary: 'Indicates whether a LicenseData object is either None or invalid.',
        since: 5
      },
      {
        signature: 'static bool IsValid(LicenseData data)',
        summary: 'Indicates whether a LicenseData object is not None and valid.',
        since: 5
      },
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'bool IsValid()',
        summary: 'Public validator.',
        since: 5
      },
      {
        signature: 'bool IsValid(bool ignoreExpirationDate)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'LicenseIdAttribute',
    dataType: 1,
    baseclass: 'Attribute',
    constructors: [
      {
        signature: 'LicenseIdAttribute(string value)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'string Value',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'LicenseLease',
    dataType: 1,
    summary: 'LicenseLease represents a lease returned from the Cloud Zoo',
    constructors: [
      {
        signature: 'LicenseLease(IntPtr unmanagedPointer)',
        since: 6
      },
      {
        signature: 'LicenseLease(string productId,string groupName,string groupId,string userName,string userId,string productTitle,string productVersion,string productEdition,string leaseId,DateTime iat,DateTime exp)',
        since: 6
      },
      {
        signature: 'LicenseLease(string productId,string groupName,string groupId,string userName,string userId,string productTitle,string productVersion,string productEdition,string leaseId,DateTime iat,DateTime exp,DateTime renewable_until)',
        since: 6.4
      }
    ],
    properties: [
      {
        signature: 'DateTime Expiration',
        summary: 'The date when this lease will expire',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string GroupId',
        summary: 'ID of Rhino Accounts group that this lease came from',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string GroupName',
        summary: 'Name of Rhino Accounts group that this lease came from',
        since: 6,
        property: ['get']
      },
      {
        signature: 'DateTime IssuedAt',
        summary: 'The date this lease was issued',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string LeaseId',
        summary: 'The ID of this lease.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string ProductEdition',
        summary: 'Edition of product that this lease is issued to. For example, "Commercial" or "Beta"',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string ProductId',
        summary: 'The ID of the product that this lease is issued to',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string ProductTitle',
        summary: 'Title of product that this lease is issued to. For example, "Rhino 6"',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string ProductVersion',
        summary: 'Version of product that this lease is issued to. For example, "6.0"',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string UserId',
        summary: 'ID of Rhino Accounts user that was logged in when this lease was obtained',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string UserName',
        summary: 'Name of Rhino Accounts user that was logged in when this lease was obtained',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'LicenseLeaseChangedEventArgs',
    dataType: 1,
    summary: 'Arguments for OnLeaseChangedDelegate',
    constructors: [
      {
        signature: 'LicenseLeaseChangedEventArgs(LicenseLease lease)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'LicenseLease Lease',
        summary: 'The lease returned by Rhino Accounts server',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'LicenseStatus',
    dataType: 1,
    summary: 'LicenseStatus class.',
    constructors: [
      {
        signature: 'LicenseStatus()',
        summary: 'Public constructor.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'LicenseBuildType BuildType',
        summary: `The build contentType of the product, where:
       100 = A release build, either commercical, education, nfr, etc.
       200 = A evaluation build
       300 = A beta build, such as a wip.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'DateTime? CheckOutExpirationDate',
        summary: `The date and time the checked out license will expire.
     Note, this is only set if m_license_type = Standalone or CloudZoo
     and if "limited license checkout" was enabled on the Zoo server in the case of Standalone.
     Note, date and time is in local time coordinates.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'DateTime? CloudZooLeaseExpiration',
        summary: 'Returns the expiration date of the lease this instance represents.',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'bool CloudZooLeaseIsValid',
        summary: 'Returns True if the Cloud Zoo Lease represented by this instance is actively being managed by the Cloud Zoo Manager; else returns false.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'DateTime? ExpirationDate',
        summary: `The date and time the license will expire.
     This value can be None if:
       1.) The license contentType is "Standalone" and the license does not expire.
       2.) The license contentType is "Network".
       3.) The license contentType is "NetworkCheckedOut" and the checkout does not expire
     Note, date and time is in local time coordinates.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string LicenseTitle',
        summary: 'The title of the license. (e.g. "Rhinoceros 6.0 Commercial")',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'LicenseType LicenseType',
        summary: 'The license contentType. (e.g. Standalone, Network, etc.)',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Guid PluginId',
        summary: 'The ID of the plug-in that owns this license information',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Icon ProductIcon',
        summary: 'The product\'s icon. Note, this can be null.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Guid ProductId',
        summary: 'The id of the product or plugin.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string RegisteredOrganization',
        summary: 'The registered organization of the product (e.g. "Robert McNeel and Associates")',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string RegisteredOwner',
        summary: 'The registered owner of the product. (e.g. "Dale Fugier")',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string SerialNumber',
        summary: 'The "for display only" product license or serial number.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'LicenseType',
    dataType: 3,
    summary: 'LicenseType enumeration.',
    values: [
      {
        signature: 'Standalone',
        summary: 'A standalone license'
      },
      {
        signature: 'Network',
        summary: 'A network license that has not been fulfilled by a Zoo'
      },
      {
        signature: 'NetworkLoanedOut',
        summary: 'A license on temporary loan from a Zoo'
      },
      {
        signature: 'NetworkCheckedOut',
        summary: 'A license on permanent check out from a Zoo'
      },
      {
        signature: 'CloudZoo',
        summary: 'A lease granted by the Cloud Zoo'
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'LicenseUtils',
    dataType: 1,
    summary: 'License Manager Utilities.',
    methods: [
      {
        signature: 'static bool AskUserForLicense(int productType,bool standAlone,object parentWindow,string textMask,ValidateProductKeyDelegate validateProductKeyDelegate,OnLeaseChangedDelegate onLeaseChangedDelegate,string product_path,string product_title,Guid pluginId,Guid licenseId,LicenseCapabilities capabilities)',
        summary: `This version of Rhino.PlugIns.LicenseUtils.AskUserForLicense
     is used by Rhino C++ plug-ins.`,
        since: 6
      },
      {
        signature: 'static bool AskUserForLicense(int productType,bool standAlone,object parentWindow,string textMask,ValidateProductKeyDelegate validateProductKeyDelegate,OnLeaseChangedDelegate onLeaseChangedDelegate,VerifyLicenseKeyDelegate verifyLicenseKeyDelegate,VerifyPreviousVersionLicenseDelegate verifyPreviousVersionLicenseKeyDelegate,string product_path,string product_title,Guid pluginId,Guid licenseId,LicenseCapabilities capabilities)',
        since: 6
      },
      {
        signature: 'static bool CheckInLicense(Guid productId)',
        summary: `Checks in a previously checked out license to
     the Zoo server from which it was checked out.`,
        since: 5,
        parameters: [
          {
            name: 'productId',
            summary: 'The Guid of the product that you want to check in.'
          }
        ],
        returns: `True if the license was checked in successful.
     False if not successful or on error.`
      },
      {
        signature: 'static bool CheckOutLicense(Guid productId)',
        summary: `Checks out a license that is on loan from a Zoo server
     on a permanent basis.`,
        since: 5,
        parameters: [
          {
            name: 'productId',
            summary: 'The Guid of the product that you want to check out.'
          }
        ],
        returns: `True if the license was checked out successful.
     False if not successful or on error.`
      },
      {
        signature: 'static bool ConvertLicense(Guid productId)',
        summary: `Converts a product license from a standalone node
     to a network node.`,
        since: 5,
        parameters: [
          {
            name: 'productId',
            summary: 'The Guid of the product that you want to check in.'
          }
        ],
        returns: `True if the license was successfully converted.
     False if not successful or on error.`
      },
      {
        signature: 'static bool DeleteLicense(Guid productId)',
        summary: 'Deletes a license along with its license file.',
        since: 6
      },
      {
        signature: 'static string Echo(string message)',
        summary: 'Test connectivity with the Zoo.',
        since: 5
      },
      {
        signature: 'static bool GetLicense(ValidateProductKeyDelegate validateProductKeyDelegate,OnLeaseChangedDelegate leaseChangedDelegate,int product_type,int capabilities,string textMask,string product_path,string product_title,Guid pluginId,Guid licenseId)',
        summary: `This version of Rhino.PlugIns.LicenseUtils.GetLicense
     is used by Rhino C++ plug-ins.`,
        since: 6
      },
      {
        signature: 'static bool GetLicense(ValidateProductKeyDelegate validateProductKeyDelegate,OnLeaseChangedDelegate leaseChangedDelegate,VerifyLicenseKeyDelegate verifyLicenseKeyDelegate,VerifyPreviousVersionLicenseDelegate verifyPreviousVersionLicenseKeyDelegate,int product_type,int capabilities,string textMask,string product_path,string product_title,Guid pluginId,Guid licenseId)',
        since: 6
      },
      {
        signature: 'static LicenseCapabilities GetLicenseCapabilities(int filter)',
        summary: 'Converts an integer to a LicenseCapabilities flag',
        since: 5.5
      },
      {
        signature: 'static LicenseStatus[] GetLicenseStatus()',
        summary: 'Returns the current status of every license for ui purposes.',
        since: 5
      },
      {
        signature: 'static int GetLicenseType(Guid productId)',
        summary: 'Returns the contentType of a specified product license',
        since: 5
      },
      {
        signature: 'static LicenseStatus GetOneLicenseStatus(Guid productid)',
        summary: 'Returns the current status of a license for ui purposes.',
        since: 5.5
      },
      {
        signature: 'static bool Initialize()',
        summary: 'Initializes the license manager.',
        since: 5
      },
      {
        signature: 'static bool IsCheckOutEnabled()',
        summary: 'Returns whether or not license checkout is enabled.',
        since: 5
      },
      {
        signature: 'static bool LicenseOptionsHandler(Guid pluginId,Guid licenseId,string productTitle,bool standAlone)',
        since: 6
      },
      {
        signature: 'static bool LoginToCloudZoo()',
        since: 6
      },
      {
        signature: 'static bool LogoutOfCloudZoo()',
        since: 6
      },
      {
        signature: 'static bool ReturnLicense(Guid productId)',
        summary: 'OBSOLETE - REMOVE WHEN POSSIBLE.',
        since: 5
      },
      {
        signature: 'static void ShowBuyLicenseUi(Guid productId)',
        since: 5.5
      },
      {
        signature: 'static bool ShowLicenseValidationUi(string cdkey)',
        summary: 'ShowLicenseValidationUi',
        since: 5
      },
      {
        signature: 'static bool ShowRhinoExpiredMessage(Mode mode,int result)',
        summary: 'Show Rhino or Beta expired message',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'LoadPlugInResult',
    dataType: 3,
    summary: 'Result of attempting to load a plug-in',
    values: [
      {
        signature: 'Success',
        summary: 'Successfully loaded'
      },
      {
        signature: 'SuccessAlreadyLoaded'
      },
      {
        signature: 'ErrorUnknown'
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'LoadReturnCode',
    dataType: 3,
    values: [
      {
        signature: 'Success = 1'
      },
      {
        signature: 'ErrorShowDialog = 0'
      },
      {
        signature: 'ErrorNoDialog = -1'
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'PlugIn',
    dataType: 1,
    properties: [
      {
        signature: 'static bool AskOnLoadProtection',
        summary: `If true, Rhino will display a warning dialog when load-protected plug-ins are attempting to load. 
     If false, load-protected plug-ins will silently not load.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'static int InstalledPlugInCount',
        summary: 'Returns the number of installed Rhino plug-ins.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Assembly Assembly',
        summary: 'Source assembly for this plug-in.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string Description',
        summary: 'Returns the description of the plug-in, as found in the plug-in\'s assembly attributes.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid Id',
        summary: 'Returns the Guid, or unique Id, of the plug-in.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid LicenseId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool LoadAtStartup',
        since: 5,
        property: ['get']
      },
      {
        signature: 'PlugInLoadTime LoadTime',
        summary: `Plug-ins are typically loaded on demand when they are first needed. You can change
     this behavior to load the plug-in at during different stages in time by overriding
     this property.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'string Name',
        summary: 'Returns the name of the plug-in, as found in the plug-in\'s assembly attributes.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'PersistentSettings Settings',
        summary: 'Persistent plug-in settings.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string SettingsDirectory',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string SettingsDirectoryAllUsers',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string Version',
        summary: 'Returns the version of the plug-in, as found in the plug-in\'s assembly attributes.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'PersistentSettings WindowPositionSettings',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static PlugIn Find(Assembly pluginAssembly)',
        summary: 'Finds the plug-in instance that was loaded from a given assembly.',
        since: 5,
        parameters: [
          {
            name: 'pluginAssembly',
            summary: `The plug-in assembly.
     You can get the assembly instance at runtime with the  instance property.`
          }
        ],
        returns: 'The assembly plug-in instance if successful. Otherwise, null.'
      },
      {
        signature: 'static PlugIn Find(Guid plugInId)',
        summary: 'Finds the plug-in instance that was loaded from a given plug-in Id.',
        since: 5.5,
        parameters: [
          {
            name: 'plugInId',
            summary: 'The plug-in Id.'
          }
        ],
        returns: 'The plug-in instance if successful. Otherwise, null.'
      },
      {
        signature: 'static void FlushSettingsSavedQueue()',
        since: 6
      },
      {
        signature: 'static string[] GetEnglishCommandNames(Guid pluginId)',
        summary: 'Gets names of all "non-test" commands for a given plug-in.',
        since: 5,
        parameters: [
          {
            name: 'pluginId',
            summary: 'The plug-in ID.'
          }
        ],
        returns: 'An array with all plug-in names. This can be empty, but not null.'
      },
      {
        signature: 'static string[] GetInstalledPlugInFolders()',
        since: 5
      },
      {
        signature: 'static string[] GetInstalledPlugInNames()',
        summary: 'Returns the names of all installed Rhino plug-ins.',
        since: 5,
        returns: 'The names if successful.'
      },
      {
        signature: 'static string[] GetInstalledPlugInNames(PlugInType typeFilter,bool loaded,bool unloaded)',
        summary: 'Gets a list of installed plug-in names.  The list can be restricted by some filters.',
        since: 5,
        parameters: [
          {
            name: 'typeFilter',
            summary: 'The enumeration flags that determine which types of plug-ins are included.'
          },
          {
            name: 'loaded',
            summary: 'True if loaded plug-ins are returned.'
          },
          {
            name: 'unloaded',
            summary: 'True if unloaded plug-ins are returned.'
          }
        ],
        returns: 'An array of installed plug-in names. This can be empty, but not null.'
      },
      {
        signature: 'static Dictionary<Guid, string> GetInstalledPlugIns()',
        since: 5
      },
      {
        signature: 'static bool GetLoadProtection(Guid pluginId,bool loadSilently)',
        summary: 'Get load protection state for a plug-in',
        since: 5.5
      },
      {
        signature: 'static PlugInInfo GetPlugInInfo(Guid pluginId)',
        summary: 'Returns detailed information about an installed Rhino plug-in.',
        since: 6,
        parameters: [
          {
            name: 'pluginId',
            summary: 'The id of the plug-in.'
          }
        ],
        returns: 'Detailed information about an installed Rhino plug-in if successful, None otherwise.'
      },
      {
        signature: 'static PersistentSettings GetPluginSettings(Guid plugInId,bool load)',
        since: 6
      },
      {
        signature: 'static Guid IdFromName(string pluginName)',
        summary: 'Gets the id of an installed plug-in giving the plug-in\'s name.',
        since: 5.5,
        parameters: [
          {
            name: 'pluginName',
            summary: 'The name of the installed plug-in.'
          }
        ],
        returns: 'The id if successful.'
      },
      {
        signature: 'static Guid IdFromPath(string pluginPath)',
        summary: 'Gets the id of an installed plug-in giving the plug-in\'s file path.',
        since: 5,
        parameters: [
          {
            name: 'pluginPath',
            summary: 'The path to the installed plug-in.'
          }
        ],
        returns: 'The id if successful.'
      },
      {
        signature: 'static void LoadComputeExtensionPlugins()',
        summary: 'Used by compute\'s startup code to load plugins that have registered custom endpoints',
        since: 7
      },
      {
        signature: 'static bool LoadPlugIn(Guid pluginId)',
        summary: 'Loads an installed plug-in.',
        since: 5,
        parameters: [
          {
            name: 'pluginId',
            summary: 'The id of the installed plug-in.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'static bool LoadPlugIn(Guid pluginId,bool loadQuietly,bool forceLoad)',
        summary: 'Loads an installed plug-in.',
        since: 6,
        parameters: [
          {
            name: 'pluginId',
            summary: 'The id of the installed plug-in.'
          },
          {
            name: 'loadQuietly',
            summary: 'Load the plug-in quietly.'
          },
          {
            name: 'forceLoad',
            summary: 'Load plug-in even if previous attempt to load has failed.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'static LoadPlugInResult LoadPlugIn(string path,Guid plugInId)',
        summary: `Attempt to load a plug-in at a path. Loaded plug-ins are remembered by
     Rhino between sessions, so this function can also be considered a plug-in
     installation routine`,
        since: 6,
        parameters: [
          {
            name: 'path',
            summary: 'full path to plug-in to attempt to load'
          },
          {
            name: 'plugInId',
            summary: `If successfull (or the plug-in is already loaded), the unique id for the
     plug-in is returned here. Guid.Empty on failure`
          }
        ]
      },
      {
        signature: 'static string NameFromPath(string pluginPath)',
        summary: 'Gets a plug-in name for an installed plug-in given the path to that plug-in.',
        since: 5,
        parameters: [
          {
            name: 'pluginPath',
            summary: 'The path of the plug-in.'
          }
        ],
        returns: 'The plug-in name.'
      },
      {
        signature: 'static string PathFromId(Guid pluginId)',
        summary: 'Gets the path to an installed plug-in given the id of that plug-in',
        since: 5.9
      },
      {
        signature: 'static string PathFromName(string pluginName)',
        summary: 'Gets the path to an installed plug-in given the name of that plug-in',
        since: 5.9
      },
      {
        signature: 'static bool PlugInExists(Guid id,bool loaded,bool loadProtected)',
        summary: 'Verifies that a Rhino plug-in is installed.',
        since: 5,
        parameters: [
          {
            name: 'id',
            summary: 'The id of the plug-in.'
          },
          {
            name: 'loaded',
            summary: 'The loaded state of the plug-in.'
          },
          {
            name: 'loadProtected',
            summary: 'The load protected state of the plug-in.'
          }
        ],
        returns: 'Returns True if the plug-in exists, or is installed.'
      },
      {
        signature: 'static void RaiseOnPlugInSettingsSavedEvent()',
        summary: `Raise any pending OnPlugInSettingsSaved events, the events are normally
     queued while a command is running and and fired while Rhino is in an
     idle state.  Calling this method will raise any pending changed events
     regardless of Rhino's current idle state or if a command is running.`,
        since: 6
      },
      {
        signature: 'static void SavePluginSettings(Guid plugInId)',
        since: 6
      },
      {
        signature: 'static void SetLoadProtection(Guid pluginId,bool loadSilently)',
        summary: 'Set load protection state for a certain plug-in',
        since: 5.5
      },
      {
        signature: 'PersistentSettings CommandSettings(string name)',
        since: 5
      },
      {
        signature: 'Commands.Command[] GetCommands()',
        summary: 'All of the commands associated with this plug-in.',
        since: 5
      },
      {
        signature: 'object GetPlugInObject()',
        since: 5
      },
      {
        signature: 'System.Drawing.Bitmap Icon(Size size)',
        summary: 'Returns the plug-in\'s icon in bitmap form.',
        since: 6,
        parameters: [
          {
            name: 'size',
            summary: 'The desired size in pixels.'
          }
        ],
        returns: 'The icon if successful, None otherwise.'
      },
      {
        signature: 'void SaveSettings()',
        summary: `Write settings to disk which will raise a SettingsSaved
     event.`,
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'PlugInDescriptionAttribute',
    dataType: 1,
    baseclass: 'Attribute',
    constructors: [
      {
        signature: 'PlugInDescriptionAttribute(DescriptionType descriptionType,string value)',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'DescriptionType DescriptionType',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string Value',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'PlugInInfo',
    dataType: 1,
    summary: 'Contains detailed information about a Rhino plug-in.',
    properties: [
      {
        signature: 'string Address',
        summary: 'Returns the address of the organization or company that created the plug-in.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string[] CommandNames',
        summary: 'Returns a plug-in\'s English command names.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Country',
        summary: 'Returns the country of the organization or company that created the plug-in.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Description',
        summary: 'Returns the plug-in\'s description.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Email',
        summary: 'Returns the email address of the organization or company that created the plug-in.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Fax',
        summary: 'Returns the fax number of the organization or company that created the plug-in.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string FileName',
        summary: 'Returns the plug-in\'s file name.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string[] FileTypeDescriptions',
        summary: 'Returns the description of supported file types for file import and file export plug-in.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string[] FileTypeExtensions',
        summary: 'Returns the file types extensions supported for file import and file export plug-in.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'Guid Id',
        summary: 'Returns the plug-in\'s Id.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsDotNet',
        summary: 'Returns True if the plug-in is based on .NET, False otherwise.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsLoaded',
        summary: 'Returns True if the plug-in is loaded, False otherwise.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Name',
        summary: 'Returns the plug-in\'s name.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Organization',
        summary: 'Returns the organization or company that created the plug-in.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Phone',
        summary: 'Returns the phone number of the organization or company that created the plug-in.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'PlugInLoadTime PlugInLoadTime',
        summary: 'Returns the plug-in\'s load time.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'PlugInType PlugInType',
        summary: 'Returns the plug-in type.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string RegistryPath',
        summary: 'Returns the plug-in\'s Windows Registry path.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool ShipsWithRhino',
        summary: 'Returns True if the plug-in ships with Rhino, False otherwise.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string UpdateUrl',
        summary: 'Returns the web site, or url, were an updated version of the plug-in can be found.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Version',
        summary: 'Returns the plug-in\'s version.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string WebSite',
        summary: 'Returns the web site, or url, of the organization or company that created the plug-in.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'System.Drawing.Bitmap Icon(Size size)',
        summary: 'Returns the plug-in\'s icon in bitmap form.',
        since: 6
      },
      {
        signature: 'bool IsLoadProtected(bool loadSilently)',
        summary: 'Returns the load protection state for a plug-in',
        since: 6,
        parameters: [
          {
            name: 'loadSilently',
            summary: 'The plug-in\'s load silently state.'
          }
        ],
        returns: 'True if the plug-in is load protected, False otherwise.'
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'PlugInLoadTime',
    dataType: 3,
    values: [
      {
        signature: 'Disabled = 0',
        summary: 'never load plug-in.'
      },
      {
        signature: 'AtStartup = 1',
        summary: 'Load when Rhino starts.'
      },
      {
        signature: 'WhenNeeded = 2',
        summary: '(default) Load the first time a plug-in command used.'
      },
      {
        signature: 'WhenNeededIgnoreDockingBars = 6',
        summary: 'Load the first time a plug-in command used NOT when restoring docking control bars.'
      },
      {
        signature: 'WhenNeededOrOptionsDialog = 10',
        summary: 'When a plug-in command is used or the options dialog is shown.'
      },
      {
        signature: 'WhenNeededOrTabbedDockBar = 18',
        summary: 'When a plug-in command is used or when a tabbed dockbar is loaded.'
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'PlugInType',
    dataType: 3,
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'Render = 1'
      },
      {
        signature: 'FileImport = 2'
      },
      {
        signature: 'FileExport = 4'
      },
      {
        signature: 'Digitizer = 8'
      },
      {
        signature: 'Utility = 16'
      },
      {
        signature: 'DisplayPipeline = 32'
      },
      {
        signature: 'DisplayEngine = 64'
      },
      {
        signature: 'Any = Render | FileImport | FileExport | Digitizer | Utility | DisplayPipeline | DisplayEngine'
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'PreviewNotification',
    dataType: 1,
    methods: [
      {
        signature: 'void NotifyIntermediateUpdate(RenderWindow rw)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'RenderPlugIn',
    dataType: 1,
    baseclass: 'Rhino.PlugIns.PlugIn',
    properties: [
      {
        signature: 'bool PerferBasicContent',
        summary: `Set to True if you would like Rhino to quickly create a basic render
     content in response to 'Create New' commands. Set to False if you would
     prefer Rhino to display the render content chooser dialog.`,
        since: 5.12,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static bool CurrentRendererSupportsFeature(RenderFeature feature)',
        since: 6.1
      },
      {
        signature: 'bool EnableAssignMaterialButton()',
        summary: `Called to enable/disable the "Material" button located on the
     "Material" tab in the Properties and Layer dialog boxes.  The default
     return value is False which will disable the button.  If the button is
     disabled then the OnAssignMaterial function is never called.`,
        since: 5.12
      },
      {
        signature: 'bool EnableCreateMaterialButton()',
        summary: `Called to enable/disable the "New" button located on the "Material" in
     the  Properties and Layer dialog boxes.  The default return value is
     False which will disable the button.  If the button is disabled then
     the OnEditMaterial function is never called.`,
        since: 5.12
      },
      {
        signature: 'bool EnableEditMaterialButton(RhinoDoc doc,Material material)',
        summary: `Called to enable/disable the "Edit" button located on the "Material" in
     the Properties and Layer dialog boxes.  The default return value is
     False  which will disable the button.  If the button is disabled then
     the OnEditMaterial function is never called.`,
        since: 5.12
      },
      {
        signature: 'List<Guid> GetRenderSettingsSections()',
        summary: 'This function returns a list of uuid for the render settings pages that should be displayed.',
        since: 6.17,
        returns: 'Return a Id list of of the Render settings sections that will be displayed'
      },
      {
        signature: 'bool OnAssignMaterial(IntPtr parent,RhinoDoc doc,Material material)',
        summary: `This function is called by the Object Properties and Layer Control
     dialogs when the "Material" button is pressed in the "Render" tab.
     This is only called if EnableAssignMaterialButton returns true.`,
        since: 5.12
      },
      {
        signature: 'bool OnCreateMaterial(IntPtr parent,RhinoDoc doc,Material material)',
        summary: `This function is called by the Object Properties and Layer Control
     dialogs when the "New" button is pressed in the "Material" tab.  This
     is only called if EnableCreateMaterialButton returns true.`,
        since: 5.12
      },
      {
        signature: 'bool OnEditMaterial(IntPtr parent,RhinoDoc doc,Material material)',
        summary: `This function is called by the Object Properties and Layer Control
     dialogs when the "Edit" button is pressed in the "Material" tab.  This
     is only called if EnableEditMaterialButton returns true. A return value
     of True means the material has been updated.`,
        since: 5.12
      },
      {
        signature: 'void RenderSettingsCustomSections(List<ICollapsibleSection> sections)',
        summary: `Override this function to provide custom sections for the render settings panel that are displayed
     when your plug-in is the current render plug-in.`,
        since: 6,
        parameters: [
          {
            name: 'sections',
            summary: 'Create your sections and return a list of them'
          }
        ]
      },
      {
        signature: 'void SunCustomSections(List<ICollapsibleSection> sections)',
        summary: `Override this function to provide custom sections for the sun panel that are displayed
     when your plug-in is the current render plug-in.`,
        since: 6,
        parameters: [
          {
            name: 'sections',
            summary: 'Create your sections and return a list of them'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'RenderPlugIn.PreviewRenderTypes',
    dataType: 3,
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'ThreeSeparateImages'
      },
      {
        signature: 'SingleImage'
      },
      {
        signature: 'Progressive'
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'RenderPlugIn.RenderFeature',
    dataType: 3,
    values: [
      {
        signature: 'Materials = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.Materials'
      },
      {
        signature: 'Environments = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.Environments'
      },
      {
        signature: 'Textures = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.Textures'
      },
      {
        signature: 'PostEffects = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.PostEffects'
      },
      {
        signature: 'Sun = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.Sun'
      },
      {
        signature: 'CustomRenderMeshes = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.CustomRenderMeshes'
      },
      {
        signature: 'Decals = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.Decals'
      },
      {
        signature: 'GroundPlane = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.GroundPlane'
      },
      {
        signature: 'SkyLight = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.SkyLight'
      },
      {
        signature: 'CustomDecalProperties = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.CustomDecalProperties'
      },
      {
        signature: 'LinearWorkflow = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.LinearWorkflow'
      },
      {
        signature: 'Exposure = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.Exposure'
      },
      {
        signature: 'ShadowOnlyGroundPlane = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.ShadowOnlyGroundPlane'
      },
      {
        signature: 'RenderBlowup = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.RenderBlowup'
      },
      {
        signature: 'RenderWindow = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.RenderWindow'
      },
      {
        signature: 'RenderInWindow = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.RenderInWindow'
      },
      {
        signature: 'FocalBlur = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.RenderFocalBlur'
      },
      {
        signature: 'RenderArctic = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.RenderArctic'
      },
      {
        signature: 'RenderViewSource  = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.RenderViewSource'
      },
      {
        signature: 'CustomSkylightEnvironment = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.CustomSkylightEnvironment'
      },
      {
        signature: 'CustomReflectionEnvironment = UnsafeNativeMethods.CRhinoRenderPlugInFeatures.CustomReflectionEnvironment'
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'ValidateResult',
    dataType: 3,
    summary: 'ValidateProductKeyDelegate result code.',
    values: [
      {
        signature: 'Success = 1',
        summary: 'The product key or license is validated successfully.'
      },
      {
        signature: 'ErrorShowMessage = 0',
        summary: `There was an error validating the product key or license, the license
     manager show an error message.`
      },
      {
        signature: 'ErrorHideMessage = -1',
        summary: `There was an error validating the product key or license. The validating
     delegate will show an error message, not the license manager.`
      }
    ]
  },
  {
    namespace: 'Rhino.PlugIns',
    name: 'WriteFileResult',
    dataType: 3,
    values: [
      {
        signature: 'Cancel = -1'
      },
      {
        signature: 'Failure = 0'
      },
      {
        signature: 'Success = 1'
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'ReadFileResult',
    dataType: 3,
    summary: 'ON::ReadFileResult reports what happened when a file read was attempted.',
    values: [
      {
        signature: 'Unset = 0',
        summary: 'No result is available.'
      },
      {
        signature: 'Completed = 1',
        summary: 'Read completed with no errors.'
      },
      {
        signature: 'CompletedWithErrors = 2',
        summary: 'Read completed with non fatal errors.'
      },
      {
        signature: 'Failed = 3',
        summary: 'Read failed.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'AsyncRenderContext',
    dataType: 1,
    summary: `\\ingroup rhino_render
   Inherit from AsyncRenderContext to be able to create asynchronous
   render engine implementations through RhinoCommon.`,
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'Thread RenderThread',
        summary: `Holder for render thread, that gets set through
     StartRenderThread()`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'RenderWindow RenderWindow',
        summary: `Handle to the RenderWindow for the instance of this class. This
     is a convenience property for implementors to use.`,
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'void JoinRenderThread()',
        summary: 'Join the render thread, then set to null;',
        since: 6
      },
      {
        signature: 'bool StartRenderThread(ThreadStart threadStart,string threadName)',
        summary: 'Start a new render thread with given function.',
        since: 6,
        parameters: [
          {
            name: 'threadStart',
            summary: 'Function to start in render thread'
          },
          {
            name: 'threadName',
            summary: 'Name for the thread'
          }
        ]
      },
      {
        signature: 'void StopRendering()',
        summary: `Override StopRendering if you need to do additional tasks besides
     having Cancel set to true.
     
     Note: you should always base.StopRendering() in your overriding
     implementation.`,
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'CachedTextureCoordinates',
    dataType: 1,
    summary: 'Used for cached texture coordinates',
    baseclass: 'Rhino.Runtime.CommonObject',
    interfaces: ['IList<Point3d>'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Number of cached coordinates.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'int Dim',
        summary: 'Coordinate dimension: 2 = UV, 3 = UVW',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'bool IsReadOnly',
        summary: 'This collection is always read-only',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Guid MappingId',
        summary: 'The texture mapping Id.',
        since: 5.1,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool Contains(Point3d item)',
        summary: 'Determines whether this collection contains a specific value.',
        since: 5.1
      },
      {
        signature: 'void CopyTo(Point3d[] array,int arrayIndex)',
        summary: `Copies the elements of the this collection to an System.Array,
     starting at a particular System.Array index.`,
        since: 5.1,
        parameters: [
          {
            name: 'array',
            summary: `The one-dimensional System.Array that is the destination of the
     elements copied from this collection. The System.Array must have
     zero-based indexing.`
          },
          {
            name: 'arrayIndex',
            summary: 'The zero-based index in array at which copying begins.'
          }
        ]
      },
      {
        signature: 'IEnumerator<Point3d> GetEnumerator()',
        summary: 'Returns an enumerator that iterates through this collection.',
        since: 5.1,
        returns: 'A enumerator that can be used to iterate through this collection.'
      },
      {
        signature: 'int IndexOf(Point3d item)',
        summary: 'Determines the index of a specific point in this collection.',
        since: 5.1,
        parameters: [
          {
            name: 'item',
            summary: 'The point (UV or UVW) to locate in this collection.'
          }
        ],
        returns: 'The index of item if found in the list; otherwise, -1.'
      },
      {
        signature: 'bool TryGetAt(int index,double u,double v,double w)',
        summary: 'Use this method to iterate the cached texture coordinate array.',
        since: 5.1,
        parameters: [
          {
            name: 'index',
            summary: 'Index for the vertex to fetch.'
          },
          {
            name: 'u',
            summary: 'Output parameter which will receive the U value.'
          },
          {
            name: 'v',
            summary: 'Output parameter which will receive the V value.'
          },
          {
            name: 'w',
            summary: `Output parameter which will receive the W value, this is only
     meaningful if Dim is 3.`
          }
        ],
        returns: 'Returns True if index is valid; otherwise returns false.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'ChangeQueue',
    dataType: 1,
    summary: `Base class for ChangeQueue.
   
   Generally used by render plugins to build interactive updating of scenes that are being rendered.`,
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'DisplayPipelineAttributes DisplayPipelineAttributes',
        summary: 'Get the DisplayPipelineAttributes if available, None otherwise',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsPreview',
        summary: `Return True if this ChangeQueue is created for preview rendering.
     
     No view was set for preview rendering.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid ViewId',
        summary: `Return view ID for a RhinoDoc based ChangeQueue.
     
     Returns Guid.Empty if no view was associated with the changequeue,
     i.e. preview rendering.`,
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static void ConvertCameraBasedLightToWorld(ChangeQueue changequeue,Light light,ViewInfo vp)',
        summary: 'Convert given (camera-based) light to a world-based light (in-place)',
        since: 6
      },
      {
        signature: 'static uint CrcFromGuid(Guid guid)',
        summary: 'Helper function to get a CRC from a Guid.',
        since: 6
      },
      {
        signature: 'bool AreViewsEqual(ViewInfo aView,ViewInfo bView)',
        summary: `Compare to ViewInfo instances and decide whether they are equal or not.
     
     If you need to change the way the comparison is done you can override
     this function and implement your custom comparison.`,
        since: 6,
        parameters: [
          {
            name: 'aView',
            summary: 'First ViewInfo to compare'
          },
          {
            name: 'bView',
            summary: 'Second ViewInfo to compare'
          }
        ],
        returns: 'True if the views are considered equal'
      },
      {
        signature: 'void CreateWorld()',
        summary: 'Calls CreateWorld with True passed.',
        since: 6
      },
      {
        signature: 'void CreateWorld(bool bFlushWhenReady)',
        summary: 'Signal the queue to do the initialisation of the queue, seeding it with the content currently available.',
        since: 6,
        parameters: [
          {
            name: 'bFlushWhenReady',
            summary: `Set to True CreateWorld should automatically flush at the end.
     Note that the Flush called when True is passed doesn't apply changes.`
          }
        ]
      },
      {
        signature: 'void Dispose()',
        summary: 'Dispose our ChangeQueue',
        since: 6
      },
      {
        signature: 'RenderEnvironment EnvironmentForid(uint crc)',
        summary: 'Get RenderEnvironment for given RenderHash',
        since: 6
      },
      {
        signature: 'uint EnvironmentIdForUsage(Usage usage)',
        summary: 'Get RenderEnvironment RenderHash for given usage.',
        since: 6
      },
      {
        signature: 'void Flush()',
        summary: `Tell the ChangeQueue to flush all collected events.
    
     This can trigger a host of Apply* calls.
     
     The following is the order in which those calls get
     made if there are changes for that specific data type:
     
     ApplyViewChange
     ApplyLinearWorkflowChanges
     ApplyDynamicObjectTransforms
     ApplyDynamicLightChanges
     ApplyRenderSettingsChanges
     ApplyEnvironmentChanges (background)
     ApplyEnvironmentChanges (refl)
     ApplyEnvironmentChanges (sky)
     ApplySkylightChanges
     ApplySunChanges
     ApplyLightChanges
     ApplyMaterialChanges
     ApplyMeshChanges
     ApplyMeshInstanceChanges
     ApplyGroundPlaneChanges
     ApplyClippingPlaneChanges`,
        since: 6
      },
      {
        signature: 'GroundPlane GetQueueGroundPlane()',
        summary: 'Get groundplane known to the queue at the time of the Flush',
        since: 6
      },
      {
        signature: 'RenderSettings GetQueueRenderSettings()',
        summary: 'Get render settings known to the queue at the time of the Flush',
        since: 6
      },
      {
        signature: 'BoundingBox GetQueueSceneBoundingBox()',
        summary: 'Get the scene bounding box',
        since: 6,
        returns: 'Scene bounding box'
      },
      {
        signature: 'Skylight GetQueueSkylight()',
        summary: 'Get skylight known to the queue at the time of the Flush',
        since: 6
      },
      {
        signature: 'Geometry.Light GetQueueSun()',
        summary: 'Get sun known to the queue at the time of the Flush',
        since: 6
      },
      {
        signature: 'ViewInfo GetQueueView()',
        summary: 'Get view known to the queue at the time of the Flush',
        since: 6,
        returns: 'ViewInfo'
      },
      {
        signature: 'RenderMaterial MaterialFromId(uint crc)',
        summary: 'Get the RenderMaterial from the ChangeQueue material cache based on RenderHash',
        since: 6,
        parameters: [
          {
            name: 'crc',
            summary: 'The RenderHash'
          }
        ],
        returns: 'RenderMaterial'
      },
      {
        signature: 'void OneShot()',
        summary: 'Call Flush() once, after that automatically dispose the queue.',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'ChangeQueue.BakingFunctions',
    dataType: 3,
    summary: 'Enumeration of functions for baking to conduct.',
    values: [
      {
        signature: 'None = 0x00',
        summary: 'No baking'
      },
      {
        signature: 'Decals = 0x01',
        summary: 'Bake decals'
      },
      {
        signature: 'ProceduralTextures = 0x02',
        summary: 'Bake procedural textures'
      },
      {
        signature: 'CustomObjectMappings = 0x04',
        summary: 'Bake custom object mappings'
      },
      {
        signature: 'WcsBasedMappings = 0x08',
        summary: 'Bake WCS-based mappings'
      },
      {
        signature: 'MultipleMappingChannels = 0x10',
        summary: 'Bake multiple mapping channels'
      },
      {
        signature: 'NoRepeatTextures = 0x20',
        summary: 'Bake no-repeat textures'
      },
      {
        signature: 'All = 0xFFFFFFFF',
        summary: 'Bake everything'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'ClippingPlane',
    dataType: 1,
    summary: 'ChangeQueue clipping plane',
    properties: [
      {
        signature: 'ObjectAttributes Attributes',
        summary: 'Get the ClippingPlaneObject for this clipping plane',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid Id',
        summary: 'Get Guid for this clipping plane',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsEnabled',
        summary: 'True if clipping plane is enabled',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Plane Plane',
        summary: 'Get the plane that represents this clipping plane',
        since: 6,
        property: ['get']
      },
      {
        signature: 'List<Guid> ViewIds',
        summary: 'Get list of View IDs this clipping plane is supposed to clip.',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'DisplayRenderSettings',
    dataType: 1,
    summary: 'ChangeQueue DisplayRenderSettings',
    properties: [
      {
        signature: 'bool CullBackFaces',
        summary: 'True if backfaces should be culled',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool ForceFlatShading',
        summary: 'True if flat shading is forced',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool SceneLightingOn',
        summary: 'True if scene lighting is enabled',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'DynamicObjectTransform',
    dataType: 1,
    summary: 'ChangeQueue DynamicObject',
    properties: [
      {
        signature: 'uint MeshInstanceId',
        summary: 'Get the mesh instance id for this dynamic object.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Transform Transform',
        summary: 'Transform for the DynamicObject',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'string ToString()',
        summary: 'String representation of DynamicObject'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'Environment',
    dataType: 1,
    summary: 'ChangeQueue environment'
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'Environment.FrameBufferFillMode',
    dataType: 3,
    summary: 'Fillmode for background',
    values: [
      {
        signature: 'None = 0',
        summary: 'None set'
      },
      {
        signature: 'DefaultColor = 1',
        summary: 'Use default color'
      },
      {
        signature: 'SolidColor',
        summary: 'Use specified solid color'
      },
      {
        signature: 'Gradient2Color',
        summary: 'Use 2-color gradient'
      },
      {
        signature: 'Gradient4Color',
        summary: 'Use 4-color gradient (colors are specified by corners)'
      },
      {
        signature: 'Bitmap',
        summary: 'Use bitmap'
      },
      {
        signature: 'Renderer',
        summary: 'Use whatever renderer chooses'
      },
      {
        signature: 'Transparent',
        summary: 'Transparent background'
      },
      {
        signature: 'Force32Bit = 0xffffffff',
        summary: 'Use 32bit color @todo verify what this means'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'GroundPlane',
    dataType: 1,
    summary: 'ChangeQueue ground plane',
    properties: [
      {
        signature: 'double Altitude',
        summary: 'Get the altitude for ground plane',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint Crc',
        summary: 'Get the checksum of this groundplane object',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool Enabled',
        summary: 'Return True if ground plane is enabled',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsShadowOnly',
        summary: 'Get True if ground plane should be shadow-only',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint MaterialId',
        summary: 'The CRC / RenderHash of the material on this ground plane',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Vector2d TextureOffset',
        summary: 'Get texture offset on the ground plane',
        since: 6,
        property: ['get']
      },
      {
        signature: 'double TextureRotation',
        summary: 'Get texture rotation on the ground plane',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Vector2d TextureScale',
        summary: 'Get texture scale on the ground plane',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'Light',
    dataType: 1,
    summary: 'ChangeQueue Light change representation',
    properties: [
      {
        signature: 'Event ChangeType',
        summary: 'Get what type of light change this represents',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Light Data',
        summary: 'Get the actual light data',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid Id',
        summary: 'Get the light object id',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint IdCrc',
        summary: 'Get CRC computed from Id',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'Light.Event',
    dataType: 3,
    summary: 'Light change type',
    values: [
      {
        signature: 'Added',
        summary: 'Light was added'
      },
      {
        signature: 'Deleted',
        summary: 'Light was deleted'
      },
      {
        signature: 'Undeleted',
        summary: 'Light was undeleted'
      },
      {
        signature: 'Modified',
        summary: 'Light was modified'
      },
      {
        signature: 'Sorted',
        summary: 'Light was sorted in LightTable'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'MappingChannel',
    dataType: 1,
    summary: 'Mapping Channel for a ChangeQueue Mesh',
    properties: [
      {
        signature: 'Transform Local',
        summary: 'Local transform for the mapping',
        since: 6,
        property: ['get']
      },
      {
        signature: 'TextureMapping Mapping',
        summary: 'Return TexturMapping for this MappingChannel',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'MappingChannelCollection',
    dataType: 1,
    summary: 'MappingChannels for a Mesh',
    properties: [
      {
        signature: 'IEnumerable<MappingChannel> Channels',
        summary: 'Enumerate all available channels in this mapping',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int Count',
        summary: 'Get count of MappingChannels in this collection',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'Material',
    dataType: 1,
    summary: 'Representation of a Material through the change queue',
    properties: [
      {
        signature: 'uint Id',
        summary: 'Get the material ID (crc)',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int MeshIndex',
        summary: 'Get mesh index',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint MeshInstanceId',
        summary: 'Get the material InstanceAncestry',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'Mesh',
    dataType: 1,
    summary: 'Representation of ChangeQueue Mesh',
    properties: [
      {
        signature: 'ObjectAttributes Attributes',
        summary: `Get object attributes of object associated to this mesh. This will be possible only 
     after returning True from ChangeQueue.ProvideOriginalObject()`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'MappingChannelCollection Mapping',
        summary: 'Get the mapping for this mesh.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RhinoObject Object',
        summary: `Get a copy of the original RhinoObject this Mesh is created from. Possible only after
     return True from ChangeQueue.ProvideOriginalObject().
     
     Access this only with a using(var o = mesh.Object) {} construct.
     
     Note that the object is free floating, i.e. not part of a document.`,
        since: 6.8,
        property: ['get']
      },
      {
        signature: 'MappingChannel SingleMapping',
        summary: 'Get texture mapping info as single mapping',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Geometry.Mesh[] GetMeshes()',
        summary: 'Get a SimpleArrayMeshPointer containing all meshes for the related Mesh',
        since: 6
      },
      {
        signature: 'Guid Id()',
        summary: 'Get the Object Guid this mesh is for.',
        since: 6,
        returns: 'Guid of parent object.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'MeshInstance',
    dataType: 1,
    summary: 'Representation of ChangeQueue MeshInstance',
    properties: [
      {
        signature: 'bool CastShadows',
        summary: 'Return True if mesh instance should cast shadows',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint GroupId',
        summary: 'Get identifier that specifies the grouping of these mesh instances - usually based on the object that this originally comprised.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint InstanceId',
        summary: 'Get the instance identifier for this mesh instance.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint MaterialId',
        summary: 'The Material CRC / RenderHash',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid MeshId',
        summary: 'Get the mesh identifier for this mesh instance.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int MeshIndex',
        summary: 'Get the mesh index for this mesh instance.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Transform OcsTransform',
        summary: 'OCS Transform for the MeshInstance (identity means no OCS, potentially just simple WCS/WCS Box)',
        since: 7,
        property: ['get']
      },
      {
        signature: 'bool ReceiveShadows',
        summary: 'Return True if mesh instance should receive shadows',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RenderMaterial RenderMaterial',
        summary: 'RenderMaterial associated with mesh instance',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Transform Transform',
        summary: 'Transform for the MeshInstance',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render.ChangeQueue',
    name: 'Skylight',
    dataType: 1,
    summary: 'ChangeQueue skylight',
    properties: [
      {
        signature: 'bool Enabled',
        summary: 'Return True if skylight is enabled',
        since: 6,
        property: ['get']
      },
      {
        signature: 'double ShadowIntensity',
        summary: 'Get shadow intensity for skylight',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool UsesCustomEnvironment',
        summary: 'Return True if skylight uses custom environment',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'string ToString()',
        summary: 'Textual representation of Skylight'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'City',
    dataType: 1,
    summary: 'City',
    properties: [
      {
        signature: 'double Latitude',
        summary: 'Gets latitude of city.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'double Longitude',
        summary: 'Gets longitude of city.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'String Name',
        summary: 'Gets name of city.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'double TimeZone',
        summary: 'Gets time zone of city.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static int Cities()',
        summary: 'Returns number of available cities.',
        since: 6,
        returns: 'City count.'
      },
      {
        signature: 'static City CityAt(int index)',
        summary: 'Returns city at given index.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'index.'
          }
        ],
        returns: 'City at index.'
      },
      {
        signature: 'static City FindNearest(double latitude,double longitude)',
        summary: 'Finds nearest city of specified input parameters.',
        since: 6,
        parameters: [
          {
            name: 'latitude',
            summary: 'latitude.'
          },
          {
            name: 'longitude',
            summary: 'longitude.'
          }
        ],
        returns: 'Nearest city.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'ContentCollectionIterator',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'ContentCollectionIterator(IntPtr pCollection)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void DeleteThis()',
        since: 6
      },
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'RenderContent First()',
        since: 6
      },
      {
        signature: 'RenderContent Next()',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'ContentUndoBlocker',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'ContentUndoBlocker()',
        summary: `Constructs a ContentUndoBlocker object inside a using block to block undo when modifying a RenderContent
     while a ContentUndoHelper is active. Alternatively - create the ContentUndoBlocker and explicitly call Dispose when you are done.`,
        since: 5.1
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5.1
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'ContentUndoHelper',
    dataType: 1,
    summary: 'Content undo helper to be used with "using {}" to enclose a block of changes.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'ContentUndoHelper(RhinoDoc doc,String description)',
        summary: `Constructs a ContentUndoHelper object inside a using block to handle undo when modifying a RenderContent
     or - alternatively - create the ContentUndoHelper and explicitly call Dispose when you are done.`,
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: ''
          },
          {
            name: 'description',
            summary: 'Undo description (which appears in the UI when undo is run)'
          }
        ]
      }
    ],
    methods: [
      {
        signature: 'bool AddContent(RenderContent content,RenderContent parent)',
        summary: 'Call this *after* adding a content. Undo will cause the content to be deleted.',
        since: 6,
        parameters: [
          {
            name: 'content',
            summary: 'Content you just added to the ContentList.'
          },
          {
            name: 'parent',
            summary: 'is the content that will become the parent of the new content, or None if the new content is being added at the top level (i.e., not a child).'
          }
        ],
        returns: 'True if the content was added.'
      },
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'bool ModifyContent(RenderContent content)',
        summary: 'Call this before modifying or deleting a content. Undo will cause the content to be restored.',
        since: 6,
        parameters: [
          {
            name: 'content',
            summary: 'Content you are about to modify.'
          }
        ],
        returns: 'True if the content was modified.'
      },
      {
        signature: 'bool TweakContent(RenderContent content,String parameterName)',
        summary: 'Call this before tweaking a single content parameter. Undo will cause the parameter to be restored.',
        since: 6,
        parameters: [
          {
            name: 'content',
            summary: 'The render content'
          },
          {
            name: 'parameterName',
            summary: 'The parameter name you are about to change.'
          }
        ],
        returns: 'True if the content was tweaked.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'ContentUuids',
    dataType: 1,
    summary: `Content Guids of RenderContent provided by the RDK SDK.
   
   These Guids can be used to check against RenderContent.TypeId.`,
    properties: [
      {
        signature: 'static Guid AdvancedDotTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid BasicEnvironmentCCI',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid BasicEnvironmentType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid BasicMaterialCCI',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid BasicMaterialType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid BitmapTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid BlendMaterialCCI',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid BlendMaterialType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid BlendTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid CompositeMaterialCCI',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid CompositeMaterialType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid CrossHatchBumpTexture',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid CubeMapTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid DefaultEnvironmentInstance',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid DefaultMaterialInstance',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid DotBumpTexture',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid DoubleSidedMaterialType',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static Guid ExposureTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid EXRTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid FBmTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid GemMaterialType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid GlassMaterialType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid GradientTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid GraniteTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid GridTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid GritBumpTexture',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid HatchBumpTexture',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid HDRTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid LeatherBumpTexture',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid MarbleTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid MaskTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid MetalMaterialType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid NoiseTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid PaintMaterialType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid PerlinMarbleTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid PerturbingTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid PhysicallyBasedMaterialType',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static Guid PictureMaterialType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid PlasterMaterialType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid PlasticMaterialType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ProjectionChangerTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid RealtimeDisplayMaterialType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ResampleTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid SimpleBitmapTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid SingleColorTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid SpeckleBumpTexture',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid StuccoTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid Texture2DCheckerTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid Texture3DCheckerTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid TextureAdjustmentTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid TileTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid TurbulenceTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid WavesTextureType',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid WoodBumpTexture',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid WoodTextureType',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'ConvertibleExtensions',
    dataType: 1,
    summary: `Extension methods for IConvertible that work when
   an object is a Variant.`,
    methods: [
      {
        signature: 'static Color4f ToColor4f(IConvertible variant)',
        since: 6
      },
      {
        signature: 'static Vector2d ToVector2d(IConvertible variant)',
        since: 6
      },
      {
        signature: 'static Vector3d ToVector3d(IConvertible variant)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'CrcRenderHashFlags',
    dataType: 3,
    values: [
      {
        signature: 'Normal                 = 0'
      },
      {
        signature: 'ExcludeLinearWorkflow  = 1'
      },
      {
        signature: 'ExcludeLocalMapping    = 2'
      },
      {
        signature: 'Reserved1              = 4'
      },
      {
        signature: 'Reserved2              = 8'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'CreatePreviewEventArgs',
    dataType: 1,
    summary: 'Used in RenderPlugIn virtual CreatePreview function',
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'bool Cancel',
        summary: 'Get set by Rhino if the preview generation should be canceled for this',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'RenderContentKind ContentKind',
        summary: 'Description of content that preview is being generated for.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid ContentTypeId',
        summary: 'The class Id of content that preview is being generated for.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RenderEnvironment Environment',
        summary: 'The environment that the previewed object is rendered in.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'int Id',
        summary: 'Unique Id for this scene.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Light> Lights',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'List<SceneObject> Objects',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'RenderContent PreviewContent',
        summary: 'Obsolete, will return always null',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Bitmap PreviewImage',
        summary: `Initially null.  If this image is set, then this image will be used for
     the preview.  If never set, the default internal simulation preview will
     be used.`,
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Size PreviewImageSize',
        summary: 'Pixel size of the image that is being requested for the preview scene',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'PreviewNotification PreviewNotifier',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'PreviewSceneQuality Quality',
        summary: 'Quality of the preview image that is being requested for the preview scene',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'CreatePreviewReason Reason',
        summary: 'Reason the preview is getting generated',
        since: 5.11,
        property: ['get']
      },
      {
        signature: 'ViewportInfo Viewport',
        since: 5.1,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void SkipInitialisation()',
        summary: `Call this if you don't want the argument to handle data initialisation.
     
     This is for use with the ChangeQueue`,
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'CreatePreviewEventArgs.SceneObject',
    dataType: 1,
    properties: [
      {
        signature: 'RenderMaterial Material',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Mesh Mesh',
        since: 5.1,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'CreatePreviewReason',
    dataType: 3,
    summary: 'Reason the content preview is being generated',
    values: [
      {
        signature: 'ContentChanged = UnsafeNativeMethods.CRhRdkPlugInQuickPreviewReason.ContentChanged'
      },
      {
        signature: 'ViewChanged = UnsafeNativeMethods.CRhRdkPlugInQuickPreviewReason.ViewChanged'
      },
      {
        signature: 'RefreshDisplay = UnsafeNativeMethods.CRhRdkPlugInQuickPreviewReason.RefreshDisplay'
      },
      {
        signature: 'UpdateBitmap = UnsafeNativeMethods.CRhRdkPlugInQuickPreviewReason.UpdateBitmap'
      },
      {
        signature: 'Other = UnsafeNativeMethods.CRhRdkPlugInQuickPreviewReason.Other'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'CreateTexture2dPreviewEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'Bitmap PreviewImage',
        summary: `Initially null.  If this image is set, then this image will be used for
     the preview.  If never set, the default internal simulation preview will
     be used.`,
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Size PreviewImageSize',
        summary: 'Pixel size of the image that is being requested for the preview scene',
        since: 5.1,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'CustomEvent',
    dataType: 1,
    summary: 'This class contains the event for CustomEvents that are fired from RDK .',
    events: [
      {
        signature: 'static OnCustomEvent',
        summary: 'This event is raised when a Custom Event is triggered in rdk.',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'CustomRenderContentAttribute',
    dataType: 1,
    baseclass: 'Attribute',
    constructors: [
      {
        signature: 'CustomRenderContentAttribute(string renderEngineGuid,bool imageBased,string category,bool is_elevated,bool is_built_in,bool is_private)',
        since: 6
      },
      {
        signature: 'CustomRenderContentAttribute(string renderEngineGuid,bool imageBased,string category,bool is_elevated,bool is_built_in,bool is_private,bool is_linear,bool is_hdrcapable,bool is_normalmap)',
        since: 6.16
      }
    ],
    properties: [
      {
        signature: 'string Category',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ImageBased',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsBuiltIn',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsElevated',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsHdrCapable',
        since: 6.16,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsLinear',
        since: 6.16,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsNormalMap',
        since: 6.16,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsPrivate',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Guid RenderEngineId',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'CustomRenderMeshProvider',
    dataType: 1,
    summary: `You must call CustomRenderMeshProvider.RegisterProviders() from your
   plug-ins OnLoad override for each assembly containing a custom mesh
   provider.  Only publicly exported classes derived from
   CustomRenderMeshProvider with a public constructor that has no parameters
   will get registered.`,
    properties: [
      {
        signature: 'static Guid CurvePipingId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid DisplacementId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid EdgeSofteningId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ShutLiningId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ThickeningId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'String Name',
        summary: 'The name of the provider for UI display.',
        since: 5.7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static void AllObjectsChanged()',
        summary: 'Call this method if your render meshes change.',
        since: 5.7
      },
      {
        signature: 'static void AllObjectsChanged(RhinoDoc doc)',
        summary: 'Call this method if your render meshes change.',
        since: 6
      },
      {
        signature: 'static void DocumentBasedMeshesChanged(RhinoDoc doc)',
        since: 6
      },
      {
        signature: 'static void ObjectChanged(RhinoDoc doc,RhinoObject obj)',
        since: 6
      },
      {
        signature: 'static void RegisterProviders(Assembly assembly,Guid pluginId)',
        summary: `Call this method once from your plug-ins OnLoad override for each
     assembly containing a custom mesh provider.  Only publicly exported
     classes derived from CustomRenderMeshProvider with a public constructor
     that has no parameters will get registered.`,
        since: 5.7,
        parameters: [
          {
            name: 'assembly',
            summary: 'Assembly to search for valid CustomRenderMeshProvider derived classes.'
          },
          {
            name: 'pluginId',
            summary: 'The plug-in that owns the custom mesh providers.'
          }
        ]
      },
      {
        signature: 'BoundingBox BoundingBox(ViewportInfo vp,RhinoObject obj,Guid requestingPlugIn,bool preview)',
        summary: 'Returns a bounding box for the custom render meshes for the given object.',
        since: 5.7,
        parameters: [
          {
            name: 'vp',
            summary: 'The viewport being rendered.'
          },
          {
            name: 'obj',
            summary: 'The Rhino object of interest.  This can be None in the case where document meshes (not associated with any object) are being requested.'
          },
          {
            name: 'requestingPlugIn',
            summary: 'UUID of the RDK plug-in requesting the meshes.'
          },
          {
            name: 'preview',
            summary: 'Type of mesh to build.'
          }
        ],
        returns: 'A bounding box value.'
      },
      {
        signature: 'BoundingBox BoundingBox(ViewportInfo vp,RhinoObject obj,RhinoDoc doc,Guid requestingPlugIn,DisplayPipelineAttributes attrs)',
        since: 6
      },
      {
        signature: 'bool BuildCustomMeshes(ViewportInfo vp,RenderPrimitiveList objMeshes,Guid requestingPlugIn,bool meshType)',
        summary: 'Build custom render mesh(es).',
        since: 5.7,
        parameters: [
          {
            name: 'vp',
            summary: 'The viewport being rendered.'
          },
          {
            name: 'objMeshes',
            summary: 'The meshes class to populate with custom meshes.'
          },
          {
            name: 'requestingPlugIn',
            summary: 'UUID of the RDK plug-in requesting the meshes.'
          },
          {
            name: 'meshType',
            summary: 'Type of mesh to build.'
          }
        ],
        returns: 'True if operation was successful.'
      },
      {
        signature: 'bool WillBuildCustomMeshes(ViewportInfo vp,RhinoObject obj,Guid requestingPlugIn,bool preview)',
        summary: 'Determines if custom render meshes will be built for a particular object.',
        since: 5.7,
        parameters: [
          {
            name: 'vp',
            summary: 'The viewport being rendered.'
          },
          {
            name: 'obj',
            summary: 'The Rhino object of interest.  This can be None in the case where document meshes (not associated with any object) are being requested.'
          },
          {
            name: 'requestingPlugIn',
            summary: 'UUID of the RDK plug-in requesting the meshes.'
          },
          {
            name: 'preview',
            summary: 'Type of mesh to build.'
          }
        ],
        returns: 'True if custom meshes will be built.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'CustomRenderMeshProvider2',
    dataType: 1,
    baseclass: 'Rhino.Render.CustomRenderMeshProvider',
    methods: [
      {
        signature: 'BoundingBox BoundingBox(ViewportInfo vp,RhinoObject obj,Guid requestingPlugIn,bool preview)',
        since: 6.4
      },
      {
        signature: 'BoundingBox BoundingBox(ViewportInfo vp,RhinoObject obj,RhinoDoc doc,Guid requestingPlugIn,DisplayPipelineAttributes attrs)',
        since: 6
      },
      {
        signature: 'bool BuildCustomMeshes(ViewportInfo vp,RenderPrimitiveList objMeshes,Guid requestingPlugIn,bool preview)',
        since: 6.4
      },
      {
        signature: 'bool BuildCustomMeshes(ViewportInfo vp,RhinoDoc doc,RenderPrimitiveList objMeshes,Guid requestingPlugIn,DisplayPipelineAttributes attrs)',
        since: 6
      },
      {
        signature: 'bool WillBuildCustomMeshes(ViewportInfo vp,RhinoObject obj,Guid requestingPlugIn,bool preview)',
        since: 6.4
      },
      {
        signature: 'bool WillBuildCustomMeshes(ViewportInfo vp,RhinoObject obj,RhinoDoc doc,Guid requestingPlugIn,DisplayPipelineAttributes attrs)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'AssignBys',
    dataType: 3,
    values: [
      {
        signature: 'Unset'
      },
      {
        signature: 'Layer'
      },
      {
        signature: 'Parent'
      },
      {
        signature: 'Object'
      },
      {
        signature: 'Varies'
      },
      {
        signature: 'PlugIn'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'ContentDatabaseEventInfo.AttachReason',
    dataType: 3,
    values: [
      {
        signature: 'Attach'
      },
      {
        signature: 'Change'
      },
      {
        signature: 'Undo'
      },
      {
        signature: 'Open'
      },
      {
        signature: 'Edit'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'ContentDatabaseEventInfo.DetachReason',
    dataType: 3,
    values: [
      {
        signature: 'Detach'
      },
      {
        signature: 'Change'
      },
      {
        signature: 'Undo'
      },
      {
        signature: 'Delete'
      },
      {
        signature: 'Edit'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'ContentDatabaseEventInfo.Types',
    dataType: 3,
    values: [
      {
        signature: 'Attached'
      },
      {
        signature: 'Detaching'
      },
      {
        signature: 'Detached'
      },
      {
        signature: 'Replacing'
      },
      {
        signature: 'Replaced'
      },
      {
        signature: 'Blossom'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'ContentEditorSettings.Layouts',
    dataType: 3,
    values: [
      {
        signature: 'Horizontal'
      },
      {
        signature: 'Vertical'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'ContentEditorSettings.Splitters',
    dataType: 3,
    values: [
      {
        signature: 'HA'
      },
      {
        signature: 'HB'
      },
      {
        signature: 'HC'
      },
      {
        signature: 'VA'
      },
      {
        signature: 'VB'
      },
      {
        signature: 'VC'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'ContentFactories',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'ContentFactories(IntPtr pRdkContentFactories)',
        since: 6.1
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6.1,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 6.1
      },
      {
        signature: 'ContentFactory FindFactory(Guid uuid)',
        since: 6.7
      },
      {
        signature: 'ContentFactory FirstFactory()',
        since: 6.1
      },
      {
        signature: 'ContentFactory NextFactory()',
        since: 6.1
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'ContentFactory',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'ContentFactory(IntPtr pRdkContentFactory)',
        since: 6.1
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6.1,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Guid ContentTypeId()',
        since: 6.7
      },
      {
        signature: 'void Dispose()',
        since: 6.1
      },
      {
        signature: 'RenderContentKind Kind()',
        since: 6.3
      },
      {
        signature: 'RenderContent NewContent()',
        summary: `New Content returns a new content, which is Initialized with the Initialize() function.
     The content should be unitilized after use with the Unitialize function.`,
        since: 6.1
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'ContentParamEventInfo.Types',
    dataType: 3,
    values: [
      {
        signature: 'Name'
      },
      {
        signature: 'Notes'
      },
      {
        signature: 'Tags'
      },
      {
        signature: 'GroupId'
      },
      {
        signature: 'Param'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'DecalEventInfo.Operations',
    dataType: 3,
    values: [
      {
        signature: 'Add'
      },
      {
        signature: 'Delete'
      },
      {
        signature: 'Modify'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'MetaData',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'MetaData(IntPtr pMetaData)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Guid ContentInstanceId()',
        since: 6.7
      },
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'string Geometry()',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'Modes',
    dataType: 3,
    values: [
      {
        signature: 'Unset'
      },
      {
        signature: 'Grid'
      },
      {
        signature: 'List'
      },
      {
        signature: 'Tree'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'NamedItemCommand.States',
    dataType: 3,
    values: [
      {
        signature: 'Off = UnsafeNativeMethods.NamedItemCommand_States.Off'
      },
      {
        signature: 'On = UnsafeNativeMethods.NamedItemCommand_States.On'
      },
      {
        signature: 'Varies = UnsafeNativeMethods.NamedItemCommand_States.Varies'
      },
      {
        signature: 'Unknown = UnsafeNativeMethods.NamedItemCommand_States.Unknown'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'NamedItems.CommandFilters',
    dataType: 3,
    values: [
      {
        signature: 'ToolButton = UnsafeNativeMethods.NamedItems_CommandFilters.ToolButton'
      },
      {
        signature: 'MenuItem = UnsafeNativeMethods.NamedItems_CommandFilters.MenuItem'
      },
      {
        signature: 'CheckBox = UnsafeNativeMethods.NamedItems_CommandFilters.CheckBox'
      },
      {
        signature: 'All = UnsafeNativeMethods.NamedItems_CommandFilters.All'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'NamedItems.DisplayModes',
    dataType: 3,
    values: [
      {
        signature: 'List = UnsafeNativeMethods.NamedItems_DisplayMode.List'
      },
      {
        signature: 'Thumbnail = UnsafeNativeMethods.NamedItems_DisplayMode.Thumbnail'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'ParamBlock.UiHints',
    dataType: 3,
    values: [
      {
        signature: 'None'
      },
      {
        signature: 'Folder'
      },
      {
        signature: 'Filename'
      },
      {
        signature: 'Combo'
      },
      {
        signature: 'Solar'
      },
      {
        signature: 'Location'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'RdkEdit',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'RdkEdit(IntPtr pRdkEdit)',
        since: 6.5
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6.5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 6.5
      },
      {
        signature: 'bool Execute(RenderContentCollection collection)',
        since: 6.5
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'RdkModalEditContentBucket',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'RdkModalEditContentBucket(IntPtr pRdkModalEditContentBucket)',
        since: 6.5
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6.5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'RenderContentCollection ContentsIn()',
        since: 6.5
      },
      {
        signature: 'void Dispose()',
        since: 6.5
      },
      {
        signature: 'void SetContentsOut(RenderContentCollection collection)',
        since: 6.5
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'RdkSelectionNavigator',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'RdkSelectionNavigator(IntPtr pRhinoSettings)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(RenderContentCollection selectedContentArray)',
        summary: `Add a selection of contents at the current position.
   Clears the navigator ahead of the current position.`,
        since: 6,
        parameters: [
          {
            name: 'selectedContentArray',
            summary: 'The selected content'
          }
        ]
      },
      {
        signature: 'bool CanGoBackwards()',
        summary: 'Check the backwards status of the navigator',
        since: 6,
        returns: 'True if it is possible to navigate backwards, else false'
      },
      {
        signature: 'bool CanGoForwards()',
        summary: 'Check the forwards status of the navigator',
        since: 6,
        returns: 'True if it is possible to navigate forwards, else false'
      },
      {
        signature: 'void Clear()',
        summary: 'Clear the navigator.',
        since: 6
      },
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'bool GoBackwards(RenderContentCollection selectedContentArray)',
        summary: 'Navigate backwards if possible',
        since: 6,
        parameters: [
          {
            name: 'selectedContentArray',
            summary: 'selectedContentArray is the new selection after navigating backwards'
          }
        ],
        returns: 'True on success, else false'
      },
      {
        signature: 'bool GoForwards(RenderContentCollection selectedContentArray)',
        summary: 'Navigate forwards if possible',
        since: 6,
        parameters: [
          {
            name: 'selectedContentArray',
            summary: 'selectedContentArray is the new selection after navigating forwards'
          }
        ],
        returns: 'True on success, else false'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'RhinoSettings',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'RhinoSettings(IntPtr pRhinoSettings)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'RhinoView ActiveView()',
        since: 6
      },
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'List<System.Drawing.Size> GetCustomRenderSizes()',
        since: 6
      },
      {
        signature: 'RenderSettings GetRenderSettings()',
        since: 6
      },
      {
        signature: 'bool GroundPlaneOnInViewDisplayMode(RhinoView view)',
        since: 6.14
      },
      {
        signature: 'Rhino.DocObjects.ViewInfo RenderingView()',
        since: 6.12
      },
      {
        signature: 'void SetGroundPlaneOnInViewDisplayMode(RhinoView view,bool bOn)',
        since: 6.14
      },
      {
        signature: 'void SetRenderSettings(RenderSettings renderSettings)',
        since: 6
      },
      {
        signature: 'bool ViewSupportsShading(RhinoView view)',
        since: 6.14
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'Shapes',
    dataType: 3,
    values: [
      {
        signature: 'Square'
      },
      {
        signature: 'Wide'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.DataSources',
    name: 'Sizes',
    dataType: 3,
    values: [
      {
        signature: 'Unset'
      },
      {
        signature: 'Tiny'
      },
      {
        signature: 'Small'
      },
      {
        signature: 'Medium'
      },
      {
        signature: 'Large'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'Decal',
    dataType: 1,
    summary: 'Represents a decal, or a picture that can be moved on an object.',
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'int CRC',
        summary: `The decal CRC identifies a decal by its state. Multiple decals which would be
     exactly the same would have the same CRC and are culled from the system.
     If you store this value with the intention of using it to find the decal again
     later, you must update your stored value whenever the decal state changes.
     You can detect when a decal changes by watching for the OnUserDataTransformed event.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'DecalMapping DecalMapping',
        summary: 'Gets the mapping of the decal.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'DecalProjection DecalProjection',
        summary: 'Gets the decal\'s projection. Used only when mapping is planar.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'double EndLatitude',
        summary: 'Gets the end angle of the decal\'s arc of latitude or \'horizontal sweep\'. This is actually a LONGITUDINAL angle. Only used when mapping is cylindrical or spherical.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'double EndLongitude',
        summary: 'Gets the end angle of the decal\'s arc of longitude or \'vertical sweep\'. This is actually a LATITUDINAL angle. Only used when mapping is spherical.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'double Height',
        summary: 'Gets the height of the decal. Only used when mapping is cylindrical.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'bool MapToInside',
        summary: 'Used only when mapping is cylindrical or spherical.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Point3d Origin',
        summary: 'Gets the origin of the decal in world space.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'double Radius',
        summary: 'Gets the radius of the decal. Only used when mapping is cylindrical or spherical.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'double StartLatitude',
        summary: 'Gets the start angle of the decal\'s arc of latitude or \'horizontal sweep\'. This is actually a LONGITUDINAL angle. Only used when mapping is cylindrical or spherical.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'double StartLongitude',
        summary: 'Gets the start angle of the decal\'s arc of longitude or \'vertical sweep\'. This is actually a LATITUDINAL angle. Only used when mapping is spherical.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Guid TextureInstanceId',
        summary: 'Gets the texture ID for this decal.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'double Transparency',
        summary: 'Gets the decal\'s transparency in the range 0 to 1.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Vector3d VectorAcross',
        summary: 'Gets the vector across. For cylindrical and spherical mapping, the vector is unitized.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Vector3d VectorUp',
        summary: 'For cylindrical and spherical mapping, the vector is unitized.',
        since: 5.1,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Decal Create(DecalCreateParams createParams)',
        since: 5.1
      },
      {
        signature: 'IntPtr ConstPointer()',
        since: 5.1
      },
      {
        signature: 'List<Rhino.Render.NamedValue> CustomData()',
        summary: 'Gets custom data associated with this decal - see Rhino.Plugins.RenderPlugIn.ShowDecalProperties.',
        since: 6,
        returns: 'The return value can be None if there is no data associated with this decal.'
      },
      {
        signature: 'void Dispose()',
        since: 5.1
      },
      {
        signature: 'void Dispose(bool isDisposing)',
        since: 5.1
      },
      {
        signature: 'IntPtr NonConstPointer()',
        since: 5.1
      },
      {
        signature: 'bool TryGetColor(Point3d point,Vector3d normal,Color4f colInOut,Point2d uvOut)',
        summary: 'Blend color with the decal color at a given point.',
        since: 5.1,
        parameters: [
          {
            name: 'point',
            summary: 'The point in space or, if the decal is uv-mapped, the uv-coordinate of that point.'
          },
          {
            name: 'normal',
            summary: 'The face normal of the given point.'
          },
          {
            name: 'colInOut',
            summary: 'The color to blend the decal color to.'
          },
          {
            name: 'uvOut',
            summary: 'the UV on the texture that the color point was read from.'
          }
        ],
        returns: 'True if the given point hits the decal, else false.'
      },
      {
        signature: 'void UVBounds(double minUOut,double minVOut,double maxUOut,double maxVOut)',
        summary: 'The UV bounds of the decal. Only used when mapping is UV.',
        since: 5.1
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'DecalCreateParams',
    dataType: 1,
    summary: 'Used by RhinoObject.AddDecal() to create and add a decal',
    properties: [
      {
        signature: 'DecalMapping DecalMapping',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'DecalProjection DecalProjection',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double EndLatitude',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double EndLongitude',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double Height',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool MapToInside',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double MaxU',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double MaxV',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double MinU',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double MinV',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d Origin',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double Radius',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double StartLatitude',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double StartLongitude',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Guid TextureInstanceId',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double Transparency',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d VectorAcross',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d VectorUp',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'DecalMapping',
    dataType: 3,
    values: [
      {
        signature: 'Planar = (int)UnsafeNativeMethods.RhRdkDecalMapping.Planar',
        summary: 'Planar mapping. Uses projection, origin, up and across vectors (not unitized).'
      },
      {
        signature: 'Cylindrical = (int)UnsafeNativeMethods.RhRdkDecalMapping.Cylindrical',
        summary: 'Cylindrical mapping. Uses origin, up, across, height, radius, latitude start and stop.'
      },
      {
        signature: 'Spherical = (int)UnsafeNativeMethods.RhRdkDecalMapping.Spherical',
        summary: 'Spherical mapping. Uses origin, up, across, radius, latitude/longitude start and stop.'
      },
      {
        signature: 'UV = (int)UnsafeNativeMethods.RhRdkDecalMapping.UV',
        summary: 'UV mapping.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'DecalProjection',
    dataType: 3,
    values: [
      {
        signature: 'Forward = (int)UnsafeNativeMethods.RhRdkDecalProjection.Forward',
        summary: 'Project forward'
      },
      {
        signature: 'Backward = (int)UnsafeNativeMethods.RhRdkDecalProjection.Backward',
        summary: 'Project backward'
      },
      {
        signature: 'Both = (int)UnsafeNativeMethods.RhRdkDecalProjection.Both',
        summary: 'Project forward and backward'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'Decals',
    dataType: 1,
    summary: 'Represents all the decals of an object.',
    interfaces: ['IEnumerable<Decal>'],
    methods: [
      {
        signature: 'uint Add(Decal decal)',
        summary: `Add a new Decal to the decals list, use Decal.Create to create
     a new decal instance to add.`,
        since: 5.1
      },
      {
        signature: 'void Clear()',
        since: 5.1
      },
      {
        signature: 'IEnumerator<Decal> GetEnumerator()',
        since: 5.1
      },
      {
        signature: 'bool Remove(Decal decal)',
        since: 5.1
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'Dithering.Methods',
    dataType: 3,
    summary: 'Dithering algorithm.',
    values: [
      {
        signature: 'None',
        summary: 'No dithering'
      },
      {
        signature: 'FloydSteinberg',
        summary: 'Floyd Steinberg algorithm'
      },
      {
        signature: 'SimpleNoise',
        summary: 'Simple random noise'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'DocumentOrFreeFloatingBase',
    dataType: 1,
    summary: `Base class for Rhino.Render objects that are owned by the document, or can be delivered separately
   from other functions.  In general, you cannot create these objects yourself.`,
    baseclass: 'Rhino.Render.FreeFloatingBase',
    methods: [
      {
        signature: 'void BeginChange(ChangeContexts cc)',
        summary: 'Call this function before making any change to this object (calling a setter) otherwise undo will not work correctly.  Calls to BeginChange must be paired with a call to EndChange.',
        since: 6,
        parameters: [
          {
            name: 'cc',
            summary: 'Change context'
          }
        ]
      },
      {
        signature: 'bool EndChange()',
        summary: 'See BeginChange',
        since: 6,
        returns: 'True if the object has returned to no-changes mode.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'DynamicIconUsage',
    dataType: 3,
    values: [
      {
        signature: 'TreeControl = 0',
        summary: 'Dynamic icon appears in a tree control.'
      },
      {
        signature: 'SubnodeControl = 1',
        summary: 'Dynamic icon appears in a sub-node control (\\see CRhRdkSubNodeCtrl)'
      },
      {
        signature: 'ContentControl = 2',
        summary: 'Dynamic icon appears in a content control  (\\see CRhRdkContentCtrl)'
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'BoolField',
    dataType: 1,
    summary: 'bool field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'bool Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'ByteArrayField',
    dataType: 1,
    summary: 'ByteArray field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'byte[] Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'Color4fField',
    dataType: 1,
    summary: 'Color4f field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'Color SystemColorValue',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Color4f Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'DateTimeField',
    dataType: 1,
    summary: 'DateTime field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'DateTime Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'DoubleField',
    dataType: 1,
    summary: 'double field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'double Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'Field',
    dataType: 1,
    summary: `Generic data fields used to add publicly accessible properties to
   RenderContent.FieldDictionary.  These should be created by calling a
   FieldDictaionary.Add() method on a Render content object.  These are
   allocated after the RenderContent object's C++ object is created and
   added to the underlying C++ objects content dictionary, who ever
   allocates a field is responsible for deleting it so these objects clean
   up the C++ pointers when they are disposed of.`,
    properties: [
      {
        signature: 'string Key',
        summary: 'Field name value string passed to the constructor',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'string Name',
        summary: 'Field name value string passed to the constructor.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'object Tag',
        summary: 'Gets or sets an object that contains data to associate with the field.',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'int TextureAmountMax',
        summary: 'Set Max value for Texture amount',
        since: 7,
        property: ['set']
      },
      {
        signature: 'int TextureAmountMin',
        summary: 'Set Min value for Texture amount',
        since: 7,
        property: ['set']
      }
    ],
    methods: [
      {
        signature: 'T GetValue()',
        summary: 'Parametrized version of GetValue calling appropriate ValueAs* methods.',
        since: 6.12,
        returns: 'Value of type T of the field'
      },
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'FieldDictionary',
    dataType: 1,
    summary: `Dictionary containing RenderContent data fields, add fields to this
   dictionary in your derived RenderContent classes constructor.  Get field
   values using the TryGet[data type]() methods and set them using the Set()
   method.`,
    interfaces: ['IEnumerable'],
    methods: [
      {
        signature: 'BoolField Add(string key,bool value)',
        summary: `Add a new BoolField to the dictionary. This will be a data only field
     and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'BoolField Add(string key,bool value,string prompt)',
        summary: 'Add a new BoolField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'ByteArrayField Add(string key,byte[] value)',
        summary: `AddField a new ByteArrayField to the dictionary. This will be a data
     only field and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'Color4fField Add(string key,Color value)',
        summary: `Add a new Color4fField to the dictionary. This will be a data only
     field and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'Color4fField Add(string key,Color value,string prompt)',
        summary: 'Add a new Color4fField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'Color4fField Add(string key,Color4f value)',
        summary: `Add a new Color4fField to the dictionary. This will be a data only
     field and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'Color4fField Add(string key,Color4f value,string prompt)',
        summary: 'Add a new Color4fField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'DateTimeField Add(string key,DateTime value)',
        summary: `Add a new DateTimeField to the dictionary. This will be a data only
     field and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'DateTimeField Add(string key,DateTime value,string prompt)',
        summary: 'Add a new DateTimeField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'DoubleField Add(string key,double value)',
        summary: `AddField a new DoubleField to the dictionary. This will be a data only
     field and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'DoubleField Add(string key,double value,string prompt)',
        summary: 'Add a new DoubleField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'FloatField Add(string key,float value)',
        summary: `Add a new FloatField to the dictionary. This will be a data only field
     and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'FloatField Add(string key,float value,string prompt)',
        summary: 'AddField a new FloatField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'GuidField Add(string key,Guid value)',
        summary: `Add a new GuidField to the dictionary. This will be a data only field
     and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'GuidField Add(string key,Guid value,string prompt)',
        summary: 'Add a new GuidField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'IntField Add(string key,int value)',
        summary: `Add a new IntField to the dictionary. This will be a data only field
     and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'IntField Add(string key,int value,string prompt)',
        summary: 'Add a new IntField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'Point2dField Add(string key,Point2d value)',
        summary: `Add a new Point2dField to the dictionary. This will be a data only
     field and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'Point2dField Add(string key,Point2d value,string prompt)',
        summary: 'Add a new Point2dField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'Point3dField Add(string key,Point3d value)',
        summary: `Add a new Point3dField to the dictionary. This will be a data only
     field and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'Point3dField Add(string key,Point3d value,string prompt)',
        summary: 'Add a new Point3dField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'Point4dField Add(string key,Point4d value)',
        summary: `Add a new Point4dField to the dictionary. This will be a data only
     field and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'Point4dField Add(string key,Point4d value,string prompt)',
        summary: 'Add a new Point4dField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'StringField Add(string key,string value)',
        summary: `Add a new StringField to the dictionary.  This will be a data only
     field and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'StringField Add(string key,string value,string prompt)',
        summary: 'Add a new StringField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'TransformField Add(string key,Transform value)',
        summary: `Add a new TransformField to the dictionary. This will be a data only
     field and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'TransformField Add(string key,Transform value,string prompt)',
        summary: 'Add a new TransformField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'Vector2dField Add(string key,Vector2d value)',
        summary: `Add a new Vector2dField to the dictionary. This will be a data only
     field and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'Vector2dField Add(string key,Vector2d value,string prompt)',
        summary: 'Add a new Vector2dField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'Vector3dField Add(string key,Vector3d value)',
        summary: `Add a new Vector3dField to the dictionary. This will be a data only
     field and not show up in the content browsers.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          }
        ]
      },
      {
        signature: 'Vector3dField Add(string key,Vector3d value,string prompt)',
        summary: 'Add a new Vector3dField to the dictionary.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          }
        ]
      },
      {
        signature: 'BoolField AddTextured(string key,bool value,string prompt)',
        since: 5.7
      },
      {
        signature: 'BoolField AddTextured(string key,bool value,string prompt,bool treatAsLinear)',
        summary: `Add a new BoolField to the dictionary. This overload will cause the
     field to be tagged as "textured" so that the texturing UI will appear
     in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'Color4fField AddTextured(string key,Color value,string prompt)',
        since: 5.7
      },
      {
        signature: 'Color4fField AddTextured(string key,Color value,string prompt,bool treatAsLinear)',
        summary: `Add a new Color4fField to the dictionary. This overload will cause the
     field to be tagged as "textured" so that the texturing UI will appear
     in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'Color4fField AddTextured(string key,Color4f value,string prompt)',
        since: 5.7
      },
      {
        signature: 'Color4fField AddTextured(string key,Color4f value,string prompt,bool treatAsLinear)',
        summary: `Add a new Color4fField to the dictionary. This overload will cause the
     field to be tagged as "textured" so that the texturing UI will appear
     in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'DateTimeField AddTextured(string key,DateTime value,string prompt)',
        since: 5.7
      },
      {
        signature: 'DateTimeField AddTextured(string key,DateTime value,string prompt,bool treatAsLinear)',
        summary: `Add a new DateTimeField to the dictionary. This overload will cause the
     field to be tagged as "textured" so that the texturing UI will appear
     in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'DoubleField AddTextured(string key,double value,string prompt)',
        since: 5.7
      },
      {
        signature: 'DoubleField AddTextured(string key,double value,string prompt,bool treatAsLinear)',
        summary: `Add a new DoubleField to the dictionary. This overload will cause the
     field to be tagged as "textured" so that the texturing UI will appear
     in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'FloatField AddTextured(string key,float value,string prompt)',
        since: 5.7
      },
      {
        signature: 'FloatField AddTextured(string key,float value,string prompt,bool treatAsLinear)',
        summary: `Add a new FloatField to the dictionary. This overload will cause the
     field to be tagged as "textured" so that the texturing UI will appear
     in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'GuidField AddTextured(string key,Guid value,string prompt)',
        since: 5.7
      },
      {
        signature: 'GuidField AddTextured(string key,Guid value,string prompt,bool treatAsLinear)',
        summary: `Add a new GuidField to the dictionary. This overload will cause the
     field to be tagged as "textured" so that the texturing UI will appear
     in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'IntField AddTextured(string key,int value,string prompt)',
        since: 5.7
      },
      {
        signature: 'IntField AddTextured(string key,int value,string prompt,bool treatAsLinear)',
        summary: `Add a new IntField to the dictionary. This overload will cause the
     field to be tagged as "textured" so that the texturing UI will appear
     in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'Point2dField AddTextured(string key,Point2d value,string prompt)',
        since: 5.7
      },
      {
        signature: 'Point2dField AddTextured(string key,Point2d value,string prompt,bool treatAsLinear)',
        summary: `Add a new Point2dField to the dictionary. This overload will cause the
     field to be tagged as "textured" so that the texturing UI will appear
     in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'Point3dField AddTextured(string key,Point3d value,string prompt)',
        since: 5.7
      },
      {
        signature: 'Point3dField AddTextured(string key,Point3d value,string prompt,bool treatAsLinear)',
        summary: `Add a new Point3dField to the dictionary. This overload will cause the
     field to be tagged as "textured" so that the texturing UI will appear
     in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'Point4dField AddTextured(string key,Point4d value,string prompt)',
        since: 5.7
      },
      {
        signature: 'Point4dField AddTextured(string key,Point4d value,string prompt,bool treatAsLinear)',
        summary: `Add a new Point4dField to the dictionary. This overload will cause the
     field to be tagged as "textured" so that the texturing UI will appear
     in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'StringField AddTextured(string key,string value,string prompt)',
        since: 5.7
      },
      {
        signature: 'StringField AddTextured(string key,string value,string prompt,bool treatAsLinear)',
        summary: `Add a new StringField to the dictionary. This overload will cause the
     field to be tagged as "textured" so that the texturing UI will appear
     in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'TransformField AddTextured(string key,Transform value,string prompt)',
        since: 5.7
      },
      {
        signature: 'TransformField AddTextured(string key,Transform value,string prompt,bool treatAsLinear)',
        summary: `Add a new TransformField to the dictionary. This overload will cause
     the field to be tagged as "textured" so that the texturing UI will
     appear in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'Vector2dField AddTextured(string key,Vector2d value,string prompt)',
        since: 5.7
      },
      {
        signature: 'Vector2dField AddTextured(string key,Vector2d value,string prompt,bool treatAsLinear)',
        summary: `Add a new Vector2dField to the dictionary. This overload will cause the
     field to be tagged as "textured" so that the texturing UI will appear
     in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'Vector3dField AddTextured(string key,Vector3d value,string prompt)',
        since: 5.7
      },
      {
        signature: 'Vector3dField AddTextured(string key,Vector3d value,string prompt,bool treatAsLinear)',
        summary: `Add a new Vector3dField to the dictionary. This overload will cause the
     field to be tagged as "textured" so that the texturing UI will appear
     in automatic UIs.`,
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'Initial value for this field.'
          },
          {
            name: 'prompt',
            summary: `Prompt to display in the user interface (Content Browsers) if this
     is None or an empty string the this field is a data only field and will
     not appear in the user interface.`
          },
          {
            name: 'treatAsLinear',
            summary: 'Determines whether the texture in this slot will be treated as linear by rendering engines (ie - not gamma packed).'
          }
        ]
      },
      {
        signature: 'bool ContainsField(string fieldName)',
        summary: `Call this method to determine if a this FieldsList contains a field
     with the specified field name.`,
        since: 5.1,
        parameters: [
          {
            name: 'fieldName',
            summary: 'Field to search for'
          }
        ],
        returns: `Returns True if a field with that matches fieldName is found or false
     if it is not found.`
      },
      {
        signature: 'IEnumerator<Field> GetEnumerator()',
        since: 6
      },
      {
        signature: 'Field GetField(string fieldName)',
        summary: 'Call this method to get the field with the matching name.',
        since: 5.3,
        parameters: [
          {
            name: 'fieldName',
            summary: 'Field name to search for.'
          }
        ],
        returns: `If the field exists in the Fields dictionary then the field is returned
     otherwise; None is returned.`
      },
      {
        signature: 'void RemoveField(string fieldName)',
        since: 6
      },
      {
        signature: 'void Set(string key,bool value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,bool value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,byte[] value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,byte[] value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Color value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Color value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Color4f value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Color4f value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,DateTime value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,DateTime value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,double value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,double value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,float value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,float value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Guid value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Guid value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,int value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,int value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Point2d value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Point2d value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Point3d value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Point3d value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Point4d value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Point4d value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,string value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,string value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Transform value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Transform value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Vector2d value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Vector2d value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Vector3d value)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          }
        ]
      },
      {
        signature: 'void Set(string key,Vector3d value,ChangeContexts changeContext)',
        summary: `Set the field value and send the appropriate change notification to the
     render SDK.  Will throw a InvalidOperationException exception if the key
     name is not valid.`,
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field value to change.'
          },
          {
            name: 'value',
            summary: 'New value for this field.'
          },
          {
            name: 'changeContext',
            summary: 'The reason why the value is changing.'
          }
        ]
      },
      {
        signature: 'bool SetTag(string key,object tag)',
        summary: 'Sets an object that contains data to associate with the field.  THIS IS NOW OBSOLETE - if you were using this, please email andy@mcneel.com and let me know why.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name for the field to tag.'
          },
          {
            name: 'tag',
            summary: 'Data to associate with the field.'
          }
        ],
        returns: 'True if the field is found and the tag was set otherwise False is returned.'
      },
      {
        signature: 'bool TryGetTag(string key,object tag)',
        summary: 'Gets object that contains data associate with a field. THIS IS NOW OBSOLETE - if you were using this, please email andy@mcneel.com and let me know why.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get.'
          },
          {
            name: 'tag',
            summary: 'Data associated with the field.'
          }
        ],
        returns: `Returns True if the field is found and its tag was retrieved otherwise;
     returns false.`
      },
      {
        signature: 'bool TryGetValue(string key,bool value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,byte[] value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,Color value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,Color4f value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,DateTime value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,double value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,float value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,Guid value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,int value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,Point2d value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,Point3d value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,Point4d value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,string value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,T value)',
        summary: 'Parametrized version of TryGetValue.',
        since: 6.12,
        parameters: [
          {
            name: 'key',
            summary: 'Name of field to find.'
          },
          {
            name: 'value',
            summary: 'out parameter to be set.'
          }
        ],
        returns: 'True if field was found. If False out parameter value will be set to default(T).'
      },
      {
        signature: 'bool TryGetValue(string key,Transform value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,Vector2d value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      },
      {
        signature: 'bool TryGetValue(string key,Vector3d value)',
        summary: 'Find a field with the specified key and get its value if found.',
        since: 5.1,
        parameters: [
          {
            name: 'key',
            summary: 'Key name of the field to get a value for.'
          },
          {
            name: 'value',
            summary: 'Output parameter which will receive the field value.'
          }
        ],
        returns: `Returns True if the key is found and the value parameter is set to the
     field value.  Returns False if the field was not found.`
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'FloatField',
    dataType: 1,
    summary: 'float field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'float Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'GuidField',
    dataType: 1,
    summary: 'Guid field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'Guid Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'IntField',
    dataType: 1,
    summary: 'Integer field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'int Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'Point2dField',
    dataType: 1,
    summary: 'Point2d field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'Point2d Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'Point3dField',
    dataType: 1,
    summary: 'Point3d field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'Point3d Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'Point4dField',
    dataType: 1,
    summary: 'Point4d field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'Point4d Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'StringField',
    dataType: 1,
    summary: 'String field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'string Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'TransformField',
    dataType: 1,
    summary: 'Transform field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'Transform Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'Vector2dField',
    dataType: 1,
    summary: 'Vector2d field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'Vector2d Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render.Fields',
    name: 'Vector3dField',
    dataType: 1,
    summary: 'Vector3d field value class',
    baseclass: 'Rhino.Render.Fields.Field',
    properties: [
      {
        signature: 'Vector3d Value',
        summary: 'Gets or sets the field value',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'object ValueAsObject()',
        since: 5.7
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'FilterContentByUsage',
    dataType: 3,
    summary: 'Content collection filter value',
    values: [
      {
        signature: 'None',
        summary: 'No filter in use'
      },
      {
        signature: 'Used',
        summary: 'Display only used contents'
      },
      {
        signature: 'Unused',
        summary: 'Display only unused contents'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'FreeFloatingBase',
    dataType: 1,
    summary: `Base class for Rhino.Render objects that are owned by the document, or can be delivered separately
   from other functions.  In general, you cannot create these objects yourself.`,
    methods: [
      {
        signature: 'void CopyFrom(FreeFloatingBase src)',
        summary: 'Copy from another object',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'GroundPlane',
    dataType: 1,
    summary: `Represents an infinite plane for implementation by renderers.
   See Rhino.PlugIns.RenderPlugIn.SupportsFeature.`,
    baseclass: 'Rhino.Render.DocumentOrFreeFloatingBase',
    constructors: [
      {
        signature: 'GroundPlane()',
        summary: 'Create an utility object not associated with any document',
        since: 6
      },
      {
        signature: 'GroundPlane(GroundPlane g)',
        summary: 'Create an utility object not associated with any document from another object',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'double Altitude',
        summary: 'Height above world XY plane in model units.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool AutoAltitude',
        summary: 'Determines whether the ground plane is fixed by the Altitude property, or whether it is automatically placed at the lowest point in the model.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool Enabled',
        summary: 'Determines whether the document ground plane is enabled.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Guid MaterialInstanceId',
        summary: 'Id of material in material table for this ground plane.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShadowOnly',
        summary: 'Determines whether the ground plane shows the material assigned, or whether it is transparent, but captures shadows.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool ShowUnderside',
        summary: 'If this is off, the ground plane will not be visible when seen from below.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Vector2d TextureOffset',
        summary: 'Texture mapping offset in world units.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool TextureOffsetLocked',
        summary: 'Texture offset locked.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double TextureRotation',
        summary: 'Texture mapping rotation around world origin + offset in degrees.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector2d TextureSize',
        summary: 'Texture mapping single UV span size in world units.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool TextureSizeLocked',
        summary: 'Texture size locked.',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void CopyFrom(FreeFloatingBase src)',
        since: 6
      }
    ],
    events: [
      {
        signature: 'static Changed',
        summary: 'This event is raised when a GroundPlane property value is changed.',
        since: 5.1
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'ICurrentEnvironment',
    dataType: 4
  },
  {
    namespace: 'Rhino.Render',
    name: 'ICurrentEnvironment_Get',
    dataType: 4
  },
  {
    namespace: 'Rhino.Render',
    name: 'ImageFile',
    dataType: 1,
    summary: 'Controls interaction with RDK render image files',
    events: [
      {
        signature: 'static Deleted',
        summary: `Called when the RDK is cleaning up old render image files, a
       plug-in should delete any plug-in specific image files at this
       time.`,
        since: 5.11
      },
      {
        signature: 'static Loaded',
        summary: `Generally called when the "RenderOpenLastRender" command is run,
       this event is raised after the render window has been created and the
       saved scene has been loaded.`,
        since: 5.11
      },
      {
        signature: 'static Saved',
        summary: `Render image file saved, happens when a rendering completes.
       If a plug-in needs to save additional file information it should
       write it to the same folder as the Rhino render image file.  Rhino
       will take care of deleting old data.`,
        since: 5.11
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'ImageFileEvent',
    dataType: 3,
    values: [
      {
        signature: 'Saved',
        summary: 'Render image file has been successfully written'
      },
      {
        signature: 'Loaded',
        summary: 'Render image file has been successfully loaded'
      },
      {
        signature: 'Deleted',
        summary: 'Render image file was just deleted'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'ImageFileEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'int EllapsedTime',
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'ImageFileEvent Event',
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'string FileName',
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'string RenderEngine',
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'Guid RenderEngineId',
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'Guid SessionId',
        since: 5.11,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'IRhRdkPreviewSceneServer_eRotationType',
    dataType: 3,
    summary: 'c# version of IRhRdkPreviewSceneServer eRotationType enum',
    values: [
      {
        signature: 'Camera',
        summary: 'Camera'
      },
      {
        signature: 'Object',
        summary: 'Object'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'it_strategy',
    dataType: 3,
    summary: 'Defines the collection type to iterate.',
    values: [
      {
        signature: 'ContentDataBase'
      },
      {
        signature: 'ContentSelection'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'LightArray',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'LightArray()',
        since: 6
      },
      {
        signature: 'LightArray(IntPtr pLightArray)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Append(Light light)',
        since: 6
      },
      {
        signature: 'int Count()',
        since: 6
      },
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'Rhino.Geometry.Light ElementAt(int index)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'LightManagerSupport',
    dataType: 1,
    summary: 'Base class for implementing custom light managers in .NET',
    methods: [
      {
        signature: 'static void RegisterLightManager(PlugIn plugin)',
        summary: `Find and register classes that derive from LightManagerSupport
     from the given plug-in.`,
        since: 6
      },
      {
        signature: 'static void RegisterProviders(Assembly assembly,Guid pluginId)',
        summary: `Find and register classes that derive from RealtimeDisplayMode
     from the given plug-in. The plug-in is found in the given assembly`,
        since: 6
      },
      {
        signature: 'bool DeleteLight(RhinoDoc doc,Light light,bool bUndelete)',
        summary: 'Delete light',
        since: 6,
        returns: 'If delete is successful, then return true, else return false'
      },
      {
        signature: 'void GetLights(RhinoDoc doc,LightArray light_array)',
        summary: `Get all the lights that are associated to the light manager. The lights are added 
      to the LightArray parameter passed to the GetLights method`,
        since: 6
      },
      {
        signature: 'bool GetLightSolo(RhinoDoc doc,Guid uuid_light)',
        summary: `Returns the value of "ON_LIght::m_bOn" if the light is in solo storage, or 
      False if not in solo storage (ie - this is the checkbox state on the light manager dialog)`,
        since: 6,
        returns: 'Returns True if the light is in solo storage, or False if not in solo storage'
      },
      {
        signature: 'void GroupLights(RhinoDoc doc,LightArray light_array)',
        summary: 'Creates a new group with the lights',
        since: 6
      },
      {
        signature: 'string LightDescription(RhinoDoc doc,Light light)',
        summary: 'Gets the string representation of the light description',
        since: 6,
        returns: 'Returns the string representation of the light description'
      },
      {
        signature: 'bool LightFromId(RhinoDoc doc,Guid uuid,Light light)',
        summary: 'Get Rhino.Geometry.Light object associated to Guig uuid',
        since: 6
      },
      {
        signature: 'int LightsInSoloStorage(RhinoDoc doc)',
        summary: 'Returns the number of lights in solo storage - any number other than 0 means "in solo mode"',
        since: 6,
        returns: 'Returns the number of lights in solo storage - any number other than 0 means "in solo mode"'
      },
      {
        signature: 'void ModifyLight(RhinoDoc doc,Light light)',
        summary: 'Modify properties of the light',
        since: 6
      },
      {
        signature: 'int ObjectSerialNumberFromLight(RhinoDoc doc,Light light)',
        summary: 'Get the object serial number of the light',
        since: 6
      },
      {
        signature: 'void OnCustomLightEvent(RhinoDoc doc,LightMangerSupportCustomEvent le,Light light)',
        summary: `Generates LightMangerSupportCustomEvent: 
        light_added,
        light_deleted,
        light_undeleted,
        light_modified,
        light_sorted,
      The event triggers a Light table event that the rdk lightmanager listens too`,
        since: 6,
        returns: 'Returns the string representation of the light description'
      },
      {
        signature: 'bool OnEditLight(RhinoDoc doc,LightArray light_array)',
        summary: `The default implementation of OnEditLight selects the lights and opens
      the Lights Properties page`,
        since: 6,
        returns: 'Returns True if successful, else false'
      },
      {
        signature: 'Guid PluginId()',
        summary: 'The Guid of the plugin',
        since: 6,
        returns: 'Returns the Guid of the plugin'
      },
      {
        signature: 'Guid RenderEngineId()',
        summary: 'The Guid of the render engine',
        since: 6,
        returns: 'Returns the Guid of the render engine that is associated with this light manager'
      },
      {
        signature: 'bool SetLightSolo(RhinoDoc doc,Guid uuid_light,bool bSolo)',
        summary: `First checks to see if we are in "solo mode" - which means that there are any lights that respond "true" to IsInSoloStorage.
     If in solo mode:
      If bSolo = true
       Sets this light on.
      If bSolo = false
       If this is the last light "on", forces all lights out of solo mode.
       If there are other lights on, turns this light off.
     If not in solo mode:
      If bSolo = true
       Forces all lights into solo storage and sets this light on.
      If bSolo = false
       This shouldn't happen.  Will cause an ASSERT`,
        since: 6,
        returns: 'Returns True if action is successful'
      },
      {
        signature: 'void UnGroup(RhinoDoc doc,LightArray light_array)',
        summary: 'UnGroups the lights',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'LightManagerSupportClient',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'LightManagerSupportClient(uint doc_uuid)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void DeleteLight(Light light)',
        since: 6
      },
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'Rhino.Geometry.Light GetLightFromId(Guid uuid)',
        since: 6
      },
      {
        signature: 'LightArray GetLights()',
        since: 6
      },
      {
        signature: 'bool GetLightSolo(Light light)',
        since: 6
      },
      {
        signature: 'void GroupLights(LightArray lights)',
        since: 6
      },
      {
        signature: 'string LightDescription(Light light)',
        since: 6
      },
      {
        signature: 'int LightsInSoloStorage()',
        since: 6
      },
      {
        signature: 'void ModifyLight(Light light)',
        since: 6
      },
      {
        signature: 'Rhino.DocObjects.RhinoObject ObjectFromLight(Light light)',
        since: 6
      },
      {
        signature: 'void OnEditLight(LightArray lights)',
        since: 6
      },
      {
        signature: 'bool SetLightSolo(Light light,bool bSolo)',
        since: 6
      },
      {
        signature: 'void UnGroup(LightArray lights)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'LightMangerSupportCustomEvent',
    dataType: 3,
    summary: 'LightMangerSupportCustomEvent',
    values: [
      {
        signature: 'light_added'
      },
      {
        signature: 'light_deleted'
      },
      {
        signature: 'light_undeleted'
      },
      {
        signature: 'light_modified'
      },
      {
        signature: 'light_sorted'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'LinearWorkflow',
    dataType: 1,
    summary: 'This is the interface to linear workflow settings.',
    baseclass: 'Rhino.Render.DocumentOrFreeFloatingBase',
    constructors: [
      {
        signature: 'LinearWorkflow()',
        summary: 'Create an utility object not associated with any document',
        since: 6
      },
      {
        signature: 'LinearWorkflow(LinearWorkflow src)',
        summary: 'Create utility object not associated with any document from another object',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'uint Hash',
        summary: 'Linear workflow CRC',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool PostProcessFrameBuffer',
        summary: 'Linear workflow active state',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'float PostProcessGamma',
        summary: 'Linear workflow gamma',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool PostProcessGammaOn',
        summary: 'Linear workflow gamma',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'float PostProcessGammaReciprocal',
        summary: 'Linear workflow gamma',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool PreProcessColors',
        summary: 'Linear workflow active state',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'float PreProcessGamma',
        summary: 'Linear workflow gamma',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool PreProcessTextures',
        summary: 'Linear workflow active state',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void CopyFrom(FreeFloatingBase src)',
        summary: 'Create a copy of linearworkflow',
        since: 6
      },
      {
        signature: 'bool Equals(object obj)',
        summary: `Compare two LinearWorkflow objects. They are considered equal when
     their Hashes match.`
      },
      {
        signature: 'int GetHashCode()',
        summary: 'Get hash code for this object. It is the Hash property cast to int.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'MappingTag',
    dataType: 1,
    summary: 'Holds texture mapping information.',
    properties: [
      {
        signature: 'Guid Id',
        summary: 'Gets or sets a map globally unique identifier.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'uint MappingCRC',
        summary: `Gets or sets the cyclic redundancy check on the mapping.
     See also RhinoMath.CRC32(uint,byte[]).`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'TextureMappingType MappingType',
        summary: 'Gets or sets a texture mapping type: linear, cylinder, etc...',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Transform MeshTransform',
        summary: 'Gets or sets a 4x4 matrix transform.',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'MetaDataProxy',
    dataType: 1,
    summary: 'ProxyClass for MetaData',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'MetaDataProxy()',
        summary: 'Constructor for MetaDataProxy',
        since: 6.8
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        summary: 'MetaDataProxy c++ pointer',
        since: 6.8,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Dispose for MetaDataProxy',
        since: 6.8
      },
      {
        signature: 'void SetContentInstanceId(Guid uuid)',
        summary: 'Set Content instance id for meta data',
        since: 6.8
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'NamedValue',
    dataType: 1,
    constructors: [
      {
        signature: 'NamedValue(string name,object value)',
        since: 5.1
      }
    ],
    properties: [
      {
        signature: 'string Name',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'object Value',
        since: 5.1,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'PhysicallyBasedMaterial',
    dataType: 1,
    properties: [
      {
        signature: 'double Anisotropic',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double AnisotropicRotation',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'Color4f BaseColor',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'BRDFs BRDF',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double Clearcoat',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double ClearcoatRoughness',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'Color4f Emission',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'Material Material',
        since: 7,
        property: ['get']
      },
      {
        signature: 'double Metallic',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double Opacity',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double OpacityIOR',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double OpacityRoughness',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double ReflectiveIOR',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double Roughness',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double Sheen',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double SheenTint',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double Specular',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double SpecularTint',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double Subsurface',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'Color4f SubsurfaceScatteringColor',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double SubsurfaceScatteringRadius',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'bool Supported',
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'DocObjects.Texture GetTexture(TextureType which)',
        summary: 'Get the texture that corresponds with the specified texture type for this material.',
        since: 7
      },
      {
        signature: 'DocObjects.Texture[] GetTextures()',
        summary: 'Get array of textures that this material uses',
        since: 7
      },
      {
        signature: 'bool SetTexture(Texture texture,TextureType which)',
        summary: 'Set the texture that corresponds with the specified texture type for this material.',
        since: 7,
        parameters: [
          {
            name: 'texture',
            summary: 'An instance of Rhino.DocObjects.Texture'
          },
          {
            name: 'which',
            summary: 'Use Rhino.DocObjects.TextureType'
          }
        ]
      },
      {
        signature: 'void SynchronizeLegacyMaterial()',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'PhysicallyBasedMaterial.BRDFs',
    dataType: 3,
    values: [
      {
        signature: 'GGX = 0'
      },
      {
        signature: 'Ward = 1'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'PhysicallyBasedMaterial.ParametersNames',
    dataType: 1,
    summary: 'Helper class with fields containing the names of fields available in our PBR implementation.',
    properties: [
      {
        signature: 'static string AmbientOcclusion',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string Anisotropic',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string AnisotropicRotation',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string BaseColor',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string BRDF',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string Bump',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string Clearcoat',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string ClearcoatBump',
        since: 6.16,
        property: ['get']
      },
      {
        signature: 'static string ClearcoatRoughness',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string Displacement',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string Emission',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string Metallic',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string Normal',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string Opacity',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string OpacityIor',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string OpacityRoughness',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string Roughness',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string Sheen',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string SheenTint',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string Smudge',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string Specular',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string SpecularTint',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string Subsurface',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string SubsurfaceScatteringColor',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static string SubsurfaceScatteringRadius',
        since: 6.12,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static string FromTextureType(TextureType tt)',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'PixelBuffer',
    dataType: 1,
    constructors: [
      {
        signature: 'PixelBuffer(IntPtr bufferPointer)',
        summary: `Create a new PixelBuffer pointing to the
     (unmanaged) pixel data buffer behind IntPtr`,
        since: 6,
        parameters: [
          {
            name: 'bufferPointer',
            summary: 'IntPtr to the unmanaged pixel data buffer'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'IntPtr Buffer',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'PreviewAppearance',
    dataType: 1,
    summary: 'PreviewAppearance class',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'PreviewAppearance(IntPtr pRenderContent)',
        summary: 'Constructor for previewappearance',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        summary: 'Previewappearances c++ pointer',
        since: 6,
        property: ['get']
      },
      {
        signature: 'MetaData MetaData',
        summary: 'Previewappearance MetaData',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'PreviewBackground Background()',
        summary: 'Background',
        since: 6
      },
      {
        signature: 'void Dispose()',
        summary: 'Dispose for previewappearance',
        since: 6
      },
      {
        signature: 'void FromMetaData(MetaData md)',
        summary: 'Copy data from MetaData to PreviewAppearance',
        since: 6
      },
      {
        signature: 'PreviewGeometry Geometry()',
        summary: 'Geometry',
        since: 6
      },
      {
        signature: 'PreviewLighting Lighting()',
        summary: 'Lighting',
        since: 6
      },
      {
        signature: 'IRhRdkPreviewSceneServer_eRotationType RotationType()',
        summary: 'RotationType',
        since: 6
      },
      {
        signature: 'double RotationX()',
        summary: 'RotationX',
        since: 6
      },
      {
        signature: 'double RotationY()',
        summary: 'RotationY',
        since: 6
      },
      {
        signature: 'void SetRotationType(IRhRdkPreviewSceneServer_eRotationType type)',
        summary: 'SetRotationType',
        since: 6
      },
      {
        signature: 'void SetRotationX(double d)',
        summary: 'SetRotationX',
        since: 6
      },
      {
        signature: 'void SetRotationY(double d)',
        summary: 'SetRotationY',
        since: 6
      },
      {
        signature: 'void SetSize(double d)',
        summary: 'SetSize',
        since: 6
      },
      {
        signature: 'double Size()',
        summary: 'Size',
        since: 6
      },
      {
        signature: 'void ToMetaData()',
        summary: 'Copy PreviewAppearance to MetaData',
        since: 6
      },
      {
        signature: 'void ToMetaData(MetaDataProxy mdp)',
        summary: 'Copy PreviewAppearance to MetaData',
        since: 6.8
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'PreviewBackground',
    dataType: 1,
    summary: 'PreviewBackGround takes care of constucting and desctrutction of PreviewLight',
    constructors: [
      {
        signature: 'PreviewBackground(IntPtr pPreviewBackground)',
        summary: 'Constructor for PreivewLighting',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        summary: 'CppPointer for PreivewLighting',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'string ElementKind()',
        summary: 'ElementKind',
        since: 6
      },
      {
        signature: 'Guid EnvironmentInstanceId()',
        summary: 'EnvironmentInstanceId',
        since: 6
      },
      {
        signature: 'void SetEnvironmentInstanceId(Guid guid)',
        summary: 'SetEnvironmentInstanceId',
        since: 6
      },
      {
        signature: 'void SetUpPreview(IntPtr sceneServerPointer,Guid guid)',
        summary: 'SetUpPreview',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'PreviewGeometry',
    dataType: 1,
    summary: 'PreviewAppearance takes care of constucting and desctrutction of PreivewGeometry',
    constructors: [
      {
        signature: 'PreviewGeometry(IntPtr pPreviewGeometry)',
        summary: 'Constructor for PreviewGeometry',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        summary: 'CppPointer for PreviewGeometry',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'string ElementKind()',
        summary: 'ElementKind',
        since: 6
      },
      {
        signature: 'void SetUpPreview(IntPtr sceneServerPointer,IntPtr pRenderContent,bool bCopy)',
        summary: 'SetUpPreview',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'PreviewLighting',
    dataType: 1,
    summary: 'PreviewAppearance takes care of constucting and desctrutction of PreviewLight',
    constructors: [
      {
        signature: 'PreviewLighting(IntPtr pPreviewLighting)',
        summary: 'Constructor for PreivewLighting',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        summary: 'CppPointer for PreivewLighting',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'string ElementKind()',
        summary: 'ElementKind',
        since: 6
      },
      {
        signature: 'void SetUpPreview(IntPtr sceneServerPointer)',
        summary: 'SetUpPreview',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'PreviewSceneQuality',
    dataType: 3,
    summary: 'Quality levels when creating preview images',
    values: [
      {
        signature: '    RealtimeQuick = Low',
        summary: 'Very fast preview. Typically using the internal OpenGL preview generator.'
      },
      {
        signature: '    RefineFirstPass = Low',
        summary: 'Low quality rendering for quick preview.'
      },
      {
        signature: '    RefineSecondPass = Medium',
        summary: 'Medium quality rendering for intermediate preview.'
      },
      {
        signature: '    RefineThirdPass = Full',
        summary: 'Full quality rendering (quality comes from user settings)'
      },
      {
        signature: 'None = 0',
        summary: 'No quality set.'
      },
      {
        signature: 'Low = 1',
        summary: 'Low quality rendering for quick preview.'
      },
      {
        signature: 'Medium = 2',
        summary: 'Medium quality rendering for intermediate preview.'
      },
      {
        signature: 'IntermediateProgressive = 3',
        summary: `Intermediate update, always considered better quality than the previous
     IntermediateProgressive, but not as high as Full.`
      },
      {
        signature: 'Full = 4',
        summary: 'Full quality rendering (quality comes from user settings).'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'PreviewSceneServer',
    dataType: 1,
    summary: 'PreviewSceneServer',
    constructors: [
      {
        signature: 'PreviewSceneServer(IntPtr pPreviewSceneServer)',
        summary: 'Constructor for PreviewSceneServer',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        summary: 'The CppPointer of PreviewSceneServer',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void ApplyRotation(double X,double Y,IRhRdkPreviewSceneServer_eRotationType type)',
        summary: 'Set Scene Server Rotation',
        since: 6
      },
      {
        signature: 'void Dispose()',
        summary: 'Dispose for PreviewSceneServer',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'ProxyTypes',
    dataType: 3,
    summary: 'Defines the proxy type of the render content',
    values: [
      {
        signature: 'None'
      },
      {
        signature: 'Single'
      },
      {
        signature: 'Multi'
      },
      {
        signature: 'Texture'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RdkUndo',
    dataType: 1,
    summary: `RdkUndo class, which is used to get the 
   RdkUndoRecord`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'RdkUndo(IntPtr pUndoRecord)',
        summary: 'Constructor for RdkUndo',
        since: 6.11
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Dispose for RdkUndo',
        since: 6.11
      },
      {
        signature: 'RdkUndoRecord NewUndoRecord()',
        summary: 'Get a new UndoRecord',
        since: 6.11
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RdkUndoRecord',
    dataType: 1,
    summary: 'RdkUndoRecord class',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'RdkUndoRecord(IntPtr pUndoRecord)',
        summary: 'Constructor for RdkUndoRecord',
        since: 6
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Dispose for RdkUndoRecord',
        since: 6
      },
      {
        signature: 'void SetDescription(String description)',
        summary: 'Set description for RdkUndoRecord',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RealtimeDisplayMode',
    dataType: 1,
    summary: `Base class for implementing real-time display modes in .NET.
   
   Pay special attention that in StartRenderer the RenderWindow.SetSize()
   function is called if the implementation relies on the RenderWindow to
   do the drawing to the viewport. If i.e. OpenGL is used to draw render
   results to the viewport then SetSize() doesn't have to be called, nor
   should the implementation then access channels on the RenderWindow, as
   those then don't exist. For OpenGL-based drawing the RenderWindow is
   used as a container for ViewInfo management, nothing else.`,
    properties: [
      {
        signature: 'LinearWorkflow LinearWorkflow',
        summary: 'Returns the LinearWorkflow data for this realitime display mode.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool Locked',
        since: 6.6,
        property: ['get', 'set']
      },
      {
        signature: 'int MaxPasses',
        since: 6.6,
        property: ['get', 'set']
      },
      {
        signature: 'bool Paused',
        since: 6.6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static RealtimeDisplayMode GetRealtimeViewport(IntPtr realtimeViewport)',
        summary: 'Retrieve RealtimeDisplayMode instance that the IntPtr refers to.',
        since: 6,
        parameters: [
          {
            name: 'realtimeViewport',
            summary: `IntPtr of the instance searched for. If
     the instance doesn't exist, a new one is created.`
          }
        ]
      },
      {
        signature: 'static RealtimeDisplayMode GetRealtimeViewport(IntPtr realtimeViewport,bool create)',
        summary: `Retrieve RealtimeDisplayMode instance. If create is set to true
     then a new instance is created if not found, None is returned for false.`,
        since: 6,
        parameters: [
          {
            name: 'realtimeViewport',
            summary: 'IntPtr'
          },
          {
            name: 'create',
            summary: 'True to create if not found, False to return None if not found.'
          }
        ]
      },
      {
        signature: 'static RealtimeDisplayModeClassInfo[] RegisterDisplayModes(Assembly assembly,Guid pluginId)',
        summary: `Find and register classes that derive from RealtimeDisplayMode
     from the given plug-in. The plug-in is found in the given assembly`,
        since: 6
      },
      {
        signature: 'static RealtimeDisplayModeClassInfo[] RegisterDisplayModes(PlugIn plugin)',
        summary: `Find and register classes that derive from RealtimeDisplayMode
     from the given plug-in.`,
        since: 6
      },
      {
        signature: 'static void RemoveRealtimeViewport(IntPtr realtimeViewport)',
        summary: 'Remove RealtimeDisplayMode instance from internal dictionary.',
        since: 6,
        parameters: [
          {
            name: 'realtimeViewport',
            summary: 'IntPtr to the RealtimeDisplayMode instance to remove.'
          }
        ]
      },
      {
        signature: 'static void UnregisterDisplayModes(Assembly assembly,Guid pluginId)',
        since: 6
      },
      {
        signature: 'static void UnregisterDisplayModes(PlugIn plugin)',
        since: 6
      },
      {
        signature: 'double CaptureProgress()',
        summary: 'Override to communicate the progress of a capture.',
        since: 6,
        returns: 'A number between 0.0 and 1.0 inclusive. 1.0 means 100%.'
      },
      {
        signature: 'uint ComputeViewportCrc(ViewInfo view)',
        summary: 'Compute viewport CRC for the given ViewInfo',
        since: 6,
        returns: 'the CRC for the given view'
      },
      {
        signature: 'void CreateWorld(RhinoDoc doc,ViewInfo viewInfo,DisplayPipelineAttributes displayPipelineAttributes)',
        summary: `Implement if you need to handle the initial CreateWorld call initiated by the display pipeline system. Note
     that this is not the same as the CreateWorld call in Rhino.Render.ChangeQueue.ChangeQueue, although
     related.`,
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'Rhino document'
          },
          {
            name: 'viewInfo',
            summary: 'active viewport info'
          },
          {
            name: 'displayPipelineAttributes',
            summary: 'display pipeline attributes'
          }
        ]
      },
      {
        signature: 'bool DrawOpenGl()',
        since: 6
      },
      {
        signature: 'void GetRenderSize(int width,int height)',
        summary: 'Get the current render resolution for the running render session.',
        since: 6
      },
      {
        signature: 'ViewInfo GetView()',
        summary: 'Get ViewInfo that has been registered with this RealtimeDisplayMode instance.',
        since: 6
      },
      {
        signature: 'bool HudAllowEditMaxPasses()',
        summary: 'Override to allow maximum pass editing. By default disabled.',
        since: 6,
        returns: 'Return True to allow users to edit the maximum pass count.'
      },
      {
        signature: 'string HudCustomStatusText()',
        summary: 'Override to display status of the render engine.',
        since: 6,
        returns: 'Status text to display'
      },
      {
        signature: 'int HudLastRenderedPass()',
        summary: 'Override to communicate the last completed pass. Can be shown in the HUD',
        since: 6,
        returns: 'Last completed pass'
      },
      {
        signature: 'int HudMaximumPasses()',
        summary: `Override to communicate the maximum passes count currently in use for the render session.
     Can be shown in the HUD`,
        since: 6,
        returns: 'Maximum passes'
      },
      {
        signature: 'string HudProductName()',
        summary: `Override to return the name of your product. This will be printed in
     the HUD.`,
        since: 6,
        returns: 'Name of the product.'
      },
      {
        signature: 'bool HudRendererLocked()',
        summary: 'Implement to support locking in the viewport',
        since: 6,
        returns: 'Return True if the render engine is locked.'
      },
      {
        signature: 'bool HudRendererPaused()',
        summary: 'Implement to support pausing and resuming in the viewport',
        since: 6,
        returns: 'Return True if the render engine is paused.'
      },
      {
        signature: 'bool HudShow()',
        summary: 'Override if you want to hide the HUD. Shown by default',
        since: 6,
        returns: 'Return False to hide the HUD.'
      },
      {
        signature: 'bool HudShowControls()',
        summary: `Show control buttons on the realtime display HUD.
     
     By default these are shown, override this function and
     return False if HUD controls aren't needed.`,
        since: 6
      },
      {
        signature: 'bool HudShowCustomStatusText()',
        summary: 'Override to show status text in HUD. By default disabled.',
        since: 6,
        returns: 'Return True to show status text in HUD'
      },
      {
        signature: 'bool HudShowMaxPasses()',
        summary: 'Override to show maximum passes in HUD. By default disabled.',
        since: 6,
        returns: 'Return True to show maximum passes.'
      },
      {
        signature: 'bool HudShowPasses()',
        summary: 'Override to show current pass in HUD. By default disabled.',
        since: 6,
        returns: 'Return True to show current pass in HUD.'
      },
      {
        signature: 'DateTime HudStartTime()',
        since: 6
      },
      {
        signature: 'bool IsCompleted()',
        summary: 'Implement to tell if your render engine has completed a frame for drawing into the viewport',
        since: 6
      },
      {
        signature: 'bool IsFrameBufferAvailable(ViewInfo view)',
        summary: 'Implement to tell the render pipeline that a framebuffer is ready',
        since: 6,
        returns: `Return True when a framebuffer is ready. This is generally the
     case when StartRenderer as returned successfully.`
      },
      {
        signature: 'bool IsRendererStarted()',
        summary: 'Override to tell the started state of your render engine.',
        since: 6,
        returns: 'True if render engine is ready and rendering'
      },
      {
        signature: 'int LastRenderedPass()',
        summary: 'Implement to communicate last completed pass to the underlying system.',
        since: 6,
        returns: 'the last completed pass'
      },
      {
        signature: 'bool OnRenderSizeChanged(int width,int height)',
        summary: 'Override to restart your render engine',
        since: 6
      },
      {
        signature: 'int OpenGlVersion()',
        since: 6
      },
      {
        signature: 'void PostConstruct()',
        summary: `Override PostConstruct if you need to initialize where
     the underlying RealtimeDisplayMode is available.
     
     The connection is made right after RealtimeDisplayMode
     has been instantiated, but just before PostConstruct is called.
     
     For instance finding out OpenGL information can be done in
     PostConstruct.`,
        since: 6
      },
      {
        signature: 'void SetUseDrawOpenGl(bool use)',
        summary: `During run-time change whether to use OpenGL drawing of results or not. For instance
     offline rendering (viewcapture* with different resolution than viewport) could use
     RenderWindow instead of direct OpenGL drawing.`,
        since: 6,
        parameters: [
          {
            name: 'use',
            summary: `Set to True if OpenGL drawing is wanted, set to False if RenderWindow
     method is needed.`
          }
        ]
      },
      {
        signature: 'void SetView(ViewInfo view)',
        summary: 'Set ViewInfo for this RealtimeDisplayMode instance.',
        since: 6,
        parameters: [
          {
            name: 'view',
            summary: 'The ViewInfo to set for subsequent tests.'
          }
        ]
      },
      {
        signature: 'bool ShowCaptureProgress()',
        summary: 'Override if you want to i.e. hide the progress dialog for capture progress.',
        since: 6,
        returns: 'Return True to show, False to hide'
      },
      {
        signature: 'void ShutdownRenderer()',
        summary: 'Override to shutdown your render engine',
        since: 6
      },
      {
        signature: 'void SignalRedraw()',
        summary: `Use to signal the underlying pipeline a redraw is wanted. This can be used
     for instance when a renderer has completed a pass which should be
     updated in the associated viewport.`,
        since: 6
      },
      {
        signature: 'bool StartRenderer(int w,int h,RhinoDoc doc,ViewInfo view,ViewportInfo viewportInfo,bool forCapture,RenderWindow renderWindow)',
        summary: `Override to start your render engine.
     
     Note that before using the RenderWindow you *must* call SetSize
     to properly initialize the underlying DIB.`,
        since: 6,
        parameters: [
          {
            name: 'w',
            summary: 'Width of resolution'
          },
          {
            name: 'h',
            summary: 'Height of resolution'
          },
          {
            name: 'doc',
            summary: 'Rhino document'
          },
          {
            name: 'view',
            summary: 'active view'
          },
          {
            name: 'viewportInfo',
            summary: 'active viewport info'
          },
          {
            name: 'forCapture',
            summary: 'True if renderer is started for capture purposes (ViewCaptureTo*), False for regular interactive rendering'
          },
          {
            name: 'renderWindow',
            summary: 'RenderWindow to hold render results in.'
          }
        ],
        returns: 'Return True when your render engine started correctly, False when that failed'
      },
      {
        signature: 'bool UseFastDraw()',
        summary: `Implement and return True if you want the display pipeline to not
     wait for IsFramebufferAvailable during the MiddleGround draw phase.
     This will also tell the pipeline to draw a complete middleground pass in OpenGL.`,
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RealtimeDisplayMode.DisplayPipelineSettingsChangedEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    constructors: [
      {
        signature: 'RealtimeDisplayMode.DisplayPipelineSettingsChangedEventArgs(DisplayPipelineAttributes dpa)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'DisplayPipelineAttributes Attributes',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RealtimeDisplayMode.DrawMiddlegroundEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    constructors: [
      {
        signature: 'RealtimeDisplayMode.DrawMiddlegroundEventArgs(DisplayPipeline dp)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'DisplayPipeline Pipeline',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RealtimeDisplayMode.HudMaxPassesChangedEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    constructors: [
      {
        signature: 'RealtimeDisplayMode.HudMaxPassesChangedEventArgs(int mp)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'int MaxPasses',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RealtimeDisplayMode.InitFramebufferEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    constructors: [
      {
        signature: 'RealtimeDisplayMode.InitFramebufferEventArgs(DisplayPipeline dp)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'DisplayPipeline Pipeline',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RealtimeDisplayModeClassInfo',
    dataType: 1,
    summary: `Class information obligatory for registering RealtimeDisplayMode
   implementations.`,
    properties: [
      {
        signature: 'bool DontRegisterAttributesOnStart',
        summary: `Override and return True when you don't want your class info
     to cause display attributes to be registered with the system.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool DrawOpenGl',
        summary: `Return True if the RealtimeDisplayMode draws its result
     using OpenGL. RenderWindow usage will then be skipped.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid GUID',
        summary: 'Get the RealtimeDisplayMode implementation GUID',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Name',
        summary: `Get human-facing class description for RealtimeDisplayMode
     implementation. This string might show up in the Rhino
     UI.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'Type RealtimeDisplayModeType',
        summary: 'Get the type being registered.',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContent',
    dataType: 1,
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'bool CanBeEdited',
        summary: 'Determines if the content can be edited.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'String Category',
        summary: 'Category for this content.',
        since: 6.7,
        property: ['get']
      },
      {
        signature: 'String ChildSlotDisplayName',
        summary: 'Returns the localized display name of the child slot name',
        since: 7,
        property: ['get']
      },
      {
        signature: 'String ChildSlotName',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'IntPtr CppPointer',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'If this content is in a document content list, the document will be returned.  Otherwise null.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'RhinoDoc DocumentAssoc',
        summary: `If this content is associated by a document in any way, the document will be returned.  This includes copies of
     contents that were initially in the document. Otherwise null.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'RhinoDoc DocumentRegistered',
        summary: `If this content is used by a document, including not in the content lists (for example, as a decal),
     the document will be returned.  Otherwise null.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'FieldDictionary Fields',
        summary: `Rhino.Render.Fields FieldDictionary which provides access to setting
     and retrieving field values.`,
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'IEnumerable<string> FilesToEmbed',
        summary: `A string array of full paths to files used by the content that may be
     embedded in .3dm files and library files (.rmtl, .renv, .rtex). The
     default implementation returns an empty string list. Override this to
     return the file name or file names used by your content. This is
     typically used by textures that reference files containing the texture
     imagery.`,
        since: 5.12,
        property: ['get']
      },
      {
        signature: 'RenderContent FirstChild',
        summary: 'Return First child of this content or nullptr if none.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool Hidden',
        summary: 'Determines if the content has the hidden flag set.',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Guid Id',
        summary: 'Instance identifier for this content.',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool IsDefaultInstance',
        summary: 'Checks if render content is default instance.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsHiddenByAutoDelete',
        summary: `Contents can be created as 'auto-delete' by certain commands such as 'PictureFrame'.
     These contents are automatically hidden from the user when the associated Rhino object
     is deleted. They are later deleted when the document is saved.`,
        since: 6.15,
        property: ['get']
      },
      {
        signature: 'bool IsLocked',
        summary: `Set this property to True prior to adding content to the document to
     lock the content browser editing UI methods.  Setting this to True will
     keep the browser from allowing things like deleting, renaming or
     changing content.  This is useful for custom child content that you
     want to be editable but persistent.  Setting this after adding content
     to the document will cause an exception to be thrown.`,
        since: 5.12,
        property: ['get', 'set']
      },
      {
        signature: 'String Name',
        summary: 'Instance name for this content.',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'RenderContent NextSibling',
        summary: 'Return First sibling of this content or nullptr if none.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'String Notes',
        summary: 'Notes for this content.',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'RenderContent Parent',
        summary: 'Returns the top content in this parent/child chain.',
        since: 5.11,
        property: ['get']
      },
      {
        signature: 'ProxyTypes ProxyType',
        summary: 'Gets the proxy type of the render content',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint RenderHash',
        summary: `Render hash for the content hierarchy. It iterates children and includes
     a caching mechanism which means the hash value can be retrieved quickly
     if it hasn't changed. The cache is invalidated when Changed() is called.
     
     You can override the CalculateRenderHash method to provide
     a custom hash value.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'String Tags',
        summary: 'Tags for this content.',
        since: 6.4,
        property: ['get', 'set']
      },
      {
        signature: 'bool TopLevel',
        summary: 'Returns True if this content has no parent, False if it is the child of another content.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'RenderContent TopLevelParent',
        summary: 'Returns the top content in this parent/child chain.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'String TypeDescription',
        summary: 'Description for your content type.  ie.  "Procedural checker pattern"',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Guid TypeId',
        summary: 'Type identifier for this content',
        since: 6,
        property: ['get']
      },
      {
        signature: 'String TypeName',
        summary: 'Name for your content type.  ie. "My .net Texture"',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'String Xml',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static bool AddPersistentRenderContent(RenderContent renderContent)',
        summary: `Add a material, environment or texture to the internal RDK document lists as
     top level content.  The content must have been returned from
     RenderContent::MakeCopy, NewContentFromType or a similar function that returns
     a non-document content.`,
        since: 5.1,
        parameters: [
          {
            name: 'renderContent',
            summary: 'The render content.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'static bool AddPersistentRenderContent(RhinoDoc document,RenderContent renderContent)',
        summary: `Add a material, environment or texture to the internal RDK document lists as
     top level content.  The content must have been returned from
     RenderContent::MakeCopy, NewContentFromType or a similar function that returns
     a non-document content.`,
        since: 6,
        parameters: [
          {
            name: 'document',
            summary: 'The document to attach the render content to.'
          },
          {
            name: 'renderContent',
            summary: 'The render content.'
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'static RenderContent Create(Guid type,RenderContent parent,String childSlotName,ShowContentChooserFlags flags,RhinoDoc doc)',
        summary: `Constructs a new content of the specified type and add it to the persistent content list.
     This function cannot be used to create temporary content that you delete after use.
     Content created by this function is owned by RDK and appears in the content editor.
     To create a temporary content which is owned by you, call RenderContentType.NewContentFromType().`,
        since: 5.1,
        parameters: [
          {
            name: 'type',
            summary: 'is the type of the content to add.'
          },
          {
            name: 'parent',
            summary: `Parent is the parent content. If not NULL, this must be an RDK-owned content that is
     in the persistent content list (either top-level or child). The new content then becomes its child.
     If NULL, the new content is added to the top-level content list instead.`
          },
          {
            name: 'childSlotName',
            summary: 'ChildSlotName is the unique child identifier to use for the new content when creating it as a child of pParent (i.e., when pParent is not NULL)'
          },
          {
            name: 'flags',
            summary: 'Options for the tab.'
          },
          {
            name: 'doc',
            summary: 'The current Rhino document.'
          }
        ],
        returns: 'A new persistent render content.'
      },
      {
        signature: 'static RenderContent Create(Guid type,ShowContentChooserFlags flags,RhinoDoc doc)',
        summary: `Constructs a new content of the specified type and add it to the persistent content list.
     This function cannot be used to create temporary content that you delete after use.
     Content created by this function is owned by RDK and appears in the content editor.
     To create a temporary content which is owned by you, call RenderContentType.NewContentFromType().`,
        since: 5.1,
        parameters: [
          {
            name: 'type',
            summary: 'Is the type of the content to add.'
          },
          {
            name: 'flags',
            summary: 'Options for the tab.'
          },
          {
            name: 'doc',
            summary: 'The current Rhino document.'
          }
        ],
        returns: 'A new persistent render content.'
      },
      {
        signature: 'static RenderContent Create(Type type,RenderContent parent,String childSlotName,ShowContentChooserFlags flags,RhinoDoc doc)',
        summary: `Constructs a new content of the specified type and add it to the persistent content list.
     This function cannot be used to create temporary content that you delete after use.
     Content created by this function is owned by RDK and appears in the content editor.
     To create a temporary content which is owned by you, call RenderContentType.NewContentFromType().`,
        since: 5.1,
        parameters: [
          {
            name: 'type',
            summary: 'is the type of the content to add.'
          },
          {
            name: 'parent',
            summary: `Parent is the parent content. If not NULL, this must be an RDK-owned content that is
     in the persistent content list (either top-level or child). The new content then becomes its child.
     If NULL, the new content is added to the top-level content list instead.`
          },
          {
            name: 'childSlotName',
            summary: 'ChildSlotName is the unique child identifier to use for the new content when creating it as a child of pParent (i.e., when pParent is not NULL)'
          },
          {
            name: 'flags',
            summary: 'Options for the tab.'
          },
          {
            name: 'doc',
            summary: 'The current Rhino document.'
          }
        ],
        returns: 'A new persistent render content.'
      },
      {
        signature: 'static RenderContent Create(Type type,ShowContentChooserFlags flags,RhinoDoc doc)',
        summary: `Constructs a new content of the specified type and add it to the persistent content list.
     This function cannot be used to create temporary content that you delete after use.
     Content created by this function is owned by RDK and appears in the content editor.
     To create a temporary content which is owned by you, call RenderContentType.NewContentFromType().`,
        since: 5.1,
        parameters: [
          {
            name: 'type',
            summary: 'Is the type of the content to add.'
          },
          {
            name: 'flags',
            summary: 'Options for the tab.'
          },
          {
            name: 'doc',
            summary: 'The current Rhino document.'
          }
        ],
        returns: 'A new persistent render content.'
      },
      {
        signature: 'static RenderContent FromId(RhinoDoc document,Guid id)',
        summary: 'Search for a content object based on its Id',
        since: 5.7,
        parameters: [
          {
            name: 'document',
            summary: 'The Rhino document containing the content.'
          },
          {
            name: 'id',
            summary: 'Id of the content instance to search for.'
          }
        ],
        returns: `Returns the content object with the specified Id if it is found
     otherwise it returns null.`
      },
      {
        signature: 'static RenderContent FromXml(String xml)',
        since: 6
      },
      {
        signature: 'static RenderContent FromXml(String xml,RhinoDoc doc)',
        since: 6.4
      },
      {
        signature: 'static RenderContent LoadFromFile(String filename)',
        summary: `Loads content from a library file.  Does not add the content to the persistent content list.
     Use AddPersistantContent to add it to the list.`,
        since: 5.1,
        parameters: [
          {
            name: 'filename',
            summary: 'full path to the file to be loaded.'
          }
        ],
        returns: 'The loaded content or None if an error occurred.'
      },
      {
        signature: 'static Type[] RegisterContent(Assembly assembly,Guid pluginId)',
        summary: `Call RegisterContent in your plug-in's OnLoad function in order to register all of the
     custom RenderContent classes in your assembly.`,
        since: 5.1,
        parameters: [
          {
            name: 'assembly',
            summary: `Assembly where custom content is defined, this may be a plug-in assembly
     or another assembly referenced by the plug-in.`
          },
          {
            name: 'pluginId',
            summary: 'Parent plug-in for this assembly.'
          }
        ],
        returns: 'array of render content types registered on success. None on error.'
      },
      {
        signature: 'static Type[] RegisterContent(PlugIn plugin)',
        summary: `Call RegisterContent in your plug-in's OnLoad function in order to register all of the
     custom RenderContent classes in your assembly.`,
        since: 5.1,
        returns: 'array of render content types registered on success. None on error.'
      },
      {
        signature: 'bool AddAutomaticUserInterfaceSection(string caption,int id)',
        summary: `Add a new automatic user interface section, Field values which include
     prompts will be automatically added to this section.`,
        since: 5.1,
        parameters: [
          {
            name: 'caption',
            summary: 'Expandable tab caption.'
          },
          {
            name: 'id',
            summary: 'Tab id which may be used later on to reference this tab.'
          }
        ],
        returns: `Returns True if the automatic tab section was added otherwise; returns
     False on error.`
      },
      {
        signature: 'bool AddChild(RenderContent renderContent)',
        since: 5.6
      },
      {
        signature: 'bool AddChild(RenderContent renderContent,String childSlotName)',
        since: 6
      },
      {
        signature: 'bool AddUserInterfaceSection(ICollapsibleSection section)',
        since: 6
      },
      {
        signature: 'UI.UserInterfaceSection AddUserInterfaceSection(Type classType,string caption,bool createExpanded,bool createVisible)',
        summary: `Add a new .NET control to an content expandable tab section, the height
     of the createExpanded tabs client area will be the initial height of the
     specified control.`,
        since: 5.1,
        parameters: [
          {
            name: 'classType',
            summary: `The control class to create and embed as a child window in the
     expandable tab client area.  This class type must be derived from
     IWin32Window or this method will throw an ArgumentException.  Implement
     the IUserInterfaceSection interface in your classType to get
     UserInterfaceSection notification.`
          },
          {
            name: 'caption',
            summary: 'Expandable tab caption.'
          },
          {
            name: 'createExpanded',
            summary: `If this value is True then the new expandable tab section will
     initially be expanded, if it is False it will be collapsed.`
          },
          {
            name: 'createVisible',
            summary: `If this value is True then the new expandable tab section will
     initially be visible, if it is False it will be hidden.`
          }
        ],
        returns: `Returns the UserInterfaceSection object used to manage the new 
     user control object.`
      },
      {
        signature: 'void BeginChange(ChangeContexts changeContext)',
        summary: `Begins a change or batch of changes. This returns a reference to the
     content which you should use to make your changes. It may also make a
     copy of the content state allowing EndChange to send an
     event with the old and new contents. Calls to this method are counted;
     you must call EndChange() once for every call to BeginChange().
     Note:
       If Changed() was called between the calls to BeginChange() and
       EndChange(), the last call to EndChange() may cause the ContentChanged
       event to be sent.`,
        since: 6,
        parameters: [
          {
            name: 'changeContext',
            summary: `the change context. If this is kUI, kProgram, kDrop or kTree, the
     content will be copied. EndChange() will then send the copy as 'old' in
     the OnContentChanged event.
     Note:
       If you override this method, please be sure to call the base
       class. EndChangeContentChanged`
          }
        ]
      },
      {
        signature: 'void BindParameterToField(string parameterName,Field field,ChangeContexts setEvent)',
        summary: 'Use bindings to automatically wire parameters to fields',
        since: 5.7
      },
      {
        signature: 'void BindParameterToField(string parameterName,string childSlotName,Field field,ChangeContexts setEvent)',
        summary: 'Use bindings to automatically wire parameters to fields',
        since: 5.7
      },
      {
        signature: 'bool ChangeChild(RenderContent oldContent,RenderContent newContent)',
        since: 5.6
      },
      {
        signature: 'double ChildSlotAmount(String childSlotName)',
        summary: 'Gets the amount property for the texture in the specified child slot.  Values are typically from 0.0 - 100.0',
        since: 5.7,
        parameters: [
          {
            name: 'childSlotName',
            summary: 'Child slot name for the child'
          }
        ]
      },
      {
        signature: 'string ChildSlotNameFromParamName(String paramName)',
        summary: `A "child slot" is the specific "slot" that a child (usually a texture) occupies.
     This is generally the "use" of the child - in other words, the thing the child
     operates on.  Some examples are "color", "transparency".`,
        since: 5.1,
        parameters: [
          {
            name: 'paramName',
            summary: `The name of a parameter field. Since child textures will usually correspond with some
    parameter (they generally either replace or modify a parameter over UV space) these functions are used to
    specify which parameter corresponded with child slot.  If there is no correspondence, return the empty
    string.`
          }
        ],
        returns: `The default behavior for these functions is to return the input string.
     Sub-classes may (in the future) override these functions to provide different mappings.`
      },
      {
        signature: 'bool ChildSlotOn(String childSlotName)',
        summary: 'Gets the on-ness property for the texture in the specified child slot.',
        since: 5.7,
        parameters: [
          {
            name: 'childSlotName',
            summary: 'Child slot name for the child'
          }
        ]
      },
      {
        signature: 'void DeleteAllChildren(ChangeContexts changeContexts)',
        since: 5.1
      },
      {
        signature: 'bool DeleteChild(string childSlotName,ChangeContexts changeContexts)',
        since: 5.1
      },
      {
        signature: 'void Dispose()',
        since: 5.1
      },
      {
        signature: 'bool DynamicIcon(Size size,Bitmap bitmap,DynamicIconUsage usage)',
        since: 6
      },
      {
        signature: 'RenderContent Edit()',
        summary: `Call this method to open the content in the a modal version of the editor.
     The content must be in the document or the call will fail.`,
        since: 6.13,
        returns: 'Returns the edited content on succees or None on error.'
      },
      {
        signature: 'void EndChange()',
        summary: `Ends a change or batch of changes. Calls to this method are counted;
     you must call this method once for every call to BeginChange.
     Note:
       If BeginChange was called with ChangeContexts.UI,
       ChangeContexts.Program, ChangeContexts.Drop or ChangeContexts.UI.Tree
       and Changed() was called between the calls to BeginChange and
       EndChange(), the last call to EndChange() will raise the
       ContentChanged event.`,
        since: 6
      },
      {
        signature: 'DataSources.ContentFactory Factory()',
        since: 6.1
      },
      {
        signature: 'RenderContent FindChild(String childSlotName)',
        since: 5.1
      },
      {
        signature: 'RenderContent ForDisplay()',
        summary: `**** This method is for proxies and will be marked obsolete in V7 ****
    
     The only place a single proxy can be displayed is in the
     New Content Control main thumbnail. All other attempts to
     use a single proxy in a UI require it to be replaced with
     the corresponding multi proxy. Single proxies override this
     to find the corresponding multi proxy.`,
        since: 6.9,
        returns: 'The cotnent.'
      },
      {
        signature: 'object GetChildSlotParameter(String parameterName,String childSlotName)',
        summary: `Extra requirements are a way of specifying extra functionality on parameters in the automatic UI.
     Implement this function to specify additional functionality for automatic UI sections or the texture summary.
     See IAutoUIExtraRequirements.h in the C++ RDK for string definitions for the parameter names.`,
        since: 5.7,
        parameters: [
          {
            name: 'parameterName',
            summary: 'The parameter or field internal name to which this query applies'
          },
          {
            name: 'childSlotName',
            summary: 'The extra requirement parameter, as listed in IAutoUIExtraRequirements.h in the C++ RDK'
          }
        ],
        returns: `Call the base class if you do not support the extra requirement parameter.
     Current supported return values are (int, bool, float, double, string, Guid, Color, Vector3d, Point3d, DateTime)`
      },
      {
        signature: 'string[] GetEmbeddedFilesList()',
        since: 6
      },
      {
        signature: 'object GetParameter(String parameterName)',
        summary: `Query the content instance for the value of a given named parameter.
     If you do not support this parameter, call the base class.`,
        since: 5.7,
        parameters: [
          {
            name: 'parameterName',
            summary: 'Name of the parameter'
          }
        ],
        returns: 'IConvertible. Note that you can\'t directly cast from object, instead you have to use the Convert mechanism.'
      },
      {
        signature: 'bool GetUnderlyingInstances(RenderContentCollection collection)',
        since: 7
      },
      {
        signature: 'bool Icon(Size size,Bitmap bitmap)',
        since: 6
      },
      {
        signature: 'bool Initialize()',
        since: 6.1
      },
      {
        signature: 'bool IsCompatible(Guid renderEngineId)',
        since: 6
      },
      {
        signature: 'bool IsContentTypeAcceptableAsChild(Guid type,String childSlotName)',
        since: 6
      },
      {
        signature: 'bool IsFactoryProductAcceptableAsChild(ContentFactory factory,String childSlotName)',
        since: 6.1
      },
      {
        signature: 'bool IsFactoryProductAcceptableAsChild(Guid kindId,string factoryKind,string childSlotName)',
        summary: `Override this method to restrict the type of acceptable child content.
     The default implementation of this method just returns true.`,
        since: 5.11,
        returns: `Return True only if content with the specified kindId can be  accepted
     as a child in the specified child slot.`
      },
      {
        signature: 'bool IsReference()',
        summary: 'Query whether or not the content or any of its ancestors is a reference content.',
        since: 6.9,
        returns: 'True if the content is a reference, else false'
      },
      {
        signature: 'bool IsRenderHashCached()',
        summary: `This method is deprecated and no longer called. For more information
     see CalculateRenderHash`,
        since: 6,
        returns: 'bool'
      },
      {
        signature: 'RenderContent MakeCopy()',
        summary: `Create a copy of the render content. All content is the same, except for the
     instance Id.`,
        since: 6,
        returns: 'The new RenderContent'
      },
      {
        signature: 'MatchDataResult MatchData(RenderContent oldContent)',
        summary: 'Implement to transfer data from another content to this content during creation.',
        since: 6,
        parameters: [
          {
            name: 'oldContent',
            summary: 'An old content object from which the implementation may harvest data.'
          }
        ],
        returns: 'Information about how much data was matched.'
      },
      {
        signature: 'PreviewSceneServer NewPreviewSceneServer(SceneServerData ssd)',
        summary: 'Gets the PreviewSceneServer of the content',
        since: 6,
        parameters: [
          {
            name: 'ssd',
            summary: 'SceneServerData'
          }
        ]
      },
      {
        signature: 'bool OpenInEditor()',
        summary: `Call this method to open the content in the relevant thumbnail editor
     and select it for editing by the user. The content must be in the
     document or the call will fail.`,
        since: 5.7,
        returns: 'Returns True on success or False on error.'
      },
      {
        signature: 'bool OpenInModalEditor()',
        summary: `Call this method to open the content in the a modal version of the editor.
     The content must be in the document or the call will fail.`,
        since: 5.7,
        returns: 'Returns True on success or False on error.'
      },
      {
        signature: 'string ParamNameFromChildSlotName(String childSlotName)',
        summary: `A "child slot" is the specific "slot" that a child (usually a texture) occupies.
     This is generally the "use" of the child - in other words, the thing the child
     operates on.  Some examples are "color", "transparency".`,
        since: 5.1,
        parameters: [
          {
            name: 'childSlotName',
            summary: 'The named of the child slot to receive the parameter name for.'
          }
        ],
        returns: 'The default behavior for these functions is to return the input string.  Sub-classes may (in the future) override these functions to provide different mappings.'
      },
      {
        signature: 'uint RenderHashExclude(CrcRenderHashFlags flags,string excludeParameterNames)',
        summary: 'As RenderHash, but ignore parameter names given.',
        since: 6.2,
        parameters: [
          {
            name: 'flags',
            summary: 'Flags to ignore'
          },
          {
            name: 'excludeParameterNames',
            summary: 'semicolon-delimited string'
          }
        ],
        returns: 'Render hash'
      },
      {
        signature: 'uint RenderHashExclude(TextureRenderHashFlags flags,string excludeParameterNames)',
        summary: 'As RenderHash, but ignore parameter names given.',
        since: 6,
        parameters: [
          {
            name: 'flags',
            summary: 'Flags to ignore'
          },
          {
            name: 'excludeParameterNames',
            summary: 'semicolon-delimited string'
          }
        ],
        returns: 'Render hash'
      },
      {
        signature: 'bool Replace(RenderContent newcontent)',
        since: 6.13
      },
      {
        signature: 'bool SetChild(RenderContent renderContent,String childSlotName)',
        summary: `Set another content as a child of this content. This content may or may
     not be attached to a document.  If this content already has a child
     with the specified child slot name, that child will be deleted.  If
     this content is not attached to a document, the child will be added
     without sending any events.  If this content is attached to a document,
     the necessary events will be sent to update the UI.
     Note:
       Do not call this method to add children in your constructor. If you
       want to add default children, you should override Initialize() and add
       them there.`,
        since: 6,
        parameters: [
          {
            name: 'renderContent',
            summary: `Child content to add to this content. If pChild is NULL, the function
     will fail.  If pChild is already attached to a document, the function
     will fail.  If pChild is already a child of this or another content,
     the function will fail.`
          },
          {
            name: 'childSlotName',
            summary: `The name that will be assigned to this child slot. The child slot name
     cannot be an empty string. If it is, the function will fail.`
          }
        ],
        returns: `Returns True if the content was added or the child slot with this name
     was modified otherwise; returns false.`
      },
      {
        signature: 'bool SetChild(RenderContent renderContent,String childSlotName,ChangeContexts changeContexts)',
        summary: `Set another content as a child of this content. This content may or may
     not be attached to a document.  If this content already has a child
     with the specified child slot name, that child will be deleted.  If
     this content is not attached to a document, the child will be added
     without sending any events.  If this content is attached to a document,
     the necessary events will be sent to update the UI.
     Note:
       Do not call this method to add children in your constructor. If you
       want to add default children, you should override Initialize() and add
       them there.`,
        since: 5.1,
        parameters: [
          {
            name: 'renderContent',
            summary: `Child content to add to this content. If pChild is NULL, the function
     will fail.  If pChild is already attached to a document, the function
     will fail.  If pChild is already a child of this or another content,
     the function will fail.`
          },
          {
            name: 'childSlotName',
            summary: `The name that will be assigned to this child slot. The child slot name
     cannot be an empty string. If it is, the function will fail.`
          },
          {
            name: 'changeContexts',
            summary: ''
          }
        ],
        returns: `Returns True if the content was added or the child slot with this name
     was modified otherwise; returns false.`
      },
      {
        signature: 'void SetChildSlotAmount(String childSlotName,double amount,ChangeContexts cc)',
        summary: 'Sets the amount property for the texture in the specified child slot.  Values are typically from 0.0 - 100.0',
        since: 5.7,
        parameters: [
          {
            name: 'childSlotName',
            summary: 'Child slot name for the child'
          },
          {
            name: 'amount',
            summary: 'Texture amount. Values are typically from 0.0 - 100.0'
          },
          {
            name: 'cc',
            summary: 'Context of the change.'
          }
        ]
      },
      {
        signature: 'void SetChildSlotOn(String childSlotName,bool bOn,ChangeContexts cc)',
        summary: 'Sets the on-ness property for the texture in the specified child slot.',
        since: 5.7,
        parameters: [
          {
            name: 'childSlotName',
            summary: 'Child slot name for the child'
          },
          {
            name: 'bOn',
            summary: 'Value for the on-ness property.'
          },
          {
            name: 'cc',
            summary: 'Context of the change'
          }
        ]
      },
      {
        signature: 'bool SetChildSlotParameter(String parameterName,String childSlotName,object value,ExtraRequirementsSetContexts sc)',
        summary: `Extra requirements are a way of specifying extra functionality on parameters in the automatic UI.
     Implement this function to support values being set from automatic UI sections or the texture summary.
     See IAutoUIExtraRequirements.h in the C++ RDK for string definitions for the parameter names.`,
        since: 5.7,
        parameters: [
          {
            name: 'parameterName',
            summary: 'The parameter or field internal name to which this query applies'
          },
          {
            name: 'childSlotName',
            summary: 'The extra requirement parameter, as listed in IAutoUIExtraRequirements.h in the C++ RDK'
          },
          {
            name: 'value',
            summary: 'The value to set this extra requirement parameter. You will typically use System.Convert to convert the value to the type you need'
          },
          {
            name: 'sc',
            summary: 'The context of this operation.'
          }
        ],
        returns: 'Null variant if not supported.  Call the base class if you do not support the extra requirement paramter.'
      },
      {
        signature: 'void SetName(string name,bool bRenameEvents,bool bEnsureNameUnique)',
        summary: 'Set instance name for this content',
        since: 7
      },
      {
        signature: 'bool SetParameter(String parameterName,object value)',
        summary: `Set the named parameter value for this content instance.
     If you do not support this parameter, call the base class.`,
        since: 6
      },
      {
        signature: 'bool SetParameter(String parameterName,object value,ChangeContexts changeContext)',
        summary: `Set the named parameter value for this content instance.
     If you do not support this parameter, call the base class.`,
        since: 5.7
      },
      {
        signature: 'void SetRenderHash(uint hash)',
        summary: `This method is deprecated and no longer called. For more information
     see CalculateRenderHash`,
        since: 6
      },
      {
        signature: 'void Uninitialize()',
        since: 6.1
      },
      {
        signature: 'int UseCount()',
        summary: 'UseCount returns how many times the content is used',
        since: 6.9
      },
      {
        signature: 'bool VirtualIcon(Size size,Bitmap bitmap)',
        summary: `Icon to display in the content browser, this bitmap needs to be valid for
     the life of this content object, the content object that returns the bitmap
     is responsible for disposing of the bitmap.`,
        since: 6,
        parameters: [
          {
            name: 'size',
            summary: 'Requested icon size'
          },
          {
            name: 'bitmap',
            summary: ''
          }
        ],
        returns: 'Return Icon to display in the content browser.'
      }
    ],
    events: [
      {
        signature: 'static ContentAdded',
        summary: 'Used to monitor render content addition to the document.',
        since: 5.7
      },
      {
        signature: 'static ContentChanged',
        summary: 'Used to monitor render content modifications.',
        since: 5.7
      },
      {
        signature: 'static ContentDeleted',
        summary: 'Used to monitor render content deletion from the document.',
        since: 6
      },
      {
        signature: 'static ContentDeleting',
        summary: 'Used to monitor render content deletion from the document.',
        since: 5.7
      },
      {
        signature: 'static ContentFieldChanged',
        summary: 'This event is raised when a field value is modified.',
        since: 5.11
      },
      {
        signature: 'static ContentRenamed',
        summary: 'Used to monitor render content renaming in the document.',
        since: 5.7
      },
      {
        signature: 'static ContentReplaced',
        summary: 'Used to monitor render content replacing in the document.',
        since: 5.7
      },
      {
        signature: 'static ContentReplacing',
        summary: 'Used to monitor render content replacing in the document.',
        since: 5.7
      },
      {
        signature: 'static ContentUpdatePreview',
        summary: 'Used to monitor render content preview updates.',
        since: 5.7
      },
      {
        signature: 'static CurrentEnvironmentChanged',
        summary: `Event fired when changes to current environments have been made.
     This will be one of Background, ReflectionAndRefraction or Skylighting
     Since 6.11`,
        since: 6.11
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContent.ChangeContexts',
    dataType: 3,
    summary: 'Context of a change to content parameters.',
    values: [
      {
        signature: 'UI = 0',
        summary: 'Change occurred as a result of user activity in the content\'s UI.'
      },
      {
        signature: 'Drop = 1',
        summary: 'Change occurred as a result of drag and drop.'
      },
      {
        signature: 'Program = 2',
        summary: 'Change occurred as a result of internal program activity.'
      },
      {
        signature: 'Ignore = 3',
        summary: 'Change can be disregarded.'
      },
      {
        signature: 'Tree = 4',
        summary: 'Change occurred within the content tree (e.g., nodes reordered).'
      },
      {
        signature: 'Undo = 5',
        summary: 'Change occurred as a result of an undo.'
      },
      {
        signature: 'FieldInit = 6',
        summary: 'Change occurred as a result of a field initialization.'
      },
      {
        signature: 'Serialize = 7',
        summary: 'Change occurred during serialization (loading).'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContent.ExtraRequirementsSetContexts',
    dataType: 3,
    values: [
      {
        signature: 'UI = 0',
        summary: 'Setting extra requirement as a result of user activity.'
      },
      {
        signature: 'Drop = 1',
        summary: 'Setting extra requirement as a result of drag and drop.'
      },
      {
        signature: 'Program = 2',
        summary: 'Setting extra requirement as a result of other (non-user) program activity.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContent.MatchDataResult',
    dataType: 3,
    summary: 'Return values for MatchData function',
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'Some = 1'
      },
      {
        signature: 'All = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContent.ShowContentChooserFlags',
    dataType: 3,
    values: [
      {
        signature: 'None = 0x0000'
      },
      {
        signature: 'HideNewTab = 0x0001'
      },
      {
        signature: 'HideExistingTab = 0x0002'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContentChangedEventArgs',
    dataType: 1,
    baseclass: 'Rhino.Render.RenderContentEventArgs',
    properties: [
      {
        signature: 'ChangeContexts ChangeContext',
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'RenderContent OldContent',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContentChangeReason',
    dataType: 3,
    summary: 'Enumeration denoting type of change for attach or detach',
    values: [
      {
        signature: 'None',
        summary: 'No attach or detach change'
      },
      {
        signature: 'Attach',
        summary: 'Content is being attached by the RhinoDoc.AttachContent() or RenderContent.AttachChild() methods.'
      },
      {
        signature: 'Detach',
        summary: 'Content is being detached by the RenderContent.DeleteContent() method.'
      },
      {
        signature: 'ChangeAttach',
        summary: 'Content is being attached while changing.'
      },
      {
        signature: 'ChangeDetach',
        summary: 'Content is being detached while changing.'
      },
      {
        signature: 'AttachUndo',
        summary: 'Content is being attached during undo/redo'
      },
      {
        signature: 'DetachUndo',
        summary: 'Content is being detached during undo/redo.'
      },
      {
        signature: 'Open',
        summary: 'Content is being attached during open document'
      },
      {
        signature: 'Delete',
        summary: 'Content is being detached during normal deletion.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContentCollection',
    dataType: 1,
    interfaces: ['IDisposable', 'IEnumerable'],
    constructors: [
      {
        signature: 'RenderContentCollection()',
        since: 6
      },
      {
        signature: 'RenderContentCollection(IntPtr nativePtr)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(RenderContentCollection collection)',
        since: 6
      },
      {
        signature: 'void Append(RenderContent content)',
        since: 6
      },
      {
        signature: 'void Clear()',
        since: 6
      },
      {
        signature: 'RenderContent ContentAt(int index)',
        since: 6
      },
      {
        signature: 'bool ContentNeedsPreviewThumbnail(RenderContent c)',
        since: 7
      },
      {
        signature: 'bool ContentNeedsPreviewThumbnail(RenderContent c,bool bIncludeChildren)',
        since: 7
      },
      {
        signature: 'int Count()',
        since: 6
      },
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'RenderContent Find_Sel(Guid uuid)',
        since: 6
      },
      {
        signature: 'string FirstTag()',
        since: 6.13
      },
      {
        signature: 'IEnumerator GetEnumerator()',
        since: 6
      },
      {
        signature: 'FilterContentByUsage GetFilterContentByUsage()',
        since: 6.9
      },
      {
        signature: 'bool GetForcedVaries()',
        since: 6.9
      },
      {
        signature: 'string GetSearchPattern()',
        since: 6
      },
      {
        signature: 'ContentCollectionIterator Iterator()',
        since: 6
      },
      {
        signature: 'string NextTag()',
        since: 6.13
      },
      {
        signature: 'void Remove(RenderContentCollection collection)',
        since: 6
      },
      {
        signature: 'void Set(RenderContentCollection collection)',
        since: 6
      },
      {
        signature: 'void SetForcedVaries(bool b)',
        since: 6.9
      },
      {
        signature: 'void SetSearchPattern(string pattern)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContentEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RenderContent Content',
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Usage EnvironmentUsage',
        summary: `Meaningful for CurrentEnvironmentChanged event. Will be one of Background, ReflectionAndRefraction or Skylighting.
     
     Since 6.11`,
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'RenderContentChangeReason Reason',
        summary: 'Not when used in CurrentEnvironmentChanged (defaults to None).',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContentFieldChangedEventArgs',
    dataType: 1,
    baseclass: 'Rhino.Render.RenderContentChangedEventArgs',
    properties: [
      {
        signature: 'string FieldName',
        since: 5.11,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContentKind',
    dataType: 3,
    summary: `Defines constant values for all render content kinds, such as material,
   environment or texture.`,
    values: [
      {
        signature: 'None = UnsafeNativeMethods.CRhRdkContentKindConst.None'
      },
      {
        signature: 'Material = UnsafeNativeMethods.CRhRdkContentKindConst.Material'
      },
      {
        signature: 'Environment = UnsafeNativeMethods.CRhRdkContentKindConst.Environment'
      },
      {
        signature: 'Texture = UnsafeNativeMethods.CRhRdkContentKindConst.Texture'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContentKindList',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'RenderContentKindList()',
        since: 6.7
      },
      {
        signature: 'RenderContentKindList(IntPtr pRdkRenderContentKindList)',
        since: 6.1
      },
      {
        signature: 'RenderContentKindList(RenderContentKindList kind_list)',
        since: 6.7
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6.1,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(RenderContentKind kind)',
        since: 6.7
      },
      {
        signature: 'bool Contains(RenderContentKind kind)',
        since: 6.3
      },
      {
        signature: 'int Count()',
        since: 6.1
      },
      {
        signature: 'void Dispose()',
        since: 6.1
      },
      {
        signature: 'RenderContentKind SingleKind()',
        since: 6.1
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContentManager',
    dataType: 1,
    summary: `RenderContentManager's RestoreRenderContents method unpacks the 
   default render contents from the from the application and places them 
   in the User's folder.  Only available on Mac at the moment.`,
    properties: [
      {
        signature: 'static string UserRenderContentPath',
        summary: `Get the path to: 
     Windows: C:\\Users\\user\\AppData\\Roaming\\McNeel\\Rhinoceros\\6.0\\Localization\\en-US\\Render Content
     macOS: ~/Library/Application Support/McNeel/Rhinoceros/6.0/Render Content
     If a CustomLibraryPath is set, this is returned`,
        since: 6.1,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static bool RestoreRenderContent()',
        summary: `Unpacks the default render contents from the from the application and places them in the User's folder.
     This will restore the default versions if the version of Rhino that is running is newer than the contents
     of the last Rhino that wrote the version.txt file.  If the version.txt file is not present, it will
     automatically restore the default contents.  This does not overwrite files that the user has changed.`,
        since: 6.1
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContentSerializer',
    dataType: 1,
    summary: `Used to import and export custom render content types such as
   materials, environments and textures.  You must override
   RenderPlugIn.RenderContentSerializers() and return an array of
   derived RenderContentSerializer class types to add to the content
   browsers.`,
    properties: [
      {
        signature: 'bool CanRead',
        summary: `If True then the file type can be imported and will be included in the
     file open box when importing the specified render content type.`,
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'bool CanWrite',
        summary: `If True then the file type can be exported and will be included in the
     file save box when exporting the specified render content type.`,
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'RenderContentKind ContentType',
        summary: 'Type of content created when importing or exporting this file type.',
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'String EnglishDescription',
        summary: 'English string describing this plug-in',
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'string FileExtension',
        summary: 'File extension associated with this serialize object',
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'String LocalDescription',
        summary: 'Localized plug-in description',
        since: 5.7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'RenderContent Read(String pathToFile)',
        summary: `Called to when importing a file, file should be parsed and converted to
     a valid RenderContent object.`,
        since: 5.7,
        parameters: [
          {
            name: 'pathToFile',
            summary: 'Full path of the file to load.'
          }
        ],
        returns: `Returns a valid RenderContent object such as RenderMaterial if the file
     was successfully parsed otherwise returns null.`
      },
      {
        signature: 'bool RegisterSerializer(Guid id)',
        summary: 'Register the RenderContentSerializer',
        since: 6,
        parameters: [
          {
            name: 'id',
            summary: 'Plug-in id'
          }
        ]
      },
      {
        signature: 'bool Write(String pathToFile,RenderContent renderContent,CreatePreviewEventArgs previewArgs)',
        summary: 'Called to save a custom RenderContent object as an external file.',
        since: 5.7,
        parameters: [
          {
            name: 'pathToFile',
            summary: 'Full path of file to write'
          },
          {
            name: 'renderContent',
            summary: 'Render content to save'
          },
          {
            name: 'previewArgs',
            summary: `Parameters used to generate a preview image which may be embedded in
     the exported file.`
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContentStyles',
    dataType: 3,
    values: [
      {
        signature: 'None = 0',
        summary: 'No defined styles'
      },
      {
        signature: 'TextureSummary = 0x0001',
        summary: 'Texture UI includes an auto texture summary section. See AddAutoParameters().'
      },
      {
        signature: 'QuickPreview = 0x0002',
        summary: 'Editor displays an instant preview before preview cycle begins.'
      },
      {
        signature: 'PreviewCache = 0x0004',
        summary: 'Content\'s preview imagery can be stored in the preview cache.'
      },
      {
        signature: 'ProgressivePreview = 0x0008',
        summary: 'Content\'s preview imagery can be rendered progressively.'
      },
      {
        signature: 'LocalTextureMapping = 0x0010',
        summary: 'Texture UI includes an auto local mapping section for textures. See AddAutoParameters()'
      },
      {
        signature: 'GraphDisplay = 0x0020',
        summary: 'Texture UI includes a graph section.'
      },
      {
        signature: '    SharedUI = 0x0040',
        summary: 'Content supports UI sharing between contents of the same type id.'
      },
      {
        signature: 'Adjustment = 0x0080',
        summary: 'Texture UI includes an adjustment section.'
      },
      {
        signature: 'Fields = 0x0100',
        summary: 'Content uses fields to facilitate data storage and undo support. See Fields()'
      },
      {
        signature: 'ModalEditing = 0x0200',
        summary: 'Content supports editing in a modal editor.'
      },
      {
        signature: 'DynamicFields = 0x0400',
        summary: 'The content\'s fields are dynamic. Dynamic fields can be created during loading.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContentTableEventForwarder.RenderContentTableEventArgs',
    dataType: 1,
    baseclass: 'EventArgs'
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderContentType',
    dataType: 1,
    summary: 'Represents one of the render content types registered with Rhino.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'RenderContentType(Guid typeId)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'Guid Id',
        summary: 'Returns the type identifier associated with this type.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'String InternalName',
        summary: 'Returns the internal name identifier associated with this type.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid PlugInId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid RenderEngineId',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static RenderContentType[] GetAllAvailableTypes()',
        summary: 'Gets an array of all available render content types registered with Rhino.',
        since: 6,
        returns: 'An array with all types.'
      },
      {
        signature: 'static RenderContent NewContentFromTypeId(Guid typeId)',
        summary: `Create a new content specified by the Guid.
    
     This function can be used to create temporary content, as it calls
     ::RhRdkContentFactories().NewContentFromType().`,
        since: 6
      },
      {
        signature: 'static RenderContent NewContentFromTypeId(Guid typeId,RhinoDoc doc)',
        since: 6.4
      },
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'RenderContent NewRenderContent()',
        summary: 'Returns a new instance of the render content of this type.  This content can be added to a persistant list.',
        since: 6,
        returns: 'A new render content instance.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderCustomEventArgs',
    dataType: 1,
    summary: 'Used as Rhino.Render Custom Events args.',
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'IntPtr Argument',
        summary: 'The pointer to the custom event args.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'Guid EventType',
        summary: 'The type of the event.',
        since: 7,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderEndEventArgs',
    dataType: 1,
    summary: 'Contains information about why OnRenderEnd was called',
    baseclass: 'EventArgs'
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderEnvironment',
    dataType: 1,
    baseclass: 'Rhino.Render.RenderContent',
    properties: [
      {
        signature: 'static RenderEnvironment CurrentEnvironment',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'String TextureChildSlotName',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static RenderEnvironment NewBasicEnvironment(SimulatedEnvironment environment)',
        summary: 'Constructs a new RenderEnvironment from a SimulatedEnvironment.',
        since: 5.3,
        parameters: [
          {
            name: 'environment',
            summary: 'The environment to create the basic environment from.'
          }
        ],
        returns: 'A new basic environment.'
      },
      {
        signature: 'static RenderEnvironment NewBasicEnvironment(SimulatedEnvironment environment,RhinoDoc doc)',
        since: 6.4
      },
      {
        signature: 'SimulatedEnvironment SimulateEnvironment(bool isForDataOnly)',
        since: 6
      },
      {
        signature: 'void SimulateEnvironment(SimulatedEnvironment simulation,bool isForDataOnly)',
        since: 5.1
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderEnvironment.Usage',
    dataType: 3,
    values: [
      {
        signature: 'None                      = 0x00'
      },
      {
        signature: 'Background                = 0x01'
      },
      {
        signature: 'ReflectionAndRefraction   = 0x02'
      },
      {
        signature: 'Skylighting               = 0x04'
      },
      {
        signature: 'AnyUsage                  = Background | ReflectionAndRefraction | Skylighting'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderEnvironmentTable',
    dataType: 1,
    interfaces: ['IRenderContentTable<RenderEnvironment>', 'IEnumerable<RenderEnvironment>', 'Collections.IRhinoTable<RenderEnvironment>'],
    properties: [
      {
        signature: 'int Count',
        since: 5.7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool Add(RenderEnvironment c)',
        since: 6
      },
      {
        signature: 'void BeginChange(ChangeContexts changeContext)',
        since: 7
      },
      {
        signature: 'void EndChange()',
        since: 7
      },
      {
        signature: 'IEnumerator<RenderEnvironment> GetEnumerator()',
        since: 5.7
      },
      {
        signature: 'bool Remove(RenderEnvironment c)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'Rendering.CommandFilters',
    dataType: 3,
    values: [
      {
        signature: 'ToolButton = UnsafeNativeMethods.RdkRendering_CommandFilters.ToolButton'
      },
      {
        signature: 'MenuItem = UnsafeNativeMethods.RdkRendering_CommandFilters.MenuItem'
      },
      {
        signature: 'All = UnsafeNativeMethods.RdkRendering_CommandFilters.All'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'Rendering.StatusTexts',
    dataType: 3,
    values: [
      {
        signature: 'Image = UnsafeNativeMethods.RdkRendering_StatusTexts.Image'
      },
      {
        signature: 'Zoom = UnsafeNativeMethods.RdkRendering_StatusTexts.Zoom'
      },
      {
        signature: 'Channel = UnsafeNativeMethods.RdkRendering_StatusTexts.Channel'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderingCommand.MenuCategories',
    dataType: 3,
    values: [
      {
        signature: 'File = UnsafeNativeMethods.RdkRenderingCommand_MenuCategories.File'
      },
      {
        signature: 'Edit = UnsafeNativeMethods.RdkRenderingCommand_MenuCategories.Edit'
      },
      {
        signature: 'View = UnsafeNativeMethods.RdkRenderingCommand_MenuCategories.View'
      },
      {
        signature: 'Render = UnsafeNativeMethods.RdkRenderingCommand_MenuCategories.Render'
      },
      {
        signature: 'Help = UnsafeNativeMethods.RdkRenderingCommand_MenuCategories.Help'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderingCommand.States',
    dataType: 3,
    values: [
      {
        signature: 'Off = UnsafeNativeMethods.RdkRenderingCommand_States.Off'
      },
      {
        signature: 'On = UnsafeNativeMethods.RdkRenderingCommand_States.On'
      },
      {
        signature: 'Unknown = UnsafeNativeMethods.RdkRenderingCommand_States.Unknown'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderingHistogram.HistogramFlags',
    dataType: 3,
    values: [
      {
        signature: 'UseAlpha = 0x01'
      },
      {
        signature: 'Photometric = 0x02'
      },
      {
        signature: 'Logarithmic = 0x04'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderingHistogram.HistogramType',
    dataType: 3,
    values: [
      {
        signature: 'Original = UnsafeNativeMethods.RdkRendering_Histogram.Original'
      },
      {
        signature: 'Early = UnsafeNativeMethods.RdkRendering_Histogram.Early'
      },
      {
        signature: 'ToneMapping = UnsafeNativeMethods.RdkRendering_Histogram.ToneMapping'
      },
      {
        signature: 'Late = UnsafeNativeMethods.RdkRendering_Histogram.Late'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderingPostEffectCommand.States',
    dataType: 3,
    values: [
      {
        signature: 'Off = UnsafeNativeMethods.RhRdkRenderingPostEffectCommand_States.Off'
      },
      {
        signature: 'On = UnsafeNativeMethods.RhRdkRenderingPostEffectCommand_States.On'
      },
      {
        signature: 'Unknown = UnsafeNativeMethods.RhRdkRenderingPostEffectCommand_States.Unknown'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderingPostEffects.Disposition',
    dataType: 3,
    values: [
      {
        signature: 'Early = UnsafeNativeMethods.RhRdkRenderingPostEffects_Disposition.Early'
      },
      {
        signature: 'ToneMapping = UnsafeNativeMethods.RhRdkRenderingPostEffects_Disposition.ToneMapping'
      },
      {
        signature: 'Late = UnsafeNativeMethods.RhRdkRenderingPostEffects_Disposition.Late'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderMaterial',
    dataType: 1,
    baseclass: 'Rhino.Render.RenderContent',
    properties: [
      {
        signature: 'static Guid GemMaterialGuid',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid GlassMaterialGuid',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid MetalMaterialGuid',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid PaintMaterialGuid',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid PictureMaterialGuid',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid PlasterMaterialGuid',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid PlasticMaterialGuid',
        since: 6,
        property: ['get']
      },
      {
        signature: 'PreviewBackgroundType DefaultPreviewBackgroundType',
        summary: `Set or get the default scene background for the image that appears in
     preview panes`,
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'PreviewGeometryType DefaultPreviewGeometryType',
        summary: 'Set or get the default geometry that appears in preview panes',
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'double DefaultPreviewSize',
        summary: 'The default preview geometry size',
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'bool SmellsLikeGem',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool SmellsLikeGlass',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool SmellsLikeMetal',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool SmellsLikePaint',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool SmellsLikePlaster',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool SmellsLikePlastic',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool SmellsLikeTexturedGem',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool SmellsLikeTexturedGlass',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool SmellsLikeTexturedMetal',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool SmellsLikeTexturedPaint',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool SmellsLikeTexturedPlaster',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool SmellsLikeTexturedPlastic',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static RenderMaterial CreateBasicMaterial(Material material)',
        summary: 'Constructs a new basic material from a Rhino.DocObjects.Material.',
        since: 5.1,
        parameters: [
          {
            name: 'material',
            summary: '(optional)The material to create the basic material from.'
          }
        ],
        returns: 'A new basic material.'
      },
      {
        signature: 'static RenderMaterial CreateBasicMaterial(Material material,RhinoDoc doc)',
        since: 6.4
      },
      {
        signature: 'static RenderMaterial CreateImportedMaterial(Material material,RhinoDoc doc,bool bReference)',
        since: 7
      },
      {
        signature: 'double GetTextureAmountFromUsage(StandardChildSlots which)',
        since: 6
      },
      {
        signature: 'RenderTexture GetTextureFromUsage(StandardChildSlots which)',
        since: 6
      },
      {
        signature: 'bool GetTextureOnFromUsage(StandardChildSlots which)',
        since: 6
      },
      {
        signature: 'bool HandleTexturedValue(string slotname,TexturedValue<T> tc)',
        summary: `Handle a textured content field. Values will be read into an
     instance of TexturedColor`,
        since: 6.12,
        returns: 'True if reading the base value succeeded'
      },
      {
        signature: 'DocObjects.Material SimulatedMaterial(bool isForDataOnly)',
        since: 7
      },
      {
        signature: 'DocObjects.Material SimulatedMaterial(TextureGeneration tg)',
        since: 7
      },
      {
        signature: 'Rhino.Render.PhysicallyBasedMaterial SimulatedPhysicallyBasedMaterial(TextureGeneration tg)',
        since: 7
      },
      {
        signature: 'DocObjects.Material SimulateMaterial(bool isForDataOnly)',
        summary: 'Call this function to receive the simulation for a RenderMaterial used by the display and other rendering engines.',
        since: 6,
        parameters: [
          {
            name: 'isForDataOnly',
            summary: 'Called when only asking for a hash - don\'t write any textures to the disk - just provide the filenames they will get.'
          }
        ],
        returns: 'The simulation of the render material'
      },
      {
        signature: 'void SimulateMaterial(Material simulation,bool isForDataOnly)',
        summary: `Override this function to provide a Rhino.DocObjects.Material definition for this material
     to be used by other rendering engines including the display.`,
        since: 5.1,
        parameters: [
          {
            name: 'simulation',
            summary: 'Set the properties of the input basic material to provide the simulation for this material.'
          },
          {
            name: 'isForDataOnly',
            summary: 'Called when only asking for a hash - don\'t write any textures to the disk - just provide the filenames they will get.'
          }
        ]
      },
      {
        signature: 'void SimulateMaterial(Material simulation,TextureGeneration tg)',
        summary: `Override this function to provide a Rhino.DocObjects.Material definition for this material
     to be used by other rendering engines including the display.`,
        since: 7,
        parameters: [
          {
            name: 'simulation',
            summary: 'Set the properties of the input basic material to provide the simulation for this material.'
          },
          {
            name: 'tg',
            summary: 'See RenderTexture.TextureGeneration.'
          }
        ]
      },
      {
        signature: 'string TextureChildSlotName(StandardChildSlots slot)',
        summary: `Override this function to provide information about which texture is used for
     the standard (ie - defined in ON_Texture) texture channels.`,
        since: 5.1,
        parameters: [
          {
            name: 'slot',
            summary: 'An valid slot.'
          }
        ],
        returns: 'The texture used for the channel.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderMaterial.BasicMaterialParameterNames',
    dataType: 1,
    summary: 'Parameter names for use in GetNamedParameter and SetNamedParameter with basic materials.'
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderMaterial.PhysicallyBased',
    dataType: 1,
    summary: 'Helper class with fields containing the names of fields available in our PBR implementation.'
  },
  {
    namespace: 'Rhino.Render',
    name: 'PhysicallyBased.ChildSlotNames',
    dataType: 1,
    properties: [
      {
        signature: 'static string AmbientOcclusion',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Anisotropic',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string AnisotropicRotation',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string BaseColor',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Bump',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Clearcoat',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string ClearcoatBump',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string ClearcoatRoughness',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Displacement',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Emission',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Metallic',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Opacity',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string OpacityIor',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string OpacityRoughness',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Roughness',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Sheen',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string SheenTint',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Specular',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string SpecularTint',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Subsurface',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string SubsurfaceScatteringColor',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string SubsurfaceScatteringRadius',
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static string FromTextureType(TextureType tt)',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'PhysicallyBased.ParametersNames',
    dataType: 1,
    properties: [
      {
        signature: 'static string AmbientOcclusion',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Anisotropic',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string AnisotropicRotation',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string BaseColor',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string BRDF',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Bump',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Clearcoat',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string ClearcoatBump',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string ClearcoatRoughness',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Displacement',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Emission',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Metallic',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Opacity',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string OpacityIor',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string OpacityRoughness',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Roughness',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Sheen',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string SheenTint',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Specular',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string SpecularTint',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string Subsurface',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string SubsurfaceScatteringColor',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string SubsurfaceScatteringRadius',
        since: 7,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderMaterial.PreviewBackgroundType',
    dataType: 3,
    summary: `The default scene background for the image that appears in
     preview panes`,
    values: [
      {
        signature: 'None = UnsafeNativeMethods.RhCmnMaterialPreviewBackground.None'
      },
      {
        signature: 'Checkered = UnsafeNativeMethods.RhCmnMaterialPreviewBackground.Checkered'
      },
      {
        signature: 'Scene = UnsafeNativeMethods.RhCmnMaterialPreviewBackground.Scene'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderMaterial.PreviewGeometryType',
    dataType: 3,
    summary: 'Geometry that appears in preview panes',
    values: [
      {
        signature: 'Cone = UnsafeNativeMethods.RhRdkPreviewSceneServerGeometry.Cone'
      },
      {
        signature: 'Cube = UnsafeNativeMethods.RhRdkPreviewSceneServerGeometry.Cuboid'
      },
      {
        signature: 'Plane = UnsafeNativeMethods.RhRdkPreviewSceneServerGeometry.Plane'
      },
      {
        signature: 'Pyramid = UnsafeNativeMethods.RhRdkPreviewSceneServerGeometry.Pyramid'
      },
      {
        signature: 'Sphere = UnsafeNativeMethods.RhRdkPreviewSceneServerGeometry.Sphere'
      },
      {
        signature: 'Torus = UnsafeNativeMethods.RhRdkPreviewSceneServerGeometry.Torus'
      },
      {
        signature: 'Scene = UnsafeNativeMethods.RhRdkPreviewSceneServerGeometry.Mesh'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderMaterial.StandardChildSlots',
    dataType: 3,
    summary: 'Defines enumerated constant values for use in TextureChildSlotName method.',
    values: [
      {
        signature: 'None = 0x0',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::None.'
      },
      {
        signature: 'Diffuse = 0x1',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::Diffuse.'
      },
      {
        signature: 'Transparency = 0x2',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::Transparency'
      },
      {
        signature: 'Bump = 0x4',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::Bump'
      },
      {
        signature: 'Environment = 0x8',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::Environment'
      },
      {
        signature: 'PbrBaseColor = 0x1',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_base_color'
      },
      {
        signature: 'PbrSubsurface = 0x20',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_subsurface'
      },
      {
        signature: 'PbrSubSurfaceScattering = 0x40',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_subsurface_scattering'
      },
      {
        signature: 'PbrSubsurfaceScatteringRadius = 0x80',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_subsurface_scattering_radius'
      },
      {
        signature: 'PbrMetallic = 0x100',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_metallic'
      },
      {
        signature: 'PbrSpecular = 0x200',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_specular'
      },
      {
        signature: 'PbrSpecularTint = 0x400',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_specular_tint'
      },
      {
        signature: 'PbrRoughness = 0x800',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_roughness'
      },
      {
        signature: 'PbrAnisotropic = 0x1000',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_anisotropic'
      },
      {
        signature: 'PbrAnisotropicRotation = 0x2000',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_anisotropic_rotation'
      },
      {
        signature: 'PbrSheen = 0x4000',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_sheen'
      },
      {
        signature: 'PbrSheenTint = 0x8000',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_sheen_tint'
      },
      {
        signature: 'PbrClearcoat = 0x10000',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_clearcoat'
      },
      {
        signature: 'PbrClearcoatRoughness = 0x20000',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_clearcoat_roughness'
      },
      {
        signature: 'PbrOpacityIor = 0x40000',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_opacity_ior'
      },
      {
        signature: 'PbrOpacity = 0x02',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_opacity'
      },
      {
        signature: 'PbrOpacityRoughness = 0x80000',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_opacity_roughness'
      },
      {
        signature: 'PbrEmission = 0x100000',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_emission'
      },
      {
        signature: 'PbrAmbientOcclusion = 0x200000',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_ambient_occlusion'
      },
      {
        signature: 'PbrDisplacement = 0x800000',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_smudge'
      },
      {
        signature: 'PbrClearcoatBump = 0x1000000',
        summary: 'Corresponds to CRhRdkMaterial::ChildSlotUsage::PBR_clearcoat_roughness'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderMaterialTable',
    dataType: 1,
    interfaces: ['IRenderContentTable<RenderMaterial>', 'IEnumerable<RenderMaterial>', 'Collections.IRhinoTable<RenderMaterial>'],
    properties: [
      {
        signature: 'int Count',
        since: 5.7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool Add(RenderMaterial c)',
        since: 6
      },
      {
        signature: 'void BeginChange(ChangeContexts changeContext)',
        since: 7
      },
      {
        signature: 'void EndChange()',
        since: 7
      },
      {
        signature: 'IEnumerator<RenderMaterial> GetEnumerator()',
        since: 5.7
      },
      {
        signature: 'bool Remove(RenderMaterial c)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderPanels',
    dataType: 1,
    summary: 'This class is used to extend the standard Render user interface',
    methods: [
      {
        signature: 'static object FromRenderSessionId(PlugIn plugIn,Type panelType,Guid renderSessionId)',
        summary: `Get the instance of a render panel associated with a specific render
     session, this is useful when it is necessary to update a control from a
     RenderPipeline`,
        since: 5.11,
        parameters: [
          {
            name: 'plugIn',
            summary: 'The plug-in that registered the custom user interface'
          },
          {
            name: 'panelType',
            summary: 'The type of panel to return'
          },
          {
            name: 'renderSessionId',
            summary: `The RenderPipeline.RenderSessionId of a specific render
     session.`
          }
        ],
        returns: 'Returns the custom panel object if found; otherwise None is returned.'
      },
      {
        signature: 'void RegisterPanel(PlugIn plugin,RenderPanelType renderPanelType,Type panelType,string caption,bool alwaysShow,bool initialShow)',
        summary: `Register custom render user interface with Rhino.  This should only be
     done in RenderPlugIn.RegisterRenderPanels.  Panels
     registered after RenderPlugIn.RegisterRenderPanels is called
     will be ignored.`,
        since: 5.11,
        parameters: [
          {
            name: 'plugin',
            summary: 'The plug-in providing the custom user interface'
          },
          {
            name: 'renderPanelType',
            summary: 'See RenderPanelType for supported user interface types.'
          },
          {
            name: 'panelType',
            summary: 'The type of object to be created and added to the render container.'
          },
          {
            name: 'caption',
            summary: 'The caption for the custom user interface.'
          },
          {
            name: 'alwaysShow',
            summary: `If True the custom user interface will always be visible, if False then
     it may be hidden or shown as requested by the user.`
          },
          {
            name: 'initialShow',
            summary: 'Initial visibility state of the custom user interface control.'
          }
        ]
      },
      {
        signature: 'void RegisterPanelEx(PlugIn plugin,RenderPanelType renderPanelType,Type panelType,Guid renderEngineId,string caption,bool alwaysShow,bool initialShow)',
        summary: `Register custom render user interface with Rhino.  This should only be
     done in RenderPlugIn.RegisterRenderPanels.  Panels
     registered after RenderPlugIn.RegisterRenderPanels is called
     will be ignored.`,
        since: 7,
        parameters: [
          {
            name: 'plugin',
            summary: 'The plug-in providing the custom user interface'
          },
          {
            name: 'renderPanelType',
            summary: 'See RenderPanelType for supported user interface types.'
          },
          {
            name: 'panelType',
            summary: 'The type of object to be created and added to the render container.'
          },
          {
            name: 'renderEngineId',
            summary: 'The render engine id allowing the UI to be shown'
          },
          {
            name: 'caption',
            summary: 'The caption for the custom user interface.'
          },
          {
            name: 'alwaysShow',
            summary: `If True the custom user interface will always be visible, if False then
     it may be hidden or shown as requested by the user.`
          },
          {
            name: 'initialShow',
            summary: 'Initial visibility state of the custom user interface control.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderPanelType',
    dataType: 3,
    summary: 'Contains the custom user interfaces that may be provided',
    values: [
      {
        signature: 'RenderWindow = UnsafeNativeMethods.RhRdkCustomUiType.RenderWindowCustomDlgInterface',
        summary: 'A custom control panel added to the render output window.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderPipeline',
    dataType: 1,
    summary: `Provides facilities to a render plug-in for integrating with the standard
   Rhino render window. Also adds helper functions for processing a render
   scene. This is the suggested class to use when integrating a renderer with
   Rhino and maintaining a "standard" user interface that users will expect.`,
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'int ConfirmationSeconds',
        summary: `Sets the number of seconds that need to elapse during rendering before
     the user is asked if the rendered image should be saved.`,
        since: 5,
        property: ['set']
      },
      {
        signature: 'PlugIn PlugIn',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid RenderSessionId',
        summary: `Get the Id associated with this render session, this is useful when
     looking up Rhino.Render.RenderPanels.`,
        since: 5.11,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Size RenderSize()',
        since: 5
      },
      {
        signature: 'static Size RenderSize(RhinoDoc doc)',
        summary: 'Get the render size as specified in the ON_3dmRenderSettings. Will automatically return the correct size based on the ActiveView or custom settings.',
        since: 6,
        returns: 'The render size.'
      },
      {
        signature: 'static Size RenderSize(RhinoDoc doc,bool fromRenderSources)',
        summary: `Get the render size as specified in the ON_3dmRenderSettings, and from RenderSources when
     fromRenderSources is true.`,
        since: 6,
        returns: 'The render size.'
      },
      {
        signature: 'bool CloseWindow()',
        summary: 'Closes the render window associated with this render instance.',
        since: 5.11,
        returns: 'Return True if successful or False if not.'
      },
      {
        signature: 'Rhino.Commands.Result CommandResult()',
        since: 5
      },
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'RenderWindow GetRenderWindow()',
        summary: 'Get the RenderWindow associated with this RenderPipeline instance.  This is virtual rather than abstract for V5 compat',
        since: 5,
        returns: `RenderWindow if one exists, None otherwise (i.e. rendering
     has already completed).`
      },
      {
        signature: 'RenderWindow GetRenderWindow(bool withWireframeChannel)',
        summary: `As GetRenderWindow(), but if withWireframeChannel is true
     the returned RenderWindow will have the channel added.`,
        since: 6,
        returns: `RenderWindow with wireframe channel enabled, or null
     if no RenderWindow can be found (i.e. rendering has completed
     already)`
      },
      {
        signature: 'RenderWindow GetRenderWindow(bool withWireframeChannel,bool fromRenderViewSource)',
        summary: `As GetRenderWindow().
     The parameter withWireframeChannel controls whether
     the returned RenderWindow will have the channel added.
     The parameter fromRenderViewSource controls from where
     the RenderSize is queried.`,
        since: 6,
        parameters: [
          {
            name: 'withWireframeChannel',
            summary: 'True if the RenderWindow needs to have a wireframe channel.'
          },
          {
            name: 'fromRenderViewSource',
            summary: `True if the RenderWindow size needs to be set from RenderViewSource size. False will
     use the active view.`
          }
        ],
        returns: `RenderWindow if one exists, None otherwise (i.e. rendering
     has already completed).`
      },
      {
        signature: 'RenderWindow GetRenderWindowFromRenderViewSource(bool fromRenderViewSource)',
        summary: `Like GetRenderWindow(), but with the size for RenderWindow
     set from RenderViewSources if fromRenderViewSource is set to true`,
        since: 6,
        parameters: [
          {
            name: 'fromRenderViewSource',
            summary: 'True if'
          }
        ],
        returns: `RenderWindow if one exists, None otherwise (i.e. rendering
     has already completed).`
      },
      {
        signature: 'void PauseRendering()',
        summary: 'Implement to pause the current render session',
        since: 6
      },
      {
        signature: 'RenderReturnCode Render()',
        summary: 'Call this function to render the scene normally. The function returns when rendering is complete (or cancelled).',
        since: 5,
        returns: 'A code that explains how rendering completed.'
      },
      {
        signature: 'RenderReturnCode RenderWindow(RhinoView view,Rectangle rect,bool inWindow)',
        summary: 'Call this function to render the scene in a view window. The function returns when rendering is complete (or cancelled).',
        since: 5,
        parameters: [
          {
            name: 'view',
            summary: 'the view that the user selected a rectangle in.'
          },
          {
            name: 'rect',
            summary: 'rectangle that the user selected.'
          },
          {
            name: 'inWindow',
            summary: 'True to render directly into the view window.'
          }
        ],
        returns: 'A code that explains how rendering completed.'
      },
      {
        signature: 'void ResumeRendering()',
        summary: 'Implement to resume current render session',
        since: 6
      },
      {
        signature: 'bool SaveImage(string fileName,bool saveAlpha)',
        summary: 'Saves the rendered image to a file. Does not prompt the user in any way.',
        since: 5.14,
        parameters: [
          {
            name: 'fileName',
            summary: 'Full path to the file name to save to.'
          },
          {
            name: 'saveAlpha',
            summary: 'Determines if alpha will be saved in files that support it (e.g., PNG).'
          }
        ]
      },
      {
        signature: 'void SetAsyncRenderContext(AsyncRenderContext aRC)',
        since: 6
      },
      {
        signature: 'bool SupportsPause()',
        summary: 'Override and return True if the renderer supports pausing',
        since: 6,
        returns: 'True if pausing is supported, False otherwise'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderPipeline.RenderReturnCode',
    dataType: 3,
    values: [
      {
        signature: 'Ok = 0'
      },
      {
        signature: 'EmptyScene'
      },
      {
        signature: 'Cancel'
      },
      {
        signature: 'NoActiveView'
      },
      {
        signature: 'OnPreCreateWindow'
      },
      {
        signature: 'NoFrameWndPointer'
      },
      {
        signature: 'ErrorCreatingWindow'
      },
      {
        signature: 'ErrorStartingRender'
      },
      {
        signature: 'EnterModalLoop'
      },
      {
        signature: 'ExitModalLoop'
      },
      {
        signature: 'ExitRhino'
      },
      {
        signature: 'InternalError'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderPlugInInfo',
    dataType: 1,
    properties: [
      {
        signature: 'string Name',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Guid PlugInId',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderPlugInList',
    dataType: 1,
    baseclass: 'List<RenderPlugInInfo>',
    constructors: [
      {
        signature: 'RenderPlugInList()',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderPrimitive',
    dataType: 1,
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'BoundingBox BoundingBox',
        summary: 'The bounding box for this primitive.',
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'Transform InstanceTransform',
        summary: 'Instance reference transform or Identity if not an instance reference.',
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'RenderPrimitiveType PrimitiveType',
        summary: `Call this before extracting meshes if you support render primitives to
     get the RenderPrimitiveType of this mesh then call the
     associated TryGetSphere, TryGetPlane, TryGetCone, or
     TryGetBox method.  Calling the Mesh property
     will mesh the primitive and return a mesh always.`,
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'RenderMaterial RenderMaterial',
        summary: 'The RenderMaterial associated with this mesh or None if there is not one.',
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'RhinoObject RhinoObject',
        summary: 'The Rhino object associated with this render primitive.',
        since: 5.7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5.7
      },
      {
        signature: 'Mesh Mesh()',
        summary: `Returns the mesh associated with the object, this will mesh primitives
     and always return a mesh.`,
        since: 5.7
      },
      {
        signature: 'bool TryGetBox(Box box)',
        summary: `Call this method to get a Box primitive for this mesh.  If this
     meshes PrimitiveType is not a Rhino.Render.RenderPrimitiveType.Box
     then the box parameter is set to Box.Empty.`,
        since: 5.7,
        parameters: [
          {
            name: 'box',
            summary: 'Gets set to the box primitive for this object on success or Box.Empty on error.'
          }
        ],
        returns: `Returns True if PrimitiveType is Rhino.Render.RenderPrimitiveType.Box and
     the box parameter was initialized otherwise returns false.`
      },
      {
        signature: 'bool TryGetCone(Cone cone,Plane truncation)',
        summary: `Call this method to get a Cone primitive for this mesh.  If this
     meshes PrimitiveType is not a Rhino.Render.RenderPrimitiveType.Cone
     then the cone parameter is set to Cone.Unset and the truncation
     parameter is set to Plane.Unset.`,
        since: 5.7,
        parameters: [
          {
            name: 'cone',
            summary: 'Gets set to the cone primitive for this object on success or Cone.Unset on error.'
          },
          {
            name: 'truncation',
            summary: 'Gets set to the truncation plane for this object on success or Plane.Unset on error.'
          }
        ],
        returns: `Returns True if PrimitiveType is Rhino.Render.RenderPrimitiveType.Cone and
     the cone and truncation parameters were initialized otherwise returns false.`
      },
      {
        signature: 'bool TryGetPlane(PlaneSurface plane)',
        summary: `Call this method to get a Plane primitive for this mesh.  If this
     meshes PrimitiveType is not a Rhino.Render.RenderPrimitiveType.Plane
     then the plane parameter is set to null.`,
        since: 5.7,
        parameters: [
          {
            name: 'plane',
            summary: 'Gets set to the plane primitive for this object on success or None on error.'
          }
        ],
        returns: `Returns True if PrimitiveType is Rhino.Render.RenderPrimitiveType.Plane and
     the plane parameter was initialized otherwise returns false.`
      },
      {
        signature: 'bool TryGetSphere(Sphere sphere)',
        summary: `Call this method to get a sphere primitive for this mesh.  If this
     meshes PrimitiveType is not a Rhino.Render.RenderPrimitiveType.Sphere
     then the sphere parameter is set to Sphere.Unset.`,
        since: 5.7,
        parameters: [
          {
            name: 'sphere',
            summary: 'Gets set to the primitive sphere for this object on success.'
          }
        ],
        returns: `Returns True if PrimitiveType is Rhino.Render.RenderPrimitiveType.Sphere and
     the sphere parameter was initialized otherwise returns false.`
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderPrimitiveList',
    dataType: 1,
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'int Count',
        summary: 'Number of meshes in this list',
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'RhinoObject RhinoObject',
        summary: 'The Rhino object associated with this list',
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'bool UseObjectsMappingChannels',
        summary: `Returns True if the texture mapping will be taken from the Rhino
     object otherwise; the texture mapping will use the texture coordinates
     on the mesh only.`,
        since: 5.7,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Add(Box box,RenderMaterial material)',
        summary: 'Add primitive box and material.',
        since: 5.7,
        parameters: [
          {
            name: 'box',
            summary: 'Box to add.'
          },
          {
            name: 'material',
            summary: 'Material to add, may be None if not needed.'
          }
        ]
      },
      {
        signature: 'void Add(Cone cone,Plane truncation,RenderMaterial material)',
        summary: 'Add primitive cone and material.',
        since: 5.7,
        parameters: [
          {
            name: 'cone',
            summary: 'Cone to add.'
          },
          {
            name: 'truncation',
            summary: `The plane used to cut the cone (the non-apex end is kept). Should be
     equal to cone.plane if not truncated.`
          },
          {
            name: 'material',
            summary: 'Material to add, may be None if not needed.'
          }
        ]
      },
      {
        signature: 'void Add(Mesh mesh,RenderMaterial material)',
        summary: 'Add mesh and material.',
        since: 5.7,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh to add.'
          },
          {
            name: 'material',
            summary: 'Material to add, may be None if not needed.'
          }
        ]
      },
      {
        signature: 'void Add(Mesh mesh,RenderMaterial material,Transform t)',
        summary: 'Add mesh and material.',
        since: 6.12,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh to add.'
          },
          {
            name: 'material',
            summary: `Transformation of this mesh.
     Material to add, may be None if not needed.`
          },
          {
            name: 't',
            summary: 'Transformation of this mesh.'
          }
        ]
      },
      {
        signature: 'void Add(PlaneSurface plane,RenderMaterial material)',
        summary: 'Add primitive plane and material.',
        since: 5.7,
        parameters: [
          {
            name: 'plane',
            summary: 'Plane to add.'
          },
          {
            name: 'material',
            summary: 'Material to add, may be None if not needed.'
          }
        ]
      },
      {
        signature: 'void Add(Sphere sphere,RenderMaterial material)',
        summary: 'Add primitive sphere and material.',
        since: 5.7,
        parameters: [
          {
            name: 'sphere',
            summary: 'Sphere to add.'
          },
          {
            name: 'material',
            summary: 'Material to add, may be None if not needed.'
          }
        ]
      },
      {
        signature: 'bool AutoDeleteMaterialsOn()',
        since: 6
      },
      {
        signature: 'bool AutoDeleteMeshesOn()',
        since: 6
      },
      {
        signature: 'void Clear()',
        summary: 'Remove all primitives from this list',
        since: 5.7
      },
      {
        signature: 'void ConvertMeshesToTriangles()',
        summary: 'Convert mesh quad faces to triangle faces.',
        since: 5.7
      },
      {
        signature: 'void Dispose()',
        since: 5.7
      },
      {
        signature: 'Transform GetInstanceTransform(int index)',
        since: 6
      },
      {
        signature: 'RenderMaterial Material(int index)',
        summary: `Call this method to get the render material associated with the mesh at
     the specified index.  Will return None if there is no
     material associated with the requested mesh.`,
        since: 5.7,
        parameters: [
          {
            name: 'index',
            summary: `The zero based index of the item in the list.  Valid values are greater
     than or equal to 0 and less than Count.`
          }
        ],
        returns: `If there is a render material associated at the requested index then
     the material is returned otherwise None is returned.`
      },
      {
        signature: 'Mesh Mesh(int index)',
        summary: `Get the mesh for the primitive at the specified index. If the item at
     this index is a primitive type other than a mesh then it mesh
     representation is returned.`,
        since: 5.7,
        parameters: [
          {
            name: 'index',
            summary: `The zero based index of the item in the list.  Valid values are greater
     than or equal to 0 and less than Count.`
          }
        ],
        returns: `Returns the mesh for the primitive at the specified index. If the item
     at this index is a primitive type other than a mesh then it mesh
     representation is returned.`
      },
      {
        signature: 'Mesh MeshInstance(int index,Transform instance_transform)',
        summary: `Get the mesh for the primitive at the specified index. If the item at
     this index is a primitive type other than a mesh then it mesh
     representation is returned.`,
        since: 6.12,
        parameters: [
          {
            name: 'index',
            summary: `The zero based index of the item in the list.  Valid values are greater
     than or equal to 0 and less than Count.`
          },
          {
            name: 'instance_transform',
            summary: 'Receives the transformation of this mesh.'
          }
        ],
        returns: `Returns the mesh for the primitive at the specified index. If the item
     at this index is a primitive type other than a mesh then it mesh
     representation is returned.`
      },
      {
        signature: 'RenderPrimitiveType PrimitiveType(int index)',
        summary: 'Type of primitive object at this index.',
        since: 5.7,
        parameters: [
          {
            name: 'index',
            summary: `The zero based index of the item in the list.  Valid values are greater
     than or equal to 0 and less than Count.`
          }
        ],
        returns: 'Primitive type of the item at this index.'
      },
      {
        signature: 'void SetInstanceTransform(int index,Transform xform)',
        since: 6
      },
      {
        signature: 'RenderMaterial[] ToMaterialArray()',
        summary: `Call this method to see if there are any RenderMaterials associated
     with the meshes.  Each primitive can optionally have a RenderMaterial
     associated with it, if the RenderMaterial is None then check for a
     RhinoObject.RenderMaterial.`,
        since: 5.7,
        returns: `Return an array that of the same size as the ToMeshArray() containing
     the RenderMaterial associated with the mesh, may contain None entries
     if there is no RenderMaterial associated with the custom mesh.`
      },
      {
        signature: 'Mesh[] ToMeshArray()',
        summary: `Call this method to get a array of meshes, all primitives will get
     meshed and the meshes will get included in the returned array.`,
        since: 5.7,
        returns: `Return an array of meshes from this list, this will convert all
     primitives to meshes.`
      },
      {
        signature: 'bool TryGetBox(int index,Box box)',
        summary: 'Call this method to get a box at the specified index.',
        since: 5.7,
        parameters: [
          {
            name: 'index',
            summary: `The zero based index of the item in the list.  Valid values are greater
     than or equal to 0 and less than Count.`
          },
          {
            name: 'box',
            summary: `Will contain the box at the requested index if the index is in range
     and the primitive at the requested index is a box.`
          }
        ],
        returns: `Return True if the index is in range and the primitive at the requested
     index is a box otherwise returns false.`
      },
      {
        signature: 'bool TryGetCone(int index,Cone cone,Plane truncation)',
        summary: 'Call this method to get a box at the specified index.',
        since: 5.7,
        parameters: [
          {
            name: 'index',
            summary: `The zero based index of the item in the list.  Valid values are greater
     than or equal to 0 and less than Count.`
          },
          {
            name: 'cone',
            summary: `Will contain the cone at the requested index if the index is in range
     and the primitive at the requested index is a box.`
          },
          {
            name: 'truncation',
            summary: ''
          }
        ],
        returns: `Return True if the index is in range and the primitive at the requested
     index is a box otherwise returns false.`
      },
      {
        signature: 'bool TryGetPlane(int index,PlaneSurface plane)',
        summary: 'Call this method to get a box at the specified index.',
        since: 5.7,
        parameters: [
          {
            name: 'index',
            summary: `The zero based index of the item in the list.  Valid values are greater
     than or equal to 0 and less than Count.`
          },
          {
            name: 'plane',
            summary: `Will contain the plane at the requested index if the index is in range
     and the primitive at the requested index is a plane.`
          }
        ],
        returns: `Return True if the index is in range and the primitive at the requested
     index is a plane otherwise returns false.`
      },
      {
        signature: 'bool TryGetSphere(int index,Sphere sphere)',
        summary: 'Call this method to get a box at the specified index.',
        since: 5.7,
        parameters: [
          {
            name: 'index',
            summary: `The zero based index of the item in the list.  Valid values are greater
     than or equal to 0 and less than Count.`
          },
          {
            name: 'sphere',
            summary: `Will contain the sphere at the requested index if the index is in range
     and the primitive at the requested index is a box.`
          }
        ],
        returns: `Return True if the index is in range and the primitive at the requested
     index is a box otherwise returns false.`
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderPrimitiveType',
    dataType: 3,
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'Mesh = 1'
      },
      {
        signature: 'Sphere = 2'
      },
      {
        signature: 'Plane = 3'
      },
      {
        signature: 'Box = 4'
      },
      {
        signature: 'Cone = 5'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderPropertyChangedEvent',
    dataType: 1,
    summary: 'Used by Rhino.Render object property value has changed events.',
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'int Context',
        summary: 'Optional argument which may specify the property being modified.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'The document triggering the event.',
        since: 5.1,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderSettings',
    dataType: 1,
    summary: 'Contains settings used in rendering.',
    baseclass: 'Rhino.Runtime.CommonObject',
    constructors: [
      {
        signature: 'RenderSettings()',
        summary: 'Initialize a new instance of the RenderSettings class.',
        since: 5
      },
      {
        signature: 'RenderSettings(RenderSettings source)',
        summary: 'Initialize new instance of the RenderSettings class.',
        since: 6,
        parameters: [
          {
            name: 'source',
            summary: 'If not null, settings are copied from source'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'Color AmbientLight',
        summary: 'Gets or sets the ambient light color used in rendering.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'AntialiasLevel AntialiasLevel',
        summary: 'Gets or sets antialias level, used for render quality',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color BackgroundColorBottom',
        summary: 'Gets or sets the background bottom color used in rendering.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color BackgroundColorTop',
        summary: `Gets or sets the background top color used in rendering.
     Sets also the background color if a solid background color is set.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'BackgroundStyle BackgroundStyle',
        summary: 'How the viewport\'s backgroun should be filled.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool DepthCue',
        summary: `Gets or sets a value indicating whether to render using depth cues.
     These are clues to help the perception of position and orientation of objects in the image.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Dithering Dithering',
        summary: 'Get the document dithering interface',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool FlatShade',
        summary: 'Gets or sets a value indicating whether to render using flat shading.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double ImageDpi',
        summary: `Number of dots/inch (dots=pixels) to use when printing and saving
     bitmaps. The default is 72.0 dots/inch.`,
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'Size ImageSize',
        summary: `Gets or sets a value indicating the size of the rendering result if
     UseViewportSize is set to false.  If UseViewportSize is set to true,
     then this value is ignored.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'UnitSystem ImageUnitSystem',
        summary: `unit system to use when converting image pixel size and dpi information
     into a print size.  Default = inches`,
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'LinearWorkflow LinearWorkflow',
        summary: 'Get the document linear workflow interface',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string NamedView',
        summary: 'Get or set the given named view',
        since: 6.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool RenderAnnotations',
        summary: `Gets or sets a value indicating whether to instruct the rendering engine to show annotations,
     such as linear dimensions or angular dimensions.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool RenderBackfaces',
        summary: 'Gets or sets a value indicating whether to render back faces.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool RenderCurves',
        summary: 'Gets or sets a value indicating whether to instruct the rendering engine to show curves.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool RenderIsoparams',
        summary: 'Gets or sets a value indicating whether to instruct the rendering engine to show isocurves.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool RenderMeshEdges',
        summary: 'Gets or sets a value indicating whether to instruct the rendering engine to show mesh edges.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool RenderPoints',
        summary: 'Gets or sets a value indicating whether to instruct the rendering engine to show points.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'RenderingSources RenderSource',
        summary: 'Gets or sets the render source RenderingSources enumeration.',
        since: 6.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool ScaleBackgroundToFit',
        summary: `Gets or sets a value indicating whether to scale the wallpaper in the
     background or not. This is meaningful only if the viewport has a wallpaper
     and render settings are set to render Wallpaper into the background.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'int ShadowmapLevel',
        summary: '0=none, 1=normal, 2=best.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Snapshot',
        summary: 'Set os get the given snapshot view',
        since: 6.1,
        property: ['get', 'set']
      },
      {
        signature: 'string SpecificViewport',
        summary: 'Set or get the given specific viewport',
        since: 6.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool TransparentBackground',
        summary: 'Gets or sets whether rendering should be done with transparent background.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool UseHiddenLights',
        summary: 'Gets or sets a value indicating whether to render using lights that are on layers that are off.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool UseViewportSize',
        summary: `Gets or sets a value indicating whether to use the resolution of the
     viewport being rendered or ImageSize when rendering`,
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderSettings.RenderingSources',
    dataType: 3,
    summary: 'Rendering source (render directly from a NamedView or Snapshot)',
    values: [
      {
        signature: 'ActiveViewport',
        summary: 'Get the rendering view from the currently active viewport (as in all previous versions of Rhino)'
      },
      {
        signature: 'SpecificViewport',
        summary: 'Get the rendering view from the named viewport (see NamedViewport below)'
      },
      {
        signature: 'NamedView',
        summary: 'Get the rendering view from a specific named view (see NamedView below)'
      },
      {
        signature: 'SnapShot',
        summary: 'Before rendering, restore the Snapshot specified in Snapshot below, then render.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderSourceView',
    dataType: 1,
    summary: `Helper class to get the correct view from the Render View Source settings.
   
   An instance of this class is supposed to be used with the using() {} construct.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'RenderSourceView(RhinoDoc doc)',
        summary: `Create a new RenderSourceView for the given doc.
     
     Note that this should be done with using(var rsv = new RenderSourceView(doc)) {}
     
     If the RenderSettings have the source view set to for instance a SnapShot this
     construct will ensure that the (active) view is set to the correct snapshot, and
     reverted back to the original once this instance goes out of scope.`,
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'Rhino document'
          }
        ]
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'Rhino.DocObjects.ViewInfo GetViewInfo()',
        summary: 'Get the ViewInfo as specified by the render source view settings.',
        since: 6,
        returns: 'ViewInfo if view was found, None otherwise'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderTabs',
    dataType: 1,
    methods: [
      {
        signature: 'static object FromRenderSessionId(PlugIn plugIn,Type tabType,Guid renderSessionId)',
        summary: `Get the instance of a render tab associated with a specific render
     session, this is useful when it is necessary to update a control from a
     RenderPipeline`,
        since: 5.11,
        parameters: [
          {
            name: 'plugIn',
            summary: 'The plug-in that registered the custom user interface'
          },
          {
            name: 'tabType',
            summary: 'The type of tab to return'
          },
          {
            name: 'renderSessionId',
            summary: `The RenderPipeline.RenderSessionId of a specific render
     session.`
          }
        ],
        returns: 'Returns the custom tab object if found; otherwise None is returned.'
      },
      {
        signature: 'static Guid SessionIdFromTab(object tab)',
        summary: 'Get the session Id that created the specified tab object.',
        since: 5.11
      },
      {
        signature: 'void RegisterTab(PlugIn plugin,Type tabType,string caption,Icon icon)',
        summary: `Register custom render user interface with Rhino.  This should only be
     done in RenderPlugIn.RegisterRenderTabs.  Panels
     registered after RenderPlugIn.RegisterRenderTabs is called
     will be ignored.  If the class includes a public method "void DoHelp()"
     the method will get called when F1 is pressed and the custom tab is active.`,
        since: 5.11,
        parameters: [
          {
            name: 'plugin',
            summary: 'The plug-in providing the custom user interface'
          },
          {
            name: 'tabType',
            summary: 'The type of object to be created and added to the render container.'
          },
          {
            name: 'caption',
            summary: 'The caption for the custom user interface.'
          },
          {
            name: 'icon',
            summary: ''
          }
        ]
      },
      {
        signature: 'void RegisterTabEx(PlugIn plugin,Type tabType,Guid renderEngineId,string caption,Icon icon)',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderTexture',
    dataType: 1,
    baseclass: 'Rhino.Render.RenderContent',
    properties: [
      {
        signature: 'Transform LocalMappingTransform',
        summary: `Gets the transformation that can be applied to the UVW vector to convert it
     from normalized texture space into locally mapped space (ie - with repeat,
     offset and rotation applied.)`,
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'uint RenderHashWithoutLocalMapping',
        summary: 'Render hash for texture excluding local mapping.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static bool GetEnvironmentMappingProjection(TextureEnvironmentMappingMode mode,Vector3d reflectionVector,float u,float v)',
        since: 5.7
      },
      {
        signature: 'static Point3d GetWcsBoxMapping(Point3d worldXyz,Vector3d normal)',
        since: 5.7
      },
      {
        signature: 'static RenderTexture NewBitmapTexture(Bitmap bitmap,RhinoDoc doc)',
        summary: 'Constructs a new basic texture from a Bitmap.',
        since: 7,
        parameters: [
          {
            name: 'bitmap',
            summary: 'The bitmap to create the basic texture from.'
          },
          {
            name: 'doc',
            summary: 'The document to associate the texture with.'
          }
        ],
        returns: 'A new render texture.'
      },
      {
        signature: 'static RenderTexture NewBitmapTexture(SimulatedTexture texture)',
        summary: 'Constructs a new basic texture from a SimulatedTexture.',
        since: 5.3,
        parameters: [
          {
            name: 'texture',
            summary: 'The texture to create the basic texture from.'
          }
        ],
        returns: 'A new render texture.'
      },
      {
        signature: 'static RenderTexture NewBitmapTexture(SimulatedTexture texture,RhinoDoc doc)',
        summary: 'Constructs a new basic texture from a SimulatedTexture.',
        since: 6.4,
        parameters: [
          {
            name: 'texture',
            summary: 'The texture to create the basic texture from.'
          },
          {
            name: 'doc',
            summary: 'The document to associate the texture with.'
          }
        ],
        returns: 'A new render texture.'
      },
      {
        signature: 'TextureEvaluator CreateEvaluator()',
        summary: `Constructs a texture evaluator. This is an independent lightweight object
     capable of evaluating texture color throughout uvw space. May be called
     from within a rendering shade pipeline.`,
        since: 5.1,
        returns: 'A texture evaluator instance.'
      },
      {
        signature: 'TextureEvaluator CreateEvaluator(TextureEvaluatorFlags evaluatorFlags)',
        summary: `Constructs a texture evaluator. This is an independent lightweight object
     capable of evaluating texture color throughout uvw space. May be called
     from within a rendering shade pipeline.`,
        since: 6,
        returns: 'A texture evaluator instance.'
      },
      {
        signature: 'bool GetDisplayInViewport()',
        since: 5.7
      },
      {
        signature: 'TextureEnvironmentMappingMode GetEnvironmentMappingMode()',
        since: 5.7
      },
      {
        signature: 'TextureEnvironmentMappingMode GetInternalEnvironmentMappingMode()',
        since: 5.7
      },
      {
        signature: 'eLocalMappingType GetLocalMappingType()',
        since: 6.3
      },
      {
        signature: 'int GetMappingChannel()',
        since: 5.7
      },
      {
        signature: 'Vector3d GetOffset()',
        summary: `Get offset value across UVW space. If the projection type is WCS or
     other type specified in model units, then this is the offset in meters.`,
        since: 5.7
      },
      {
        signature: 'bool GetOffsetLocked()',
        since: 5.7
      },
      {
        signature: 'bool GetPreviewIn3D()',
        since: 5.7
      },
      {
        signature: 'bool GetPreviewLocalMapping()',
        since: 5.7
      },
      {
        signature: 'TextureProjectionMode GetProjectionMode()',
        since: 5.7
      },
      {
        signature: 'Vector3d GetRepeat()',
        summary: `Get repeat value across UVW space. If the projection type is WCS or
     other type specified in model units, then this is the repeat across 1
     meter of the model.`,
        since: 5.7
      },
      {
        signature: 'bool GetRepeatLocked()',
        since: 5.7
      },
      {
        signature: 'Vector3d GetRotation()',
        since: 5.7
      },
      {
        signature: 'TextureWrapType GetWrapType()',
        since: 5.7
      },
      {
        signature: 'void GraphInfo(TextureGraphInfo tgi)',
        since: 6.3
      },
      {
        signature: 'bool IsHdrCapable()',
        summary: `Return True if the texture is HDR capable.
     
     When creating a custom RenderTexture implementation that is HDR capable
     set the appropriate property on the CustomRenderContentAttribute decorator on that clas.`,
        since: 5.7
      },
      {
        signature: 'bool IsImageBased()',
        summary: `Query if the texture is image based.
    
     When creating a custom RenderTexture implementation of an image-based texture
     set the appropriate property on the CustomRenderContentAttribute decorator on that class.
     
     Do not override this function`,
        since: 6,
        returns: 'True if the texture is image-based.'
      },
      {
        signature: 'bool IsLinear()',
        summary: `Return True if the texture color data is linear.
      
      NOTE: this function is marked as virtual, but the correct way to make a custom RenderTexture linear is by
      setting the correct property for the CustomRenderContentAttribute decorator on the class.`,
        since: 6
      },
      {
        signature: 'bool IsNormalMap()',
        summary: `Return True if the texture is a normalmap.
     
     When creating a custom RenderTexture implementation of a normal map
     set the appropriate property on the CustomRenderContentAttribute decorator on that clas.`,
        since: 6.16
      },
      {
        signature: 'void PixelSize(int u,int v,int w)',
        summary: 'Get the texture dimensions for the RenderTexture.',
        since: 6,
        parameters: [
          {
            name: 'u',
            summary: 'width'
          },
          {
            name: 'v',
            summary: 'height'
          },
          {
            name: 'w',
            summary: 'depth, used for 3D textures'
          }
        ]
      },
      {
        signature: 'bool SaveAsImage(string FullPath,int width,int height,int depth)',
        summary: 'Save texture as image',
        since: 6.15,
        parameters: [
          {
            name: 'FullPath',
            summary: 'The full path of the file'
          },
          {
            name: 'width',
            summary: 'Image width'
          },
          {
            name: 'height',
            summary: 'Image height'
          },
          {
            name: 'depth',
            summary: 'Image depth'
          }
        ],
        returns: 'returns True if file was saved, otherwise false'
      },
      {
        signature: 'void SetDisplayInViewport(bool value)',
        since: 6
      },
      {
        signature: 'void SetDisplayInViewport(bool value,ChangeContexts changeContext)',
        since: 5.7
      },
      {
        signature: 'void SetEnvironmentMappingMode(TextureEnvironmentMappingMode value)',
        since: 6
      },
      {
        signature: 'void SetEnvironmentMappingMode(TextureEnvironmentMappingMode value,ChangeContexts changeContext)',
        since: 5.7
      },
      {
        signature: 'void SetGraphInfo(TextureGraphInfo tgi)',
        since: 6.3
      },
      {
        signature: 'void SetMappingChannel(int value,ChangeContexts changeContext)',
        since: 5.7
      },
      {
        signature: 'void SetOffset(Vector3d value,ChangeContexts changeContext)',
        summary: `Set offset value across UVW space. If the projection type is WCS or
     other type specified in model units, then this is the offset in meters.`,
        since: 5.7
      },
      {
        signature: 'void SetOffsetLocked(bool value,ChangeContexts changeContext)',
        since: 5.7
      },
      {
        signature: 'void SetPreviewIn3D(bool value,ChangeContexts changeContext)',
        since: 5.7
      },
      {
        signature: 'void SetPreviewLocalMapping(bool value)',
        since: 6
      },
      {
        signature: 'void SetPreviewLocalMapping(bool value,ChangeContexts changeContext)',
        since: 5.7
      },
      {
        signature: 'void SetProjectionMode(TextureProjectionMode value,ChangeContexts changeContext)',
        since: 5.7
      },
      {
        signature: 'void SetRepeat(Vector3d value,ChangeContexts changeContext)',
        summary: `Set repeat value across UVW space. If the projection type is WCS or
     other type specified in model units, then this is the repeat across 1
     meter of the model.`,
        since: 5.7
      },
      {
        signature: 'void SetRepeatLocked(bool value,ChangeContexts changeContext)',
        since: 5.7
      },
      {
        signature: 'void SetRotation(Vector3d value,ChangeContexts changeContext)',
        since: 5.7
      },
      {
        signature: 'void SetWrapType(TextureWrapType value,ChangeContexts changeContext)',
        since: 5.7
      },
      {
        signature: 'SimulatedTexture SimulatedTexture(TextureGeneration tg,int size,RhinoObject obj)',
        since: 6
      },
      {
        signature: 'void SimulateTexture(SimulatedTexture simulation,bool isForDataOnly)',
        since: 5.1
      },
      {
        signature: 'void SimulateTexture(SimulatedTexture simulation,TextureGeneration tg,int size,RhinoObject obj)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderTexture.eLocalMappingType',
    dataType: 3,
    values: [
      {
        signature: 'lmt_none'
      },
      {
        signature: 'lmt_2D'
      },
      {
        signature: 'lmt_3D'
      },
      {
        signature: 'lmt_force32bit = 0xFFFFFFFF'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderTexture.TextureEvaluatorFlags',
    dataType: 3,
    values: [
      {
        signature: 'Normal                  = 0x0000'
      },
      {
        signature: 'DisableFiltering        = 0x0001'
      },
      {
        signature: 'DisableLocalMapping     = 0x0002'
      },
      {
        signature: 'DisableAdjustment       = 0x0004'
      },
      {
        signature: 'DisableProjectionChange = 0x0008'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderTexture.TextureGeneration',
    dataType: 3,
    values: [
      {
        signature: 'Allow = UnsafeNativeMethods.CRhRdkTextureGenConsts.Allow'
      },
      {
        signature: 'Disallow = UnsafeNativeMethods.CRhRdkTextureGenConsts.Disallow'
      },
      {
        signature: 'Skip = UnsafeNativeMethods.CRhRdkTextureGenConsts.Skip'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderTextureTable',
    dataType: 1,
    interfaces: ['IRenderContentTable<RenderTexture>', 'IEnumerable<RenderTexture>', 'Collections.IRhinoTable<RenderTexture>'],
    properties: [
      {
        signature: 'int Count',
        since: 5.7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool Add(RenderTexture c)',
        since: 6
      },
      {
        signature: 'void BeginChange(ChangeContexts changeContext)',
        since: 7
      },
      {
        signature: 'void EndChange()',
        since: 7
      },
      {
        signature: 'IEnumerator<RenderTexture> GetEnumerator()',
        since: 5.7
      },
      {
        signature: 'bool Remove(RenderTexture c)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderWindow',
    dataType: 1,
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'Guid SessionId',
        since: 5.11,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static Guid ChannelId(StandardChannels ch)',
        since: 5
      },
      {
        signature: 'static RenderWindow Create(Size szSize)',
        since: 6
      },
      {
        signature: 'static RenderWindow FromSessionId(Guid sessionId)',
        since: 5.11
      },
      {
        signature: 'bool AddChannel(StandardChannels channel)',
        summary: 'Add a channel to the frame buffer in addition to the fixed Red, Green, Blue and Alpha channels.',
        since: 5,
        parameters: [
          {
            name: 'channel',
            summary: 'Channel to add'
          }
        ],
        returns: 'If the channel existed then True is returned otherwise; returns True if the channel was added or False if not.'
      },
      {
        signature: 'bool AddWireframeChannel(RhinoDoc doc,ViewportInfo viewport,Size size,Rectangle region)',
        summary: `A wireframe channel will not be added if none of the document properties settings
     indicate that one is needed. In other words, Rhino will not generate an empty wireframe channel
     just for the fun of it.`,
        since: 5,
        parameters: [
          {
            name: 'doc',
            summary: 'The document to display'
          },
          {
            name: 'viewport',
            summary: 'The view to display'
          },
          {
            name: 'size',
            summary: `The size of the image without clipping (ie - if you have a region, it was the
     size of the image before you cut the region out.`
          },
          {
            name: 'region',
            summary: `The area of the rendering you want to display.  This should match the size
     of the render window itself (ie - the one set using SetSize)`
          }
        ],
        returns: 'Returns True if the wireframe channel was successfully added.'
      },
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'void EndAsyncRender(RenderSuccessCode successCode)',
        summary: 'Must be called when an asynchronous render has finished or ended for any reason.',
        since: 6,
        parameters: [
          {
            name: 'successCode',
            summary: 'Completed for a correct or canceled render, Failed for errors.'
          }
        ]
      },
      {
        signature: 'ImageAdjust GetAdjust()',
        summary: `Get an ImageAdjust instance containing current image adjusting settings
     for this RenderWindow`,
        since: 6,
        returns: 'ImageAdjust'
      },
      {
        signature: 'Bitmap GetBitmap()',
        since: 6
      },
      {
        signature: 'void Invalidate()',
        summary: 'Invalidate the entire view window so that the pixels get painted.',
        since: 5
      },
      {
        signature: 'void InvalidateArea(Rectangle rect)',
        since: 5
      },
      {
        signature: 'bool IsChannelAvailable(Guid id)',
        summary: 'Query if a channel is available.',
        since: 7,
        returns: 'Returns True if the channel is available.'
      },
      {
        signature: 'bool IsChannelShown(Guid id)',
        summary: 'Query if a channel is being shown.',
        since: 7,
        returns: 'Returns True if the channel is being shown.'
      },
      {
        signature: 'Channel OpenChannel(StandardChannels id)',
        since: 5
      },
      {
        signature: 'void SaveDibAsBitmap(string filename)',
        summary: `Save current Dib of RenderWindow as file
     Helper function for debugging purposes.`,
        since: 6
      },
      {
        signature: 'void SaveRenderImageAs(string filename,bool saveAlpha)',
        summary: `Like RenderWindow.SaveRenderImageAs(string,Guid,bool), but with
   Guid set to Guid.Empty.`,
        since: 6,
        parameters: [
          {
            name: 'filename',
            summary: 'Filename of image file to be created'
          },
          {
            name: 'saveAlpha',
            summary: 'True if alpha channel should be saved.'
          }
        ]
      },
      {
        signature: 'void SaveRenderImageAs(string filename,Guid renderEngineGuid,bool saveAlpha)',
        summary: `Save current RenderWindow contents as
   an image file with the given name. The
   filetype will be determine. 
   
   Pass in render engine Guid if an engine
   implements saving to a format that is not
   supported by Rhino. Guid.Empty if there is no need for that.`,
        since: 6,
        parameters: [
          {
            name: 'filename',
            summary: 'Filename of image file to be created'
          },
          {
            name: 'renderEngineGuid',
            summary: 'render engine ID'
          },
          {
            name: 'saveAlpha',
            summary: 'True if alpha channel should be saved.'
          }
        ]
      },
      {
        signature: 'void SetAdjust(ImageAdjust imageAdjust)',
        summary: `Set new ImageAdjust to use. An ImageAdjust instance can be obtained by first
     querying for one using GetAdjust()`,
        since: 6,
        parameters: [
          {
            name: 'imageAdjust',
            summary: 'ImageAdjust'
          }
        ]
      },
      {
        signature: 'void SetProgress(string text,float progress)',
        summary: 'Accepts a rendering progress value to inform the user of the rendering advances.',
        since: 5,
        parameters: [
          {
            name: 'text',
            summary: 'The progress text.'
          },
          {
            name: 'progress',
            summary: 'A progress value in the domain [0.0f; 1.0f].'
          }
        ]
      },
      {
        signature: 'void SetRGBAChannelColors(Rectangle rectangle,Color4f[] colors)',
        summary: 'Call this method to open the RenderWindow.StandardChannels.RGBA channel and set a block of color values',
        since: 5,
        parameters: [
          {
            name: 'rectangle',
            summary: `rectangle.X is the horizontal pixel position of the left edge. No validation is done on this value.
       The caller is responsible for ensuring that it is within the frame buffer.
     rectangle.Y is the vertical pixel position of the top edge. No validation is done on this value.
       The caller is responsible for ensuring that it is within the frame buffer.
     rectangle.Width is the width of the rectangle in pixels. No validation is done on this value.
     rectangle.Height is the height of the rectangle in pixels. No validation is done on this value.`
          },
          {
            name: 'colors',
            summary: 'Array of Color4f values used to set the RenderWindow.StandardChannels.RGBA'
          }
        ]
      },
      {
        signature: 'void SetRGBAChannelColors(Size size,Color4f[] colors)',
        summary: 'Call this method to open the RenderWindow.StandardChannels.RGBA channel and set a block of color values',
        since: 5,
        parameters: [
          {
            name: 'size',
            summary: 'Size of the area to set. No validation is done on this value'
          },
          {
            name: 'colors',
            summary: 'Array of Color4f values used to set the RenderWindow.StandardChannels.RGBA'
          }
        ]
      },
      {
        signature: 'void SetSize(Size size)',
        since: 5
      },
      {
        signature: 'void SetView(ViewInfo view)',
        since: 6
      },
      {
        signature: 'System.Drawing.Size Size()',
        since: 5
      }
    ],
    events: [
      {
        signature: 'static Cloned',
        since: 5.11
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderWindow.Channel',
    dataType: 1,
    interfaces: ['IDisposable'],
    methods: [
      {
        signature: 'void AddValue(int x,int y,Color4f value)',
        summary: `Add value to existing values at point x, y.
       If x or y are out of range, the function will fail and may crash Rhino.`,
        since: 6,
        parameters: [
          {
            name: 'x',
            summary: `The horizontal pixel position. No validation is done on this value. 
       The caller is responsible for ensuring that it is within the frame buffer.`
          },
          {
            name: 'y',
            summary: `The vertical pixel position. No validation is done on this value.
       The caller is responsible for ensuring that it is within the frame buffer.`
          },
          {
            name: 'value',
            summary: 'The color to store in the channel at the specified position.'
          }
        ]
      },
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'int PixelSize()',
        summary: `Returns the size of the data in one pixel in the channel. For RDK standard channels, this value is always sizeof(float). 
       For the special chanRGBA collective channel,
       this value is 4 * sizeof(float).`,
        since: 5,
        returns: 'The size of a pixel.'
      },
      {
        signature: 'void SetValue(int x,int y,Color4f value)',
        summary: 'If x or y are out of range, the function will fail and may crash Rhino.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: `The horizontal pixel position. No validation is done on this value. 
       The caller is responsible for ensuring that it is within the frame buffer.`
          },
          {
            name: 'y',
            summary: `The vertical pixel position. No validation is done on this value.
       The caller is responsible for ensuring that it is within the frame buffer.`
          },
          {
            name: 'value',
            summary: 'The color to store in the channel at the specified position.'
          }
        ]
      },
      {
        signature: 'void SetValue(int x,int y,float value)',
        summary: 'If x or y are out of range, the function will fail and may crash Rhino.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: `The horizontal pixel position. No validation is done on this value. 
       The caller is responsible for ensuring that it is within the frame buffer.`
          },
          {
            name: 'y',
            summary: `the vertical pixel position. No validation is done on this value.
       The caller is responsible for ensuring that it is within the frame buffer.`
          },
          {
            name: 'value',
            summary: 'The value to store in the channel at the specified position.'
          }
        ]
      },
      {
        signature: 'void SetValues(Rectangle rectangle,Size bufferResolution,PixelBuffer colorBuffer)',
        summary: 'Set a pixel buffer',
        since: 6,
        parameters: [
          {
            name: 'rectangle',
            summary: ''
          },
          {
            name: 'bufferResolution',
            summary: ''
          },
          {
            name: 'colorBuffer',
            summary: 'PixelBuffer to a color buffer of floats in RGBA format.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderWindow.ImageAdjust',
    dataType: 1,
    summary: `Class to set image adjusting settings to a RenderWindow. This can't be
     directly created. Instead, one should use RenderWindow.GetAdjust() to
     get an ImageAdjust instance that can be modified, then passed into
     RenderWindow.SetAdjust() to update image adjusting settings.1`,
    properties: [
      {
        signature: 'Methods Dither',
        summary: `Set the Dithering method to use when adjusting the RenderWindow
       content.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'float Gamma',
        summary: `Set the gamma value. The inverse of this will be used to apply
       gamma correction to the RenderWindow RGBA channel when necessary.`,
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderWindow.RenderSuccessCode',
    dataType: 3,
    values: [
      {
        signature: 'Completed = 0'
      },
      {
        signature: 'Failed'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderWindow.StandardChannels',
    dataType: 3,
    values: [
      {
        signature: 'None    = 0x0000'
      },
      {
        signature: 'Red     = 0x0001'
      },
      {
        signature: 'Green   = 0x0002'
      },
      {
        signature: 'Blue    = 0x0004'
      },
      {
        signature: 'Alpha   = 0x0008'
      },
      {
        signature: 'RGBA    = 0x000E'
      },
      {
        signature: 'RGB     = 0x000F'
      },
      {
        signature: 'DistanceFromCamera  = 0x0010'
      },
      {
        signature: 'NormalX             = 0x0020'
      },
      {
        signature: 'NormalY             = 0x0040'
      },
      {
        signature: 'NormalZ             = 0x0080'
      },
      {
        signature: 'NormalXYZ           = 0x00F0'
      },
      {
        signature: 'LuminanceRed        = 0x0100'
      },
      {
        signature: 'LuminanceGreen      = 0x0200'
      },
      {
        signature: 'LuminanceBlue       = 0x0400'
      },
      {
        signature: 'BackgroundLuminanceRed      = 0x1000'
      },
      {
        signature: 'BackgroundLuminanceGreen    = 0x2000'
      },
      {
        signature: 'BackgroundLuminanceBlue     = 0x4000'
      },
      {
        signature: 'MaterialIds       = 0x00010000'
      },
      {
        signature: 'ObjectIds         = 0x00020000'
      },
      {
        signature: 'Wireframe         = 0x00040000'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'RenderWindowClonedEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RenderWindow NewRenderWindow',
        since: 5.11,
        property: ['get']
      },
      {
        signature: 'Guid NewSessionId',
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'RenderWindow OldRenderWindow',
        since: 5.11,
        property: ['get']
      },
      {
        signature: 'Guid OldSessionId',
        since: 5.11,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'SceneServerData',
    dataType: 1,
    summary: 'The Scene Server Data used by the PreviewSceneServer',
    constructors: [
      {
        signature: 'SceneServerData(PreviewGeometry geo,PreviewBackground back,PreviewLighting light,SceneServerDataUsage usage)',
        summary: 'Constructor for SceneServerData',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        summary: 'The CppPointer of SceneServerData',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Dispose for SceneServerData',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'SceneServerDataUsage',
    dataType: 3,
    summary: 'SceneServerData Usage (Synchronous or Asynchronous)',
    values: [
      {
        signature: 'Synchronous'
      },
      {
        signature: 'Asynchronous'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'SimulatedEnvironment',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimulatedEnvironment()',
        since: 5.1
      }
    ],
    properties: [
      {
        signature: 'Color BackgroundColor',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'SimulatedTexture BackgroundImage',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'BackgroundProjections BackgroundProjection',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static BackgroundProjections ProjectionFromString(String projection)',
        since: 5.1
      },
      {
        signature: 'static string StringFromProjection(BackgroundProjections projection)',
        since: 5.1
      },
      {
        signature: 'IntPtr ConstPointer()',
        since: 5.1
      },
      {
        signature: 'void Dispose()',
        since: 5.1
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'SimulatedEnvironment.BackgroundProjections',
    dataType: 3,
    values: [
      {
        signature: 'Planar = 0'
      },
      {
        signature: 'Spherical = 1'
      },
      {
        signature: 'Emap = 2'
      },
      {
        signature: 'Box = 3'
      },
      {
        signature: 'Automatic = 4'
      },
      {
        signature: 'Lightprobe = 5'
      },
      {
        signature: 'Cubemap = 6'
      },
      {
        signature: 'VerticalCrossCubemap = 7'
      },
      {
        signature: 'HorizontalCrossCubemap = 8'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'SimulatedTexture',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimulatedTexture()',
        since: 5.1
      }
    ],
    properties: [
      {
        signature: 'static int BitmapSize',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'String Filename',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool Filtered',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool HasTransparentColor',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Transform LocalMappingTransform',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'int MappingChannel',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Vector2d Offset',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'String OriginalFilename',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'ProjectionModes ProjectionMode',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Vector2d Repeat',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool Repeating',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'double Rotation',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Color4f TransparentColor',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'double TransparentColorSensitivity',
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        since: 5.1
      },
      {
        signature: 'void Dispose()',
        since: 5.1
      },
      {
        signature: 'double MetersToUnits(double units)',
        since: 5.1
      },
      {
        signature: 'double MetersToUnits(RhinoDoc doc,double units)',
        since: 6
      },
      {
        signature: 'void SetMappingChannelAndProjectionMode(ProjectionModes pm,int mappingChannel,EnvironmentMappingModes emm)',
        since: 6
      },
      {
        signature: 'Rhino.DocObjects.Texture Texture()',
        since: 5.1
      },
      {
        signature: 'double UnitsToMeters(double units)',
        since: 5.1
      },
      {
        signature: 'double UnitsToMeters(RhinoDoc doc,double units)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'SimulatedTexture.EnvironmentMappingModes',
    dataType: 3,
    values: [
      {
        signature: 'Automatic = 0'
      },
      {
        signature: 'Spherical = 1'
      },
      {
        signature: 'Emap = 2'
      },
      {
        signature: 'Box = 3'
      },
      {
        signature: 'Lightprobe = 5'
      },
      {
        signature: 'Cubemap = 6'
      },
      {
        signature: 'VerticalCrossCubemap = 7'
      },
      {
        signature: 'HorizontalCrossCubemap = 8'
      },
      {
        signature: 'Hemispherical = 9'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'SimulatedTexture.ProjectionModes',
    dataType: 3,
    values: [
      {
        signature: 'MappingChannel = 0'
      },
      {
        signature: 'View = 1'
      },
      {
        signature: 'Wcs = 2'
      },
      {
        signature: 'Emap = 3'
      },
      {
        signature: 'WcsBox = 4'
      },
      {
        signature: 'Screen = 5'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'Skylight',
    dataType: 1,
    baseclass: 'Rhino.Render.DocumentOrFreeFloatingBase',
    constructors: [
      {
        signature: 'Skylight()',
        summary: 'Create an utility object not associated with any document',
        since: 6
      },
      {
        signature: 'Skylight(Skylight src)',
        summary: 'Create an utility object not associated with any document from another object',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'Guid CustomEnvironment',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool CustomEnvironmentOn',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool Enabled',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double ShadowIntensity',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void CopyFrom(FreeFloatingBase src)',
        since: 6
      }
    ],
    events: [
      {
        signature: 'static Changed',
        summary: 'This event is raised when a Skylight property value is changed.',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'Sun',
    dataType: 1,
    summary: 'Represents the Sun on a little portion of Earth.',
    baseclass: 'Rhino.Render.DocumentOrFreeFloatingBase',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'Sun()',
        summary: 'Create a non-document controlled Sun',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'double Altitude',
        summary: 'Get the altitude for the sun. To set use SetPosition(azimuth, altitude)',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double Azimuth',
        summary: 'Get the azimuth for the sun. To set use SetPosition(azimuth, altitude)',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool DaylightSaving',
        summary: 'Daylight savings time',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'int DaylightSavingMinutes',
        summary: 'Daylight saving minutes',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool Enabled',
        summary: 'Turn the sun on/off in this document.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double Intensity',
        summary: 'Sun intensity.',
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'double Latitude',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Light Light',
        summary: `Get a Light which represents the sun. If manual control is in effect, no sun calculation
     is performed; the function uses the values last used in calls to Azimuth, Altitude
     or Vector. If manual control is not in effect, the observer's position, date, time,
     time zone and daylight saving values are used to calculate the position of the sun.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'double Longitude',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool ManualControl',
        summary: 'Set angles directly or use place/date/time',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'double North',
        summary: `Angle in degrees on world X-Y plane that should be considered north in the model. Angle is
     measured starting at X-Axis and travels counterclockwise. Y-Axis would be a north angle of 90
     degrees.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool SkylightOn',
        summary: 'Turn skylight on or off.',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'double TimeZone',
        summary: 'Measured in hours += UTC',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d Vector',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static double AltitudeFromValues(double latitude,double longitude,double timezoneHours,int daylightMinutes,DateTime when,double hours,bool fast)',
        since: 6
      },
      {
        signature: 'static System.Drawing.Color ColorFromAltitude(double altitudeDegrees)',
        summary: 'Get sun color based on altitude.',
        since: 6,
        parameters: [
          {
            name: 'altitudeDegrees',
            summary: 'The altitude sun angle in degrees.'
          }
        ],
        returns: 'Returns color for altitude.'
      },
      {
        signature: 'static bool Here(double latitude,double longitude)',
        since: 6
      },
      {
        signature: 'static double JulianDay(double timezoneHours,int daylightMinutes,DateTime when,double hours)',
        since: 6
      },
      {
        signature: 'static Geometry.Vector3d SunDirection(double latitude,double longitude,DateTime when)',
        since: 5
      },
      {
        signature: 'static double TwilightZone()',
        since: 6
      },
      {
        signature: 'void CopyFrom(FreeFloatingBase src)',
        since: 6
      },
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'DateTime GetDateTime(DateTimeKind kind)',
        since: 5
      },
      {
        signature: 'void SetDateTime(DateTime time,DateTimeKind kind)',
        since: 6
      },
      {
        signature: 'void SetPosition(DateTime when,double latitudeDegrees,double longitudeDegrees)',
        summary: 'Sets position of the sun based on physical location and time.',
        since: 5,
        parameters: [
          {
            name: 'when',
            summary: `A DateTime instance.
     If the date Kind is DateTimeKind.Local,
     or DateTimeKind.Unspecified, the date is considered local.`
          },
          {
            name: 'latitudeDegrees',
            summary: 'The latitude, in degrees, of the location on Earth.'
          },
          {
            name: 'longitudeDegrees',
            summary: 'The longitude, in degrees, of the location on Earth.'
          }
        ]
      },
      {
        signature: 'void SetPosition(double azimuthDegrees,double altitudeDegrees)',
        summary: `Sets position of the Sun based on azimuth and altitude values.
     Using this function will also set sun to manual.`,
        since: 5,
        parameters: [
          {
            name: 'azimuthDegrees',
            summary: 'The azimuth sun angle in degrees.'
          },
          {
            name: 'altitudeDegrees',
            summary: 'The altitude sun angle in degrees.'
          }
        ]
      },
      {
        signature: 'void ShowDialog()',
        summary: 'Show the tabbed sun dialog.',
        since: 5
      }
    ],
    events: [
      {
        signature: 'static Changed',
        summary: 'This event is raised when a Sun property value is changed.',
        since: 5.1
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'SupportOptions',
    dataType: 1,
    methods: [
      {
        signature: 'static bool AlwaysShowSunPreview()',
        since: 6
      },
      {
        signature: 'static int AutoSaveKeepAmount()',
        since: 6
      },
      {
        signature: 'static bool AutoSaveRenderings()',
        since: 6
      },
      {
        signature: 'static bool CheckSupportFilesBeforeRendering()',
        since: 6
      },
      {
        signature: 'static bool CombineEditors()',
        since: 6
      },
      {
        signature: 'static string CustomLibraryPath()',
        since: 6
      },
      {
        signature: 'static string CustomPaths()',
        since: 6
      },
      {
        signature: 'static int DarkPreviewCheckerColor()',
        since: 6
      },
      {
        signature: 'static bool EnablePreviewJobLog()',
        since: 6
      },
      {
        signature: 'static bool HarvestContentParameters()',
        since: 6
      },
      {
        signature: 'static int LabelFormatLoc()',
        since: 6
      },
      {
        signature: 'static int LabelFormatUtc()',
        since: 6
      },
      {
        signature: 'static string LastNavigatedLocation()',
        since: 6.1
      },
      {
        signature: 'static RdkInitialLocation LibrariesInitialLocation()',
        since: 6
      },
      {
        signature: 'static string LibrariesInitialLocationCustomFolder()',
        since: 6
      },
      {
        signature: 'static int LightPreviewCheckerColor()',
        since: 6
      },
      {
        signature: 'static int MaxPreviewCacheMB()',
        since: 6
      },
      {
        signature: 'static int MaxPreviewSeconds()',
        since: 6
      },
      {
        signature: 'static bool MultithreadedTextureEvaluation()',
        since: 6
      },
      {
        signature: 'static bool PreferNativeRenderer()',
        since: 6
      },
      {
        signature: 'static string PreferredUnpackFolder()',
        since: 6
      },
      {
        signature: 'static bool PreviewCustomRenderMeshes()',
        since: 6
      },
      {
        signature: 'static void SetAlwaysShowSunPreview(bool b)',
        since: 6
      },
      {
        signature: 'static void SetAutoSaveKeepAmount(int value)',
        since: 6
      },
      {
        signature: 'static void SetAutoSaveRenderings(bool b)',
        since: 6
      },
      {
        signature: 'static void SetCheckSupportFilesBeforeRendering(bool b)',
        since: 6
      },
      {
        signature: 'static void SetCombineEditors(bool b)',
        since: 6
      },
      {
        signature: 'static void SetCustomLibraryPath(string path)',
        since: 6
      },
      {
        signature: 'static void SetCustomPaths(string path)',
        since: 6
      },
      {
        signature: 'static void SetHarvestContentParameters(bool b)',
        since: 6
      },
      {
        signature: 'static void SetLabelFormatLoc(int value)',
        since: 6
      },
      {
        signature: 'static void SetLabelFormatUtc(int value)',
        since: 6
      },
      {
        signature: 'static void SetLastNavigatedLocation(string folder)',
        since: 6.1
      },
      {
        signature: 'static void SetLibrariesInitialLocation(RdkInitialLocation l)',
        since: 6
      },
      {
        signature: 'static void SetLibrariesInitialLocationCustomFolder(string path)',
        since: 6
      },
      {
        signature: 'static void SetMultithreadedTextureEvaluation(bool b)',
        since: 6
      },
      {
        signature: 'static void SetPreferNativeRenderer(bool b)',
        since: 6
      },
      {
        signature: 'static void SetPreferredUnpackFolder(string path)',
        since: 6
      },
      {
        signature: 'static void SetPreviewCustomRenderMeshes(bool b)',
        since: 6
      },
      {
        signature: 'static void SetShowCustom(bool b)',
        since: 6
      },
      {
        signature: 'static void SetShowDetailsPanel(bool b)',
        since: 6
      },
      {
        signature: 'static void SetShowDocuments(bool b)',
        since: 6
      },
      {
        signature: 'static void SetShowRenderContent(bool b)',
        since: 6
      },
      {
        signature: 'static void SetSupportSharedUIs(bool b)',
        since: 6
      },
      {
        signature: 'static void SetTextureSize(RdkTextureSize size,bool bSendEvent)',
        since: 6
      },
      {
        signature: 'static void SetUseDefaultLibraryPath(bool b)',
        since: 6
      },
      {
        signature: 'static void SetUsePreviewCache(bool b)',
        since: 6
      },
      {
        signature: 'static void SetUseQuickInitialPreview(bool b)',
        since: 6
      },
      {
        signature: 'static bool ShowCustom()',
        since: 6
      },
      {
        signature: 'static bool ShowDetailsPanel()',
        since: 6
      },
      {
        signature: 'static bool ShowDocuments()',
        since: 6
      },
      {
        signature: 'static bool ShowRenderContent()',
        since: 6
      },
      {
        signature: 'static bool SupportSharedUIs()',
        since: 6
      },
      {
        signature: 'static bool SupportSharedUIsNoCache()',
        since: 6
      },
      {
        signature: 'static int TextureSize()',
        since: 6
      },
      {
        signature: 'static bool UseDefaultLibraryPath()',
        since: 6
      },
      {
        signature: 'static bool UsePreview()',
        since: 6
      },
      {
        signature: 'static bool UsePreviewCache()',
        since: 6
      },
      {
        signature: 'static bool UseQuickInitialPreview()',
        since: 6
      },
      {
        signature: 'static bool UseRenderedPreview()',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'SupportOptions.RdkInitialLocation',
    dataType: 3,
    values: [
      {
        signature: 'RenderContent = UnsafeNativeMethods.RdkInitialLocation.RenderContent'
      },
      {
        signature: 'LastOpenedFolder = UnsafeNativeMethods.RdkInitialLocation.LastOpenedFolder'
      },
      {
        signature: 'CustomFolder = UnsafeNativeMethods.RdkInitialLocation.CustomFolder'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'SupportOptions.RdkTextureSize',
    dataType: 3,
    values: [
      {
        signature: 'Size1 = UnsafeNativeMethods.RdkTextureSize.Size1'
      },
      {
        signature: 'Size2 = UnsafeNativeMethods.RdkTextureSize.Size2'
      },
      {
        signature: 'Size3 = UnsafeNativeMethods.RdkTextureSize.Size3'
      },
      {
        signature: 'Size4 = UnsafeNativeMethods.RdkTextureSize.Size4'
      },
      {
        signature: 'Size5 = UnsafeNativeMethods.RdkTextureSize.Size5'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TexturedColor',
    dataType: 1,
    summary: 'Color4f specialization of TexturedValue.',
    baseclass: 'TexturedValue<Display.Color4f>',
    constructors: [
      {
        signature: 'TexturedColor(string name,Color4f value,bool on,float amount)',
        since: 6.12
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TexturedFloat',
    dataType: 1,
    summary: 'float specialization of TexturedValue.',
    baseclass: 'TexturedValue<float>',
    constructors: [
      {
        signature: 'TexturedFloat(string name,float value,bool on,float amount)',
        since: 6.12
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TexturedValue',
    dataType: 1,
    summary: `Generic class to help holding on to related values. This can be
   used to get data from textured content fields with the
   HandleTexturedValue function.`,
    constructors: [
      {
        signature: 'TexturedValue(string name,T value,bool on,float amount)'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TextureEnvironmentMappingMode',
    dataType: 3,
    values: [
      {
        signature: 'Automatic   = 0'
      },
      {
        signature: 'Spherical   = 1'
      },
      {
        signature: 'EnvironmentMap    = 2'
      },
      {
        signature: 'Box         = 3'
      },
      {
        signature: 'LightProbe = 5'
      },
      {
        signature: 'Cube  = 6'
      },
      {
        signature: 'VerticalCrossCube = 7'
      },
      {
        signature: 'HorizontalCrossCube = 8'
      },
      {
        signature: 'Hemispherical = 9'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TextureEvaluator',
    dataType: 1,
    summary: 'This is the interface to a lightweight object capable of evaluating texture color throughout uvw space.  Derive from this class to create your own texture evaluator to return from a custom RenderTexture.',
    interfaces: ['IDisposable'],
    methods: [
      {
        signature: 'static void FreeByteArray(IntPtr p)',
        since: 7
      },
      {
        signature: 'static byte GetByteArrayValue(IntPtr p,int offset)',
        since: 7
      },
      {
        signature: 'static IntPtr NewByteArray(int width,int height)',
        since: 7
      },
      {
        signature: 'static void Rdk_TextureEvaluator_ApplyGamma(IntPtr p,int width,int height,float gamma)',
        since: 7
      },
      {
        signature: 'static void SetByteArrayValue(IntPtr p,int offset,byte value)',
        since: 7
      },
      {
        signature: 'bool CanBeDumpedToBytes(int width,int height)',
        summary: `Fast access to bitmap evaluator for Cycles - supply size (which you will probably have received from CRhRdkTexture::PixelSize) to see
     if the data can be extracted direct to a width*height*4 array of unsigned chars.
     This is implemented by EVF(L"CanBeDumpedToBytes", ON_2iSize*) != nullptr;`,
        since: 7,
        parameters: [
          {
            name: 'width',
            summary: 'is the point for which to evaluate the texture.'
          },
          {
            name: 'height',
            summary: 'duvwdx is a ray differential.'
          }
        ],
        returns: 'True if the evaluator returned a valid color.  Otherwise false.'
      },
      {
        signature: 'void Dispose()',
        summary: 'For Dispose pattern',
        since: 5.1
      },
      {
        signature: 'void DumpToBytes(int width,int height,IntPtr buffer)',
        summary: `Fast access to bitmap evaluator for Cycles - supply size (which you will probably have received from CRhRdkTexture::PixelSize) to see
     if the data can be extracted direct to a width*height*4 array of unsigned chars.
     This is implemented by EVF(L"CanBeDumpedToBytes", ON_2iSize*) != nullptr;`,
        since: 7,
        parameters: [
          {
            name: 'width',
            summary: 'is the point for which to evaluate the texture.'
          },
          {
            name: 'height',
            summary: 'duvwdx is a ray differential.'
          },
          {
            name: 'buffer',
            summary: 'duvwdx is a ray differential.'
          }
        ],
        returns: 'True if the evaluator returned a valid color.  Otherwise false.'
      },
      {
        signature: 'Display.Color4f GetColor(Point3d uvw,Vector3d duvwdx,Vector3d duvwdy)',
        summary: `Get the color of the texture at a particular point in uvw space.
   May be called from within a rendering shade pipeline.
   note For ray differentials see Pharr Humphreys, "Physically Based Rendering", chapter 11.`,
        since: 5.1,
        parameters: [
          {
            name: 'uvw',
            summary: 'is the point for which to evaluate the texture.'
          },
          {
            name: 'duvwdx',
            summary: 'duvwdx is a ray differential.'
          },
          {
            name: 'duvwdy',
            summary: 'duvwdy is a ray differential.'
          }
        ],
        returns: 'The texture color at this point in UV space.'
      },
      {
        signature: 'bool GetColor(Point3d uvw,Vector3d duvwdx,Vector3d duvwdy,Color4f color)',
        summary: 'Optimized version of GetColor for callers.  Much faster in the case of a native (C++) evaluator.',
        since: 7,
        parameters: [
          {
            name: 'uvw',
            summary: 'is the point for which to evaluate the texture.'
          },
          {
            name: 'duvwdx',
            summary: 'duvwdx is a ray differential.'
          },
          {
            name: 'duvwdy',
            summary: 'duvwdy is a ray differential.'
          },
          {
            name: 'color',
            summary: 'The texture color at this point in UV space.'
          }
        ],
        returns: 'True if the evaluator returned a valid color.  Otherwise false.'
      },
      {
        signature: 'bool Initialize()',
        summary: `Call this function before calling GetColor for the first time. Ideally, this should
   be on the main thread, but you can also call it on a worker thread as long as you
     are sure that Initialize() or GetColor() cannot be called at the same time on another thread.`,
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TextureGeneration',
    dataType: 3,
    values: [
      {
        signature: 'Allow = UnsafeNativeMethods.CRhRdkTextureGenConsts.Allow'
      },
      {
        signature: 'Disallow = UnsafeNativeMethods.CRhRdkTextureGenConsts.Disallow'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TextureGraphInfo',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'TextureGraphInfo()',
        since: 6.3
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6.3,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'Axis ActiveAxis()',
        since: 6.3
      },
      {
        signature: 'Channel ActiveChannel()',
        since: 6.3
      },
      {
        signature: 'double AmountU()',
        since: 6.3
      },
      {
        signature: 'double AmountV()',
        since: 6.3
      },
      {
        signature: 'double AmountW()',
        since: 6.3
      },
      {
        signature: 'void Dispose()',
        since: 6.3
      },
      {
        signature: 'void SetActiveAxis(Axis axis)',
        since: 6.3
      },
      {
        signature: 'void SetActiveChannel(Channel channel)',
        since: 6.3
      },
      {
        signature: 'void SetAmountU(double d)',
        since: 6.3
      },
      {
        signature: 'void SetAmountV(double d)',
        since: 6.3
      },
      {
        signature: 'void SetAmountW(double d)',
        since: 6.3
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TextureGraphInfo.Axis',
    dataType: 3,
    values: [
      {
        signature: 'kU = 0'
      },
      {
        signature: 'kV = 1'
      },
      {
        signature: 'kW = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TextureGraphInfo.Channel',
    dataType: 3,
    values: [
      {
        signature: 'kRed = 0'
      },
      {
        signature: 'kGrn = 1'
      },
      {
        signature: 'kBlu = 2'
      },
      {
        signature: 'kAlp = 3'
      },
      {
        signature: 'kLum = 4'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TextureMapping',
    dataType: 1,
    summary: 'Represents a texture mapping.',
    baseclass: 'Rhino.DocObjects.ModelComponent',
    properties: [
      {
        signature: 'ModelComponentType ComponentType',
        summary: 'Returns ModelComponentType.TextureMapping.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid Id',
        summary: 'The unique Id for this texture mapping object.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'TextureMappingType MappingType',
        summary: 'Texture mapping type associated with this Mapping object.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Transform NormalTransform',
        summary: `For primitive based mappings, these transformations are used to map
     the world coordinate (x,y,z) point P and  surface normal N before it is
     projected to the normalized mapping primitive. The surface normal
     transformation, m_Nxyz, is always calculated from m_Pxyz.  It is a
     runtime setting that is not saved in 3dm files. If m_type is
     srfp_mapping, then m_Pxyz and m_Nxyz are ignored.`,
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Transform PrimativeTransform',
        summary: `For primitive based mappings, these transformations are used to map
     the world coordinate (x,y,z) point P and  surface normal N before it is
     projected to the normalized mapping primitive. The surface normal
     transformation, m_Nxyz, is always calculated from m_Pxyz.  It is a
     runtime setting that is not saved in 3dm files. If m_type is
     srfp_mapping, then m_Pxyz and m_Nxyz are ignored.`,
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Transform UvwTransform',
        summary: `Transform applied to mapping coordinate (u,v,w) to convert it into a
     texture coordinate.`,
        since: 5.1,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static TextureMapping CreateBoxMapping(Plane plane,Interval dx,Interval dy,Interval dz,bool capped)',
        summary: 'Create a box projection texture mapping.',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: `The sides of the box the box are parallel to the plane's coordinate
     planes.  The dx, dy, dz intervals determine the location of the sides.`
          },
          {
            name: 'dx',
            summary: `Determines the location of the front and back planes. The vector
     plane.xaxis is perpendicular to these planes and they pass through
     plane.PointAt(dx[0],0,0) and plane.PointAt(dx[1],0,0), respectivly.`
          },
          {
            name: 'dy',
            summary: `Determines the location of the left and right planes. The vector
     plane.yaxis is perpendicular to these planes and they pass through
     plane.PointAt(0,dy[0],0) and plane.PointAt(0,dy[1],0), respectivly.`
          },
          {
            name: 'dz',
            summary: `Determines the location of the top and bottom planes. The vector
     plane.zaxis is perpendicular to these planes and they pass through
     plane.PointAt(0,0,dz[0]) and plane.PointAt(0,0,dz[1]), respectivly.`
          },
          {
            name: 'capped',
            summary: 'If true, the box is treated as a finite capped box.'
          }
        ],
        returns: 'TextureMapping instance if input is valid'
      },
      {
        signature: 'static TextureMapping CreateCustomMeshMapping(Mesh mesh)',
        summary: 'Create custom mesh mapping',
        since: 6.15,
        parameters: [
          {
            name: 'mesh',
            summary: 'Mesh with texture coordinates'
          }
        ],
        returns: 'TextureMapping instance'
      },
      {
        signature: 'static TextureMapping CreateCylinderMapping(Cylinder cylinder,bool capped)',
        summary: 'Create a cylindrical projection texture mapping.',
        since: 5,
        parameters: [
          {
            name: 'cylinder',
            summary: `cylinder in world space used to define a cylindrical coordinate system.
     The angular parameter maps (0,2pi) to texture "u" (0,1), The height
     parameter maps (height[0],height[1]) to texture "v" (0,1), and the
     radial parameter maps (0,r) to texture "w" (0,1).`
          },
          {
            name: 'capped',
            summary: 'If true, the cylinder is treated as a finite capped cylinder'
          }
        ],
        returns: 'TextureMapping instance if input is valid'
      },
      {
        signature: 'static TextureMapping CreatePlaneMapping(Plane plane,Interval dx,Interval dy,Interval dz)',
        summary: 'Create a planar UV projection texture mapping',
        since: 5,
        parameters: [
          {
            name: 'plane',
            summary: 'A plane to use for mapping.'
          },
          {
            name: 'dx',
            summary: 'portion of the plane\'s x axis that is mapped to [0,1] (can be a decreasing interval)'
          },
          {
            name: 'dy',
            summary: 'portion of the plane\'s y axis that is mapped to [0,1] (can be a decreasing interval)'
          },
          {
            name: 'dz',
            summary: 'portion of the plane\'s z axis that is mapped to [0,1] (can be a decreasing interval)'
          }
        ],
        returns: 'TextureMapping instance if input is valid'
      },
      {
        signature: 'static TextureMapping CreatePlaneMapping(Plane plane,Interval dx,Interval dy,Interval dz,bool capped)',
        summary: 'Create a planar projection texture mapping',
        since: 6.7,
        parameters: [
          {
            name: 'plane',
            summary: 'A plane to use for mapping.'
          },
          {
            name: 'dx',
            summary: 'portion of the plane\'s x axis that is mapped to [0,1] (can be a decreasing interval)'
          },
          {
            name: 'dy',
            summary: 'portion of the plane\'s y axis that is mapped to [0,1] (can be a decreasing interval)'
          },
          {
            name: 'dz',
            summary: 'portion of the plane\'s z axis that is mapped to [0,1] (can be a decreasing interval)'
          },
          {
            name: 'capped',
            summary: 'set to True if planar UVW is meant, False for planar UV'
          }
        ],
        returns: 'TextureMapping instance if input is valid'
      },
      {
        signature: 'static TextureMapping CreateSphereMapping(Sphere sphere)',
        summary: 'Create a spherical projection texture mapping.',
        since: 5,
        parameters: [
          {
            name: 'sphere',
            summary: `sphere in world space used to define a spherical coordinate system.
     The longitude parameter maps (0,2pi) to texture "u" (0,1).
     The latitude paramter maps (-pi/2,+pi/2) to texture "v" (0,1).
     The radial parameter maps (0,r) to texture "w" (0,1).`
          }
        ],
        returns: 'TextureMapping instance if input is valid'
      },
      {
        signature: 'int Evaluate(Point3d p,Vector3d n,Point3d t)',
        summary: 'Evaluate the mapping to get a texture coordinate',
        since: 6.17,
        parameters: [
          {
            name: 'p',
            summary: 'Vertex location'
          },
          {
            name: 'n',
            summary: `If the mapping projection is ray_projection, then this
     is the vertex unit normal.  Otherwise n is ignored.`
          },
          {
            name: 't',
            summary: 'Texture coordinate (u,v,w)'
          }
        ],
        returns: `Nonzero if evaluation is successful.  When the mapping is a box or
     capped cylinder mapping, the value indicates which side was evaluated.
     Cylinder mapping: 1 = cylinder wall, 2 = bottom cap, 3 = top cap
     Box mapping: 1 = front, 2 = right, 3 = back, 4 = left, 5 = bottom, 6 = top`
      },
      {
        signature: 'int Evaluate(Point3d p,Vector3d n,Point3d t,Transform pXform,Transform nXform)',
        summary: 'Evaluate the mapping to get a texture coordinate',
        since: 6.17,
        parameters: [
          {
            name: 'p',
            summary: 'Vertex location'
          },
          {
            name: 'n',
            summary: `If the mapping projection is ray_projection, then this
     is the vertex unit normal.  Otherwise n is ignored.`
          },
          {
            name: 't',
            summary: 'Texture coordinate (u,v,w)'
          },
          {
            name: 'pXform',
            summary: 'Transformation to be applied to P before performing the mapping calculation.'
          },
          {
            name: 'nXform',
            summary: `Transformation to be applied to N before performing the mapping
     calculation. One way to calculate nXxform is to use the call
     pXform::GetVectorTransform(nXform).`
          }
        ],
        returns: `Nonzero if evaluation is successful.  When the mapping is a box or
     capped cylinder mapping, the value indicates which side was evaluated.
     Cylinder mapping: 1 = cylinder wall, 2 = bottom cap, 3 = top cap
     Box mapping: 1 = front, 2 = right, 3 = back, 4 = left, 5 = bottom, 6 = top`
      },
      {
        signature: 'bool TryGetMappingBox(Plane plane,Interval dx,Interval dy,Interval dz)',
        summary: 'Get a box projection from the texture mapping.',
        since: 5.1,
        parameters: [
          {
            name: 'plane',
            summary: `The center of the box is at plane.origin and the sides of the box are
     parallel to the plane's coordinate planes.`
          },
          {
            name: 'dx',
            summary: `The "front" and "back" sides of the box are in spanned by the vectors
     plane.yaxis and plane.zaxis.  The back plane contains the point
     plane.PointAt(dx[0],0,0) and the front plane contains the point
     plane.PointAt(dx[1],0,0).`
          },
          {
            name: 'dy',
            summary: `The "left" and "right" sides of the box are in spanned by the vectors
     plane.zaxis and plane.xaxis.  The left plane contains the point
     plane.PointAt(0,dx[0],0) and the back plane contains the point
     plane.PointAt(0,dy[1],0).`
          },
          {
            name: 'dz',
            summary: `The "top" and "bottom" sides of the box are in spanned by the vectors
     plane.xaxis and plane.yaxis.  The bottom plane contains the point
     plane.PointAt(0,0,dz[0]) and the top plane contains the point
     plane.PointAt(0,0,dz[1]).`
          }
        ],
        returns: 'Returns True if a valid box is returned.'
      },
      {
        signature: 'bool TryGetMappingBox(Plane plane,Interval dx,Interval dy,Interval dz,bool capped)',
        summary: 'Get a box projection from the texture mapping, including capped information',
        since: 6.7,
        parameters: [
          {
            name: 'plane',
            summary: `The center of the box is at plane.origin and the sides of the box are
     parallel to the plane's coordinate planes.`
          },
          {
            name: 'dx',
            summary: `The "front" and "back" sides of the box are in spanned by the vectors
     plane.yaxis and plane.zaxis.  The back plane contains the point
     plane.PointAt(dx[0],0,0) and the front plane contains the point
     plane.PointAt(dx[1],0,0).`
          },
          {
            name: 'dy',
            summary: `The "left" and "right" sides of the box are in spanned by the vectors
     plane.zaxis and plane.xaxis.  The left plane contains the point
     plane.PointAt(0,dx[0],0) and the back plane contains the point
     plane.PointAt(0,dy[1],0).`
          },
          {
            name: 'dz',
            summary: `The "top" and "bottom" sides of the box are in spanned by the vectors
     plane.xaxis and plane.yaxis.  The bottom plane contains the point
     plane.PointAt(0,0,dz[0]) and the top plane contains the point
     plane.PointAt(0,0,dz[1]).`
          },
          {
            name: 'capped',
            summary: 'True if box mapping is capped.'
          }
        ],
        returns: 'Returns True if a valid box is returned.'
      },
      {
        signature: 'bool TryGetMappingCylinder(Cylinder cylinder)',
        summary: 'Get a cylindrical projection parameters from this texture mapping.',
        since: 5.1,
        returns: 'Returns True if a valid cylinder is returned.'
      },
      {
        signature: 'bool TryGetMappingCylinder(Cylinder cylinder,bool capped)',
        summary: 'Get a cylindrical projection parameters from this texture mapping.',
        since: 6.7,
        parameters: [
          {
            name: 'cylinder',
            summary: ''
          },
          {
            name: 'capped',
            summary: 'will be True if capped'
          }
        ],
        returns: 'Returns True if a valid cylinder is returned.'
      },
      {
        signature: 'bool TryGetMappingMesh(Mesh mesh)',
        summary: 'Get custom mapping mesh from this texture mapping.',
        since: 6.18,
        returns: 'True if custom mapping mesh was returned.'
      },
      {
        signature: 'bool TryGetMappingPlane(Plane plane,Interval dx,Interval dy,Interval dz)',
        summary: 'Get plane mapping parameters from this texture mapping.',
        since: 5.1,
        parameters: [
          {
            name: 'plane',
            summary: ''
          },
          {
            name: 'dx',
            summary: 'Portion of the plane\'s x axis that is mapped to [0,1]'
          },
          {
            name: 'dy',
            summary: 'Portion of the plane\'s y axis that is mapped to [0,1]'
          },
          {
            name: 'dz',
            summary: 'Portion of the plane\'s z axis that is mapped to [0,1]'
          }
        ],
        returns: 'Return True if valid plane mapping parameters were returned.'
      },
      {
        signature: 'bool TryGetMappingPlane(Plane plane,Interval dx,Interval dy,Interval dz,bool capped)',
        summary: 'Get plane mapping parameters from this texture mapping, including capping information',
        since: 6.7,
        parameters: [
          {
            name: 'plane',
            summary: ''
          },
          {
            name: 'dx',
            summary: 'Portion of the plane\'s x axis that is mapped to [0,1]'
          },
          {
            name: 'dy',
            summary: 'Portion of the plane\'s y axis that is mapped to [0,1]'
          },
          {
            name: 'dz',
            summary: 'Portion of the plane\'s z axis that is mapped to [0,1]'
          },
          {
            name: 'capped',
            summary: ''
          }
        ],
        returns: 'Return True if valid plane mapping parameters were returned.'
      },
      {
        signature: 'bool TryGetMappingSphere(Sphere sphere)',
        summary: 'Get a spherical projection parameters from this texture mapping.',
        since: 5.1,
        returns: 'Returns True if a valid sphere is returned.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TextureMappingType',
    dataType: 3,
    summary: 'Defines enumerated constants for mapping types such as planar, cylindrical or spherical.',
    values: [
      {
        signature: 'None = UnsafeNativeMethods.TextureMappingType.NoMapping',
        summary: 'No mapping is selected.'
      },
      {
        signature: 'SurfaceParameters = UnsafeNativeMethods.TextureMappingType.SrfpMapping',
        summary: '(u, v) = linear transform of surface params, w = 0.'
      },
      {
        signature: 'PlaneMapping = UnsafeNativeMethods.TextureMappingType.PlaneMapping',
        summary: '(u, v, w) = 3d coordinates wrt frame.'
      },
      {
        signature: 'CylinderMapping = UnsafeNativeMethods.TextureMappingType.CylinderMapping',
        summary: '(u, v, w) = longitude, height, radius.'
      },
      {
        signature: 'SphereMapping = UnsafeNativeMethods.TextureMappingType.SphereMapping',
        summary: '(u, v, w) = longitude,latitude,radius.'
      },
      {
        signature: 'BoxMapping = UnsafeNativeMethods.TextureMappingType.BoxMapping',
        summary: 'Box mapping type.'
      },
      {
        signature: 'MeshMappingPrimitive = UnsafeNativeMethods.TextureMappingType.MeshMappingPrimitive',
        summary: 'Mapping primitive is a mesh.'
      },
      {
        signature: 'SurfaceMappingPrimitive = UnsafeNativeMethods.TextureMappingType.SrfMappingPrimitive',
        summary: 'Mapping primitive is a surface.'
      },
      {
        signature: 'BrepMappingPrimitive = UnsafeNativeMethods.TextureMappingType.BrepMappingPrimitive',
        summary: 'Mapping primitive is a brep.'
      },
      {
        signature: 'OcsMapping = UnsafeNativeMethods.TextureMappingType.OcsMapping',
        summary: 'OCS mapping type (WCS/WCS Box with object frame).'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TextureMode',
    dataType: 3,
    values: [
      {
        signature: 'PROJECTION_MODE = 0'
      },
      {
        signature: 'MAPPING_CHANNEL_MODE'
      },
      {
        signature: 'WRAP_TYPE_MODE'
      },
      {
        signature: 'REPEAT_LOCKED_MODE'
      },
      {
        signature: 'OFFSET_LOCKED_MODE'
      },
      {
        signature: 'PREVIEW_IN_3D_MODE'
      },
      {
        signature: 'REPEAT_MODE'
      },
      {
        signature: 'OFFSET_MODE'
      },
      {
        signature: 'ROTATION_MODE'
      },
      {
        signature: 'ENVIRONMENT_MAPPING_MODE'
      },
      {
        signature: 'INTERNAL_ENVIRONMENT_MAPPING_MODE'
      },
      {
        signature: 'PREVIEW_LOCAL_MAPPING_MODE'
      },
      {
        signature: 'DISPLAY_IN_VIEWPORT_MODE'
      },
      {
        signature: 'IS_HDR_CAPABLE_MODE'
      },
      {
        signature: 'IS_LINEAR_MODE'
      },
      {
        signature: 'IS_IMAGE_BASED'
      },
      {
        signature: 'IS_NORMALMAP'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TextureProjectionMode',
    dataType: 3,
    values: [
      {
        signature: 'MappingChannel = 0'
      },
      {
        signature: 'View = 1'
      },
      {
        signature: 'Wcs = 2'
      },
      {
        signature: 'EnvironmentMap = 3'
      },
      {
        signature: 'WcsBox = 4'
      },
      {
        signature: 'Screen = 5'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TextureRenderHashFlags',
    dataType: 3,
    values: [
      {
        signature: 'ExcludeLocalMapping = (1 << 32)'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TextureWrapType',
    dataType: 3,
    values: [
      {
        signature: 'Clamped = 0'
      },
      {
        signature: 'Repeating = 1'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TimeZone',
    dataType: 1,
    summary: 'TimeZone',
    properties: [
      {
        signature: 'double Hours',
        summary: 'Gets hours of a time zone.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'double Latitude',
        summary: 'Returns the latitude of a major city nearby',
        since: 6.15,
        property: ['get']
      },
      {
        signature: 'double Longitude',
        summary: 'Returns the Longitude of a major city nearby',
        since: 6.15,
        property: ['get']
      },
      {
        signature: 'String Name',
        summary: 'Gets name of a time zone.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static TimeZone TimeZoneAt(int index)',
        summary: 'Returns a time zone at given index.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'index.'
          }
        ],
        returns: 'Time zone at index.'
      },
      {
        signature: 'static int TimeZones()',
        summary: 'Returns number of available time zones.',
        since: 6,
        returns: 'Time zone count.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'TwoColorRenderTexture',
    dataType: 1,
    baseclass: 'Rhino.Render.RenderTexture',
    properties: [
      {
        signature: 'Color4f Color1',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'Color4f Color2',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool SuperSample',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool SwapColors',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'double Texture1Amount',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool Texture1On',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'double Texture2Amount',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool Texture2On',
        since: 5.1,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Render.UI',
    name: 'IUserInterfaceSection',
    dataType: 4,
    summary: `Implement this interface in your user control to get UserInterfaceSection
   event notification.`
  },
  {
    namespace: 'Rhino.Render.UI',
    name: 'UserInterfaceSection',
    dataType: 1,
    summary: 'Custom user interface section manager',
    properties: [
      {
        signature: 'RenderContent RenderContent',
        summary: 'The RenderContent object that created this user interface object.',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'object Window',
        summary: 'The user control associated with this user interface object.',
        since: 5.1,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static UserInterfaceSection FromWindow(object window)',
        summary: `Find the UserInterfaceSection that created the specified instance of a
     window.`,
        since: 6,
        parameters: [
          {
            name: 'window',
            summary: `If window is not None then look for the UserInterfaceSection that
     created the window.`
          }
        ],
        returns: `If a UserInterfaceSection object is found containing a reference to
     the requested window then return the object otherwise return null.`
      },
      {
        signature: 'void Expand(bool expand)',
        summary: 'Expand or collapse this content section.',
        since: 5.1,
        parameters: [
          {
            name: 'expand',
            summary: 'If True then expand the content section otherwise collapse it.'
          }
        ]
      },
      {
        signature: 'RenderContent[] GetContentList()',
        summary: 'Returns a list of currently selected content items to be edited.',
        since: 5.1,
        returns: 'Returns a list of currently selected content items to be edited.'
      },
      {
        signature: 'void Show(bool visible)',
        summary: 'Show or hide this content section.',
        since: 5.1,
        parameters: [
          {
            name: 'visible',
            summary: 'If True then show the content section otherwise hide it.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Render.UI',
    name: 'WorldMapDayNight',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'WorldMapDayNight()',
        since: 6
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'bool HasMapForCurrentSettings()',
        since: 6
      },
      {
        signature: 'System.Drawing.Point LocationToMap(Point2d latlong)',
        since: 6
      },
      {
        signature: 'void MakeMapBitmap()',
        since: 6
      },
      {
        signature: 'System.Drawing.Image Map()',
        since: 6
      },
      {
        signature: 'Rhino.Geometry.Point2d MapToLocation(Point mapPoint)',
        since: 6
      },
      {
        signature: 'void SetDayNightDisplay(bool bOn)',
        since: 6
      },
      {
        signature: 'void SetEnabled(bool bEnabled)',
        since: 6
      },
      {
        signature: 'void SetTimeInfo(DateTime dt,double timezone,int daylightSavingMinutes,bool bDaylightSavingsOn)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'UndoRedo',
    dataType: 1,
    summary: 'This class contains the event for UndoRedoChanged that is fired from RDK .',
    events: [
      {
        signature: 'static UndoRedoChanged',
        summary: 'Called after undo or redo has occurred for document settings.',
        since: 6
      },
      {
        signature: 'static UndoRedoEndedChanged',
        summary: 'This event is raised when undo/redo ends in rdk.',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'Utilities',
    dataType: 1,
    properties: [
      {
        signature: 'static Guid DefaultRenderPlugInId',
        summary: 'Get the plug-in Id for the default render plug-in',
        since: 5.3,
        property: ['get']
      },
      {
        signature: 'static bool ShowIncompatibleEnvironments',
        summary: 'Specifies whether incompatible content should be shown in the corresponding editor.',
        since: 5.3,
        property: ['get', 'set']
      },
      {
        signature: 'static bool ShowIncompatibleMaterials',
        summary: 'Specifies whether incompatible content should be shown in the corresponding editor.',
        since: 5.3,
        property: ['get', 'set']
      },
      {
        signature: 'static bool ShowIncompatibleTextures',
        summary: 'Specifies whether incompatible content should be shown in the corresponding editor.',
        since: 5.3,
        property: ['get', 'set']
      },
      {
        signature: 'static UiFrameworks UiFramework',
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static RenderContent ChangeContentType(RenderContent oldContent,Guid newType,bool harvestParameters)',
        summary: `Changes the type of a content. This deletes the content and creates a replacement
    of the specified type allowing the caller to decide about harvesting.`,
        since: 6,
        parameters: [
          {
            name: 'oldContent',
            summary: 'oldContent is the old content which is deleted.'
          },
          {
            name: 'newType',
            summary: 'The type of content to replace pOldContent with.'
          },
          {
            name: 'harvestParameters',
            summary: 'Determines whether or not parameter harvesting will be performed.'
          }
        ],
        returns: 'A new persistent render content.'
      },
      {
        signature: 'static string FindFile(RhinoDoc doc,string fullPathToFile)',
        summary: `Finds a file and also handles network shares.
     This is a replacement for CRhinoFileUtilities::FindFile().`,
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'Document to use for locating .3dm file\'s folder.'
          },
          {
            name: 'fullPathToFile',
            summary: 'The file to be found.'
          }
        ],
        returns: 'The found file.'
      },
      {
        signature: 'static string FindFile(RhinoDoc doc,string fullPathToFile,bool unpackFromBitmapTableIfNecessary)',
        summary: `Finds a file and also handles network shares.
     This is a replacement for CRhinoFileUtilities::FindFile().`,
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'Document to use for locating .3dm file\'s folder.'
          },
          {
            name: 'fullPathToFile',
            summary: 'The file to be found.'
          },
          {
            name: 'unpackFromBitmapTableIfNecessary',
            summary: 'True to seasch for the file in the bitmap table and unpack it into the temp folder if not found in the initial search.'
          }
        ],
        returns: 'The found file.'
      },
      {
        signature: 'static bool IsCachedTextureFileInUse(string textureFileName)',
        summary: 'Determines if any texture in any persistent content list is using the specified file name for caching.',
        since: 6,
        parameters: [
          {
            name: 'textureFileName',
            summary: 'The file name to check for. The extension is ignored.'
          }
        ],
        returns: 'True if the texture is present.'
      },
      {
        signature: 'static RenderContent LoadPersistentRenderContentFromFile(uint docSerialNumber,String filename)',
        summary: 'Loads a content from a library file and adds it to the persistent content list of a particular document.',
        since: 6,
        parameters: [
          {
            name: 'docSerialNumber',
            summary: 'identifies the document into which the content should be loaded.'
          },
          {
            name: 'filename',
            summary: 'is the full path to the file to be loaded.'
          }
        ],
        returns: 'The loaded content or None if an error occurred.'
      },
      {
        signature: 'static void MoveWindow(IntPtr hwnd,Rectangle rect,bool bRepaint,bool bRepaintNC)',
        since: 6
      },
      {
        signature: 'static string PromptForSaveImageFileParameters(string filename,int width,int height,int colorDepth)',
        summary: 'Prompts the user for a save file name and the width, height and depth of an image to be saved.',
        since: 6,
        parameters: [
          {
            name: 'filename',
            summary: 'The original file path.'
          },
          {
            name: 'width',
            summary: 'A width.'
          },
          {
            name: 'height',
            summary: 'An height.'
          },
          {
            name: 'colorDepth',
            summary: 'A color depth.'
          }
        ],
        returns: 'The new file name.'
      },
      {
        signature: 'static bool SafeFrameEnabled(RhinoDoc doc)',
        summary: 'Queries whether or not the Safe Frame is visible.',
        since: 6
      },
      {
        signature: 'static bool SetDefaultRenderPlugIn(Guid pluginId)',
        summary: 'Set default render application',
        since: 5.3,
        parameters: [
          {
            name: 'pluginId',
            summary: 'ID of render plug-in'
          }
        ],
        returns: `True if plug-in found and loaded successfully.  False if pluginId is
      invalid or was unable to load plug-in`
      },
      {
        signature: 'static ShowContentChooserResults ShowContentChooser(Guid defaultType,Guid defaultInstanceId,RenderContentKind kinds,Guid instanceIdOut,ShowContentChooserFlags flags,RhinoDoc doc)',
        summary: 'Shows the content chooser to allow the user to select a new or existing content.',
        since: 6.25,
        parameters: [
          {
            name: 'defaultType',
            summary: 'The content type that will be initially selected in the \'New\' tab.'
          },
          {
            name: 'defaultInstanceId',
            summary: 'The content instance that will be initially selected in the \'Existing\' tab.'
          },
          {
            name: 'kinds',
            summary: 'Which content kinds will be displayed.'
          },
          {
            name: 'instanceIdOut',
            summary: 'The UUID of the chosen item. Depending on eRhRdkSccResult, this can be the type id of a content type or the instance id of an existing content.'
          },
          {
            name: 'flags',
            summary: 'Tabs specifications.'
          },
          {
            name: 'doc',
            summary: 'A Rhino document.'
          }
        ],
        returns: 'The result.'
      },
      {
        signature: 'static bool ShowIORMenu(IntPtr hwnd,Point pt,double outIOR,string outString)',
        summary: 'Display and track the context menu.',
        since: 6,
        parameters: [
          {
            name: 'hwnd',
            summary: 'The window that displays the menu, for example an edit box.'
          },
          {
            name: 'pt',
            summary: 'The position to display the menu at inside the window'
          },
          {
            name: 'outIOR',
            summary: 'Accepts the IOR value of the user\'s chosen substance'
          },
          {
            name: 'outString',
            summary: 'Accepts the name of the user\'s chosen substance. Can be None if not required.'
          }
        ],
        returns: 'True if the function showed the IOR menu and something was picked.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'Utilities.ShowContentChooserResults',
    dataType: 3,
    values: [
      {
        signature: 'None',
        summary: 'No choice (user cancelled).'
      },
      {
        signature: 'New',
        summary: 'User chose from \'New\' tab. uuidOut is the type id.'
      },
      {
        signature: 'Copy',
        summary: 'User chose from \'Existing\' tab with \'copy\' radio button checked. uuidOut is the instance id.'
      },
      {
        signature: 'Instance',
        summary: 'User chose from \'Existing\' tab with \'instance\' radio button checked. uuidOut is the instance id.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'Utilities.UiFrameworks',
    dataType: 3,
    values: [
      {
        signature: 'Win32',
        summary: 'Win32.'
      },
      {
        signature: 'Cocoa',
        summary: 'Cocoa.'
      },
      {
        signature: 'Eto',
        summary: 'Eto.'
      },
      {
        signature: 'WinForms',
        summary: 'WinForms.'
      },
      {
        signature: 'WPF',
        summary: 'WPF.'
      }
    ]
  },
  {
    namespace: 'Rhino.Render',
    name: 'Variant.VariantTypes',
    dataType: 3,
    values: [
      {
        signature: 'Null = 0'
      },
      {
        signature: 'Bool = 1'
      },
      {
        signature: 'Integer = 2'
      },
      {
        signature: 'Float = 3'
      },
      {
        signature: 'Double = 4'
      },
      {
        signature: 'Color = 5'
      },
      {
        signature: 'Vector2d = 6'
      },
      {
        signature: 'Vector3d = 7'
      },
      {
        signature: 'String = 8'
      },
      {
        signature: 'Pointer = 9'
      },
      {
        signature: 'Uuid = 10'
      },
      {
        signature: 'Matrix = 11'
      },
      {
        signature: 'Time = 12'
      },
      {
        signature: 'Buffer = 13'
      },
      {
        signature: 'Point4d = 14'
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'RhinoApp',
    dataType: 1,
    summary: '.NET RhinoApp is parallel to C++ CRhinoApp.',
    properties: [
      {
        signature: 'static DateTime BuildDate',
        summary: 'Gets the build date.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static bool CanSave',
        summary: `Returns True when Rhino is allowed to save, False otherwise
     Conditions where Rhino is not allowed to save are: when evaluation licenses are expired;
     when a Cloud Zoo lease is expired; when a license is shared by a single user on multiple
     computers, and the current computer is not active.`,
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string CommandHistoryWindowText',
        summary: 'Text in Rhino\'s command history window.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static CommandLineTextWriter CommandLineOut',
        summary: 'Provides a TextWriter that can write to the command line.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static string CommandPrompt',
        summary: 'Rhino command prompt.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool CommandWindowCaptureEnabled',
        summary: `Enable or disable capturing of the strings sent to the CommandWindow through
     Write and WriteLine calls`,
        since: 7,
        property: ['get', 'set']
      },
      {
        signature: 'static Guid CurrentRhinoId',
        summary: 'Gets the current ID of Rhino.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static int DaysUntilExpiration',
        summary: `Returns number of days until license expires. Zero when
       license is expired.
     Raises InvalidLicenseTypeException if LicenseExpires
     would return false.`,
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'static Font DefaultUiFont',
        summary: 'Default font used to render user interface',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static int ExeServiceRelease',
        summary: `Service release version of Rhino executable (0, 1, 2, ...)  
    The integer is the service release number of Rhino.  For example,
    this function returns "0" if Rhino V4SR0 is running and returns
    "1" if Rhino V4SR1 is running.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'static int ExeVersion',
        summary: 'Major version of Rhino executable 4, 5, ...',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Installation InstallationType',
        summary: 'Gets the product installation type, as seen in Rhino\'s ABOUT dialog box.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static string InstallationTypeString',
        summary: 'Gets the type of installation (product edition) of the license or lease.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static bool InvokeRequired',
        summary: 'Returns True if we are currently not running on the main user interface thread',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static bool IsClosing',
        summary: `Returns True if Rhino is in the process of closing, False otherwise.
     This can be True even before the Closing event fires, such as when RhinoDoc.CloseDocument event is called.`,
        property: ['get']
      },
      {
        signature: 'static bool IsCloudZooNode',
        summary: `Returns 
       True if rhino is currently using the Cloud Zoo
       False otherwise`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static bool IsExiting',
        summary: `Returns True if Rhino is in the process of exiting, False otherwise.
     This can be True even before the Closing event fires, such as when RhinoDoc.CloseDocument event is called.`,
        property: ['get']
      },
      {
        signature: 'static bool IsInternetAccessAllowed',
        summary: 'Returns True when Rhino is allowed to access the internet, False otherwise',
        since: 6.15,
        property: ['get']
      },
      {
        signature: 'static bool IsLicenseValidated',
        summary: `Returns 
       True if the license is validated
       False otherwise`,
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'static bool IsPreRelease',
        summary: `Returns
       True if Rhino is compiled a s Pre-release build (Beta, WIP)
       False otherwise`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static bool IsRunningAutomated',
        summary: 'Is Rhino currently being executed through automation',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static bool IsRunningHeadless',
        summary: 'Is Rhino currently being executed in headless mode',
        since: 6.1,
        property: ['get']
      },
      {
        signature: 'static bool IsSkinned',
        summary: 'Is Rhino currently using custom, user-interface Skin.',
        since: 6.2,
        property: ['get']
      },
      {
        signature: 'static bool LicenseExpires',
        summary: `Returns 
       True if the license will expire
       False otherwise`,
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'static string LicenseUserName',
        summary: 'Gets the name of the user that owns the license or lease.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static string LicenseUserOrganization',
        summary: 'Gets the name of the organization of the user that owns the license or lease.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Image LoggedInUserAvatar',
        summary: `Returns the logged in user's avatar picture. 
     Returns a default avatar if the user does not have an avatar or if the avatar could not be fetched.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static string LoggedInUserName',
        summary: 'Returns the name of the logged in user, or None if the user is not logged in.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static RhinoWindow MainApplicationWindow',
        summary: 'Same as MainWindow function, but provides the concrete class instead of an interface',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static string Name',
        summary: 'Gets the application name.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static LicenseNode NodeType',
        summary: 'Gets license the node type.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Guid Rhino2Id',
        summary: 'Gets the ID of Rhino 2.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Guid Rhino3Id',
        summary: 'Gets the ID of Rhino 3.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Guid Rhino4Id',
        summary: 'Gets the ID of Rhino 4.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Guid Rhino5Id',
        summary: 'Gets the ID of Rhino 5.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Guid Rhino6Id',
        summary: 'Gets the ID of Rhino 6.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'static string SchemeName',
        summary: 'Gets the current Registry scheme name.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static int SdkServiceRelease',
        summary: `Rhino SDK 9 digit SDK service release number in the form YYYYMMDDn
    
    Service service release of the Rhino SDK supported by this executable. Rhino will only
    load plug-ins that require a service release of <= this release number.
    For example, SR1 will load all plug-ins made with any SDK released up through and including
    the SR1 SDK. But, SR1 will not load a plug-in built using the SR2 SDK. If an "old" Rhino
    tries to load a "new" plug-in, the user is told that they have to get a free Rhino.exe
    update in order for the plug-in to load. Rhino.exe updates are available from http://www.rhino3d.com.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'static int SdkVersion',
        summary: `Rhino SDK 9 digit SDK version number in the form YYYYMMDDn
    
    Rhino will only load plug-ins that were build with exactly the
    same version of the SDK.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'static string SerialNumber',
        summary: 'Gets the product serial number, as seen in Rhino\'s ABOUT dialog box.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static ToolbarFileCollection ToolbarFiles',
        summary: 'Collection of currently open toolbar files in the application',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static int UpdatesAndStatisticsStatus',
        summary: 'Returns True when Rhino is allowed to access the internet, False otherwise',
        since: 6.15,
        property: ['get']
      },
      {
        signature: 'static bool UserIsLoggedIn',
        summary: `Returns True if the user is logged in; else returns false.
     A logged in user does not guarantee that the auth tokens managed by the CloudZooManager instance are valid.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static int ValidationGracePeriodDaysLeft',
        summary: `Returns number of days within which validation must occur. Zero when
       validation grace period has expired.
     Raises InvalidLicenseTypeException if LicenseType is one of:
       EvaluationSaveLimited
       EvaluationTimeLimited
       Viewer
       Unknown`,
        since: 5.6,
        property: ['get']
      },
      {
        signature: 'static Version Version',
        summary: 'File version of the main Rhino process',
        since: 5.9,
        property: ['get']
      },
      {
        signature: 'static string VersionControlRevision',
        summary: `McNeel version control revision identifier at the time this version
     of Rhino was built.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static bool AskUserForRhinoLicense(bool standAlone,object parentWindow)',
        summary: 'Display UI asking the user to enter a license for Rhino or use one from the Zoo.',
        since: 6,
        parameters: [
          {
            name: 'standAlone',
            summary: 'True to ask for a stand-alone license, False to ask the user for a license from the Zoo'
          },
          {
            name: 'parentWindow',
            summary: 'Parent window for the user interface dialog.'
          }
        ]
      },
      {
        signature: 'static string[] CapturedCommandWindowStrings(bool clearBuffer)',
        summary: `Get list of strings sent to the command window through calls to Write or WriteLine
     when capturing has been enabled`,
        since: 7,
        parameters: [
          {
            name: 'clearBuffer',
            summary: 'Clear the captured buffer after this call'
          }
        ],
        returns: 'array of captured strings'
      },
      {
        signature: 'static bool ChangeLicenseKey(Guid pluginId)',
        summary: 'Display UI asking the user to enter a license for the product specified by licenseId.',
        since: 6,
        parameters: [
          {
            name: 'pluginId',
            summary: 'Guid identifying the plugin that is requesting a change of license key'
          }
        ],
        returns: 'True on success, False otherwise'
      },
      {
        signature: 'static void ClearCommandHistoryWindow()',
        summary: 'Clear the text in Rhino\'s command history window.',
        since: 5
      },
      {
        signature: 'static void DisableContinuousMainLoop()',
        summary: `This function makes it so that Rhino's main loop is not executed continuously.
     This is default behavior.`,
        since: 7
      },
      {
        signature: 'static bool EnableContinuousMainLoop()',
        summary: `This function makes it so that Rhino's main loop is executed continuously.
     This is useful when Rhino needs to be doing something as often as possible, 
     such as rendering a view at interactive frame rates.`,
        since: 7,
        returns: 'True if the functionality was enabled successfully, False otherwise.'
      },
      {
        signature: 'static Commands.Result ExecuteCommand(RhinoDoc document,string commandName)',
        summary: 'Execute a Rhino command.',
        since: 6,
        parameters: [
          {
            name: 'document',
            summary: 'Document to execute the command for'
          },
          {
            name: 'commandName',
            summary: 'Name of command to run.  Use command\'s localized name or preface with an underscore.'
          }
        ],
        returns: 'Returns the reult of the command.'
      },
      {
        signature: 'static void Exit()',
        summary: 'Exits, or closes, Rhino.',
        since: 5
      },
      {
        signature: 'static string GetDataDirectory(bool localUser,bool forceDirectoryCreation)',
        summary: 'Gets the data directory.',
        since: 6,
        parameters: [
          {
            name: 'localUser',
            summary: 'If set to true local user.'
          },
          {
            name: 'forceDirectoryCreation',
            summary: 'If set to true force directory creation.'
          }
        ],
        returns: 'The data directory.'
      },
      {
        signature: 'static string GetDataDirectory(bool localUser,bool forceDirectoryCreation,string subDirectory)',
        summary: 'Gets the data directory.',
        since: 6,
        parameters: [
          {
            name: 'localUser',
            summary: 'If set to true local user.'
          },
          {
            name: 'forceDirectoryCreation',
            summary: 'If set to true force directory creation.'
          },
          {
            name: 'subDirectory',
            summary: `Sub directory, will get appended to the end of the data directory.  if forceDirectoryCreation
     is True then this directory will get created and writable.`
          }
        ],
        returns: 'The data directory.'
      },
      {
        signature: 'static System.IO.DirectoryInfo GetExecutableDirectory()',
        summary: 'directory',
        since: 6.7
      },
      {
        signature: 'static object GetPlugInObject(Guid pluginId)',
        summary: `Gets the object that is returned by PlugIn.GetPlugInObject for a given
     plug-in. This function attempts to find and load a plug-in with a given Id.
     When a plug-in is found, it's GetPlugInObject function is called and the
     result is returned here.
     Note the plug-in must have already been installed in Rhino or the plug-in manager
     will not know where to look for a plug-in with a matching id.`,
        since: 5,
        parameters: [
          {
            name: 'pluginId',
            summary: 'Guid for a given plug-in.'
          }
        ],
        returns: 'Result of PlugIn.GetPlugInObject for a given plug-in on success.'
      },
      {
        signature: 'static object GetPlugInObject(string plugin)',
        summary: `Gets the object that is returned by PlugIn.GetPlugInObject for a given
     plug-in. This function attempts to find and load a plug-in with a given name.
     When a plug-in is found, it's GetPlugInObject function is called and the
     result is returned here.
     Note the plug-in must have already been installed in Rhino or the plug-in manager
     will not know where to look for a plug-in with a matching name.`,
        since: 5,
        parameters: [
          {
            name: 'plugin',
            summary: 'Name of a plug-in.'
          }
        ],
        returns: 'Result of PlugIn.GetPlugInObject for a given plug-in on success.'
      },
      {
        signature: 'static bool InFullScreen()',
        summary: 'Verifies that Rhino is running in full screen mode.',
        since: 6,
        returns: 'True if Rhino is running full screen, False otherwise.'
      },
      {
        signature: 'static void InvokeAndWait(Action action)',
        summary: 'Work-In-Progess. Testing this with our unit test framework',
        since: 6
      },
      {
        signature: 'static void InvokeOnUiThread(Delegate method,object[] args)',
        summary: 'Execute a function on the main UI thread.',
        since: 6,
        parameters: [
          {
            name: 'method',
            summary: 'function to execute'
          },
          {
            name: 'args',
            summary: 'parameters to pass to the function'
          }
        ]
      },
      {
        signature: 'static bool IsInstallationBeta(Installation licenseType)',
        summary: `If licenseType is a beta license, returns true. A beta license grants
     full use of the product during the pre-release development period.`,
        since: 5.6,
        returns: 'True if licenseType is a beta license. False otherwise'
      },
      {
        signature: 'static bool IsInstallationCommercial(Installation licenseType)',
        summary: `If licenseType is a commercial license, returns true. A commercial license grants
     full use of the product.`,
        since: 5.6,
        returns: 'True if licenseType is a commercial license. False otherwise'
      },
      {
        signature: 'static bool IsInstallationEvaluation(Installation licenseType)',
        summary: `If licenseType is an evaluation license, returns true. An evaluation license limits the ability of
     Rhino to save based on either the number of saves or a fixed period of time.`,
        since: 5.6,
        returns: 'True if licenseType is an evaluation license. False otherwise'
      },
      {
        signature: 'static bool LoginToCloudZoo()',
        summary: 'Logs in to the cloud zoo.',
        since: 6
      },
      {
        signature: 'static System.Windows.Forms.IWin32Window MainWindow()',
        summary: 'Main Rhino Window',
        since: 5
      },
      {
        signature: 'static IntPtr MainWindowHandle()',
        summary: 'Gets the HWND of the Rhino main window.',
        since: 5
      },
      {
        signature: 'static void OutputDebugString(string str)',
        summary: `Print a string to the Visual Studio Output window, if a debugger is attached.
    
     Note that the developer needs to add a newline manually if the next output should
     come on a separate line.`,
        since: 6,
        parameters: [
          {
            name: 'str',
            summary: 'The string to print to the Output window.'
          }
        ]
      },
      {
        signature: 'static string ParseTextField(string formula,RhinoObject obj,RhinoObject topParentObject)',
        since: 6
      },
      {
        signature: 'static bool RefreshRhinoLicense()',
        summary: 'Refresh the license used by Rhino. This allows any part of Rhino to ensure that the most current version of the license file on disk is in use.',
        since: 6
      },
      {
        signature: 'static bool ReleaseMouseCapture()',
        summary: 'Releases the mouse capture.',
        since: 5
      },
      {
        signature: 'static bool RunMenuScript(string script)',
        summary: 'Run a Rhino menu item script.  Will add the selected menu string to the MRU command menu.',
        since: 6,
        parameters: [
          {
            name: 'script',
            summary: '[in] script to run.'
          }
        ]
      },
      {
        signature: 'static bool RunningInRdp()',
        summary: 'Find out if Rhino is running in a remote session',
        since: 6,
        returns: 'True if Rhino is running in a RDP session, False otherwise'
      },
      {
        signature: 'static bool RunningOnVMWare()',
        summary: 'Verifies that Rhino is running on VMWare',
        since: 6,
        returns: 'True if Rhino is running in Windows on VMWare, False otherwise'
      },
      {
        signature: 'static bool RunScript(string script,bool echo)',
        summary: 'Runs a Rhino command script.',
        since: 5,
        parameters: [
          {
            name: 'script',
            summary: '[in] script to run.'
          },
          {
            name: 'echo',
            summary: `Controls how the script is echoed in the command output window.
     False = silent - nothing is echoed.
     True = verbatim - the script is echoed literally.`
          }
        ]
      },
      {
        signature: 'static bool RunScript(string script,string mruDisplayString,bool echo)',
        summary: 'Runs a Rhino command script.',
        since: 5,
        parameters: [
          {
            name: 'script',
            summary: '[in] script to run.'
          },
          {
            name: 'mruDisplayString',
            summary: '[in] String to display in the most recent command list.'
          },
          {
            name: 'echo',
            summary: `Controls how the script is echoed in the command output window.
     False = silent - nothing is echoed.
     True = verbatim - the script is echoed literally.`
          }
        ]
      },
      {
        signature: 'static void SendKeystrokes(string characters,bool appendReturn)',
        summary: 'Sends a string of printable characters, including spaces, to Rhino\'s command line.',
        since: 5,
        parameters: [
          {
            name: 'characters',
            summary: '[in] A string to characters to send to the command line. This can be null.'
          },
          {
            name: 'appendReturn',
            summary: '[in] Append a return character to the end of the string.'
          }
        ]
      },
      {
        signature: 'static void SetCommandPrompt(string prompt)',
        summary: 'Set Rhino command prompt.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'The new prompt text.'
          }
        ]
      },
      {
        signature: 'static void SetCommandPrompt(string prompt,string promptDefault)',
        summary: 'Sets the command prompt in Rhino.',
        since: 5,
        parameters: [
          {
            name: 'prompt',
            summary: 'The new prompt text.'
          },
          {
            name: 'promptDefault',
            summary: 'Text that appears in angle brackets and indicates what will happen if the user pressed ENTER.'
          }
        ]
      },
      {
        signature: 'static void SetCommandPromptMessage(string prompt)',
        summary: `Set the text that appears in the Rhino command prompt.
     In general, you should use the SetCommandPrompt functions. 
     In rare cases, like worker thread messages, the message that 
     appears in the prompt has non-standard formatting. In these 
     rare cases, SetCommandPromptMessage can be used to literally 
     specify the text that appears in the command prompt window.`,
        since: 6,
        parameters: [
          {
            name: 'prompt',
            summary: 'A literal text for the command prompt window.'
          }
        ]
      },
      {
        signature: 'static void SetFocusToMainWindow()',
        summary: `Sets the focus to the main window. This function attempts to use the
     ActiveDoc on Mac to figure out which window to set focus to.`,
        since: 5
      },
      {
        signature: 'static void SetFocusToMainWindow(RhinoDoc doc)',
        summary: 'Sets the focus to the main windows for a given document',
        since: 6.16,
        parameters: [
          {
            name: 'doc',
            summary: 'the document to use for determing a "main window"'
          }
        ]
      },
      {
        signature: 'static void Wait()',
        summary: `Pauses to keep Windows message pump alive so views will update
     and windows will repaint.`,
        since: 5
      },
      {
        signature: 'static void Write(string message)',
        summary: 'Print formatted text in the command window.',
        since: 5
      },
      {
        signature: 'static void Write(string format,object arg0)',
        summary: 'Print formatted text in the command window.',
        since: 5
      },
      {
        signature: 'static void Write(string format,object arg0,object arg1)',
        summary: 'Print formatted text in the command window.',
        since: 5
      },
      {
        signature: 'static void Write(string format,object arg0,object arg1,object arg2)',
        summary: 'Print formatted text in the command window.',
        since: 5
      },
      {
        signature: 'static void WriteLine()',
        summary: 'Print a newline in the command window.',
        since: 5
      },
      {
        signature: 'static void WriteLine(string message)',
        summary: 'Print text in the command window.',
        since: 5
      },
      {
        signature: 'static void WriteLine(string format,object arg0)',
        summary: 'Print formatted text with a newline in the command window.',
        since: 5
      },
      {
        signature: 'static void WriteLine(string format,object arg0,object arg1)',
        summary: 'Print formatted text with a newline in the command window.',
        since: 5
      },
      {
        signature: 'static void WriteLine(string format,object arg0,object arg1,object arg2)',
        summary: 'Print formatted text with a newline in the command window.',
        since: 5
      }
    ],
    events: [
      {
        signature: 'static AppSettingsChanged',
        summary: 'Is raised when settings are changed.',
        since: 5
      },
      {
        signature: 'static Closing',
        summary: 'Is raised when the application is about to close.',
        since: 5
      },
      {
        signature: 'static EscapeKeyPressed',
        summary: 'Can add or removed delegates that are raised when the escape key is clicked.',
        since: 5
      },
      {
        signature: 'static Idle',
        summary: 'Occurs when the application finishes processing and is about to enter the idle state',
        since: 5.1
      },
      {
        signature: 'static Initialized',
        summary: 'Is raised when the apllication is fully initialized.',
        since: 5
      },
      {
        signature: 'static KeyboardEvent',
        summary: 'Can add or removed delegates that are raised by a keyboard event.',
        since: 5.2
      },
      {
        signature: 'static MainLoop',
        summary: 'Gets called every loop iteration inside Rhino\'s main message loop.',
        since: 7
      },
      {
        signature: 'static RdkCacheImageChanged',
        summary: 'Monitors when the RDK thumbnail cache images are changed.',
        since: 5.1
      },
      {
        signature: 'static RdkGlobalSettingsChanged',
        summary: 'Monitors when RDK global settings are modified.',
        since: 5.1
      },
      {
        signature: 'static RdkNewDocument',
        summary: 'Monitors when RDK document information is rebuilt.',
        since: 5.1
      },
      {
        signature: 'static RdkPlugInUnloading',
        summary: 'Monitors when RDK client plugins are unloaded.',
        since: 5.1
      },
      {
        signature: 'static RdkUpdateAllPreviews',
        summary: 'Monitors when RDK thumbnails are updated.',
        since: 5.1
      },
      {
        signature: 'static RendererChanged',
        summary: 'Monitors when Rhino\'s current renderer changes.',
        since: 5.1
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'RhinoApp.CommandLineTextWriter',
    dataType: 1,
    summary: 'Provides a text writer that writes to the command line.',
    baseclass: 'System.IO.TextWriter',
    properties: [
      {
        signature: 'Encoding Encoding',
        summary: 'Returns Encoding Unicode.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Write(char value)',
        summary: 'Writes a char to the command line.',
        since: 6
      },
      {
        signature: 'void Write(char[] buffer,int index,int count)',
        summary: 'Writes a char buffer to the command line.',
        since: 6
      },
      {
        signature: 'void write(string str)',
        summary: 'Provided to give a simple way to IronPython to call this class.',
        since: 6,
        parameters: [
          {
            name: 'str',
            summary: 'The text.'
          }
        ]
      },
      {
        signature: 'void Write(string value)',
        summary: 'Writes a string to the command line.',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'RhinoDoc',
    dataType: 1,
    summary: 'Represents an active model.',
    interfaces: ['IDisposable'],
    properties: [
      {
        signature: 'static RhinoDoc ActiveDoc',
        summary: `WARNING!! Do not use the ActiveDoc if you don't have to. Under Mac Rhino the ActiveDoc
     can change while a command is running. Use the doc that is passed to you in your RunCommand
     function or continue to use the same doc after the first call to ActiveDoc.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'AnimationProperties AnimationProperties',
        since: 6.11,
        property: ['get', 'set']
      },
      {
        signature: 'BitmapTable Bitmaps',
        summary: 'bitmaps used in textures, backgrounds, wallpapers, ...',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ICurrentEnvironment CurrentEnvironment',
        summary: 'Access to the current environment for various uses',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint CurrentUndoRecordSerialNumber',
        summary: `>0: undo recording is active and being saved on the undo record with
         the specified serial number.
     0: undo recording is not active. (Disabled or nothing is being
        recorded.)`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'Size> CustomRenderSizes',
        since: 6,
        property: ['get']
      },
      {
        signature: 'DateTime DateCreated',
        since: 5,
        property: ['get']
      },
      {
        signature: 'DateTime DateLastEdited',
        since: 5,
        property: ['get']
      },
      {
        signature: 'DimStyleTable DimStyles',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int DistanceDisplayPrecision',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int DocumentId',
        summary: 'Gets the Document Id.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'EarthAnchorPoint EarthAnchorPoint',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'FontTable Fonts',
        since: 5,
        property: ['get']
      },
      {
        signature: 'GroundPlane GroundPlane',
        summary: 'Gets the ground plane of this document.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'GroupTable Groups',
        since: 5,
        property: ['get']
      },
      {
        signature: 'HatchPatternTable HatchPatterns',
        since: 5,
        property: ['get']
      },
      {
        signature: 'InstanceDefinitionTable InstanceDefinitions',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsAvailable',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsClosing',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsCommandRunning',
        summary: 'Returns True if Rhino is currently running a command.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'bool IsCreating',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsHeadless',
        since: 7,
        property: ['get']
      },
      {
        signature: 'bool IsInitializing',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsLocked',
        summary: `Check to see if the file associated with this document is locked.  If it is
     locked then this is the only document that will be able to write the file.  Other
     instances of Rhino will fail to write this document.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsOpening',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool IsReadOnly',
        summary: `Current read-only mode for this document.
     True if the document can be viewed but NOT saved.
     False if document can be viewed and saved.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsSendingMail',
        summary: 'True if Rhino is in the process of sending this document as an email attachment.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'LayerTable Layers',
        summary: 'Layers in the document.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool LayoutSpaceAnnotationScalingEnabled',
        summary: `If LayoutSpaceAnnotationScaling is on, sizes in dimstyles are multiplied by 
     dimscale when the annotation is displayed in a detail viewport not in a detail`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'LightTable Lights',
        since: 5,
        property: ['get']
      },
      {
        signature: 'LinetypeTable Linetypes',
        summary: 'Linetypes in the document.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ManifestTable Manifest',
        since: 6,
        property: ['get']
      },
      {
        signature: 'MaterialTable Materials',
        summary: 'Materials in the document.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'MeshingParameterStyle MeshingParameterStyle',
        summary: 'Type of MeshingParameters currently used by the document to mesh objects',
        since: 5.1,
        property: ['get', 'set']
      },
      {
        signature: 'double ModelAbsoluteTolerance',
        summary: 'Model space absolute tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double ModelAngleToleranceDegrees',
        summary: 'Model space angle tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double ModelAngleToleranceRadians',
        summary: 'Model space angle tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Point3d ModelBasepoint',
        summary: `The base point in the model that is used when inserting the model into another as a block definition.
     By default the base point in any model is 0,0,0.`,
        since: 6.1,
        property: ['get', 'set']
      },
      {
        signature: 'int ModelDistanceDisplayPrecision',
        since: 5.8,
        property: ['get', 'set']
      },
      {
        signature: 'double ModelRelativeTolerance',
        summary: 'Model space relative tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ModelSpaceAnnotationScalingEnabled',
        summary: `If ModelSpaceAnnotationScaling is on, sizes in dimstyles are multiplied by 
     dimscale when the annotation is displayed in a model space viewport not in a detail`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'double ModelSpaceHatchScale',
        summary: 'The scale factor for hatches in model space when Hatch Scaling is enabled',
        since: 6.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool ModelSpaceHatchScalingEnabled',
        summary: 'True if hatch scaling is enabled, False if not.',
        since: 6.16,
        property: ['get', 'set']
      },
      {
        signature: 'double ModelSpaceTextScale',
        summary: 'The scale factor for text in model space when Annotation Scaling is enabled',
        since: 6.1,
        property: ['get', 'set']
      },
      {
        signature: 'UnitSystem ModelUnitSystem',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool Modified',
        summary: 'Returns or sets the document\'s modified flag.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Name',
        summary: 'Returns the name of the currently loaded Rhino document (3DM file).',
        since: 5,
        property: ['get']
      },
      {
        signature: 'NamedConstructionPlaneTable NamedConstructionPlanes',
        summary: 'Collection of named construction planes.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'NamedLayerStateTable NamedLayerStates',
        summary: 'Collection of named layer states.',
        since: 6.14,
        property: ['get']
      },
      {
        signature: 'NamedPositionTable NamedPositions',
        summary: 'Collection of named positions.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'NamedViewTable NamedViews',
        summary: 'Collection of named views.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'uint NextUndoRecordSerialNumber',
        summary: `The serial number that will be assigned to the next undo record that is
     constructed.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Notes',
        summary: 'Returns or sets the document\'s notes.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'ObjectTable Objects',
        since: 5,
        property: ['get']
      },
      {
        signature: 'double PageAbsoluteTolerance',
        summary: 'Page space absolute tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PageAngleToleranceDegrees',
        summary: 'Page space angle tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'double PageAngleToleranceRadians',
        summary: 'Page space angle tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int PageDistanceDisplayPrecision',
        since: 5.8,
        property: ['get', 'set']
      },
      {
        signature: 'double PageRelativeTolerance',
        summary: 'Page space relative tolerance.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'UnitSystem PageUnitSystem',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Path',
        summary: 'Returns the path of the currently loaded Rhino document (3DM file).',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool RedoActive',
        summary: 'Returns True if Redo is currently active.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RenderEnvironmentTable RenderEnvironments',
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'RenderMaterialTable RenderMaterials',
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'RenderSettings RenderSettings',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'RenderTextureTable RenderTextures',
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'RuntimeDocumentDataTable RuntimeData',
        summary: `Collection of document runtime data. This is a good place to
     put non-serializable, per document data, such as panel view models.  
     Note well: This data will be dispose with the document and does not
     get serailzed.`,
        since: 6.3,
        property: ['get']
      },
      {
        signature: 'uint RuntimeSerialNumber',
        summary: `Unique serialNumber for the document while the application is running.
     This is not a persistent value.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'SnapshotTable Snapshots',
        summary: 'Collection of snapshots.',
        since: 6.7,
        property: ['get']
      },
      {
        signature: 'StringTable Strings',
        summary: 'Collection of document user data strings in this document',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string TemplateFileUsed',
        summary: `name of the template file used to create this document. This is a runtime value
     only present if the document was newly created.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool UndoActive',
        summary: 'Returns True if Undo is currently active.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool UndoRecordingEnabled',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool UndoRecordingIsActive',
        summary: 'True if undo recording is actually happening now.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ViewTable Views',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Worksession Worksession',
        summary: 'Provides access to the document\'s worksession.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static RhinoDoc Create(string modelTemplateFileName)',
        summary: 'Creates a new RhinoDoc',
        since: 6.4,
        parameters: [
          {
            name: 'modelTemplateFileName',
            summary: `Name of a Rhino model to use as a template to initialize the document.
     If the template contains views, those views are created.
     If null, an empty document with no views is created`
          }
        ]
      },
      {
        signature: 'static RhinoDoc CreateHeadless(string file3dmTemplatePath)',
        summary: 'Create a new headless RhinoDoc from a template file',
        since: 7,
        parameters: [
          {
            name: 'file3dmTemplatePath',
            summary: `Name of a Rhino model to use as a template to initialize the document.
     If null, an empty document is created`
          }
        ],
        returns: `New RhinoDoc on success. Note that this is a "headless" RhinoDoc and it's
     lifetime is under your control.`
      },
      {
        signature: 'static System.Drawing.Bitmap ExtractPreviewImage(string path)',
        summary: 'Extracts the bitmap preview image from the specified model (3DM).',
        since: 5,
        parameters: [
          {
            name: 'path',
            summary: `The model (3DM) from which to extract the preview image.
    If null, the currently loaded model is used.`
          }
        ],
        returns: 'True on success.'
      },
      {
        signature: 'static RhinoDoc FromFilePath(string filePath)',
        summary: `Search the open document list for a document with a Path equal
     to the specified file path.`,
        since: 6,
        parameters: [
          {
            name: 'filePath',
            summary: 'The full path to the file to search for.'
          }
        ],
        returns: 'The file name to search for'
      },
      {
        signature: 'static RhinoDoc FromId(int docId)',
        since: 5
      },
      {
        signature: 'static RhinoDoc FromRuntimeSerialNumber(uint serialNumber)',
        since: 6
      },
      {
        signature: 'static RhinoDoc Load(string file3dmPath)',
        summary: `Loads a 3DM file into a new headless RhinoDoc. Load is different than New in that
     load sets the document path`,
        since: 7,
        parameters: [
          {
            name: 'file3dmPath',
            summary: 'Path of a Rhino model to load.'
          }
        ]
      },
      {
        signature: 'static RhinoDoc New(string file3dmTemplatePath)',
        summary: 'Create a new headless RhinoDoc from a template file',
        since: 7,
        parameters: [
          {
            name: 'file3dmTemplatePath',
            summary: `Name of a Rhino model to use as a template to initialize the document.
     If null, an empty document is created`
          }
        ],
        returns: `New RhinoDoc on success. Note that this is a "headless" RhinoDoc and it's
     lifetime is under your control.`
      },
      {
        signature: 'static RhinoDoc Open(string filePath,bool wasAlreadyOpen)',
        summary: `Opens a 3dm file and makes it the active document. If called on
     windows the active document will be saved and closed and the new
     document will be opened and become the active document.  If called
     on the Mac the file will be opened in a new document window.`,
        since: 6,
        parameters: [
          {
            name: 'filePath',
            summary: 'Full path to the 3dm file to open'
          },
          {
            name: 'wasAlreadyOpen',
            summary: `Will get set to True if there is a currently open document with the
     specified path; otherwise it will get set to false.`
          }
        ],
        returns: 'Returns the newly opened document on success or None on error.'
      },
      {
        signature: 'static RhinoDoc[] OpenDocuments()',
        summary: 'Returns a list of currently open Rhino documents',
        since: 6
      },
      {
        signature: 'static bool OpenFile(string path)',
        since: 5
      },
      {
        signature: 'static RhinoDoc OpenHeadless(string file3dmPath)',
        summary: 'Opens a 3DM file into a new headless RhinoDoc.',
        since: 7,
        parameters: [
          {
            name: 'file3dmPath',
            summary: 'Path of a Rhino model to load.'
          }
        ]
      },
      {
        signature: 'static bool ReadFile(string path,FileReadOptions options)',
        since: 5
      },
      {
        signature: 'bool AddCustomUndoEvent(string description,EventHandler<CustomUndoEventArgs> handler)',
        since: 5
      },
      {
        signature: 'bool AddCustomUndoEvent(string description,EventHandler<CustomUndoEventArgs> handler,object tag)',
        summary: `Add a custom undo event so you can undo private plug-in data
     when the user performs an undo or redo`,
        since: 5
      },
      {
        signature: 'void AdjustModelUnitSystem(UnitSystem newUnitSystem,bool scale)',
        since: 5
      },
      {
        signature: 'void AdjustPageUnitSystem(UnitSystem newUnitSystem,bool scale)',
        since: 5
      },
      {
        signature: 'uint BeginUndoRecord(string description)',
        summary: `Instructs Rhino to begin recording undo information when the document
     is changed outside of a command. We use this, e.g., to save changes
     caused by the modeless layer or object properties dialogs
     when commands are not running.`,
        since: 5,
        parameters: [
          {
            name: 'description',
            summary: 'A text describing the record.'
          }
        ],
        returns: `Serial number of record.  Returns 0 if record is not started
     because undo information is already being recorded or
     undo is disabled.`
      },
      {
        signature: 'void ClearRedoRecords()',
        since: 5
      },
      {
        signature: 'void ClearUndoRecords(bool purgeDeletedObjects)',
        since: 5
      },
      {
        signature: 'void ClearUndoRecords(uint undoSerialNumber,bool purgeDeletedObjects)',
        since: 6
      },
      {
        signature: 'DocObjects.ObjectAttributes CreateDefaultAttributes()',
        summary: `Gets the default object attributes for this document. 
     The attributes will be linked to the currently active layer 
     and they will inherit the Document WireDensity setting.`,
        since: 5
      },
      {
        signature: 'void Dispose()',
        since: 7
      },
      {
        signature: 'bool EndUndoRecord(uint undoRecordSerialNumber)',
        summary: 'Ends the undo record.',
        since: 5,
        parameters: [
          {
            name: 'undoRecordSerialNumber',
            summary: 'The serial number of the undo record.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'bool Equals(object obj)'
      },
      {
        signature: 'bool Export(string filePath)',
        summary: `Export the entire document to a file. All file formats that Rhino can export to
     are supported by this function.`,
        since: 7,
        returns: 'True on success'
      },
      {
        signature: 'bool ExportSelected(string filePath)',
        summary: `Export selected geometry to a file. All file formats that Rhino can export
     to are supported by this function.`,
        since: 7,
        returns: 'True on success'
      },
      {
        signature: 'string FindFile(string filename)',
        summary: `Search for a file using Rhino's search path.  Rhino will look in the
     following places:
     1. Current model folder
     2. Path specified in options dialog/File tab
     3. Rhino system folders
     4. Rhino executable folder`,
        since: 5,
        returns: 'Path to existing file if found, an empty string if no file was found'
      },
      {
        signature: 'MeshingParameters GetAnalysisMeshingParameters()',
        summary: 'Get analysis meshing parameters currently used by the document',
        since: 6
      },
      {
        signature: 'MeshingParameters GetCurrentMeshingParameters()',
        summary: 'Get the custom meshing parameters that this document will use.',
        since: 6
      },
      {
        signature: 'string[] GetEmbeddedFilesList(bool missingOnly)',
        since: 6
      },
      {
        signature: 'bool GetGumballPlane(Plane plane)',
        summary: `Returns the active plane of Rhino's auto-gumball widget.
     Note, when calling from a Rhino command, make sure the command 
     class has the Rhino.Commands.Style.Transparent command style attribute.`,
        since: 6,
        parameters: [
          {
            name: 'plane',
            summary: 'The active plane.'
          }
        ],
        returns: 'True if the auto-gumball widget is enabled and visible. False otherwise.'
      },
      {
        signature: 'int GetHashCode()'
      },
      {
        signature: 'MeshingParameters GetMeshingParameters(MeshingParameterStyle style)',
        summary: 'Get MeshingParameters currently used by the document',
        since: 5.1
      },
      {
        signature: 'RenderPrimitiveList GetRenderPrimitiveList(ViewportInfo viewport,DisplayPipelineAttributes attrs)',
        summary: 'Build custom render mesh(es) for this document (ie - GH meshes).',
        since: 6.9,
        parameters: [
          {
            name: 'viewport',
            summary: 'The viewport being rendered.'
          },
          {
            name: 'attrs',
            summary: 'Attributes for the view mode you are supplying meshes for.  Will be None if this is a modal rendering.'
          }
        ],
        returns: 'Returns a RenderPrimitiveList if successful otherwise returns null.'
      },
      {
        signature: 'IEnumerable<RenderPrimitive> GetRenderPrimitives(bool forceTriangleMeshes,bool quietly)',
        summary: 'Get a enumerable list of custom mesh primitives',
        since: 6,
        parameters: [
          {
            name: 'forceTriangleMeshes',
            summary: 'If True all mesh faces will be triangulated'
          },
          {
            name: 'quietly',
            summary: 'Iterate quietly, if True then no user interface will be displayed'
          }
        ]
      },
      {
        signature: 'IEnumerable<RenderPrimitive> GetRenderPrimitives(Guid plugInId,ViewportInfo viewport,bool forceTriangleMeshes,bool quietly)',
        summary: 'Get a enumerable list of custom mesh primitives',
        since: 6,
        parameters: [
          {
            name: 'plugInId',
            summary: 'The Id of the plug-in creating the iterator.'
          },
          {
            name: 'viewport',
            summary: 'The rendering view camera.'
          },
          {
            name: 'forceTriangleMeshes',
            summary: 'If True all mesh faces will be triangulated'
          },
          {
            name: 'quietly',
            summary: 'Iterate quietly, if True then no user interface will be displayed'
          }
        ]
      },
      {
        signature: 'IEnumerable<RenderPrimitive> GetRenderPrimitives(ViewportInfo viewport,bool forceTriangleMeshes,bool quietly)',
        summary: 'Get a enumerable list of custom mesh primitives',
        since: 6,
        parameters: [
          {
            name: 'viewport',
            summary: 'The rendering view camera.'
          },
          {
            name: 'forceTriangleMeshes',
            summary: 'If True all mesh faces will be triangulated'
          },
          {
            name: 'quietly',
            summary: 'Iterate quietly, if True then no user interface will be displayed'
          }
        ]
      },
      {
        signature: 'string GetUnitSystemName(bool modelUnits,bool capitalize,bool singular,bool abbreviate)',
        since: 5
      },
      {
        signature: 'bool Import(string filePath)',
        summary: `Import geometry into a RhinoDoc from a file. This can be any file format
     that Rhino can import`,
        since: 7,
        returns: 'True on success'
      },
      {
        signature: 'int ReadFileVersion()',
        summary: `Returns the file version of the current document.  
    Use this function to determine which version of Rhino last saved the document.`,
        since: 5,
        returns: 'The file version (e.g. 1, 2, 3, 4, etc.) or -1 if the document has not been read from disk.'
      },
      {
        signature: 'bool Redo()',
        summary: 'Redo the last action that was "undone"',
        since: 6.16,
        returns: 'True on success'
      },
      {
        signature: 'bool Save()',
        summary: 'Save doc to disk using the document\'s Path',
        since: 7
      },
      {
        signature: 'bool SaveAs(string file3dmPath)',
        summary: 'Save doc as a 3dm to a specified path using the current Rhino file version',
        since: 7,
        returns: 'True on success'
      },
      {
        signature: 'bool SaveAs(string file3dmPath,int version)',
        summary: 'Save doc as a 3dm to a specified path',
        since: 7,
        parameters: [
          {
            name: 'file3dmPath',
            summary: ''
          },
          {
            name: 'version',
            summary: 'Rhino file version'
          }
        ],
        returns: 'True on success'
      },
      {
        signature: 'bool SaveAsTemplate(string file3dmTemplatePath)',
        summary: 'Save this document as a template',
        since: 7,
        returns: 'True on success'
      },
      {
        signature: 'bool SaveAsTemplate(string file3dmTemplatePath,int version)',
        summary: 'Save this document as a template to a specific Rhino file version',
        since: 7,
        returns: 'True on success'
      },
      {
        signature: 'void SetCustomMeshingParameters(MeshingParameters mp)',
        summary: `Set the custom meshing parameters that this document will use. You must also modify the
     MeshingParameterStyle property on the document to Custom if you want these meshing
     parameters to be used`,
        since: 5.1
      },
      {
        signature: 'bool SupportsRenderPrimitiveList(ViewportInfo viewport,DisplayPipelineAttributes attrs)',
        summary: 'Determines if custom render meshes will be built for this document (ie - GH meshes).',
        since: 6.9,
        parameters: [
          {
            name: 'viewport',
            summary: 'The viewport being rendered.'
          },
          {
            name: 'attrs',
            summary: `Type of mesh to build. If attrs is non-None then a smaller mesh may be
     generated in less time, False is meant when actually rendering.`
          }
        ],
        returns: 'Returns True if custom render mesh(es) will get built for this document.'
      },
      {
        signature: 'bool TryGetRenderPrimitiveBoundingBox(ViewportInfo viewport,DisplayPipelineAttributes attrs,BoundingBox boundingBox)',
        summary: `Get the bounding box for the custom render meshes associated with this
     document (ie - GH meshes).`,
        since: 6.9,
        parameters: [
          {
            name: 'viewport',
            summary: 'The viewport being rendered.'
          },
          {
            name: 'attrs',
            summary: 'Attributes for the view mode you are supplying meshes for.  Will be None if this is a modal rendering.'
          },
          {
            name: 'boundingBox',
            summary: `This will be set to BoundingBox.Unset on failure otherwise it will be
     the bounding box for the custom render meshes associated with this
     object.`
          }
        ],
        returns: `Returns True if the bounding box was successfully calculated otherwise
     returns False on error.`
      },
      {
        signature: 'bool Undo()',
        summary: 'Undo the last action',
        since: 6.16,
        returns: 'True on success'
      },
      {
        signature: 'bool Write3dmFile(string path,FileWriteOptions options)',
        summary: `Write information in this document to a .3dm file. 
     Note, the active document's name will not be changed.`,
        since: 6.5,
        parameters: [
          {
            name: 'path',
            summary: 'The name of the .3dm file to write.'
          },
          {
            name: 'options',
            summary: 'The file writing options.'
          }
        ],
        returns: 'True if successful, False on failure.'
      },
      {
        signature: 'bool WriteFile(string path,FileWriteOptions options)',
        summary: `Write information in this document to a file. 
     Note, the active document's name will be changed to that
     of the path provided.`,
        since: 5,
        parameters: [
          {
            name: 'path',
            summary: 'The name of the file to write.'
          },
          {
            name: 'options',
            summary: 'The file writing options.'
          }
        ],
        returns: 'True if successful, False on failure.'
      }
    ],
    events: [
      {
        signature: 'static ActiveDocumentChanged',
        summary: `This event is raised when the active document used by modeless user
     interface changes.  On Mac Rhino this will get raised before the
     NewDocument, BeginOpenDocument and
     EndOpenDocument events.  Mac Rhino will also raise this
     event with 0 for the document Id and a None document pointer when the
     last document is closed.  Windows Rhino will raise this event after the
     NewDocument, BeginOpenDocument and
     EndOpenDocument events when a new or existing model is
     opened.`,
        since: 6
      },
      {
        signature: 'static AddRhinoObject',
        summary: 'Called if a new object is added to the document.',
        since: 5
      },
      {
        signature: 'static BeforeTransformObjects',
        summary: 'Called before objects are being transformed',
        since: 5.1
      },
      {
        signature: 'static BeginOpenDocument',
        summary: `This event is raised when the document open operation begins.
     NOTE: On Windows, this event will be fired when a clipboard paste 
     operation occurs, as Rhino opens a .tmp file in the User's
     Local folder with the contents of the pasted document.`,
        since: 5
      },
      {
        signature: 'static BeginSaveDocument',
        since: 5
      },
      {
        signature: 'static CloseDocument',
        since: 5
      },
      {
        signature: 'static DeleteRhinoObject',
        summary: 'Called if an object is deleted. At some later point the object can be un-deleted.',
        since: 5
      },
      {
        signature: 'static DeselectAllObjects',
        summary: 'Called when all objects are deselected.',
        since: 5
      },
      {
        signature: 'static DeselectObjects',
        summary: 'Called when object(s) are deselected.',
        since: 5
      },
      {
        signature: 'static DimensionStyleTableEvent',
        summary: 'Called when any modification happens to a document\'s dimension style table.',
        since: 6
      },
      {
        signature: 'static DocumentPropertiesChanged',
        since: 5
      },
      {
        signature: 'static EndOpenDocument',
        since: 5
      },
      {
        signature: 'static EndOpenDocumentInitialiViewUpdate',
        summary: `This event is raised after EndOpenDocument when the
     documents initial views have been created and initialized.`,
        since: 5.11
      },
      {
        signature: 'static EndOpenDocumentInitialViewUpdate',
        summary: `This event is raised after EndOpenDocument when the
     documents initial views have been created and initialized.`,
        since: 6.18
      },
      {
        signature: 'static EndSaveDocument',
        since: 5
      },
      {
        signature: 'static GroupTableEvent',
        summary: 'Called when any modification happens to a document\'s group table.',
        since: 5
      },
      {
        signature: 'static InstanceDefinitionTableEvent',
        summary: 'Called when any modification happens to a document\'s light table.',
        since: 5.3
      },
      {
        signature: 'static LayerTableEvent',
        summary: 'Called when any modification happens to a document\'s layer table.',
        since: 5
      },
      {
        signature: 'static LightTableEvent',
        summary: 'Called when any modification happens to a document\'s light table.',
        since: 5.3
      },
      {
        signature: 'static MaterialTableEvent',
        summary: 'Called when any modification happens to a document\'s material table.',
        since: 5
      },
      {
        signature: 'static ModifyObjectAttributes',
        summary: 'Called when all object attributes are changed.',
        since: 5
      },
      {
        signature: 'static NewDocument',
        since: 5
      },
      {
        signature: 'static PurgeRhinoObject',
        summary: 'Called if an object is being purged from a document. The object will cease to exist forever.',
        since: 5
      },
      {
        signature: 'static RenderEnvironmentTableEvent',
        since: 5.7
      },
      {
        signature: 'static RenderMaterialsTableEvent',
        since: 5.7
      },
      {
        signature: 'static RenderTextureTableEvent',
        summary: `Called when the RenderTextureTable has been loaded, is
     about to be cleared or has been cleared.  See RenderContentTableEventType for more
     information.`,
        since: 5.7
      },
      {
        signature: 'static ReplaceRhinoObject',
        summary: `Called if an object is about to be replaced.
     If both RhinoDoc.UndoActive() and RhinoDoc.RedoActive() return false,
     then immediately after the ReplaceObject event, there will be a DeleteObject
     event followed by an AddObject event.
    
     If either RhinoDoc.UndoActive() or RhinoDoc::RedoActive() return true,
     then immediately after the ReplaceObject event, there will be a DeleteObject
     event followed by an UndeleteObject event.`,
        since: 5
      },
      {
        signature: 'static SelectObjects',
        summary: 'Called when object(s) are selected.',
        since: 5
      },
      {
        signature: 'static TextureMappingEvent',
        summary: 'Called when any modification happens to a document objects texture mapping.',
        since: 5.8
      },
      {
        signature: 'static UndeleteRhinoObject',
        summary: 'Called if an object is un-deleted.',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'RhinoDoc.RenderContentTableEventArgs',
    dataType: 1,
    summary: `Passed to the RenderMaterialsTableEvent, RenderEnvironmentTableEvent and the
     RenderTextureTableEvent events.`,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RhinoDoc Document',
        summary: 'Document the table belongs to',
        since: 5.7,
        property: ['get']
      },
      {
        signature: 'RenderContentTableEventType EventType',
        summary: 'Event type',
        since: 5.7,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'RhinoDoc.RenderContentTableEventType',
    dataType: 3,
    summary: 'Type of content table event',
    values: [
      {
        signature: 'Loaded',
        summary: 'The document has been read and the table has been loaded'
      },
      {
        signature: 'Clearing',
        summary: 'The table is about to be cleared'
      },
      {
        signature: 'Cleared',
        summary: 'The table has been cleared'
      },
      {
        signature: 'MaterialAssignmentChanged',
        summary: 'Object or layer material assignment changed'
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'RhinoDoc.RenderMaterialAssignmentChangedEventArgs',
    dataType: 1,
    baseclass: 'RenderContentTableEventArgs',
    properties: [
      {
        signature: 'bool IsLayer',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'bool IsObject',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Guid LayerId',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Guid NewRenderMaterial',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Guid ObjectId',
        since: 5.1,
        property: ['get']
      },
      {
        signature: 'Guid OldRenderMaterial',
        since: 5.1,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'RhinoDoc.TextureMappingEventArgs',
    dataType: 1,
    summary: 'Event arguments passed to the RhinoDoc.TextureMappingEvent.',
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'RhinoDoc Document',
        since: 5.8,
        property: ['get']
      },
      {
        signature: 'TextureMappingEventType EventType',
        since: 5.8,
        property: ['get']
      },
      {
        signature: 'TextureMapping NewMapping',
        since: 5.8,
        property: ['get']
      },
      {
        signature: 'TextureMapping OldMapping',
        since: 5.8,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'RhinoDoc.TextureMappingEventType',
    dataType: 3,
    values: [
      {
        signature: 'Added = UnsafeNativeMethods.RhinoEventWatcherTextureMappingEventConsts.Added',
        summary: 'Adding texture mapping to a document'
      },
      {
        signature: 'Deleted = UnsafeNativeMethods.RhinoEventWatcherTextureMappingEventConsts.Deleted',
        summary: 'A texture mapping was deleted from a document'
      },
      {
        signature: 'Undeleted = UnsafeNativeMethods.RhinoEventWatcherTextureMappingEventConsts.Undeleted',
        summary: 'A texture mapping was undeleted in a document'
      },
      {
        signature: 'Modified = UnsafeNativeMethods.RhinoEventWatcherTextureMappingEventConsts.Modified',
        summary: 'A texture mapping was modified in a document'
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'RhinoDocObserverArgs',
    dataType: 1,
    summary: 'Arguments passed to IRhinoDocObserver methods.',
    constructors: [
      {
        signature: 'RhinoDocObserverArgs(RhinoDoc doc)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'RhinoDoc Doc',
        summary: 'Document',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint RuntimeSerialNumber',
        summary: 'Document runtime serial number, will be different across Rhino sessions.',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'RhinoFileWatcherChangeReason',
    dataType: 3,
    summary: 'Passed to IRhinoFileEventWatcher::Changed when a change event is raised.',
    values: [
      {
        signature: 'Created = 1',
        summary: 'The creation of a file or folder.'
      },
      {
        signature: 'Deleted = 2',
        summary: 'The deletion of a file or folder.'
      },
      {
        signature: 'Changed = 4',
        summary: `The change of a file or folder. The types of changes include: changes to size,
   attributes, security settings, last write, and last access time.`
      },
      {
        signature: 'Renamed',
        summary: 'The renaming of a file or folder.'
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'RhinoMath',
    dataType: 1,
    summary: `Provides constants and static methods that are additional to
   System.Math.`,
    methods: [
      {
        signature: 'static double Clamp(double value,double bound1,double bound2)',
        summary: 'Restricts a double to be specified within an interval of two numbers.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'A number.'
          },
          {
            name: 'bound1',
            summary: 'A first bound.'
          },
          {
            name: 'bound2',
            summary: 'A second bound. This does not necessarily need to be larger or smaller than bound1.'
          }
        ],
        returns: 'The clamped value.'
      },
      {
        signature: 'static int Clamp(int value,int bound1,int bound2)',
        summary: 'Restricts a int to be specified within an interval of two integers.',
        since: 5,
        parameters: [
          {
            name: 'value',
            summary: 'An integer.'
          },
          {
            name: 'bound1',
            summary: 'A first bound.'
          },
          {
            name: 'bound2',
            summary: 'A second bound. This does not necessarily need to be larger or smaller than bound1.'
          }
        ],
        returns: 'The clamped value.'
      },
      {
        signature: 'static uint CRC32(uint currentRemainder,byte[] buffer)',
        summary: `Advances the cyclic redundancy check value remainder given a byte array.
     http://en.wikipedia.org/wiki/Cyclic_redundancy_check.`,
        since: 5,
        parameters: [
          {
            name: 'currentRemainder',
            summary: 'The remainder from which to start.'
          },
          {
            name: 'buffer',
            summary: 'The value to add to the current remainder.'
          }
        ],
        returns: 'The new current remainder.'
      },
      {
        signature: 'static uint CRC32(uint currentRemainder,double value)',
        summary: `Advances the cyclic redundancy check value remainder given a double.
     http://en.wikipedia.org/wiki/Cyclic_redundancy_check.`,
        since: 5,
        parameters: [
          {
            name: 'currentRemainder',
            summary: 'The remainder from which to start.'
          },
          {
            name: 'value',
            summary: 'The value to add to the current remainder.'
          }
        ],
        returns: 'The new current remainder.'
      },
      {
        signature: 'static uint CRC32(uint currentRemainder,int value)',
        summary: `Advances the cyclic redundancy check value remainder given a int.
     http://en.wikipedia.org/wiki/Cyclic_redundancy_check.`,
        since: 5,
        parameters: [
          {
            name: 'currentRemainder',
            summary: 'The remainder from which to start.'
          },
          {
            name: 'value',
            summary: 'The value to add to the current remainder.'
          }
        ],
        returns: 'The new current remainder.'
      },
      {
        signature: 'static bool EpsilonEquals(double x,double y,double epsilon)',
        summary: 'Compare two doubles for equality within some "epsilon" range',
        since: 5.4
      },
      {
        signature: 'static bool EpsilonEquals(float x,float y,float epsilon)',
        summary: 'Compare to floats for equality within some "epsilon" range',
        since: 5.4
      },
      {
        signature: 'static bool EvaluateNormal(int limitDirection,Vector3d ds,Vector3d dt,Vector3d dss,Vector3d dst,Vector3d dtt,Vector3d n)',
        summary: 'Expert tool to evaluate surface unit normal.',
        since: 7,
        parameters: [
          {
            name: 'limitDirection',
            summary: `Determines which direction is used to compute the limit, where:
     0 = default, 1 = from quadrant I, 2 = from quadrant II, etc.`
          },
          {
            name: 'ds',
            summary: 'First partial derivative.'
          },
          {
            name: 'dt',
            summary: 'First first partial derivative.'
          },
          {
            name: 'dss',
            summary: 'Second partial derivative.'
          },
          {
            name: 'dst',
            summary: 'Second partial derivative.'
          },
          {
            name: 'dtt',
            summary: 'Second partial derivative.'
          },
          {
            name: 'n',
            summary: 'Unit normal.'
          }
        ],
        returns: 'True if successful, False otherwise.'
      },
      {
        signature: 'static bool EvaluateNormalPartials(Vector3d ds,Vector3d dt,Vector3d dss,Vector3d dst,Vector3d dtt,Vector3d ns,Vector3d nt)',
        summary: 'Expert tool to evaluate partial derivatives of surface unit normal.',
        since: 7,
        parameters: [
          {
            name: 'ds',
            summary: 'First partial derivative.'
          },
          {
            name: 'dt',
            summary: 'First first partial derivative.'
          },
          {
            name: 'dss',
            summary: 'Second partial derivative.'
          },
          {
            name: 'dst',
            summary: 'Second partial derivative.'
          },
          {
            name: 'dtt',
            summary: 'Second partial derivative.'
          },
          {
            name: 'ns',
            summary: 'First partial derivative of unit normal. If the Jacobian is degenerate, ns is set to zero.'
          },
          {
            name: 'nt',
            summary: 'First partial derivative of unit normal. If the Jacobian is degenerate, nt is set to zero.'
          }
        ],
        returns: 'True if Jacobian is non-degenerate, False if Jacobian is degenerate.'
      },
      {
        signature: 'static string IntIndexToString(int index)',
        summary: 'Portrays an int index in text.',
        since: 6,
        parameters: [
          {
            name: 'index',
            summary: 'int number express as string.'
          }
        ],
        returns: 'The text representation of the int index.'
      },
      {
        signature: 'static bool IsValidDouble(double x)',
        summary: `Determines whether a double value is valid within the RhinoCommon context.
     Rhino does not use Double.NaN by convention, so this test evaluates to True if:x is not equal to RhinoMath.UnsetValueSystem.Double.IsNaN(x) evaluates to falseSystem.Double.IsInfinity(x) evaluates to false`,
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'double number to test for validity.'
          }
        ],
        returns: 'True if the number if valid, False if the number is NaN, Infinity or Unset.'
      },
      {
        signature: 'static bool IsValidSingle(float x)',
        summary: `Determines whether a float value is valid within the RhinoCommon context.
     Rhino does not use Single.NaN by convention, so this test evaluates to True if:x is not equal to RhinoMath.UnsetValue,System.Single.IsNaN(x) evaluates to falseSystem.Single.IsInfinity(x) evaluates to false`,
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'float number to test for validity.'
          }
        ],
        returns: 'True if the number if valid, False if the number is NaN, Infinity or Unset.'
      },
      {
        signature: 'static double ParseNumber(string expression)',
        summary: 'Evaluates command line math expression.',
        since: 6,
        returns: 'result'
      },
      {
        signature: 'static double ToDegrees(double radians)',
        summary: 'Convert an angle from radians to degrees.',
        since: 5,
        parameters: [
          {
            name: 'radians',
            summary: 'Radians to convert (180 degrees equals pi radians).'
          }
        ]
      },
      {
        signature: 'static double ToRadians(double degrees)',
        summary: 'Convert an angle from degrees to radians.',
        since: 5,
        parameters: [
          {
            name: 'degrees',
            summary: 'Degrees to convert (180 degrees equals pi radians).'
          }
        ]
      },
      {
        signature: 'static bool TryParseNumber(string expression,double result)',
        summary: 'Evaluates command line math expression.',
        since: 6,
        returns: 'True if successfull otherwise false'
      },
      {
        signature: 'static double UnitScale(UnitSystem from,UnitSystem to)',
        summary: 'Computes the scale factor for changing the measurements unit systems.',
        since: 5,
        parameters: [
          {
            name: 'from',
            summary: 'The system to convert from.'
          },
          {
            name: 'to',
            summary: 'The system to convert measurements into.'
          }
        ],
        returns: 'A scale multiplier.'
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'RhinoWindow',
    dataType: 1,
    summary: 'Represents the top level window in Rhino',
    baseclass: 'System.Windows.Forms.IWin32Window',
    properties: [
      {
        signature: 'IntPtr Handle',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool InvokeRequired',
        summary: 'See Control.InvokeRequired',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Invoke(Delegate method)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'AdvancedSetting',
    dataType: 3,
    summary: 'Advanced setting Id',
    values: [
      {
        signature: 'UseNewDraftAngleAnalysisUi',
        summary: `UseNewDraftAngleAnalysisUi
   bool Value, defaults to true`
      },
      {
        signature: 'UseCompressionWhenSaving',
        summary: `Use compressed buffers when saving 3dm files.
    bool Value, defults to true`
      },
      {
        signature: 'TestAdvancedString',
        summary: 'String value, defaults to "test string"'
      },
      {
        signature: 'TestAdvancedInt',
        summary: 'Integer value, defaults 123'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'Analytics',
    dataType: 1,
    summary: 'Provides tools for sending Google Analytics events using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details.',
    constructors: [
      {
        signature: 'Analytics(string TrackingID,string Name)',
        summary: 'Construct Analytics class',
        since: 6,
        parameters: [
          {
            name: 'TrackingID',
            summary: 'Google Analytics Tracking ID'
          },
          {
            name: 'Name',
            summary: 'Name of Application. For example, "Ocelot". Do not include version numbers. Maps to Google Analytics parameter \'an\''
          }
        ]
      },
      {
        signature: 'Analytics(string TrackingID,string Name,string Platform,string InstallerId,string Version)',
        summary: 'Construct Analytics class',
        since: 6,
        parameters: [
          {
            name: 'TrackingID',
            summary: 'Google Analytics Tracking ID'
          },
          {
            name: 'Name',
            summary: 'Name of Application. For example, "Ocelot". Do not include version numbers. Maps to Google Analytics parameter \'an\''
          },
          {
            name: 'Platform',
            summary: 'Platform application is running on. For example "Mac", "Windows". Again, don\'t include version numbers. Maps to Google Analytics parameter \'ai\''
          },
          {
            name: 'InstallerId',
            summary: 'App Installer Id. In Rhino, we use this to differentiate between different builds such as "WIP" and "Commercial". Maps to Google Analytics parameter \'aiid\''
          },
          {
            name: 'Version',
            summary: 'Application version string. Maps to Google Analytics parameter \'av\''
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'static bool UsageStatisticsEnabled',
        summary: 'Determine if user allows automatic data collection from Rhino',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid UserId',
        summary: `Returns a GUID that allows events to be aggregated by user. There is no way to determine who the
     end user is based on this GUID, unless the user tells you their ID.  On Windows, this uses the 
     registry to store the ID.  On Mac, the Hardware UUID is used as the ID.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'string AppInstallerId',
        summary: `App Installer Id. In Rhino, we use this to differentiate between different builds such as "WIP" and "Commercial".
     Maps to Google Analytics parameter 'aiid'`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string AppName',
        summary: `Name of Application. For example, "Ocelot". Do not include version numbers.
     Maps to Google Analytics parameter 'an'`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string AppPlatform',
        summary: `Platform application is running on. For example "Mac", "Windows". Again, don't include version numbers.
     Maps to Google Analytics parameter 'ai'`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string AppVersion',
        summary: `Application version string.
     Maps to Google Analytics parameter 'av'`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string GoogleAnalyticsTrackingID',
        summary: 'Google Analytics Tracking ID',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Send(NameValueCollection data)',
        summary: `Advanced method for sending Google Analytics data.
     It is the caller's responsibility to make sure that all parameters passed will result in a valid Google Analytics hit. Failure to do so will result in Google Analytics ignoring your hit, and the caller will get no data.
     The Analytics class will populate data from the Application, the GoogleAnalyticsTrackingID, the User ID, and set the hit type "t" to "event". It also sets other information about the system.`,
        since: 6,
        parameters: [
          {
            name: 'data',
            summary: 'Name-Value pairs of data to send. Any valid Google Analytics Measurement Protocol parameter is allowed. No input validation is performed.'
          }
        ]
      },
      {
        signature: 'void Send(string Category)',
        summary: 'Sends a Google Analytics event using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details.',
        since: 6,
        parameters: [
          {
            name: 'Category',
            summary: 'Event category. We use the feature or subsystem, such as "installer" or "app" or "document" or "loft". Maps to the Google Analytics parameter "ec".'
          }
        ]
      },
      {
        signature: 'void Send(string Category,string Action)',
        summary: 'Sends a Google Analytics event using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details.',
        since: 6,
        parameters: [
          {
            name: 'Category',
            summary: 'Event category. We use the feature or subsystem, such as "installer" or "app" or "document" or "loft". Maps to the Google Analytics parameter "ec".'
          },
          {
            name: 'Action',
            summary: 'Event action. A verb: "open" or "start" or "option" Maps to the Google Analytics parameter "ea".'
          }
        ]
      },
      {
        signature: 'void Send(string Category,string Action,string Label)',
        summary: 'Sends a Google Analytics event using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details.',
        since: 6,
        parameters: [
          {
            name: 'Category',
            summary: 'Event category. We use the feature or subsystem, such as "installer" or "app" or "document" or "loft". Maps to the Google Analytics parameter "ec".'
          },
          {
            name: 'Action',
            summary: 'Event action. A verb: "open" or "start" or "option" Maps to the Google Analytics parameter "ea".'
          },
          {
            name: 'Label',
            summary: 'Event label. Maps to the Google Analytics parameter "el".'
          }
        ]
      },
      {
        signature: 'void Send(string Category,string Action,string Label,uint Value)',
        summary: `Sends a Google Analytics event using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details.
     This method is asyncrhonous and the return code is completely ignored. Validate the data you send`,
        since: 6,
        parameters: [
          {
            name: 'Category',
            summary: 'Event category. We use the feature or subsystem, such as "installer" or "app" or "document" or "loft". Maps to the Google Analytics parameter "ec".'
          },
          {
            name: 'Action',
            summary: 'Event action. A verb: "open" or "start" or "option" Maps to the Google Analytics parameter "ea".'
          },
          {
            name: 'Label',
            summary: 'Event label. Maps to the Google Analytics parameter "el".'
          },
          {
            name: 'Value',
            summary: 'Event value. Maps to the Google Analytics parameter "ev".'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'AssemblyResolver',
    dataType: 1,
    summary: 'Assembly Resolver for the Rhino App Domain.',
    methods: [
      {
        signature: 'static void AddSearchFile(string file)',
        summary: `Register another file with the Assembly Resolver. File must be a .NET assembly, 
     so it should probably be a dll, rhp or exe.`,
        since: 5,
        parameters: [
          {
            name: 'file',
            summary: 'Path of file to include during Assembly Resolver events.'
          }
        ]
      },
      {
        signature: 'static void AddSearchFolder(string folder)',
        summary: `Register a custom folder with the Assembly Resolver. Folders will be 
     searched recursively, so this could potentially be a very expensive operation. 
     If at all possible, you should consider only registering individual files.`,
        since: 5,
        parameters: [
          {
            name: 'folder',
            summary: 'Path of folder to include during Assembly Resolver events.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'CommonObject',
    dataType: 1,
    summary: 'Base class for .NET classes that wrap C++ unmanaged Rhino classes.',
    interfaces: ['IDisposable', 'ISerializable'],
    properties: [
      {
        signature: 'static bool PerformCorruptionTesting',
        summary: 'Used to test ON_Object* pointers to see if they are a brep or mesh that is corrupt enough to crash Rhino.',
        since: 6.1,
        property: ['get', 'set']
      },
      {
        signature: 'bool Disposed',
        summary: `Indicates if this object has been disposed or the
     document it originally belonged to has been disposed.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool HasUserData',
        summary: 'Gets True if this class has any custom information attached to it through UserData.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsDocumentControlled',
        summary: `If True this object may not be modified. Any properties or functions that attempt
     to modify this object when it is set to "IsReadOnly" will throw a NotSupportedException.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsValid',
        summary: 'Tests an object to see if it is valid.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'UserDataList UserData',
        summary: 'List of custom information that is attached to this class.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'ArchivableDictionary UserDictionary',
        summary: `Dictionary of custom information attached to this class. The dictionary is actually user
     data provided as an easy to use sharable set of information.`,
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static CommonObject FromBase64String(int archive3dm,int opennurbs,string base64Data)',
        summary: `Create a CommonObject instance from a Base64 encoded string. This is typically the values
     used when passing common objects around as JSON data`,
        since: 7
      },
      {
        signature: 'static CommonObject FromJSON(Dictionary<string,string> jsonDictionary)',
        summary: 'Create a CommonObject instance from a JSON dictionary',
        since: 7
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'void EnsurePrivateCopy()',
        summary: `If you want to keep a copy of this class around by holding onto it in a variable after a command
     completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can
     call this function as many times as you want.`,
        since: 5
      },
      {
        signature: 'void GetObjectData(SerializationInfo info,StreamingContext context)',
        summary: 'Populates a System.Runtime.Serialization.SerializationInfo with the data needed to serialize the target object.',
        since: 5,
        parameters: [
          {
            name: 'info',
            summary: 'The System.Runtime.Serialization.SerializationInfo to populate with data.'
          },
          {
            name: 'context',
            summary: 'The destination (see System.Runtime.Serialization.StreamingContext) for this serialization.'
          }
        ]
      },
      {
        signature: 'bool IsValidWithLog(string log)',
        summary: `Determines if an object is valid. Also provides a report on errors if this
     object happens not to be valid.`,
        since: 5,
        parameters: [
          {
            name: 'log',
            summary: 'A textual log. This out parameter is assigned during this call.'
          }
        ],
        returns: 'True if this object is valid; False otherwise.'
      },
      {
        signature: 'string ToJSON(SerializationOptions options)',
        summary: 'Create a JSON string representation of this object',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'CorruptGeometryException',
    dataType: 1,
    summary: 'Thrown when Rhino finds a brep or mesh that will cause a crash if used for calculations.',
    baseclass: 'Exception',
    properties: [
      {
        signature: 'CommonObject CommonObject',
        summary: 'Corrupt geometry .NET class',
        since: 6.1,
        property: ['get', 'set']
      },
      {
        signature: 'IntPtr Pointer',
        summary: 'pointer to base geometry (ON_Object*)',
        since: 6.1,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'DocumentCollectedException',
    dataType: 1,
    summary: `Represents the error that happen when a class user attempts to execute a modifying operation
   on an object that has been added to a document.`,
    baseclass: 'Exception',
    constructors: [
      {
        signature: 'DocumentCollectedException()',
        summary: 'Initializes a new instance of the document controlled exception class.',
        since: 5
      },
      {
        signature: 'DocumentCollectedException(string message)',
        summary: 'Initializes a new instance of the document collected exception class.',
        since: 6,
        parameters: [
          {
            name: 'message',
            summary: 'A more specific message.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'HostUtils',
    dataType: 1,
    summary: 'Contains static methods to deal with teh runtime environment.',
    properties: [
      {
        signature: 'static string ComputerSerialNumber',
        summary: 'Gets the serial number of the computer running Rhino.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static uint CurrentOSLanguage',
        summary: 'Get the current operating system language.',
        since: 6.8,
        property: ['get']
      },
      {
        signature: 'static Guid DeviceId',
        summary: `The DeviceId is a unique, stable ID that anonymously identifies the device
     that Rhino is running on. It is computed based on hardware information that
     should not change when the OS is upgraded, or if commonly modified hardware
     are added or removed from the computer. The machine-specific information is
     hashed using a cryptographic hash to make it anonymous.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static string DeviceName',
        summary: `Name of the computer running Rhino. If the computer is part of a
     Windows Domain, the computer name has "@[DOMAIN]" appended.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'static string OperatingSystemBuildNumber',
        summary: 'Returns Operating System Build Number "11763" | "7601" | ... | "Unknown"',
        since: 6.15,
        property: ['get']
      },
      {
        signature: 'static string OperatingSystemEdition',
        summary: 'Returns Operating System Edition: "Professional" | "ServerDatacenter" | ... | "Unknown"',
        since: 6.15,
        property: ['get']
      },
      {
        signature: 'static string OperatingSystemInstallationType',
        summary: 'Returns Operating System Installation Type: "Client" | "Server" | "Unknown"',
        since: 6.15,
        property: ['get']
      },
      {
        signature: 'static string OperatingSystemProductName',
        summary: 'Returns Operating System Edition: "Professional" | "ServerDatacenter" | ... | "Unknown"',
        since: 6.15,
        property: ['get']
      },
      {
        signature: 'static string OperatingSystemVersion',
        summary: 'Returns Operating System Version "6.1" | "6.3" | ... | "Unknown"',
        since: 6.15,
        property: ['get']
      },
      {
        signature: 'static bool RunningInDarkMode',
        summary: `Returns True if the host operating system is in dark mode and Rhino
     supports dark mode.`,
        since: 6.19,
        property: ['get']
      },
      {
        signature: 'static bool RunningInMono',
        summary: 'Tests if this process is currently executing under the Mono runtime.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static bool RunningInRhino',
        summary: `Tests if RhinoCommon is currently executing inside of the Rhino.exe process.
     There are other cases where RhinoCommon could be running; specifically inside
     of Visual Studio when something like a windows form is being worked on in the
     resource editor or running stand-alone when compiled to be used as a version
     of OpenNURBS.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'static bool RunningOnOSX',
        summary: 'Tests if this process is currently executing on the Mac OSX platform.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static bool RunningOnWindows',
        summary: 'Tests if this process is currently executing on the Windows platform.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static bool SendDebugToCommandLine',
        summary: 'Gets or sets whether debug messages are printed to the command line.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static string AutoInstallPlugInFolder(bool currentUser)',
        summary: 'Gets the auto install plug-in folder for machine or current user.',
        since: 6,
        parameters: [
          {
            name: 'currentUser',
            summary: 'True if the query relates to the current user.'
          }
        ],
        returns: 'The full path to the revelant auto install plug-in directory.'
      },
      {
        signature: 'static int CallFromCoreRhino(string task)',
        summary: `Don't change this function in ANY way unless you chat with Steve first!
     This function is called by Rhino on initial startup and the signature
     must be exact`,
        since: 6
      },
      {
        signature: 'static bool CheckForRdk(bool throwOnFalse,bool usePreviousResult)',
        summary: 'Determines if the RDK is loaded.',
        since: 5,
        parameters: [
          {
            name: 'throwOnFalse',
            summary: `if the RDK is not loaded, then throws a
     RdkNotLoadedException.`
          },
          {
            name: 'usePreviousResult',
            summary: `if true, then the last result can be used instaed of
     performing a full check.`
          }
        ],
        returns: `True if the RDK is loaded; False if the RDK is not loaded. Note that the
     RdkNotLoadedException will hinder the retrieval of any return value.`
      },
      {
        signature: 'static void ClearFpuExceptionStatus()',
        summary: 'Clear FPU exception and busy flags (Intel assembly fnclex)',
        since: 6
      },
      {
        signature: 'static int CreateCommands(IntPtr pPlugIn,Assembly pluginAssembly)',
        summary: 'Parses a plugin and create all the commands defined therein.',
        since: 5,
        parameters: [
          {
            name: 'pPlugIn',
            summary: 'Plugin to harvest for commands.'
          },
          {
            name: 'pluginAssembly',
            summary: 'Assembly associated with the plugin.'
          }
        ],
        returns: 'The number of newly created commands.'
      },
      {
        signature: 'static void CreateCommands(PlugIn plugin)',
        summary: 'Parses a plugin and create all the commands defined therein.',
        since: 5,
        parameters: [
          {
            name: 'plugin',
            summary: 'Plugin to harvest for commands.'
          }
        ]
      },
      {
        signature: 'static PlugIn CreatePlugIn(Type pluginType,bool printDebugMessages)',
        summary: 'Instantiates a plug-in type and registers the associated commands and classes.',
        since: 5,
        parameters: [
          {
            name: 'pluginType',
            summary: 'A plug-in type. This type must derive from PlugIn.'
          },
          {
            name: 'printDebugMessages',
            summary: 'True if debug messages should be printed.'
          }
        ],
        returns: 'A new plug-in instance.'
      },
      {
        signature: 'static string DebugDumpToString(BezierCurve bezierCurve)',
        summary: `Gets the debug dumps. This is a text description of the geometric contents.
     DebugDump() is intended for debugging and is not suitable for creating high
     quality text descriptions of an object.`,
        since: 5,
        parameters: [
          {
            name: 'bezierCurve',
            summary: 'curve to evaluate'
          }
        ],
        returns: 'A debug dump text.'
      },
      {
        signature: 'static string DebugDumpToString(GeometryBase geometry)',
        summary: `Gets the debug dumps. This is a text description of the geometric contents.
     DebugDump() is intended for debugging and is not suitable for creating high
     quality text descriptions of an object.`,
        since: 5,
        parameters: [
          {
            name: 'geometry',
            summary: 'Some geometry.'
          }
        ],
        returns: 'A debug dump text.'
      },
      {
        signature: 'static void DebugString(string msg)',
        summary: `Prints a debug message to the Rhino Command Line.
     The message will only appear if the SendDebugToCommandLine property is set to true.`,
        since: 5,
        parameters: [
          {
            name: 'msg',
            summary: 'Message to print.'
          }
        ]
      },
      {
        signature: 'static void DebugString(string format,object[] args)',
        summary: `Prints a debug message to the Rhino Command Line.
     The message will only appear if the SendDebugToCommandLine property is set to true.`,
        since: 5,
        parameters: [
          {
            name: 'format',
            summary: 'Message to format and print.'
          },
          {
            name: 'args',
            summary: 'An Object array containing zero or more objects to format.'
          }
        ]
      },
      {
        signature: 'static void DisplayOleAlerts(bool display)',
        summary: `Defines if Ole alerts ("Server busy") alerts should be visualized.
     This function makes no sense on Mono.`,
        since: 5,
        parameters: [
          {
            name: 'display',
            summary: 'Whether alerts should be visible.'
          }
        ]
      },
      {
        signature: 'static void ExceptionReport(Exception ex)',
        summary: 'Informs RhinoCommon of an exception that has been handled but that the developer wants to screen.',
        since: 5,
        parameters: [
          {
            name: 'ex',
            summary: 'An exception.'
          }
        ]
      },
      {
        signature: 'static void ExceptionReport(string source,Exception ex)',
        summary: 'Informs RhinoCommon of an exception that has been handled but that the developer wants to screen.',
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'An exception source text.'
          },
          {
            name: 'ex',
            summary: 'An exception.'
          }
        ]
      },
      {
        signature: 'static void ExecuteNamedCallback(string name,NamedParametersEventArgs args)',
        summary: 'Execute a named callback',
        since: 7
      },
      {
        signature: 'static bool FileNameEndsWithRhinoBackupExtension(string fileName)',
        summary: `Strip file extension from file name and check to see if it is a valid
     Rhino backup file extension.`,
        since: 6,
        parameters: [
          {
            name: 'fileName',
            summary: 'File name to check.'
          }
        ],
        returns: 'Returns True if the file name has an extension like 3dmbak.'
      },
      {
        signature: 'static bool FileNameEndsWithRhinoExtension(string fileName)',
        summary: `Strip file extension from file name and check to see if it is a valid
     Rhino file extension.`,
        since: 6,
        parameters: [
          {
            name: 'fileName',
            summary: 'File name to check.'
          }
        ],
        returns: 'Returns True if the file name has an extension like 3dm.'
      },
      {
        signature: 'static bool GetAbsolutePath(string relativePath,bool bRelativePathisFileName,string relativeTo,bool bRelativeToIsFileName,string pathOut)',
        summary: `Call this method to convert a relative path to an absolute path
     relative to the specified path.`,
        since: 6,
        parameters: [
          {
            name: 'relativePath',
            summary: 'Relative path to convert to an absolute path'
          },
          {
            name: 'bRelativePathisFileName',
            summary: `If True then lpsFrom is treated as a file name otherwise it is treated
     as a directory name`
          },
          {
            name: 'relativeTo',
            summary: 'File or folder the path is relative to'
          },
          {
            name: 'bRelativeToIsFileName',
            summary: `If True then lpsFrom is treated as a file name otherwise it is treated
     as a directory name`
          },
          {
            name: 'pathOut',
            summary: 'Reference to string which will receive the computed absolute path'
          }
        ],
        returns: `Returns True if parameters are valid and lpsRelativePath is indeed
     relative to lpsRelativeTo otherwise returns false`
      },
      {
        signature: 'static IEnumerable<System.IO.DirectoryInfo> GetActivePlugInVersionFolders(bool currentUser)',
        summary: 'Recurses through the auto install plug-in folders and returns the directories containing "active" versions of plug-ins.',
        since: 6,
        parameters: [
          {
            name: 'currentUser',
            summary: 'Current user (true) or machine (false).'
          }
        ]
      },
      {
        signature: 'static string[] GetAssemblySearchPaths()',
        summary: `Returns list of directory names where additional assemblies (plug-ins, DLLs, Grasshopper components)
     may be located`,
        since: 5
      },
      {
        signature: 'static void GetCurrentProcessInfo(string processName,Version processVersion)',
        summary: `Returns information about the current process. If Rhino is the top level process,
     processName is "Rhino". Otherwise, processName is the name, without extension, of the main
     module that is executing. For example, "compute.backend" or "Revit".
     
     processVersion is the System.Version of the running process. It is the FileVersion
     of the executable.`,
        since: 6.15
      },
      {
        signature: 'static Tuple<string, Type>[] GetCustomComputeEndpoints()',
        summary: 'Used by compute to define custom endpoints',
        since: 7
      },
      {
        signature: 'static T GetPlatformService(string assemblyPath,string typeFullName)',
        summary: 'For internal use only. Loads an assembly for dependency injection via IPlatformServiceLocator.',
        since: 6,
        parameters: [
          {
            name: 'assemblyPath',
            summary: 'The relative path of the assembly, relative to the position of RhinoCommon.dll'
          },
          {
            name: 'typeFullName',
            summary: 'The full name of the type that is IPlatformServiceLocator. This is optional.'
          }
        ],
        returns: 'An instance, or null.'
      },
      {
        signature: 'static System.Reflection.Assembly GetRhinoDotNetAssembly()',
        summary: 'Only works on Windows. Returns None on Mac.',
        since: 5,
        returns: 'An assembly.'
      },
      {
        signature: 'static void InitializeRhinoCommon()',
        summary: `Makes sure all static RhinoCommon components is set up correctly.
     This happens automatically when a plug-in is loaded, so you probably won't
     have to call this method.`,
        since: 5
      },
      {
        signature: 'static void InitializeRhinoCommon_RDK()',
        summary: `Makes sure all static RhinoCommon RDK components are set up correctly.
     This happens automatically when the RDK is loaded, so you probably won't
     have to call this method.`,
        since: 6
      },
      {
        signature: 'static void InitializeZooClient()',
        summary: `Initializes the ZooClient and Rhino license manager, this should get
     called automatically when RhinoCommon is loaded so you probably won't
     have to call this method.`,
        since: 5.6
      },
      {
        signature: 'static void InPlaceConstCast(GeometryBase geometry,bool makeNonConst)',
        summary: `DO NOT USE UNLESS YOU ARE CERTAIN ABOUT THE IMPLICATIONS.
     This is an expert user function which should not be needed in most
     cases. This function is similar to a const_cast in C++ to allow an object
     to be made temporarily modifiable without causing RhinoCommon to convert
     the class from const to non-const by creating a duplicate.You must call this function with a True parameter, make your
     modifications, and then restore the const flag by calling this function
     again with a False parameter. If you have any questions, please
     contact McNeel developer support before using!`,
        since: 5,
        parameters: [
          {
            name: 'geometry',
            summary: 'Some geometry.'
          },
          {
            name: 'makeNonConst',
            summary: 'A boolean value.'
          }
        ]
      },
      {
        signature: 'static bool IsManagedDll(string path)',
        summary: 'Inspects a dll to see if it is compiled as native code or as a .NET assembly',
        since: 6
      },
      {
        signature: 'static bool IsRhinoBackupFileExtension(string fileExtension)',
        summary: 'Check to see if the file extension is a valid Rhino file extension.',
        since: 6,
        returns: `Return True if fileExtension is ".3dmbak", "3dmbak", ".3dm.bak", "3dm.bak",
     ".3dx.bak" or "3dx.bak", ignoring case.`
      },
      {
        signature: 'static bool IsRhinoFileExtension(string fileExtension)',
        summary: 'Check to see if the file extension is a valid Rhino file extension.',
        since: 6,
        returns: `Returns True if fileExtension is ".3dm", "3dm", ".3dx" or "3dx",
     ignoring case.`
      },
      {
        signature: 'static void RecordInitInstanceTime(string description)',
        summary: `Used to help record times at startup with the -stopwatch flag to help
     determine bottlenecks in start up speed`,
        since: 6
      },
      {
        signature: 'static void RegisterComputeEndpoint(string endpointPath,Type t)',
        summary: 'Register a class that can participate as a compute endpoint',
        since: 7
      },
      {
        signature: 'static bool RegisterDynamicCommand(PlugIn plugin,Command cmd)',
        summary: 'Adds a new dynamic command to Rhino.',
        since: 5,
        parameters: [
          {
            name: 'plugin',
            summary: 'Plugin that owns the command.'
          },
          {
            name: 'cmd',
            summary: 'Command to add.'
          }
        ],
        returns: 'True on success, False on failure.'
      },
      {
        signature: 'static void RegisterNamedCallback(string name,EventHandler<NamedParametersEventArgs> callback)',
        summary: 'Register a named callback',
        since: 6.15
      },
      {
        signature: 'static void RhinoCommonExceptionHandler(string title,object sender,Exception ex)',
        summary: `For internal use only!!!
     Unhanded exception handler, writes stack trace to RhinoDotNet.txt file`,
        since: 6,
        parameters: [
          {
            name: 'title',
            summary: 'Exception title to write to text file'
          },
          {
            name: 'sender',
            summary: ''
          },
          {
            name: 'ex',
            summary: ''
          }
        ]
      },
      {
        signature: 'static void SendLogMessageToCloudCallbackProc(LogMessageType msg_type,IntPtr pwStringClass,IntPtr pwStringDesc,IntPtr pwStringMessage)',
        summary: 'Informs RhinoCommon of an message that has been handled but that the developer wants to screen.',
        since: 6.4,
        parameters: [
          {
            name: 'msg_type',
            summary: 'The messag type'
          },
          {
            name: 'pwStringClass',
            summary: 'The top level message type.'
          },
          {
            name: 'pwStringDesc',
            summary: 'Finer grained description of the message.'
          },
          {
            name: 'pwStringMessage',
            summary: 'The message.'
          }
        ]
      },
      {
        signature: 'static void SetInShutDown()',
        summary: 'Informs the runtime that the application is shutting down.',
        since: 5
      },
      {
        signature: 'static void ShutDownRhinoCommon_RDK()',
        summary: 'Makes sure all static RhinoCommon RDK components are de-initialized so they aren\'t calling into space when the RDK is unloaded.',
        since: 6
      },
      {
        signature: 'static void UnhandledThreadException(object sender,ThreadExceptionEventArgs e)',
        summary: 'Exception handler for exceptions occurring on the UI thread',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'HostUtils.LogMessageType',
    dataType: 3,
    summary: 'Represents the type of message that is being sent to the OnSendLogMessageToCloud event',
    values: [
      {
        signature: 'unknown = 0',
        summary: 'Unknown message type'
      },
      {
        signature: 'information = 1',
        summary: 'Message is informational only'
      },
      {
        signature: 'warning = 2',
        summary: 'Message is a warning'
      },
      {
        signature: 'error = 3',
        summary: 'Message is an error'
      },
      {
        signature: 'assert = 4',
        summary: 'Message is a debug ASSERT'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'ImportOptionsSections',
    dataType: 3,
    summary: 'Standard CRhImportOptions sections to import',
    values: [
      {
        signature: 'AdvancedDisplay = 0'
      },
      {
        signature: 'Alias'
      },
      {
        signature: 'Appearance'
      },
      {
        signature: 'ChooseOneObject'
      },
      {
        signature: 'ControlPointContextMenu'
      },
      {
        signature: 'CursorToolTip'
      },
      {
        signature: 'Display'
      },
      {
        signature: 'File'
      },
      {
        signature: 'General'
      },
      {
        signature: 'Grid'
      },
      {
        signature: 'ModelAid'
      },
      {
        signature: 'Mouse'
      },
      {
        signature: 'ObjectContextMenu'
      },
      {
        signature: 'SearchPath'
      },
      {
        signature: 'ShortcutKey'
      },
      {
        signature: 'Smarttrack'
      },
      {
        signature: 'View'
      },
      {
        signature: 'ViewportContextMenu'
      },
      {
        signature: 'ToolPaletteSettings',
        summary: 'Tool palette settings for Mac, ignored for Windows'
      },
      {
        signature: 'Count',
        summary: 'Must always be the last item'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InProcess',
    name: 'RhinoCore',
    dataType: 1,
    summary: 'Represents an instance of RhinoCore.DLL.',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'RhinoCore()',
        summary: 'Initializes a new instance of the RhinoCore class.',
        since: 7
      },
      {
        signature: 'RhinoCore(string[] args)',
        summary: 'Initializes a new instance of the RhinoCore class.',
        since: 7,
        parameters: [
          {
            name: 'args',
            summary: 'Rhino command line parameters'
          }
        ]
      },
      {
        signature: 'RhinoCore(string[] args,WindowStyle windowStyle)',
        summary: 'Initializes a new instance of the RhinoCore class.',
        since: 7,
        parameters: [
          {
            name: 'args',
            summary: 'Rhino command line parameters'
          },
          {
            name: 'windowStyle',
            summary: 'Rhino main window initial style'
          }
        ]
      },
      {
        signature: 'RhinoCore(string[] args,WindowStyle windowStyle,IntPtr hostWnd)',
        summary: 'Initializes a new instance of the RhinoCore class.',
        since: 7,
        parameters: [
          {
            name: 'args',
            summary: 'Rhino command line parameters'
          },
          {
            name: 'windowStyle',
            summary: 'Rhino main window initial style'
          },
          {
            name: 'hostWnd',
            summary: 'Host main window OS native handle'
          }
        ]
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'IDisposable implementation',
        since: 7
      },
      {
        signature: 'bool DoEvents()',
        summary: 'If a Rhino owned window is active processes all Windows messages currently in the message queue.',
        since: 7,
        returns: 'Returns True if a Rhino owned window is still active or Idle tasks are pending.'
      },
      {
        signature: 'bool DoIdle()',
        summary: 'Processes all Rhino Idle tasks.',
        since: 7,
        returns: 'True if Idle tasks are still pending.'
      },
      {
        signature: 'void InvokeInHostContext(Action action)',
        summary: 'Invokes action in Host context',
        since: 7
      },
      {
        signature: 'T InvokeInHostContext(Func<T> func)',
        summary: 'Invokes function in Host context',
        since: 7,
        returns: 'Returns argument function return value.'
      },
      {
        signature: 'void RaiseIdle()',
        summary: 'Raises the Idle event.',
        since: 7
      },
      {
        signature: 'int Run()',
        summary: 'Runs RhinoApp Message loop',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InProcess',
    name: 'WindowStyle',
    dataType: 3,
    summary: 'Specified how a new window should appear when Rhino starts.',
    values: [
      {
        signature: 'NoWindow = -1',
        summary: 'The no window style.'
      },
      {
        signature: 'Normal = 0',
        summary: 'The normal, visible window style.'
      },
      {
        signature: 'Hidden = 1',
        summary: 'The hidden window style.'
      },
      {
        signature: 'Minimized = 2',
        summary: 'The minimized window style.'
      },
      {
        signature: 'Maximized = 3',
        summary: 'The maximized window style.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'Interop',
    dataType: 1,
    summary: 'Contains static methods to marshal objects between RhinoCommon and legacy Rhino_DotNet or C++.',
    methods: [
      {
        signature: 'static Geometry.GeometryBase CreateFromNativePointer(IntPtr pGeometry)',
        summary: `Constructs a RhinoCommon Geometry class from a given ON_Geomety*. The ON_Geometry*
     must be declared on the heap and its lifetime becomes controlled by RhinoCommon.`,
        since: 5,
        parameters: [
          {
            name: 'pGeometry',
            summary: 'ON_Geometry*'
          }
        ],
        returns: 'The appropriate geometry class in RhinoCommon on success.'
      },
      {
        signature: 'static IntPtr FileReadOptionsConstPointer(FileReadOptions options)',
        summary: `Returns the underlying const CRhinoFileReadOptions* for a Rhino.FileIO.FileReadOptions object.
     You should only be interested in using this function if you are writing C++ code.`,
        since: 6,
        parameters: [
          {
            name: 'options',
            summary: 'A FileReadOptions object.'
          }
        ],
        returns: 'A pointer to the Rhino const object.'
      },
      {
        signature: 'static IntPtr FileWriteOptionsConstPointer(FileWriteOptions options)',
        summary: `Returns the underlying const CRhinoFileWriteOptions* for a Rhino.FileIO.FileWriteOptions object. 
     You should only be interested in using this function if you are writing C++ code.`,
        since: 6,
        parameters: [
          {
            name: 'options',
            summary: 'A FileWriteOptions object.'
          }
        ],
        returns: 'A pointer to the Rhino const object.'
      },
      {
        signature: 'static DocObjects.Font FontFromPointer(IntPtr ptrManagedFont)',
        summary: 'Create managed Font from native ON_Font*',
        since: 6
      },
      {
        signature: 'static Geometry.Brep FromOnBrep(object source)',
        summary: 'Copies a Rhino_DotNet brep to a RhinoCommon brep class.',
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'RMA.OpenNURBS.IOnBrep or RMA.OpenNURBS.OnBrep.'
          }
        ],
        returns: 'RhinoCommon object on success. This will be an independent copy.'
      },
      {
        signature: 'static Geometry.Curve FromOnCurve(object source)',
        summary: 'Copies a Rhino_DotNet curve to a RhinoCommon curve class.',
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'RMA.OpenNURBS.IOnCurve or RMA.OpenNURBS.OnCurve.'
          }
        ],
        returns: 'RhinoCommon object on success. This will be an independent copy.'
      },
      {
        signature: 'static Geometry.Mesh FromOnMesh(object source)',
        summary: 'Copies a Rhino_DotNet mesh to a RhinoCommon mesh class.',
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'RMA.OpenNURBS.IOnMesh or RMA.OpenNURBS.OnMesh.'
          }
        ],
        returns: 'RhinoCommon object on success. This will be an independent copy.'
      },
      {
        signature: 'static Geometry.Surface FromOnSurface(object source)',
        summary: 'Copies a Rhino_DotNet surface to a RhinoCommon Surface class.',
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: `Any of the following in the RMA.OpenNURBS namespace are acceptable.
     IOnSurface, OnSurface, IOnPlaneSurface, OnPlaneSurface, IOnClippingPlaneSurface,
     OnClippingPlaneSurface, IOnNurbsSurface, OnNurbsSurfac, IOnRevSurface, OnRevSurface,
     IOnSumSurface, OnSumSurface.`
          }
        ],
        returns: 'RhinoCommon object on success. This will be an independent copy.'
      },
      {
        signature: 'static IntPtr NativeGeometryConstPointer(GeometryBase geometry)',
        summary: `Returns the underlying const ON_Geometry* for a RhinoCommon class. You should only
     be interested in using this function if you are writing C++ code.`,
        since: 5,
        parameters: [
          {
            name: 'geometry',
            summary: 'A geometry object. This can be None and in such a case IntPtr.Zero is returned.'
          }
        ],
        returns: 'A pointer to the const geometry.'
      },
      {
        signature: 'static IntPtr NativeGeometryNonConstPointer(GeometryBase geometry)',
        summary: `Returns the underlying non-const ON_Geometry* for a RhinoCommon class. You should
     only be interested in using this function if you are writing C++ code.`,
        since: 5,
        parameters: [
          {
            name: 'geometry',
            summary: 'A geometry object. This can be None and in such a case IntPtr.Zero is returned.'
          }
        ],
        returns: 'A pointer to the non-const geometry.'
      },
      {
        signature: 'static IntPtr NativeNonConstPointer(DisplayPipeline pipeline)',
        summary: 'Get CRhinoDisplayPipeline* for a DisplayPipeline instance',
        since: 6
      },
      {
        signature: 'static IntPtr NativeNonConstPointer(GetPoint getPoint)',
        summary: 'Get CRhinoGetPoint* from a GetPoint instance',
        since: 6
      },
      {
        signature: 'static IntPtr NativeNonConstPointer(RhinoViewport viewport)',
        summary: 'Get CRhinoViewport* from a RhinoViewport instance',
        since: 6
      },
      {
        signature: 'static IntPtr NativeNonConstPointer(ViewCaptureSettings settings)',
        summary: 'Get a CRhinoPrintInfo* for a given ViewCaptureSettings class',
        since: 6
      },
      {
        signature: 'static IntPtr NativeNonConstPointer(ViewportInfo viewport)',
        summary: 'Get ON_Viewport* from a ViewportInfo instance',
        since: 5.1
      },
      {
        signature: 'static IntPtr NativeRhinoDocPointer(RhinoDoc doc)',
        summary: 'Gets the C++ CRhinoDoc* for a given RhinoCommon RhinoDoc class.',
        since: 5,
        parameters: [
          {
            name: 'doc',
            summary: 'A document.'
          }
        ],
        returns: 'A pointer value.'
      },
      {
        signature: 'static IntPtr NSFontFromFont(Font font)',
        summary: 'Get native NSFont* from a Rhino Font. Only works on Mac',
        since: 6.9,
        returns: 'NSFont* on success. IntPtr.Zero on failure'
      },
      {
        signature: 'static IntPtr NSFontFromFont(Font font,double pointSize)',
        summary: 'Get native NSFont* from a Rhino Font. Only works on Mac',
        since: 6.9,
        parameters: [
          {
            name: 'font',
            summary: ''
          },
          {
            name: 'pointSize',
            summary: 'Point size'
          }
        ],
        returns: 'NSFont* on success. IntPtr.Zero on failure'
      },
      {
        signature: 'static IntPtr PlugInPointer(PlugIn plugin)',
        summary: `Gets a C++ plug-in pointer for a given RhinoCommon plug-in.
     This is a Rhino SDK function.`,
        since: 5,
        parameters: [
          {
            name: 'plugin',
            summary: 'A plug-in.'
          }
        ],
        returns: 'A pointer.'
      },
      {
        signature: 'static IntPtr RhinoObjectConstPointer(RhinoObject rhinoObject)',
        summary: `Returns the underlying const CRhinoObject* for a RhinoCommon class. You should only
     be interested in using this function if you are writing C++ code.`,
        since: 5,
        parameters: [
          {
            name: 'rhinoObject',
            summary: 'A Rhino object.'
          }
        ],
        returns: 'A pointer to the Rhino const object.'
      },
      {
        signature: 'static DocObjects.RhinoObject RhinoObjectFromPointer(IntPtr pRhinoObject)',
        summary: 'Constructs a RhinoCommon Rhino object from an unmanaged C++ RhinoObject pointer.',
        since: 5,
        parameters: [
          {
            name: 'pRhinoObject',
            summary: 'The original pointer.'
          }
        ],
        returns: 'A new Rhino object, or None if the pointer was invalid or IntPtr.Zero.'
      },
      {
        signature: 'static object ToIRhinoViewport(RhinoViewport source)',
        summary: 'Convert a Rhino.Display.Viewport to an RMA.Rhino.IRhinoViewport.',
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'A RhinoCommon viewport.'
          }
        ],
        returns: 'Rhino_DotNet IRhinoViewport object on success. This will be an independent copy.'
      },
      {
        signature: 'static object ToOnBrep(Brep source)',
        summary: 'Constructs a Rhino_DotNet OnBrep that is a copy of a given brep.',
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'A source brep.'
          }
        ],
        returns: 'Rhino_DotNet object on success. This will be an independent copy.'
      },
      {
        signature: 'static object ToOnCurve(Curve source)',
        summary: 'Constructs a Rhino_DotNet OnCurve that is a copy of a given curve.',
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'A RhinoCommon source curve.'
          }
        ],
        returns: 'Rhino_DotNet object on success. This will be an independent copy.'
      },
      {
        signature: 'static object ToOnMesh(Mesh source)',
        summary: 'Constructs a Rhino_DotNet OnMesh that is a copy of a given mesh.',
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'A source brep.'
          }
        ],
        returns: 'Rhino_DotNet object on success. This will be an independent copy.'
      },
      {
        signature: 'static object ToOnSurface(Surface source)',
        summary: 'Constructs a Rhino_DotNet OnSurface that is a copy of a given curve.',
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'A source brep.'
          }
        ],
        returns: 'Rhino_DotNet object on success. This will be an independent copy.'
      },
      {
        signature: 'static object ToOnXform(Transform source)',
        summary: 'Constructs a Rhino_DotNet OnXform from a given RhinoCommon Transform.',
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'A RhinoCommon source transform.'
          }
        ],
        returns: 'Rhino_DotNet object on success. This will be an independent copy.'
      },
      {
        signature: 'static bool TryCopyFromOnArc(object source,Arc destination)',
        summary: 'Attempts to copy the contents of a RMA.OpenNURBS.OnArc to a Rhino.Geometry.Arc.',
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'A source OnArc.'
          },
          {
            name: 'destination',
            summary: 'A destination arc.'
          }
        ],
        returns: 'True if the operation succeeded; False otherwise.'
      },
      {
        signature: 'static bool TryCopyToOnArc(Arc source,object destination)',
        summary: 'Attempts to copy the contents of a Rhino.Geometry.Arc to a RMA.OpenNURBS.OnArc.',
        since: 5,
        parameters: [
          {
            name: 'source',
            summary: 'A source arc.'
          },
          {
            name: 'destination',
            summary: 'A destination OnArc.'
          }
        ],
        returns: 'True if the operation succeeded; False otherwise.'
      },
      {
        signature: 'static Display.ViewCaptureSettings ViewCaptureFromPointer(IntPtr ptrViewCapture)',
        summary: `Create a ViewCaptureSettings class from a native const CRhinoPrintInfo*
     The pointer values are copied`,
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'ClassArrayObjRef',
    dataType: 1,
    summary: `Represents a wrapper to an unmanaged "array" (list) of CRhinoObjRef instances.
   Wrapper for a C++ ON_ClassArray of CRhinoObjRef`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'ClassArrayObjRef()',
        summary: 'Initializes a new ClassArrayObjRef instance.',
        since: 5
      },
      {
        signature: 'ClassArrayObjRef(IEnumerable<ObjRef> objrefs)',
        summary: 'Initializes a new instances from a set of ObjRefs',
        since: 5,
        parameters: [
          {
            name: 'objrefs',
            summary: 'An array, a list or any enumerable set of Rhino object references.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of CRhinoObjRef instances in this array.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(ObjRef objref)',
        summary: 'Adds an ObjRef to the list.',
        since: 5,
        parameters: [
          {
            name: 'objref',
            summary: 'An ObjRef to add.'
          }
        ]
      },
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 5,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 5,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'Rhino.DocObjects.ObjRef[] ToNonConstArray()',
        summary: 'Copies the unmanaged array to a managed counterpart.',
        since: 5,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'ClassArrayOnObjRef',
    dataType: 1,
    summary: `Represents a wrapper to an unmanaged "array" (list) of ON_ObjRef instances.
   Wrapper for a C++ ON_ClassArray of ON_ObjRef`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'ClassArrayOnObjRef()',
        summary: 'Initializes a new ClassArrayOnObjRef instance.',
        since: 5.8
      },
      {
        signature: 'ClassArrayOnObjRef(IEnumerable<ObjRef> objrefs)',
        summary: 'Initializes a new instances from a set of ObjRefs',
        since: 5.8,
        parameters: [
          {
            name: 'objrefs',
            summary: 'An array, a list or any enumerable set of Rhino object references.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of ObjRef instances in this array.',
        since: 5.8,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(ObjRef objref)',
        summary: 'Adds an ObjRef to the list.',
        since: 5.8,
        parameters: [
          {
            name: 'objref',
            summary: 'An ObjRef to add.'
          }
        ]
      },
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 5.8,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5.8
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 5.8,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'DocObjects.ObjRef[] ToNonConstArray()',
        summary: 'Copies the unmanaged array to a managed counterpart.',
        since: 5.8,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'ClassArrayString',
    dataType: 1,
    summary: `Wrapper for a C++ ON_ClassArray<ON_wString>
   If you are not writing C++ code then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'ClassArrayString()',
        summary: 'Initializes a new ClassArrayString instance.',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of strings in this array.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(string s)',
        summary: 'Adds a string to the list.',
        since: 6,
        parameters: [
          {
            name: 's',
            summary: 'A string to add.'
          }
        ]
      },
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 6,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 6,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'string[] ToArray()',
        summary: 'Copies the unmanaged array to a managed counterpart.',
        since: 6,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'CurveSegment',
    dataType: 2,
    summary: 'For internal use only.',
    properties: [
      {
        signature: 'int Index',
        summary: 'The index of the curve used by this boundary element.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'bool Reversed',
        summary: 'True if this piece of the curve should be reversed.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'Interval SubDomain',
        summary: 'The subdomain of the curve used by this boundary element.',
        since: 7,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'MeshPointDataStruct',
    dataType: 2,
    summary: `This is only needed when passing values to the Rhino C++ core, ignore
   for .NET plug-ins.`
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArray2dex',
    dataType: 1,
    summary: `Wrapper for ON_SimpleArray<ON_2dex>. If you are not writing C++ code
   then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArray2dex()',
        summary: 'Initializes a new SimpleArray2dex class.',
        since: 6
      },
      {
        signature: 'SimpleArray2dex(IEnumerable<IndexPair> values)',
        summary: 'Initializes a new SimpleArray2dex class',
        since: 6,
        parameters: [
          {
            name: 'values',
            summary: 'initial set of integer pairs to add to the array'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of elements in this array.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 6,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 6,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'IndexPair[] ToArray()',
        summary: 'Returns the managed counterpart of the unmanaged array.',
        since: 6,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayArrayPoint3d',
    dataType: 1,
    summary: `Wrapper for ON_SimpleArray<ON_PolyLine*>, ON_SimpleArray<ON_3dPointArray*>
   If you are not writing C++ code then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayArrayPoint3d()',
        summary: 'Initializes a new empty SimpleArrayArrayPoint3d instance.',
        since: 7
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of polylines in this array.',
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 7,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 7
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 7,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'int PointCountAt(int index)',
        summary: 'Gets the amount of points in a polyline.',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayBinaryArchiveReader',
    dataType: 1,
    summary: `Wrapper for ON_SimpleArray<ON_BinaryArchive>. If you are not writing C++ code
   then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayBinaryArchiveReader()',
        summary: 'Initializes a new SimpleArrayBinaryArchiveReader class.',
        since: 6
      },
      {
        signature: 'SimpleArrayBinaryArchiveReader(IntPtr p)',
        summary: 'Initializes a new SimpleArrayBinaryArchiveReader class.',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of elements in this array.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(BinaryArchiveReader reader)',
        summary: 'Adds a new Interval at the end of this array.',
        since: 6
      },
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 6,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      },
      {
        signature: 'BinaryArchiveReader Get(int index)',
        summary: 'Get the Guid at index',
        since: 6
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 6,
        returns: 'The non-const pointer.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayBrepPointer',
    dataType: 1,
    summary: `Wrapper for a C++ ON_SimpleArray<ON_Brep*> or ON_SimpleArray<const ON_Brep*>
   If you are not writing C++ code then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayBrepPointer()',
        summary: 'Initializes a new SimpleArrayBrepPointer instance.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of breps in this array.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(Brep brep,bool asConst)',
        summary: 'Adds a brep to the list.',
        since: 5,
        parameters: [
          {
            name: 'brep',
            summary: 'A brep to add.'
          },
          {
            name: 'asConst',
            summary: 'Whether this brep should be treated as non-modifiable.'
          }
        ]
      },
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 5,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 5,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'Geometry.Brep[] ToNonConstArray()',
        summary: 'Copies the unmanaged array to a managed counterpart.',
        since: 5,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayClippingPlaneObjectPointer',
    dataType: 1,
    summary: 'ON_SimpleArray of CRhinoClippingPlaneObject*',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayClippingPlaneObjectPointer()',
        summary: 'Initializes a new SimpleArrayClippingPlaneObjectPointer instance.',
        since: 6.7
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of clipping planes in this array.',
        since: 6.7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(ClippingPlaneObject clippingplane,bool asConst)',
        summary: 'Adds a clipping plane to the list.',
        since: 6.7,
        parameters: [
          {
            name: 'clippingplane',
            summary: 'A clipping plane to add.'
          },
          {
            name: 'asConst',
            summary: 'Whether this clipping plane should be treated as non-modifiable.'
          }
        ]
      },
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 6.7,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6.7
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 6.7,
        returns: 'The non-const pointer.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayCurvePointer',
    dataType: 1,
    summary: `Wrapper for a C++ ON_SimpleArray of ON_Curve* or const ON_Curve*.  If you are not
   writing C++ code, then you can ignore this class.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayCurvePointer()',
        summary: 'Initializes a new SimpleArrayCurvePointer instance.',
        since: 5
      },
      {
        signature: 'SimpleArrayCurvePointer(IEnumerable<Curve> curves)',
        summary: 'Initializes a new SimpleArrayCurvePointer instance, from a set of input curves.',
        since: 5,
        parameters: [
          {
            name: 'curves',
            summary: 'A list, an array or any collection of curves that implements the enumerable interface.'
          }
        ]
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 5,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 5,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'Curve[] ToNonConstArray()',
        summary: 'Copies the unmanaged array to a managed counterpart.',
        since: 5,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayDouble',
    dataType: 1,
    summary: `Wrapper for ON_SimpleArray<double>. If you are not writing C++ code,
   then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayDouble()',
        summary: 'Initializes a new SimpleArrayDouble instance.',
        since: 5
      },
      {
        signature: 'SimpleArrayDouble(IEnumerable<double> items)',
        summary: 'Initializes a new SimpleArrayDouble instance, with items.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of elements in this array.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 5,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 5,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'double[] ToArray()',
        summary: 'Returns the managed counterpart of the unmanaged array.',
        since: 5,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayExtrusionPointer',
    dataType: 1,
    summary: `Wrapper for a C++ ON_SimpleArray<ON_Extrusion*> or ON_SimpleArray<const ON_Extrusion*>
   If you are not writing C++ code then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayExtrusionPointer()',
        summary: 'Initializes a new SimpleArrayExtrusionPointer instance.',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of Extrusions in this array.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(Extrusion extrusion,bool asConst)',
        summary: 'Adds a extrusion to the list.',
        since: 6,
        parameters: [
          {
            name: 'extrusion',
            summary: 'A extrusion to add.'
          },
          {
            name: 'asConst',
            summary: 'Whether this extrusion should be treated as non-modifiable.'
          }
        ]
      },
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 6,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 6,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'Geometry.Extrusion[] ToNonConstArray()',
        summary: 'Copies the unmanaged array to a managed counterpart.',
        since: 6,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayGeometryPointer',
    dataType: 1,
    summary: `Wrapper for a C++ ON_SimpleArray<ON_Geometry*>* or ON_SimpleArray<const ON_Geometry*>.
   If you are not writing C++ code, then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayGeometryPointer()',
        summary: 'Initializes a new SimpleArrayGeometryPointer instance.',
        since: 5
      },
      {
        signature: 'SimpleArrayGeometryPointer(IEnumerable geometry)',
        summary: 'Expects all of the items in the IEnumerable to be GeometryBase types',
        since: 5
      },
      {
        signature: 'SimpleArrayGeometryPointer(IEnumerable<GeometryBase> geometry)',
        summary: 'Create an ON_SimpleArray<ON_Geometry*> filled with items in geometry',
        since: 5
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 5,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 5,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'GeometryBase[] ToNonConstArray()',
        summary: 'Copies the unmanaged array to a managed counterpart.',
        since: 5,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayGuid',
    dataType: 1,
    summary: `Wrapper for ON_SimpleArray<ON_UUID>. If you are not writing C++ code
   then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayGuid()',
        summary: 'Initializes a new SimpleArrayGuid class.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of elements in this array.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Append(Guid uuid)',
        summary: 'Appends a new Guid at the end of this array.',
        since: 6
      },
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 5,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 5,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'Guid[] ToArray()',
        summary: 'Returns the managed counterpart of the unmanaged array.',
        since: 5,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayGuidPointer',
    dataType: 1,
    summary: `Wrapper for ON_SimpleArray<ON_UUID>. If you are not writing C++ code
   then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayGuidPointer()',
        summary: 'Initializes a new SimpleArrayGuidPointer class.',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of elements in this array.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 6,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 6,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'Guid[] ToArray()',
        summary: 'Returns the managed counterpart of the unmanaged array.',
        since: 6,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayInt',
    dataType: 1,
    summary: `Wrapper for ON_SimpleArray<int>. If you are not writing C++ code
   then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayInt()',
        summary: 'Initializes a new SimpleArrayInt class.',
        since: 5
      },
      {
        signature: 'SimpleArrayInt(IEnumerable<int> values)',
        summary: 'Initializes a new SimpleArrayInt class',
        since: 5.9,
        parameters: [
          {
            name: 'values',
            summary: 'initial set of integers to add to the array'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of elements in this array.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 5,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 5,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'int[] ToArray()',
        summary: 'Returns the managed counterpart of the unmanaged array.',
        since: 5,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayInterval',
    dataType: 1,
    summary: `Wrapper for ON_SimpleArray<ON_Interval>. If you are not writing C++ code
   then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayInterval()',
        summary: 'Initializes a new SimpleArrayInterval class.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of elements in this array.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(Interval interval)',
        summary: 'Adds a new Interval at the end of this array.',
        since: 6
      },
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 5,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 5,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'Interval[] ToArray()',
        summary: 'Returns the managed counterpart of the unmanaged array.',
        since: 5,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayLine',
    dataType: 1,
    summary: `Wrapper for ON_SimpleArray<ON_Line>. If you are not writing C++ code
   then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayLine()',
        summary: 'Initializes a new SimpleArrayLine instance.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of lines in this array.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 5,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 5,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'Line[] ToArray()',
        summary: 'Copies the unmanaged array to a managed counterpart.',
        since: 5,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayLinetypePointer',
    dataType: 1,
    summary: `Wrapper for a C++ ON_SimpleArray<ON_Linetype*>
   If you are not writing C++ code then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayLinetypePointer()',
        summary: 'Initializes a new SimpleArrayLinetypePointer instance.',
        since: 6.6
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of linetypes in this array.',
        since: 6.6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 6.6,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6.6
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 6.6,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'DocObjects.Linetype[] ToNonConstArray()',
        summary: 'Copies the unmanaged array to a managed counterpart.',
        since: 6.6,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayMeshPointer',
    dataType: 1,
    summary: `Represents a wrapper to an unmanaged array of mesh pointers.
   Wrapper for a C++ ON_SimpleArray of ON_Mesh* or const ON_Mesh*. If you are not
   writing C++ code then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayMeshPointer()',
        summary: 'Initializes a new SimpleArrayMeshPointer instance.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of meshes in this array.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(Mesh mesh,bool asConst)',
        summary: 'Adds a mesh to the list.',
        since: 5,
        parameters: [
          {
            name: 'mesh',
            summary: 'A mesh to add.'
          },
          {
            name: 'asConst',
            summary: 'Whether this mesh should be treated as non-modifiable.'
          }
        ]
      },
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 5,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 5,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'Geometry.Mesh[] ToNonConstArray()',
        summary: 'Copies the unmanaged array to a managed counterpart.',
        since: 5,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayPlane',
    dataType: 1,
    summary: `Wrapper for ON_SimpleArray<ON_Plane>. If you are not writing C++ code
   then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayPlane()',
        summary: 'Initializes a new SimpleArrayLine instance.',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of lines in this array.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 6,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 6,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'Plane[] ToArray()',
        summary: 'Copies the unmanaged array to a managed counterpart.',
        since: 6,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayPoint2d',
    dataType: 1,
    summary: `ON_SimpleArray<ON_2dPoint> class wrapper.  If you are not writing
   C++ code then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayPoint2d()',
        summary: 'Initializes a new empty SimpleArrayPoint3d instance.',
        since: 5.6
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of points in this array.',
        since: 5.6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 5.6,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5.6
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 5.6,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'Point2d[] ToArray()',
        summary: 'Copies the unmanaged array to a managed counterpart.',
        since: 5.6,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayPoint3d',
    dataType: 1,
    summary: `ON_SimpleArray<ON_3dPoint>, ON_3dPointArray, ON_PolyLine all have the same size
   This class wraps all of these C++ versions.  If you are not writing C++ code then this
   class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayPoint3d()',
        summary: 'Initializes a new empty SimpleArrayPoint3d instance.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the amount of points in this array.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 5,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 5,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'Point3d[] ToArray()',
        summary: 'Copies the unmanaged array to a managed counterpart.',
        since: 5,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArraySurfacePointer',
    dataType: 1,
    summary: `Wrapper for a C++ ON_SimpleArray of ON_Surface* or const ON_Surface*.  If
   you are not writing C++ code then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArraySurfacePointer()',
        summary: 'Initializes a new SimpleArraySurfacePointer instance.',
        since: 5
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 5,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 5,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'Surface[] ToNonConstArray()',
        summary: `Copies the unmanaged array to a managed counterpart.
     Elements are made non-const.`,
        since: 5,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'SimpleArrayUint',
    dataType: 1,
    summary: `Wrapper for ON_SimpleArray<unsigned int>. If you are not writing C++ code
   then this class is not for you.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'SimpleArrayUint()',
        summary: 'Initializes a new SimpleArrayInt class.',
        since: 6
      },
      {
        signature: 'SimpleArrayUint(IEnumerable<uint> values)',
        summary: 'Initializes a new SimpleArrayInt class.',
        since: 6,
        parameters: [
          {
            name: 'values',
            summary: 'A list, an array or any collection of unsigned ints that implements the enumerable interface.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Gets the number of elements in this array.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint UnsignedCount',
        summary: 'Gets the number of elements in this array.',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'IntPtr ConstPointer()',
        summary: 'Gets the const (immutable) pointer of this array.',
        since: 6,
        returns: 'The const pointer.'
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 6
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: 'Gets the non-const pointer (for modification) of this array.',
        since: 6,
        returns: 'The non-const pointer.'
      },
      {
        signature: 'uint[] ToArray()',
        summary: 'Returns the managed counterpart of the unmanaged array.',
        since: 6,
        returns: 'The managed array.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'StringHolder',
    dataType: 1,
    summary: `This class is used to pass strings back and forth between managed
   and unmanaged code.  This should not be be needed by plug-ins.
   If you are just dealing with an ON_wString*,
   use`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'StringHolder()',
        summary: 'Constructor',
        since: 5.8
      }
    ],
    methods: [
      {
        signature: 'static string GetString(IntPtr pStringHolder)',
        summary: 'Gets managed string from unmanaged ON_wString pointer.',
        since: 5.8,
        returns: 'Null if pStringHolder has no reference, otherwise, the string. This may be an empty string, if setting an empty string is possible.'
      },
      {
        signature: 'IntPtr ConstPointer()',
        summary: `C++ pointer used to access the ON_wString, managed plug-ins should
     never need this.`,
        since: 5.8
      },
      {
        signature: 'void Dispose()',
        summary: 'IDispose implementation',
        since: 5.8
      },
      {
        signature: 'IntPtr NonConstPointer()',
        summary: `C++ pointer used to access the ON_wString, managed plug-ins should
     never need this.`,
        since: 5.8
      },
      {
        signature: 'string ToString()',
        summary: 'Marshals unmanaged ON_wString to a managed .NET string'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.InteropWrappers',
    name: 'StringWrapper',
    dataType: 1,
    summary: `Represents a wrapper to an unmanaged OpenNurbs string.
   Wraps a C++ ON_wString*.`,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'StringWrapper()',
        summary: 'Initializes a new empty unmanaged string (ON_wString*).',
        since: 5
      },
      {
        signature: 'StringWrapper(string s)',
        summary: `Initializes a new unmanaged string with an initial value.
     The string s can be null.`,
        since: 5,
        parameters: [
          {
            name: 's',
            summary: 'The initial value, or null.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'IntPtr ConstPointer',
        summary: 'Gets the const pointer (const ON_wString*).',
        since: 5,
        property: ['get']
      },
      {
        signature: 'IntPtr NonConstPointer',
        summary: 'Gets the non-const pointer (ON_wString*).',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static string GetStringFromPointer(IntPtr pConstON_wString)',
        summary: 'Get string from an ON_wString*',
        since: 5
      },
      {
        signature: 'static void SetStringOnPointer(IntPtr pON_wString,string s)',
        summary: 'Set contents of an ON_wString*',
        since: 5
      },
      {
        signature: 'void Dispose()',
        summary: 'Actively reclaims unmanaged resources that this instance uses.',
        since: 5
      },
      {
        signature: 'void SetString(string s)',
        summary: 'Set contents of this string.',
        since: 5,
        parameters: [
          {
            name: 's',
            summary: 'The new string.'
          }
        ]
      },
      {
        signature: 'string ToString()',
        summary: 'Returns the string contents of this wrapper.',
        returns: 'A managed string.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'IPlatformServiceLocator',
    dataType: 4,
    summary: `Get platform specific services that are used internally for
   general cross platform funtions in RhinoCommon. This includes
   services like localization and GUI components that have concrete
   implementations in the RhinoWindows or RhinoMac assemblies`
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'IZooClientUtilities',
    dataType: 4,
    summary: 'Interface implemented in ZooClient and added to Rhino via dependency injection'
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'LicenseStateChangedEventArgs',
    dataType: 1,
    summary: 'Passed to LicenseStateChanged event on RhinoApp',
    baseclass: 'EventArgs',
    constructors: [
      {
        signature: 'LicenseStateChangedEventArgs(bool callingRhinoCommonAllowed)',
        summary: 'LicenseStateChangedEventArgs constructor',
        since: 7,
        parameters: [
          {
            name: 'callingRhinoCommonAllowed',
            summary: 'True when calling RhinoCommon will never raise Rhino.Runtime.NotLicesnedException; False otherwise.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'bool CallingRhinoCommonAllowed',
        summary: `True if RhinoCommon calls will never raise Rhino.Runtime.NotLicensedException.
     False otherwise`,
        since: 7,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'LicenseTypes',
    dataType: 3,
    summary: 'Different licensing modes that Rhino can run in',
    values: [
      {
        signature: 'Undefined = 0',
        summary: 'Licensing mode not define'
      },
      {
        signature: 'Standalone',
        summary: 'Standalone license installed on this computer.'
      },
      {
        signature: 'ZooAutoDetect',
        summary: 'Classic Zoo license with the Zoo server automatically detected at runtime.'
      },
      {
        signature: 'ZooManualDetect',
        summary: 'Classic Zoo license with the Zoo server specified by hostname or IP'
      },
      {
        signature: 'CloudZoo',
        summary: 'Cloud Zoo licenese'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'Mode',
    dataType: 3,
    summary: 'Contains enumerated constant values to represent Rhino\'s Runtime Mode.',
    values: [
      {
        signature: 'NormalMode = 0',
        summary: 'Running with a commercial, educational, or evaluation license ke'
      },
      {
        signature: 'ViewerMode',
        summary: 'Running as a viewer'
      },
      {
        signature: 'BetaMode',
        summary: 'Running as a Beta product'
      },
      {
        signature: 'InvalidMode = 100',
        summary: 'Invalid mode; this is an error condition'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'NamedParametersEventArgs',
    dataType: 1,
    summary: 'Dictionary style class used for named callbacks from C++ -> .NET',
    baseclass: 'EventArgs',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'NamedParametersEventArgs()',
        summary: 'Construct a new named parameter even args. You should dispose this class when you are done with it',
        since: 7
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'Dispose native resources',
        since: 7
      },
      {
        signature: 'void Set(string name,bool value)',
        summary: 'Set a bool value for a given key name',
        since: 7
      },
      {
        signature: 'void Set(string name,double value)',
        summary: 'Set a double value for a given key name',
        since: 7
      },
      {
        signature: 'void Set(string name,GeometryBase value)',
        summary: 'Set geometry for a given key name',
        since: 7
      },
      {
        signature: 'void Set(string name,IEnumerable<GeometryBase> values)',
        summary: 'Set a list of geometry for a given key name',
        since: 7
      },
      {
        signature: 'void Set(string name,IEnumerable<string> strings)',
        summary: 'Set a list of strings as a value for a given key name',
        since: 7
      },
      {
        signature: 'void Set(string name,int value)',
        summary: 'Set an int value for a given key name',
        since: 7
      },
      {
        signature: 'void Set(string name,Point3d value)',
        summary: 'Set a Point3d value for a given key name',
        since: 7
      },
      {
        signature: 'void Set(string name,string value)',
        summary: 'Set a string value for a given key name',
        since: 7
      },
      {
        signature: 'void Set(string name,uint value)',
        summary: 'Set an unsigned int for a given key name',
        since: 7
      },
      {
        signature: 'void SetWindowHandle(string name,IntPtr value)',
        summary: 'Set a HWND on Windows or NSView* on Mac',
        since: 7
      },
      {
        signature: 'bool TryGetBool(string name,bool value)',
        summary: 'Try to get a bool value for a given key name',
        since: 6.15
      },
      {
        signature: 'bool TryGetDouble(string name,double value)',
        summary: 'Try to get a double value for a given key name',
        since: 6.15
      },
      {
        signature: 'bool TryGetGeometry(string name,GeometryBase[] values)',
        since: 7
      },
      {
        signature: 'bool TryGetInt(string name,int value)',
        summary: 'Try to get an int value for a given key name',
        since: 6.15
      },
      {
        signature: 'bool TryGetPoint(string name,Point3d value)',
        summary: 'Try to get a Point3d value for a given key name',
        since: 7
      },
      {
        signature: 'bool TryGetRhinoObjects(string key,RhinoObject[] values)',
        summary: 'Get array of RhinoObject for the specified key',
        since: 7
      },
      {
        signature: 'bool TryGetString(string name,string value)',
        summary: 'Try to get a string value for a given key name',
        since: 6.15
      },
      {
        signature: 'bool TryGetStrings(string name,string[] value)',
        summary: 'Try to get a string value for a given key name',
        since: 7
      },
      {
        signature: 'bool TryGetUnsignedInt(string name,uint value)',
        summary: 'Try to get an unsigned int for a given key name',
        since: 7
      },
      {
        signature: 'bool TryGetWindowHandle(string name,IntPtr value)',
        summary: 'Gets a HWND on Windows or NSVIew* on Mac',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.Notifications',
    name: 'ButtonType',
    dataType: 3,
    summary: 'The type of button in a notification.',
    values: [
      {
        signature: 'CancelOrClose',
        summary: 'Denotes either the Cancel button as well as, on some platforms, the close button if present.'
      },
      {
        signature: 'Confirm',
        summary: 'The Confirm buttton.'
      },
      {
        signature: 'Alternate',
        summary: 'The Alternate button.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.Notifications',
    name: 'IAssemblyRestrictedObject',
    dataType: 4,
    summary: `A class that implements this interface signals its clients that its instances can
   only be modified by certain assemblies. This is useful in cases where only
   certain assemblies should be able to modify an object. The actual members of an 
   instance that are restricted are left to the discretion of the instance's class,
   and should be documented.`
  },
  {
    namespace: 'Rhino.Runtime.Notifications',
    name: 'Notification',
    dataType: 1,
    summary: `A Notification instance can be used to inform the user about various events. For
   a Notification instance to be displayed in Rhino, it must be added to the
   NotificationCenter. When added, it will be displayed in the
   Notifications panel in Rhino. A Notification contains 1 to 3 buttons that are 
   automatically wired to its ButtonClicked Action if it is not null. 
   The buttons are displayed when the Notification is shown modally by either the user 
   clicking on a particular notification in the Notifications panel, or by programatically 
   showing it using ShowModal.
   
   Currently, only process-wide notifications are
   supported; document specific notifications are not possible.
   
   Notification instances contain metadata that can be added, modified, or removed during
   its life. The metadata is important for LINQ queries and other patterns.
   For example, a particular action may require that multiple notifications be modified. 
   Thus, a LINQ query can be performed on the NotificationCenter using metadata
   to retrieve related Notification objects and modify them as a batch.
   
   Notification objects implement IAssemblyRestrictedObject. By default, a 
   Notification can be editedby any assembly, but explicitly specifing allowed assemblies 
   in the constructor changes this behavior.
   
   Notification objects are not thread-safe and should only be manipulated in UI thread.`,
    interfaces: ['INotifyPropertyChanged', 'Rhino.Runtime.Notifications.IAssemblyRestrictedObject'],
    constructors: [
      {
        signature: 'Notification()',
        summary: 'Creates a new instance that can be edited by any assembly.',
        since: 6
      },
      {
        signature: 'Notification(IEnumerable<Assembly> allowedAssemblies)',
        summary: 'Creates a new instance that can be edited by the given assemblies.',
        since: 6,
        parameters: [
          {
            name: 'allowedAssemblies',
            summary: `The assemblies that will be allowed to edit the instance.
     If None or empty, any assembly will be able to edit this notification.`
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'ICollection<Assembly> AllowedAssemblies',
        summary: 'The assemblies that can modify this instance.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string AlternateButtonTitle',
        summary: 'The localized title of the Alternate button.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Action<ButtonType> ButtonClicked',
        summary: 'An Action that will be invoked whenever a button for the notification is clicked or the notification is closed.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string CancelButtonTitle',
        summary: 'The localized title of the Cancel button.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string ConfirmButtonTitle',
        summary: 'The localized title of the Confirm button.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'DateTime DateUpdated',
        summary: 'The date the notification was last modified.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string Description',
        summary: 'The description of the notification. The description is displayed in the Notifications panel in Rhino.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string Message',
        summary: 'The message of the notification. The message is shown only when the instance is displayed modally. It should contain details about the notification.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'IDictionary<string, string> MetadataCopy',
        summary: 'A copy of all the metadata for this class.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Severity SeverityLevel',
        summary: 'The severity of the notification. Changing the severity of the notification may change the way Rhino chooses to display the Notifications panel.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Guid? ShowEventId',
        summary: 'A field used by Rhino for displaying notifications. Not intended for public use.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Title',
        summary: 'The title of the notification. The title is displayed when the notification is displayed modally in Rhino.',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static void ExecuteAssemblyProtectedCode(Action action)',
        summary: `If a Notification object is only allowed to be modified by certain
     assemblies, then any code that interacts with it must be wrapped around this method,
     or a InvalidOperationException will be thrown. For performance reasons,
     the code wrapped by this method should be kept as simple as possible.`,
        since: 6.3,
        parameters: [
          {
            name: 'action',
            summary: 'The code to run that modifies one or more notification objects'
          }
        ]
      },
      {
        signature: 'static TResult ExecuteAssemblyProtectedCode(Func<TResult> func)',
        summary: `If a Notification object is only allowed to be modified by certain
     assemblies, then any code that interacts with it must be wrapped around this method,
     or a InvalidOperationException will be thrown. For performance reasons,
     the code wrapped by this method should be kept as simple as possible.`,
        since: 6.3,
        parameters: [
          {
            name: 'func',
            summary: 'The code to run that modifies one or more notification objects'
          }
        ]
      },
      {
        signature: 'bool Editable()',
        summary: `Determines whether an assembly can modify the instance. Any code that modifies an assembly protected
     notification must be wrapped in a ExecuteAssemblyProtectedCode(Action) method.`,
        since: 6.3
      },
      {
        signature: 'void HideModal()',
        summary: 'Tells Rhino to hide the notification if it is being currently shown as a modal.',
        since: 6
      },
      {
        signature: 'bool RemoveMetadata(string key)',
        summary: 'Removes metadata from this instance.',
        since: 6,
        parameters: [
          {
            name: 'key',
            summary: 'The key of the metadata to remove.'
          }
        ],
        returns: 'True if the metada was removed; otherwise false.'
      },
      {
        signature: 'void ShowModal()',
        summary: 'Tells Rhino to display the notification modally.',
        since: 6
      },
      {
        signature: 'string ToString()',
        summary: 'Returns a readable string representation of the instance.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.Notifications',
    name: 'Notification.Severity',
    dataType: 3,
    summary: 'Determines the severity of a notification.',
    values: [
      {
        signature: 'Debug',
        summary: 'Least serious.'
      },
      {
        signature: 'Info',
        summary: 'Not serious.'
      },
      {
        signature: 'Warning',
        summary: 'Important.'
      },
      {
        signature: 'Serious',
        summary: 'Very important.'
      },
      {
        signature: 'Critical',
        summary: 'Extremely important.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.Notifications',
    name: 'NotificationButtonClickedArgs',
    dataType: 1,
    summary: 'Used when a button is clicked for a notification.',
    baseclass: 'EventArgs',
    constructors: [
      {
        signature: 'NotificationButtonClickedArgs(Notification notification,ButtonType buttonClicked)',
        summary: 'Creates a new instance.',
        since: 6,
        parameters: [
          {
            name: 'notification',
            summary: 'The notification whose button was clicked.'
          },
          {
            name: 'buttonClicked',
            summary: 'The button that was clicked.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'ButtonType ButtonClicked',
        summary: 'The button that was clicked.',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Notification Notification',
        summary: 'The notification whose button was clicked.',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.Notifications',
    name: 'NotificationCenter',
    dataType: 1,
    summary: `The NotificationCenter holds all Notification objects that are displayed in the Notifications panel by Rhino.
   
   The NotificationCenter is not thread-safe and should only be used in the UI thread.`
  },
  {
    namespace: 'Rhino.Runtime.Notifications',
    name: 'TrulyObservableOrderedSet',
    dataType: 1,
    summary: 'An ordered set that notifies its subscribers whenever one of its INotifyPropertyChanged elements raises its PropertyChanged event.',
    interfaces: ['IList<T>', 'INotifyCollectionChanged'],
    constructors: [
      {
        signature: 'TrulyObservableOrderedSet()',
        summary: 'Creates an empty instance.'
      },
      {
        signature: 'TrulyObservableOrderedSet(IEnumerable<T> items)',
        summary: 'Creates an instance with the given items.',
        parameters: [
          {
            name: 'items',
            summary: 'Items that the instance will contain. If there are duplicate items, they will be removed.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'int Count',
        summary: 'Returns the total number of items in the set.',
        property: ['get']
      },
      {
        signature: 'bool IsReadOnly',
        summary: 'Always returns false.',
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(T item)',
        summary: 'Adds an object to the end of the ordered set if the set does not already contain the item.',
        parameters: [
          {
            name: 'item',
            summary: 'The item to add.'
          }
        ]
      },
      {
        signature: 'void Clear()',
        summary: 'Clears the ordered set.'
      },
      {
        signature: 'bool Contains(T item)',
        summary: 'Determines whether an element is in the set.',
        parameters: [
          {
            name: 'item',
            summary: 'The item to check for inclusion.'
          }
        ],
        returns: 'True if the item is in the set; otherwise false.'
      },
      {
        signature: 'void CopyTo(T[] array,int arrayIndex)',
        summary: 'Copies the values of the set to an array.',
        parameters: [
          {
            name: 'array',
            summary: 'The array to copy the values to.'
          },
          {
            name: 'arrayIndex',
            summary: 'The index of the array to start the copy.'
          }
        ]
      },
      {
        signature: 'IEnumerator<T> GetEnumerator()',
        summary: 'Returns an enumerator that iterates through the set.'
      },
      {
        signature: 'int IndexOf(T item)',
        summary: 'Searches for the specified object and returns the zero-based index of the first occurrence.',
        parameters: [
          {
            name: 'item',
            summary: 'The item to locate.'
          }
        ],
        returns: 'The zero-based index of the first occurrence of item if found; otherwise -1.'
      },
      {
        signature: 'void Insert(int index,T item)',
        summary: 'Inserts an element at the specified index.',
        parameters: [
          {
            name: 'index',
            summary: 'The index to insert the element at.'
          },
          {
            name: 'item',
            summary: 'The item to insert.'
          }
        ]
      },
      {
        signature: 'bool Remove(T item)',
        summary: 'Removes an element from the set.',
        parameters: [
          {
            name: 'item',
            summary: 'The element to remove.'
          }
        ],
        returns: 'Returns True if the element was removed; otherwise returns false.'
      },
      {
        signature: 'void RemoveAt(int index)',
        summary: 'Removes an element at the specified index from the set.',
        parameters: [
          {
            name: 'index',
            summary: 'The index of the element to remove.'
          }
        ]
      },
      {
        signature: 'void Sort(Func<T, TKey> keySelector,bool descending)',
        summary: 'Sorts the set.',
        parameters: [
          {
            name: 'keySelector',
            summary: ''
          },
          {
            name: 'descending',
            summary: 'If true, the sort will happen in descending other; if false, it will happen in ascending order.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'NotLicensedException',
    dataType: 1,
    summary: `Exception thrown when calling functions in RhinoCommon and the
   application is executing without a license`,
    baseclass: 'Exception',
    constructors: [
      {
        signature: 'NotLicensedException()',
        summary: 'Default constructor',
        since: 7
      },
      {
        signature: 'NotLicensedException(string message)',
        summary: 'Create a new instance with a custom message',
        since: 7
      },
      {
        signature: 'NotLicensedException(string message,Exception inner)',
        summary: 'Create a new instance with a custom message and an inner exception',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'PythonCompiledCode',
    dataType: 1,
    summary: 'Represents scripting compiled code.',
    methods: [
      {
        signature: 'void Execute(PythonScript scope)',
        summary: 'Executes the script in a specific scope.',
        since: 5,
        parameters: [
          {
            name: 'scope',
            summary: 'The scope where the script should be executed.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'PythonScript',
    dataType: 1,
    summary: 'Represents a Python script.',
    properties: [
      {
        signature: 'int ContextId',
        summary: 'Gets or sets a context unique identified.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Action<string> Output',
        summary: `Gets or sets the Python script "print()" target.
     By default string output goes to the Rhino.RhinoApp.Write function.
     Set Output if you want to redirect the output from python to a different function
     while this script executes.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Command ScriptContextCommand',
        summary: 'Command associated with this script. Used for localiation',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'object ScriptContextDoc',
        summary: 'object set to variable held in scriptcontext.doc.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static void AddRuntimeAssembly(Assembly assembly)',
        summary: 'Add assembly to list of assemblies used by python',
        since: 7
      },
      {
        signature: 'static PythonScript Create()',
        summary: 'Constructs a new Python script context.',
        since: 5,
        returns: 'A new Python script, or None if none could be created. Rhino 4 always returns null.'
      },
      {
        signature: 'static System.Reflection.Assembly[] RuntimeAssemblies()',
        summary: `Get list of assemblies used by python for library browser and
     inclusion into the runtime`,
        since: 7
      },
      {
        signature: 'PythonCompiledCode Compile(string script)',
        summary: 'Compiles a class in a quick-to-execute proxy.',
        since: 5,
        parameters: [
          {
            name: 'script',
            summary: 'A string text.'
          }
        ],
        returns: 'A Python compiled code instance.'
      },
      {
        signature: 'bool ContainsVariable(string name)',
        summary: 'Determines if the main scripting context has a variable with a name.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'The variable name.'
          }
        ],
        returns: 'True if the variable is present.'
      },
      {
        signature: 'object CreateTextEditorControl(string script,Action<string> helpcallback)',
        summary: 'Creates a control where the user is able to type Python code.',
        since: 5,
        parameters: [
          {
            name: 'script',
            summary: 'A starting script.'
          },
          {
            name: 'helpcallback',
            summary: 'A method that is called when help is shown for a function, a class or a method.'
          }
        ],
        returns: 'A Windows Forms control.'
      },
      {
        signature: 'object EvaluateExpression(string statements,string expression)',
        summary: 'Evaluates statements and an expression in the main scripting context.',
        since: 5,
        parameters: [
          {
            name: 'statements',
            summary: 'One or several statements.'
          },
          {
            name: 'expression',
            summary: 'An expression.'
          }
        ],
        returns: 'The expression result.'
      },
      {
        signature: 'bool ExecuteFile(string path)',
        summary: 'Executes a Python file. The file is executed in a new, __main__ scope.',
        since: 5,
        parameters: [
          {
            name: 'path',
            summary: 'The path to the file.'
          }
        ],
        returns: 'True if the file executed. This method can throw scripting-runtime based exceptions.'
      },
      {
        signature: 'bool ExecuteFileInScope(string path)',
        summary: 'Executes a Python file in the calling script scope. All old variables are kept.',
        since: 7,
        parameters: [
          {
            name: 'path',
            summary: 'The path to the file.'
          }
        ],
        returns: 'True if the file executed. This method can throw scripting-runtime based exceptions.'
      },
      {
        signature: 'bool ExecuteScript(string script)',
        summary: 'Executes a Python string.',
        since: 5,
        parameters: [
          {
            name: 'script',
            summary: 'A Python text.'
          }
        ],
        returns: 'True if the file executed. This method can throw scripting-runtime based exceptions.'
      },
      {
        signature: 'string GetStackTraceFromException(Exception ex)',
        summary: 'Retrieves a meaningful representation of the call stack.',
        since: 5,
        parameters: [
          {
            name: 'ex',
            summary: 'An exception that was thrown by some of the methods in this class.'
          }
        ],
        returns: 'A string that represents the Python exception.'
      },
      {
        signature: 'object GetVariable(string name)',
        summary: 'Gets the object associated with a variable name in the main scripting context.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'A variable name.'
          }
        ],
        returns: 'The variable object.'
      },
      {
        signature: 'System.Collections.Generic.IEnumerable<string> GetVariableNames()',
        summary: 'Retrieves all variable names in the script.',
        since: 5,
        returns: 'An enumerable set with all names of the variables.'
      },
      {
        signature: 'void RemoveVariable(string name)',
        summary: 'Removes a defined variable from the main scripting context.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'The variable name.'
          }
        ]
      },
      {
        signature: 'void SetIntellisenseVariable(string name,object value)',
        summary: 'Sets a variable for runtime introspection.',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'A variable name.'
          },
          {
            name: 'value',
            summary: 'A variable value.'
          }
        ]
      },
      {
        signature: 'void SetupScriptContext(object doc)',
        summary: 'Setups the script context. Use a RhinoDoc instance unless unsure.',
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'Document.'
          }
        ]
      },
      {
        signature: 'void SetVariable(string name,object value)',
        summary: 'Sets a variable with a name and an object. Object can be None (Nothing in Visual Basic).',
        since: 5,
        parameters: [
          {
            name: 'name',
            summary: 'A valid variable name in Python.'
          },
          {
            name: 'value',
            summary: 'A valid value for that variable name.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'RdkNotLoadedException',
    dataType: 1,
    summary: 'Is thrown when the RDK is not loaded.',
    baseclass: 'Exception',
    constructors: [
      {
        signature: 'RdkNotLoadedException()',
        summary: 'Initializes a new instance of the RDK not loaded exception with a standard message.',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'IOAuth2Token',
    dataType: 4,
    summary: 'Represents an OAuth2 Token that can be used for authorization purposes.'
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'IOpenIDConnectToken',
    dataType: 4,
    summary: 'This class represents an OpenIDConnect token issued from an OpenID provider. The token is immutable.'
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'IRhinoAccountsManager',
    dataType: 4,
    summary: 'Performs various Rhino Accounts-related tasks.'
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'ProgressState',
    dataType: 3,
    summary: 'Describes the state of progress.',
    values: [
      {
        signature: 'AwaitingLogin',
        summary: 'The task is awaiting for the user to login.'
      },
      {
        signature: 'RetrievingTokens',
        summary: 'The task is now nogotiating with the remote server for auth tokens.'
      },
      {
        signature: 'Other',
        summary: 'Other'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'RhinoAccoountsProgressInfo',
    dataType: 1,
    summary: `This class is designed to convey the progress of an asynchronous operation through .NET's IProgress{T} interface. 
   It can be used by callers of such tasks to relay the tasks' progress, as well as useful metadata information that may be of interest.`,
    constructors: [
      {
        signature: 'RhinoAccoountsProgressInfo(ProgressState state,Dictionary<object, object> metadata,string customDescription)',
        summary: 'Creates a new instance.',
        parameters: [
          {
            name: 'state',
            summary: 'The state to report.'
          },
          {
            name: 'metadata',
            summary: 'Optional. Any metadata of interest that may be used by the caller of a task.'
          },
          {
            name: 'customDescription',
            summary: 'Optional. If a non-None value is passed, it will override the default description of the instance.'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'string Description',
        summary: 'A localized description of the state that may be shown to the user of the application.',
        property: ['get', 'set']
      },
      {
        signature: 'Dictionary<object, object> Metadata',
        summary: 'Any metadata of interest that may be used by the caller of a task.',
        property: ['get']
      },
      {
        signature: 'ProgressState State',
        summary: 'The state to report.',
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'RhinoAccountsAuthTokenMismatchException',
    dataType: 1,
    summary: 'Exception thrown when the currently logged in user is different from the newly logged in user.',
    baseclass: 'Rhino.Runtime.RhinoAccounts.RhinoAccountsException',
    constructors: [
      {
        signature: 'RhinoAccountsAuthTokenMismatchException(Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      },
      {
        signature: 'RhinoAccountsAuthTokenMismatchException(string message,Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'message',
            summary: 'The message of the exception.'
          },
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      },
      {
        signature: 'RhinoAccountsAuthTokenMismatchException(string currentUsername,string newUsername,Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'currentUsername',
            summary: 'The name of the currently logged in user.'
          },
          {
            name: 'newUsername',
            summary: 'The name of the newly logged in user.'
          },
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'RhinoAccountsCannotListenException',
    dataType: 1,
    summary: 'Exception thrown when there is no port available on the machine for Rhino to listen for Rhino Accounts\' response.',
    baseclass: 'Rhino.Runtime.RhinoAccounts.RhinoAccountsException',
    constructors: [
      {
        signature: 'RhinoAccountsCannotListenException(Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      },
      {
        signature: 'RhinoAccountsCannotListenException(string message,Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'message',
            summary: 'The message of the exception.'
          },
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'RhinoAccountsException',
    dataType: 1,
    summary: 'Base exception for all Rhino Accounts operations.',
    baseclass: 'Exception',
    constructors: [
      {
        signature: 'RhinoAccountsException(Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      },
      {
        signature: 'RhinoAccountsException(string message,Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'message',
            summary: 'The message of the exception.'
          },
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'RhinoAccountsGroup',
    dataType: 1,
    summary: 'Represents a Rhino Accounts group.',
    constructors: [
      {
        signature: 'RhinoAccountsGroup(string id,string name)',
        summary: 'Represents a group in Rhino Accounts. Groups are a collection of individual members that can share resources.'
      }
    ],
    properties: [
      {
        signature: 'string Id',
        summary: 'The id of the group. The id is unique to a group within Rhino Accounts.',
        property: ['get']
      },
      {
        signature: 'string Name',
        summary: 'The name of the group. The name can be changed at anytime by group members.',
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'RhinoAccountsInvalidResponseException',
    dataType: 1,
    summary: 'Exception thrown when the response returned by Rhino Accounts is not valid.',
    baseclass: 'Rhino.Runtime.RhinoAccounts.RhinoAccountsException',
    constructors: [
      {
        signature: 'RhinoAccountsInvalidResponseException(Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      },
      {
        signature: 'RhinoAccountsInvalidResponseException(string message,Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'message',
            summary: 'The message of the exception.'
          },
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'RhinoAccountsInvalidStateException',
    dataType: 1,
    summary: 'Occurs when the state returned by the Rhino Accounts server is not the same as the one sent to the server. It usually indicates the request has been tampered with.',
    baseclass: 'Rhino.Runtime.RhinoAccounts.RhinoAccountsException',
    constructors: [
      {
        signature: 'RhinoAccountsInvalidStateException(Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      },
      {
        signature: 'RhinoAccountsInvalidStateException(string message,Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'message',
            summary: 'The message of the exception.'
          },
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'RhinoAccountsInvalidTokenException',
    dataType: 1,
    summary: 'Exception thrown when the token returned by Rhino Accounts is not valid.',
    baseclass: 'Rhino.Runtime.RhinoAccounts.RhinoAccountsException',
    constructors: [
      {
        signature: 'RhinoAccountsInvalidTokenException(Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      },
      {
        signature: 'RhinoAccountsInvalidTokenException(string message,Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'message',
            summary: 'The message of the exception.'
          },
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'RhinoAccountsManager',
    dataType: 1,
    summary: 'Performs various Rhino Accounts-related tasks.',
    methods: [
      {
        signature: 'static void ExecuteProtectedCode(Action<SecretKey> protectedCode)',
        summary: `Any synchronous method in the IRhinoAccountsManager class must be executed within the function passed to this method,
     or an InvalidOperationException will be thrown.`,
        parameters: [
          {
            name: 'protectedCode',
            summary: `A function returning an awaitable task that has a SecretKey passed to it. You will need to pass this
     secret key to any method you wish to call within IRhinoAccountsManager.`
          }
        ]
      },
      {
        signature: 'static Task ExecuteProtectedCodeAsync(Func<SecretKey, Task> protectedCode)',
        summary: `Any asynchronous method in the IRhinoAccountsManager class must be executed within the function passed to this method,
     or an InvalidOperationException will be thrown.`,
        parameters: [
          {
            name: 'protectedCode',
            summary: `A function returning an awaitable task that has a SecretKey passed to it. You will need to pass this
     secret key to any method you wish to call within IRhinoAccountsManager.`
          }
        ]
      },
      {
        signature: 'static Task<Tuple<IOpenIDConnectToken, IOAuth2Token>> GetAuthTokensAsync(string clientId,string clientSecret,IEnumerable<string> scope,string prompt,int? maxAge,bool showUI,IProgress<RhinoAccoountsProgressInfo> progress,SecretKey secretKey,CancellationToken cancellationToken)',
        summary: 'Asynchronously retrieves auth tokens with the given criteria from the Rhino Accounts server.',
        parameters: [
          {
            name: 'clientId',
            summary: 'The unique id of the client registered in Rhino Accounts.'
          },
          {
            name: 'clientSecret',
            summary: 'The secret of the client registered in Rhino Accounts'
          },
          {
            name: 'scope',
            summary: 'The scope desired for the tokens. Valid scope values can be found in the Rhino Accounts documentation.'
          },
          {
            name: 'prompt',
            summary: 'The prompt of the request. See Rhino Accounts documentation for details. You may pass None if no prompt is desired.'
          },
          {
            name: 'maxAge',
            summary: 'The maxAge of the request. See Rhino Accounts documentation for details. You may pass None if no maxAge should be enforced.'
          },
          {
            name: 'showUI',
            summary: `True if the user should see a UI showing the progress of the operation and a way to cancel it, or False if the UI should not be displayed.
     If false, it is strongly recommended that you pass a  object and display your own UI to the user.`
          },
          {
            name: 'progress',
            summary: 'An object that will report the progress of the operation to the caller. If no progress is needed, you may pass null.'
          },
          {
            name: 'secretKey',
            summary: 'A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})'
          },
          {
            name: 'cancellationToken',
            summary: 'A token that can be used to signal that the operation should be cancelled.'
          }
        ],
        returns: 'The auth tokens requested.'
      },
      {
        signature: 'static Task<Tuple<IOpenIDConnectToken, IOAuth2Token>> GetAuthTokensAsync(string clientId,string clientSecret,SecretKey secretKey,CancellationToken cancellationToken)',
        summary: 'Asynchronously retrieves auth tokens with the given criteria from the Rhino Accounts server.',
        parameters: [
          {
            name: 'clientId',
            summary: 'The unique id of the client registered in Rhino Accounts.'
          },
          {
            name: 'clientSecret',
            summary: 'The secret of the client registered in Rhino Accounts'
          },
          {
            name: 'secretKey',
            summary: 'A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})'
          },
          {
            name: 'cancellationToken',
            summary: 'A token that can be used to signal that the operation should be cancelled.'
          }
        ],
        returns: 'The auth tokens requested.'
      },
      {
        signature: 'static Task RevokeAuthTokenAsync(IOAuth2Token oauth2Token,SecretKey secretKey,CancellationToken cancellationToken)',
        summary: 'Invalidates/revokes an IOAuth2Token object from the Rhino Accounts server.',
        parameters: [
          {
            name: 'oauth2Token',
            summary: 'The token to revoke.'
          },
          {
            name: 'secretKey',
            summary: 'A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})'
          },
          {
            name: 'cancellationToken',
            summary: 'A token that can be used to signal that the operation should be cancelled.'
          }
        ]
      },
      {
        signature: 'static Tuple<IOpenIDConnectToken, IOAuth2Token> TryGetAuthTokens(string clientId,IEnumerable<string> scope,SecretKey secretKey)',
        summary: 'Attempts to return cached auth tokens that match the given criteria if any have been stored in cache.',
        parameters: [
          {
            name: 'clientId',
            summary: 'The unique id of the client registered in Rhino Accounts.'
          },
          {
            name: 'scope',
            summary: 'The scope desired for the tokens. Valid scope values can be found in the Rhino Accounts documentation.'
          },
          {
            name: 'secretKey',
            summary: 'A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})'
          }
        ],
        returns: 'Cached tokens matching the exact criteria passed, or None if none can be found matching the criteria.'
      },
      {
        signature: 'static Tuple<IOpenIDConnectToken, IOAuth2Token> TryGetAuthTokens(string clientId,SecretKey secretKey)',
        summary: 'Attempts to return cached auth tokens that match the given criteria if any have been stored in cache.',
        parameters: [
          {
            name: 'clientId',
            summary: 'The unique id of the client registered in Rhino Accounts.'
          },
          {
            name: 'secretKey',
            summary: 'A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})'
          }
        ],
        returns: 'Cached tokens matching the exact criteria passed, or None if none can be found matching the criteria.'
      },
      {
        signature: 'static Task<IOpenIDConnectToken> UpdateOpenIDConnectTokenAsync(IOpenIDConnectToken currentToken,IOAuth2Token oauth2Token,SecretKey secretKey,CancellationToken cancellationToken)',
        summary: 'Updates an OpenID Connect token so that it contains the latest user information by contacting the Rhino Account\'s server userinfo endpoint using a compatible O',
        parameters: [
          {
            name: 'currentToken',
            summary: 'The existing OpenID Connect token that you wish to updated with the latest user information.'
          },
          {
            name: 'oauth2Token',
            summary: 'A valid OAuth2 token used for authorization. The OAuth2 token must have been issued together with the OpenID Connect token passed or a RhinoAccountsAuthTokenMismatchException will be thrown.'
          },
          {
            name: 'secretKey',
            summary: 'A special key that was handed to you in ExecuteProtectedCodeAsync(Func{SecretKey, Task})'
          },
          {
            name: 'cancellationToken',
            summary: 'A token that can be used to signal that the operation should be cancelled.'
          }
        ],
        returns: 'The updated OpenIDConnectToken based on the original token passed to this method.'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'RhinoAccountsOperationInProgressException',
    dataType: 1,
    summary: 'Exception thrown when there is already a Rhino Accounts operation taking place.',
    baseclass: 'Rhino.Runtime.RhinoAccounts.RhinoAccountsException',
    constructors: [
      {
        signature: 'RhinoAccountsOperationInProgressException(Assembly assembly,Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'assembly',
            summary: 'The assembly that is currently performing an operation.'
          },
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      },
      {
        signature: 'RhinoAccountsOperationInProgressException(string message,Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'message',
            summary: 'The message of the exception.'
          },
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'RhinoAccountsProxyException',
    dataType: 1,
    summary: 'Exception thrown when there is a problem with a proxy setting during a Rhino Accounts operation.',
    baseclass: 'Rhino.Runtime.RhinoAccounts.RhinoAccountsException',
    constructors: [
      {
        signature: 'RhinoAccountsProxyException(Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      },
      {
        signature: 'RhinoAccountsProxyException(string message,Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'message',
            summary: 'The message of the exception.'
          },
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'RhinoAccountsServerException',
    dataType: 1,
    summary: 'Exception thrown when the Rhino Accounts server returned an unsuccessful HTTP response with a code of 400 or greater.',
    baseclass: 'Rhino.Runtime.RhinoAccounts.RhinoAccountsException',
    constructors: [
      {
        signature: 'RhinoAccountsServerException(Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      },
      {
        signature: 'RhinoAccountsServerException(string message,Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'message',
            summary: 'The message of the exception.'
          },
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'RhinoAccountsServerNotReachableException',
    dataType: 1,
    summary: 'Exception thrown when the Rhino Accounts server cannot be reached due to a network problem.',
    baseclass: 'Rhino.Runtime.RhinoAccounts.RhinoAccountsException',
    constructors: [
      {
        signature: 'RhinoAccountsServerNotReachableException(Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      },
      {
        signature: 'RhinoAccountsServerNotReachableException(string message,Exception innerException)',
        summary: 'Generates a new instance of the exception.',
        parameters: [
          {
            name: 'message',
            summary: 'The message of the exception.'
          },
          {
            name: 'innerException',
            summary: 'The inner exception.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime.RhinoAccounts',
    name: 'SecretKey',
    dataType: 1,
    summary: `An instance of this of this class is given to the function you pass to ExceuteProtectedCodeAsync and
   must be passed to any method of the RhinoAccountsManager that requires it. Failure to do so will throw an InvalidOperationException.`
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'RiskyAction',
    dataType: 1,
    summary: 'Defines risky actions that need to be reported in crash exceptions',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'RiskyAction(string description,string file,string member,int line)',
        summary: 'Always create this in a using block',
        since: 6
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'IDisposable implementation',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'Skin',
    dataType: 1,
    summary: `Represents a customized environment that changes the appearance of Rhino.
   Skin DLLs must contain a single class that derives from the Skin class.`,
    properties: [
      {
        signature: 'static Skin ActiveSkin',
        summary: `Any time Rhino is running there is at most one skin being used (and
     possibly no skin).  If a RhinoCommon based Skin class is being used, use
     ActiveSkin to get at the instance of this Skin class. May return null
     if no Skin is being used or if the skin is not a RhinoCommon based skin.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'PersistentSettings Settings',
        summary: 'Gets access to the skin persistent settings.',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'TextFields',
    dataType: 1,
    summary: 'This Class Processes Text Field Functions',
    methods: [
      {
        signature: 'static double Area(string id)',
        summary: 'Returns the area value for a selected object id',
        since: 7
      },
      {
        signature: 'static double Area(string id,string unitSystem)',
        summary: 'Returns the area value for a selected object id in a specified unit system',
        since: 7
      },
      {
        signature: 'static string BlockAttributeText(string key,string prompt,string defaultValue)',
        summary: 'User text associated with a block',
        since: 7
      },
      {
        signature: 'static int BlockInstanceCount(string instanceDefinitionNameOrId)',
        summary: `Returns the number of block instances found in the document
       with the specified block definition name or the instance reference id.`,
        since: 7
      },
      {
        signature: 'static string BlockInstanceName(string blockId)',
        summary: 'Returns the block definition name of a block instance',
        since: 7
      },
      {
        signature: 'static double CurveLength(string id)',
        summary: 'Get length of a curve given a string id',
        since: 7
      },
      {
        signature: 'static double CurveLength(string id,string unitSystem)',
        summary: `Get length of a curve given a string id in a specified unit system.
       UnitSystem enum as string`,
        since: 7
      },
      {
        signature: 'static string Date()',
        summary: 'Current date',
        since: 7
      },
      {
        signature: 'static string Date(string dateFormat)',
        summary: 'Current date in a specified format',
        since: 7
      },
      {
        signature: 'static string Date(string dateFormat,string languageId)',
        summary: 'Current Date in a specific format and language',
        since: 7
      },
      {
        signature: 'static string DateModified()',
        summary: 'Date the document was last edited',
        since: 7
      },
      {
        signature: 'static string DateModified(string dateFormat)',
        summary: 'Date the document was last edited in a specified format',
        since: 7
      },
      {
        signature: 'static string DateModified(string dateFormat,string languageId)',
        summary: 'Date the document was last edited in a specific format and language',
        since: 7
      },
      {
        signature: 'static string DetailScale(string detailId,string scaleFormat)',
        summary: 'Returns a detail views scale',
        since: 7
      },
      {
        signature: 'static string DocumentText(string key)',
        summary: 'Return document user string for a given key',
        since: 7
      },
      {
        signature: 'static string FileName()',
        summary: 'Return full path to the document',
        since: 7
      },
      {
        signature: 'static string FileName(string options)',
        summary: 'Return path to the document',
        since: 7
      },
      {
        signature: 'static InstanceAttributeField[] GetInstanceAttributeFields(InstanceDefinition idef)',
        since: 7
      },
      {
        signature: 'static InstanceAttributeField[] GetInstanceAttributeFields(string str)',
        summary: `Gets an array of block attribute definitions associated with a
     TextObject.`,
        since: 7,
        parameters: [
          {
            name: 'str',
            summary: 'TextObject to check for block attribute definitions'
          }
        ],
        returns: `Will return a empty array if text is None or there is no attributes
     otherwise; returns a list of one or more attribute definitions embedded
     in the text string.`
      },
      {
        signature: 'static InstanceAttributeField[] GetInstanceAttributeFields(TextObject text)',
        summary: `Gets an array of block attribute definitions associated with a
     TextObject.`,
        since: 7,
        parameters: [
          {
            name: 'text',
            summary: 'TextObject to check for block attribute definitions'
          }
        ],
        returns: `Will return a empty array if text is None or there is no attributes
     otherwise; returns a list of one or more attribute definitions embedded
     in the text string.`
      },
      {
        signature: 'static string LayerName(string layerId)',
        summary: 'Returns the name of a layer based on the layers guid',
        since: 7
      },
      {
        signature: 'static string LayoutUserText(string key)',
        summary: 'Returns a value from the active layouts user text strings for the specified key.',
        since: 7
      },
      {
        signature: 'static string LayoutUserText(string layoutId,string key)',
        summary: 'Returns user text value from a layout id Key',
        since: 7
      },
      {
        signature: 'static string ModelUnits()',
        since: 7
      },
      {
        signature: 'static string Notes()',
        summary: 'Notes for a RhinoDoc',
        since: 7
      },
      {
        signature: 'static int NumPages()',
        summary: 'Number of layout pages in a document',
        since: 7
      },
      {
        signature: 'static string ObjectLayer(string id)',
        summary: 'Return an object\'s layer name',
        since: 7
      },
      {
        signature: 'static string ObjectName(string id)',
        summary: 'Return an object\'s name',
        since: 7
      },
      {
        signature: 'static double PageHeight()',
        summary: 'Return the current layout page height in the layout units',
        since: 7
      },
      {
        signature: 'static string PageName()',
        summary: 'Return the current layout page name',
        since: 7
      },
      {
        signature: 'static string PageName(string id)',
        summary: 'Return the page name for the specified View ID',
        since: 7
      },
      {
        signature: 'static int PageNumber()',
        summary: 'Returns the current layouts page number',
        since: 7
      },
      {
        signature: 'static double PageWidth()',
        summary: 'Return the current layout page width in the layout units',
        since: 7
      },
      {
        signature: 'static string PaperName()',
        summary: `Returns the layouts selected paper name
       example Letter / A4 / A6`,
        since: 7
      },
      {
        signature: 'static string PointCoordinate(string pointId,string axis)',
        summary: 'returns the location of a 3d point',
        since: 7
      },
      {
        signature: 'static string UserText(string id,string key)',
        summary: 'User text associated with an object, block or layout',
        since: 7
      },
      {
        signature: 'static string UserText(string id,string key,string prompt)',
        summary: 'User text associated with an object, block or layout',
        since: 7
      },
      {
        signature: 'static string UserText(string id,string key,string prompt,string defaultValue)',
        summary: 'User text associated with an object, block or layout',
        since: 7
      },
      {
        signature: 'static double Volume(string id)',
        summary: 'Returns the volume for the selected object id',
        since: 7
      },
      {
        signature: 'static double Volume(string id,string unitSystem)',
        summary: 'Returns volume for selected object id in the specified unit system',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'TextFields.InstanceAttributeField',
    dataType: 1,
    constructors: [
      {
        signature: 'TextFields.InstanceAttributeField(string key,string prompt,string defaultValue)',
        summary: 'Block attribute defintion.',
        since: 7,
        parameters: [
          {
            name: 'key',
            summary: 'Attribute key'
          },
          {
            name: 'prompt',
            summary: 'Prompt displayed by the UI when inserting a block'
          },
          {
            name: 'defaultValue',
            summary: 'Default value used when inserting a block'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'string DefaultValue',
        summary: 'Default value used when inserting a block',
        since: 7,
        property: ['get']
      },
      {
        signature: 'string Key',
        summary: 'Attribute key',
        since: 7,
        property: ['get']
      },
      {
        signature: 'string Prompt',
        summary: 'Prompt displayed by the UI when inserting a block',
        since: 7,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'ViewCaptureWriter',
    dataType: 1,
    summary: 'Callback system used by SVG and PDF exporter to generate documents',
    constructors: [
      {
        signature: 'ViewCaptureWriter(double dpi,Size pageSize)',
        since: 6
      }
    ],
    methods: [
      {
        signature: 'void Draw(IntPtr constPtrPrintInfo,RhinoDoc doc)',
        since: 6.15
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'ViewCaptureWriter.PathPoint',
    dataType: 2,
    properties: [
      {
        signature: 'PointF Location',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'PointType PointType',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'ViewCaptureWriter.Pen',
    dataType: 1,
    properties: [
      {
        signature: 'Color Color',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'float Width',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'ViewCaptureWriter.PointType',
    dataType: 3,
    values: [
      {
        signature: 'Move'
      },
      {
        signature: 'Line'
      },
      {
        signature: 'CubicBezier'
      },
      {
        signature: 'Close'
      }
    ]
  },
  {
    namespace: 'Rhino.Runtime',
    name: 'ZooClientParameters',
    dataType: 1,
    summary: `ZooClientParameters is a read-only set of parameters that control
   the flow of licensing inside ZooClient. Because this class flows through a number of
   other classes, functions, and UI, it is read-only so that inadvertent changes are not
   made to the data as it propagates from the caller.`,
    constructors: [
      {
        signature: 'ZooClientParameters(Guid productGuid,Guid licenseGuid,string productTitle,int productBuildType,LicenseCapabilities capabilities,string licenseEntryTextMask,string productPath,object parentWindow,LicenseTypes selectedLicenseType,ValidateProductKeyDelegate validateProductKey,OnLeaseChangedDelegate onLeaseChangedDelegate,VerifyLicenseKeyDelegate verifyLicenseKeyDelegate,VerifyPreviousVersionLicenseDelegate verifyPreviousVersionLicenseKeyDelegate)',
        summary: 'ZooClientParameters Constructor',
        since: 6,
        parameters: [
          {
            name: 'productGuid',
            summary: `Guid used by ZooClient to identify the plug-in requesting a license from ZooClient. This Guid may be used by different versions of the
     plug-in. If different licenses are used by different versions of the plug-in, the plug-in must also specify a LicenseGuid.`
          },
          {
            name: 'licenseGuid',
            summary: `Guid used by ZooClient to identify the license saved by ZooClient. This differs from ProductGuid because different versions of a plug-in
     with the same Plug-in ID may need different licenses.`
          },
          {
            name: 'productTitle',
            summary: 'Title of product displayed in user interface'
          },
          {
            name: 'productBuildType',
            summary: ''
          },
          {
            name: 'capabilities',
            summary: 'Enum that declares whether this product supports evalation, licensing, purchasing, and cloud zoo'
          },
          {
            name: 'licenseEntryTextMask',
            summary: 'Text mask used to limit input. EG: RH50-AAAA-AAAA-AAAA-AAAA-AAAA'
          },
          {
            name: 'productPath',
            summary: 'Full path to DLL implementing product'
          },
          {
            name: 'parentWindow',
            summary: 'Object used to parent UI DLLs'
          },
          {
            name: 'selectedLicenseType',
            summary: 'Type of license currently used by this product'
          },
          {
            name: 'validateProductKey',
            summary: 'Delegate called to validate the structure of a license key'
          },
          {
            name: 'onLeaseChangedDelegate',
            summary: 'Delegate called when a cloud zoo lease changes'
          },
          {
            name: 'verifyLicenseKeyDelegate',
            summary: 'Delegate called to verify the structure of a license key'
          },
          {
            name: 'verifyPreviousVersionLicenseKeyDelegate',
            summary: 'Delegate called to verify the structure of an upgrade license key'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'LicenseCapabilities Capabilities',
        summary: 'LicenseCapabilities flags that set options for how licenses can be obtained for this product',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string LicenseEntryTextMask',
        summary: 'Text mask in the form @"RH4A-AAAA-AAAA-AAAA-AAAA-AAAA" that informs the user what numbers they are looking for',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid LicenseGuid',
        summary: `Guid used by ZooClient to identify the license saved by ZooClient. This differs from ProductGuid because different versions of a plug-in
     with the same Plug-in ID may need different licenses.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'OnLeaseChangedDelegate OnLeaseChanged',
        summary: 'Delegate called by ZooClient when a cloud zoo lease is changed',
        since: 6,
        property: ['get']
      },
      {
        signature: 'object ParentWindow',
        summary: 'Parent window assigned to any licensing dialogs that appear. If null, the Rhino main window is used.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'int ProductBuildType',
        summary: 'Product build type. Must be one of LicenseBuildType values.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'Guid ProductGuid',
        summary: `Guid used by ZooClient to identify the plug-in requesting a license from ZooClient. This Guid may be used by different versions of the
     plug-in. If different licenses are used by different versions of the plug-in, the plug-in must also specify a LicenseGuid.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'string ProductPath',
        summary: 'Path to the application calling ZooClient',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string ProductTitle',
        summary: 'Title of the product, "Rhinoceros 6" for example.',
        since: 6,
        property: ['get']
      },
      {
        signature: 'LicenseTypes SelectedLicenseType',
        summary: 'License type selected by default when user is prompted to enter a license key',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'ValidateResult VerifyLicenseKey(string licenseKey,string validationCode,DateTime validationCodeInstallDate,bool gracePeriodExpired,LicenseData licenseData)',
        summary: 'Called by GetLicense to ensure that the license key entered by the user is legitimate and can be used.',
        since: 6,
        parameters: [
          {
            name: 'licenseKey',
            summary: 'License key string entered by user'
          },
          {
            name: 'validationCode',
            summary: 'Validation code entered by user (only if a previous call to VerifyLicenseKey set LicenseData.RequiresOnlineValidation to true).'
          },
          {
            name: 'validationCodeInstallDate',
            summary: 'Date that validation code was entered by user (only if a previous call to VerifyLicenseKey set LicenseData.RequiresOnlineValidation to true).'
          },
          {
            name: 'gracePeriodExpired',
            summary: 'Date by which license validation must complete successfully.'
          },
          {
            name: 'licenseData',
            summary: 'Output parameter where return data about the license is set.'
          }
        ]
      },
      {
        signature: 'bool VerifyPreviousVersionLicense(string license,string previousVersionLicense,string errorMessage)',
        summary: `When a caller calls GetLicense, ZooClient may call VerifyPreviousVersionLicense to ensure 
     previousVersionLicense is legitimate and can be used to upgrade license.`,
        since: 6,
        parameters: [
          {
            name: 'license',
            summary: 'License key for current product. This was returned by a previous call to VerifyLicenseKey or ValidateProductKey.'
          },
          {
            name: 'previousVersionLicense',
            summary: 'License key entered by user to show upgrade eligibility for license.'
          },
          {
            name: 'errorMessage',
            summary: 'Error message to be displayed to user if something isn\'t correct.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'RuntimeEnvironment',
    dataType: 3,
    summary: `ON::RuntimeEnvironment identifies a runtime environment (operating system).
   This value is saved in binary archives so appropriate adjustments
   to resources provided by runtime environments, like fonts, can be made
   when an archive created in one runtime environment is used in another.`,
    values: [
      {
        signature: 'Unset =  0',
        summary: 'ON::RuntimeEnvironment::Unset indicates no runtime is set.'
      },
      {
        signature: 'None = 1',
        summary: `ON::RuntimeEnvironment::None indicates no runtime.
     This is a different condition from ON::Runtime::Unset.`
      },
      {
        signature: 'Windows = 2',
        summary: 'ON::RuntimeEnvironment::Windows indicates some version of Microsoft Windows.'
      },
      {
        signature: 'Apple = 3',
        summary: 'ON::RuntimeEnvironment::Apple indicates some version of Apple OS X or iOS.'
      },
      {
        signature: 'Android =  4',
        summary: 'ON::RuntimeEnvironment::Android indicates some version of Google Android.'
      },
      {
        signature: 'Linux = 5',
        summary: 'ON::RuntimeEnvironment::Linux indicates some version of Linux.'
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'ScaleValue.ScaleStringFormat',
    dataType: 3,
    summary: `Specifies prefered formats for automatically
   created string descriptions of a scale value.`,
    values: [
      {
        signature: 'None = 0',
        summary: 'No preference for automatically created string descriptions of a scale value.'
      },
      {
        signature: 'RatioFormat = 1',
        summary: 'Prefer the ratio format using a colon, like "1:4" or "4:1".'
      },
      {
        signature: 'EquationFormat = 2',
        summary: 'Prefer the equation format using an equal sign, like "1 = 4" or "4 = 1".'
      },
      {
        signature: 'FractionFormat = 3',
        summary: 'Prefer the fraction format using a slash, like "1/4" or "4/1".'
      },
      {
        signature: 'Unset = 0xFF',
        summary: `ON_ScaleValue::ScaleStringFormat::Unset is used to indicate no preference is set.
     This condition is different from ON_ScaleValue::ScaleStringFormat::None.`
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'Symbols',
    dataType: 1,
    summary: 'Characters used for different \'drafting style\' symbols',
    properties: [
      {
        signature: 'static char DegreeSymbol',
        summary: 'Degree symbol used for angles',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static char DiameterSymbol',
        summary: 'Diameter symbol',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static char PlusMinusSymbol',
        summary: 'Plus-Minus tolerance symbol',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static char RadiusSymbol',
        summary: 'Radius symbol',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'CollapsibleSectionHolderImpl',
    dataType: 1,
    interfaces: ['IMPL_CALLBACKS', 'IDisposable'],
    constructors: [
      {
        signature: 'CollapsibleSectionHolderImpl(ICollapsibleSectionHolder client)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static ICollapsibleSectionHolder Find(IntPtr cpp)',
        since: 6
      },
      {
        signature: 'static ICollapsibleSectionHolder NewNativeWrapper(IntPtr cpp)',
        since: 6
      },
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'bool IsSameObject(IntPtr cpp)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'CollapsibleSectionImpl',
    dataType: 1,
    interfaces: ['IMPL_CALLBACKS', 'IDisposable'],
    constructors: [
      {
        signature: 'CollapsibleSectionImpl(ICollapsibleSection section)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6,
        property: ['get']
      },
      {
        signature: 'IRdkViewModel ViewModel',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static void CreateHostedSection(ICollapsibleSection section)',
        since: 6
      },
      {
        signature: 'static ICollapsibleSection Find(IntPtr cpp)',
        since: 6
      },
      {
        signature: 'static ICollapsibleSection GetSibling(ICollapsibleSection section,Guid siblingSectionId)',
        since: 6
      },
      {
        signature: 'static ICollapsibleSection[] GetSiblings(ICollapsibleSection section)',
        since: 6
      },
      {
        signature: 'static ICollapsibleSection NewNativeWrapper(IntPtr cpp)',
        since: 6
      },
      {
        signature: 'void __InternalSetParent(IntPtr parent)',
        since: 6
      },
      {
        signature: 'void Dispose()',
        since: 6
      },
      {
        signature: 'bool IsSameObject(IntPtr cpp)',
        since: 6
      },
      {
        signature: 'void ReplaceClient(ICollapsibleSection client)',
        since: 6
      }
    ],
    events: [
      {
        signature: 'DataChanged',
        since: 6
      },
      {
        signature: 'ViewModelActivated',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'CollapsibleSectionImpl.Factory',
    dataType: 1,
    baseclass: 'Rhino.UI.Controls.FactoryBase'
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'CollapsibleSectionViewModel',
    dataType: 1,
    summary: `Derive from this class to implement your own view model that wraps around a built
   in implementation of IRdkViewModel.  Use GetData etc to implement your properties.`,
    baseclass: 'Rhino.UI.Controls.IRdkViewModel',
    constructors: [
      {
        signature: 'CollapsibleSectionViewModel(ICollapsibleSection section)',
        summary: 'Construct from your section - the view model should be a member of the section',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Commit(Guid uuidDataType)',
        since: 6
      },
      {
        signature: 'void Discard(Guid uuidDataType)',
        since: 6
      },
      {
        signature: 'object GetData(Guid uuidDataType,bool bForWrite,bool bAutoChangeBracket)',
        summary: 'Call for an interface to data',
        since: 6
      },
      {
        signature: 'UndoRecord UndoHelper(string description)',
        summary: 'Helper function to ease the use of undo records',
        since: 6,
        returns: 'Return the undo record'
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls.DataSource',
    name: 'EventArgs',
    dataType: 1,
    baseclass: 'System.EventArgs',
    properties: [
      {
        signature: 'Guid DataType',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls.DataSource',
    name: 'EventInfoArgs',
    dataType: 1,
    baseclass: 'System.EventArgs',
    properties: [
      {
        signature: 'Guid DataType',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'IntPtr EventInfoPtr',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls.DataSource',
    name: 'ProviderIds',
    dataType: 1,
    properties: [
      {
        signature: 'static Guid ContentChildSlot',
        since: 6.1,
        property: ['get']
      },
      {
        signature: 'static Guid ContentDatabase',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ContentDisplayCollection',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ContentEditorSettings',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ContentLookup',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ContentParam',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ContentPreviewRendered',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ContentSelection',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ContentUIs',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ContentUpdatePreviewMarkersEventInfo',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid CurrentEnvironment',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid Decals',
        since: 6.5,
        property: ['get']
      },
      {
        signature: 'static Guid Dithering',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid GroundPlane',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid ImageFileInfo',
        since: 6.2,
        property: ['get']
      },
      {
        signature: 'static Guid LinearWorkflow',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid NamedItem',
        since: 6.1,
        property: ['get']
      },
      {
        signature: 'static Guid NewContentControlAssignBy',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid NullGuid',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid PreviewSettings',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid RdkEdit',
        since: 6.5,
        property: ['get']
      },
      {
        signature: 'static Guid RdkRendering',
        since: 6.8,
        property: ['get']
      },
      {
        signature: 'static Guid RdkRenderingGamma',
        since: 6.8,
        property: ['get']
      },
      {
        signature: 'static Guid RdkRenderingPostEffectDOF',
        since: 6.1,
        property: ['get']
      },
      {
        signature: 'static Guid RdkRenderingPostEffectFog',
        since: 6.1,
        property: ['get']
      },
      {
        signature: 'static Guid RdkRenderingPostEffectGlare',
        since: 6.1,
        property: ['get']
      },
      {
        signature: 'static Guid RdkRenderingPostEffectGlow',
        since: 6.1,
        property: ['get']
      },
      {
        signature: 'static Guid RdkRenderingPostEffects',
        since: 6.8,
        property: ['get']
      },
      {
        signature: 'static Guid RdkRenderingProgress',
        since: 6.8,
        property: ['get']
      },
      {
        signature: 'static Guid RdkRenderingToneMapping',
        since: 6.8,
        property: ['get']
      },
      {
        signature: 'static Guid RhinoSettings',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid SelectionNavigator',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid Skylight',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid Sun',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid Undo',
        since: 6.11,
        property: ['get']
      },
      {
        signature: 'static Guid UndoRecord',
        since: 6,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'Delegates',
    dataType: 1
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'FactoryBase',
    dataType: 1,
    summary: 'Base class for CollapsibleSection and ViewModel factories used by the RDK UI',
    methods: [
      {
        signature: 'static Type[] Register()',
        summary: `Call this function during startup of current assembly to load classes with factory creation support
         are registed`,
        since: 6
      },
      {
        signature: 'static Type[] Register(PlugIn plugin)',
        summary: `Call this function during the startup of your plug-in to ensure that all classes that support factory creation
         are registed`,
        since: 6
      },
      {
        signature: 'IntPtr Get(Guid id)',
        summary: 'Override this method to return a new instance of your class for the given ID',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'ICollapsibleSection',
    dataType: 4
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'ICollapsibleSectionHolder',
    dataType: 4
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'IHasCppImplementation',
    dataType: 4
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'InternalRdkViewModel.EventPriority',
    dataType: 3,
    values: [
      {
        signature: 'Low'
      },
      {
        signature: 'Normal'
      },
      {
        signature: 'High'
      },
      {
        signature: 'RealTime'
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'InternalRdkViewModel.NewUndoRecord',
    dataType: 1,
    interfaces: ['IDisposable']
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'InternalRdkViewModel.UndoHelper',
    dataType: 1,
    interfaces: ['IDisposable']
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'InternalRdkViewModelFactory',
    dataType: 1,
    baseclass: 'Rhino.UI.Controls.FactoryBase'
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'IRdkViewModel',
    dataType: 4
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'IWindow',
    dataType: 4
  },
  {
    namespace: 'Rhino.UI.Controls.Thumbnaillist',
    name: 'ThumbnailList',
    dataType: 1,
    baseclass: 'Eto.Forms.Panel',
    interfaces: ['IThumbnailList'],
    constructors: [
      {
        signature: 'ThumbnailList()'
      }
    ],
    properties: [
      {
        signature: 'ContentEditingContext CEC',
        property: ['get', 'set']
      },
      {
        signature: 'bool Created',
        property: ['get']
      },
      {
        signature: 'bool Enabled',
        property: ['get', 'set']
      },
      {
        signature: 'string EnglishCaption',
        property: ['get']
      },
      {
        signature: 'bool Hidden',
        property: ['get', 'set']
      },
      {
        signature: 'IntPtr HolderParent',
        property: ['set']
      },
      {
        signature: 'string LocalCaption',
        property: ['get']
      },
      {
        signature: 'bool Shown',
        property: ['get', 'set']
      },
      {
        signature: 'RdkThumbnaillistViewModel ViewModel',
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(IRhRdkThumbnail t)'
      },
      {
        signature: 'void Clear()'
      },
      {
        signature: 'Rhino.Render.RenderContent ContentFromThumbId(Guid uuidThumb)'
      },
      {
        signature: 'IRhRdkThumbnail Get(Guid u)'
      },
      {
        signature: 'void GetGridMetrics(int w,int h,int ox,int oy)'
      },
      {
        signature: 'IRhRdkContentThumbnailList_Sizes GetSize()'
      },
      {
        signature: 'void GetStatisticsHeaderHeight()'
      },
      {
        signature: 'IRhRdkThumbnailList_Modes Mode()'
      },
      {
        signature: 'void Move(Rectangle rect,bool bRepaint,bool bRepaintNC)'
      },
      {
        signature: 'bool PropagateSelectedAppearance()'
      },
      {
        signature: 'void SaveMetaDataToDocument()'
      },
      {
        signature: 'Rhino.Render.PreviewAppearance SelectedAppearance()'
      },
      {
        signature: 'void SetClientText(string w)'
      },
      {
        signature: 'void SetCustomBitmapSize(int w,int h)'
      },
      {
        signature: 'void SetMode(IRhRdkThumbnailList_Modes m,bool b)'
      },
      {
        signature: 'void SetSearchPattern(string w)'
      },
      {
        signature: 'void SetSettingsPath(string w)'
      },
      {
        signature: 'void SetShowLabels(bool b)'
      },
      {
        signature: 'IRhRdkThumbnailList_Shapes Shape()'
      },
      {
        signature: 'bool ShowLabels()'
      },
      {
        signature: 'Guid UUID()'
      },
      {
        signature: 'void ViewModelActivated()'
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls.Thumbnaillist',
    name: 'ThumbnailList.IHandler',
    dataType: 4
  },
  {
    namespace: 'Rhino.UI.Controls.ThumbnailUI',
    name: 'IRhRdkContentThumbnail',
    dataType: 4
  },
  {
    namespace: 'Rhino.UI.Controls.ThumbnailUI',
    name: 'IRhRdkContentThumbnailList_Sizes',
    dataType: 3,
    values: [
      {
        signature: 'Tiny',
        summary: 'Tiny thumbnails.'
      },
      {
        signature: 'Small',
        summary: 'Small thumbnails.'
      },
      {
        signature: 'Medium',
        summary: 'Medium thumbnails.'
      },
      {
        signature: 'Large',
        summary: 'Large thumbnails.'
      },
      {
        signature: 'Custom',
        summary: 'Custom-sized thumbnails.'
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls.ThumbnailUI',
    name: 'IRhRdkThumbnail',
    dataType: 4
  },
  {
    namespace: 'Rhino.UI.Controls.ThumbnailUI',
    name: 'IRhRdkThumbnailList',
    dataType: 4
  },
  {
    namespace: 'Rhino.UI.Controls.ThumbnailUI',
    name: 'IRhRdkThumbnailList_Modes',
    dataType: 3,
    values: [
      {
        signature: 'Grid',
        summary: 'Big thumbnails like Explorer icon mode (default).'
      },
      {
        signature: 'List',
        summary: 'Small thumbnails and info on right like Explorer report mode.'
      },
      {
        signature: 'Tree',
        summary: 'Tree view mode.'
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls.ThumbnailUI',
    name: 'IRhRdkThumbnailList_Shapes',
    dataType: 3,
    values: [
      {
        signature: 'Square',
        summary: 'Square thumbnails.'
      },
      {
        signature: 'Wide',
        summary: 'Wide thumbnails.'
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls.ThumbnailUI',
    name: 'ThumbData',
    dataType: 1,
    properties: [
      {
        signature: 'List<ThumbData> Children',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'RenderContent Content',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Guid Id',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Bitmap Image',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string Intensity',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool InUse',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Color4f> InUseColor',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'string Name',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'ThumbData Parent',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'PreviewAppearance PreviewAppearance',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool Selected',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'List<string> Tags',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool TopLevel',
        since: 6,
        property: ['get']
      },
      {
        signature: 'string Type',
        since: 6,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'static int GetPreviewHeigth(Sizes thumb_size,Shapes shape)',
        since: 6
      },
      {
        signature: 'static int GetPreviewWidth(Sizes thumb_size,Shapes shape)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls.ThumbnailUI',
    name: 'Thumbnail',
    dataType: 1,
    baseclass: 'Rhino.UI.Controls.ThumbnailUI.IRhRdkThumbnail',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'Thumbnail(IntPtr pRdkThumbnail)',
        summary: 'Constructor for Thumbnail',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'IntPtr CppPointer',
        summary: 'Thumbnail c++ pointer',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Dib(Bitmap dibOut)',
        since: 6
      },
      {
        signature: 'void Dispose()',
        summary: 'Dispose for Thumbnail',
        since: 6
      },
      {
        signature: 'System.Drawing.Bitmap GetDib()',
        since: 6
      },
      {
        signature: 'void GetDisplayRect(RectangleF rectOut)',
        since: 6
      },
      {
        signature: 'Guid Id()',
        since: 6
      },
      {
        signature: 'bool IsHot()',
        since: 6
      },
      {
        signature: 'bool IsSelected()',
        since: 6
      },
      {
        signature: 'string Label()',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls.ThumbnailUI',
    name: 'ThumbnailViewModelFactory',
    dataType: 1,
    baseclass: 'Rhino.UI.Controls.InternalRdkViewModelFactory',
    constructors: [
      {
        signature: 'ThumbnailViewModelFactory()',
        since: 6
      }
    ],
    methods: [
      {
        signature: 'IntPtr Get(Guid id)',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Controls',
    name: 'UndoRecord',
    dataType: 1,
    summary: 'Undo Record',
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'UndoRecord(string description,IRdkViewModel viewModel)',
        summary: 'UndoRecord Constructor',
        since: 6
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        summary: 'UndoRecord Dispose',
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'CursorStyle',
    dataType: 3,
    summary: 'Standard mouse cursors in Rhino',
    values: [
      {
        signature: 'Default = 0'
      },
      {
        signature: 'Wait = 1',
        summary: 'Wait'
      },
      {
        signature: 'CrossHair = 2'
      },
      {
        signature: 'Hand = 3'
      },
      {
        signature: 'Rotate = 4'
      },
      {
        signature: 'Magnify = 5'
      },
      {
        signature: 'ArrowCopy = 6',
        summary: 'arrow with +'
      },
      {
        signature: 'CrosshairCopy = 7'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'Dialogs',
    dataType: 1,
    methods: [
      {
        signature: 'static void KillSplash()',
        summary: 'Destroy the splash screen if it is being displayed.',
        since: 5
      },
      {
        signature: 'static void SetCustomColorDialog(EventHandler<GetColorEventArgs> handler)',
        since: 5
      },
      {
        signature: 'static void ShowAboutDialog(bool forceSimpleDialog)',
        since: 6
      },
      {
        signature: 'static bool[] ShowCheckListBox(string title,string message,IList items,IList<bool> checkState)',
        summary: 'Displays Rhino\'s check list box.',
        since: 5,
        parameters: [
          {
            name: 'title',
            summary: 'The dialog title.'
          },
          {
            name: 'message',
            summary: 'The dialog message.'
          },
          {
            name: 'items',
            summary: 'A list of items to show.'
          },
          {
            name: 'checkState',
            summary: 'A list of true/False boolean values.'
          }
        ],
        returns: 'An array or boolean values determining if the user checked the corresponding box. On error, null.'
      },
      {
        signature: 'static bool ShowColorDialog(Color color)',
        summary: 'Display Rhino\'s color selection dialog.',
        since: 5,
        parameters: [
          {
            name: 'color',
            summary: '[in/out] Default color for dialog, and will receive new color if function returns true.'
          }
        ],
        returns: 'True if the color changed. False if the color has not changed or the user pressed cancel.'
      },
      {
        signature: 'static bool ShowColorDialog(Color color,bool includeButtonColors,string dialogTitle)',
        summary: 'Display Rhino\'s color selection dialog.',
        since: 5,
        parameters: [
          {
            name: 'color',
            summary: '[in/out] Default color for dialog, and will receive new color if function returns true.'
          },
          {
            name: 'includeButtonColors',
            summary: 'Display button face and text options at top of named color list.'
          },
          {
            name: 'dialogTitle',
            summary: 'The title of the dialog.'
          }
        ],
        returns: 'True if the color changed. False if the color has not changed or the user pressed cancel.'
      },
      {
        signature: 'static bool ShowColorDialog(Color4f color,bool allowAlpha)',
        summary: 'Displays the standard modal color picker dialog for floating point colors.',
        since: 5,
        parameters: [
          {
            name: 'color',
            summary: 'The initial color to set the picker to and also accepts the user\'s choice.'
          },
          {
            name: 'allowAlpha',
            summary: 'Specifies if the color picker should allow changes to the alpha channel or not.'
          }
        ],
        returns: 'True if a color was picked, False if the user canceled the picker dialog.'
      },
      {
        signature: 'static bool ShowColorDialog(IWin32Window parent,Color4f color,bool allowAlpha)',
        summary: 'Displays the standard modal color picker dialog for floating point colors.',
        since: 5,
        parameters: [
          {
            name: 'parent',
            summary: 'Parent window for this dialog, should always pass this if calling from a form or user control.'
          },
          {
            name: 'color',
            summary: 'The initial color to set the picker to and also accepts the user\'s choice.'
          },
          {
            name: 'allowAlpha',
            summary: 'Specifies if the color picker should allow changes to the alpha channel or not.'
          }
        ],
        returns: 'True if a color was picked, False if the user canceled the picker dialog.'
      },
      {
        signature: 'static bool ShowColorDialog(object parent,Color4f color,bool allowAlpha)',
        summary: 'Displays the standard modal color picker dialog for floating point colors.',
        since: 6,
        parameters: [
          {
            name: 'parent',
            summary: 'Parent window for this dialog, should always pass this if calling from a form or user control.'
          },
          {
            name: 'color',
            summary: 'The initial color to set the picker to and also accepts the user\'s choice.'
          },
          {
            name: 'allowAlpha',
            summary: 'Specifies if the color picker should allow changes to the alpha channel or not.'
          }
        ],
        returns: 'True if a color was picked, False if the user canceled the picker dialog.'
      },
      {
        signature: 'static bool ShowColorDialog(object parent,Color4f color,bool allowAlpha,OnColorChangedEvent colorCallback)',
        summary: 'Displays the standard modal color picker dialog for floating point colors.',
        since: 6,
        parameters: [
          {
            name: 'parent',
            summary: 'Parent window for this dialog, should always pass this if calling from a form or user control.'
          },
          {
            name: 'color',
            summary: 'The initial color to set the picker to and also accepts the user\'s choice.'
          },
          {
            name: 'allowAlpha',
            summary: 'Specifies if the color picker should allow changes to the alpha channel or not.'
          },
          {
            name: 'colorCallback',
            summary: `May be optionally passed to ShowColorDialog and will get called when
       the color value changes in the color dialog.`
          }
        ],
        returns: 'True if a color was picked, False if the user canceled the picker dialog.'
      },
      {
        signature: 'static object ShowComboListBox(string title,string message,IList items)',
        summary: 'Displays Rhino\'s combo list box.',
        since: 5,
        parameters: [
          {
            name: 'title',
            summary: 'The dialog title.'
          },
          {
            name: 'message',
            summary: 'The dialog message.'
          },
          {
            name: 'items',
            summary: 'A list of items to show.'
          }
        ],
        returns: 'selected item.None if the user canceled.'
      },
      {
        signature: 'static int ShowContextMenu(IEnumerable<string> items,Point screenPoint,IEnumerable<int> modes)',
        summary: 'Creates an ETO ContextMenu from an array of strings. Use the modes array to enable/disable menu items',
        since: 5
      },
      {
        signature: 'static bool ShowEditBox(string title,string message,string defaultText,bool multiline,string text)',
        summary: 'Displays Rhino\'s string edit box.',
        since: 5,
        parameters: [
          {
            name: 'title',
            summary: 'The dialog title.'
          },
          {
            name: 'message',
            summary: 'The dialog message.'
          },
          {
            name: 'defaultText',
            summary: 'The defautl text.'
          },
          {
            name: 'multiline',
            summary: 'Set True for multi line editing.'
          },
          {
            name: 'text',
            summary: 'The modified text.'
          }
        ],
        returns: 'True of OK was clicked, False otherwise.'
      },
      {
        signature: 'static object ShowLineTypes(string title,string message,RhinoDoc doc)',
        summary: 'Displays Rhino\'s LineType list box.',
        since: 6.7,
        parameters: [
          {
            name: 'title',
            summary: 'The dialog title.'
          },
          {
            name: 'message',
            summary: 'The dialog message.'
          },
          {
            name: 'doc',
            summary: 'The active document.'
          }
        ],
        returns: 'The id of the selected item if successful, None on cancel.'
      },
      {
        signature: 'static object ShowListBox(string title,string message,IList items)',
        summary: 'Displays Rhino\'s list box.',
        since: 5,
        parameters: [
          {
            name: 'title',
            summary: 'The dialog title.'
          },
          {
            name: 'message',
            summary: 'The dialog message.'
          },
          {
            name: 'items',
            summary: 'A list of items to show.'
          }
        ],
        returns: 'The selected item if successful, None on cancel.'
      },
      {
        signature: 'static object ShowListBox(string title,string message,IList items,object selectedItem)',
        summary: 'Displays Rhino\'s list box.',
        since: 5,
        parameters: [
          {
            name: 'title',
            summary: 'The dialog title.'
          },
          {
            name: 'message',
            summary: 'The dialog message.'
          },
          {
            name: 'items',
            summary: 'A list of items to show.'
          },
          {
            name: 'selectedItem',
            summary: 'The item to preselect.'
          }
        ],
        returns: 'The selected item if successful, None on cancel.'
      },
      {
        signature: 'static ShowMessageResult ShowMessage(object parent,string message,string title,ShowMessageButton buttons,ShowMessageIcon icon,ShowMessageDefaultButton defaultButton,ShowMessageOptions options,ShowMessageMode mode)',
        summary: 'Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.',
        since: 6,
        parameters: [
          {
            name: 'parent',
            summary: 'Parent window'
          },
          {
            name: 'message',
            summary: 'Message box text content.'
          },
          {
            name: 'title',
            summary: 'Message box title text.'
          },
          {
            name: 'buttons',
            summary: 'Which buttons to display in the message box.'
          },
          {
            name: 'icon',
            summary: 'Which icon to display in the message box.'
          },
          {
            name: 'defaultButton',
            summary: 'Which button is the default button.'
          },
          {
            name: 'options',
            summary: 'Additional message box options.'
          },
          {
            name: 'mode',
            summary: 'The modality of the message box.'
          }
        ],
        returns: 'One of the ShowMessageBoxResult values.'
      },
      {
        signature: 'static ShowMessageResult ShowMessage(string message,string title)',
        summary: 'Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.',
        since: 6,
        parameters: [
          {
            name: 'message',
            summary: 'Message box text content.'
          },
          {
            name: 'title',
            summary: 'Message box title text.'
          }
        ],
        returns: 'One of the ShowMessageBoxResult values.'
      },
      {
        signature: 'static ShowMessageResult ShowMessage(string message,string title,ShowMessageButton buttons,ShowMessageIcon icon)',
        summary: 'Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.',
        since: 6,
        parameters: [
          {
            name: 'message',
            summary: 'Message box text content.'
          },
          {
            name: 'title',
            summary: 'Message box title text.'
          },
          {
            name: 'buttons',
            summary: 'Which buttons to display in the message box.'
          },
          {
            name: 'icon',
            summary: 'Which icon to display in the message box.'
          }
        ],
        returns: 'One of the ShowMessageBoxResult values.'
      },
      {
        signature: 'static System.Windows.Forms.DialogResult ShowMessageBox(string message,string title)',
        summary: 'Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.',
        since: 5
      },
      {
        signature: 'static System.Windows.Forms.DialogResult ShowMessageBox(string message,string title,MessageBoxButtons buttons,MessageBoxIcon icon)',
        summary: 'Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.',
        since: 5
      },
      {
        signature: 'static string[] ShowMultiListBox(string title,string message,IList<string> items,IList<string> defaults)',
        summary: 'Displays Rhino\'s multiple selection list box.',
        since: 5.12,
        parameters: [
          {
            name: 'title',
            summary: 'The dialog title.'
          },
          {
            name: 'message',
            summary: 'The dialog message.'
          },
          {
            name: 'items',
            summary: 'A list of items to show.'
          },
          {
            name: 'defaults',
            summary: 'The items to preselect.'
          }
        ],
        returns: 'The selected items if successful, None on cancel.'
      },
      {
        signature: 'static bool ShowNumberBox(string title,string message,double number)',
        summary: 'Displays Rhino\'s number edit box.',
        since: 5,
        parameters: [
          {
            name: 'title',
            summary: 'The dialog title.'
          },
          {
            name: 'message',
            summary: 'The dialog message.'
          },
          {
            name: 'number',
            summary: 'The default and return value.'
          }
        ],
        returns: 'True of OK was clicked, False otherwise.'
      },
      {
        signature: 'static bool ShowNumberBox(string title,string message,double number,double minimum,double maximum)',
        summary: 'Displays Rhino\'s number edit box.',
        since: 5,
        parameters: [
          {
            name: 'title',
            summary: 'The dialog title.'
          },
          {
            name: 'message',
            summary: 'The dialog message.'
          },
          {
            name: 'number',
            summary: 'The default and return value.'
          },
          {
            name: 'minimum',
            summary: 'The minimum allowable value.'
          },
          {
            name: 'maximum',
            summary: 'The maximum allowable value.'
          }
        ],
        returns: 'True of OK was clicked, False otherwise.'
      },
      {
        signature: 'static string[] ShowPropertyListBox(string title,string message,IList items,IList<string> values)',
        summary: 'Displays Rhino\'s property list box.',
        since: 5,
        parameters: [
          {
            name: 'title',
            summary: 'The dialog title.'
          },
          {
            name: 'message',
            summary: 'The dialog message.'
          },
          {
            name: 'items',
            summary: 'A list of property namss.'
          },
          {
            name: 'values',
            summary: 'A list of property values.'
          }
        ],
        returns: 'A list of property values if successful, None otherwise.'
      },
      {
        signature: 'static bool ShowSelectLayerDialog(int layerIndex,string dialogTitle,bool showNewLayerButton,bool showSetCurrentButton,bool initialSetCurrentState)',
        summary: 'Displays Rhino\'s single layer selection dialog.',
        since: 5,
        parameters: [
          {
            name: 'layerIndex',
            summary: `Initial layer for the dialog, and will receive selected
       layer if function returns DialogResult.OK.`
          },
          {
            name: 'dialogTitle',
            summary: 'The dialog title.'
          },
          {
            name: 'showNewLayerButton',
            summary: 'True if the new layer button will be visible.'
          },
          {
            name: 'showSetCurrentButton',
            summary: 'True if the set current button will be visible.'
          },
          {
            name: 'initialSetCurrentState',
            summary: 'True if the current state will be initially set.'
          }
        ],
        returns: 'True if the dialog was closed with the OK button. False if the dialog was closed with escape.'
      },
      {
        signature: 'static bool ShowSelectLinetypeDialog(int linetypeIndex,bool displayByLayer)',
        summary: 'Displays Rhino\'s single linetype selection dialog.',
        since: 6,
        parameters: [
          {
            name: 'linetypeIndex',
            summary: `Initial linetype for the dialog, and will receive selected
       linetype if function returns true.`
          },
          {
            name: 'displayByLayer',
            summary: 'Displays the "ByLayer" linetype in the list. Defaults to false.'
          }
        ],
        returns: 'True if the dialog was closed with the OK button. False if the dialog was closed with escape.'
      },
      {
        signature: 'static bool ShowSelectMultipleLayersDialog(IEnumerable<int> defaultLayerIndices,string dialogTitle,bool showNewLayerButton,int[] layerIndices)',
        since: 5.9,
        returns: 'True if the dialog was closed with the OK button. False if the dialog was closed with escape.'
      },
      {
        signature: 'static System.Windows.Forms.DialogResult ShowSemiModal(Form form)',
        summary: `Show a windows form that is modal in the sense that this function does not return until
       the form is closed, but also allows for interaction with other elements of the Rhino
       user interface.`,
        since: 5,
        parameters: [
          {
            name: 'form',
            summary: 'The form must have buttons that are assigned to the "AcceptButton" and "CancelButton".'
          }
        ],
        returns: 'One of the System.Windows.Forms.DialogResult values.'
      },
      {
        signature: 'static bool ShowSunDialog(Sun sun)',
        summary: 'Show the tabbed sun dialog.',
        since: 6,
        returns: 'Returns True if the user clicked OK, or False if the user cancelled.'
      },
      {
        signature: 'static void ShowTextDialog(string message,string title)',
        summary: 'Display a text dialog similar to the dialog used for the "What" command.',
        since: 5,
        parameters: [
          {
            name: 'message',
            summary: 'Text to display as the message content.'
          },
          {
            name: 'title',
            summary: 'Test to display as the form title.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'DistanceDisplayMode',
    dataType: 3,
    values: [
      {
        signature: 'Decimal = 0'
      },
      {
        signature: 'Fractional = 1'
      },
      {
        signature: 'FeetInches = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'DrawingUtilities',
    dataType: 1,
    summary: 'RhinoCommon Drawing Utilities',
    methods: [
      {
        signature: 'static Bitmap BitmapFromIconResource(string resourceName,Assembly assembly)',
        summary: `Load a Icon from an embedded resource and convert it to a bitmap of the
     specified size.  Will look for a icon image that is greater than or
     equal to the requested size, if all images are less than the requested
     size the largest image will be used.`,
        since: 6.12,
        parameters: [
          {
            name: 'resourceName',
            summary: ''
          },
          {
            name: 'assembly',
            summary: `The assembly containing the manifest resource, will use the calling
     assembly if null.`
          }
        ]
      },
      {
        signature: 'static Bitmap BitmapFromIconResource(string resourceName,Size bitmapSize,Assembly assembly)',
        summary: `Load a Icon from an embedded resource and convert it to a bitmap of the
     specified size.  Will look for a icon image that is greater than or
     equal to the requested size, if all images are less than the requested
     size the largest image will be used.`,
        since: 6,
        parameters: [
          {
            name: 'resourceName',
            summary: ''
          },
          {
            name: 'bitmapSize',
            summary: 'Desired bitmap size'
          },
          {
            name: 'assembly',
            summary: `The assembly containing the manifest resource, will use the calling
     assembly if null.`
          }
        ]
      },
      {
        signature: 'static Bitmap CreateMeshPreviewImage(IEnumerable<Mesh> meshes,IEnumerable<Color> colors,Size size)',
        summary: 'Creates a preview image of one or more meshs.',
        since: 6,
        parameters: [
          {
            name: 'meshes',
            summary: 'The meshes.'
          },
          {
            name: 'colors',
            summary: 'The draw colors, one for each mesh.'
          },
          {
            name: 'size',
            summary: 'The size of the preview image.'
          }
        ],
        returns: 'A bitmap if successful, None othewise.'
      },
      {
        signature: 'static Bitmap CreateMeshPreviewImage(Mesh mesh,Color color,Size size)',
        summary: 'Creates a preview image of a mesh.',
        since: 6,
        parameters: [
          {
            name: 'mesh',
            summary: 'The mesh.'
          },
          {
            name: 'color',
            summary: 'The draw color.'
          },
          {
            name: 'size',
            summary: 'The size of the preview image.'
          }
        ],
        returns: 'A bitmap if successful, None othewise.'
      },
      {
        signature: 'static Icon IconFromResource(string resourceName,Assembly assembly)',
        summary: 'Load a Icon from an embedded resource.',
        since: 6,
        parameters: [
          {
            name: 'resourceName',
            summary: 'The case-sensitive name of the icon manifest resource being requested.'
          },
          {
            name: 'assembly',
            summary: `The assembly containing the manifest resource, will use the calling
     assembly if null.`
          }
        ],
        returns: 'The Icon resource if found and loaded otherwise null.'
      },
      {
        signature: 'static Icon IconFromResource(string resourceName,Size size,Assembly assembly)',
        summary: 'Load a Icon from an embedded resource.',
        since: 6,
        parameters: [
          {
            name: 'resourceName',
            summary: 'The case-sensitive name of the icon manifest resource being requested.'
          },
          {
            name: 'size',
            summary: 'The desired size of the icon.'
          },
          {
            name: 'assembly',
            summary: `The assembly containing the manifest resource, will use the calling
     assembly if null.`
          }
        ],
        returns: 'The Icon resource if found and loaded otherwise null.'
      },
      {
        signature: 'static Image ImageFromResource(string resourceName,Assembly assembly)',
        summary: 'Load a Image from an embedded resource.',
        since: 6,
        parameters: [
          {
            name: 'resourceName',
            summary: 'The case-sensitive name of the image manifest resource being requested.'
          },
          {
            name: 'assembly',
            summary: `The assembly containing the manifest resource, will use the calling
     assembly if null.`
          }
        ],
        returns: 'The Image resource if found and loaded otherwise null.'
      },
      {
        signature: 'static Bitmap LoadBitmapWithScaleDown(string iconName,int sizeDesired,Assembly assembly)',
        summary: `Loads an icon from an embedded resource and converts it to a bitmap.
     If the icon is not a standard size, this function scales down a larger
     image.`,
        since: 6,
        parameters: [
          {
            name: 'iconName',
            summary: 'The case-sensitive name of the icon manifest resource being requested.'
          },
          {
            name: 'sizeDesired',
            summary: 'The desired size, in pixels, of the icon.'
          },
          {
            name: 'assembly',
            summary: 'The assembly containing the manifest resource.'
          }
        ],
        returns: 'The icon converted to a bitmap if successful, None otherwise.'
      },
      {
        signature: 'static Icon LoadIconWithScaleDown(string iconName,int sizeDesired,Assembly assembly)',
        summary: `Loads an icon from an embedded resource.
     If the icon is not a standard size, this function scales down a larger
     image.`,
        since: 6,
        parameters: [
          {
            name: 'iconName',
            summary: 'The case-sensitive name of the icon manifest resource being requested.'
          },
          {
            name: 'sizeDesired',
            summary: 'The desired size, in pixels, of the icon.'
          },
          {
            name: 'assembly',
            summary: 'The assembly containing the manifest resource.'
          }
        ],
        returns: 'The icon if successful, None otherwise.'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'Fonts.Size',
    dataType: 3,
    summary: 'Size for UI font.',
    values: [
      {
        signature: 'Small',
        summary: '0.8 x Normal'
      },
      {
        signature: 'Normal',
        summary: '1.0 x Normal'
      },
      {
        signature: 'Large',
        summary: '1.2 x Normal'
      },
      {
        signature: 'Title',
        summary: '2.0 x Normal'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'Fonts.Style',
    dataType: 3,
    summary: 'Style for UI font.',
    values: [
      {
        signature: 'Regular = 0',
        summary: 'Normal'
      },
      {
        signature: 'Bold = 1',
        summary: 'Bold'
      },
      {
        signature: 'Italic = 2',
        summary: 'Italic'
      },
      {
        signature: 'Underline = 4',
        summary: 'Underline'
      },
      {
        signature: 'Strikeout = 8',
        summary: 'Strikeout'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'GetColorEventArgs',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'bool IncludeButtonColors',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Color InputColor',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Color SelectedColor',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Title',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Gumball',
    name: 'GumballAppearanceSettings',
    dataType: 1,
    constructors: [
      {
        signature: 'GumballAppearanceSettings()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'int ArcThickness',
        summary: 'in pixels.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int ArrowHeadLength',
        summary: 'in pixels.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int ArrowHeadWidth',
        summary: 'in pixels.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int AxisThickness',
        summary: 'in pixels.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color ColorMenuButton',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color ColorX',
        summary: 'Default is Red.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color ColorY',
        summary: 'Default is Green.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Color ColorZ',
        summary: 'Default is Blue.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int FreeTranslate',
        summary: `When FreeTranslate is 1, the center translation control can be dragged
     in any direction and moves the object the gumball controls. When
     FreeTranslate is 2, the center translation control can be dragged in any
     direction and moves the object the gumball itself. The default value is 2.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int MenuDistance',
        summary: 'Distance of menu ball from center.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool MenuEnabled',
        summary: `When MenuEnabled is true, the menu "button" is drawn on the gumball.
     The default setting is true.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int MenuSize',
        summary: 'Radius of menu circle.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int PlanarTranslationGripCorner',
        summary: 'in pixels.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int PlanarTranslationGripSize',
        summary: 'in pixels.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int Radius',
        summary: 'in pixels.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool RelocateEnabled',
        summary: `When RelocateEnabled is true, the user can reposition the gumball by
     tapping the control key while dragging.  Once the repostion drag is
     terminated by releasing the/ mouse button, ordinary editing resumes.
     The default setting is true.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool RotateXEnabled',
        summary: `When RotateX is true, the X rotation control is available. The default
     setting is true.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool RotateYEnabled',
        summary: `When RotateY is true, the Y rotation control is available. The default
     setting is true.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool RotateZEnabled',
        summary: `When RotateZ is true, the Z rotation control is available. The default
     setting is true.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int ScaleGripSize',
        summary: 'in pixels.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ScaleXEnabled',
        summary: `When ScaleXEnabled is true, the X scale control is available. The
     default setting is true.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ScaleYEnabled',
        summary: `When ScaleYEnabled is true, the Y scale control is available. The
     default setting is true.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool ScaleZEnabled',
        summary: `When ScaleZEnabled is true, the Z scale control is available. The
     default setting is true.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool TranslateXEnabled',
        summary: `TranslateXEnabled is true, the X axis translation control is available.
     The default setting is true.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool TranslateXYEnabled',
        summary: `When TranslateXY is true, the XY plane translation control is available
     in appropriate views. The default setting is true.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool TranslateYEnabled',
        summary: `TranslateYEnabled is true, the Y axis translation control is available.
     The default setting is true.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool TranslateYZEnabled',
        summary: `When TranslateYZ is true, the YZ plane translation control is available
     in appropriate views. The default setting is true.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool TranslateZEnabled',
        summary: `TranslateZEnabled is true, the Z axis translation control is available.
     The default setting is true.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool TranslateZXEnabled',
        summary: `When TranslateZX is true, the ZX plane translation control is available
     in appropriate views. The default setting is true.`,
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Gumball',
    name: 'GumballDisplayConduit',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'GumballDisplayConduit()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'GumballObject BaseGumball',
        summary: 'Starting location.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool Enabled',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'GumballObject Gumball',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Transform GumballTransform',
        summary: `The gumball transformation is the transformation calculated by comparing
     the current gumball to the starting BaseGumball.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool InRelocate',
        since: 5,
        property: ['get']
      },
      {
        signature: 'GumballPickResult PickResult',
        summary: 'The inital mouse down event sets PickResult.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Transform PreTransform',
        summary: `The pre-transform is a transformation that needs to be applied before
     the gumball transformation.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Transform TotalTransform',
        summary: 'The total transformation is GumballTransform * PreTransform.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void CheckShiftAndControlKeys()',
        since: 5
      },
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'bool PickGumball(PickContext pickContext,GetPoint getPoint)',
        since: 5
      },
      {
        signature: 'void SetBaseGumball(GumballObject gumball)',
        summary: 'Contents of the gumball are copied to the base gumball of this class.',
        since: 5,
        parameters: [
          {
            name: 'gumball',
            summary: 'The gumball source.'
          }
        ]
      },
      {
        signature: 'void SetBaseGumball(GumballObject gumball,GumballAppearanceSettings appearanceSettings)',
        summary: 'Contents of the gumball are copied to the base gumball of this class.',
        since: 5,
        parameters: [
          {
            name: 'gumball',
            summary: 'The gumball source.'
          },
          {
            name: 'appearanceSettings',
            summary: 'The gumball appearance and behavior settings.'
          }
        ]
      },
      {
        signature: 'bool UpdateGumball(Point3d point,Line worldLine)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Gumball',
    name: 'GumballFrame',
    dataType: 2,
    properties: [
      {
        signature: 'Plane Plane',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'Vector3d ScaleGripDistance',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'GumballScaleMode ScaleMode',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Gumball',
    name: 'GumballMode',
    dataType: 3,
    summary: 'Transformation modes for gumballs.',
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'Menu  = 1',
        summary: 'Gumball menu button was picked.'
      },
      {
        signature: 'TranslateFree = 2',
        summary: 'Unconstrained translation.'
      },
      {
        signature: 'TranslateX = 3',
        summary: 'Translation along a single axis.'
      },
      {
        signature: 'TranslateY = 4',
        summary: 'Translation along a single axis.'
      },
      {
        signature: 'TranslateZ = 5',
        summary: 'Translation along a single axis.'
      },
      {
        signature: 'TranslateXY = 6',
        summary: 'Translation in a plane.'
      },
      {
        signature: 'TranslateYZ = 7',
        summary: 'Translation in a plane.'
      },
      {
        signature: 'TranslateZX = 8',
        summary: 'Translation in a plane.'
      },
      {
        signature: 'ScaleX = 9',
        summary: 'Scale along a single axis.'
      },
      {
        signature: 'ScaleY = 10',
        summary: 'Scale along a single axis.'
      },
      {
        signature: 'ScaleZ = 11',
        summary: 'Scale along a single axis.'
      },
      {
        signature: 'ScaleXY = 12',
        summary: 'Scale in a plane.'
      },
      {
        signature: 'ScaleYZ = 13',
        summary: 'Scale in a plane.'
      },
      {
        signature: 'ScaleZX = 14',
        summary: 'Scale in a plane.'
      },
      {
        signature: 'RotateX = 15',
        summary: 'Rotation around a single axis.'
      },
      {
        signature: 'RotateY = 16',
        summary: 'Rotation around a single axis.'
      },
      {
        signature: 'RotateZ = 17',
        summary: 'Rotation around a single axis.'
      },
      {
        signature: 'ExtrudeX = 18',
        summary: 'Extrusion along a single axis.'
      },
      {
        signature: 'ExtrudeY = 19',
        summary: 'Extrusion along a single axis.'
      },
      {
        signature: 'ExtrudeZ = 20',
        summary: 'Extrusion along a single axis.'
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Gumball',
    name: 'GumballObject',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'GumballObject()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'GumballFrame Frame',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'void Dispose()',
        since: 5
      },
      {
        signature: 'bool SetFromArc(Arc arc)',
        since: 5
      },
      {
        signature: 'bool SetFromBoundingBox(BoundingBox boundingBox)',
        since: 5
      },
      {
        signature: 'bool SetFromBoundingBox(Plane frame,BoundingBox frameBoundingBox)',
        summary: 'Sets the gumball bounding box with respect to a frame.',
        since: 5,
        parameters: [
          {
            name: 'frame',
            summary: 'The frame.'
          },
          {
            name: 'frameBoundingBox',
            summary: 'Bounding box with respect to frame.'
          }
        ],
        returns: `True if input is valid and gumball is set. False if input is not valid.
     In this case, gumball is set to the default.`
      },
      {
        signature: 'bool SetFromCircle(Circle circle)',
        since: 5
      },
      {
        signature: 'bool SetFromCurve(Curve curve)',
        since: 5
      },
      {
        signature: 'bool SetFromEllipse(Ellipse ellipse)',
        since: 5
      },
      {
        signature: 'bool SetFromExtrusion(Extrusion extrusion)',
        since: 5
      },
      {
        signature: 'bool SetFromHatch(Hatch hatch)',
        since: 5
      },
      {
        signature: 'bool SetFromLight(Light light)',
        since: 5
      },
      {
        signature: 'bool SetFromLine(Line line)',
        since: 5
      },
      {
        signature: 'bool SetFromPlane(Plane plane)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Gumball',
    name: 'GumballPickResult',
    dataType: 1,
    properties: [
      {
        signature: 'GumballMode Mode',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void SetToDefault()',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.UI.Gumball',
    name: 'GumballScaleMode',
    dataType: 3,
    values: [
      {
        signature: 'Independent = 0'
      },
      {
        signature: 'XY = 1'
      },
      {
        signature: 'YZ = 2'
      },
      {
        signature: 'ZX = 3'
      },
      {
        signature: 'XYZ = 4'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'IDialogService',
    dataType: 4
  },
  {
    namespace: 'Rhino.UI',
    name: 'IHelp',
    dataType: 4,
    summary: 'Implement this class to add help to a modeless UI panel.'
  },
  {
    namespace: 'Rhino.UI',
    name: 'ILocalizationService',
    dataType: 4
  },
  {
    namespace: 'Rhino.UI',
    name: 'IPanel',
    dataType: 4
  },
  {
    namespace: 'Rhino.UI',
    name: 'IPanelsService',
    dataType: 4,
    summary: `For internal use, the IPanels service is implemented in RhinoWindows
     or RhinoMac as appropriate and handles the communication with core
     Rhino`
  },
  {
    namespace: 'Rhino.UI',
    name: 'IRhinoUiDialogService',
    dataType: 4,
    summary: 'Used by Rhino.UI.Dialogs to access generic Eto dialogs from Rhino Common'
  },
  {
    namespace: 'Rhino.UI',
    name: 'IStackedDialogPageService',
    dataType: 4,
    summary: `For internal use, the IStackedDialogPageService service is implemented in
   RhinoWindows or RhinoMac as appropriate and handles the communication
   with core Rhino`
  },
  {
    namespace: 'Rhino.UI',
    name: 'LOC',
    dataType: 1,
    summary: `Used a placeholded which is used by LocalizationProcessor application to create contextId
   mapped localized strings.`,
    methods: [
      {
        signature: 'static string COMMANDNAME(string english)',
        summary: `Command names that need to be localized should call this function. The COMMANDNAME function doesn't actually
     do anything but return the original string. The LocalizationProcessor application walks
     through the source code of a project and looks for LOC.COMMANDNAME and builds a record for each command
     name for the translators that can be used by developers in a commands overridden Rhino.Commands.Command.LocalName
     which should call Rhino.UI.Localization.LocalizeCommandName(EnglishName)`,
        since: 5,
        parameters: [
          {
            name: 'english',
            summary: '[in] The English string to localize.'
          }
        ]
      },
      {
        signature: 'static LocalizeStringPair CON(string english)',
        summary: `Command option name strings that need to be localized should call this function. The CON function
     doesn't actually do anything but return the original string. The LocalizationProcessor application walks
     through the source code of a project and looks for LOC.CON. The function is then replaced with a
     call to Localization.LocalizeCommandOptionName using a unique context ID.`,
        since: 5,
        parameters: [
          {
            name: 'english',
            summary: '[in] The English string to localize.'
          }
        ],
        returns: 'Returns localized string pair with both the English and local names set to the English value.'
      },
      {
        signature: 'static LocalizeStringPair CON(string english,object assemblyFromObject)',
        summary: `Command option name strings that need to be localized should call this function. The CON function
     doesn't actually do anything but return the original string. The LocalizationProcessor application walks
     through the source code of a project and looks for LOC.CON. The function is then replaced with a
     call to Localization.LocalizeCommandOptionName using a unique context ID.`,
        since: 5,
        parameters: [
          {
            name: 'english',
            summary: '[in] The English string to localize.'
          },
          {
            name: 'assemblyFromObject',
            summary: '[in] The object that identifies the assembly that owns the command option name.'
          }
        ],
        returns: 'Returns localized string pair with both the English and local names set to the English value.'
      },
      {
        signature: 'static LocalizeStringPair COV(string english)',
        summary: `Command option name strings that need to be localized should call this function. The COV function
     doesn't actually do anything but return the original string. The LocalizationProcessor application walks
     through the source code of a project and looks for LOC.COV. The function is then replaced with a
     call to Localization.LocalizeCommandOptionValue using a unique context ID.`,
        since: 5,
        parameters: [
          {
            name: 'english',
            summary: '[in] The English string to localize.'
          }
        ],
        returns: 'Returns localized string pair with both the English and local names set to the English value.'
      },
      {
        signature: 'static LocalizeStringPair COV(string english,object assemblyFromObject)',
        summary: `Command option name strings that need to be localized should call this function. The COV function
     doesn't actually do anything but return the original string. The LocalizationProcessor application walks
     through the source code of a project and looks for LOC.COV. The function is then replaced with a
     call to Localization.LocalizeCommandOptionValue using a unique context ID.`,
        since: 5,
        parameters: [
          {
            name: 'english',
            summary: '[in] The English string to localize.'
          },
          {
            name: 'assemblyFromObject',
            summary: '[in] The object that identifies the assembly that owns the command option value.'
          }
        ],
        returns: 'Returns localized string pair with both the English and local names set to the English value.'
      },
      {
        signature: 'static string STR(string english)',
        summary: `Strings that need to be localized should call this function. The STR function doesn't actually
     do anything but return the original string. The LocalizationProcessor application walks
     through the source code of a project and looks for LOC.STR. The function is then replaced with a
     call to Localization.LocalizeString using a unique context ID.`,
        since: 5,
        parameters: [
          {
            name: 'english',
            summary: '[in] The English string to localize.'
          }
        ]
      },
      {
        signature: 'static string STR(string english,object assemblyOrObject)',
        summary: 'Similar to string.Format(string, object) function.',
        since: 5,
        parameters: [
          {
            name: 'english',
            summary: 'The English name.'
          },
          {
            name: 'assemblyOrObject',
            summary: 'Unused.'
          }
        ],
        returns: 'English name.'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'Localization',
    dataType: 1,
    properties: [
      {
        signature: 'static int CurrentLanguageId',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static bool RunningAsEnglish',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static string FormatArea(double area,UnitSystem units,DimensionStyle dimStyle,bool alternate)',
        summary: 'Format an Area string from a number',
        since: 7
      },
      {
        signature: 'static string FormatDistanceAndTolerance(double distance,UnitSystem units,DimensionStyle dimStyle,bool alternate)',
        since: 7,
        parameters: [
          {
            name: 'distance',
            summary: ''
          },
          {
            name: 'units',
            summary: ''
          },
          {
            name: 'dimStyle',
            summary: ''
          },
          {
            name: 'alternate',
            summary: 'primary or alternate'
          }
        ]
      },
      {
        signature: 'static string FormatNumber(double x,UnitSystem units,DistanceDisplayMode mode,int precision,bool appendUnitSystemName)',
        summary: 'Get a string version of a number in a given unit system / display mode.',
        since: 5,
        parameters: [
          {
            name: 'x',
            summary: 'The number to format into a string.'
          },
          {
            name: 'units',
            summary: 'The unit system for the number.'
          },
          {
            name: 'mode',
            summary: 'How the number should be formatted.'
          },
          {
            name: 'precision',
            summary: 'The precision of the number.'
          },
          {
            name: 'appendUnitSystemName',
            summary: 'Adds unit system name to the end of the number.'
          }
        ],
        returns: 'The formatted number.'
      },
      {
        signature: 'static string FormatVolume(double volume,UnitSystem units,DimensionStyle dimStyle,bool alternate)',
        summary: 'Format a Volume string from a number',
        since: 7
      },
      {
        signature: 'static string LocalizeCommandName(string english)',
        summary: 'Commands that need to be localized should call this function.',
        since: 5,
        parameters: [
          {
            name: 'english',
            summary: 'The localized command name.'
          }
        ]
      },
      {
        signature: 'static string LocalizeCommandName(string english,object assemblyOrObject)',
        since: 5
      },
      {
        signature: 'static LocalizeStringPair LocalizeCommandOptionName(string english,int contextId)',
        since: 5
      },
      {
        signature: 'static LocalizeStringPair LocalizeCommandOptionName(string english,object assemblyOrObject,int contextId)',
        since: 5
      },
      {
        signature: 'static LocalizeStringPair LocalizeCommandOptionValue(string english,int contextId)',
        since: 5
      },
      {
        signature: 'static LocalizeStringPair LocalizeCommandOptionValue(string english,object assemblyOrObject,int contextId)',
        since: 5
      },
      {
        signature: 'static string LocalizeDialogItem(object assemblyOrObject,string key,string english)',
        summary: `Look in the dialog item list for the specified key and return the translated
     localized string if the key is found otherwise return the English string.`,
        since: 5.5,
        parameters: [
          {
            name: 'assemblyOrObject',
            summary: 'An assembly or an object from an assembly.'
          },
          {
            name: 'key',
            summary: ''
          },
          {
            name: 'english',
            summary: 'The text in English.'
          }
        ],
        returns: `Look in the dialog item list for the specified key and return the translated
     localized string if the key is found otherwise return the English string.`
      },
      {
        signature: 'static void LocalizeForm(object formOrUserControl)',
        summary: `Look in the dialog item list for the specified key and return the translated
     localized string if the key is found otherwise return the English string.`,
        since: 6
      },
      {
        signature: 'static string LocalizeString(string english,int contextId)',
        summary: `Returns localized version of a given English string. This function should be autogenerated by the
     RmaLDotNetLocalizationProcessor application for every function that uses RMASTR.`,
        since: 5,
        parameters: [
          {
            name: 'english',
            summary: 'The text in English.'
          },
          {
            name: 'contextId',
            summary: 'The context ID.'
          }
        ],
        returns: 'The localized string.'
      },
      {
        signature: 'static string LocalizeString(string english,object assemblyOrObject,int contextId)',
        summary: `Returns localized version of a given English string. This function should be autogenerated by the
     RmaLDotNetLocalizationProcessor application for every function that uses RMASTR.`,
        since: 5,
        parameters: [
          {
            name: 'english',
            summary: 'The text in English.'
          },
          {
            name: 'assemblyOrObject',
            summary: 'An assembly or an object from an assembly.'
          },
          {
            name: 'contextId',
            summary: 'The context ID.'
          }
        ],
        returns: 'The localized string.'
      },
      {
        signature: 'static bool SetLanguageId(int id)',
        summary: `Sets the Id used for Localization in RhinoCommon.  Only useful for when
     using RhinoCommon outside of the Rhino process`,
        since: 5,
        returns: 'True if the language id could be set'
      },
      {
        signature: 'static string UnitSystemName(UnitSystem units,bool capitalize,bool singular,bool abbreviate)',
        summary: 'Gets localized unit system name.  Uses current application locale id.',
        since: 5,
        parameters: [
          {
            name: 'units',
            summary: 'The unit system.'
          },
          {
            name: 'capitalize',
            summary: 'True if the name should be capitalized.'
          },
          {
            name: 'singular',
            summary: 'True if the name is expressed for a singular element.'
          },
          {
            name: 'abbreviate',
            summary: 'True if name should be the abbreviation.'
          }
        ],
        returns: 'The unit system name.'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'LocalizeStringPair',
    dataType: 1,
    summary: 'Pair of strings used for localization.',
    constructors: [
      {
        signature: 'LocalizeStringPair(string english,string local)',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'string English',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Local',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'string ToString()'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ModifierKey',
    dataType: 3,
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'Control = 1'
      },
      {
        signature: 'Shift = 2'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'MouseButton',
    dataType: 3,
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'Left = 1'
      },
      {
        signature: 'Right = 2'
      },
      {
        signature: 'Middle = 4'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'MouseCallback',
    dataType: 1,
    summary: 'Used for intercepting mouse events in the Rhino views.',
    properties: [
      {
        signature: 'bool Enabled',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'MouseCallbackEventArgs',
    dataType: 1,
    baseclass: 'System.ComponentModel.CancelEventArgs',
    properties: [
      {
        signature: 'MouseButtons Button',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool CtrlKeyDown',
        since: 6,
        property: ['get']
      },
      {
        signature: 'MouseButton MouseButton',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool ShiftKeyDown',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RhinoView View',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Point ViewportPoint',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'MouseCursor',
    dataType: 1,
    summary: 'Contains static methods to control the mouse icon.',
    properties: [
      {
        signature: 'static Point2d Location',
        summary: 'Retrieves the position of the mouse cursor, in screen coordinates',
        since: 5.8,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static void SetToolTip(string tooltip)',
        summary: `Sets a cursor tooltip string shown next to the mouse cursor.
     Overrides all cursor tooltip panes.`,
        since: 5,
        parameters: [
          {
            name: 'tooltip',
            summary: 'The text to show.'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ObjectPropertiesPage',
    dataType: 1,
    summary: 'Base class used to add object property user interface panels',
    properties: [
      {
        signature: 'bool AllObjectsMustBeSupported',
        summary: `Returns True when running on Mac which requires only objects of 
     SupportedTypes.  Returns False when running on Windows which only
     requires a single item of SupportedTypes to be selected.
     
     Override if you wish to change the above behavior.`,
        since: 6.7,
        property: ['get']
      },
      {
        signature: 'string EnglishPageTitle',
        summary: 'English string used to describe this page',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Icon Icon',
        summary: `(OBSOLETE - Override PageIcon instead)
     Icon to display in the object properties tab control`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'int Index',
        summary: `The page navigation control adds buttons in the order the pages are 
     processed, override this method and return a sort index to move the button
     to the beginning of the list.  By default this returns -1 which puts the
     button at the end of the list.`,
        property: ['get']
      },
      {
        signature: 'string LocalPageTitle',
        summary: `Localized page description string, returns the EnglishPageTitle by
     default.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'object PageControl',
        summary: `The control that represents this page. Rhino Windows supports classes
     that implement the IWin32Windows interface, are derived from
     System.Windows.FrameworkElement or Eto.Forms.Control.  Mac Rhino
     supports controls that are derived from NSview or Eto.Forms.Control.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'string PageIconEmbeddedResourceString',
        summary: `Resource string for a embedded icon resource in the assembly containing
     the page instance.  If this returns a valid resource and Rhino can
     load the icon the loaed icon will get used directly otherwise;
     the PageIcon method will get called.`,
        since: 6.4,
        property: ['get']
      },
      {
        signature: 'PropertyPageType PageType',
        summary: `Override this and return the page you want to replace a specific object
     properties page.`,
        since: 5.11,
        property: ['get']
      },
      {
        signature: 'RhinoObject[] SelectedObjects',
        summary: 'Return a list of Rhino objects to be processed by this object properties page',
        since: 5.11,
        property: ['get']
      },
      {
        signature: 'ObjectType SupportedTypes',
        summary: 'Override to specify which objects this page supports',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool SupportsSubObjects',
        summary: `If your object properties page supports sub-object selection, you
     should override this method and return true.  This is ignored for view
     pages.  The default implementation returns false.`,
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool AnySelectedObject()',
        summary: 'Return True if any of the selected objects match the given type',
        since: 6
      },
      {
        signature: 'bool AnySelectedObject(bool allMustMatch)',
        summary: 'Return True if any of the selected objects match the given type',
        since: 6.7,
        parameters: [
          {
            name: 'allMustMatch',
            summary: `If True then every selected object must match the object type
     otherwise; only a single object has to be of the specified type`
          }
        ]
      },
      {
        signature: 'T[] GetSelectedObjects()',
        summary: 'Get selected objects of a given type',
        since: 6
      },
      {
        signature: 'RhinoObject[] GetSelectedObjects(ObjectType filter)',
        summary: 'Get selected objects that match a given filter',
        since: 6
      },
      {
        signature: 'void InitializeControls(RhinoObject rhObj)',
        summary: `Called on the active page after the selected objects list has changed
     to notify the page to initialize its content to reflect the new
     object list.`,
        since: 5
      },
      {
        signature: 'void ModifyPage(Action<ObjectPropertiesPageEventArgs> callbackAction)',
        summary: `Call this method when the page is ready to modify the selected objects
     list.  Rhino will suspend UpdatePageNotfictaion, call the passed action
     then restore UpdatePageNotfictaion.`,
        since: 6,
        parameters: [
          {
            name: 'callbackAction',
            summary: 'Called when it is safe to modify objects.'
          }
        ]
      },
      {
        signature: 'bool OnActivate(bool active)',
        summary: 'Called when this page is activated/deactivated.',
        since: 5,
        parameters: [
          {
            name: 'active',
            summary: 'If True then this page is on top otherwise it is about to be hidden.'
          }
        ],
        returns: `If True then the page is hidden and the requested page is not
    activated otherwise will not allow you to change the current page.
    Default returns true.  The return value is currently ignored.`
      },
      {
        signature: 'void OnCreateParent(IntPtr hwndParent)',
        summary: 'Called when the parent container is initially created.',
        since: 5
      },
      {
        signature: 'void OnHelp()',
        summary: `Called when the F1 key or help button is pressed, override to display
     plug-in specific help for this page.`,
        since: 5
      },
      {
        signature: 'void OnSizeParent(int width,int height)',
        summary: `Called when the parent containers client rectangle size has changed and
     the PageControl has been resized.`,
        since: 5
      },
      {
        signature: 'System.Drawing.Icon PageIcon(Size sizeInPixels)',
        summary: `Icon to display in the object properties tab control.  Will not get called
     if PageIconEmbeddedResourceString is overriden and provides a string for a 
     successfully loaded icon resrouce.`,
        since: 6,
        parameters: [
          {
            name: 'sizeInPixels',
            summary: `The requested icon size in pixels, DPI scaling has been applied.  The
     default value is 24 X DPI scale.`
          }
        ]
      },
      {
        signature: 'Commands.Result RunScript(ObjectPropertiesPageEventArgs e)',
        summary: `This method is called when scripting the Rhino Properties command and
     choosing this page.`,
        since: 6,
        parameters: [
          {
            name: 'e',
            summary: 'Provides access to the selected object list and document.'
          }
        ]
      },
      {
        signature: 'Commands.Result RunScript(RhinoDoc doc,RhinoObject[] objectList)',
        summary: `This method is called when scripting the Rhino Properties command and
     choosing this page.`,
        since: 6,
        parameters: [
          {
            name: 'doc',
            summary: 'Active RhinoDoc'
          },
          {
            name: 'objectList',
            summary: 'List of objects selected by the Properties command.'
          }
        ]
      },
      {
        signature: 'bool ShouldDisplay(ObjectPropertiesPageEventArgs e)',
        summary: `Called when the selected objects list changes, return True if the
     object list contains one or more object the page can modify.`,
        since: 6
      },
      {
        signature: 'bool ShouldDisplay(RhinoObject rhObj)',
        summary: `Called when the selected objects list changes, return True if the
     object list contains one or more object the page can modify.`,
        since: 5
      },
      {
        signature: 'void UpdatePage(ObjectPropertiesPageEventArgs e)',
        summary: `Called on the active page after the selected objects list has changed
     to notify the page to initialize its content to reflect the new
     object list.`,
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ObjectPropertiesPageCollection',
    dataType: 1,
    summary: `Passed to Rhino.PlugIns.PlugIn.ObjectPropertiesPages to allow a plug-in
   to add custom ObjectPropertiesPage pages to the Rhino properties panel.`,
    properties: [
      {
        signature: 'RhinoDoc Document',
        summary: 'Document associated with the Rhino properties panel.',
        since: 7,
        property: ['get']
      },
      {
        signature: 'uint DocumentRuntimeSerailNumber',
        summary: 'Document associated with the Rhino properties panel.',
        since: 7,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void Add(ObjectPropertiesPage page)',
        summary: 'Custom page to add',
        since: 7
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ObjectPropertiesPageEventArgs',
    dataType: 1,
    constructors: [
      {
        signature: 'ObjectPropertiesPageEventArgs(ObjectPropertiesPage page)',
        summary: `Used by ObjectPropertiesPage to notify the page when
     updating, modifying or determining if the page should be included
     in the navigation bar`,
        since: 6,
        parameters: [
          {
            name: 'page',
            summary: 'Page sending the message'
          }
        ]
      }
    ],
    properties: [
      {
        signature: 'uint DocRuntimeSerialNumber',
        summary: 'Document containing the objects and views',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RhinoDoc Document',
        summary: 'Document containing the objects and views',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint EventRuntimeSerialNumber',
        summary: 'Gets the runtime serial number.',
        since: 6.14,
        property: ['get']
      },
      {
        signature: 'int ObjectCount',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RhinoObject[] Objects',
        summary: 'Return a list of Rhino objects to be processed by this object properties page',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint ObjectTypes',
        since: 6,
        property: ['get']
      },
      {
        signature: 'ObjectPropertiesPage Page',
        summary: 'The page sending these arguments',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RhinoView View',
        summary: 'Active view',
        since: 6,
        property: ['get']
      },
      {
        signature: 'RhinoViewport Viewport',
        summary: 'Active viewport',
        since: 6,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'T[] GetObjects()',
        summary: 'Get selected objects of a given type',
        since: 6
      },
      {
        signature: 'RhinoObject[] GetObjects(ObjectType filter)',
        summary: 'Get selected objects that match a given filter',
        since: 6
      },
      {
        signature: 'bool IncludesObjectsType()',
        summary: 'Return True if any of the selected objects match the given type',
        since: 6
      },
      {
        signature: 'bool IncludesObjectsType(bool allMustMatch)',
        summary: 'Return True if any of the selected objects match the given type',
        since: 6.7,
        parameters: [
          {
            name: 'allMustMatch',
            summary: `If True then every selected object must match the object type
     otherwise; only a single object has to be of the specified type`
          }
        ]
      },
      {
        signature: 'bool IncludesObjectsType(ObjectType objectTypes)',
        since: 6
      },
      {
        signature: 'bool IncludesObjectsType(ObjectType objectTypes,bool allMustMatch)',
        since: 6.7,
        parameters: [
          {
            name: 'objectTypes',
            summary: ''
          },
          {
            name: 'allMustMatch',
            summary: `If True then every selected object must match the object type
     otherwise; only a single object has to be of the specified type`
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'OpenFileDialog',
    dataType: 1,
    summary: `Similar to the System.Windows.Forms.OpenFileDialog, but with customized
   Rhino user interface.`,
    constructors: [
      {
        signature: 'OpenFileDialog()',
        summary: 'Create a new open file dialog.',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'string DefaultExt',
        summary: 'The default file name extension. The returned string does not include the period.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string FileName',
        summary: 'Gets or sets a string containing the file name selected in the file dialog box.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string[] FileNames',
        summary: 'Gets the names of all of the selected files in the dialog box',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Filter',
        summary: `Gets or sets the current file name filter string, which determines
     the choices that appear in the "Save as file type" or "Files of type"
     box in the dialog box. See System.Windows.Forms.FileDialog for details.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string InitialDirectory',
        summary: 'Gets or sets the initial directory displayed by the file dialog box.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'bool MultiSelect',
        summary: 'Gets or sets a value indicating whether the dialog box allows multiple files to be selected',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Title',
        summary: 'Gets or sets the file dialog box title.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'System.Windows.Forms.DialogResult ShowDialog()',
        since: 5
      },
      {
        signature: 'bool ShowOpenDialog()',
        summary: 'Show the actual dialog to allow the user to select a file.',
        since: 5.1,
        returns: 'True if a file was selected. False if the dialog was cancelled'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'OptionPageButtons',
    dataType: 3,
    summary: 'Standard IRhinoOptionsPageButton',
    values: [
      {
        signature: 'None = 0x00000000',
        summary: 'Don\'t display any of the standard buttons.'
      },
      {
        signature: 'DefaultButton = 0x00000001',
        summary: 'The "Restore Defaults" button located at the bottom of the host.'
      },
      {
        signature: 'ApplyButton   = 0x00000002',
        summary: 'The "Apply" button located at the bottom of the host.'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'OptionsDialogPage',
    dataType: 1,
    baseclass: 'Rhino.UI.StackedDialogPage',
    methods: [
      {
        signature: 'Commands.Result RunScript(RhinoDoc doc,RunMode mode)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'PanelEventArgs',
    dataType: 1,
    summary: 'Panels.Show event arguments',
    baseclass: 'EventArgs',
    constructors: [
      {
        signature: 'PanelEventArgs(Guid panelId,uint documentSerialNumber)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'RhinoDoc Document',
        since: 6,
        property: ['get']
      },
      {
        signature: 'uint DocumentSerialNumber',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Guid PanelId',
        summary: 'Class Id for panel being shown or hidden',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'PanelIds',
    dataType: 1,
    summary: 'Standard Rhino panel Id\'s',
    properties: [
      {
        signature: 'static Guid ContextHelp',
        summary: 'Rhino context sensitive help panel.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Guid Display',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Guid Environment',
        summary: 'Rhino environment panel',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Guid GroundPlane',
        summary: 'Rhino ground plane panel',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Guid Layers',
        summary: 'Rhino Layer panel',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Guid Libraries',
        summary: 'Rhino render properties panel',
        since: 5.9,
        property: ['get']
      },
      {
        signature: 'static Guid LightManager',
        summary: 'Rhino light manager panel',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Guid Materials',
        summary: 'Rhino material browser',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Guid Notes',
        summary: 'Rhino notes panel',
        since: 5.9,
        property: ['get']
      },
      {
        signature: 'static Guid ObjectProperties',
        summary: 'Rhino object properties panel',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Guid Rendering',
        summary: 'Rhino rendering properties panel',
        since: 6,
        property: ['get']
      },
      {
        signature: 'static Guid Sun',
        summary: 'Rhino sun panel',
        since: 5,
        property: ['get']
      },
      {
        signature: 'static Guid Texture',
        summary: 'Rhino texture panel',
        since: 5.3,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'Panels',
    dataType: 1,
    summary: 'Access to Rhino panels and register custom panels',
    properties: [
      {
        signature: 'static string EtoPanelStyleName',
        summary: `Style applied to Eto controls hosted by the Rhino.UI.Panels and
       Rhino.UI.ObjectProperties systems.`,
        since: 6.15,
        property: ['get']
      },
      {
        signature: 'static Size IconSize',
        summary: 'Gets the panel icon size in logical units.',
        since: 6.12,
        property: ['get']
      },
      {
        signature: 'static Size ScaledIconSize',
        summary: 'Gets the panel icon size in pixels with DPI scaling applied.',
        since: 6.12,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static void ChangePanelIcon(Type panelType,Icon icon)',
        summary: 'Update the icon used for a panel tab.',
        since: 6,
        parameters: [
          {
            name: 'panelType',
            summary: ''
          },
          {
            name: 'icon',
            summary: 'New icon to use'
          }
        ]
      },
      {
        signature: 'static void ClosePanel(Guid panelId)',
        summary: `Will close or hide the specified panel type, in Windows Rhino, if it
       is the only visible tab the tab dock bar will be closed as well.  In
       Mac Rhino it will always close the modeless dialog hosting the panel.`,
        since: 5,
        parameters: [
          {
            name: 'panelId',
            summary: 'Class type Id of the panel to close.'
          }
        ]
      },
      {
        signature: 'static void ClosePanel(Type panelType)',
        summary: `Will close or hide the specified panel type, in Windows Rhino, if it
       is the only visible tab the tab dock bar will be closed as well.  In
       Mac Rhino it will always close the modeless dialog hosting the panel.`,
        since: 5,
        parameters: [
          {
            name: 'panelType',
            summary: 'Class type of the panel to close.'
          }
        ]
      },
      {
        signature: 'static bool FloatPanel(Guid panelTypeId,FloatPanelMode mode)',
        summary: `Mac support:
         Display the specified panel in a floating window on Mac, the floating
         window will only contain the specified panel.
       
       Windows support:
         On Windows this will show or hide the floating continer containing the
         specified panel.  If the tab is docked with other tabs it will be
         floated in a new container.`,
        since: 6.2,
        parameters: [
          {
            name: 'panelTypeId',
            summary: 'Guid for the panel type to show/hide.'
          },
          {
            name: 'mode',
            summary: 'Show, hide or toggle the visibility state of the specified panel'
          }
        ],
        returns: 'Return true if the panel visibility state was changed, false otherwise.'
      },
      {
        signature: 'static bool FloatPanel(Type panelType,FloatPanelMode mode)',
        summary: `Mac support:
         Display the specified panel in a floating window on Mac, the floating
         window will only contain the specified panel.
       
       Windows support:
         On Windows this will show or hide the floating continer containing the
         specified panel.  If the tab is docked with other tabs it will be
         floated in a new container.`,
        since: 6.2,
        parameters: [
          {
            name: 'panelType',
            summary: 'Panel type to show/hide.'
          },
          {
            name: 'mode',
            summary: 'Show, hide or toggle the visibility state of the specified panel'
          }
        ],
        returns: 'Return true if the panel visibility state was changed, false otherwise.'
      },
      {
        signature: 'static Guid[] GetOpenPanelIds()',
        summary: `Get a list of the currently open panel tabs in Windows Rhino, on Mac
       Rhino it will be a list of the currently visible modeless panel
       dialogs.`,
        since: 5,
        returns: `Returns an array of panel class Id's for the currently open panels,
       if there are no open panels it will be an empty array.`
      },
      {
        signature: 'static T GetPanel()',
        summary: 'Return an instance of a .Net panel',
        since: 6
      },
      {
        signature: 'static object GetPanel(Guid panelId)',
        summary: `Will return an instance of a .Net panel if the panel has been
       displayed at least once.  Panel instances are not created until a
       panel is displayed.`,
        since: 5,
        parameters: [
          {
            name: 'panelId',
            summary: 'Class Id of the panel to search for.'
          }
        ],
        returns: `Returns the one and only instance of a panel if it has been properly
       registered and displayed at least once.  If the panel has never been
       displayed then None will be returned even if the panel is properly
       registered.`
      },
      {
        signature: 'static object GetPanel(Guid panelId,RhinoDoc rhinoDoc)',
        summary: `Will return an instance of a .Net panel if the panel has been
       displayed at least once.  Panel instances are not created until a
       panel is displayed.`,
        since: 6,
        parameters: [
          {
            name: 'panelId',
            summary: 'Class Id of the panel to search for.'
          },
          {
            name: 'rhinoDoc',
            summary: 'Runtime document Id associated with the requested panel.'
          }
        ],
        returns: `Returns the one and only instance of a panel if it has been properly
       registered and displayed at least once.  If the panel has never been
       displayed then None will be returned even if the panel is properly
       registered.`
      },
      {
        signature: 'static object GetPanel(Guid panelId,uint documentSerialNumber)',
        summary: `Will return an instance of a .Net panel if the panel has been
       displayed at least once.  Panel instances are not created until a
       panel is displayed.`,
        since: 6,
        parameters: [
          {
            name: 'panelId',
            summary: 'Class Id of the panel to search for.'
          },
          {
            name: 'documentSerialNumber',
            summary: 'Runtime document Id associated with the requested panel.'
          }
        ],
        returns: `Returns the one and only instance of a panel if it has been properly
       registered and displayed at least once.  If the panel has never been
       displayed then None will be returned even if the panel is properly
       registered.`
      },
      {
        signature: 'static T GetPanel(RhinoDoc rhinoDoc)',
        summary: 'Return an instance of a .Net panel',
        since: 6,
        parameters: [
          {
            name: 'rhinoDoc',
            summary: 'Runtime document Id associated with the requested panel.'
          }
        ]
      },
      {
        signature: 'static T GetPanel(uint documentSerialNumber)',
        summary: 'Return an instance of a .Net panel',
        since: 6,
        parameters: [
          {
            name: 'documentSerialNumber',
            summary: 'Runtime document Id associated with the requested panel.'
          }
        ]
      },
      {
        signature: 'static object [] GetPanels(Guid panelId,RhinoDoc doc)',
        summary: 'Gets the panels.',
        since: 6.3,
        parameters: [
          {
            name: 'panelId',
            summary: 'Panel identifier.'
          },
          {
            name: 'doc',
            summary: 'Document.'
          }
        ],
        returns: 'The panels.'
      },
      {
        signature: 'static object[] GetPanels(Guid panelId,uint documentRuntimeSerialNumber)',
        summary: 'Gets the panels.',
        since: 6.3,
        parameters: [
          {
            name: 'panelId',
            summary: 'Panel identifier.'
          },
          {
            name: 'documentRuntimeSerialNumber',
            summary: 'Document runtime serial number.'
          }
        ],
        returns: 'The panels.'
      },
      {
        signature: 'static T[] GetPanels(RhinoDoc doc)',
        since: 6.3
      },
      {
        signature: 'static T [] GetPanels(uint documentRuntimeSerialNumber)',
        summary: 'Gets the panels.',
        since: 6.3,
        parameters: [
          {
            name: 'documentRuntimeSerialNumber',
            summary: 'Document runtime serial number.'
          }
        ],
        returns: 'The panels.'
      },
      {
        signature: 'static bool IsHiding(ShowPanelReason reason)',
        summary: 'Check to see if reason is equal to any of the show events',
        since: 6
      },
      {
        signature: 'static bool IsPanelVisible(Guid panelId)',
        summary: `Check to see if a panel is currently visible, on Windows this means
       you can see the tab, it does not necessarily mean it is the current
       tab.`,
        since: 5,
        parameters: [
          {
            name: 'panelId',
            summary: 'Class Id for the panel to check.'
          }
        ],
        returns: 'Returns True if the tab is visible otherwise it returns false.'
      },
      {
        signature: 'static bool IsPanelVisible(Guid panelId,bool isSelectedTab)',
        summary: `Check to see if a panel is currently visible, if isSelectedTab
       is True then the tab must be the active tab as well.`,
        since: 6,
        parameters: [
          {
            name: 'panelId',
            summary: 'Class Id for the panel to check.'
          },
          {
            name: 'isSelectedTab',
            summary: `This paramater is ignored on Mac.
       
       If Windows and True the panel must be visible in a container and
       if it is a tabbed container it must be the active tab to be true.`
          }
        ],
        returns: `On Windows:
         The return value is demendant on the isSelectedTab value.  If
         isSelectedTab is True then the panel must be included in a
         visible tabbed container and must also be the active tab to be
         true.  If isSelectedTab is False then the panel only has to be 
         included in a visible tabbed container to be true.
       On Mac:
         isSelected is ignored and True is returned if the panel appears
         in any inspector panel.`
      },
      {
        signature: 'static bool IsPanelVisible(Type panelType)',
        summary: `Check to see if a panel is currently visible, on Windows this means
       you can see the tab, it does not necessarily mean it is the current
       tab.`,
        since: 5,
        parameters: [
          {
            name: 'panelType',
            summary: 'Type of panel to check for, this type must include a GUID attribute.'
          }
        ],
        returns: `Returns True if panelType is non None and the tab is visible otherwise
       it returns false.`
      },
      {
        signature: 'static bool IsPanelVisible(Type panelType,bool isSelectedTab)',
        summary: `Check to see if a panel is currently visible, if isSelectedTab
       is True then the tab must be the active tab as well.`,
        since: 6,
        parameters: [
          {
            name: 'panelType',
            summary: 'Type of panel to check for, this type must include a GUID attribute.'
          },
          {
            name: 'isSelectedTab',
            summary: `This paramater is ignored on Mac.
       
       If Windows and True the panel must be visible in a container and
       if it is a tabbed container it must be the active tab to be true.`
          }
        ],
        returns: `On Windows:
         The return value is demendant on the isSelectedTab value.  If
         isSelectedTab is True then the panel must be included in a
         visible tabbed container and must also be the active tab to be
         true.  If isSelectedTab is False then the panel only has to be 
         included in a visible tabbed container to be true.
       On Mac:
         isSelected is ignored and True is returned if the panel appears
         in any inspector panel.`
      },
      {
        signature: 'static bool IsShowing(ShowPanelReason reason)',
        summary: 'Check to see if reason is equal to any of the hide events',
        since: 6
      },
      {
        signature: 'static void OnClosePanel(Guid panelId,uint documentSerialNumber)',
        summary: 'Call this method to raise the Closed event',
        since: 6,
        parameters: [
          {
            name: 'panelId',
            summary: 'Panel identifier.'
          },
          {
            name: 'documentSerialNumber',
            summary: 'The document associated with the closed panel.'
          }
        ]
      },
      {
        signature: 'static void OnShowPanel(Guid panelId,uint documentSerialNumber,bool show)',
        summary: 'Call this method to raise the Show event',
        since: 6,
        parameters: [
          {
            name: 'panelId',
            summary: ''
          },
          {
            name: 'documentSerialNumber',
            summary: 'The document associated with the shown/hidden panel.'
          },
          {
            name: 'show',
            summary: ''
          }
        ]
      },
      {
        signature: 'static void OpenPanel(Guid panelId)',
        summary: `Open the specified panel in its current or default location and if it
       is in a dock bar containing more than one tab, make it the current tab.`,
        since: 5,
        parameters: [
          {
            name: 'panelId',
            summary: 'Class type Id for the panel to open.'
          }
        ]
      },
      {
        signature: 'static void OpenPanel(Guid panelId,bool makeSelectedPanel)',
        summary: `Open the specified panel in its current or default location and if it
       is in a dock bar containing more than one tab, make it the current tab.`,
        since: 6,
        parameters: [
          {
            name: 'panelId',
            summary: 'Class type Id for the panel to open.'
          },
          {
            name: 'makeSelectedPanel',
            summary: `If True then the panel is set as the active tab after opening it
       otherwise; the panel is opened but not set as the active tab.`
          }
        ]
      },
      {
        signature: 'static Guid OpenPanel(Guid dockBarId,Guid panelId)',
        summary: `In Mac Rhino this will just call the version of OpenPanel that takes
       a class type Id.  In Windows Rhino this will look for a dock bar with
       the specified Id and open or move the specified panel to that dock
       bar.`,
        since: 5.12,
        parameters: [
          {
            name: 'dockBarId',
            summary: 'Id of the dock bar hosting one or more panels.'
          },
          {
            name: 'panelId',
            summary: 'Class type Id for the panel to open.'
          }
        ],
        returns: 'Returns True if the'
      },
      {
        signature: 'static Guid OpenPanel(Guid dockBarId,Guid panelId,bool makeSelectedPanel)',
        summary: `In Mac Rhino this will just call the version of OpenPanel that takes
       a class type Id.  In Windows Rhino this will look for a dock bar with
       the specified Id and open or move the specified panel to that dock
       bar.`,
        since: 6,
        parameters: [
          {
            name: 'dockBarId',
            summary: 'Id of the dock bar hosting one or more panels.'
          },
          {
            name: 'panelId',
            summary: 'Class type Id for the panel to open.'
          },
          {
            name: 'makeSelectedPanel',
            summary: `If True then the panel is set as the active tab after opening it
       otherwise; the panel is opened but not set as the active tab.`
          }
        ],
        returns: 'Returns True if the'
      },
      {
        signature: 'static Guid OpenPanel(Guid dockBarId,Type panelType)',
        summary: `In Mac Rhino this will just call the version of OpenPanel that takes
       a class type Id.  In Windows Rhino this will look for a dock bar with
       the specified Id and open or move the specified panel to that dock
       bar.`,
        since: 5.12,
        parameters: [
          {
            name: 'dockBarId',
            summary: 'Id of the dock bar hosting one or more panels.'
          },
          {
            name: 'panelType',
            summary: 'Class type for the panel to open.'
          }
        ],
        returns: 'Returns True if the'
      },
      {
        signature: 'static Guid OpenPanel(Guid dockBarId,Type panelType,bool makeSelectedPanel)',
        summary: `In Mac Rhino this will just call the version of OpenPanel that takes
       a class type Id.  In Windows Rhino this will look for a dock bar with
       the specified Id and open or move the specified panel to that dock
       bar.`,
        since: 6,
        parameters: [
          {
            name: 'dockBarId',
            summary: 'Id of the dock bar hosting one or more panels.'
          },
          {
            name: 'panelType',
            summary: 'Class type for the panel to open.'
          },
          {
            name: 'makeSelectedPanel',
            summary: `If True then the panel is set as the active tab after opening it
       otherwise; the panel is opened but not set as the active tab.`
          }
        ],
        returns: 'Returns True if the'
      },
      {
        signature: 'static void OpenPanel(Type panelType)',
        summary: `Open the specified panel in its current or default location and if it
       is in a dock bar containing more than one tab, make it the current tab.`,
        since: 5,
        parameters: [
          {
            name: 'panelType',
            summary: 'Class type of the panel to open.'
          }
        ]
      },
      {
        signature: 'static void OpenPanel(Type panelType,bool makeSelectedPanel)',
        summary: `Open the specified panel in its current or default location and if it
       is in a dock bar containing more than one tab, make it the current tab.`,
        since: 6,
        parameters: [
          {
            name: 'panelType',
            summary: 'Class type of the panel to open.'
          },
          {
            name: 'makeSelectedPanel',
            summary: `If True then the panel is set as the active tab after opening it
       otherwise; the panel is opened but not set as the active tab.`
          }
        ]
      },
      {
        signature: 'static bool OpenPanelAsSibling(Guid panelId,Guid siblingPanelId)',
        summary: `In Mac Rhino this will currently just call OpenPanel, in Windows Rhino
       this will look for a dock bar which contains the sibling panel and add
       this panel to that dock bar as necessary, if the panel was in another
       dock bar it will be moved to this dock bar.`,
        since: 5,
        parameters: [
          {
            name: 'panelId',
            summary: 'The class Id of the panel type to open.'
          },
          {
            name: 'siblingPanelId',
            summary: 'The class Id of the sibling panel.'
          }
        ],
        returns: 'Returns True if the panel was successfully opened.'
      },
      {
        signature: 'static bool OpenPanelAsSibling(Guid panelId,Guid siblingPanelId,bool makeSelectedPanel)',
        summary: `In Mac Rhino this will currently just call OpenPanel, in Windows Rhino
       this will look for a dock bar which contains the sibling panel and add
       this panel to that dock bar as necessary, if the panel was in another
       dock bar it will be moved to this dock bar.`,
        since: 6,
        parameters: [
          {
            name: 'panelId',
            summary: 'The class Id of the panel type to open.'
          },
          {
            name: 'siblingPanelId',
            summary: 'The class Id of the sibling panel.'
          },
          {
            name: 'makeSelectedPanel',
            summary: `If True then the panel is set as the active tab after opening it
       otherwise; the panel is opened but not set as the active tab.`
          }
        ],
        returns: 'Returns True if the panel was successfully opened.'
      },
      {
        signature: 'static Guid PanelDockBar(Guid panelId)',
        summary: `Will always return Guid.Emty in Mac Rhino.  In Windows Rhino it will
       look for the dock bar which contains the specified panel class Id and
       return the dock bar Id.`,
        since: 5.12,
        parameters: [
          {
            name: 'panelId',
            summary: 'Panel class Id for of the panel to look for.'
          }
        ],
        returns: `Always returns Guid.Empty on Mac Rhino.  On Windows Rhino it will
       return the Id for the dock bar which host the specified panel or 
       Guid.Empty if the panel is not currently visible.`
      },
      {
        signature: 'static Guid PanelDockBar(Type panelType)',
        summary: `Will always return Guid.Emty in Mac Rhino.  In Windows Rhino it will
       look for the dock bar which contains the specified panel class Id and
       return the dock bar Id.`,
        since: 5.12,
        parameters: [
          {
            name: 'panelType',
            summary: 'Panel class for of the panel to look for.'
          }
        ],
        returns: `Always returns Guid.Empty on Mac Rhino.  On Windows Rhino it will
       return the Id for the dock bar which host the specified panel or 
       Guid.Empty if the panel is not currently visible.`
      },
      {
        signature: 'static Guid[] PanelDockBars(Guid panelId)',
        summary: `Will always return a empty array in Mac Rhino.  In Windows Rhino it will
       look for any panel dock bars that contain the specified panel class Id and
       return the dock bar Id's.`,
        since: 6.1,
        parameters: [
          {
            name: 'panelId',
            summary: 'Panel class Id for of the panel to look for.'
          }
        ],
        returns: `Always returns Guid.Empty on Mac Rhino.  On Windows Rhino it will
       return the Id for the dock bar which host the specified panel or 
       Guid.Empty if the panel is not currently visible.`
      },
      {
        signature: 'static void RegisterPanel(PlugIn plugin,Type panelType,string caption,Icon icon)',
        summary: `You typically register your panel class in your plug-in's OnLoad
       function.  This will register your custom call with Rhino, Rhino will
       create an instance of your class the first time your panel is created
       and embed this instance of your class in a panel container.`,
        since: 5,
        parameters: [
          {
            name: 'plugin',
            summary: 'Plug-in this panel is associated with'
          },
          {
            name: 'panelType',
            summary: `Class type to construct when a panel is shown.  If your class is
       derived from Eto.Forms.Control it will work on both the Mac and
       Windows version of Rhino.  In addition Windows Rhino will support any
       class types that implement the IWin32Window interface or that are
       derived from System.Windows.FrameworkElement.  Mac Rhino will also
       support classes that are derived from NsView.  In addition to the
       type requirements the class must have a public constructor with no
       parameters or a constructor with a single uint that represents the 
       document serial number and and have a GuidAttribute applied with a
       unique Id.  n Windows there is only one panel created which gets
       recycled for each new document.  On the Mac a panel will be created
       for each open document and destroyed when the document closes.  In
       certain situations in Mac Rhino a a panel may get created and
       destroyed multiple times when opening/closing a panel while editing a
       document.`
          },
          {
            name: 'caption',
            summary: `Displays in the panel tab on Windows or at the top of the modeless
       window on Mac.`
          },
          {
            name: 'icon',
            summary: `Currently only used in Windows, use a 32bit depth icon in order to
       get proper transparency.`
          }
        ]
      },
      {
        signature: 'static void RegisterPanel(PlugIn plugIn,Type type,string caption,Icon icon,PanelType panelType)',
        summary: `Call once to register a panel type which will get dynamically created
       and embedded in a Rhino docking/floating location.`,
        since: 6.1,
        parameters: [
          {
            name: 'plugIn',
            summary: 'Plug-in restringing the panel'
          },
          {
            name: 'type',
            summary: 'Type of the control object to be displayed in the panel'
          },
          {
            name: 'caption',
            summary: `Panel caption also used as a tool-tip.  On Windows the panel may be
       displayed using the icon, caption or both.  On Mac the icon will be
       used and the caption will be the tool-tip.`
          },
          {
            name: 'icon',
            summary: `The panel icon.  On Windows the panel may be displayed using the icon,
       caption or both.  On Mac the icon will be used and the caption will be
       the tool-tip.`
          },
          {
            name: 'panelType',
            summary: 'See PanelType'
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'Panels.FloatPanelMode',
    dataType: 3,
    summary: `Used by the FloatPanel method to detemine if the floating panel
       should be shown or hidden.`,
    values: [
      {
        signature: 'Show',
        summary: 'Show the floating panel'
      },
      {
        signature: 'Hide',
        summary: 'Hide the floating panel'
      },
      {
        signature: 'Toggle',
        summary: 'Toggle the visibility state'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'PanelType',
    dataType: 3,
    summary: 'Panel type',
    values: [
      {
        signature: 'PerDoc',
        summary: 'Default panel type, creates a panel instance per document'
      },
      {
        signature: 'System',
        summary: `A System panel may appear in one or more container but the
     panel will be used for all open documents`
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'PropertyPageType',
    dataType: 3,
    summary: 'IRhinoProperties page type',
    values: [
      {
        signature: 'Material = 0',
        summary: 'Replace the material page with this page; only works for the current render plug - in.'
      },
      {
        signature: 'Light',
        summary: 'Replace the light page with this page; only works for the current render plug-in.'
      },
      {
        signature: 'Custom',
        summary: 'User-defined custom object page.'
      },
      {
        signature: 'ObjectProperties',
        summary: 'For internal use only.'
      },
      {
        signature: 'Dimension',
        summary: 'If page is provided by Rhino and only dimensions are selected, activate this page.'
      },
      {
        signature: 'Leader',
        summary: 'If page is provided by Rhino and leaders are selected, activate this page.'
      },
      {
        signature: 'Text',
        summary: 'If page is provided by Rhino and only text objects are selected, activate this page.'
      },
      {
        signature: 'Hatch',
        summary: 'If page is provided by Rhino and only hatch objects are selected, activate this page.'
      },
      {
        signature: 'Dot',
        summary: 'If page is provided by Rhino and only dot objects are selected, activate this page.'
      },
      {
        signature: 'TextureMapping',
        summary: 'Replace the texture mapping page with this page; only works for the current render plug-in.'
      },
      {
        signature: 'Detail',
        summary: 'If page is provided by Rhino and only detail objects are selected, activate this page.'
      },
      {
        signature: 'ClippingPlane',
        summary: 'If page is provided by Rhino and only clipping plane objects are selected, activate this page.'
      },
      {
        signature: 'NamedView',
        summary: 'If page is provided by Rhino and only named view widget objects are selected, activate this page.'
      },
      {
        signature: 'Decal',
        summary: 'Decals user interface'
      },
      {
        signature: 'View',
        summary: 'Page is a view properties page and uses view properties methods. Does not use object properties methods.'
      },
      {
        signature: 'PageCount',
        summary: 'Reserved, do not use.'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'RhinoGetPlotWidthArgs',
    dataType: 3,
    summary: 'Argument flags passed to methods used to get Rhino plot width lists',
    values: [
      {
        signature: 'NoArgs = 0',
        summary: 'Just get the standard or default width list'
      },
      {
        signature: 'ByLayer = 1',
        summary: 'Include a By Layer option'
      },
      {
        signature: 'ByParent = 2',
        summary: 'Include a By Parent option'
      },
      {
        signature: 'HairLine = 4',
        summary: 'Include a hairline width option'
      },
      {
        signature: 'Default = 8',
        summary: 'Include a default width option'
      },
      {
        signature: 'None = 0x20',
        summary: 'Include a no print option'
      },
      {
        signature: 'All = 0xFFFFFFF',
        summary: 'Include everything'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'RhinoHelp',
    dataType: 1,
    summary: 'Provides access to the built in Rhino help system',
    methods: [
      {
        signature: 'static bool Show(string helpLink)',
        summary: 'Call this method to display standard Rhino help',
        since: 6,
        parameters: [
          {
            name: 'helpLink',
            summary: `Rhino help links are formatted like this:
     http://docs.mcneel.com/rhino/6/help/en-us/index.htm#commands/line.htm
     This parameter would be equal to "#commands/line.htm" in the link
     above.  Rhino will calculate the string up to and including the
     index.html and append this value to the end.`
          }
        ]
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'RhinoPageInterop',
    dataType: 1,
    summary: `For internal use only, provides access to unmanaged core
   Rhino.`,
    methods: [
      {
        signature: 'static IntPtr NewPropertiesPanelPagePointer(ObjectPropertiesPage page,uint rhinoDocRuntimeSn)',
        summary: 'For internal use only, provides access to unmanaged core',
        since: 6
      },
      {
        signature: 'static StackedDialogPage StackedDialogPageFromUnmanagedPointer(IntPtr pointer)',
        summary: 'For internal use only, provides access to unmanaged core',
        since: 6.4
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'RhinoPlotWidthType',
    dataType: 3,
    summary: 'Supported plot width special types',
    values: [
      {
        signature: 'ByLayer',
        summary: 'Plot width from layer'
      },
      {
        signature: 'ByParent',
        summary: 'Plot width from parent object'
      },
      {
        signature: 'Hairline',
        summary: 'System hairline plot width'
      },
      {
        signature: 'Default',
        summary: 'Use default plot width'
      },
      {
        signature: 'None',
        summary: 'Don\'t print'
      },
      {
        signature: 'Varies',
        summary: 'Multiple objects selected with different types/widths'
      },
      {
        signature: 'Width',
        summary: 'Standard or custom width'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'RhinoPlotWidthValue',
    dataType: 3,
    summary: 'Default width values used by UI objects to represent different states',
    values: [
      {
        signature: 'Default  =   0',
        summary: 'Use default plot width'
      },
      {
        signature: 'None     =  -1',
        summary: 'Don\'t print'
      },
      {
        signature: 'ByLayer  = -10',
        summary: 'Plot width from layer'
      },
      {
        signature: 'ByParent = -15',
        summary: 'Plot width from parent object'
      },
      {
        signature: 'Varies   = -20',
        summary: 'Multiple objects selected with different types/widths'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'RuiUpdateUi',
    dataType: 1,
    baseclass: 'EventArgs',
    properties: [
      {
        signature: 'bool Checked',
        summary: 'Set to True to enable menu item or False to check menu item',
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'bool Enabled',
        summary: 'Set to True to enable menu item or False to disable menu item',
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'Guid FileId',
        summary: 'Id of the RUI file that owns this menu item',
        since: 5.11,
        property: ['get']
      },
      {
        signature: 'IntPtr MenuHandle',
        summary: 'Windows menu handle of menu that contains this item',
        since: 5.11,
        property: ['get']
      },
      {
        signature: 'Guid MenuId',
        summary: 'Id of the menu that owns this menu item',
        since: 5.11,
        property: ['get']
      },
      {
        signature: 'int MenuIndex',
        summary: 'Zero based index of item in the Windows menu',
        since: 5.11,
        property: ['get']
      },
      {
        signature: 'Guid MenuItemId',
        summary: 'Id of the menu item that owns this menu item',
        since: 5.11,
        property: ['get']
      },
      {
        signature: 'bool RadioChecked',
        summary: 'Set to True to enable menu item or False to check menu item',
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'string Text',
        summary: 'Menu item text',
        since: 5.11,
        property: ['get', 'set']
      },
      {
        signature: 'uint WindowsMenuItemId',
        summary: 'Windows menu item ID',
        since: 5.11,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'static bool RegisterMenuItem(Guid file,Guid menu,Guid item,UpdateMenuItemEventHandler callBack)',
        summary: 'Register menu item update delegate',
        since: 5.11,
        parameters: [
          {
            name: 'file',
            summary: 'Menu file Id'
          },
          {
            name: 'menu',
            summary: 'Menu Id'
          },
          {
            name: 'item',
            summary: 'Menu item Id'
          },
          {
            name: 'callBack',
            summary: ''
          }
        ],
        returns: 'True if Registered otherwise false'
      },
      {
        signature: 'static bool RegisterMenuItem(string fileId,string menuId,string itemId,UpdateMenuItemEventHandler callBack)',
        summary: 'Register menu item update delegate',
        since: 5.11,
        parameters: [
          {
            name: 'fileId',
            summary: 'Menu file Id'
          },
          {
            name: 'menuId',
            summary: 'Menu Id'
          },
          {
            name: 'itemId',
            summary: 'Menu item Id'
          },
          {
            name: 'callBack',
            summary: ''
          }
        ],
        returns: 'True if Registered otherwise false'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'SaveFileDialog',
    dataType: 1,
    summary: `Similar to the System.Windows.Forms.SaveFileDialog, but with customized
   Rhino user interface.`,
    constructors: [
      {
        signature: 'SaveFileDialog()',
        since: 5
      }
    ],
    properties: [
      {
        signature: 'string DefaultExt',
        summary: 'The default file name extension. The returned string does not include the period.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string FileName',
        summary: 'Gets or sets a string containing the file name selected in the file dialog box.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Filter',
        summary: `Gets or sets the current file name filter string, which determines
     the choices that appear in the "Save as file type" or "Files of type"
     box in the dialog box. See System.Windows.Forms.FileDialog for details.`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string InitialDirectory',
        summary: 'Gets or sets the initial directory displayed by the file dialog box.',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'string Title',
        summary: 'Gets or sets the file dialog box title.',
        since: 5,
        property: ['get', 'set']
      }
    ],
    methods: [
      {
        signature: 'System.Windows.Forms.DialogResult ShowDialog()',
        since: 5
      },
      {
        signature: 'bool ShowSaveDialog()',
        since: 5.1,
        returns: 'True if a file was selected. False if the dialog was cancelled'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ShowMessageButton',
    dataType: 3,
    values: [
      {
        signature: 'OK = 0'
      },
      {
        signature: 'OKCancel = 1'
      },
      {
        signature: 'AbortRetryIgnore = 2'
      },
      {
        signature: 'YesNoCancel = 3'
      },
      {
        signature: 'YesNo = 4'
      },
      {
        signature: 'RetryCancel = 5'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ShowMessageDefaultButton',
    dataType: 3,
    values: [
      {
        signature: 'Button1 = 0'
      },
      {
        signature: 'Button2 = 256'
      },
      {
        signature: 'Button3 = 512'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ShowMessageIcon',
    dataType: 3,
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'Error = 16'
      },
      {
        signature: 'Hand = 16'
      },
      {
        signature: 'Stop = 16'
      },
      {
        signature: 'Question = 32'
      },
      {
        signature: 'Exclamation = 48'
      },
      {
        signature: 'Warning = 48'
      },
      {
        signature: 'Information = 64'
      },
      {
        signature: 'Asterisk = 64'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ShowMessageMode',
    dataType: 3,
    values: [
      {
        signature: 'ApplicationModal = 0'
      },
      {
        signature: 'SystemModal = 4096'
      },
      {
        signature: 'TaskModal = 8192'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ShowMessageOptions',
    dataType: 3,
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'SetForeground = 65536'
      },
      {
        signature: 'DefaultDesktopOnly = 131072'
      },
      {
        signature: 'TopMost = 262144'
      },
      {
        signature: 'RightAlign = 524288'
      },
      {
        signature: 'RtlReading = 1048576'
      },
      {
        signature: 'ServiceNotification = 2097152'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ShowMessageResult',
    dataType: 3,
    values: [
      {
        signature: 'None = 0'
      },
      {
        signature: 'OK = 1'
      },
      {
        signature: 'Cancel = 2'
      },
      {
        signature: 'Abort = 3'
      },
      {
        signature: 'Retry = 4'
      },
      {
        signature: 'Ignore = 5'
      },
      {
        signature: 'Yes = 6'
      },
      {
        signature: 'No = 7'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ShowPanelEventArgs',
    dataType: 1,
    summary: 'Panels.Show event arguments',
    baseclass: 'Rhino.UI.PanelEventArgs',
    constructors: [
      {
        signature: 'ShowPanelEventArgs(Guid panelId,uint documentSerialNumber,bool show)',
        since: 6
      }
    ],
    properties: [
      {
        signature: 'bool Show',
        summary: 'Will be True if showing or False if hiding',
        since: 6,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ShowPanelReason',
    dataType: 3,
    summary: 'OnShowDockbar event type',
    values: [
      {
        signature: 'Show',
        summary: 'Dock bar shown or made visible'
      },
      {
        signature: 'Hide',
        summary: 'Dock bar hidden, no longer visible'
      },
      {
        signature: 'HideOnDeactivate',
        summary: `Dock bar temporarily hidden because the main Rhino application is no
   longer active.`
      },
      {
        signature: 'ShowOnDeactivate',
        summary: `Dock bar that was temporarily hidden when the main Rhino application
   was deactivated is now being shown.`
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'StackedDialogPage',
    dataType: 1,
    summary: 'Base class to inherit from for the addition of stacked dialog pages.',
    properties: [
      {
        signature: 'List<StackedDialogPage> Children',
        summary: 'List of child (sub) pages of this page',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string EnglishPageTitle',
        summary: `English string used when scripting this page and a user prefixes a
     command option with "_"`,
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'IntPtr Handle',
        summary: `When running on Windows return the window handle for the parent of this
     page otherwise; return IntPtr.Zero.`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool HasChildren',
        summary: 'Will be True if this page contains sub pages.',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string LocalPageTitle',
        summary: `Localized page title that will appear on a tab or other page navigation
     control.  This is also uses as a command line option when scripting
     this page.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool Modified',
        summary: `Check to see if the page has been marked as modified or not.  Marking
     the page as modified will cause the Apply button to get enabled if this
     is currently the visible page and the page includes the Apply button.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Color NavigationTextColor',
        summary: `Currently only used by Windows Rhino.  If this is set to True then the
     tree control item text be drawn using this color.  Set the color to
     System.Drawing.Color.Empty to use the default color.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'bool NavigationTextIsBold',
        summary: `Currently only used by Windows Rhino.  If this is set to True then the
     tree control item text will be bold.`,
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'object PageControl',
        summary: `Return the control that represents this page. Rhino Windows supports
     classes that implement the IWin32Windows interface or are derived from
     some form of System.Windows.FrameworkElement or Eto.Forms.Control.  Mac
     Rhino supports controls that are derived from NSview or
     Eto.Forms.Control.`,
        since: 5,
        property: ['get']
      },
      {
        signature: 'Image PageImage',
        summary: `Optionally override to provide a image to display in 
     the Mac Rhino UI`,
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool ShowApplyButton',
        summary: 'Called when this page is activated',
        since: 6,
        property: ['get']
      },
      {
        signature: 'bool ShowDefaultsButton',
        summary: 'Called when this page is activated.',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'void AddChildPage(StackedDialogPage pageToAdd)',
        summary: `Currently only supported on Windows.  Call this method to add a child
     page to a page after the parent dialog has been created.`,
        since: 6
      },
      {
        signature: 'void MakeActivePage()',
        summary: 'Make this page the active, visible page',
        since: 6
      },
      {
        signature: 'bool OnActivate(bool active)',
        summary: 'Called when this page is activated/deactivated.',
        since: 5,
        parameters: [
          {
            name: 'active',
            summary: 'If True then this page is on top otherwise it is about to be hidden.'
          }
        ],
        returns: `If True then the page is hidden and the requested page is not
    activated otherwise will not allow you to change the current page.
    Default returns true`
      },
      {
        signature: 'bool OnApply()',
        summary: 'Called when stacked dialog OK button is pressed.',
        since: 5,
        returns: `If return value is True then the dialog will be closed. A return of False means
     there was an error and dialog remains open so page can be properly updated.`
      },
      {
        signature: 'void OnCancel()',
        summary: 'Called when stacked dialog Cancel button is pressed.',
        since: 5
      },
      {
        signature: 'void OnCreateParent(IntPtr hwndParent)',
        summary: `Called when the parent window has been created on Windows platforms
     only.`,
        since: 5
      },
      {
        signature: 'void OnDefaults()',
        summary: 'Called when stacked dialog Defaults button is pressed (see ShowDefaultsButton).',
        since: 5
      },
      {
        signature: 'void OnHelp()',
        summary: 'Called when the parent dialog requests help for this page.',
        since: 5
      },
      {
        signature: 'void OnSizeParent(int width,int height)',
        summary: 'Called when the parent window has been resized',
        since: 5
      },
      {
        signature: 'void RemovePage()',
        summary: 'Remove this page from the dialog box',
        since: 6
      },
      {
        signature: 'void SetEnglishPageTitle(string newPageTile)',
        summary: `Change the title passed to the constructor and, this will cause
     LocalPageTitle to get called also.`,
        since: 6
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'StatusBar',
    dataType: 1,
    summary: 'Contains static methods to control the application status bar.',
    methods: [
      {
        signature: 'static void ClearMessagePane()',
        summary: 'Removes the message from the message pane.',
        since: 5
      },
      {
        signature: 'static void HideProgressMeter()',
        summary: 'Ends, or hides, Rhino\'s status bar progress meter.',
        since: 5
      },
      {
        signature: 'static void HideProgressMeter(uint docSerialNumber)',
        summary: 'Ends, or hides, Rhino\'s status bar progress meter.',
        since: 6.12,
        parameters: [
          {
            name: 'docSerialNumber',
            summary: 'The document runtime serial number.'
          }
        ]
      },
      {
        signature: 'static void SetDistancePane(double distance)',
        summary: 'Sets the distance pane to a distance value.',
        since: 5,
        parameters: [
          {
            name: 'distance',
            summary: 'The distance value.'
          }
        ]
      },
      {
        signature: 'static void SetMessagePane(string message)',
        summary: 'Sets the message pane to a message.',
        since: 5,
        parameters: [
          {
            name: 'message',
            summary: 'The message value.'
          }
        ]
      },
      {
        signature: 'static void SetNumberPane(double number)',
        summary: 'Sets the number pane to a number value',
        since: 6
      },
      {
        signature: 'static void SetPointPane(Point3d point)',
        summary: 'Sets the point pane to a point value.',
        since: 5,
        parameters: [
          {
            name: 'point',
            summary: 'The point value.'
          }
        ]
      },
      {
        signature: 'static int ShowProgressMeter(int lowerLimit,int upperLimit,string label,bool embedLabel,bool showPercentComplete)',
        summary: 'Starts, or shows, Rhino\'s status bar progress meter.',
        since: 5,
        parameters: [
          {
            name: 'lowerLimit',
            summary: 'The lower limit of the progress meter\'s range.'
          },
          {
            name: 'upperLimit',
            summary: 'The upper limit of the progress meter\'s range.'
          },
          {
            name: 'label',
            summary: 'The short description of the progress (e.g. "Calculating", "Meshing", etc)'
          },
          {
            name: 'embedLabel',
            summary: `If true, then the label will be embeded in the progress meter.
     If false, then the label will appear to the left of the progress meter.`
          },
          {
            name: 'showPercentComplete',
            summary: 'If true, then the percent complete will appear in the progress meter.'
          }
        ],
        returns: `1 - The progress meter was created successfully.
     0 - The progress meter was not created.
     -1 - The progress meter was not created because some other process has already created it.`
      },
      {
        signature: 'static int ShowProgressMeter(uint docSerialNumber,int lowerLimit,int upperLimit,string label,bool embedLabel,bool showPercentComplete)',
        summary: 'Starts, or shows, Rhino\'s status bar progress meter.',
        since: 6.12,
        parameters: [
          {
            name: 'docSerialNumber',
            summary: 'The document runtime serial number.'
          },
          {
            name: 'lowerLimit',
            summary: 'The lower limit of the progress meter\'s range.'
          },
          {
            name: 'upperLimit',
            summary: 'The upper limit of the progress meter\'s range.'
          },
          {
            name: 'label',
            summary: 'The short description of the progress (e.g. "Calculating", "Meshing", etc)'
          },
          {
            name: 'embedLabel',
            summary: `If true, then the label will be embeded in the progress meter.
     If false, then the label will appear to the left of the progress meter.`
          },
          {
            name: 'showPercentComplete',
            summary: 'If true, then the percent complete will appear in the progress meter.'
          }
        ],
        returns: `1 - The progress meter was created successfully.
     0 - The progress meter was not created.
     -1 - The progress meter was not created because some other process has already created it.`
      },
      {
        signature: 'static int UpdateProgressMeter(int position,bool absolute)',
        summary: 'Sets the current position of Rhino\'s status bar progress meter.',
        since: 5,
        parameters: [
          {
            name: 'position',
            summary: `The new value. This can be stated in absolute terms, or relative compared to the current position.
     The interval bounds are specified when you first show the bar.`
          },
          {
            name: 'absolute',
            summary: `If true, then the progress meter is moved to position.
     If false, then the progress meter is moved position from the current position (relative).`
          }
        ],
        returns: 'The previous position if successful.'
      },
      {
        signature: 'static int UpdateProgressMeter(uint docSerialNumber,int position,bool absolute)',
        summary: 'Sets the current position of Rhino\'s status bar progress meter.',
        since: 6.12,
        parameters: [
          {
            name: 'docSerialNumber',
            summary: 'The document runtime serial number.'
          },
          {
            name: 'position',
            summary: `The new value. This can be stated in absolute terms, or relative compared to the current position.
     The interval bounds are specified when you first show the bar.`
          },
          {
            name: 'absolute',
            summary: `If true, then the progress meter is moved to position.
     If false, then the progress meter is moved position from the current position (relative).`
          }
        ],
        returns: 'The previous position if successful.'
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'Toolbar',
    dataType: 1,
    properties: [
      {
        signature: 'static Size BitmapSize',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'static Size TabSize',
        since: 6,
        property: ['get', 'set']
      },
      {
        signature: 'Guid Id',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string Name',
        since: 5,
        property: ['get']
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ToolbarFile',
    dataType: 1,
    properties: [
      {
        signature: 'int GroupCount',
        since: 5,
        property: ['get']
      },
      {
        signature: 'Guid Id',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string Name',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string Path',
        summary: 'Full path to this file on disk',
        since: 5,
        property: ['get']
      },
      {
        signature: 'int ToolbarCount',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'bool Close(bool prompt)',
        since: 5
      },
      {
        signature: 'ToolbarGroup GetGroup(int index)',
        since: 5
      },
      {
        signature: 'ToolbarGroup GetGroup(string name)',
        since: 5
      },
      {
        signature: 'Toolbar GetToolbar(int index)',
        since: 5
      },
      {
        signature: 'bool Save()',
        since: 5
      },
      {
        signature: 'bool SaveAs(string path)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ToolbarFileCollection',
    dataType: 1,
    interfaces: ['IEnumerable<ToolbarFile>'],
    properties: [
      {
        signature: 'static bool MruSidebarIsVisible',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'static bool SidebarIsVisible',
        since: 5,
        property: ['get', 'set']
      },
      {
        signature: 'int Count',
        summary: 'Number of open toolbar files',
        since: 5,
        property: ['get']
      }
    ],
    methods: [
      {
        signature: 'ToolbarFile FindByName(string name,bool ignoreCase)',
        since: 5
      },
      {
        signature: 'ToolbarFile FindByPath(string path)',
        since: 5
      },
      {
        signature: 'IEnumerator<ToolbarFile> GetEnumerator()',
        since: 5
      },
      {
        signature: 'ToolbarFile Open(string path)',
        since: 5
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'ToolbarGroup',
    dataType: 1,
    properties: [
      {
        signature: 'Guid Id',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool IsDocked',
        since: 5,
        property: ['get']
      },
      {
        signature: 'string Name',
        since: 5,
        property: ['get']
      },
      {
        signature: 'bool Visible',
        since: 5,
        property: ['get', 'set']
      }
    ]
  },
  {
    namespace: 'Rhino.UI',
    name: 'WaitCursor',
    dataType: 1,
    interfaces: ['IDisposable'],
    constructors: [
      {
        signature: 'WaitCursor()',
        since: 5.1
      }
    ],
    methods: [
      {
        signature: 'void Clear()',
        since: 5.1
      },
      {
        signature: 'void Dispose()',
        since: 5.1
      },
      {
        signature: 'void Set()',
        since: 5.1
      }
    ]
  },
  {
    namespace: 'Rhino',
    name: 'UnitSystem',
    dataType: 3,
    summary: `ON::LengthUnitSystem identifies a length unit system
   United States customary length units references:
     http://www.nist.gov/pml/wmd/metric/upload/frn-59-5442-1959.pdf
     http://en.wikipedia.org/wiki/United_States_customary_units
     http://en.wikipedia.org/wiki/International_yard_and_pound`,
    values: [
      {
        signature: 'None =  0',
        summary: `ON::LengthUnitSystem::None indicates no length unit system. The scale factor
     when converting between a specified unit system and None is always 1.0.
     ON::LengthUnitSystem::None is used as a unit system for models and
     instance defitions that should be imported or referenced with no
     scaling applied.`
      },
      {
        signature: 'Angstroms = 12',
        summary: '1 angstroms = 1.0e-10 meters'
      },
      {
        signature: 'Nanometers = 13',
        summary: '1 nanometer = 1.0e-9 meters'
      },
      {
        signature: 'Microns =  1',
        summary: '1 micron = 1.0e-6 meters'
      },
      {
        signature: 'Millimeters =  2',
        summary: '1 millimeter = 1.0e-3 meters'
      },
      {
        signature: 'Centimeters =  3',
        summary: '1 centimeter = 1.0e-2 meters'
      },
      {
        signature: 'Decimeters = 14',
        summary: '1 decimeter = 1.0e-1 meters'
      },
      {
        signature: 'Meters =  4',
        summary: 'SI meter length unit'
      },
      {
        signature: 'Dekameters = 15',
        summary: '1 dekameter = 1.0e+1 meters'
      },
      {
        signature: 'Hectometers = 16',
        summary: '1 hectometer = 1.0e+2 meters'
      },
      {
        signature: 'Kilometers =  5',
        summary: '1 kilometer = 1.0e+3 meters'
      },
      {
        signature: 'Megameters = 17',
        summary: '1 megameter = 1.0e+6 meters'
      },
      {
        signature: 'Gigameters = 18',
        summary: '1 gigameter = 1.0e+9 meters'
      },
      {
        signature: 'Microinches =  6',
        summary: '1 microinches = 2.54e-8 meters = 1.0e-6 inches'
      },
      {
        signature: 'Mils =  7',
        summary: '1 mil = 2.54e-5 meters = 0.001 inches'
      },
      {
        signature: 'Inches =  8',
        summary: '1 inch = 0.0254 meters = 1/12 foot'
      },
      {
        signature: 'Feet =  9',
        summary: '1 foot = 0.3048  meters (12 inches)'
      },
      {
        signature: 'Yards = 19',
        summary: '1 foot = 0.3048 meters = 12 inches'
      },
      {
        signature: 'Miles = 10',
        summary: '1 US statute mile = 1609.344 meters = 5280 feet'
      },
      {
        signature: 'PrinterPoints = 20',
        summary: '1 printer point = 1/72 inch'
      },
      {
        signature: 'PrinterPicas = 21',
        summary: '1 printer pica = 1/6 inch'
      },
      {
        signature: 'NauticalMiles = 22',
        summary: `1 nautical mile = 1852 meters
     Approximately 1 minute of arc on a terrestrial great circle.
     Reference: http://en.wikipedia.org/wiki/Nautical_mile`
      },
      {
        signature: 'AstronomicalUnits = 23',
        summary: `1 astronomical unit = 1.4959787e+11 meters
     An astronomical unit (au) is the mean distance from the 
     center of the earth to the center of the sun.
     References:
       http://en.wikipedia.org/wiki/Astronomical_unit (1.4959787e+11 meters)
       http://units.nist.gov/Pubs/SP811/appenB9.htm (1.495979e+11 meters)`
      },
      {
        signature: 'LightYears = 24',
        summary: `1 light year = 9.4607304725808e+15 meters
     A light year is the distance light travels in one Julian year.
        The speed of light is exactly 299792458 meters/second.
        A Julian year is exactly 365.25 * 86400 seconds and is 
        approximately the time it takes for one earth orbit.
     References: 
       http://en.wikipedia.org/wiki/Light_year (9.4607304725808e+15 meters)
       http://units.nist.gov/Pubs/SP811/appenB9.htm (9.46073e+15 meters)`
      },
      {
        signature: 'Parsecs = 25',
        summary: `1 parsec = 3.08567758e+16 meters
     References: 
       http://en.wikipedia.org/wiki/Parsec (3.08567758e+16 meters)
       http://units.nist.gov/Pubs/SP811/appenB9.htm (3.085678e+16)`
      },
      {
        signature: 'CustomUnits = 11',
        summary: `The name of a custom unit and the conversion to meters
     are saved in the ON_UnitSystem class.`
      },
      {
        signature: 'Unset = 255',
        summary: `The ON::LengthUnitSystem::Unset is used to indicate no unit system is set.
     This is a differnt condition from ON::LengthUnitSystem::None.`
      }
    ]
  }
]

export { DataTypes, RhinoCommonApi }
